<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>407</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    407
                    <a href="406.html">prev</a>
                    <a href="408.html">next</a>
                    <a href="407_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_e408d12c730a7397701e361d52cac823c1694111_rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111^1:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111^2:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;09a8d23c2b8c9e6955f6f68bed4a2fe16cc7fbd3:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.rdb.all;
  20 
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.BaseSideInfo;
  23 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  24 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  25 import com.dtstack.flink.sql.util.RowDataComplete;
  26 import com.dtstack.flink.sql.util.RowDataConvert;
  27 import com.google.common.collect.Lists;
  28 import com.google.common.collect.Maps;
  29 import org.apache.calcite.sql.JoinType;
  30 import org.apache.commons.collections.CollectionUtils;
  31 import org.apache.commons.lang3.StringUtils;
  32 import org.apache.flink.api.common.typeinfo.TypeInformation;
  33 import org.apache.flink.configuration.Configuration;
  34 import org.apache.flink.table.dataformat.BaseRow;
  35 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  36 import org.apache.flink.types.Row;
  37 import org.apache.flink.util.Collector;
  38 import org.slf4j.Logger;
  39 import org.slf4j.LoggerFactory;
  40 
  41 import java.sql.*;
  42 import java.time.LocalDateTime;
  43 import java.util.ArrayList;
  44 import java.util.Calendar;
  45 import java.util.List;
  46 import java.util.Map;
  47 import java.util.concurrent.atomic.AtomicReference;
  48 import java.util.stream.Collectors;
  49 
  50 /**
  51  * side operator with cache for all(period reload)
  52  * Date: 2018/11/26
  53  * Company: www.dtstack.com
  54  *
  55  * @author maqi
  56  */
  57 
  58 public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  59 
  60     private static final long serialVersionUID = 2098635140857937718L;
  61 
  62     private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  63 
  64     private static final int CONN_RETRY_NUM = 3;
  65 
  66     private static final int DEFAULT_FETCH_SIZE = 1000;
  67 
  68     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  69 
  70     public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  71         super(sideInfo);
  72     }
  73 
  74     @Override
  75     public void open(Configuration parameters) throws Exception {
  76         super.open(parameters);
  77         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  78         LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  79     }
  80 
  81     @Override
  82     protected void initCache() throws SQLException {
  83         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  84         cacheRef.set(newCache);
  85         loadData(newCache);
  86     }
  87 
  88     @Override
  89     protected void reloadCache() {
  90         //reload cacheRef and replace to old cacheRef
  91         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  92         try {
  93             loadData(newCache);
  94         } catch (SQLException e) {
  95             throw new RuntimeException(e);
  96         }
  97         cacheRef.set(newCache);
  98         LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
  99     }
 100 
 101     @Override
 102     public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {
 103         List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
 104         ArrayList&lt;Object&gt; inputParams = equalValIndex.stream()
 105                 .map(value::getField)
 106                 .filter(object -&gt; null != object)
 107                 .collect(Collectors.toCollection(ArrayList::new));
 108 
 109         if (inputParams.size() != equalValIndex.size() &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 110             Row row = fillData(value, null);
 111             RowDataComplete.collectRow(out, row);
 112             return;
 113         }
 114 
 115         String cacheKey = inputParams.stream()
 116                 .map(Object::toString)
 117                 .collect(Collectors.joining(&quot;_&quot;));
 118 
 119         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 120         if (CollectionUtils.isEmpty(cacheList) &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 121             Row row = fillData(value, null);
 122             RowDataComplete.collectRow(out, row);
 123         } else if (!CollectionUtils.isEmpty(cacheList)) {
<abbr title=" 124             cacheList.stream().forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));"> 124             cacheList.stream().forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value,🔵</abbr>
 125         }
 126     }
 127 
 128 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 129     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 130     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 131         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 134         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 135             // origin value</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 136             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 137             obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(), obj);"> 137             obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(),🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 138             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 139         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 140 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 141         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 142             if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 143                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 144             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 145                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 148         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 149         return row;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 150     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 151 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 152     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 153      * covert flink time attribute.Type information for indicating event or processing time.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 154      * However, it behaves like a regular SQL timestamp but is serialized as Long.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 155      *</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 156      * @param entry</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 157      * @param obj</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 158      * @return</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 159      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 160     protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 161         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 162         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 163             obj = Timestamp.valueOf(((LocalDateTime) obj));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 164         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 165         return obj;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 166     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 167 </span>
 168 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169         if (CollectionUtils.isEmpty(cacheList)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 170             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 171         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 173         cacheList.forEach(one -&gt; out.collect(new CRow(fillData(value.row(), one), value.change())));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 179         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 180 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 181         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182             // origin value</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 184             obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(), obj);"> 184             obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(),🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189             if (cacheInfo == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196         return row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200      * covert flink time attribute.Type information for indicating event or processing time.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201      * However, it behaves like a regular SQL timestamp but is serialized as Long.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203      * @param entry</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204      * @param obj</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205      * @return</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207     protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
 208 =======
 209 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 210     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 211         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 212         Connection connection = null;
 213 
 214         try {
 215             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 216                 try {
<abbr title=" 217                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());"> 217                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPasswo🔵</abbr>
 218                     break;
 219                 } catch (Exception e) {
 220                     if (i == CONN_RETRY_NUM - 1) {
 221                         throw new RuntimeException(&quot;&quot;, e);
 222                     }
 223                     try {
<abbr title=" 224                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 224                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserN🔵</abbr>
 225                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 226                         Thread.sleep(5 * 1000);
 227                     } catch (InterruptedException e1) {
 228                         LOG.error(&quot;&quot;, e1);
 229                     }
 230                 }
 231             }
 232             queryAndFillData(tmpCache, connection);
 233         } catch (Exception e) {
 234             LOG.error(&quot;&quot;, e);
 235             throw new SQLException(e);
 236         } finally {
 237             if (connection != null) {
 238                 connection.close();
 239             }
 240         }
 241     }
 242 
<abbr title=" 243     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 243     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection)🔵</abbr>
 244         //load data from table
 245         String sql = sideInfo.getSqlCondition();
 246         Statement statement = connection.createStatement();
 247         statement.setFetchSize(getFetchSize());
 248         ResultSet resultSet = statement.executeQuery(sql);
 249 
 250         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 251         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 252         while (resultSet.next()) {
 253             Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 254             for (String fieldName : sideFieldNames) {
 255                 Object object = resultSet.getObject(fieldName.trim());
 256                 int fieldIndex = sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());
 257                 object = SwitchUtil.getTarget(object, fields[fieldIndex]);
 258                 oneRow.put(fieldName.trim(), object);
 259             }
 260 
 261             String cacheKey = sideInfo.getEqualFieldList().stream()
 262                     .map(oneRow::get)
 263                     .map(Object::toString)
 264                     .collect(Collectors.joining(&quot;_&quot;));
 265 
 266             tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList())
 267                     .add(oneRow);
 268         }
 269     }
 270 
 271     public int getFetchSize() {
 272         return DEFAULT_FETCH_SIZE;
 273     }
 274 
 275     /**
 276      * get jdbc connection
 277      *
 278      * @param dbURL
 279      * @param userName
 280      * @param password
 281      * @return
 282      */
 283     public abstract Connection getConn(String dbURL, String userName, String password);
 284 
 285 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.rdb.all;
  20 import org.apache.flink.api.common.typeinfo.TypeInformation;
  21 import org.apache.flink.configuration.Configuration;
  22 import org.apache.flink.table.dataformat.BaseRow;
  23 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  24 import org.apache.flink.types.Row;
  25 import org.apache.flink.util.Collector;
  26 
  27 import com.dtstack.flink.sql.side.BaseAllReqRow;
  28 import com.dtstack.flink.sql.side.BaseSideInfo;
  29 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  30 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  31 import com.dtstack.flink.sql.util.RowDataComplete;
  32 import com.dtstack.flink.sql.util.RowDataConvert;
  33 import com.google.common.collect.Lists;
  34 import com.google.common.collect.Maps;
  35 import org.apache.calcite.sql.JoinType;
  36 import org.apache.commons.collections.CollectionUtils;
  37 import org.apache.commons.lang3.StringUtils;
  38 import org.slf4j.Logger;
  39 import org.slf4j.LoggerFactory;
  40 
  41 import java.sql.*;
  42 import java.time.LocalDateTime;
  43 import java.util.ArrayList;
  44 import java.util.List;
  45 import java.util.Map;
  46 import java.util.Calendar;
  47 import java.util.concurrent.atomic.AtomicReference;
  48 import java.util.stream.Collectors;
  49 
  50 /**
  51  * side operator with cache for all(period reload)
  52  * Date: 2018/11/26
  53  * Company: www.dtstack.com
  54  *
  55  * @author maqi
  56  */
  57 
  58 public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  59 
  60     private static final long serialVersionUID = 2098635140857937718L;
  61 
  62     private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  63 
  64     private static final int CONN_RETRY_NUM = 3;
  65 
  66     private static final int DEFAULT_FETCH_SIZE = 1000;
  67 
  68     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  69 
  70     public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  71         super(sideInfo);
  72     }
  73 
  74     @Override
  75     public void open(Configuration parameters) throws Exception {
  76         super.open(parameters);
  77         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  78         LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  79     }
  80 
  81     @Override
  82     protected void initCache() throws SQLException {
  83         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  84         cacheRef.set(newCache);
  85         loadData(newCache);
  86     }
  87 
  88     @Override
  89     protected void reloadCache() {
  90         //reload cacheRef and replace to old cacheRef
  91         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  92         try {
  93             loadData(newCache);
  94         } catch (SQLException e) {
  95             throw new RuntimeException(e);
  96         }
  97         cacheRef.set(newCache);
  98         LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
  99     }
 100 
 101     @Override
 102     public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {
 103         List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
 104         ArrayList&lt;Object&gt; inputParams = equalValIndex.stream()
 105                 .map(value::getField)
 106                 .filter(object -&gt; null != object)
 107                 .collect(Collectors.toCollection(ArrayList::new));
 108 
 109         if (inputParams.size() != equalValIndex.size() &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 110             Row row = fillData(value, null);
 111             RowDataComplete.collectRow(out, row);
 112             return;
 113         }
 114 
 115         String cacheKey = inputParams.stream()
 116                 .map(Object::toString)
 117                 .collect(Collectors.joining(&quot;_&quot;));
 118 
 119         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 120         if (CollectionUtils.isEmpty(cacheList) &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 121             Row row = fillData(value, null);
 122             RowDataComplete.collectRow(out, row);
 123         } else if (!CollectionUtils.isEmpty(cacheList)) {
<abbr title=" 124             cacheList.stream().forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));"> 124             cacheList.stream().forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value,🔵</abbr>
 125         }
 126     }
 127 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 128 protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 129         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 130         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 131             obj = Timestamp.valueOf(((LocalDateTime) obj));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133         return obj;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 134     }</span>
 135 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136 protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 138         if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 139             //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 140             obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 141         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 142         return obj;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 143     }</span>
 144 =======
 145 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 146 
 147 
 148     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 149         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 150         Connection connection = null;
 151 
 152         try {
 153             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 154                 try {
<abbr title=" 155                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());"> 155                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPasswo🔵</abbr>
 156                     break;
 157                 } catch (Exception e) {
 158                     if (i == CONN_RETRY_NUM - 1) {
 159                         throw new RuntimeException(&quot;&quot;, e);
 160                     }
 161                     try {
<abbr title=" 162                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 162                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserN🔵</abbr>
 163                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 164                         Thread.sleep(5 * 1000);
 165                     } catch (InterruptedException e1) {
 166                         LOG.error(&quot;&quot;, e1);
 167                     }
 168                 }
 169             }
 170             queryAndFillData(tmpCache, connection);
 171         } catch (Exception e) {
 172             LOG.error(&quot;&quot;, e);
 173             throw new SQLException(e);
 174         } finally {
 175             if (connection != null) {
 176                 connection.close();
 177             }
 178         }
 179     }
 180 
<abbr title=" 181     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 181     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection)🔵</abbr>
 182         //load data from table
 183         String sql = sideInfo.getSqlCondition();
 184         Statement statement = connection.createStatement();
 185         statement.setFetchSize(getFetchSize());
 186         ResultSet resultSet = statement.executeQuery(sql);
 187 
 188         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 189         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 190         while (resultSet.next()) {
 191             Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 192             for (String fieldName : sideFieldNames) {
 193                 Object object = resultSet.getObject(fieldName.trim());
 194                 int fieldIndex = sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());
 195                 object = SwitchUtil.getTarget(object, fields[fieldIndex]);
 196                 oneRow.put(fieldName.trim(), object);
 197             }
 198 
 199             String cacheKey = sideInfo.getEqualFieldList().stream()
 200                     .map(oneRow::get)
 201                     .map(Object::toString)
 202                     .collect(Collectors.joining(&quot;_&quot;));
 203 
 204             tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList())
 205                     .add(oneRow);
 206         }
 207     }
 208 
 209     public int getFetchSize() {
 210         return DEFAULT_FETCH_SIZE;
 211     }
 212 
 213     /**
 214      * get jdbc connection
 215      *
 216      * @param dbURL
 217      * @param userName
 218      * @param password
 219      * @return
 220      */
 221     public abstract Connection getConn(String dbURL, String userName, String password);
 222 
 223 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.rdb.all;
  19 
  20 import com.dtstack.flink.sql.side.BaseAllReqRow;
  21 import com.dtstack.flink.sql.side.BaseSideInfo;
  22 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  23 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  24 import com.dtstack.flink.sql.util.RowDataComplete;
  25 import com.dtstack.flink.sql.util.RowDataConvert;
  26 import com.google.common.collect.Lists;
  27 import com.google.common.collect.Maps;
  28 import java.sql.*;
  29 import java.time.LocalDateTime;
  30 import java.util.ArrayList;
  31 import java.util.Calendar;
  32 import java.util.List;
  33 import java.util.Map;
  34 import java.util.concurrent.atomic.AtomicReference;
  35 import java.util.stream.Collectors;
  36 import org.apache.calcite.sql.JoinType;
  37 import org.apache.commons.collections.CollectionUtils;
  38 import org.apache.commons.lang3.StringUtils;
  39 import org.apache.flink.api.common.typeinfo.TypeInformation;
  40 import org.apache.flink.configuration.Configuration;
  41 import org.apache.flink.table.dataformat.BaseRow;
  42 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  43 import org.apache.flink.types.Row;
  44 import org.apache.flink.util.Collector;
  45 import org.slf4j.Logger;
  46 import org.slf4j.LoggerFactory;
  47 
  48 
  49 /**
  50  * side operator with cache for all(period reload)
  51  * Date: 2018/11/26
  52  * Company: www.dtstack.com
  53  *
  54  * @author maqi
  55  */
  56 public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  57     private static final long serialVersionUID = 2098635140857937718L;
  58 
  59     private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  60 
  61     private static final int CONN_RETRY_NUM = 3;
  62 
  63     private static final int DEFAULT_FETCH_SIZE = 1000;
  64 
  65     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  66 
  67     public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  68         super(sideInfo);
  69     }
  70 
  71     @Override
  72     public void open(Configuration parameters) throws Exception {
  73         super.open(parameters);
  74         RdbSideTableInfo tableInfo = ((RdbSideTableInfo) (sideInfo.getSideTableInfo()));
  75         LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  76     }
  77 
  78     @Override
  79     protected void initCache() throws SQLException {
  80         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  81         cacheRef.set(newCache);
  82         loadData(newCache);
  83     }
  84 
  85     @Override
  86     protected void reloadCache() {
  87         //reload cacheRef and replace to old cacheRef
  88         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  89         try {
  90             loadData(newCache);
  91         } catch (SQLException e) {
  92             throw new RuntimeException(e);
  93         }
  94         cacheRef.set(newCache);
  95         LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
  96     }
  97 
  98     @Override
  99     public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {
 100         List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
<abbr title=" 101         ArrayList&lt;Object&gt; inputParams = equalValIndex.stream().map(value::getField).filter(( object) -&gt; null != object).collect(Collectors.toCollection(ArrayList::new));"> 101         ArrayList&lt;Object&gt; inputParams = equalValIndex.stream().map(value::getField).filter(( object) -&gt; n🔵</abbr>
 102         if ((inputParams.size() != equalValIndex.size()) &amp;&amp; (sideInfo.getJoinType() == JoinType.LEFT)) {
 103             Row row = fillData(value, null);
 104             RowDataComplete.collectRow(out, row);
 105             return;
 106         }
 107         String cacheKey = inputParams.stream().map(Object::toString).collect(Collectors.joining(&quot;_&quot;));
 108         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 109         if (CollectionUtils.isEmpty(cacheList) &amp;&amp; (sideInfo.getJoinType() == JoinType.LEFT)) {
 110             Row row = fillData(value, null);
 111             RowDataComplete.collectRow(out, row);
 112         } else if (!CollectionUtils.isEmpty(cacheList)) {
<abbr title=" 113             cacheList.stream().forEach(( one) -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));"> 113             cacheList.stream().forEach(( one) -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(val🔵</abbr>
 114         }
 115     }
 116 
 117     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 118         RdbSideTableInfo tableInfo = ((RdbSideTableInfo) (sideInfo.getSideTableInfo()));
 119         Connection connection = null;
 120         try {
 121             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 122                 try {
<abbr title=" 123                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());"> 123                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPasswo🔵</abbr>
 124                     break;
 125                 } catch (java.lang.Exception e) {
 126                     if (i == (CONN_RETRY_NUM - 1)) {
 127                         throw new RuntimeException(&quot;&quot;, e);
 128                     }
 129                     try {
<abbr title=" 130                         String connInfo = ((((&quot;url:&quot; + tableInfo.getUrl()) + &quot;;userName:&quot;) + tableInfo.getUserName()) + &quot;,pwd:&quot;) + tableInfo.getPassword();"> 130                         String connInfo = ((((&quot;url:&quot; + tableInfo.getUrl()) + &quot;;userName:&quot;) + tableInfo.ge🔵</abbr>
 131                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 132                         Thread.sleep(5 * 1000);
 133                     } catch (java.lang.InterruptedException e1) {
 134                         LOG.error(&quot;&quot;, e1);
 135                     }
 136                 }
 137             }
 138             queryAndFillData(tmpCache, connection);
 139         } catch (java.lang.Exception e) {
 140             LOG.error(&quot;&quot;, e);
 141             throw new SQLException(e);
 142         } finally {
 143             if (connection != null) {
 144                 connection.close();
 145             }
 146         }
 147     }
 148 
<abbr title=" 149     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 149     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection)🔵</abbr>
 150         //load data from table
 151         String sql = sideInfo.getSqlCondition();
 152         Statement statement = connection.createStatement();
 153         statement.setFetchSize(getFetchSize());
 154         ResultSet resultSet = statement.executeQuery(sql);
 155         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 156         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 157         while (resultSet.next()) {
 158             Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 159             for (String fieldName : sideFieldNames) {
 160                 Object object = resultSet.getObject(fieldName.trim());
 161                 int fieldIndex = sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());
 162                 object = SwitchUtil.getTarget(object, fields[fieldIndex]);
 163                 oneRow.put(fieldName.trim(), object);
 164             }
<abbr title=" 165             String cacheKey = sideInfo.getEqualFieldList().stream().map(oneRow::get).map(Object::toString).collect(Collectors.joining(&quot;_&quot;));"> 165             String cacheKey = sideInfo.getEqualFieldList().stream().map(oneRow::get).map(Object::toString🔵</abbr>
 166             tmpCache.computeIfAbsent(cacheKey, ( key) -&gt; Lists.newArrayList()).add(oneRow);
 167         }
 168     }
 169 
 170     public int getFetchSize() {
 171         return DEFAULT_FETCH_SIZE;
 172     }
 173 
 174     /**
 175      * get jdbc connection
 176      *
 177      * @param dbURL
 178      * @param userName
 179      * @param password
 180      * @return
 181      */
 182     public abstract Connection getConn(String dbURL, String userName, String password);
 183 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.rdb.all;
  20  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 -import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import org.apache.flink.util.Collector;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 -</span>
  29  import com.dtstack.flink.sql.side.BaseAllReqRow;
  30  import com.dtstack.flink.sql.side.BaseSideInfo;
  31  import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  32  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import com.dtstack.flink.sql.util.RowDataComplete;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import com.dtstack.flink.sql.util.RowDataConvert;</span>
  35  import com.google.common.collect.Lists;
  36  import com.google.common.collect.Maps;
  37  import org.apache.calcite.sql.JoinType;
  38  import org.apache.commons.collections.CollectionUtils;
  39  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  42 +import org.apache.flink.table.dataformat.BaseRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  43 +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import org.apache.flink.util.Collector;</span>
  46  import org.slf4j.Logger;
  47  import org.slf4j.LoggerFactory;
  48  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import java.sql.Connection;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import java.sql.ResultSet;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -import java.sql.SQLException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import java.sql.Statement;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +import java.sql.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +import java.time.LocalDateTime;</span>
  56  import java.util.ArrayList;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import java.util.Calendar;</span>
  58  import java.util.List;
  59  import java.util.Map;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -import java.util.Objects;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  61 -import java.util.Calendar;</span>
  62  import java.util.concurrent.atomic.AtomicReference;
  63  import java.util.stream.Collectors;
  64  
  65  /**
  66   * side operator with cache for all(period reload)
  67   * Date: 2018/11/26
  68   * Company: www.dtstack.com
  69   *
  70   * @author maqi
  71   */
  72  
  73  public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  74  
  75      private static final long serialVersionUID = 2098635140857937718L;
  76  
  77      private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  78  
  79      private static final int CONN_RETRY_NUM = 3;
  80  
  81      private static final int DEFAULT_FETCH_SIZE = 1000;
  82  
  83      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  84  
  85      public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  86          super(sideInfo);
  87      }
  88  
  89      @Override
  90      public void open(Configuration parameters) throws Exception {
  91          super.open(parameters);
  92          RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  93          LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  94      }
  95  
  96      @Override
  97      protected void initCache() throws SQLException {
  98          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  99          cacheRef.set(newCache);
 100          loadData(newCache);
 101      }
 102  
 103      @Override
 104      protected void reloadCache() {
 105          //reload cacheRef and replace to old cacheRef
 106          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 107          try {
 108              loadData(newCache);
 109          } catch (SQLException e) {
 110              throw new RuntimeException(e);
 111          }
 112          cacheRef.set(newCache);
 113          LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
 114      }
 115  
 116      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -    public void flatMap(CRow value, Collector&lt;CRow&gt; out) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +    public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {</span>
 119          List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
 120          ArrayList&lt;Object&gt; inputParams = equalValIndex.stream()
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 121 -                .map(value.row()::getField)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -                .filter(Objects::nonNull)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +                .map(value::getField)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +                .filter(object -&gt; null != object)</span>
 125                  .collect(Collectors.toCollection(ArrayList::new));
 126  
 127          if (inputParams.size() != equalValIndex.size() &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -            out.collect(new CRow(fillData(value.row(), null), value.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +            Row row = fillData(value, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +            RowDataComplete.collectRow(out, row);</span>
 131              return;
 132          }
 133  
 134          String cacheKey = inputParams.stream()
 135                  .map(Object::toString)
 136                  .collect(Collectors.joining(&quot;_&quot;));
 137  
 138          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 139          if (CollectionUtils.isEmpty(cacheList) &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -            out.collect(new CRow(fillData(value.row(), null), value.change()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -        if (CollectionUtils.isEmpty(cacheList)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -        cacheList.forEach(one -&gt; out.collect(new CRow(fillData(value.row(), one), value.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +            Row row = fillData(value, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +            RowDataComplete.collectRow(out, row);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +        } else if (!CollectionUtils.isEmpty(cacheList)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +            cacheList.stream().forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +        }</span>
 154      }
 155  
 156      @Override
 157      public Row fillData(Row input, Object sideInput) {
 158          Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
 159          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 160  
 161          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 162              // origin value
 163              Object obj = input.getField(entry.getValue());
 164              obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(), obj);
 165              row.setField(entry.getKey(), obj);
 166          }
 167  
 168          for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
 169              if (cacheInfo == null) {
 170                  row.setField(entry.getKey(), null);
 171              } else {
 172                  row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 173              }
 174  
 175          }
 176          return row;
 177      }
 178  
 179      /**
 180       * covert flink time attribute.Type information for indicating event or processing time.
 181       * However, it behaves like a regular SQL timestamp but is serialized as Long.
 182       *
 183       * @param entry
 184       * @param obj
 185       * @return
 186       */
 187      protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {
 188          boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -        if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -            //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -            obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +        if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +            obj = Timestamp.valueOf(((LocalDateTime) obj));</span>
 194          }
 195          return obj;
 196      }
 197  
 198      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 199          RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 200          Connection connection = null;
 201  
 202          try {
 203              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 204                  try {
 205                      connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());
 206                      break;
 207                  } catch (Exception e) {
 208                      if (i == CONN_RETRY_NUM - 1) {
 209                          throw new RuntimeException(&quot;&quot;, e);
 210                      }
 211                      try {
<abbr title=" 212                          String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 212                          String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;🔵</abbr>
 213                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 214                          Thread.sleep(5 * 1000);
 215                      } catch (InterruptedException e1) {
 216                          LOG.error(&quot;&quot;, e1);
 217                      }
 218                  }
 219              }
 220              queryAndFillData(tmpCache, connection);
 221          } catch (Exception e) {
 222              LOG.error(&quot;&quot;, e);
 223              throw new SQLException(e);
 224          } finally {
 225              if (connection != null) {
 226                  connection.close();
 227              }
 228          }
 229      }
 230  
<abbr title=" 231      private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 231      private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws S🔵</abbr>
 232          //load data from table
 233          String sql = sideInfo.getSqlCondition();
 234          Statement statement = connection.createStatement();
 235          statement.setFetchSize(getFetchSize());
 236          ResultSet resultSet = statement.executeQuery(sql);
 237  
 238          String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 239          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 240          while (resultSet.next()) {
 241              Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 242              for (String fieldName : sideFieldNames) {
 243                  Object object = resultSet.getObject(fieldName.trim());
 244                  int fieldIndex = sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());
 245                  object = SwitchUtil.getTarget(object, fields[fieldIndex]);
 246                  oneRow.put(fieldName.trim(), object);
 247              }
 248  
 249              String cacheKey = sideInfo.getEqualFieldList().stream()
 250                      .map(oneRow::get)
 251                      .map(Object::toString)
 252                      .collect(Collectors.joining(&quot;_&quot;));
 253  
 254              tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList())
 255                      .add(oneRow);
 256          }
 257      }
 258  
 259      public int getFetchSize() {
 260          return DEFAULT_FETCH_SIZE;
 261      }
 262  
 263      /**
 264       * get jdbc connection
 265       *
 266       * @param dbURL
 267       * @param userName
 268       * @param password
 269       * @return
 270       */
 271      public abstract Connection getConn(String dbURL, String userName, String password);
 272  
 273  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.rdb.all;
  20  
  21  import org.apache.flink.api.common.typeinfo.TypeInformation;
  22  import org.apache.flink.configuration.Configuration;
  23  import org.apache.flink.table.runtime.types.CRow;
  24  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  25  import org.apache.flink.types.Row;
  26  import org.apache.flink.util.Collector;
  27  
  28  
  29  import com.dtstack.flink.sql.side.BaseAllReqRow;
  30  import com.dtstack.flink.sql.side.BaseSideInfo;
  31  import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  32  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;


  33  import com.google.common.collect.Lists;
  34  import com.google.common.collect.Maps;
  35  import org.apache.calcite.sql.JoinType;
  36  import org.apache.commons.collections.CollectionUtils;
  37  import org.apache.commons.lang3.StringUtils;






  38  import org.slf4j.Logger;
  39  import org.slf4j.LoggerFactory;
  40  
  41  import java.sql.Connection;
  42  import java.sql.ResultSet;
  43  import java.sql.SQLException;
  44  import java.sql.Statement;
  45  import java.sql.Timestamp;


  46  import java.util.ArrayList;

  47  import java.util.List;
  48  import java.util.Map;
  49  import java.util.Objects;
  50  import java.util.Calendar;
  51  import java.util.concurrent.atomic.AtomicReference;
  52  import java.util.stream.Collectors;
  53  
  54  /**
  55   * side operator with cache for all(period reload)
  56   * Date: 2018/11/26
  57   * Company: www.dtstack.com
  58   *
  59   * @author maqi
  60   */
  61  
  62  public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  63  
  64      private static final long serialVersionUID = 2098635140857937718L;
  65  
  66      private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  67  
  68      private static final int CONN_RETRY_NUM = 3;
  69  
  70      private static final int DEFAULT_FETCH_SIZE = 1000;
  71  
  72      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  73  
  74      public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  75          super(sideInfo);
  76      }
  77  
  78      @Override
  79      public void open(Configuration parameters) throws Exception {
  80          super.open(parameters);
  81          RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  82          LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  83      }
  84  
  85      @Override
  86      protected void initCache() throws SQLException {
  87          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  88          cacheRef.set(newCache);
  89          loadData(newCache);
  90      }
  91  
  92      @Override
  93      protected void reloadCache() {
  94          //reload cacheRef and replace to old cacheRef
  95          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  96          try {
  97              loadData(newCache);
  98          } catch (SQLException e) {
  99              throw new RuntimeException(e);
 100          }
 101          cacheRef.set(newCache);
 102          LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
 103      }
 104  
 105      @Override
 106      public void flatMap(CRow value, Collector&lt;CRow&gt; out) throws Exception {

 107          List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
 108          ArrayList&lt;Object&gt; inputParams = equalValIndex.stream()
 109                  .map(value.row()::getField)
 110                  .filter(Objects::nonNull)


 111                  .collect(Collectors.toCollection(ArrayList::new));
 112  
 113          if (inputParams.size() != equalValIndex.size() &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 114              out.collect(new CRow(fillData(value.row(), null), value.change()));


 115              return;
 116          }
 117  
 118          String cacheKey = inputParams.stream()
 119                  .map(Object::toString)
 120                  .collect(Collectors.joining(&quot;_&quot;));
 121  
 122          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 123          if (CollectionUtils.isEmpty(cacheList) &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 124              out.collect(new CRow(fillData(value.row(), null), value.change()));
 125              return;
 126          }
 127  
 128          if (CollectionUtils.isEmpty(cacheList)) {
 129              return;
 130          }
 131  
 132          cacheList.forEach(one -&gt; out.collect(new CRow(fillData(value.row(), one), value.change())));





<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -    public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -        Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -        for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -            // origin value</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -            Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -            obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(), obj);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -            row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -        for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -            if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -                row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -                row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -        return row;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -     * covert flink time attribute.Type information for indicating event or processing time.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -     * However, it behaves like a regular SQL timestamp but is serialized as Long.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -     * @param entry</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -     * @param obj</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -     * @return</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -    protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -        boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -        if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -            //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -            obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -        return obj;</span>
 173      }
 174  
 175      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 176          RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 177          Connection connection = null;
 178  
 179          try {
 180              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 181                  try {
 182                      connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());
 183                      break;
 184                  } catch (Exception e) {
 185                      if (i == CONN_RETRY_NUM - 1) {
 186                          throw new RuntimeException(&quot;&quot;, e);
 187                      }
 188                      try {
<abbr title=" 189                          String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 189                          String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;🔵</abbr>
 190                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 191                          Thread.sleep(5 * 1000);
 192                      } catch (InterruptedException e1) {
 193                          LOG.error(&quot;&quot;, e1);
 194                      }
 195                  }
 196              }
 197              queryAndFillData(tmpCache, connection);
 198          } catch (Exception e) {
 199              LOG.error(&quot;&quot;, e);
 200              throw new SQLException(e);
 201          } finally {
 202              if (connection != null) {
 203                  connection.close();
 204              }
 205          }
 206      }
 207  
<abbr title=" 208      private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 208      private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws S🔵</abbr>
 209          //load data from table
 210          String sql = sideInfo.getSqlCondition();
 211          Statement statement = connection.createStatement();
 212          statement.setFetchSize(getFetchSize());
 213          ResultSet resultSet = statement.executeQuery(sql);
 214  
 215          String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 216          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 217          while (resultSet.next()) {
 218              Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 219              for (String fieldName : sideFieldNames) {
 220                  Object object = resultSet.getObject(fieldName.trim());
 221                  int fieldIndex = sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());
 222                  object = SwitchUtil.getTarget(object, fields[fieldIndex]);
 223                  oneRow.put(fieldName.trim(), object);
 224              }
 225  
 226              String cacheKey = sideInfo.getEqualFieldList().stream()
 227                      .map(oneRow::get)
 228                      .map(Object::toString)
 229                      .collect(Collectors.joining(&quot;_&quot;));
 230  
 231              tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList())
 232                      .add(oneRow);
 233          }
 234      }
 235  
 236      public int getFetchSize() {
 237          return DEFAULT_FETCH_SIZE;
 238      }
 239  
 240      /**
 241       * get jdbc connection
 242       *
 243       * @param dbURL
 244       * @param userName
 245       * @param password
 246       * @return
 247       */
 248      public abstract Connection getConn(String dbURL, String userName, String password);
 249  
 250  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            