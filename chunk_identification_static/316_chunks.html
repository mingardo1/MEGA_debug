<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>316 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;package com.automattic.simplenote;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Calendar;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.app.Fragment;\n&#x27;
                           &#x27;import android.content.Context;\n&#x27;
                           &#x27;import android.os.Bundle;\n&#x27;
                           &#x27;import android.os.Handler;\n&#x27;
                           &#x27;import android.text.Editable;\n&#x27;
                           &#x27;import android.text.SpannableString;\n&#x27;
                           &#x27;import android.text.Spanned;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import android.text.TextWatcher;\n&#x27;
                           &#x27;import android.util.Log;\n&#x27;
                           &#x27;import android.view.LayoutInflater;\n&#x27;
                           &#x27;import android.view.View;\n&#x27;
                           &#x27;import android.view.ViewGroup;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.view.inputmethod.InputMethodManager;\n&#x27;
                           &#x27;import android.widget.ArrayAdapter;\n&#x27;
                           &#x27;import android.widget.EditText;\n&#x27;
                           &#x27;import android.widget.LinearLayout;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.widget.MultiAutoCompleteTextView.Tokenizer;\n&#x27;
                           &#x27;import android.widget.ToggleButton;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Note;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Tag;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;\n&#x27;
                           &#x27;import com.simperium.client.Bucket;\n&#x27;
                           &#x27;import com.simperium.client.Bucket.ObjectCursor;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.simperium.client.BucketObjectMissingException;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class NoteEditorFragment extends Fragment &#x27;
                           &#x27;implements TextWatcher, OnTagAddedListener {\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The fragment argument representing the item &#x27;
                           &#x27;ID that this fragment\n&#x27;
                           &#x27;     * represents.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static final String ARG_ITEM_ID = &#x27;
                           &#x27;&quot;item_id&quot;;\n&#x27;
                           &#x27;    private static final int AUTOSAVE_DELAY_MILLIS &#x27;
                           &#x27;= 2000;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The dummy content this fragment is &#x27;
                           &#x27;presenting.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private Note mNote;\n&#x27;
                           &#x27;    private EditText mContentEditText;\n&#x27;
                           &#x27;    private TagsMultiAutoCompleteTextView &#x27;
                           &#x27;mTagView;\n&#x27;
                           &#x27;    private ToggleButton mPinButton;\n&#x27;
                           &#x27;    private boolean mShowNoteTitle;\n&#x27;
                           &#x27;    private Handler mAutoSaveHandler;\n&#x27;
                           &#x27;    private LinearLayout mPlaceholderView;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Mandatory empty constructor for the &#x27;
                           &#x27;fragment manager to instantiate the\n&#x27;
                           &#x27;     * fragment (e.g. upon screen orientation &#x27;
                           &#x27;changes).\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public NoteEditorFragment() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onCreate(Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        super.onCreate(savedInstanceState);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (getArguments() != null &amp;&amp; &#x27;
                           &#x27;getArguments().containsKey(ARG_ITEM_ID)) {\n&#x27;
                           &#x27;            Simplenote application = (Simplenote) &#x27;
                           &#x27;getActivity().getApplication();\n&#x27;
                           &#x27;            Bucket&lt;Note&gt; notesBucket = &#x27;
                           &#x27;application.getNotesBucket();\n&#x27;
                           &#x27;            String key = &#x27;
                           &#x27;getArguments().getString(ARG_ITEM_ID);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                mNote = notesBucket.get(key);\n&#x27;
                           &#x27;            } catch (BucketObjectMissingException &#x27;
                           &#x27;e) {\n&#x27;
                           &#x27;                // TODO: Handle a missing note\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreenLandscape())\n&#x27;
                           &#x27;            mShowNoteTitle = true;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mAutoSaveHandler = new Handler();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public View onCreateView(LayoutInflater &#x27;
                           &#x27;inflater, ViewGroup container, Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        View rootView = &#x27;
                           &#x27;inflater.inflate(R.layout.fragment_note_editor, &#x27;
                           &#x27;container, false);\n&#x27;
                           &#x27;        mContentEditText = ((EditText) &#x27;
                           &#x27;rootView.findViewById(R.id.note_content));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mContentEditText.addTextChangedListener(this);\n&#x27;
                           &#x27;        mTagView = (TagsMultiAutoCompleteTextView) &#x27;
                           &#x27;rootView.findViewById(R.id.tag_view);\n&#x27;
                           &#x27;        mTagView.setTokenizer(new &#x27;
                           &#x27;SpaceTokenizer());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mPinButton = (ToggleButton) &#x27;
                           &#x27;rootView.findViewById(R.id.pinButton);\n&#x27;
                           &#x27;        mPlaceholderView = (LinearLayout) &#x27;
                           &#x27;rootView.findViewById(R.id.placeholder);\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreen())\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\trefreshContent();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn rootView;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onResume() {\n&#x27;
                           &#x27;        super.onResume();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(this);\n&#x27;
                           &#x27;        if (mNote != null &amp;&amp; &#x27;
                           &#x27;mNote.getContent().isEmpty()) {\n&#x27;
                           &#x27;            // Show soft keyboard\n&#x27;
                           &#x27;            mContentEditText.requestFocus();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            InputMethodManager inputMethodManager &#x27;
                           &#x27;= (InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;            if (inputMethodManager != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;inputMethodManager.showSoftInput(mContentEditText, &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onPause() {\n&#x27;
                           &#x27;        saveAndSyncNote();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(null);\n&#x27;
                           &#x27;        // Hide soft keyboard\n&#x27;
                           &#x27;        InputMethodManager inputMethodManager = &#x27;
                           &#x27;(InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;        if (inputMethodManager != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;inputMethodManager.hideSoftInputFromWindow(mContentEditText.getWindowToken(), &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        super.onPause();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setNote(Note note) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // If we have a note already (on a tablet &#x27;
                           &#x27;in landscape), save the note.\n&#x27;
                           &#x27;        if (mNote != null)\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mNote = note;\n&#x27;
                           &#x27;        refreshContent();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void refreshContent() {\n&#x27;
                           &#x27;        if (mNote != null) {\n&#x27;
                           &#x27;            Log.v(&quot;Simplenote&quot;, &quot;refreshing &#x27;
                           &#x27;content&quot;);\n&#x27;
                           &#x27;            // Restore the cursor position if &#x27;
                           &#x27;possible.\n&#x27;
                           &#x27;            int cursorPosition = &#x27;
                           &#x27;newCursorLocation(mNote.getContent(), &#x27;
                           &#x27;mContentEditText.getText().toString(), &#x27;
                           &#x27;mContentEditText.getSelectionEnd());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mContentEditText.setText(mNote.getContent());\n&#x27;
                           &#x27;            if (mContentEditText.hasFocus() &amp;&amp; &#x27;
                           &#x27;cursorPosition != &#x27;
                           &#x27;mContentEditText.getSelectionEnd())\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mContentEditText.setSelection(cursorPosition);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPinButton.setChecked(mNote.isPinned());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            updateTagList();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void updateTagList(){\n&#x27;
                           &quot;        // Populate this note&#x27;s tags in the &quot;
                           &#x27;tagView\n&#x27;
                           &#x27;        mTagView.setChips(mNote.getTagString());\n&#x27;
                           &#x27;        \n&#x27;
                           &#x27;\t\t// Populate tag list\n&#x27;
                           &#x27;        Simplenote simplenote = &#x27;
                           &#x27;(Simplenote)getActivity().getApplication();\n&#x27;
                           &#x27;        Bucket&lt;Tag&gt; tagBucket = &#x27;
                           &#x27;simplenote.getTagsBucket();\n&#x27;
                           &#x27;        ObjectCursor&lt;Tag&gt; tagsCursor = &#x27;
                           &#x27;tagBucket.query().orderByKey().execute();\n&#x27;
                           &#x27;        List&lt;String&gt; allTags = new &#x27;
                           &#x27;ArrayList&lt;String&gt;(tagsCursor.getCount());\n&#x27;
                           &#x27;        while (tagsCursor.moveToNext()) {\n&#x27;
                           &#x27;            Tag tag = tagsCursor.getObject();\n&#x27;
                           &#x27;            if (!mNote.hasTag(tag)) &#x27;
                           &#x27;allTags.add(tag.getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        tagsCursor.close();\n&#x27;
                           &#x27;        ArrayAdapter&lt;String&gt; adapter = new &#x27;
                           &#x27;ArrayAdapter&lt;String&gt;(getActivity(),\n&#x27;
                           &#x27;                &#x27;
                           &#x27;android.R.layout.simple_dropdown_item_1line, &#x27;
                           &#x27;allTags);\n&#x27;
                           &#x27;        mTagView.setAdapter(adapter);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void setActionBarTitle() {\n&#x27;
                           &#x27;        if (mShowNoteTitle) {\n&#x27;
                           &#x27;            if (mNote.getTitle() != null &amp;&amp; &#x27;
                           &#x27;!mNote.getTitle().equals(&quot;&quot;))\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(mNote.getTitle());\n&#x27;
                           &#x27;            else\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(R.string.new_note);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int newCursorLocation(String newText, String &#x27;
                           &#x27;oldText, int cursorLocation) {\n&#x27;
                           &#x27;        // Ported from the iOS app :)\n&#x27;
                           &#x27;        // Cases:\n&#x27;
                           &#x27;        // 0. All text after cursor (and possibly &#x27;
                           &#x27;more) was removed ==&gt; put cursor at end\n&#x27;
                           &#x27;        // 1. Text was added after the cursor ==&gt; &#x27;
                           &#x27;no change\n&#x27;
                           &#x27;        // 2. Text was added before the cursor ==&gt; &#x27;
                           &#x27;location advances\n&#x27;
                           &#x27;        // 3. Text was removed after the cursor &#x27;
                           &#x27;==&gt; no change\n&#x27;
                           &#x27;        // 4. Text was removed before the cursor &#x27;
                           &#x27;==&gt; location retreats\n&#x27;
                           &#x27;        // 5. Text was added/removed on both sides &#x27;
                           &#x27;of the cursor ==&gt; not handled\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int newCursorLocation = cursorLocation;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int deltaLength = newText.length() - &#x27;
                           &#x27;oldText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Case 0\n&#x27;
                           &#x27;        if (newText.length() &lt; cursorLocation)\n&#x27;
                           &#x27;            return newText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        boolean beforeCursorMatches = false;\n&#x27;
                           &#x27;        boolean afterCursorMatches = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            beforeCursorMatches = &#x27;
                           &#x27;oldText.substring(0, &#x27;
                           &#x27;cursorLocation).equals(newText.substring(0, &#x27;
                           &#x27;cursorLocation));\n&#x27;
                           &#x27;            afterCursorMatches = &#x27;
                           &#x27;oldText.substring(cursorLocation, &#x27;
                           &#x27;oldText.length()).equals(newText.substring(cursorLocation &#x27;
                           &#x27;+ deltaLength, newText.length()));\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 2 and 4\n&#x27;
                           &#x27;        if (!beforeCursorMatches &amp;&amp; &#x27;
                           &#x27;afterCursorMatches)\n&#x27;
                           &#x27;            newCursorLocation += deltaLength;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 1, 3 and 5 have no change\n&#x27;
                           &#x27;        return newCursorLocation;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Runnable autoSaveRunnable = new &#x27;
                           &#x27;Runnable() {\n&#x27;
                           &#x27;        @Override\n&#x27;
                           &#x27;        public void run() {\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    };\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTagsChanged(String tagString){\n&#x27;
                           &#x27;        mNote.setTagString(tagString);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;        updateTagList();\n&#x27;
                           &#x27;        mNote.save();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void beforeTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void afterTextChanged(Editable &#x27;
                           &#x27;editable) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // When text changes, start timer that &#x27;
                           &#x27;will fire after AUTOSAVE_DELAY_MILLIS passes\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null) {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.postDelayed(autoSaveRunnable, &#x27;
                           &#x27;AUTOSAVE_DELAY_MILLIS);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void saveAndSyncNote() {\n&#x27;
                           &#x27;        if (mNote == null)\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String content = &#x27;
                           &#x27;mContentEditText.getText().toString();\n&#x27;
                           &#x27;        if (mNote.hasChanges(content, &#x27;
                           &#x27;mPinButton.isChecked())) {\n&#x27;
                           &#x27;            mNote.setContent(content);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setTagString(mTagView.getText().toString());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setPinned(mPinButton.isChecked());\n&#x27;
                           &#x27;            mNote.save();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Log.v(&quot;Simplenote&quot;, &quot;autosaving note&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPlaceholderVisible(boolean &#x27;
                           &#x27;isVisible) {\n&#x27;
                           &#x27;        if (isVisible) {\n&#x27;
                           &#x27;            mNote = null;\n&#x27;
                           &#x27;            mContentEditText.setText(&quot;&quot;);\n&#x27;
                           &#x27;            mTagView.setText(&quot;&quot;);\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.VISIBLE);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // Use spaces in tag autocompletion list\n&#x27;
                           &#x27;    // From &#x27;
                           &#x27;http://stackoverflow.com/questions/3482981/how-to-replace-the-comma-with-a-space-when-i-use-the-multiautocompletetextview\n&#x27;
                           &#x27;    public class SpaceTokenizer implements &#x27;
                           &#x27;Tokenizer {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenStart(CharSequence &#x27;
                           &#x27;text, int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) != &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            while (i &lt; cursor &amp;&amp; text.charAt(i) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i++;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return i;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenEnd(CharSequence text, &#x27;
                           &#x27;int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;            int len = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &lt; len) {\n&#x27;
                           &quot;                if (text.charAt(i) == &#x27; &#x27;) {\n&quot;
                           &#x27;                    return i;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    i++;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return len;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public CharSequence &#x27;
                           &#x27;terminateToken(CharSequence text) {\n&#x27;
                           &#x27;            int i = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &quot;            if (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27; &quot;
                           &quot;&#x27;) {\n&quot;
                           &#x27;                return text;\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                if (text instanceof Spanned) {\n&#x27;
                           &#x27;                    SpannableString sp = new &#x27;
                           &#x27;SpannableString(text + &quot; &quot;);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TextUtils.copySpansFrom((Spanned) text, 0, &#x27;
                           &#x27;text.length(),\n&#x27;
                           &#x27;                            Object.class, sp, 0);\n&#x27;
                           &#x27;                    return sp;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    return text + &quot; &quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;package com.automattic.simplenote;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Calendar;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.app.Fragment;\n&#x27;
                           &#x27;import android.content.Context;\n&#x27;
                           &#x27;import android.os.Bundle;\n&#x27;
                           &#x27;import android.os.Handler;\n&#x27;
                           &#x27;import android.text.Editable;\n&#x27;
                           &#x27;import android.text.SpannableString;\n&#x27;
                           &#x27;import android.text.Spanned;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import android.text.TextWatcher;\n&#x27;
                           &#x27;import android.util.Log;\n&#x27;
                           &#x27;import android.view.LayoutInflater;\n&#x27;
                           &#x27;import android.view.View;\n&#x27;
                           &#x27;import android.view.ViewGroup;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.view.inputmethod.InputMethodManager;\n&#x27;
                           &#x27;import android.widget.ArrayAdapter;\n&#x27;
                           &#x27;import android.widget.EditText;\n&#x27;
                           &#x27;import android.widget.LinearLayout;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.widget.MultiAutoCompleteTextView.Tokenizer;\n&#x27;
                           &#x27;import android.widget.ToggleButton;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Note;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Tag;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;\n&#x27;
                           &#x27;import com.simperium.client.Bucket;\n&#x27;
                           &#x27;import com.simperium.client.Bucket.ObjectCursor;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.simperium.client.BucketObjectMissingException;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class NoteEditorFragment extends Fragment &#x27;
                           &#x27;implements TextWatcher, OnTagAddedListener {\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The fragment argument representing the item &#x27;
                           &#x27;ID that this fragment\n&#x27;
                           &#x27;     * represents.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static final String ARG_ITEM_ID = &#x27;
                           &#x27;&quot;item_id&quot;;\n&#x27;
                           &#x27;    private static final int AUTOSAVE_DELAY_MILLIS &#x27;
                           &#x27;= 2000;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The dummy content this fragment is &#x27;
                           &#x27;presenting.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private Note mNote;\n&#x27;
                           &#x27;    private EditText mContentEditText;\n&#x27;
                           &#x27;    private TagsMultiAutoCompleteTextView &#x27;
                           &#x27;mTagView;\n&#x27;
                           &#x27;    private ToggleButton mPinButton;\n&#x27;
                           &#x27;    private boolean mShowNoteTitle;\n&#x27;
                           &#x27;    private Handler mAutoSaveHandler;\n&#x27;
                           &#x27;    private LinearLayout mPlaceholderView;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Mandatory empty constructor for the &#x27;
                           &#x27;fragment manager to instantiate the\n&#x27;
                           &#x27;     * fragment (e.g. upon screen orientation &#x27;
                           &#x27;changes).\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public NoteEditorFragment() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onCreate(Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        super.onCreate(savedInstanceState);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (getArguments() != null &amp;&amp; &#x27;
                           &#x27;getArguments().containsKey(ARG_ITEM_ID)) {\n&#x27;
                           &#x27;            Simplenote application = (Simplenote) &#x27;
                           &#x27;getActivity().getApplication();\n&#x27;
                           &#x27;            Bucket&lt;Note&gt; notesBucket = &#x27;
                           &#x27;application.getNotesBucket();\n&#x27;
                           &#x27;            String key = &#x27;
                           &#x27;getArguments().getString(ARG_ITEM_ID);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                mNote = notesBucket.get(key);\n&#x27;
                           &#x27;            } catch (BucketObjectMissingException &#x27;
                           &#x27;e) {\n&#x27;
                           &#x27;                // TODO: Handle a missing note\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreenLandscape())\n&#x27;
                           &#x27;            mShowNoteTitle = true;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mAutoSaveHandler = new Handler();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public View onCreateView(LayoutInflater &#x27;
                           &#x27;inflater, ViewGroup container, Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        View rootView = &#x27;
                           &#x27;inflater.inflate(R.layout.fragment_note_editor, &#x27;
                           &#x27;container, false);\n&#x27;
                           &#x27;        mContentEditText = ((EditText) &#x27;
                           &#x27;rootView.findViewById(R.id.note_content));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mContentEditText.addTextChangedListener(this);\n&#x27;
                           &#x27;        mTagView = (TagsMultiAutoCompleteTextView) &#x27;
                           &#x27;rootView.findViewById(R.id.tag_view);\n&#x27;
                           &#x27;        mTagView.setTokenizer(new &#x27;
                           &#x27;SpaceTokenizer());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mPinButton = (ToggleButton) &#x27;
                           &#x27;rootView.findViewById(R.id.pinButton);\n&#x27;
                           &#x27;        mPlaceholderView = (LinearLayout) &#x27;
                           &#x27;rootView.findViewById(R.id.placeholder);\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreen())\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\trefreshContent();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn rootView;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onResume() {\n&#x27;
                           &#x27;        super.onResume();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(this);\n&#x27;
                           &#x27;        if (mNote != null &amp;&amp; &#x27;
                           &#x27;mNote.getContent().isEmpty()) {\n&#x27;
                           &#x27;            // Show soft keyboard\n&#x27;
                           &#x27;            mContentEditText.requestFocus();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            InputMethodManager inputMethodManager &#x27;
                           &#x27;= (InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;            if (inputMethodManager != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;inputMethodManager.showSoftInput(mContentEditText, &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onPause() {\n&#x27;
                           &#x27;        saveAndSyncNote();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(null);\n&#x27;
                           &#x27;        // Hide soft keyboard\n&#x27;
                           &#x27;        InputMethodManager inputMethodManager = &#x27;
                           &#x27;(InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;        if (inputMethodManager != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;inputMethodManager.hideSoftInputFromWindow(mContentEditText.getWindowToken(), &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        super.onPause();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setNote(Note note) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // If we have a note already (on a tablet &#x27;
                           &#x27;in landscape), save the note.\n&#x27;
                           &#x27;        if (mNote != null)\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mNote = note;\n&#x27;
                           &#x27;        refreshContent();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void refreshContent() {\n&#x27;
                           &#x27;        if (mNote != null) {\n&#x27;
                           &#x27;            Log.v(&quot;Simplenote&quot;, &quot;refreshing &#x27;
                           &#x27;content&quot;);\n&#x27;
                           &#x27;            // Restore the cursor position if &#x27;
                           &#x27;possible.\n&#x27;
                           &#x27;            int cursorPosition = &#x27;
                           &#x27;newCursorLocation(mNote.getContent(), &#x27;
                           &#x27;mContentEditText.getText().toString(), &#x27;
                           &#x27;mContentEditText.getSelectionEnd());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mContentEditText.setText(mNote.getContent());\n&#x27;
                           &#x27;            if (mContentEditText.hasFocus() &amp;&amp; &#x27;
                           &#x27;cursorPosition != &#x27;
                           &#x27;mContentEditText.getSelectionEnd())\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mContentEditText.setSelection(cursorPosition);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPinButton.setChecked(mNote.isPinned());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            updateTagList();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void updateTagList(){\n&#x27;
                           &quot;        // Populate this note&#x27;s tags in the &quot;
                           &#x27;tagView\n&#x27;
                           &#x27;        mTagView.setChips(mNote.getTagString());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t// Populate tag list\n&#x27;
                           &#x27;        Simplenote simplenote = &#x27;
                           &#x27;(Simplenote)getActivity().getApplication();\n&#x27;
                           &#x27;        Bucket&lt;Tag&gt; tagBucket = &#x27;
                           &#x27;simplenote.getTagsBucket();\n&#x27;
                           &#x27;        ObjectCursor&lt;Tag&gt; tagsCursor = &#x27;
                           &#x27;tagBucket.query().orderByKey().execute();\n&#x27;
                           &#x27;        List&lt;String&gt; allTags = new &#x27;
                           &#x27;ArrayList&lt;String&gt;(tagsCursor.getCount());\n&#x27;
                           &#x27;        while (tagsCursor.moveToNext()) {\n&#x27;
                           &#x27;            Tag tag = tagsCursor.getObject();\n&#x27;
                           &#x27;            if (!mNote.hasTag(tag)) &#x27;
                           &#x27;allTags.add(tag.getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        tagsCursor.close();\n&#x27;
                           &#x27;        ArrayAdapter&lt;String&gt; adapter = new &#x27;
                           &#x27;ArrayAdapter&lt;String&gt;(getActivity(),\n&#x27;
                           &#x27;                &#x27;
                           &#x27;android.R.layout.simple_dropdown_item_1line, &#x27;
                           &#x27;allTags);\n&#x27;
                           &#x27;        mTagView.setAdapter(adapter);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void setActionBarTitle() {\n&#x27;
                           &#x27;        if (mShowNoteTitle) {\n&#x27;
                           &#x27;            if (mNote.getTitle() != null &amp;&amp; &#x27;
                           &#x27;!mNote.getTitle().equals(&quot;&quot;))\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(mNote.getTitle());\n&#x27;
                           &#x27;            else\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(R.string.new_note);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int newCursorLocation(String newText, String &#x27;
                           &#x27;oldText, int cursorLocation) {\n&#x27;
                           &#x27;        // Ported from the iOS app :)\n&#x27;
                           &#x27;        // Cases:\n&#x27;
                           &#x27;        // 0. All text after cursor (and possibly &#x27;
                           &#x27;more) was removed ==&gt; put cursor at end\n&#x27;
                           &#x27;        // 1. Text was added after the cursor ==&gt; &#x27;
                           &#x27;no change\n&#x27;
                           &#x27;        // 2. Text was added before the cursor ==&gt; &#x27;
                           &#x27;location advances\n&#x27;
                           &#x27;        // 3. Text was removed after the cursor &#x27;
                           &#x27;==&gt; no change\n&#x27;
                           &#x27;        // 4. Text was removed before the cursor &#x27;
                           &#x27;==&gt; location retreats\n&#x27;
                           &#x27;        // 5. Text was added/removed on both sides &#x27;
                           &#x27;of the cursor ==&gt; not handled\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int newCursorLocation = cursorLocation;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int deltaLength = newText.length() - &#x27;
                           &#x27;oldText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Case 0\n&#x27;
                           &#x27;        if (newText.length() &lt; cursorLocation)\n&#x27;
                           &#x27;            return newText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        boolean beforeCursorMatches = false;\n&#x27;
                           &#x27;        boolean afterCursorMatches = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            beforeCursorMatches = &#x27;
                           &#x27;oldText.substring(0, &#x27;
                           &#x27;cursorLocation).equals(newText.substring(0, &#x27;
                           &#x27;cursorLocation));\n&#x27;
                           &#x27;            afterCursorMatches = &#x27;
                           &#x27;oldText.substring(cursorLocation, &#x27;
                           &#x27;oldText.length()).equals(newText.substring(cursorLocation &#x27;
                           &#x27;+ deltaLength, newText.length()));\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 2 and 4\n&#x27;
                           &#x27;        if (!beforeCursorMatches &amp;&amp; &#x27;
                           &#x27;afterCursorMatches)\n&#x27;
                           &#x27;            newCursorLocation += deltaLength;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 1, 3 and 5 have no change\n&#x27;
                           &#x27;        return newCursorLocation;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Runnable autoSaveRunnable = new &#x27;
                           &#x27;Runnable() {\n&#x27;
                           &#x27;        @Override\n&#x27;
                           &#x27;        public void run() {\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    };\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTagsChanged(String tagString){\n&#x27;
                           &#x27;        mNote.setTagString(tagString);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;        updateTagList();\n&#x27;
                           &#x27;        mNote.save();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void beforeTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void afterTextChanged(Editable &#x27;
                           &#x27;editable) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // When text changes, start timer that &#x27;
                           &#x27;will fire after AUTOSAVE_DELAY_MILLIS passes\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null) {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.postDelayed(autoSaveRunnable, &#x27;
                           &#x27;AUTOSAVE_DELAY_MILLIS);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void saveAndSyncNote() {\n&#x27;
                           &#x27;        if (mNote == null)\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String content = &#x27;
                           &#x27;mContentEditText.getText().toString();\n&#x27;
                           &#x27;        if (mNote.hasChanges(content, &#x27;
                           &#x27;mPinButton.isChecked())) {\n&#x27;
                           &#x27;            mNote.setContent(content);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setTagString(mTagView.getText().toString());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setPinned(mPinButton.isChecked());\n&#x27;
                           &#x27;            mNote.save();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Log.v(&quot;Simplenote&quot;, &quot;autosaving note&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPlaceholderVisible(boolean &#x27;
                           &#x27;isVisible) {\n&#x27;
                           &#x27;        if (isVisible) {\n&#x27;
                           &#x27;            mNote = null;\n&#x27;
                           &#x27;            mContentEditText.setText(&quot;&quot;);\n&#x27;
                           &#x27;            mTagView.setText(&quot;&quot;);\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.VISIBLE);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // Use spaces in tag autocompletion list\n&#x27;
                           &#x27;    // From &#x27;
                           &#x27;http://stackoverflow.com/questions/3482981/how-to-replace-the-comma-with-a-space-when-i-use-the-multiautocompletetextview\n&#x27;
                           &#x27;    public class SpaceTokenizer implements &#x27;
                           &#x27;Tokenizer {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenStart(CharSequence &#x27;
                           &#x27;text, int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) != &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            while (i &lt; cursor &amp;&amp; text.charAt(i) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i++;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return i;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenEnd(CharSequence text, &#x27;
                           &#x27;int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;            int len = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &lt; len) {\n&#x27;
                           &quot;                if (text.charAt(i) == &#x27; &#x27;) {\n&quot;
                           &#x27;                    return i;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    i++;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return len;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public CharSequence &#x27;
                           &#x27;terminateToken(CharSequence text) {\n&#x27;
                           &#x27;            int i = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &quot;            if (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27; &quot;
                           &quot;&#x27;) {\n&quot;
                           &#x27;                return text;\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                if (text instanceof Spanned) {\n&#x27;
                           &#x27;                    SpannableString sp = new &#x27;
                           &#x27;SpannableString(text + &quot; &quot;);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TextUtils.copySpansFrom((Spanned) text, 0, &#x27;
                           &#x27;text.length(),\n&#x27;
                           &#x27;                            Object.class, sp, 0);\n&#x27;
                           &#x27;                    return sp;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    return text + &quot; &quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;package com.automattic.simplenote;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Calendar;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.app.Fragment;\n&#x27;
                           &#x27;import android.content.Context;\n&#x27;
                           &#x27;import android.os.Bundle;\n&#x27;
                           &#x27;import android.os.Handler;\n&#x27;
                           &#x27;import android.text.Editable;\n&#x27;
                           &#x27;import android.text.SpannableString;\n&#x27;
                           &#x27;import android.text.Spanned;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import android.text.TextWatcher;\n&#x27;
                           &#x27;import android.util.Log;\n&#x27;
                           &#x27;import android.view.LayoutInflater;\n&#x27;
                           &#x27;import android.view.View;\n&#x27;
                           &#x27;import android.view.ViewGroup;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.view.inputmethod.InputMethodManager;\n&#x27;
                           &#x27;import android.widget.ArrayAdapter;\n&#x27;
                           &#x27;import android.widget.EditText;\n&#x27;
                           &#x27;import android.widget.LinearLayout;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.widget.MultiAutoCompleteTextView.Tokenizer;\n&#x27;
                           &#x27;import android.widget.ToggleButton;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Note;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Tag;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;\n&#x27;
                           &#x27;import com.simperium.client.Bucket;\n&#x27;
                           &#x27;import com.simperium.client.Bucket.ObjectCursor;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.simperium.client.BucketObjectMissingException;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class NoteEditorFragment extends Fragment &#x27;
                           &#x27;implements TextWatcher, OnTagAddedListener {\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The fragment argument representing the item &#x27;
                           &#x27;ID that this fragment\n&#x27;
                           &#x27;     * represents.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static final String ARG_ITEM_ID = &#x27;
                           &#x27;&quot;item_id&quot;;\n&#x27;
                           &#x27;    private static final int AUTOSAVE_DELAY_MILLIS &#x27;
                           &#x27;= 2000;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The dummy content this fragment is &#x27;
                           &#x27;presenting.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private Note mNote;\n&#x27;
                           &#x27;    private EditText mContentEditText;\n&#x27;
                           &#x27;    private TagsMultiAutoCompleteTextView &#x27;
                           &#x27;mTagView;\n&#x27;
                           &#x27;    private ToggleButton mPinButton;\n&#x27;
                           &#x27;    private boolean mShowNoteTitle;\n&#x27;
                           &#x27;    private Handler mAutoSaveHandler;\n&#x27;
                           &#x27;    private LinearLayout mPlaceholderView;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Mandatory empty constructor for the &#x27;
                           &#x27;fragment manager to instantiate the\n&#x27;
                           &#x27;     * fragment (e.g. upon screen orientation &#x27;
                           &#x27;changes).\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public NoteEditorFragment() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onCreate(Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        super.onCreate(savedInstanceState);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (getArguments() != null &amp;&amp; &#x27;
                           &#x27;getArguments().containsKey(ARG_ITEM_ID)) {\n&#x27;
                           &#x27;            Simplenote application = (Simplenote) &#x27;
                           &#x27;getActivity().getApplication();\n&#x27;
                           &#x27;            Bucket&lt;Note&gt; notesBucket = &#x27;
                           &#x27;application.getNotesBucket();\n&#x27;
                           &#x27;            String key = &#x27;
                           &#x27;getArguments().getString(ARG_ITEM_ID);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                mNote = notesBucket.get(key);\n&#x27;
                           &#x27;            } catch (BucketObjectMissingException &#x27;
                           &#x27;e) {\n&#x27;
                           &#x27;                // TODO: Handle a missing note\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreenLandscape())\n&#x27;
                           &#x27;            mShowNoteTitle = true;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mAutoSaveHandler = new Handler();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public View onCreateView(LayoutInflater &#x27;
                           &#x27;inflater, ViewGroup container, Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        View rootView = &#x27;
                           &#x27;inflater.inflate(R.layout.fragment_note_editor, &#x27;
                           &#x27;container, false);\n&#x27;
                           &#x27;        mContentEditText = ((EditText) &#x27;
                           &#x27;rootView.findViewById(R.id.note_content));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mContentEditText.addTextChangedListener(this);\n&#x27;
                           &#x27;        mTagView = (TagsMultiAutoCompleteTextView) &#x27;
                           &#x27;rootView.findViewById(R.id.tag_view);\n&#x27;
                           &#x27;        mTagView.setTokenizer(new &#x27;
                           &#x27;SpaceTokenizer());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mPinButton = (ToggleButton) &#x27;
                           &#x27;rootView.findViewById(R.id.pinButton);\n&#x27;
                           &#x27;        mPlaceholderView = (LinearLayout) &#x27;
                           &#x27;rootView.findViewById(R.id.placeholder);\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreen())\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\trefreshContent();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn rootView;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onResume() {\n&#x27;
                           &#x27;        super.onResume();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(this);\n&#x27;
                           &#x27;        if (mNote != null &amp;&amp; &#x27;
                           &#x27;mNote.getContent().isEmpty()) {\n&#x27;
                           &#x27;            // Show soft keyboard\n&#x27;
                           &#x27;            mContentEditText.requestFocus();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            InputMethodManager inputMethodManager &#x27;
                           &#x27;= (InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;            if (inputMethodManager != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;inputMethodManager.showSoftInput(mContentEditText, &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onPause() {\n&#x27;
                           &#x27;        saveAndSyncNote();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(null);\n&#x27;
                           &#x27;        // Hide soft keyboard\n&#x27;
                           &#x27;        InputMethodManager inputMethodManager = &#x27;
                           &#x27;(InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;        if (inputMethodManager != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;inputMethodManager.hideSoftInputFromWindow(mContentEditText.getWindowToken(), &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        super.onPause();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setNote(Note note) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // If we have a note already (on a tablet &#x27;
                           &#x27;in landscape), save the note.\n&#x27;
                           &#x27;        if (mNote != null)\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mNote = note;\n&#x27;
                           &#x27;        refreshContent();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void refreshContent() {\n&#x27;
                           &#x27;        if (mNote != null) {\n&#x27;
                           &#x27;            Log.v(&quot;Simplenote&quot;, &quot;refreshing &#x27;
                           &#x27;content&quot;);\n&#x27;
                           &#x27;            // Restore the cursor position if &#x27;
                           &#x27;possible.\n&#x27;
                           &#x27;            int cursorPosition = &#x27;
                           &#x27;newCursorLocation(mNote.getContent(), &#x27;
                           &#x27;mContentEditText.getText().toString(), &#x27;
                           &#x27;mContentEditText.getSelectionEnd());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mContentEditText.setText(mNote.getContent());\n&#x27;
                           &#x27;            if (mContentEditText.hasFocus() &amp;&amp; &#x27;
                           &#x27;cursorPosition != &#x27;
                           &#x27;mContentEditText.getSelectionEnd())\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mContentEditText.setSelection(cursorPosition);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPinButton.setChecked(mNote.isPinned());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            updateTagList();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void updateTagList(){\n&#x27;
                           &quot;        // Populate this note&#x27;s tags in the &quot;
                           &#x27;tagView\n&#x27;
                           &#x27;        mTagView.setChips(mNote.getTagString());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t// Populate tag list\n&#x27;
                           &#x27;        Simplenote simplenote = &#x27;
                           &#x27;(Simplenote)getActivity().getApplication();\n&#x27;
                           &#x27;        Bucket&lt;Tag&gt; tagBucket = &#x27;
                           &#x27;simplenote.getTagsBucket();\n&#x27;
                           &#x27;        ObjectCursor&lt;Tag&gt; tagsCursor = &#x27;
                           &#x27;tagBucket.query().orderByKey().execute();\n&#x27;
                           &#x27;        List&lt;String&gt; allTags = new &#x27;
                           &#x27;ArrayList&lt;String&gt;(tagsCursor.getCount());\n&#x27;
                           &#x27;        while (tagsCursor.moveToNext()) {\n&#x27;
                           &#x27;            Tag tag = tagsCursor.getObject();\n&#x27;
                           &#x27;            if (!mNote.hasTag(tag)) &#x27;
                           &#x27;allTags.add(tag.getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        tagsCursor.close();\n&#x27;
                           &#x27;        ArrayAdapter&lt;String&gt; adapter = new &#x27;
                           &#x27;ArrayAdapter&lt;String&gt;(getActivity(),\n&#x27;
                           &#x27;                &#x27;
                           &#x27;android.R.layout.simple_dropdown_item_1line, &#x27;
                           &#x27;allTags);\n&#x27;
                           &#x27;        mTagView.setAdapter(adapter);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void setActionBarTitle() {\n&#x27;
                           &#x27;        if (mShowNoteTitle) {\n&#x27;
                           &#x27;            if (mNote.getTitle() != null &amp;&amp; &#x27;
                           &#x27;!mNote.getTitle().equals(&quot;&quot;))\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(mNote.getTitle());\n&#x27;
                           &#x27;            else\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(R.string.new_note);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int newCursorLocation(String newText, String &#x27;
                           &#x27;oldText, int cursorLocation) {\n&#x27;
                           &#x27;        // Ported from the iOS app :)\n&#x27;
                           &#x27;        // Cases:\n&#x27;
                           &#x27;        // 0. All text after cursor (and possibly &#x27;
                           &#x27;more) was removed ==&gt; put cursor at end\n&#x27;
                           &#x27;        // 1. Text was added after the cursor ==&gt; &#x27;
                           &#x27;no change\n&#x27;
                           &#x27;        // 2. Text was added before the cursor ==&gt; &#x27;
                           &#x27;location advances\n&#x27;
                           &#x27;        // 3. Text was removed after the cursor &#x27;
                           &#x27;==&gt; no change\n&#x27;
                           &#x27;        // 4. Text was removed before the cursor &#x27;
                           &#x27;==&gt; location retreats\n&#x27;
                           &#x27;        // 5. Text was added/removed on both sides &#x27;
                           &#x27;of the cursor ==&gt; not handled\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int newCursorLocation = cursorLocation;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int deltaLength = newText.length() - &#x27;
                           &#x27;oldText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Case 0\n&#x27;
                           &#x27;        if (newText.length() &lt; cursorLocation)\n&#x27;
                           &#x27;            return newText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        boolean beforeCursorMatches = false;\n&#x27;
                           &#x27;        boolean afterCursorMatches = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            beforeCursorMatches = &#x27;
                           &#x27;oldText.substring(0, &#x27;
                           &#x27;cursorLocation).equals(newText.substring(0, &#x27;
                           &#x27;cursorLocation));\n&#x27;
                           &#x27;            afterCursorMatches = &#x27;
                           &#x27;oldText.substring(cursorLocation, &#x27;
                           &#x27;oldText.length()).equals(newText.substring(cursorLocation &#x27;
                           &#x27;+ deltaLength, newText.length()));\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 2 and 4\n&#x27;
                           &#x27;        if (!beforeCursorMatches &amp;&amp; &#x27;
                           &#x27;afterCursorMatches)\n&#x27;
                           &#x27;            newCursorLocation += deltaLength;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 1, 3 and 5 have no change\n&#x27;
                           &#x27;        return newCursorLocation;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Runnable autoSaveRunnable = new &#x27;
                           &#x27;Runnable() {\n&#x27;
                           &#x27;        @Override\n&#x27;
                           &#x27;        public void run() {\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    };\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTagsChanged(String tagString){\n&#x27;
                           &#x27;        mNote.setTagString(tagString);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;        updateTagList();\n&#x27;
                           &#x27;        mNote.save();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void beforeTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void afterTextChanged(Editable &#x27;
                           &#x27;editable) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // When text changes, start timer that &#x27;
                           &#x27;will fire after AUTOSAVE_DELAY_MILLIS passes\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null) {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.postDelayed(autoSaveRunnable, &#x27;
                           &#x27;AUTOSAVE_DELAY_MILLIS);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void saveAndSyncNote() {\n&#x27;
                           &#x27;        if (mNote == null)\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String content = &#x27;
                           &#x27;mContentEditText.getText().toString();\n&#x27;
                           &#x27;        if (mNote.hasChanges(content, &#x27;
                           &#x27;mPinButton.isChecked())) {\n&#x27;
                           &#x27;            mNote.setContent(content);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setTagString(mTagView.getText().toString());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setPinned(mPinButton.isChecked());\n&#x27;
                           &#x27;            mNote.save();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Log.v(&quot;Simplenote&quot;, &quot;autosaving note&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPlaceholderVisible(boolean &#x27;
                           &#x27;isVisible) {\n&#x27;
                           &#x27;        if (isVisible) {\n&#x27;
                           &#x27;            mNote = null;\n&#x27;
                           &#x27;            mContentEditText.setText(&quot;&quot;);\n&#x27;
                           &#x27;            mTagView.setText(&quot;&quot;);\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.VISIBLE);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // Use spaces in tag autocompletion list\n&#x27;
                           &#x27;    // From &#x27;
                           &#x27;http://stackoverflow.com/questions/3482981/how-to-replace-the-comma-with-a-space-when-i-use-the-multiautocompletetextview\n&#x27;
                           &#x27;    public class SpaceTokenizer implements &#x27;
                           &#x27;Tokenizer {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenStart(CharSequence &#x27;
                           &#x27;text, int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) != &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            while (i &lt; cursor &amp;&amp; text.charAt(i) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i++;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return i;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenEnd(CharSequence text, &#x27;
                           &#x27;int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;            int len = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &lt; len) {\n&#x27;
                           &quot;                if (text.charAt(i) == &#x27; &#x27;) {\n&quot;
                           &#x27;                    return i;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    i++;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return len;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public CharSequence &#x27;
                           &#x27;terminateToken(CharSequence text) {\n&#x27;
                           &#x27;            int i = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &quot;            if (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27; &quot;
                           &quot;&#x27;) {\n&quot;
                           &#x27;                return text;\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                if (text instanceof Spanned) {\n&#x27;
                           &#x27;                    SpannableString sp = new &#x27;
                           &#x27;SpannableString(text + &quot; &quot;);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TextUtils.copySpansFrom((Spanned) text, 0, &#x27;
                           &#x27;text.length(),\n&#x27;
                           &#x27;                            Object.class, sp, 0);\n&#x27;
                           &#x27;                    return sp;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    return text + &quot; &quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;package com.automattic.simplenote;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Calendar;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.app.Fragment;\n&#x27;
                           &#x27;import android.content.Context;\n&#x27;
                           &#x27;import android.os.Bundle;\n&#x27;
                           &#x27;import android.os.Handler;\n&#x27;
                           &#x27;import android.text.Editable;\n&#x27;
                           &#x27;import android.text.SpannableString;\n&#x27;
                           &#x27;import android.text.Spanned;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import android.text.TextWatcher;\n&#x27;
                           &#x27;import android.util.Log;\n&#x27;
                           &#x27;import android.view.LayoutInflater;\n&#x27;
                           &#x27;import android.view.View;\n&#x27;
                           &#x27;import android.view.ViewGroup;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.view.inputmethod.InputMethodManager;\n&#x27;
                           &#x27;import android.widget.ArrayAdapter;\n&#x27;
                           &#x27;import android.widget.EditText;\n&#x27;
                           &#x27;import android.widget.LinearLayout;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.widget.MultiAutoCompleteTextView.Tokenizer;\n&#x27;
                           &#x27;import android.widget.ToggleButton;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Note;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Tag;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;\n&#x27;
                           &#x27;import com.simperium.client.Bucket;\n&#x27;
                           &#x27;import com.simperium.client.Bucket.ObjectCursor;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.simperium.client.BucketObjectMissingException;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class NoteEditorFragment extends Fragment &#x27;
                           &#x27;implements TextWatcher, OnTagAddedListener {\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The fragment argument representing the item &#x27;
                           &#x27;ID that this fragment\n&#x27;
                           &#x27;     * represents.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static final String ARG_ITEM_ID = &#x27;
                           &#x27;&quot;item_id&quot;;\n&#x27;
                           &#x27;    private static final int AUTOSAVE_DELAY_MILLIS &#x27;
                           &#x27;= 2000;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The dummy content this fragment is &#x27;
                           &#x27;presenting.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private Note mNote;\n&#x27;
                           &#x27;    private EditText mContentEditText;\n&#x27;
                           &#x27;    private TagsMultiAutoCompleteTextView &#x27;
                           &#x27;mTagView;\n&#x27;
                           &#x27;    private ToggleButton mPinButton;\n&#x27;
                           &#x27;    private boolean mShowNoteTitle;\n&#x27;
                           &#x27;    private Handler mAutoSaveHandler;\n&#x27;
                           &#x27;    private LinearLayout mPlaceholderView;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Mandatory empty constructor for the &#x27;
                           &#x27;fragment manager to instantiate the\n&#x27;
                           &#x27;     * fragment (e.g. upon screen orientation &#x27;
                           &#x27;changes).\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public NoteEditorFragment() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onCreate(Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        super.onCreate(savedInstanceState);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (getArguments() != null &amp;&amp; &#x27;
                           &#x27;getArguments().containsKey(ARG_ITEM_ID)) {\n&#x27;
                           &#x27;            Simplenote application = (Simplenote) &#x27;
                           &#x27;getActivity().getApplication();\n&#x27;
                           &#x27;            Bucket&lt;Note&gt; notesBucket = &#x27;
                           &#x27;application.getNotesBucket();\n&#x27;
                           &#x27;            String key = &#x27;
                           &#x27;getArguments().getString(ARG_ITEM_ID);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                mNote = notesBucket.get(key);\n&#x27;
                           &#x27;            } catch (BucketObjectMissingException &#x27;
                           &#x27;e) {\n&#x27;
                           &#x27;                // TODO: Handle a missing note\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreenLandscape())\n&#x27;
                           &#x27;            mShowNoteTitle = true;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mAutoSaveHandler = new Handler();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public View onCreateView(LayoutInflater &#x27;
                           &#x27;inflater, ViewGroup container, Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        View rootView = &#x27;
                           &#x27;inflater.inflate(R.layout.fragment_note_editor, &#x27;
                           &#x27;container, false);\n&#x27;
                           &#x27;        mContentEditText = ((EditText) &#x27;
                           &#x27;rootView.findViewById(R.id.note_content));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mContentEditText.addTextChangedListener(this);\n&#x27;
                           &#x27;        mTagView = (TagsMultiAutoCompleteTextView) &#x27;
                           &#x27;rootView.findViewById(R.id.tag_view);\n&#x27;
                           &#x27;        mTagView.setTokenizer(new &#x27;
                           &#x27;SpaceTokenizer());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mPinButton = (ToggleButton) &#x27;
                           &#x27;rootView.findViewById(R.id.pinButton);\n&#x27;
                           &#x27;        mPlaceholderView = (LinearLayout) &#x27;
                           &#x27;rootView.findViewById(R.id.placeholder);\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreen())\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\trefreshContent();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn rootView;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onResume() {\n&#x27;
                           &#x27;        super.onResume();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(this);\n&#x27;
                           &#x27;        if (mNote != null &amp;&amp; &#x27;
                           &#x27;mNote.getContent().isEmpty()) {\n&#x27;
                           &#x27;            // Show soft keyboard\n&#x27;
                           &#x27;            mContentEditText.requestFocus();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            InputMethodManager inputMethodManager &#x27;
                           &#x27;= (InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;            if (inputMethodManager != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;inputMethodManager.showSoftInput(mContentEditText, &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onPause() {\n&#x27;
                           &#x27;        saveAndSyncNote();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(null);\n&#x27;
                           &#x27;        // Hide soft keyboard\n&#x27;
                           &#x27;        InputMethodManager inputMethodManager = &#x27;
                           &#x27;(InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;        if (inputMethodManager != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;inputMethodManager.hideSoftInputFromWindow(mContentEditText.getWindowToken(), &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        super.onPause();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setNote(Note note) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // If we have a note already (on a tablet &#x27;
                           &#x27;in landscape), save the note.\n&#x27;
                           &#x27;        if (mNote != null)\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mNote = note;\n&#x27;
                           &#x27;        refreshContent();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void refreshContent() {\n&#x27;
                           &#x27;        if (mNote != null) {\n&#x27;
                           &#x27;            Log.v(&quot;Simplenote&quot;, &quot;refreshing &#x27;
                           &#x27;content&quot;);\n&#x27;
                           &#x27;            // Restore the cursor position if &#x27;
                           &#x27;possible.\n&#x27;
                           &#x27;            int cursorPosition = &#x27;
                           &#x27;newCursorLocation(mNote.getContent(), &#x27;
                           &#x27;mContentEditText.getText().toString(), &#x27;
                           &#x27;mContentEditText.getSelectionEnd());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mContentEditText.setText(mNote.getContent());\n&#x27;
                           &#x27;            if (mContentEditText.hasFocus() &amp;&amp; &#x27;
                           &#x27;cursorPosition != &#x27;
                           &#x27;mContentEditText.getSelectionEnd())\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mContentEditText.setSelection(cursorPosition);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPinButton.setChecked(mNote.isPinned());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            updateTagList();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void updateTagList(){\n&#x27;
                           &quot;        // Populate this note&#x27;s tags in the &quot;
                           &#x27;tagView\n&#x27;
                           &#x27;        mTagView.setChips(mNote.getTagString());\n&#x27;
                           &#x27;        \n&#x27;
                           &#x27;\t\t// Populate tag list\n&#x27;
                           &#x27;        Simplenote simplenote = &#x27;
                           &#x27;(Simplenote)getActivity().getApplication();\n&#x27;
                           &#x27;        Bucket&lt;Tag&gt; tagBucket = &#x27;
                           &#x27;simplenote.getTagsBucket();\n&#x27;
                           &#x27;        ObjectCursor&lt;Tag&gt; tagsCursor = &#x27;
                           &#x27;tagBucket.query().orderByKey().execute();\n&#x27;
                           &#x27;        List&lt;String&gt; allTags = new &#x27;
                           &#x27;ArrayList&lt;String&gt;(tagsCursor.getCount());\n&#x27;
                           &#x27;        while (tagsCursor.moveToNext()) {\n&#x27;
                           &#x27;            Tag tag = tagsCursor.getObject();\n&#x27;
                           &#x27;            if (!mNote.hasTag(tag)) &#x27;
                           &#x27;allTags.add(tag.getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        tagsCursor.close();\n&#x27;
                           &#x27;        ArrayAdapter&lt;String&gt; adapter = new &#x27;
                           &#x27;ArrayAdapter&lt;String&gt;(getActivity(),\n&#x27;
                           &#x27;                &#x27;
                           &#x27;android.R.layout.simple_dropdown_item_1line, &#x27;
                           &#x27;allTags);\n&#x27;
                           &#x27;        mTagView.setAdapter(adapter);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void setActionBarTitle() {\n&#x27;
                           &#x27;        if (mShowNoteTitle) {\n&#x27;
                           &#x27;            if (mNote.getTitle() != null &amp;&amp; &#x27;
                           &#x27;!mNote.getTitle().equals(&quot;&quot;))\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(mNote.getTitle());\n&#x27;
                           &#x27;            else\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(R.string.new_note);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int newCursorLocation(String newText, String &#x27;
                           &#x27;oldText, int cursorLocation) {\n&#x27;
                           &#x27;        // Ported from the iOS app :)\n&#x27;
                           &#x27;        // Cases:\n&#x27;
                           &#x27;        // 0. All text after cursor (and possibly &#x27;
                           &#x27;more) was removed ==&gt; put cursor at end\n&#x27;
                           &#x27;        // 1. Text was added after the cursor ==&gt; &#x27;
                           &#x27;no change\n&#x27;
                           &#x27;        // 2. Text was added before the cursor ==&gt; &#x27;
                           &#x27;location advances\n&#x27;
                           &#x27;        // 3. Text was removed after the cursor &#x27;
                           &#x27;==&gt; no change\n&#x27;
                           &#x27;        // 4. Text was removed before the cursor &#x27;
                           &#x27;==&gt; location retreats\n&#x27;
                           &#x27;        // 5. Text was added/removed on both sides &#x27;
                           &#x27;of the cursor ==&gt; not handled\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int newCursorLocation = cursorLocation;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int deltaLength = newText.length() - &#x27;
                           &#x27;oldText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Case 0\n&#x27;
                           &#x27;        if (newText.length() &lt; cursorLocation)\n&#x27;
                           &#x27;            return newText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        boolean beforeCursorMatches = false;\n&#x27;
                           &#x27;        boolean afterCursorMatches = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            beforeCursorMatches = &#x27;
                           &#x27;oldText.substring(0, &#x27;
                           &#x27;cursorLocation).equals(newText.substring(0, &#x27;
                           &#x27;cursorLocation));\n&#x27;
                           &#x27;            afterCursorMatches = &#x27;
                           &#x27;oldText.substring(cursorLocation, &#x27;
                           &#x27;oldText.length()).equals(newText.substring(cursorLocation &#x27;
                           &#x27;+ deltaLength, newText.length()));\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 2 and 4\n&#x27;
                           &#x27;        if (!beforeCursorMatches &amp;&amp; &#x27;
                           &#x27;afterCursorMatches)\n&#x27;
                           &#x27;            newCursorLocation += deltaLength;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 1, 3 and 5 have no change\n&#x27;
                           &#x27;        return newCursorLocation;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Runnable autoSaveRunnable = new &#x27;
                           &#x27;Runnable() {\n&#x27;
                           &#x27;        @Override\n&#x27;
                           &#x27;        public void run() {\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    };\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTagsChanged(String tagString){\n&#x27;
                           &#x27;        mNote.setTagString(tagString);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;        updateTagList();\n&#x27;
                           &#x27;        mNote.save();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void beforeTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void afterTextChanged(Editable &#x27;
                           &#x27;editable) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // When text changes, start timer that &#x27;
                           &#x27;will fire after AUTOSAVE_DELAY_MILLIS passes\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null) {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.postDelayed(autoSaveRunnable, &#x27;
                           &#x27;AUTOSAVE_DELAY_MILLIS);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void saveAndSyncNote() {\n&#x27;
                           &#x27;        if (mNote == null)\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String content = &#x27;
                           &#x27;mContentEditText.getText().toString();\n&#x27;
                           &#x27;        if (mNote.hasChanges(content, &#x27;
                           &#x27;mPinButton.isChecked())) {\n&#x27;
                           &#x27;            mNote.setContent(content);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setTagString(mTagView.getText().toString());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setPinned(mPinButton.isChecked());\n&#x27;
                           &#x27;            mNote.save();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Log.v(&quot;Simplenote&quot;, &quot;autosaving note&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPlaceholderVisible(boolean &#x27;
                           &#x27;isVisible) {\n&#x27;
                           &#x27;        if (isVisible) {\n&#x27;
                           &#x27;            mNote = null;\n&#x27;
                           &#x27;            mContentEditText.setText(&quot;&quot;);\n&#x27;
                           &#x27;            mTagView.setText(&quot;&quot;);\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.VISIBLE);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // Use spaces in tag autocompletion list\n&#x27;
                           &#x27;    // From &#x27;
                           &#x27;http://stackoverflow.com/questions/3482981/how-to-replace-the-comma-with-a-space-when-i-use-the-multiautocompletetextview\n&#x27;
                           &#x27;    public class SpaceTokenizer implements &#x27;
                           &#x27;Tokenizer {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenStart(CharSequence &#x27;
                           &#x27;text, int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) != &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            while (i &lt; cursor &amp;&amp; text.charAt(i) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i++;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return i;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenEnd(CharSequence text, &#x27;
                           &#x27;int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;            int len = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &lt; len) {\n&#x27;
                           &quot;                if (text.charAt(i) == &#x27; &#x27;) {\n&quot;
                           &#x27;                    return i;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    i++;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return len;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public CharSequence &#x27;
                           &#x27;terminateToken(CharSequence text) {\n&#x27;
                           &#x27;            int i = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &quot;            if (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27; &quot;
                           &quot;&#x27;) {\n&quot;
                           &#x27;                return text;\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                if (text instanceof Spanned) {\n&#x27;
                           &#x27;                    SpannableString sp = new &#x27;
                           &#x27;SpannableString(text + &quot; &quot;);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TextUtils.copySpansFrom((Spanned) text, 0, &#x27;
                           &#x27;text.length(),\n&#x27;
                           &#x27;                            Object.class, sp, 0);\n&#x27;
                           &#x27;                    return sp;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    return text + &quot; &quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;package com.automattic.simplenote;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Calendar;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.app.Fragment;\n&#x27;
                           &#x27;import android.content.Context;\n&#x27;
                           &#x27;import android.os.Bundle;\n&#x27;
                           &#x27;import android.os.Handler;\n&#x27;
                           &#x27;import android.text.Editable;\n&#x27;
                           &#x27;import android.text.SpannableString;\n&#x27;
                           &#x27;import android.text.Spanned;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import android.text.TextWatcher;\n&#x27;
                           &#x27;import android.util.Log;\n&#x27;
                           &#x27;import android.view.LayoutInflater;\n&#x27;
                           &#x27;import android.view.View;\n&#x27;
                           &#x27;import android.view.ViewGroup;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.view.inputmethod.InputMethodManager;\n&#x27;
                           &#x27;import android.widget.ArrayAdapter;\n&#x27;
                           &#x27;import android.widget.EditText;\n&#x27;
                           &#x27;import android.widget.LinearLayout;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.widget.MultiAutoCompleteTextView.Tokenizer;\n&#x27;
                           &#x27;import android.widget.ToggleButton;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Note;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Tag;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;\n&#x27;
                           &#x27;import com.simperium.client.Bucket;\n&#x27;
                           &#x27;import com.simperium.client.Bucket.ObjectCursor;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.simperium.client.BucketObjectMissingException;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class NoteEditorFragment extends Fragment &#x27;
                           &#x27;implements TextWatcher, OnTagAddedListener {\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The fragment argument representing the item &#x27;
                           &#x27;ID that this fragment\n&#x27;
                           &#x27;     * represents.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static final String ARG_ITEM_ID = &#x27;
                           &#x27;&quot;item_id&quot;;\n&#x27;
                           &#x27;    private static final int AUTOSAVE_DELAY_MILLIS &#x27;
                           &#x27;= 2000;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The dummy content this fragment is &#x27;
                           &#x27;presenting.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private Note mNote;\n&#x27;
                           &#x27;    private EditText mContentEditText;\n&#x27;
                           &#x27;    private TagsMultiAutoCompleteTextView &#x27;
                           &#x27;mTagView;\n&#x27;
                           &#x27;    private ToggleButton mPinButton;\n&#x27;
                           &#x27;    private boolean mShowNoteTitle;\n&#x27;
                           &#x27;    private Handler mAutoSaveHandler;\n&#x27;
                           &#x27;    private LinearLayout mPlaceholderView;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Mandatory empty constructor for the &#x27;
                           &#x27;fragment manager to instantiate the\n&#x27;
                           &#x27;     * fragment (e.g. upon screen orientation &#x27;
                           &#x27;changes).\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public NoteEditorFragment() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onCreate(Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        super.onCreate(savedInstanceState);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (getArguments() != null &amp;&amp; &#x27;
                           &#x27;getArguments().containsKey(ARG_ITEM_ID)) {\n&#x27;
                           &#x27;            Simplenote application = (Simplenote) &#x27;
                           &#x27;getActivity().getApplication();\n&#x27;
                           &#x27;            Bucket&lt;Note&gt; notesBucket = &#x27;
                           &#x27;application.getNotesBucket();\n&#x27;
                           &#x27;            String key = &#x27;
                           &#x27;getArguments().getString(ARG_ITEM_ID);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                mNote = notesBucket.get(key);\n&#x27;
                           &#x27;            } catch (BucketObjectMissingException &#x27;
                           &#x27;e) {\n&#x27;
                           &#x27;                // TODO: Handle a missing note\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreenLandscape())\n&#x27;
                           &#x27;            mShowNoteTitle = true;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mAutoSaveHandler = new Handler();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public View onCreateView(LayoutInflater &#x27;
                           &#x27;inflater, ViewGroup container, Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        View rootView = &#x27;
                           &#x27;inflater.inflate(R.layout.fragment_note_editor, &#x27;
                           &#x27;container, false);\n&#x27;
                           &#x27;        mContentEditText = ((EditText) &#x27;
                           &#x27;rootView.findViewById(R.id.note_content));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mContentEditText.addTextChangedListener(this);\n&#x27;
                           &#x27;        mTagView = (TagsMultiAutoCompleteTextView) &#x27;
                           &#x27;rootView.findViewById(R.id.tag_view);\n&#x27;
                           &#x27;        mTagView.setTokenizer(new &#x27;
                           &#x27;SpaceTokenizer());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mPinButton = (ToggleButton) &#x27;
                           &#x27;rootView.findViewById(R.id.pinButton);\n&#x27;
                           &#x27;        mPlaceholderView = (LinearLayout) &#x27;
                           &#x27;rootView.findViewById(R.id.placeholder);\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreen())\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\trefreshContent();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn rootView;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onResume() {\n&#x27;
                           &#x27;        super.onResume();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(this);\n&#x27;
                           &#x27;        if (mNote != null &amp;&amp; &#x27;
                           &#x27;mNote.getContent().isEmpty()) {\n&#x27;
                           &#x27;            // Show soft keyboard\n&#x27;
                           &#x27;            mContentEditText.requestFocus();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            InputMethodManager inputMethodManager &#x27;
                           &#x27;= (InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;            if (inputMethodManager != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;inputMethodManager.showSoftInput(mContentEditText, &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onPause() {\n&#x27;
                           &#x27;        saveAndSyncNote();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(null);\n&#x27;
                           &#x27;        // Hide soft keyboard\n&#x27;
                           &#x27;        InputMethodManager inputMethodManager = &#x27;
                           &#x27;(InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;        if (inputMethodManager != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;inputMethodManager.hideSoftInputFromWindow(mContentEditText.getWindowToken(), &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        super.onPause();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setNote(Note note) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // If we have a note already (on a tablet &#x27;
                           &#x27;in landscape), save the note.\n&#x27;
                           &#x27;        if (mNote != null)\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mNote = note;\n&#x27;
                           &#x27;        refreshContent();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void refreshContent() {\n&#x27;
                           &#x27;        if (mNote != null) {\n&#x27;
                           &#x27;            Log.v(&quot;Simplenote&quot;, &quot;refreshing &#x27;
                           &#x27;content&quot;);\n&#x27;
                           &#x27;            // Restore the cursor position if &#x27;
                           &#x27;possible.\n&#x27;
                           &#x27;            int cursorPosition = &#x27;
                           &#x27;newCursorLocation(mNote.getContent(), &#x27;
                           &#x27;mContentEditText.getText().toString(), &#x27;
                           &#x27;mContentEditText.getSelectionEnd());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mContentEditText.setText(mNote.getContent());\n&#x27;
                           &#x27;            if (mContentEditText.hasFocus() &amp;&amp; &#x27;
                           &#x27;cursorPosition != &#x27;
                           &#x27;mContentEditText.getSelectionEnd())\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mContentEditText.setSelection(cursorPosition);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPinButton.setChecked(mNote.isPinned());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            updateTagList();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void updateTagList(){\n&#x27;
                           &quot;        // Populate this note&#x27;s tags in the &quot;
                           &#x27;tagView\n&#x27;
                           &#x27;        mTagView.setChips(mNote.getTagString());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t// Populate tag list\n&#x27;
                           &#x27;        Simplenote simplenote = &#x27;
                           &#x27;(Simplenote)getActivity().getApplication();\n&#x27;
                           &#x27;        Bucket&lt;Tag&gt; tagBucket = &#x27;
                           &#x27;simplenote.getTagsBucket();\n&#x27;
                           &#x27;        ObjectCursor&lt;Tag&gt; tagsCursor = &#x27;
                           &#x27;tagBucket.query().orderByKey().execute();\n&#x27;
                           &#x27;        List&lt;String&gt; allTags = new &#x27;
                           &#x27;ArrayList&lt;String&gt;(tagsCursor.getCount());\n&#x27;
                           &#x27;        while (tagsCursor.moveToNext()) {\n&#x27;
                           &#x27;            Tag tag = tagsCursor.getObject();\n&#x27;
                           &#x27;            if (!mNote.hasTag(tag)) &#x27;
                           &#x27;allTags.add(tag.getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        tagsCursor.close();\n&#x27;
                           &#x27;        ArrayAdapter&lt;String&gt; adapter = new &#x27;
                           &#x27;ArrayAdapter&lt;String&gt;(getActivity(),\n&#x27;
                           &#x27;                &#x27;
                           &#x27;android.R.layout.simple_dropdown_item_1line, &#x27;
                           &#x27;allTags);\n&#x27;
                           &#x27;        mTagView.setAdapter(adapter);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void setActionBarTitle() {\n&#x27;
                           &#x27;        if (mShowNoteTitle) {\n&#x27;
                           &#x27;            if (mNote.getTitle() != null &amp;&amp; &#x27;
                           &#x27;!mNote.getTitle().equals(&quot;&quot;))\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(mNote.getTitle());\n&#x27;
                           &#x27;            else\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(R.string.new_note);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int newCursorLocation(String newText, String &#x27;
                           &#x27;oldText, int cursorLocation) {\n&#x27;
                           &#x27;        // Ported from the iOS app :)\n&#x27;
                           &#x27;        // Cases:\n&#x27;
                           &#x27;        // 0. All text after cursor (and possibly &#x27;
                           &#x27;more) was removed ==&gt; put cursor at end\n&#x27;
                           &#x27;        // 1. Text was added after the cursor ==&gt; &#x27;
                           &#x27;no change\n&#x27;
                           &#x27;        // 2. Text was added before the cursor ==&gt; &#x27;
                           &#x27;location advances\n&#x27;
                           &#x27;        // 3. Text was removed after the cursor &#x27;
                           &#x27;==&gt; no change\n&#x27;
                           &#x27;        // 4. Text was removed before the cursor &#x27;
                           &#x27;==&gt; location retreats\n&#x27;
                           &#x27;        // 5. Text was added/removed on both sides &#x27;
                           &#x27;of the cursor ==&gt; not handled\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int newCursorLocation = cursorLocation;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int deltaLength = newText.length() - &#x27;
                           &#x27;oldText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Case 0\n&#x27;
                           &#x27;        if (newText.length() &lt; cursorLocation)\n&#x27;
                           &#x27;            return newText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        boolean beforeCursorMatches = false;\n&#x27;
                           &#x27;        boolean afterCursorMatches = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            beforeCursorMatches = &#x27;
                           &#x27;oldText.substring(0, &#x27;
                           &#x27;cursorLocation).equals(newText.substring(0, &#x27;
                           &#x27;cursorLocation));\n&#x27;
                           &#x27;            afterCursorMatches = &#x27;
                           &#x27;oldText.substring(cursorLocation, &#x27;
                           &#x27;oldText.length()).equals(newText.substring(cursorLocation &#x27;
                           &#x27;+ deltaLength, newText.length()));\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 2 and 4\n&#x27;
                           &#x27;        if (!beforeCursorMatches &amp;&amp; &#x27;
                           &#x27;afterCursorMatches)\n&#x27;
                           &#x27;            newCursorLocation += deltaLength;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 1, 3 and 5 have no change\n&#x27;
                           &#x27;        return newCursorLocation;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Runnable autoSaveRunnable = new &#x27;
                           &#x27;Runnable() {\n&#x27;
                           &#x27;        @Override\n&#x27;
                           &#x27;        public void run() {\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    };\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTagsChanged(String tagString){\n&#x27;
                           &#x27;        mNote.setTagString(tagString);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;        updateTagList();\n&#x27;
                           &#x27;        mNote.save();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void beforeTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void afterTextChanged(Editable &#x27;
                           &#x27;editable) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // When text changes, start timer that &#x27;
                           &#x27;will fire after AUTOSAVE_DELAY_MILLIS passes\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null) {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.postDelayed(autoSaveRunnable, &#x27;
                           &#x27;AUTOSAVE_DELAY_MILLIS);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void saveAndSyncNote() {\n&#x27;
                           &#x27;        if (mNote == null)\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String content = &#x27;
                           &#x27;mContentEditText.getText().toString();\n&#x27;
                           &#x27;        if (mNote.hasChanges(content, &#x27;
                           &#x27;mPinButton.isChecked())) {\n&#x27;
                           &#x27;            mNote.setContent(content);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setTagString(mTagView.getText().toString());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setPinned(mPinButton.isChecked());\n&#x27;
                           &#x27;            mNote.save();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Log.v(&quot;Simplenote&quot;, &quot;autosaving note&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPlaceholderVisible(boolean &#x27;
                           &#x27;isVisible) {\n&#x27;
                           &#x27;        if (isVisible) {\n&#x27;
                           &#x27;            mNote = null;\n&#x27;
                           &#x27;            mContentEditText.setText(&quot;&quot;);\n&#x27;
                           &#x27;            mTagView.setText(&quot;&quot;);\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.VISIBLE);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // Use spaces in tag autocompletion list\n&#x27;
                           &#x27;    // From &#x27;
                           &#x27;http://stackoverflow.com/questions/3482981/how-to-replace-the-comma-with-a-space-when-i-use-the-multiautocompletetextview\n&#x27;
                           &#x27;    public class SpaceTokenizer implements &#x27;
                           &#x27;Tokenizer {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenStart(CharSequence &#x27;
                           &#x27;text, int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) != &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            while (i &lt; cursor &amp;&amp; text.charAt(i) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i++;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return i;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenEnd(CharSequence text, &#x27;
                           &#x27;int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;            int len = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &lt; len) {\n&#x27;
                           &quot;                if (text.charAt(i) == &#x27; &#x27;) {\n&quot;
                           &#x27;                    return i;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    i++;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return len;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public CharSequence &#x27;
                           &#x27;terminateToken(CharSequence text) {\n&#x27;
                           &#x27;            int i = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &quot;            if (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27; &quot;
                           &quot;&#x27;) {\n&quot;
                           &#x27;                return text;\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                if (text instanceof Spanned) {\n&#x27;
                           &#x27;                    SpannableString sp = new &#x27;
                           &#x27;SpannableString(text + &quot; &quot;);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TextUtils.copySpansFrom((Spanned) text, 0, &#x27;
                           &#x27;text.length(),\n&#x27;
                           &#x27;                            Object.class, sp, 0);\n&#x27;
                           &#x27;                    return sp;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    return text + &quot; &quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;package com.automattic.simplenote;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Calendar;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.app.Fragment;\n&#x27;
                           &#x27;import android.content.Context;\n&#x27;
                           &#x27;import android.os.Bundle;\n&#x27;
                           &#x27;import android.os.Handler;\n&#x27;
                           &#x27;import android.text.Editable;\n&#x27;
                           &#x27;import android.text.SpannableString;\n&#x27;
                           &#x27;import android.text.Spanned;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import android.text.TextWatcher;\n&#x27;
                           &#x27;import android.util.Log;\n&#x27;
                           &#x27;import android.view.LayoutInflater;\n&#x27;
                           &#x27;import android.view.View;\n&#x27;
                           &#x27;import android.view.ViewGroup;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.view.inputmethod.InputMethodManager;\n&#x27;
                           &#x27;import android.widget.ArrayAdapter;\n&#x27;
                           &#x27;import android.widget.EditText;\n&#x27;
                           &#x27;import android.widget.LinearLayout;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;android.widget.MultiAutoCompleteTextView.Tokenizer;\n&#x27;
                           &#x27;import android.widget.ToggleButton;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Note;\n&#x27;
                           &#x27;import com.automattic.simplenote.models.Tag;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;\n&#x27;
                           &#x27;import com.simperium.client.Bucket;\n&#x27;
                           &#x27;import com.simperium.client.Bucket.ObjectCursor;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.simperium.client.BucketObjectMissingException;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class NoteEditorFragment extends Fragment &#x27;
                           &#x27;implements TextWatcher, OnTagAddedListener {\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The fragment argument representing the item &#x27;
                           &#x27;ID that this fragment\n&#x27;
                           &#x27;     * represents.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static final String ARG_ITEM_ID = &#x27;
                           &#x27;&quot;item_id&quot;;\n&#x27;
                           &#x27;    private static final int AUTOSAVE_DELAY_MILLIS &#x27;
                           &#x27;= 2000;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * The dummy content this fragment is &#x27;
                           &#x27;presenting.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private Note mNote;\n&#x27;
                           &#x27;    private EditText mContentEditText;\n&#x27;
                           &#x27;    private TagsMultiAutoCompleteTextView &#x27;
                           &#x27;mTagView;\n&#x27;
                           &#x27;    private ToggleButton mPinButton;\n&#x27;
                           &#x27;    private boolean mShowNoteTitle;\n&#x27;
                           &#x27;    private Handler mAutoSaveHandler;\n&#x27;
                           &#x27;    private LinearLayout mPlaceholderView;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Mandatory empty constructor for the &#x27;
                           &#x27;fragment manager to instantiate the\n&#x27;
                           &#x27;     * fragment (e.g. upon screen orientation &#x27;
                           &#x27;changes).\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public NoteEditorFragment() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onCreate(Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        super.onCreate(savedInstanceState);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (getArguments() != null &amp;&amp; &#x27;
                           &#x27;getArguments().containsKey(ARG_ITEM_ID)) {\n&#x27;
                           &#x27;            Simplenote application = (Simplenote) &#x27;
                           &#x27;getActivity().getApplication();\n&#x27;
                           &#x27;            Bucket&lt;Note&gt; notesBucket = &#x27;
                           &#x27;application.getNotesBucket();\n&#x27;
                           &#x27;            String key = &#x27;
                           &#x27;getArguments().getString(ARG_ITEM_ID);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                mNote = notesBucket.get(key);\n&#x27;
                           &#x27;            } catch (BucketObjectMissingException &#x27;
                           &#x27;e) {\n&#x27;
                           &#x27;                // TODO: Handle a missing note\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreenLandscape())\n&#x27;
                           &#x27;            mShowNoteTitle = true;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mAutoSaveHandler = new Handler();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public View onCreateView(LayoutInflater &#x27;
                           &#x27;inflater, ViewGroup container, Bundle &#x27;
                           &#x27;savedInstanceState) {\n&#x27;
                           &#x27;        View rootView = &#x27;
                           &#x27;inflater.inflate(R.layout.fragment_note_editor, &#x27;
                           &#x27;container, false);\n&#x27;
                           &#x27;        mContentEditText = ((EditText) &#x27;
                           &#x27;rootView.findViewById(R.id.note_content));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mContentEditText.addTextChangedListener(this);\n&#x27;
                           &#x27;        mTagView = (TagsMultiAutoCompleteTextView) &#x27;
                           &#x27;rootView.findViewById(R.id.tag_view);\n&#x27;
                           &#x27;        mTagView.setTokenizer(new &#x27;
                           &#x27;SpaceTokenizer());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mPinButton = (ToggleButton) &#x27;
                           &#x27;rootView.findViewById(R.id.pinButton);\n&#x27;
                           &#x27;        mPlaceholderView = (LinearLayout) &#x27;
                           &#x27;rootView.findViewById(R.id.placeholder);\n&#x27;
                           &#x27;        if (!((NotesActivity) &#x27;
                           &#x27;getActivity()).isLargeScreen())\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\trefreshContent();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn rootView;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onResume() {\n&#x27;
                           &#x27;        super.onResume();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(this);\n&#x27;
                           &#x27;        if (mNote != null &amp;&amp; &#x27;
                           &#x27;mNote.getContent().isEmpty()) {\n&#x27;
                           &#x27;            // Show soft keyboard\n&#x27;
                           &#x27;            mContentEditText.requestFocus();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            InputMethodManager inputMethodManager &#x27;
                           &#x27;= (InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;            if (inputMethodManager != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;inputMethodManager.showSoftInput(mContentEditText, &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onPause() {\n&#x27;
                           &#x27;        saveAndSyncNote();\n&#x27;
                           &#x27;        mTagView.setOnTagAddedListener(null);\n&#x27;
                           &#x27;        // Hide soft keyboard\n&#x27;
                           &#x27;        InputMethodManager inputMethodManager = &#x27;
                           &#x27;(InputMethodManager) &#x27;
                           &#x27;getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n&#x27;
                           &#x27;        if (inputMethodManager != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;inputMethodManager.hideSoftInputFromWindow(mContentEditText.getWindowToken(), &#x27;
                           &#x27;0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null)\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        super.onPause();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setNote(Note note) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // If we have a note already (on a tablet &#x27;
                           &#x27;in landscape), save the note.\n&#x27;
                           &#x27;        if (mNote != null)\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        mNote = note;\n&#x27;
                           &#x27;        refreshContent();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void refreshContent() {\n&#x27;
                           &#x27;        if (mNote != null) {\n&#x27;
                           &#x27;            Log.v(&quot;Simplenote&quot;, &quot;refreshing &#x27;
                           &#x27;content&quot;);\n&#x27;
                           &#x27;            // Restore the cursor position if &#x27;
                           &#x27;possible.\n&#x27;
                           &#x27;            int cursorPosition = &#x27;
                           &#x27;newCursorLocation(mNote.getContent(), &#x27;
                           &#x27;mContentEditText.getText().toString(), &#x27;
                           &#x27;mContentEditText.getSelectionEnd());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mContentEditText.setText(mNote.getContent());\n&#x27;
                           &#x27;            if (mContentEditText.hasFocus() &amp;&amp; &#x27;
                           &#x27;cursorPosition != &#x27;
                           &#x27;mContentEditText.getSelectionEnd())\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mContentEditText.setSelection(cursorPosition);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mPinButton.setChecked(mNote.isPinned());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            updateTagList();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void updateTagList(){\n&#x27;
                           &quot;        // Populate this note&#x27;s tags in the &quot;
                           &#x27;tagView\n&#x27;
                           &#x27;        mTagView.setChips(mNote.getTagString());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t// Populate tag list\n&#x27;
                           &#x27;        Simplenote simplenote = &#x27;
                           &#x27;(Simplenote)getActivity().getApplication();\n&#x27;
                           &#x27;        Bucket&lt;Tag&gt; tagBucket = &#x27;
                           &#x27;simplenote.getTagsBucket();\n&#x27;
                           &#x27;        ObjectCursor&lt;Tag&gt; tagsCursor = &#x27;
                           &#x27;tagBucket.query().orderByKey().execute();\n&#x27;
                           &#x27;        List&lt;String&gt; allTags = new &#x27;
                           &#x27;ArrayList&lt;String&gt;(tagsCursor.getCount());\n&#x27;
                           &#x27;        while (tagsCursor.moveToNext()) {\n&#x27;
                           &#x27;            Tag tag = tagsCursor.getObject();\n&#x27;
                           &#x27;            if (!mNote.hasTag(tag)) &#x27;
                           &#x27;allTags.add(tag.getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        tagsCursor.close();\n&#x27;
                           &#x27;        ArrayAdapter&lt;String&gt; adapter = new &#x27;
                           &#x27;ArrayAdapter&lt;String&gt;(getActivity(),\n&#x27;
                           &#x27;                &#x27;
                           &#x27;android.R.layout.simple_dropdown_item_1line, &#x27;
                           &#x27;allTags);\n&#x27;
                           &#x27;        mTagView.setAdapter(adapter);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void setActionBarTitle() {\n&#x27;
                           &#x27;        if (mShowNoteTitle) {\n&#x27;
                           &#x27;            if (mNote.getTitle() != null &amp;&amp; &#x27;
                           &#x27;!mNote.getTitle().equals(&quot;&quot;))\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(mNote.getTitle());\n&#x27;
                           &#x27;            else\n&#x27;
                           &#x27;                &#x27;
                           &#x27;getActivity().getActionBar().setTitle(R.string.new_note);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int newCursorLocation(String newText, String &#x27;
                           &#x27;oldText, int cursorLocation) {\n&#x27;
                           &#x27;        // Ported from the iOS app :)\n&#x27;
                           &#x27;        // Cases:\n&#x27;
                           &#x27;        // 0. All text after cursor (and possibly &#x27;
                           &#x27;more) was removed ==&gt; put cursor at end\n&#x27;
                           &#x27;        // 1. Text was added after the cursor ==&gt; &#x27;
                           &#x27;no change\n&#x27;
                           &#x27;        // 2. Text was added before the cursor ==&gt; &#x27;
                           &#x27;location advances\n&#x27;
                           &#x27;        // 3. Text was removed after the cursor &#x27;
                           &#x27;==&gt; no change\n&#x27;
                           &#x27;        // 4. Text was removed before the cursor &#x27;
                           &#x27;==&gt; location retreats\n&#x27;
                           &#x27;        // 5. Text was added/removed on both sides &#x27;
                           &#x27;of the cursor ==&gt; not handled\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int newCursorLocation = cursorLocation;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        int deltaLength = newText.length() - &#x27;
                           &#x27;oldText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Case 0\n&#x27;
                           &#x27;        if (newText.length() &lt; cursorLocation)\n&#x27;
                           &#x27;            return newText.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        boolean beforeCursorMatches = false;\n&#x27;
                           &#x27;        boolean afterCursorMatches = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            beforeCursorMatches = &#x27;
                           &#x27;oldText.substring(0, &#x27;
                           &#x27;cursorLocation).equals(newText.substring(0, &#x27;
                           &#x27;cursorLocation));\n&#x27;
                           &#x27;            afterCursorMatches = &#x27;
                           &#x27;oldText.substring(cursorLocation, &#x27;
                           &#x27;oldText.length()).equals(newText.substring(cursorLocation &#x27;
                           &#x27;+ deltaLength, newText.length()));\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 2 and 4\n&#x27;
                           &#x27;        if (!beforeCursorMatches &amp;&amp; &#x27;
                           &#x27;afterCursorMatches)\n&#x27;
                           &#x27;            newCursorLocation += deltaLength;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Cases 1, 3 and 5 have no change\n&#x27;
                           &#x27;        return newCursorLocation;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Runnable autoSaveRunnable = new &#x27;
                           &#x27;Runnable() {\n&#x27;
                           &#x27;        @Override\n&#x27;
                           &#x27;        public void run() {\n&#x27;
                           &#x27;            saveAndSyncNote();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    };\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTagsChanged(String tagString){\n&#x27;
                           &#x27;        mNote.setTagString(tagString);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;        updateTagList();\n&#x27;
                           &#x27;        mNote.save();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void beforeTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void afterTextChanged(Editable &#x27;
                           &#x27;editable) {\n&#x27;
                           &#x27;        // Unused\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onTextChanged(CharSequence &#x27;
                           &#x27;charSequence, int i, int i2, int i3) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // When text changes, start timer that &#x27;
                           &#x27;will fire after AUTOSAVE_DELAY_MILLIS passes\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (mAutoSaveHandler != null) {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.removeCallbacks(autoSaveRunnable);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mAutoSaveHandler.postDelayed(autoSaveRunnable, &#x27;
                           &#x27;AUTOSAVE_DELAY_MILLIS);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void saveAndSyncNote() {\n&#x27;
                           &#x27;        if (mNote == null)\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String content = &#x27;
                           &#x27;mContentEditText.getText().toString();\n&#x27;
                           &#x27;        if (mNote.hasChanges(content, &#x27;
                           &#x27;mPinButton.isChecked())) {\n&#x27;
                           &#x27;            mNote.setContent(content);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setTagString(mTagView.getText().toString());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setModificationDate(Calendar.getInstance());\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mNote.setPinned(mPinButton.isChecked());\n&#x27;
                           &#x27;            mNote.save();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        setActionBarTitle();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Log.v(&quot;Simplenote&quot;, &quot;autosaving note&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPlaceholderVisible(boolean &#x27;
                           &#x27;isVisible) {\n&#x27;
                           &#x27;        if (isVisible) {\n&#x27;
                           &#x27;            mNote = null;\n&#x27;
                           &#x27;            mContentEditText.setText(&quot;&quot;);\n&#x27;
                           &#x27;            mTagView.setText(&quot;&quot;);\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.VISIBLE);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            if (mPlaceholderView != null)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mPlaceholderView.setVisibility(View.GONE);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // Use spaces in tag autocompletion list\n&#x27;
                           &#x27;    // From &#x27;
                           &#x27;http://stackoverflow.com/questions/3482981/how-to-replace-the-comma-with-a-space-when-i-use-the-multiautocompletetextview\n&#x27;
                           &#x27;    public class SpaceTokenizer implements &#x27;
                           &#x27;Tokenizer {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenStart(CharSequence &#x27;
                           &#x27;text, int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) != &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            while (i &lt; cursor &amp;&amp; text.charAt(i) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i++;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return i;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public int findTokenEnd(CharSequence text, &#x27;
                           &#x27;int cursor) {\n&#x27;
                           &#x27;            int i = cursor;\n&#x27;
                           &#x27;            int len = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &lt; len) {\n&#x27;
                           &quot;                if (text.charAt(i) == &#x27; &#x27;) {\n&quot;
                           &#x27;                    return i;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    i++;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return len;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        public CharSequence &#x27;
                           &#x27;terminateToken(CharSequence text) {\n&#x27;
                           &#x27;            int i = text.length();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            while (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27;
                           &quot;&#x27; &#x27;) {\n&quot;
                           &#x27;                i--;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &quot;            if (i &gt; 0 &amp;&amp; text.charAt(i - 1) == &#x27; &quot;
                           &quot;&#x27;) {\n&quot;
                           &#x27;                return text;\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                if (text instanceof Spanned) {\n&#x27;
                           &#x27;                    SpannableString sp = new &#x27;
                           &#x27;SpannableString(text + &quot; &quot;);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TextUtils.copySpansFrom((Spanned) text, 0, &#x27;
                           &#x27;text.length(),\n&#x27;
                           &#x27;                            Object.class, sp, 0);\n&#x27;
                           &#x27;                    return sp;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    return text + &quot; &quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        