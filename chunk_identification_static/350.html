<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>350</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    350
                    <a href="349.html">prev</a>
                    <a href="351.html">next</a>
                    <a href="350_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_e6ed3988bac4d4b13794dd43536bb6267a88aa12_rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e6ed3988bac4d4b13794dd43536bb6267a88aa12:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e6ed3988bac4d4b13794dd43536bb6267a88aa12^1:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e6ed3988bac4d4b13794dd43536bb6267a88aa12^2:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;25fadc462a51b3a20e02d1882eb9e208ad803b99:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/all/AbstractRdbAllReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.rdb.all;
  20 
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.BaseSideInfo;
  23 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  24 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  25 import com.dtstack.flink.sql.util.RowDataComplete;
  26 import com.dtstack.flink.sql.util.RowDataConvert;
  27 import com.google.common.collect.Lists;
  28 import com.google.common.collect.Maps;
  29 import org.apache.calcite.sql.JoinType;
  30 import org.apache.commons.collections.CollectionUtils;
  31 import org.apache.commons.lang3.StringUtils;
  32 import org.apache.flink.api.common.typeinfo.TypeInformation;
  33 import org.apache.flink.configuration.Configuration;
  34 import org.apache.flink.table.dataformat.BaseRow;
  35 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  36 import org.apache.flink.types.Row;
  37 import org.apache.flink.util.Collector;
  38 import org.slf4j.Logger;
  39 import org.slf4j.LoggerFactory;
  40 
  41 import java.sql.*;
  42 import java.time.LocalDateTime;
  43 import java.util.ArrayList;
  44 import java.util.Calendar;
  45 import java.util.HashMap;
  46 import java.util.List;
  47 import java.util.Map;
  48 import java.util.Objects;
  49 import java.util.concurrent.atomic.AtomicReference;
  50 import java.util.stream.Collectors;
  51 
  52 /**
  53  * side operator with cache for all(period reload)
  54  * Date: 2018/11/26
  55  * Company: www.dtstack.com
  56  *
  57  * @author maqi
  58  */
  59 
  60 public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  61 
  62     private static final long serialVersionUID = 2098635140857937718L;
  63 
  64     private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  65 
  66     private static final int CONN_RETRY_NUM = 3;
  67 
  68     private static final int DEFAULT_FETCH_SIZE = 1000;
  69 
  70     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  71 
  72     public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  73         super(sideInfo);
  74     }
  75 
  76     @Override
  77     public void open(Configuration parameters) throws Exception {
  78         super.open(parameters);
  79         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  80         LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  81     }
  82 
  83     @Override
  84     protected void initCache() throws SQLException {
  85         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  86         cacheRef.set(newCache);
  87         loadData(newCache);
  88     }
  89 
  90     @Override
  91     protected void reloadCache() {
  92         //reload cacheRef and replace to old cacheRef
  93         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  94         try {
  95             loadData(newCache);
  96         } catch (SQLException e) {
  97             throw new RuntimeException(e);
  98         }
  99         cacheRef.set(newCache);
 100         LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
 101     }
 102 
 103     @Override
 104     public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {
 105         List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
 106         ArrayList&lt;Object&gt; inputParams = equalValIndex.stream()
 107                 .map(value::getField)
 108                 .filter(Objects::nonNull)
 109                 .collect(Collectors.toCollection(ArrayList::new));
 110 
 111         if (inputParams.size() != equalValIndex.size() &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 112             Row row = fillData(value, null);
 113             RowDataComplete.collectRow(out, row);
 114             return;
 115         }
 116 
 117         String cacheKey = inputParams.stream()
 118                 .map(Object::toString)
 119                 .collect(Collectors.joining(&quot;_&quot;));
 120 
 121         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 122         if (CollectionUtils.isEmpty(cacheList) &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 123             Row row = fillData(value, null);
 124             RowDataComplete.collectRow(out, row);
 125         } else if (!CollectionUtils.isEmpty(cacheList)) {
 126             cacheList.forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));
 127         }
 128     }
 129 
 130 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 131     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 134         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 135 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 136         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 137             // origin value</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 138             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 139             obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(), obj);"> 139             obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(),🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 140             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 141         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 142 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 143         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 144             if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 145                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 148             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 149 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 150         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 151         return row;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 152     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 153 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 154     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 155      * covert flink time attribute.Type information for indicating event or processing time.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 156      * However, it behaves like a regular SQL timestamp but is serialized as Long.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 157      *</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 158      * @param entry</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 159      * @param obj</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 160      * @return</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 161      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 162     protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 163         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 164         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 165             //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 166             obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 167         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 168         return obj;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 169     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 170 </span>
 171 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 173     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178             // origin value</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 179             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 180             obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(), obj);"> 180             obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(),🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 181             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185             if (cacheInfo == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192         return row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196      * covert flink time attribute.Type information for indicating event or processing time.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197      * However, it behaves like a regular SQL timestamp but is serialized as Long.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199      * @param entry</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200      * @param obj</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201      * @return</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203     protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206             obj = Timestamp.valueOf(((LocalDateTime) obj));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208         return obj;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {</span>
 212 =======
 213 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 214     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 215         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 216         Connection connection = null;
 217 
 218         try {
 219             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 220                 try {
<abbr title=" 221                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());"> 221                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPasswo🔵</abbr>
 222                     break;
 223                 } catch (Exception e) {
 224                     if (i == CONN_RETRY_NUM - 1) {
 225                         throw new RuntimeException(&quot;&quot;, e);
 226                     }
 227                     try {
<abbr title=" 228                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 228                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserN🔵</abbr>
 229                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 230                         Thread.sleep(5 * 1000);
 231                     } catch (InterruptedException e1) {
 232                         LOG.error(&quot;&quot;, e1);
 233                     }
 234                 }
 235             }
 236             queryAndFillData(tmpCache, connection);
 237         } catch (Exception e) {
 238             LOG.error(&quot;&quot;, e);
 239             throw new SQLException(e);
 240         } finally {
 241             if (connection != null) {
 242                 connection.close();
 243             }
 244         }
 245     }
 246 
<abbr title=" 247     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 247     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection)🔵</abbr>
 248         //load data from table
 249         String sql = sideInfo.getSqlCondition();
 250         Statement statement = connection.createStatement();
 251         statement.setFetchSize(getFetchSize());
 252         ResultSet resultSet = statement.executeQuery(sql);
 253 
 254         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 255         String[] sideFieldTypes = sideInfo.getSideTableInfo().getFieldTypes();
 256         Map&lt;String, String&gt; sideFieldNamesAndTypes = Maps.newHashMap();
 257         for (int i = 0; i &lt; sideFieldNames.length; i++) {
 258             sideFieldNamesAndTypes.put(sideFieldNames[i], sideFieldTypes[i]);
 259         }
 260 
 261         while (resultSet.next()) {
 262             Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 263             for (String fieldName : sideFieldNames) {
 264                 Object object = resultSet.getObject(fieldName.trim());
 265                 object = SwitchUtil.getTarget(object, sideFieldNamesAndTypes.get(fieldName));
 266                 oneRow.put(fieldName.trim(), object);
 267             }
 268 
 269             String cacheKey = sideInfo.getEqualFieldList().stream()
 270                     .map(oneRow::get)
 271                     .map(Object::toString)
 272                     .collect(Collectors.joining(&quot;_&quot;));
 273 
 274             tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList())
 275                     .add(oneRow);
 276         }
 277     }
 278 
 279     public int getFetchSize() {
 280         return DEFAULT_FETCH_SIZE;
 281     }
 282 
 283     /**
 284      * get jdbc connection
 285      *
 286      * @param dbURL
 287      * @param userName
 288      * @param password
 289      * @return
 290      */
 291     public abstract Connection getConn(String dbURL, String userName, String password);
 292 
 293 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.rdb.all;
  20 
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.BaseSideInfo;
  23 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  24 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  25 import com.dtstack.flink.sql.util.RowDataComplete;
  26 import com.dtstack.flink.sql.util.RowDataConvert;
  27 import com.google.common.collect.Lists;
  28 import com.google.common.collect.Maps;
  29 import org.apache.calcite.sql.JoinType;
  30 import org.apache.commons.collections.CollectionUtils;
  31 import org.apache.commons.lang3.StringUtils;
  32 import org.apache.flink.api.common.typeinfo.TypeInformation;
  33 import org.apache.flink.configuration.Configuration;
  34 import org.apache.flink.table.dataformat.BaseRow;
  35 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  36 import org.apache.flink.types.Row;
  37 import org.apache.flink.util.Collector;
  38 import org.slf4j.Logger;
  39 import org.slf4j.LoggerFactory;
  40 
  41 import java.sql.*;
  42 import java.time.LocalDateTime;
  43 import java.util.ArrayList;
  44 import java.util.Calendar;
  45 import java.util.HashMap;
  46 import java.util.List;
  47 import java.util.Map;
  48 import java.util.Objects;
  49 import java.util.concurrent.atomic.AtomicReference;
  50 import java.util.stream.Collectors;
  51 
  52 /**
  53  * side operator with cache for all(period reload)
  54  * Date: 2018/11/26
  55  * Company: www.dtstack.com
  56  *
  57  * @author maqi
  58  */
  59 
  60 public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  61 
  62     private static final long serialVersionUID = 2098635140857937718L;
  63 
  64     private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  65 
  66     private static final int CONN_RETRY_NUM = 3;
  67 
  68     private static final int DEFAULT_FETCH_SIZE = 1000;
  69 
  70     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  71 
  72     public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  73         super(sideInfo);
  74     }
  75 
  76     @Override
  77     public void open(Configuration parameters) throws Exception {
  78         super.open(parameters);
  79         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  80         LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  81     }
  82 
  83     @Override
  84     protected void initCache() throws SQLException {
  85         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  86         cacheRef.set(newCache);
  87         loadData(newCache);
  88     }
  89 
  90     @Override
  91     protected void reloadCache() {
  92         //reload cacheRef and replace to old cacheRef
  93         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  94         try {
  95             loadData(newCache);
  96         } catch (SQLException e) {
  97             throw new RuntimeException(e);
  98         }
  99         cacheRef.set(newCache);
 100         LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
 101     }
 102 
 103     @Override
 104     public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {
 105         List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
 106         ArrayList&lt;Object&gt; inputParams = equalValIndex.stream()
 107                 .map(value::getField)
 108                 .filter(Objects::nonNull)
 109                 .collect(Collectors.toCollection(ArrayList::new));
 110 
 111         if (inputParams.size() != equalValIndex.size() &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 112             Row row = fillData(value, null);
 113             RowDataComplete.collectRow(out, row);
 114             return;
 115         }
 116 
 117         String cacheKey = inputParams.stream()
 118                 .map(Object::toString)
 119                 .collect(Collectors.joining(&quot;_&quot;));
 120 
 121         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 122         if (CollectionUtils.isEmpty(cacheList) &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 123             Row row = fillData(value, null);
 124             RowDataComplete.collectRow(out, row);
 125         } else if (!CollectionUtils.isEmpty(cacheList)) {
 126             cacheList.forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));
 127         }
 128     }
 129 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 130 protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 131         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133             //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 134             obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 135         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 136         return obj;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 137     }</span>
 138 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 139 protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 140         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 141         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 142             obj = Timestamp.valueOf(((LocalDateTime) obj));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 143         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 144         return obj;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 145     }</span>
 146 =======
 147 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 148 
 149 
 150     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 151         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 152         Connection connection = null;
 153 
 154         try {
 155             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 156                 try {
<abbr title=" 157                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());"> 157                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPasswo🔵</abbr>
 158                     break;
 159                 } catch (Exception e) {
 160                     if (i == CONN_RETRY_NUM - 1) {
 161                         throw new RuntimeException(&quot;&quot;, e);
 162                     }
 163                     try {
<abbr title=" 164                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 164                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserN🔵</abbr>
 165                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 166                         Thread.sleep(5 * 1000);
 167                     } catch (InterruptedException e1) {
 168                         LOG.error(&quot;&quot;, e1);
 169                     }
 170                 }
 171             }
 172             queryAndFillData(tmpCache, connection);
 173         } catch (Exception e) {
 174             LOG.error(&quot;&quot;, e);
 175             throw new SQLException(e);
 176         } finally {
 177             if (connection != null) {
 178                 connection.close();
 179             }
 180         }
 181     }
 182 
<abbr title=" 183     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 183     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection)🔵</abbr>
 184         //load data from table
 185         String sql = sideInfo.getSqlCondition();
 186         Statement statement = connection.createStatement();
 187         statement.setFetchSize(getFetchSize());
 188         ResultSet resultSet = statement.executeQuery(sql);
 189 
 190         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 191         String[] sideFieldTypes = sideInfo.getSideTableInfo().getFieldTypes();
 192         Map&lt;String, String&gt; sideFieldNamesAndTypes = Maps.newHashMap();
 193         for (int i = 0; i &lt; sideFieldNames.length; i++) {
 194             sideFieldNamesAndTypes.put(sideFieldNames[i], sideFieldTypes[i]);
 195         }
 196 
 197         while (resultSet.next()) {
 198             Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 199             for (String fieldName : sideFieldNames) {
 200                 Object object = resultSet.getObject(fieldName.trim());
 201                 object = SwitchUtil.getTarget(object, sideFieldNamesAndTypes.get(fieldName));
 202                 oneRow.put(fieldName.trim(), object);
 203             }
 204 
 205             String cacheKey = sideInfo.getEqualFieldList().stream()
 206                     .map(oneRow::get)
 207                     .map(Object::toString)
 208                     .collect(Collectors.joining(&quot;_&quot;));
 209 
 210             tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList())
 211                     .add(oneRow);
 212         }
 213     }
 214 
 215     public int getFetchSize() {
 216         return DEFAULT_FETCH_SIZE;
 217     }
 218 
 219     /**
 220      * get jdbc connection
 221      *
 222      * @param dbURL
 223      * @param userName
 224      * @param password
 225      * @return
 226      */
 227     public abstract Connection getConn(String dbURL, String userName, String password);
 228 
 229 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.rdb.all;
  19 
  20 import com.dtstack.flink.sql.side.BaseAllReqRow;
  21 import com.dtstack.flink.sql.side.BaseSideInfo;
  22 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  23 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  24 import com.dtstack.flink.sql.util.RowDataComplete;
  25 import com.dtstack.flink.sql.util.RowDataConvert;
  26 import com.google.common.collect.Lists;
  27 import com.google.common.collect.Maps;
  28 import java.sql.*;
  29 import java.time.LocalDateTime;
  30 import java.util.ArrayList;
  31 import java.util.Calendar;
  32 import java.util.HashMap;
  33 import java.util.List;
  34 import java.util.Map;
  35 import java.util.Objects;
  36 import java.util.concurrent.atomic.AtomicReference;
  37 import java.util.stream.Collectors;
  38 import org.apache.calcite.sql.JoinType;
  39 import org.apache.commons.collections.CollectionUtils;
  40 import org.apache.commons.lang3.StringUtils;
  41 import org.apache.flink.api.common.typeinfo.TypeInformation;
  42 import org.apache.flink.configuration.Configuration;
  43 import org.apache.flink.table.dataformat.BaseRow;
  44 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  45 import org.apache.flink.types.Row;
  46 import org.apache.flink.util.Collector;
  47 import org.slf4j.Logger;
  48 import org.slf4j.LoggerFactory;
  49 
  50 
  51 /**
  52  * side operator with cache for all(period reload)
  53  * Date: 2018/11/26
  54  * Company: www.dtstack.com
  55  *
  56  * @author maqi
  57  */
  58 public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  59     private static final long serialVersionUID = 2098635140857937718L;
  60 
  61     private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  62 
  63     private static final int CONN_RETRY_NUM = 3;
  64 
  65     private static final int DEFAULT_FETCH_SIZE = 1000;
  66 
  67     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  68 
  69     public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  70         super(sideInfo);
  71     }
  72 
  73     @Override
  74     public void open(Configuration parameters) throws Exception {
  75         super.open(parameters);
  76         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  77         LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  78     }
  79 
  80     @Override
  81     protected void initCache() throws SQLException {
  82         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  83         cacheRef.set(newCache);
  84         loadData(newCache);
  85     }
  86 
  87     @Override
  88     protected void reloadCache() {
  89         //reload cacheRef and replace to old cacheRef
  90         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  91         try {
  92             loadData(newCache);
  93         } catch (SQLException e) {
  94             throw new RuntimeException(e);
  95         }
  96         cacheRef.set(newCache);
  97         LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
  98     }
  99 
 100     @Override
 101     public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {
 102         List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
<abbr title=" 103         ArrayList&lt;Object&gt; inputParams = equalValIndex.stream().map(value::getField).filter(Objects::nonNull).collect(Collectors.toCollection(ArrayList::new));"> 103         ArrayList&lt;Object&gt; inputParams = equalValIndex.stream().map(value::getField).filter(Objects::nonNu🔵</abbr>
 104         if ((inputParams.size() != equalValIndex.size()) &amp;&amp; (sideInfo.getJoinType() == JoinType.LEFT)) {
 105             Row row = fillData(value, null);
 106             RowDataComplete.collectRow(out, row);
 107             return;
 108         }
 109         String cacheKey = inputParams.stream().map(Object::toString).collect(Collectors.joining(&quot;_&quot;));
 110         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 111         if (CollectionUtils.isEmpty(cacheList) &amp;&amp; (sideInfo.getJoinType() == JoinType.LEFT)) {
 112             Row row = fillData(value, null);
 113             RowDataComplete.collectRow(out, row);
 114         } else if (!CollectionUtils.isEmpty(cacheList)) {
<abbr title=" 115             cacheList.forEach(( one) -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));"> 115             cacheList.forEach(( one) -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))🔵</abbr>
 116         }
 117     }
 118 
 119     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 120         RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 121         Connection connection = null;
 122 
 123         try {
 124             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 125                 try {
<abbr title=" 126                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());"> 126                     connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPasswo🔵</abbr>
 127                     break;
 128                 } catch (Exception e) {
 129                     if (i == CONN_RETRY_NUM - 1) {
 130                         throw new RuntimeException(&quot;&quot;, e);
 131                     }
 132                     try {
<abbr title=" 133                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 133                         String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserN🔵</abbr>
 134                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 135                         Thread.sleep(5 * 1000);
 136                     } catch (InterruptedException e1) {
 137                         LOG.error(&quot;&quot;, e1);
 138                     }
 139                 }
 140             }
 141             queryAndFillData(tmpCache, connection);
 142         } catch (Exception e) {
 143             LOG.error(&quot;&quot;, e);
 144             throw new SQLException(e);
 145         } finally {
 146             if (connection != null) {
 147                 connection.close();
 148             }
 149         }
 150     }
 151 
<abbr title=" 152     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 152     private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection)🔵</abbr>
 153         // load data from table
 154         String sql = sideInfo.getSqlCondition();
 155         Statement statement = connection.createStatement();
 156         statement.setFetchSize(getFetchSize());
 157         ResultSet resultSet = statement.executeQuery(sql);
 158         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 159         String[] sideFieldTypes = sideInfo.getSideTableInfo().getFieldTypes();
 160         Map&lt;String, String&gt; sideFieldNamesAndTypes = Maps.newHashMap();
 161         for (int i = 0; i &lt; sideFieldNames.length; i++) {
 162             sideFieldNamesAndTypes.put(sideFieldNames[i], sideFieldTypes[i]);
 163         }
 164         while (resultSet.next()) {
 165             Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 166             for (String fieldName : sideFieldNames) {
 167                 Object object = resultSet.getObject(fieldName.trim());
 168                 object = SwitchUtil.getTarget(object, sideFieldNamesAndTypes.get(fieldName));
 169                 oneRow.put(fieldName.trim(), object);
 170             }
<abbr title=" 171             String cacheKey = sideInfo.getEqualFieldList().stream().map(oneRow::get).map(Object::toString).collect(Collectors.joining(&quot;_&quot;));"> 171             String cacheKey = sideInfo.getEqualFieldList().stream().map(oneRow::get).map(Object::toString🔵</abbr>
 172             tmpCache.computeIfAbsent(cacheKey, ( key) -&gt; Lists.newArrayList()).add(oneRow);
 173         }
 174     }
 175 
 176     public int getFetchSize() {
 177         return DEFAULT_FETCH_SIZE;
 178     }
 179 
 180     /**
 181      * get jdbc connection
 182      *
 183      * @param dbURL
 184      * @param userName
 185      * @param password
 186      * @return
 187      */
 188     public abstract Connection getConn(String dbURL, String userName, String password);
 189 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.rdb.all;
  20  
  21  import com.dtstack.flink.sql.side.BaseAllReqRow;
  22  import com.dtstack.flink.sql.side.BaseSideInfo;
  23  import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  24  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  25  import com.dtstack.flink.sql.util.RowDataComplete;
  26  import com.dtstack.flink.sql.util.RowDataConvert;
  27  import com.google.common.collect.Lists;
  28  import com.google.common.collect.Maps;
  29  import org.apache.calcite.sql.JoinType;
  30  import org.apache.commons.collections.CollectionUtils;
  31  import org.apache.commons.lang3.StringUtils;
  32  import org.apache.flink.api.common.typeinfo.TypeInformation;
  33  import org.apache.flink.configuration.Configuration;
  34  import org.apache.flink.table.dataformat.BaseRow;
  35  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  36  import org.apache.flink.types.Row;
  37  import org.apache.flink.util.Collector;
  38  import org.slf4j.Logger;
  39  import org.slf4j.LoggerFactory;
  40  
  41  import java.sql.*;
  42  import java.time.LocalDateTime;
  43  import java.util.ArrayList;
  44  import java.util.Calendar;

  45  import java.util.List;
  46  import java.util.Map;

  47  import java.util.concurrent.atomic.AtomicReference;
  48  import java.util.stream.Collectors;
  49  
  50  /**
  51   * side operator with cache for all(period reload)
  52   * Date: 2018/11/26
  53   * Company: www.dtstack.com
  54   *
  55   * @author maqi
  56   */
  57  
  58  public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  59  
  60      private static final long serialVersionUID = 2098635140857937718L;
  61  
  62      private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  63  
  64      private static final int CONN_RETRY_NUM = 3;
  65  
  66      private static final int DEFAULT_FETCH_SIZE = 1000;
  67  
  68      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  69  
  70      public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  71          super(sideInfo);
  72      }
  73  
  74      @Override
  75      public void open(Configuration parameters) throws Exception {
  76          super.open(parameters);
  77          RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  78          LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  79      }
  80  
  81      @Override
  82      protected void initCache() throws SQLException {
  83          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  84          cacheRef.set(newCache);
  85          loadData(newCache);
  86      }
  87  
  88      @Override
  89      protected void reloadCache() {
  90          //reload cacheRef and replace to old cacheRef
  91          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  92          try {
  93              loadData(newCache);
  94          } catch (SQLException e) {
  95              throw new RuntimeException(e);
  96          }
  97          cacheRef.set(newCache);
  98          LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
  99      }
 100  
 101      @Override
 102      public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {
 103          List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
 104          ArrayList&lt;Object&gt; inputParams = equalValIndex.stream()
 105                  .map(value::getField)
 106                  .filter(object -&gt; null != object)

 107                  .collect(Collectors.toCollection(ArrayList::new));
 108  
 109          if (inputParams.size() != equalValIndex.size() &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 110              Row row = fillData(value, null);
 111              RowDataComplete.collectRow(out, row);
 112              return;
 113          }
 114  
 115          String cacheKey = inputParams.stream()
 116                  .map(Object::toString)
 117                  .collect(Collectors.joining(&quot;_&quot;));
 118  
 119          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 120          if (CollectionUtils.isEmpty(cacheList) &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 121              Row row = fillData(value, null);
 122              RowDataComplete.collectRow(out, row);
 123          } else if (!CollectionUtils.isEmpty(cacheList)) {
 124              cacheList.stream().forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));
 125          }
 126      }
 127  
 128      @Override
 129      public Row fillData(Row input, Object sideInput) {
 130          Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
 131          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 132  
 133          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 134              // origin value
 135              Object obj = input.getField(entry.getValue());
 136              obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(), obj);
 137              row.setField(entry.getKey(), obj);
 138          }
 139  
 140          for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
 141              if (cacheInfo == null) {
 142                  row.setField(entry.getKey(), null);
 143              } else {
 144                  row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 145              }
 146  
 147          }
 148          return row;
 149      }
 150  
 151      /**
 152       * covert flink time attribute.Type information for indicating event or processing time.
 153       * However, it behaves like a regular SQL timestamp but is serialized as Long.
 154       *
 155       * @param entry
 156       * @param obj
 157       * @return
 158       */
 159      protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {
 160          boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);
 161          if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -            obj = Timestamp.valueOf(((LocalDateTime) obj));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +            //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +            obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
 165          }
 166          return obj;


 167      }
 168  
 169      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 170          RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 171          Connection connection = null;
 172  
 173          try {
 174              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 175                  try {
 176                      connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());
 177                      break;
 178                  } catch (Exception e) {
 179                      if (i == CONN_RETRY_NUM - 1) {
 180                          throw new RuntimeException(&quot;&quot;, e);
 181                      }
 182                      try {
<abbr title=" 183                          String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 183                          String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;🔵</abbr>
 184                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 185                          Thread.sleep(5 * 1000);
 186                      } catch (InterruptedException e1) {
 187                          LOG.error(&quot;&quot;, e1);
 188                      }
 189                  }
 190              }
 191              queryAndFillData(tmpCache, connection);
 192          } catch (Exception e) {
 193              LOG.error(&quot;&quot;, e);
 194              throw new SQLException(e);
 195          } finally {
 196              if (connection != null) {
 197                  connection.close();
 198              }
 199          }
 200      }
 201  
<abbr title=" 202      private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 202      private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws S🔵</abbr>
 203          //load data from table
 204          String sql = sideInfo.getSqlCondition();
 205          Statement statement = connection.createStatement();
 206          statement.setFetchSize(getFetchSize());
 207          ResultSet resultSet = statement.executeQuery(sql);
 208  
 209          String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 210          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();






 211          while (resultSet.next()) {
 212              Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 213              for (String fieldName : sideFieldNames) {
 214                  Object object = resultSet.getObject(fieldName.trim());
 215                  int fieldIndex = sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());
 216                  object = SwitchUtil.getTarget(object, fields[fieldIndex]);

 217                  oneRow.put(fieldName.trim(), object);
 218              }
 219  
 220              String cacheKey = sideInfo.getEqualFieldList().stream()
 221                      .map(oneRow::get)
 222                      .map(Object::toString)
 223                      .collect(Collectors.joining(&quot;_&quot;));
 224  
 225              tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList())
 226                      .add(oneRow);
 227          }
 228      }
 229  
 230      public int getFetchSize() {
 231          return DEFAULT_FETCH_SIZE;
 232      }
 233  
 234      /**
 235       * get jdbc connection
 236       *
 237       * @param dbURL
 238       * @param userName
 239       * @param password
 240       * @return
 241       */
 242      public abstract Connection getConn(String dbURL, String userName, String password);
 243  
 244  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.rdb.all;
  20  
  21  import com.dtstack.flink.sql.side.BaseAllReqRow;
  22  import com.dtstack.flink.sql.side.BaseSideInfo;
  23  import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  24  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  25  import com.dtstack.flink.sql.util.RowDataComplete;
  26  import com.dtstack.flink.sql.util.RowDataConvert;
  27  import com.google.common.collect.Lists;
  28  import com.google.common.collect.Maps;
  29  import org.apache.calcite.sql.JoinType;
  30  import org.apache.commons.collections.CollectionUtils;
  31  import org.apache.commons.lang3.StringUtils;
  32  import org.apache.flink.api.common.typeinfo.TypeInformation;
  33  import org.apache.flink.configuration.Configuration;
  34  import org.apache.flink.table.dataformat.BaseRow;
  35  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  36  import org.apache.flink.types.Row;
  37  import org.apache.flink.util.Collector;
  38  import org.slf4j.Logger;
  39  import org.slf4j.LoggerFactory;
  40  
  41  import java.sql.*;
  42  import java.time.LocalDateTime;
  43  import java.util.ArrayList;
  44  import java.util.Calendar;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import java.util.HashMap;</span>
  46  import java.util.List;
  47  import java.util.Map;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import java.util.Objects;</span>
  49  import java.util.concurrent.atomic.AtomicReference;
  50  import java.util.stream.Collectors;
  51  
  52  /**
  53   * side operator with cache for all(period reload)
  54   * Date: 2018/11/26
  55   * Company: www.dtstack.com
  56   *
  57   * @author maqi
  58   */
  59  
  60  public abstract class AbstractRdbAllReqRow extends BaseAllReqRow {
  61  
  62      private static final long serialVersionUID = 2098635140857937718L;
  63  
  64      private static final Logger LOG = LoggerFactory.getLogger(AbstractRdbAllReqRow.class);
  65  
  66      private static final int CONN_RETRY_NUM = 3;
  67  
  68      private static final int DEFAULT_FETCH_SIZE = 1000;
  69  
  70      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  71  
  72      public AbstractRdbAllReqRow(BaseSideInfo sideInfo) {
  73          super(sideInfo);
  74      }
  75  
  76      @Override
  77      public void open(Configuration parameters) throws Exception {
  78          super.open(parameters);
  79          RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  80          LOG.info(&quot;rdb dim table config info: {} &quot;, tableInfo.toString());
  81      }
  82  
  83      @Override
  84      protected void initCache() throws SQLException {
  85          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  86          cacheRef.set(newCache);
  87          loadData(newCache);
  88      }
  89  
  90      @Override
  91      protected void reloadCache() {
  92          //reload cacheRef and replace to old cacheRef
  93          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  94          try {
  95              loadData(newCache);
  96          } catch (SQLException e) {
  97              throw new RuntimeException(e);
  98          }
  99          cacheRef.set(newCache);
 100          LOG.info(&quot;----- rdb all cacheRef reload end:{}&quot;, Calendar.getInstance());
 101      }
 102  
 103      @Override
 104      public void flatMap(Row value, Collector&lt;BaseRow&gt; out) throws Exception {
 105          List&lt;Integer&gt; equalValIndex = sideInfo.getEqualValIndex();
 106          ArrayList&lt;Object&gt; inputParams = equalValIndex.stream()
 107                  .map(value::getField)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -                .filter(object -&gt; null != object)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +                .filter(Objects::nonNull)</span>
 110                  .collect(Collectors.toCollection(ArrayList::new));
 111  
 112          if (inputParams.size() != equalValIndex.size() &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 113              Row row = fillData(value, null);
 114              RowDataComplete.collectRow(out, row);
 115              return;
 116          }
 117  
 118          String cacheKey = inputParams.stream()
 119                  .map(Object::toString)
 120                  .collect(Collectors.joining(&quot;_&quot;));
 121  
 122          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(cacheKey);
 123          if (CollectionUtils.isEmpty(cacheList) &amp;&amp; sideInfo.getJoinType() == JoinType.LEFT) {
 124              Row row = fillData(value, null);
 125              RowDataComplete.collectRow(out, row);
 126          } else if (!CollectionUtils.isEmpty(cacheList)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -            cacheList.stream().forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -    public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -        Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -        for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -            // origin value</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -            Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -            obj = dealTimeAttributeType(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass(), obj);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -            row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -        for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -            if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -                row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -                row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -        return row;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -     * covert flink time attribute.Type information for indicating event or processing time.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -     * However, it behaves like a regular SQL timestamp but is serialized as Long.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -     * @param entry</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -     * @param obj</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -     * @return</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -    protected Object dealTimeAttributeType(Class&lt;? extends TypeInformation&gt; entry, Object obj) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -        boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(entry);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -        if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -            obj = Timestamp.valueOf(((LocalDateTime) obj));</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -        return obj;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +            cacheList.forEach(one -&gt; out.collect(RowDataConvert.convertToBaseRow(fillData(value, one))));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +        }</span>
 170      }
 171  
 172      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 173          RdbSideTableInfo tableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 174          Connection connection = null;
 175  
 176          try {
 177              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 178                  try {
 179                      connection = getConn(tableInfo.getUrl(), tableInfo.getUserName(), tableInfo.getPassword());
 180                      break;
 181                  } catch (Exception e) {
 182                      if (i == CONN_RETRY_NUM - 1) {
 183                          throw new RuntimeException(&quot;&quot;, e);
 184                      }
 185                      try {
<abbr title=" 186                          String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 186                          String connInfo = &quot;url:&quot; + tableInfo.getUrl() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;🔵</abbr>
 187                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 188                          Thread.sleep(5 * 1000);
 189                      } catch (InterruptedException e1) {
 190                          LOG.error(&quot;&quot;, e1);
 191                      }
 192                  }
 193              }
 194              queryAndFillData(tmpCache, connection);
 195          } catch (Exception e) {
 196              LOG.error(&quot;&quot;, e);
 197              throw new SQLException(e);
 198          } finally {
 199              if (connection != null) {
 200                  connection.close();
 201              }
 202          }
 203      }
 204  
<abbr title=" 205      private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws SQLException {"> 205      private void queryAndFillData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache, Connection connection) throws S🔵</abbr>
 206          //load data from table
 207          String sql = sideInfo.getSqlCondition();
 208          Statement statement = connection.createStatement();
 209          statement.setFetchSize(getFetchSize());
 210          ResultSet resultSet = statement.executeQuery(sql);
 211  
 212          String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -        String[] fields = sideInfo.getSideTableInfo().getFieldTypes();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +        String[] sideFieldTypes = sideInfo.getSideTableInfo().getFieldTypes();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +        Map&lt;String, String&gt; sideFieldNamesAndTypes = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +        for (int i = 0; i &lt; sideFieldNames.length; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +            sideFieldNamesAndTypes.put(sideFieldNames[i], sideFieldTypes[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +</span>
 220          while (resultSet.next()) {
 221              Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 222              for (String fieldName : sideFieldNames) {
 223                  Object object = resultSet.getObject(fieldName.trim());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -                int fieldIndex = sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 225 -                object = SwitchUtil.getTarget(object, fields[fieldIndex]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +                object = SwitchUtil.getTarget(object, sideFieldNamesAndTypes.get(fieldName));</span>
 227                  oneRow.put(fieldName.trim(), object);
 228              }
 229  
 230              String cacheKey = sideInfo.getEqualFieldList().stream()
 231                      .map(oneRow::get)
 232                      .map(Object::toString)
 233                      .collect(Collectors.joining(&quot;_&quot;));
 234  
 235              tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList())
 236                      .add(oneRow);
 237          }
 238      }
 239  
 240      public int getFetchSize() {
 241          return DEFAULT_FETCH_SIZE;
 242      }
 243  
 244      /**
 245       * get jdbc connection
 246       *
 247       * @param dbURL
 248       * @param userName
 249       * @param password
 250       * @return
 251       */
 252      public abstract Connection getConn(String dbURL, String userName, String password);
 253  
 254  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            