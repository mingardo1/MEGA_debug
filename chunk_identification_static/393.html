<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>393</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    393
                    <a href="392.html">prev</a>
                    <a href="394.html">next</a>
                    <a href="393_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_c81cbb2319a97e630255649586b2ac8a9af400f0_rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c81cbb2319a97e630255649586b2ac8a9af400f0:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c81cbb2319a97e630255649586b2ac8a9af400f0^1:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c81cbb2319a97e630255649586b2ac8a9af400f0^2:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;04550b05a4b7c47d56536f6b75d86ac17f0b2bbf:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.rdb.async;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheContentType;
  23 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  24 import com.dtstack.flink.sql.side.BaseSideInfo;
  25 import com.dtstack.flink.sql.side.CacheMissVal;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  28 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  29 import com.dtstack.flink.sql.util.DateUtil;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import io.vertx.core.json.JsonArray;
  33 import io.vertx.core.json.JsonObject;
  34 import io.vertx.ext.sql.SQLClient;
  35 import io.vertx.ext.sql.SQLConnection;
  36 import org.apache.commons.lang3.StringUtils;
  37 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  38 import org.apache.flink.table.runtime.types.CRow;
  39 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  40 import org.apache.flink.types.Row;
  41 import org.slf4j.Logger;
  42 import org.slf4j.LoggerFactory;
  43 
  44 import java.math.BigDecimal;
  45 import java.sql.Timestamp;
  46 import java.time.Instant;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.concurrent.CountDownLatch;
  50 import java.util.concurrent.ScheduledFuture;
  51 import java.util.concurrent.atomic.AtomicBoolean;
  52 import java.util.concurrent.atomic.AtomicLong;
  53 
  54 /**
  55  * Date: 2018/11/26
  56  * Company: www.dtstack.com
  57  *
  58  * @author maqi
  59  */
  60 
  61 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  62 
  63     private static final long serialVersionUID = 2098635244857937720L;
  64 
  65     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  66 
  67     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  68 
<abbr title="  69     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  69     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  70 
<abbr title="  71     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  71     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTðŸ”µ</abbr>
  72 
  73     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  74 
  75     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  76 
  77     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  78 
<abbr title="  79     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  79     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  80 
  81     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  82 
  83     private transient SQLClient rdbSqlClient;
  84 
  85     private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  86 
  87     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  88         super(sideInfo);
  89         init(sideInfo);
  90     }
  91 
  92 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  93     protected void init(BaseSideInfo sideInfo) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  94         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  95         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="  96         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;">  96         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  97         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  98     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  99 </span>
 100 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 101     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 102 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 104     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 105     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 106 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 107     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 109     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 110     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 110     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112         AtomicLong networkLogCounter = new AtomicLong(0L);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113         while (!CONN_STATUS.get()){//network is unhealth</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 114             //todo:ç»Ÿä¸€è®¡æ•°</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 115             if(networkLogCounter.getAndIncrement() % 1000 == 0){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 116                 LOG.info(&quot;network unhealth to block task&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 117             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 118             Thread.sleep(100);</span>
 119 =======
 120 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 121     @Override
 122     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 123 
 124     }
 125 
 126     @Override
<abbr title=" 127     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 127     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 128 
 129         AtomicLong networkLogCounter = new AtomicLong(0L);
 130         while (!CONN_STATUS.get()){//network is unhealth
 131             if(networkLogCounter.getAndIncrement() % 1000 == 0){
 132                 LOG.info(&quot;network unhealth to block task&quot;);
 133             }
 134             Thread.sleep(100);
 135         }
 136         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 137         rdbSqlClient.getConnection(conn -&gt; {
 138             if(conn.failed()){
 139                 CONN_STATUS.set(false);
 140                 connectWithRetry(params, input, resultFuture, rdbSqlClient);
 141                 return;
 142             }
 143             CONN_STATUS.set(true);
 144             ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 145             cancelTimerWhenComplete(resultFuture, timerFuture);
 146             handleQuery(conn.result(), params, input, resultFuture);
 147         });
 148 
 149     }
 150 
<abbr title=" 151     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 151     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 152         AtomicLong failCounter = new AtomicLong(0);
 153         AtomicBoolean finishFlag = new AtomicBoolean(false);
 154         while(!finishFlag.get()){
 155             CountDownLatch latch = new CountDownLatch(1);
 156             rdbSqlClient.getConnection(conn -&gt; {
 157                 try {
 158                     if(conn.failed()){
 159                         if(failCounter.getAndIncrement() % 1000 == 0){
 160                             LOG.error(&quot;getConnection error&quot;, conn.cause());
 161                         }
 162                         if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)){
 163                             dealFillDataError(input, resultFuture, conn.cause());
 164                             finishFlag.set(true);
 165                         }
 166                         conn.result().close();
 167                         return;
 168                     }
 169                     CONN_STATUS.set(true);
 170                     ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 171                     cancelTimerWhenComplete(resultFuture, timerFuture);
 172                     handleQuery(conn.result(), inputParams, input, resultFuture);
 173                     finishFlag.set(true);
 174                 } catch (Exception e) {
 175                     dealFillDataError(input, resultFuture, e);
 176                 } finally {
 177                     latch.countDown();
 178                 }
 179             });
 180             //ä¸»çº¿ç¨‹é˜»å¡ž
 181             try {
 182                 latch.wait();
 183             } catch (InterruptedException e) {
 184                 LOG.error(&quot;&quot;, e);
 185             }
 186         }
 187 
 188     }
 189 
 190     @Override
 191     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 192         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 193     }
 194 
 195     @Override
 196     public Row fillData(Row input, Object line) {
 197         JsonArray jsonArray = (JsonArray) line;
 198         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 199         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 200         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 201             Object obj = input.getField(entry.getValue());
<abbr title=" 202             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 202             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 203             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 204                 obj = ((Timestamp) obj).getTime();
 205             }
 206 
 207             row.setField(entry.getKey(), obj);
 208         }
 209 
 210         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 211             if (jsonArray == null) {
 212                 row.setField(entry.getKey(), null);
 213             } else {
<abbr title=" 214                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 214                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 215                 row.setField(entry.getKey(), object);
 216             }
 217         }
 218 
 219         return row;
 220     }
 221 
 222 
 223     @Override
 224     public void close() throws Exception {
 225         super.close();
 226         if (rdbSqlClient != null) {
 227             rdbSqlClient.close();
 228         }
 229 
 230     }
 231 
 232     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 233         this.rdbSqlClient = rdbSqlClient;
 234     }
 235 
<abbr title=" 236     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 236     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResulðŸ”µ</abbr>
 237         String key = buildCacheKey(inputParams);
 238         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 239         connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 240             if (rs.failed()) {
 241                 dealFillDataError(input, resultFuture, rs.cause());
 242                 return;
 243             }
 244 
 245             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 246 
 247             int resultSize = rs.result().getResults().size();
 248             if (resultSize &gt; 0) {
 249                 List&lt;CRow&gt; rowList = Lists.newArrayList();
 250 
 251                 for (JsonArray line : rs.result().getResults()) {
 252                     Row row = fillData(input.row(), line);
 253                     if (openCache()) {
 254                         cacheContent.add(line);
 255                     }
 256                     rowList.add(new CRow(row, input.change()));
 257                 }
 258 
 259                 if (openCache()) {
 260                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 261                 }
 262 
 263                 resultFuture.complete(rowList);
 264             } else {
 265                 dealMissKey(input, resultFuture);
 266                 if (openCache()) {
 267                     putCache(key, CacheMissVal.getMissKeyObj());
 268                 }
 269             }
 270 
 271             // and close the connection
 272             connection.close(done -&gt; {
 273                 if (done.failed()) {
 274                     throw new RuntimeException(done.cause());
 275                 }
 276             });
 277         });
 278     }
 279 
 280     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 281         Map&lt;String, Object&gt; result = Maps.newHashMap();
 282         inputParam.forEach((k,v) -&gt; {
 283             result.put(k, convertDataType(v));
 284         });
 285         return result;
 286     }
 287 
 288     private Object convertDataType(Object val) {
 289         if (val == null) {
 290             // OK
 291         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 292             // OK
 293         } else if (val instanceof Boolean) {
 294             // OK
 295         } else if (val instanceof String) {
 296             // OK
 297         } else if (val instanceof Character) {
 298             // OK
 299         } else if (val instanceof CharSequence) {
 300 
 301         } else if (val instanceof JsonObject) {
 302 
 303         } else if (val instanceof JsonArray) {
 304 
 305         } else if (val instanceof Map) {
 306 
 307         } else if (val instanceof List) {
 308 
 309         } else if (val instanceof byte[]) {
 310 
 311         } else if (val instanceof Instant) {
 312 
 313         } else if (val instanceof Timestamp) {
 314             val = DateUtil.timestampToString((Timestamp) val);
 315         } else if (val instanceof java.util.Date) {
 316             val = DateUtil.dateToString((java.util.Date)val);
 317         } else {
 318             val = val.toString();
 319         }
 320         return val;
 321     }
 322 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.rdb.async;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheContentType;
  23 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  24 import com.dtstack.flink.sql.side.BaseSideInfo;
  25 import com.dtstack.flink.sql.side.CacheMissVal;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  28 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  29 import com.dtstack.flink.sql.util.DateUtil;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import io.vertx.core.json.JsonArray;
  33 import io.vertx.core.json.JsonObject;
  34 import io.vertx.ext.sql.SQLClient;
  35 import io.vertx.ext.sql.SQLConnection;
  36 import org.apache.commons.lang3.StringUtils;
  37 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  38 import org.apache.flink.table.runtime.types.CRow;
  39 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  40 import org.apache.flink.types.Row;
  41 import org.slf4j.Logger;
  42 import org.slf4j.LoggerFactory;
  43 
  44 import java.math.BigDecimal;
  45 import java.sql.Timestamp;
  46 import java.time.Instant;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.concurrent.CountDownLatch;
  50 import java.util.concurrent.ScheduledFuture;
  51 import java.util.concurrent.atomic.AtomicBoolean;
  52 import java.util.concurrent.atomic.AtomicLong;
  53 
  54 /**
  55  * Date: 2018/11/26
  56  * Company: www.dtstack.com
  57  *
  58  * @author maqi
  59  */
  60 
  61 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  62 
  63     private static final long serialVersionUID = 2098635244857937720L;
  64 
  65     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  66 
  67     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  68 
<abbr title="  69     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  69     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  70 
<abbr title="  71     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  71     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTðŸ”µ</abbr>
  72 
  73     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  74 
  75     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  76 
  77     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  78 
<abbr title="  79     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  79     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  80 
  81     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  82 
  83     private transient SQLClient rdbSqlClient;
  84 
  85     private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  86 
  87     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  88         super(sideInfo);
  89         init(sideInfo);
  90     }
  91 
  92     protected void init(BaseSideInfo sideInfo) {
  93         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  94         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title="  95         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;">  95         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :ðŸ”µ</abbr>
  96         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
  97     }
  98 
  99     @Override
 100     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 101 
 102     }
 103 
 104     @Override
<abbr title=" 105     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 105     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 106 
 107         AtomicLong networkLogCounter = new AtomicLong(0L);
 108         while (!CONN_STATUS.get()){//network is unhealth
 109             if(networkLogCounter.getAndIncrement() % 1000 == 0){
 110                 LOG.info(&quot;network unhealth to block task&quot;);
 111             }
 112             Thread.sleep(100);
 113         }
 114         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 115         rdbSqlClient.getConnection(conn -&gt; {
 116             if(conn.failed()){
 117                 CONN_STATUS.set(false);
 118                 connectWithRetry(params, input, resultFuture, rdbSqlClient);
 119                 return;
 120             }
 121             CONN_STATUS.set(true);
 122             ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 123             cancelTimerWhenComplete(resultFuture, timerFuture);
 124             handleQuery(conn.result(), params, input, resultFuture);
 125         });
 126 
 127     }
 128 
<abbr title=" 129     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 129     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 130         AtomicLong failCounter = new AtomicLong(0);
 131         AtomicBoolean finishFlag = new AtomicBoolean(false);
 132         while(!finishFlag.get()){
 133             CountDownLatch latch = new CountDownLatch(1);
 134             rdbSqlClient.getConnection(conn -&gt; {
 135                 try {
 136                     if(conn.failed()){
 137                         if(failCounter.getAndIncrement() % 1000 == 0){
 138                             LOG.error(&quot;getConnection error&quot;, conn.cause());
 139                         }
 140                         if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)){
 141                             dealFillDataError(input, resultFuture, conn.cause());
 142                             finishFlag.set(true);
 143                         }
 144                         conn.result().close();
 145                         return;
 146                     }
 147                     CONN_STATUS.set(true);
 148                     ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 149                     cancelTimerWhenComplete(resultFuture, timerFuture);
 150                     handleQuery(conn.result(), inputParams, input, resultFuture);
 151                     finishFlag.set(true);
 152                 } catch (Exception e) {
 153                     dealFillDataError(input, resultFuture, e);
 154                 } finally {
 155                     latch.countDown();
 156                 }
 157             });
 158             //ä¸»çº¿ç¨‹é˜»å¡ž
 159             try {
 160                 latch.wait();
 161             } catch (InterruptedException e) {
 162                 LOG.error(&quot;&quot;, e);
 163             }
 164         }
 165 
 166     }
 167 
 168     @Override
 169     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 170         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 171     }
 172 
 173     @Override
 174     public Row fillData(Row input, Object line) {
 175         JsonArray jsonArray = (JsonArray) line;
 176         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 177         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 178         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 179             Object obj = input.getField(entry.getValue());
<abbr title=" 180             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 180             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 181             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 182                 obj = ((Timestamp) obj).getTime();
 183             }
 184 
 185             row.setField(entry.getKey(), obj);
 186         }
 187 
 188         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 189             if (jsonArray == null) {
 190                 row.setField(entry.getKey(), null);
 191             } else {
<abbr title=" 192                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 192                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 193                 row.setField(entry.getKey(), object);
 194             }
 195         }
 196 
 197         return row;
 198     }
 199 
 200 
 201     @Override
 202     public void close() throws Exception {
 203         super.close();
 204         if (rdbSqlClient != null) {
 205             rdbSqlClient.close();
 206         }
 207 
 208     }
 209 
 210     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 211         this.rdbSqlClient = rdbSqlClient;
 212     }
 213 
<abbr title=" 214     private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 214     private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultðŸ”µ</abbr>
 215         String key = buildCacheKey(inputParams);
 216         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 217         connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 218             if (rs.failed()) {
 219                 dealFillDataError(input, resultFuture, rs.cause());
 220                 return;
 221             }
 222 
 223             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 224 
 225             int resultSize = rs.result().getResults().size();
 226             if (resultSize &gt; 0) {
 227                 List&lt;CRow&gt; rowList = Lists.newArrayList();
 228 
 229                 for (JsonArray line : rs.result().getResults()) {
 230                     Row row = fillData(input.row(), line);
 231                     if (openCache()) {
 232                         cacheContent.add(line);
 233                     }
 234                     rowList.add(new CRow(row, input.change()));
 235                 }
 236 
 237                 if (openCache()) {
 238                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 239                 }
 240 
 241                 resultFuture.complete(rowList);
 242             } else {
 243                 dealMissKey(input, resultFuture);
 244                 if (openCache()) {
 245                     putCache(key, CacheMissVal.getMissKeyObj());
 246                 }
 247             }
 248 
 249             // and close the connection
 250             connection.close(done -&gt; {
 251                 if (done.failed()) {
 252                     throw new RuntimeException(done.cause());
 253                 }
 254             });
 255         });
 256     }
 257 
 258     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 259         Map&lt;String, Object&gt; result = Maps.newHashMap();
 260         inputParam.forEach((k,v) -&gt; {
 261             result.put(k, convertDataType(v));
 262         });
 263         return result;
 264     }
 265 
 266     private Object convertDataType(Object val) {
 267         if (val == null) {
 268             // OK
 269         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 270             // OK
 271         } else if (val instanceof Boolean) {
 272             // OK
 273         } else if (val instanceof String) {
 274             // OK
 275         } else if (val instanceof Character) {
 276             // OK
 277         } else if (val instanceof CharSequence) {
 278 
 279         } else if (val instanceof JsonObject) {
 280 
 281         } else if (val instanceof JsonArray) {
 282 
 283         } else if (val instanceof Map) {
 284 
 285         } else if (val instanceof List) {
 286 
 287         } else if (val instanceof byte[]) {
 288 
 289         } else if (val instanceof Instant) {
 290 
 291         } else if (val instanceof Timestamp) {
 292             val = DateUtil.timestampToString((Timestamp) val);
 293         } else if (val instanceof java.util.Date) {
 294             val = DateUtil.dateToString((java.util.Date)val);
 295         } else {
 296             val = val.toString();
 297         }
 298         return val;
 299     }
 300 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.rdb.async;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  22 import com.dtstack.flink.sql.side.BaseSideInfo;
  23 import com.dtstack.flink.sql.side.CacheMissVal;
  24 import com.dtstack.flink.sql.side.cache.CacheObj;
  25 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  26 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  27 import com.dtstack.flink.sql.util.DateUtil;
  28 import com.google.common.collect.Lists;
  29 import com.google.common.collect.Maps;
  30 import io.vertx.core.json.JsonArray;
  31 import io.vertx.core.json.JsonObject;
  32 import io.vertx.ext.sql.SQLClient;
  33 import io.vertx.ext.sql.SQLConnection;
  34 import java.math.BigDecimal;
  35 import java.sql.Timestamp;
  36 import java.time.Instant;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.concurrent.CountDownLatch;
  40 import java.util.concurrent.ScheduledFuture;
  41 import java.util.concurrent.atomic.AtomicBoolean;
  42 import java.util.concurrent.atomic.AtomicLong;
  43 import org.apache.commons.lang3.StringUtils;
  44 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  45 import org.apache.flink.table.runtime.types.CRow;
  46 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  47 import org.apache.flink.types.Row;
  48 import org.slf4j.Logger;
  49 import org.slf4j.LoggerFactory;
  50 
  51 
  52 /**
  53  * Date: 2018/11/26
  54  * Company: www.dtstack.com
  55  *
  56  * @author maqi
  57  */
  58 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  59     private static final long serialVersionUID = 2098635244857937720L;
  60 
  61     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  62 
  63     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  64 
<abbr title="  65     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  65     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  66 
<abbr title="  67     public static final int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  67     public static final int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTðŸ”µ</abbr>
  68 
  69     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  70 
  71     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  72 
  73     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  74 
<abbr title="  75     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  75     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  76 
  77     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  78 
  79     private transient SQLClient rdbSqlClient;
  80 
  81     private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  82 
  83     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  84         super(sideInfo);
  85         init(sideInfo);
  86     }
  87 
  88     protected void init(BaseSideInfo sideInfo) {
  89         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  90         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title="  91         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;">  91         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :ðŸ”µ</abbr>
  92         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
  93     }
  94 
  95     @Override
  96     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
  97 
  98     }
  99 
 100     @Override
<abbr title=" 101     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 101     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 102         AtomicLong networkLogCounter = new AtomicLong(0L);
 103         while (!CONN_STATUS.get()) {
 104         //network is unhealth
 105             if ((networkLogCounter.getAndIncrement() % 1000) == 0) {
 106                 LOG.info(&quot;network unhealth to block task&quot;);
 107             }
 108             Thread.sleep(100);
 109         }
 110         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 111         rdbSqlClient.getConnection(( conn) -&gt; {
 112             if (conn.failed()) {
 113                 CONN_STATUS.set(false);
 114                 connectWithRetry(params, input, resultFuture, rdbSqlClient);
 115                 return;
 116             }
 117             CONN_STATUS.set(true);
 118             ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 119             cancelTimerWhenComplete(resultFuture, timerFuture);
 120             handleQuery(conn.result(), params, input, resultFuture);
 121         });
 122     }
 123 
<abbr title=" 124     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 124     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 125         AtomicLong failCounter = new AtomicLong(0);
 126         AtomicBoolean finishFlag = new AtomicBoolean(false);
 127         while (!finishFlag.get()) {
 128             CountDownLatch latch = new CountDownLatch(1);
 129             rdbSqlClient.getConnection(( conn) -&gt; {
 130                 try {
 131                     if (conn.failed()) {
 132                         if ((failCounter.getAndIncrement() % 1000) == 0) {
 133                             LOG.error(&quot;getConnection error&quot;, conn.cause());
 134                         }
 135                         if (failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)) {
 136                             dealFillDataError(input, resultFuture, conn.cause());
 137                             finishFlag.set(true);
 138                         }
 139                         conn.result().close();
 140                         return;
 141                     }
 142                     CONN_STATUS.set(true);
 143                     ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 144                     cancelTimerWhenComplete(resultFuture, timerFuture);
 145                     handleQuery(conn.result(), inputParams, input, resultFuture);
 146                     finishFlag.set(true);
 147                 } catch ( e) {
 148                     dealFillDataError(input, resultFuture, e);
 149                 } finally {
 150                     latch.countDown();
 151                 }
 152             });
 153             //ä¸»çº¿ç¨‹é˜»å¡ž
 154             try {
 155                 latch.wait();
 156             } catch (java.lang.InterruptedException e) {
 157                 LOG.error(&quot;&quot;, e);
 158             }
 159         }
 160     }
 161 
 162     @Override
 163     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 164         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 165     }
 166 
 167     @Override
 168     public Row fillData(Row input, Object line) {
 169         JsonArray jsonArray = (JsonArray) line;
 170         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 171         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 172         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 173             Object obj = input.getField(entry.getValue());
<abbr title=" 174             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 174             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 175             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 176                 obj = ((Timestamp) obj).getTime();
 177             }
 178 
 179             row.setField(entry.getKey(), obj);
 180         }
 181 
 182         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 183             if (jsonArray == null) {
 184                 row.setField(entry.getKey(), null);
 185             } else {
<abbr title=" 186                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 186                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 187                 row.setField(entry.getKey(), object);
 188             }
 189         }
 190 
 191         return row;
 192     }
 193 
 194     @Override
 195     public void close() throws Exception {
 196         super.close();
 197         if (rdbSqlClient != null) {
 198             rdbSqlClient.close();
 199         }
 200 
 201     }
 202 
 203     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 204         this.rdbSqlClient = rdbSqlClient;
 205     }
 206 
<abbr title=" 207     private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 207     private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultðŸ”µ</abbr>
 208         String key = buildCacheKey(inputParams);
 209         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 210         connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 211             if (rs.failed()) {
 212                 dealFillDataError(input, resultFuture, rs.cause());
 213                 return;
 214             }
 215 
 216             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 217 
 218             int resultSize = rs.result().getResults().size();
 219             if (resultSize &gt; 0) {
 220                 List&lt;CRow&gt; rowList = Lists.newArrayList();
 221 
 222                 for (JsonArray line : rs.result().getResults()) {
 223                     Row row = fillData(input.row(), line);
 224                     if (openCache()) {
 225                         cacheContent.add(line);
 226                     }
 227                     rowList.add(new CRow(row, input.change()));
 228                 }
 229 
 230                 if (openCache()) {
 231                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 232                 }
 233 
 234                 resultFuture.complete(rowList);
 235             } else {
 236                 dealMissKey(input, resultFuture);
 237                 if (openCache()) {
 238                     putCache(key, CacheMissVal.getMissKeyObj());
 239                 }
 240             }
 241 
 242             // and close the connection
 243             connection.close(done -&gt; {
 244                 if (done.failed()) {
 245                     throw new RuntimeException(done.cause());
 246                 }
 247             });
 248         });
 249     }
 250 
 251     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 252         Map&lt;String, Object&gt; result = Maps.newHashMap();
 253         inputParam.forEach((k,v) -&gt; {
 254             result.put(k, convertDataType(v));
 255         });
 256         return result;
 257     }
 258 
 259     private Object convertDataType(Object val) {
 260         if (val == null) {
 261             // OK
 262         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 263             // OK
 264         } else if (val instanceof Boolean) {
 265             // OK
 266         } else if (val instanceof String) {
 267             // OK
 268         } else if (val instanceof Character) {
 269             // OK
 270         } else if (val instanceof CharSequence) {
 271 
 272         } else if (val instanceof JsonObject) {
 273 
 274         } else if (val instanceof JsonArray) {
 275 
 276         } else if (val instanceof Map) {
 277 
 278         } else if (val instanceof List) {
 279 
 280         } else if (val instanceof byte[]) {
 281 
 282         } else if (val instanceof Instant) {
 283 
 284         } else if (val instanceof Timestamp) {
 285             val = DateUtil.timestampToString((Timestamp) val);
 286         } else if (val instanceof java.util.Date) {
 287             val = DateUtil.dateToString((java.util.Date)val);
 288         } else {
 289             val = val.toString();
 290         }
 291         return val;
 292     }
 293 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.rdb.async;
  21  
  22  import com.dtstack.flink.sql.enums.ECacheContentType;
  23  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  24  import com.dtstack.flink.sql.side.BaseSideInfo;
  25  import com.dtstack.flink.sql.side.CacheMissVal;
  26  import com.dtstack.flink.sql.side.cache.CacheObj;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;</span>
  28  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import com.dtstack.flink.sql.util.DateUtil;</span>
  30  import com.google.common.collect.Lists;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import com.google.common.collect.Maps;</span>
  32  import io.vertx.core.json.JsonArray;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import io.vertx.core.json.JsonObject;</span>
  34  import io.vertx.ext.sql.SQLClient;
  35  import io.vertx.ext.sql.SQLConnection;
  36  import org.apache.commons.lang3.StringUtils;
  37  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  38  import org.apache.flink.table.runtime.types.CRow;
  39  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  40  import org.apache.flink.types.Row;
  41  import org.slf4j.Logger;
  42  import org.slf4j.LoggerFactory;
  43  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +import java.math.BigDecimal;</span>
  45  import java.sql.Timestamp;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +import java.time.Instant;</span>
  47  import java.util.List;
  48  import java.util.Map;
  49  import java.util.concurrent.CountDownLatch;
  50  import java.util.concurrent.ScheduledFuture;
  51  import java.util.concurrent.atomic.AtomicBoolean;
  52  import java.util.concurrent.atomic.AtomicLong;
  53  
  54  /**
  55   * Date: 2018/11/26
  56   * Company: www.dtstack.com
  57   *
  58   * @author maqi
  59   */
  60  
  61  public class RdbAsyncReqRow extends BaseAsyncReqRow {
  62  
  63      private static final long serialVersionUID = 2098635244857937720L;
  64  
  65      private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  66  
  67      public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  68  
  69      public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
  70  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  71 -    public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  71 -    public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  72 +    public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  72 +    public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +    public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;</span>
  75  
  76      public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  77  
  78      public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  79  
<abbr title="  80      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  80      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvidðŸ”µ</abbr>
  81  
  82      public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  83  
  84      private transient SQLClient rdbSqlClient;
  85  
  86      private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  87  
  88      private Logger logger = LoggerFactory.getLogger(getClass());
  89  
  90      public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  91          super(sideInfo);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +        init(sideInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +    protected void init(BaseSideInfo sideInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +        RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +        int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 100 +        int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;"> 100 +        int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +        rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +    }</span>
 103  
 104      @Override
 105      protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 106  
 107      }
 108  
 109      @Override
<abbr title=" 110      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 110      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr>
 111  
 112          AtomicLong networkLogCounter = new AtomicLong(0L);
 113          while (!CONN_STATUS.get()){//network is unhealth
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -            //todo:ç»Ÿä¸€è®¡æ•°</span>
 115              if(networkLogCounter.getAndIncrement() % 1000 == 0){
 116                  LOG.info(&quot;network unhealth to block task&quot;);
 117              }
 118              Thread.sleep(100);
 119          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +        Map&lt;String, Object&gt; params = formatInputParam(inputParams);</span>
 121          rdbSqlClient.getConnection(conn -&gt; {
 122              if(conn.failed()){
 123                  CONN_STATUS.set(false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -                connectWithRetry(inputParams, input, resultFuture, rdbSqlClient);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +                connectWithRetry(params, input, resultFuture, rdbSqlClient);</span>
 126                  return;
 127              }
 128              CONN_STATUS.set(true);
 129              ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 130              cancelTimerWhenComplete(resultFuture, timerFuture);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -            handleQuery(conn.result(), inputParams, input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +            handleQuery(conn.result(), params, input, resultFuture);</span>
 133          });
 134  
 135      }
 136  
<abbr title=" 137      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 137      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQðŸ”µ</abbr>
 138          AtomicLong failCounter = new AtomicLong(0);
 139          AtomicBoolean finishFlag = new AtomicBoolean(false);
 140          while(!finishFlag.get()){
 141              CountDownLatch latch = new CountDownLatch(1);
 142              rdbSqlClient.getConnection(conn -&gt; {
 143                  try {
 144                      if(conn.failed()){
 145                          if(failCounter.getAndIncrement() % 1000 == 0){
 146                              logger.error(&quot;getConnection error&quot;, conn.cause());

 147                          }
 148                          if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)){
 149                              dealFillDataError(input, resultFuture, conn.cause());
 150                              finishFlag.set(true);
 151                          }
 152                          conn.result().close();
 153                          return;
 154                      }
 155                      CONN_STATUS.set(true);
 156                      ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 157                      cancelTimerWhenComplete(resultFuture, timerFuture);
 158                      handleQuery(conn.result(), inputParams, input, resultFuture);
 159                      finishFlag.set(true);
 160                  } catch (Exception e) {
 161                      dealFillDataError(input, resultFuture, e);
 162                  } finally {
 163                      latch.countDown();
 164                  }
 165              });
 166              //ä¸»çº¿ç¨‹é˜»å¡ž
 167              try {
 168                  latch.wait();
 169              } catch (InterruptedException e) {
 170                  logger.error(&quot;&quot;, e);

 171              }
 172          }
 173  
 174      }
 175  
 176      @Override
 177      public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 178          return StringUtils.join(inputParam.values(),&quot;_&quot;);
 179      }
 180  
 181      @Override
 182      public Row fillData(Row input, Object line) {
 183          JsonArray jsonArray = (JsonArray) line;
 184          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 185          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 186          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 187              Object obj = input.getField(entry.getValue());
<abbr title=" 188              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 188              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoðŸ”µ</abbr>
 189              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 190                  obj = ((Timestamp) obj).getTime();
 191              }
 192  
 193              row.setField(entry.getKey(), obj);
 194          }
 195  
 196          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 197              if (jsonArray == null) {
 198                  row.setField(entry.getKey(), null);
 199              } else {
<abbr title=" 200                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 200                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()ðŸ”µ</abbr>
 201                  row.setField(entry.getKey(), object);
 202              }
 203          }
 204  
 205          return row;
 206      }
 207  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +</span>
 209      @Override
 210      public void close() throws Exception {
 211          super.close();
 212          if (rdbSqlClient != null) {
 213              rdbSqlClient.close();
 214          }
 215  
 216      }
 217  
 218      public void setRdbSqlClient(SQLClient rdbSqlClient) {
 219          this.rdbSqlClient = rdbSqlClient;
 220      }
 221  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 222 -    private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 222 -    private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 223 +    private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 223 +    private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CðŸ”µ</abbr></span>
 224          String key = buildCacheKey(inputParams);
 225          JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 226          connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 227              if (rs.failed()) {
 228                  dealFillDataError(input, resultFuture, rs.cause());
 229                  return;
 230              }
 231  
 232              List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 233  
 234              int resultSize = rs.result().getResults().size();
 235              if (resultSize &gt; 0) {
 236                  List&lt;CRow&gt; rowList = Lists.newArrayList();
 237  
 238                  for (JsonArray line : rs.result().getResults()) {
 239                      Row row = fillData(input.row(), line);
 240                      if (openCache()) {
 241                          cacheContent.add(line);
 242                      }
 243                      rowList.add(new CRow(row, input.change()));
 244                  }
 245  
 246                  if (openCache()) {
 247                      putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 248                  }
 249  
 250                  resultFuture.complete(rowList);
 251              } else {
 252                  dealMissKey(input, resultFuture);
 253                  if (openCache()) {
 254                      putCache(key, CacheMissVal.getMissKeyObj());
 255                  }
 256              }
 257  
 258              // and close the connection
 259              connection.close(done -&gt; {
 260                  if (done.failed()) {
 261                      throw new RuntimeException(done.cause());
 262                  }
 263              });
 264          });
 265      }
 266  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +    private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +        Map&lt;String, Object&gt; result = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +        inputParam.forEach((k,v) -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +            result.put(k, convertDataType(v));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +        return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 273 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 274 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +    private Object convertDataType(Object val) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 276 +        if (val == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +        } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 280 +        } else if (val instanceof Boolean) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +        } else if (val instanceof String) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +        } else if (val instanceof Character) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +        } else if (val instanceof CharSequence) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +        } else if (val instanceof JsonObject) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +        } else if (val instanceof JsonArray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +        } else if (val instanceof Map) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +        } else if (val instanceof List) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 295 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 296 +        } else if (val instanceof byte[]) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 297 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 298 +        } else if (val instanceof Instant) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 299 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 300 +        } else if (val instanceof Timestamp) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 301 +            val = DateUtil.timestampToString((Timestamp) val);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 302 +        } else if (val instanceof java.util.Date) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 303 +            val = DateUtil.dateToString((java.util.Date)val);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +            val = val.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +        return val;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +    }</span>
 309  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.rdb.async;
  21  
  22  import com.dtstack.flink.sql.enums.ECacheContentType;
  23  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  24  import com.dtstack.flink.sql.side.BaseSideInfo;
  25  import com.dtstack.flink.sql.side.CacheMissVal;
  26  import com.dtstack.flink.sql.side.cache.CacheObj;

  27  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;

  28  import com.google.common.collect.Lists;

  29  import io.vertx.core.json.JsonArray;

  30  import io.vertx.ext.sql.SQLClient;
  31  import io.vertx.ext.sql.SQLConnection;
  32  import org.apache.commons.lang3.StringUtils;
  33  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  34  import org.apache.flink.table.runtime.types.CRow;
  35  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  36  import org.apache.flink.types.Row;
  37  import org.slf4j.Logger;
  38  import org.slf4j.LoggerFactory;
  39  

  40  import java.sql.Timestamp;

  41  import java.util.List;
  42  import java.util.Map;
  43  import java.util.concurrent.CountDownLatch;
  44  import java.util.concurrent.ScheduledFuture;
  45  import java.util.concurrent.atomic.AtomicBoolean;
  46  import java.util.concurrent.atomic.AtomicLong;
  47  
  48  /**
  49   * Date: 2018/11/26
  50   * Company: www.dtstack.com
  51   *
  52   * @author maqi
  53   */
  54  
  55  public class RdbAsyncReqRow extends BaseAsyncReqRow {
  56  
  57      private static final long serialVersionUID = 2098635244857937720L;
  58  
  59      private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  60  
  61      public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  62  
  63      public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
  64  
<abbr title="  65      public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  65      public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORðŸ”µ</abbr>



  66  
  67      public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  68  
  69      public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  70  
<abbr title="  71      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  71      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvidðŸ”µ</abbr>
  72  
  73      public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  74  
  75      private transient SQLClient rdbSqlClient;
  76  
  77      private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  78  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -    private Logger logger = LoggerFactory.getLogger(getClass());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -</span>
  81      public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  82          super(sideInfo);
  83      }
  84  









<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  85 -</span>
  86      @Override
  87      protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
  88  
  89      }
  90  
  91      @Override
<abbr title="  92      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {">  92      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr>
  93  
  94          AtomicLong networkLogCounter = new AtomicLong(0L);
  95          while (!CONN_STATUS.get()){//network is unhealth
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -            //todo:ç»Ÿä¸€è®¡æ•°</span>
  97              if(networkLogCounter.getAndIncrement() % 1000 == 0){
  98                  LOG.info(&quot;network unhealth to block task&quot;);
  99              }
 100              Thread.sleep(100);
 101          }

 102          rdbSqlClient.getConnection(conn -&gt; {
 103              if(conn.failed()){
 104                  CONN_STATUS.set(false);
 105                  connectWithRetry(inputParams, input, resultFuture, rdbSqlClient);

 106                  return;
 107              }
 108              CONN_STATUS.set(true);
 109              ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 110              cancelTimerWhenComplete(resultFuture, timerFuture);
 111              handleQuery(conn.result(), inputParams, input, resultFuture);

 112          });
 113  
 114      }
 115  
<abbr title=" 116      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 116      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQðŸ”µ</abbr>
 117          AtomicLong failCounter = new AtomicLong(0);
 118          AtomicBoolean finishFlag = new AtomicBoolean(false);
 119          while(!finishFlag.get()){
 120              CountDownLatch latch = new CountDownLatch(1);
 121              rdbSqlClient.getConnection(conn -&gt; {
 122                  try {
 123                      if(conn.failed()){
 124                          if(failCounter.getAndIncrement() % 1000 == 0){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -                            logger.error(&quot;getConnection error&quot;, conn.cause());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +                            LOG.error(&quot;getConnection error&quot;, conn.cause());</span>
 127                          }
 128                          if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)){
 129                              dealFillDataError(input, resultFuture, conn.cause());
 130                              finishFlag.set(true);
 131                          }
 132                          conn.result().close();
 133                          return;
 134                      }
 135                      CONN_STATUS.set(true);
 136                      ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 137                      cancelTimerWhenComplete(resultFuture, timerFuture);
 138                      handleQuery(conn.result(), inputParams, input, resultFuture);
 139                      finishFlag.set(true);
 140                  } catch (Exception e) {
 141                      dealFillDataError(input, resultFuture, e);
 142                  } finally {
 143                      latch.countDown();
 144                  }
 145              });
 146              //ä¸»çº¿ç¨‹é˜»å¡ž
 147              try {
 148                  latch.wait();
 149              } catch (InterruptedException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -                logger.error(&quot;&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +                LOG.error(&quot;&quot;, e);</span>
 152              }
 153          }
 154  
 155      }
 156  
 157      @Override
 158      public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 159          return StringUtils.join(inputParam.values(),&quot;_&quot;);
 160      }
 161  
 162      @Override
 163      public Row fillData(Row input, Object line) {
 164          JsonArray jsonArray = (JsonArray) line;
 165          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 166          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 167          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 168              Object obj = input.getField(entry.getValue());
<abbr title=" 169              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 169              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoðŸ”µ</abbr>
 170              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 171                  obj = ((Timestamp) obj).getTime();
 172              }
 173  
 174              row.setField(entry.getKey(), obj);
 175          }
 176  
 177          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 178              if (jsonArray == null) {
 179                  row.setField(entry.getKey(), null);
 180              } else {
<abbr title=" 181                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 181                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()ðŸ”µ</abbr>
 182                  row.setField(entry.getKey(), object);
 183              }
 184          }
 185  
 186          return row;
 187      }
 188  

 189      @Override
 190      public void close() throws Exception {
 191          super.close();
 192          if (rdbSqlClient != null) {
 193              rdbSqlClient.close();
 194          }
 195  
 196      }
 197  
 198      public void setRdbSqlClient(SQLClient rdbSqlClient) {
 199          this.rdbSqlClient = rdbSqlClient;
 200      }
 201  
<abbr title=" 202      private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 202      private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRðŸ”µ</abbr>

 203          String key = buildCacheKey(inputParams);
 204          JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 205          connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 206              if (rs.failed()) {
 207                  dealFillDataError(input, resultFuture, rs.cause());
 208                  return;
 209              }
 210  
 211              List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 212  
 213              int resultSize = rs.result().getResults().size();
 214              if (resultSize &gt; 0) {
 215                  List&lt;CRow&gt; rowList = Lists.newArrayList();
 216  
 217                  for (JsonArray line : rs.result().getResults()) {
 218                      Row row = fillData(input.row(), line);
 219                      if (openCache()) {
 220                          cacheContent.add(line);
 221                      }
 222                      rowList.add(new CRow(row, input.change()));
 223                  }
 224  
 225                  if (openCache()) {
 226                      putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 227                  }
 228  
 229                  resultFuture.complete(rowList);
 230              } else {
 231                  dealMissKey(input, resultFuture);
 232                  if (openCache()) {
 233                      putCache(key, CacheMissVal.getMissKeyObj());
 234                  }
 235              }
 236  
 237              // and close the connection
 238              connection.close(done -&gt; {
 239                  if (done.failed()) {
 240                      throw new RuntimeException(done.cause());
 241                  }
 242              });
 243          });
 244      }
 245  










































 246  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            