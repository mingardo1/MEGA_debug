<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>396</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    396
                    <a href="395.html">prev</a>
                    <a href="397.html">next</a>
                    <a href="396_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_b0443afbb92cd23ff3706e251dabb140983c5a20_rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b0443afbb92cd23ff3706e251dabb140983c5a20:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b0443afbb92cd23ff3706e251dabb140983c5a20^1:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b0443afbb92cd23ff3706e251dabb140983c5a20^2:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;330be96a729c630506a8737ce198d5ee6a77b99e:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.rdb.async;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheContentType;
  23 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  24 import com.dtstack.flink.sql.side.BaseSideInfo;
  25 import com.dtstack.flink.sql.side.CacheMissVal;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  28 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  29 import com.dtstack.flink.sql.util.DateUtil;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import io.vertx.core.json.JsonArray;
  33 import io.vertx.core.json.JsonObject;
  34 import io.vertx.ext.sql.SQLClient;
  35 import io.vertx.ext.sql.SQLConnection;
  36 import org.apache.commons.lang3.StringUtils;
  37 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  38 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  39 import org.apache.flink.metrics.Counter;</span>
  40 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  41 import org.apache.calcite.sql.JoinType;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  42 import org.apache.commons.lang3.StringUtils;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  43 import org.apache.flink.metrics.Counter;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  44 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  45 import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  46 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  47 import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  48 import org.slf4j.Logger;</span>
  49 =======
  50 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  51 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  52 import org.apache.flink.table.runtime.types.CRow;
  53 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  54 import org.apache.flink.types.Row;
  55 import org.slf4j.Logger;
  56 import org.slf4j.LoggerFactory;
  57 
  58 import java.math.BigDecimal;
  59 import java.sql.Timestamp;
  60 import java.time.Instant;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.concurrent.CountDownLatch;
  64 import java.util.concurrent.ScheduledFuture;
  65 import java.util.concurrent.atomic.AtomicBoolean;
  66 import java.util.concurrent.atomic.AtomicLong;
  67 
  68 /**
  69  * Date: 2018/11/26
  70  * Company: www.dtstack.com
  71  *
  72  * @author maqi
  73  */
  74 
  75 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  76 
  77     private static final long serialVersionUID = 2098635244857937720L;
  78 
  79     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  80 
  81     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  82 
<abbr title="  83     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  83     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  84 
<abbr title="  85     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  85     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTðŸ”µ</abbr>
  86 
  87     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  88 
  89     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  90 
  91     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  92 
<abbr title="  93     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  93     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  94 
  95     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  96 
  97     private transient SQLClient rdbSqlClient;
  98 
  99     private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
 100 
 101     private Logger logger = LoggerFactory.getLogger(getClass());
 102 
 103     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
 104         super(sideInfo);
 105         init(sideInfo);
 106     }
 107 
 108     protected void init(BaseSideInfo sideInfo) {
 109         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 110         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title=" 111         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;"> 111         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :ðŸ”µ</abbr>
 112         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
 113     }
 114 
 115     @Override
 116     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 117 
 118     }
 119 
 120     @Override
<abbr title=" 121     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 121     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 122 
 123         AtomicLong networkLogCounter = new AtomicLong(0L);
 124         while (!CONN_STATUS.get()){//network is unhealth
 125             //todo:ç»Ÿä¸€è®¡æ•°
 126             if(networkLogCounter.getAndIncrement() % 1000 == 0){
 127                 LOG.info(&quot;network unhealth to block task&quot;);
 128             }
 129             Thread.sleep(100);
 130         }
 131         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 132         rdbSqlClient.getConnection(conn -&gt; {
 133             if(conn.failed()){
 134                 CONN_STATUS.set(false);
 135                 connectWithRetry(params, input, resultFuture, rdbSqlClient);
 136                 return;
 137             }
 138             CONN_STATUS.set(true);
 139             ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 140             cancelTimerWhenComplete(resultFuture, timerFuture);
 141             handleQuery(conn.result(), params, input, resultFuture);
 142         });
 143 
 144     }
 145 
<abbr title=" 146     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 146     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 147         AtomicLong failCounter = new AtomicLong(0);
 148         AtomicBoolean finishFlag = new AtomicBoolean(false);
 149         while(!finishFlag.get()){
 150             CountDownLatch latch = new CountDownLatch(1);
 151             rdbSqlClient.getConnection(conn -&gt; {
 152                 try {
 153                     if(conn.failed()){
 154                         if(failCounter.getAndIncrement() % 1000 == 0){
 155                             logger.error(&quot;getConnection error&quot;, conn.cause());
 156                         }
 157                         if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)){
 158                             dealFillDataError(input, resultFuture, conn.cause());
 159                             finishFlag.set(true);
 160                         }
 161                         conn.result().close();
 162                         return;
 163                     }
 164                     CONN_STATUS.set(true);
 165                     ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 166                     cancelTimerWhenComplete(resultFuture, timerFuture);
 167                     handleQuery(conn.result(), inputParams, input, resultFuture);
 168                     finishFlag.set(true);
 169                 } catch (Exception e) {
 170                     dealFillDataError(input, resultFuture, e);
 171                 } finally {
 172                     latch.countDown();
 173                 }
 174             });
 175             //ä¸»çº¿ç¨‹é˜»å¡ž
 176             try {
 177                 latch.wait();
 178             } catch (InterruptedException e) {
 179                 logger.error(&quot;&quot;, e);
 180             }
 181         }
 182 
 183     }
 184 
 185     @Override
 186     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 187         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 188     }
 189 
 190     @Override
 191     public Row fillData(Row input, Object line) {
 192         JsonArray jsonArray = (JsonArray) line;
 193         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 194         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 195         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 196             Object obj = input.getField(entry.getValue());
<abbr title=" 197             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 197             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 198             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 199                 obj = ((Timestamp) obj).getTime();
 200             }
 201 
 202             row.setField(entry.getKey(), obj);
 203         }
 204 
 205         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 206             if (jsonArray == null) {
 207                 row.setField(entry.getKey(), null);
 208             } else {
<abbr title=" 209                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 209                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 210                 row.setField(entry.getKey(), object);
 211             }
 212         }
 213 
 214         return row;
 215     }
 216 
 217 
 218     @Override
 219     public void close() throws Exception {
 220         super.close();
 221         if (rdbSqlClient != null) {
 222             rdbSqlClient.close();
 223         }
 224 
 225     }
 226 
 227     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 228         this.rdbSqlClient = rdbSqlClient;
 229     }
 230 
<abbr title=" 231     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 231     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResulðŸ”µ</abbr>
 232         String key = buildCacheKey(inputParams);
 233         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 234         connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 235             if (rs.failed()) {
 236                 dealFillDataError(input, resultFuture, rs.cause());
 237                 return;
 238             }
 239 
 240             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 241 
 242             int resultSize = rs.result().getResults().size();
 243             if (resultSize &gt; 0) {
 244                 List&lt;CRow&gt; rowList = Lists.newArrayList();
 245 
 246                 for (JsonArray line : rs.result().getResults()) {
 247                     Row row = fillData(input.row(), line);
 248                     if (openCache()) {
 249                         cacheContent.add(line);
 250                     }
 251                     rowList.add(new CRow(row, input.change()));
 252                 }
 253 
 254                 if (openCache()) {
 255                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 256                 }
 257 
 258                 resultFuture.complete(rowList);
 259             } else {
 260                 dealMissKey(input, resultFuture);
 261                 if (openCache()) {
 262                     putCache(key, CacheMissVal.getMissKeyObj());
 263                 }
 264             }
 265 
 266             // and close the connection
 267             connection.close(done -&gt; {
 268                 if (done.failed()) {
 269                     throw new RuntimeException(done.cause());
 270                 }
 271             });
 272         });
 273     }
 274 
 275     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 276         Map&lt;String, Object&gt; result = Maps.newHashMap();
 277         inputParam.forEach((k,v) -&gt; {
 278             result.put(k, convertDataType(v));
 279         });
 280         return result;
 281     }
 282 
 283     private Object convertDataType(Object val) {
 284         if (val == null) {
 285             // OK
 286         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 287             // OK
 288         } else if (val instanceof Boolean) {
 289             // OK
 290         } else if (val instanceof String) {
 291             // OK
 292         } else if (val instanceof Character) {
 293             // OK
 294         } else if (val instanceof CharSequence) {
 295 
 296         } else if (val instanceof JsonObject) {
 297 
 298         } else if (val instanceof JsonArray) {
 299 
 300         } else if (val instanceof Map) {
 301 
 302         } else if (val instanceof List) {
 303 
 304         } else if (val instanceof byte[]) {
 305 
 306         } else if (val instanceof Instant) {
 307 
 308         } else if (val instanceof Timestamp) {
 309             val = DateUtil.timestampToString((Timestamp) val);
 310         } else if (val instanceof java.util.Date) {
 311             val = DateUtil.dateToString((java.util.Date)val);
 312         } else {
 313             val = val.toString();
 314         }
 315         return val;
 316     }
 317 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.rdb.async;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheContentType;
  23 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  24 import com.dtstack.flink.sql.side.BaseSideInfo;
  25 import com.dtstack.flink.sql.side.CacheMissVal;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  28 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  29 import com.dtstack.flink.sql.util.DateUtil;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import io.vertx.core.json.JsonArray;
  33 import io.vertx.core.json.JsonObject;
  34 import io.vertx.ext.sql.SQLClient;
  35 import io.vertx.ext.sql.SQLConnection;
  36 import org.apache.commons.lang3.StringUtils;
  37 import org.apache.flink.configuration.Configuration;
  38 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  39 import org.apache.flink.table.runtime.types.CRow;
  40 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  41 import org.apache.flink.types.Row;
  42 import org.slf4j.Logger;
  43 import org.slf4j.LoggerFactory;
  44 
  45 import java.math.BigDecimal;
  46 import java.sql.Timestamp;
  47 import java.time.Instant;
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.concurrent.CountDownLatch;
  51 import java.util.concurrent.ScheduledFuture;
  52 import java.util.concurrent.atomic.AtomicBoolean;
  53 import java.util.concurrent.atomic.AtomicLong;
  54 
  55 /**
  56  * Date: 2018/11/26
  57  * Company: www.dtstack.com
  58  *
  59  * @author maqi
  60  */
  61 
  62 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  63 
  64     private static final long serialVersionUID = 2098635244857937720L;
  65 
  66     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  67 
  68     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  69 
<abbr title="  70     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  70     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  71 
<abbr title="  72     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  72     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTðŸ”µ</abbr>
  73 
  74     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  75 
  76     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  77 
  78     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  79 
<abbr title="  80     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  80     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  81 
  82     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  83 
  84     private transient SQLClient rdbSqlClient;
  85 
  86     private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  87 
  88     private Logger logger = LoggerFactory.getLogger(getClass());
  89 
  90     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  91         super(sideInfo);
  92         init(sideInfo);
  93     }
  94 
  95     protected void init(BaseSideInfo sideInfo) {
  96         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  97         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title="  98         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;">  98         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :ðŸ”µ</abbr>
  99         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
 100     }
 101 
 102     @Override
 103     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 104 
 105     }
 106 
 107     @Override
<abbr title=" 108     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 108     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 109 
 110         AtomicLong networkLogCounter = new AtomicLong(0L);
 111         while (!CONN_STATUS.get()){//network is unhealth
 112             //todo:ç»Ÿä¸€è®¡æ•°
 113             if(networkLogCounter.getAndIncrement() % 1000 == 0){
 114                 LOG.info(&quot;network unhealth to block task&quot;);
 115             }
 116             Thread.sleep(100);
 117         }
 118         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 119         rdbSqlClient.getConnection(conn -&gt; {
 120             if(conn.failed()){
 121                 CONN_STATUS.set(false);
 122                 connectWithRetry(params, input, resultFuture, rdbSqlClient);
 123                 return;
 124             }
 125             CONN_STATUS.set(true);
 126             ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 127             cancelTimerWhenComplete(resultFuture, timerFuture);
 128             handleQuery(conn.result(), params, input, resultFuture);
 129         });
 130 
 131     }
 132 
<abbr title=" 133     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 133     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 134         AtomicLong failCounter = new AtomicLong(0);
 135         AtomicBoolean finishFlag = new AtomicBoolean(false);
 136         while(!finishFlag.get()){
 137             CountDownLatch latch = new CountDownLatch(1);
 138             rdbSqlClient.getConnection(conn -&gt; {
 139                 try {
 140                     if(conn.failed()){
 141                         if(failCounter.getAndIncrement() % 1000 == 0){
 142                             logger.error(&quot;getConnection error&quot;, conn.cause());
 143                         }
 144                         if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)){
 145                             dealFillDataError(input, resultFuture, conn.cause());
 146                             finishFlag.set(true);
 147                         }
 148                         conn.result().close();
 149                         return;
 150                     }
 151                     CONN_STATUS.set(true);
 152                     ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 153                     cancelTimerWhenComplete(resultFuture, timerFuture);
 154                     handleQuery(conn.result(), inputParams, input, resultFuture);
 155                     finishFlag.set(true);
 156                 } catch (Exception e) {
 157                     dealFillDataError(input, resultFuture, e);
 158                 } finally {
 159                     latch.countDown();
 160                 }
 161             });
 162             //ä¸»çº¿ç¨‹é˜»å¡ž
 163             try {
 164                 latch.wait();
 165             } catch (InterruptedException e) {
 166                 logger.error(&quot;&quot;, e);
 167             }
 168         }
 169 
 170     }
 171 
 172     @Override
 173     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 174         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 175     }
 176 
 177     @Override
 178     public Row fillData(Row input, Object line) {
 179         JsonArray jsonArray = (JsonArray) line;
 180         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 181         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 182         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 183             Object obj = input.getField(entry.getValue());
<abbr title=" 184             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 184             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 185             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 186                 obj = ((Timestamp) obj).getTime();
 187             }
 188 
 189             row.setField(entry.getKey(), obj);
 190         }
 191 
 192         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 193             if (jsonArray == null) {
 194                 row.setField(entry.getKey(), null);
 195             } else {
<abbr title=" 196                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 196                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 197                 row.setField(entry.getKey(), object);
 198             }
 199         }
 200 
 201         return row;
 202     }
 203 
 204 
 205     @Override
 206     public void close() throws Exception {
 207         super.close();
 208         if (rdbSqlClient != null) {
 209             rdbSqlClient.close();
 210         }
 211 
 212     }
 213 
 214     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 215         this.rdbSqlClient = rdbSqlClient;
 216     }
 217 
<abbr title=" 218     private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 218     private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultðŸ”µ</abbr>
 219         String key = buildCacheKey(inputParams);
 220         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 221         connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 222             if (rs.failed()) {
 223                 dealFillDataError(input, resultFuture, rs.cause());
 224                 return;
 225             }
 226 
 227             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 228 
 229             int resultSize = rs.result().getResults().size();
 230             if (resultSize &gt; 0) {
 231                 List&lt;CRow&gt; rowList = Lists.newArrayList();
 232 
 233                 for (JsonArray line : rs.result().getResults()) {
 234                     Row row = fillData(input.row(), line);
 235                     if (openCache()) {
 236                         cacheContent.add(line);
 237                     }
 238                     rowList.add(new CRow(row, input.change()));
 239                 }
 240 
 241                 if (openCache()) {
 242                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 243                 }
 244 
 245                 resultFuture.complete(rowList);
 246             } else {
 247                 dealMissKey(input, resultFuture);
 248                 if (openCache()) {
 249                     putCache(key, CacheMissVal.getMissKeyObj());
 250                 }
 251             }
 252 
 253             // and close the connection
 254             connection.close(done -&gt; {
 255                 if (done.failed()) {
 256                     throw new RuntimeException(done.cause());
 257                 }
 258             });
 259         });
 260     }
 261 
 262     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 263         Map&lt;String, Object&gt; result = Maps.newHashMap();
 264         inputParam.forEach((k,v) -&gt; {
 265             result.put(k, convertDataType(v));
 266         });
 267         return result;
 268     }
 269 
 270     private Object convertDataType(Object val) {
 271         if (val == null) {
 272             // OK
 273         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 274             // OK
 275         } else if (val instanceof Boolean) {
 276             // OK
 277         } else if (val instanceof String) {
 278             // OK
 279         } else if (val instanceof Character) {
 280             // OK
 281         } else if (val instanceof CharSequence) {
 282 
 283         } else if (val instanceof JsonObject) {
 284 
 285         } else if (val instanceof JsonArray) {
 286 
 287         } else if (val instanceof Map) {
 288 
 289         } else if (val instanceof List) {
 290 
 291         } else if (val instanceof byte[]) {
 292 
 293         } else if (val instanceof Instant) {
 294 
 295         } else if (val instanceof Timestamp) {
 296             val = DateUtil.timestampToString((Timestamp) val);
 297         } else if (val instanceof java.util.Date) {
 298             val = DateUtil.dateToString((java.util.Date)val);
 299         } else {
 300             val = val.toString();
 301         }
 302         return val;
 303     }
 304 }
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.rdb.async;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  22 import com.dtstack.flink.sql.side.BaseSideInfo;
  23 import com.dtstack.flink.sql.side.CacheMissVal;
  24 import com.dtstack.flink.sql.side.cache.CacheObj;
  25 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  26 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  27 import com.dtstack.flink.sql.util.DateUtil;
  28 import com.google.common.collect.Lists;
  29 import com.google.common.collect.Maps;
  30 import io.vertx.core.json.JsonArray;
  31 import io.vertx.core.json.JsonObject;
  32 import io.vertx.ext.sql.SQLClient;
  33 import io.vertx.ext.sql.SQLConnection;
  34 import java.math.BigDecimal;
  35 import java.sql.Timestamp;
  36 import java.time.Instant;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.concurrent.CountDownLatch;
  40 import java.util.concurrent.ScheduledFuture;
  41 import java.util.concurrent.atomic.AtomicBoolean;
  42 import java.util.concurrent.atomic.AtomicLong;
  43 import org.apache.commons.lang3.StringUtils;
  44 import org.apache.flink.configuration.Configuration;
  45 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  46 import org.apache.flink.table.runtime.types.CRow;
  47 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  48 import org.apache.flink.types.Row;
  49 import org.slf4j.Logger;
  50 import org.slf4j.LoggerFactory;
  51 
  52 
  53 /**
  54  * Date: 2018/11/26
  55  * Company: www.dtstack.com
  56  *
  57  * @author maqi
  58  */
  59 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  60     private static final long serialVersionUID = 2098635244857937720L;
  61 
  62     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  63 
  64     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  65 
<abbr title="  66     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  66     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  67 
<abbr title="  68     public static final int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  68     public static final int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTðŸ”µ</abbr>
  69 
  70     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  71 
  72     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  73 
  74     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  75 
<abbr title="  76     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  76     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  77 
  78     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  79 
  80     private transient SQLClient rdbSqlClient;
  81 
  82     private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  83 
  84     private Logger logger = LoggerFactory.getLogger(getClass());
  85 
  86     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  87         super(sideInfo);
  88         init(sideInfo);
  89     }
  90 
  91     protected void init(BaseSideInfo sideInfo) {
  92         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  93         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title="  94         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;">  94         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :ðŸ”µ</abbr>
  95         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
  96     }
  97 
  98     @Override
  99     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 100 
 101     }
 102 
 103     @Override
<abbr title=" 104     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 104     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 105         AtomicLong networkLogCounter = new AtomicLong(0L);
 106         while (!CONN_STATUS.get()) {
 107             // network is unhealth
 108             // todo:ç»Ÿä¸€è®¡æ•°
 109             if ((networkLogCounter.getAndIncrement() % 1000) == 0) {
 110                 LOG.info(&quot;network unhealth to block task&quot;);
 111             }
 112             Thread.sleep(100);
 113         }
 114         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 115         rdbSqlClient.getConnection(( conn) -&gt; {
 116             if (conn.failed()) {
 117                 CONN_STATUS.set(false);
 118                 connectWithRetry(params, input, resultFuture, rdbSqlClient);
 119                 return;
 120             }
 121             CONN_STATUS.set(true);
 122             ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 123             cancelTimerWhenComplete(resultFuture, timerFuture);
 124             handleQuery(conn.result(), params, input, resultFuture);
 125         });
 126     }
 127 
<abbr title=" 128     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 128     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 129         AtomicLong failCounter = new AtomicLong(0);
 130         AtomicBoolean finishFlag = new AtomicBoolean(false);
 131         while (!finishFlag.get()) {
 132             CountDownLatch latch = new CountDownLatch(1);
 133             rdbSqlClient.getConnection(( conn) -&gt; {
 134                 try {
 135                     if (conn.failed()) {
 136                         if ((failCounter.getAndIncrement() % 1000) == 0) {
 137                             logger.error(&quot;getConnection error&quot;, conn.cause());
 138                         }
 139                         if (failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)) {
 140                             dealFillDataError(input, resultFuture, conn.cause());
 141                             finishFlag.set(true);
 142                         }
 143                         conn.result().close();
 144                         return;
 145                     }
 146                     CONN_STATUS.set(true);
 147                     ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 148                     cancelTimerWhenComplete(resultFuture, timerFuture);
 149                     handleQuery(conn.result(), inputParams, input, resultFuture);
 150                     finishFlag.set(true);
 151                 } catch ( e) {
 152                     dealFillDataError(input, resultFuture, e);
 153                 } finally {
 154                     latch.countDown();
 155                 }
 156             });
 157             // ä¸»çº¿ç¨‹é˜»å¡ž
 158             try {
 159                 latch.wait();
 160             } catch (java.lang.InterruptedException e) {
 161                 logger.error(&quot;&quot;, e);
 162             }
 163         }
 164     }
 165 
 166     @Override
 167     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 168         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 169     }
 170 
 171     @Override
 172     public Row fillData(Row input, Object line) {
 173         JsonArray jsonArray = (JsonArray) line;
 174         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 175         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 176         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 177             Object obj = input.getField(entry.getValue());
<abbr title=" 178             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 178             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 179             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 180                 obj = ((Timestamp) obj).getTime();
 181             }
 182 
 183             row.setField(entry.getKey(), obj);
 184         }
 185 
 186         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 187             if (jsonArray == null) {
 188                 row.setField(entry.getKey(), null);
 189             } else {
<abbr title=" 190                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 190                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 191                 row.setField(entry.getKey(), object);
 192             }
 193         }
 194 
 195         return row;
 196     }
 197 
 198     @Override
 199     public void close() throws Exception {
 200         super.close();
 201         if (rdbSqlClient != null) {
 202             rdbSqlClient.close();
 203         }
 204 
 205     }
 206 
 207     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 208         this.rdbSqlClient = rdbSqlClient;
 209     }
 210 
<abbr title=" 211     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) {"> 211     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResulðŸ”µ</abbr>
 212         String key = buildCacheKey(inputParams);
 213         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 214         connection.queryWithParams(sideInfo.getSqlCondition(), params, ( rs) -&gt; {
 215             if (rs.failed()) {
 216                 dealFillDataError(input, resultFuture, rs.cause());
 217                 return;
 218             }
 219             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 220             int resultSize = rs.result().getResults().size();
 221             if (resultSize &gt; 0) {
 222                 List&lt;CRow&gt; rowList = Lists.newArrayList();
 223                 for (JsonArray line : rs.result().getResults()) {
 224                     Row row = fillData(input.row(), line);
 225                     if (openCache()) {
 226                         cacheContent.add(line);
 227                     }
 228                     rowList.add(new CRow(row, input.change()));
 229                 }
 230                 if (openCache()) {
 231                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 232                 }
 233                 resultFuture.complete(rowList);
 234             } else {
 235                 dealMissKey(input, resultFuture);
 236                 if (openCache()) {
 237                     putCache(key, CacheMissVal.getMissKeyObj());
 238                 }
 239             }
 240             // and close the connection
 241             connection.close(( done) -&gt; {
 242                 if (done.failed()) {
 243                     throw new RuntimeException(done.cause());
 244                 }
 245             });
 246         });
 247     }
 248 
 249     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 250         Map&lt;String, Object&gt; result = Maps.newHashMap();
 251         inputParam.forEach((k,v) -&gt; {
 252             result.put(k, convertDataType(v));
 253         });
 254         return result;
 255     }
 256 
 257     private Object convertDataType(Object val) {
 258         if (val == null) {
 259             // OK
 260         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 261             // OK
 262         } else if (val instanceof Boolean) {
 263             // OK
 264         } else if (val instanceof String) {
 265             // OK
 266         } else if (val instanceof Character) {
 267             // OK
 268         } else if (val instanceof CharSequence) {
 269 
 270         } else if (val instanceof JsonObject) {
 271 
 272         } else if (val instanceof JsonArray) {
 273 
 274         } else if (val instanceof Map) {
 275 
 276         } else if (val instanceof List) {
 277 
 278         } else if (val instanceof byte[]) {
 279 
 280         } else if (val instanceof Instant) {
 281 
 282         } else if (val instanceof Timestamp) {
 283             val = DateUtil.timestampToString((Timestamp) val);
 284         } else if (val instanceof java.util.Date) {
 285             val = DateUtil.dateToString((java.util.Date)val);
 286         } else {
 287             val = val.toString();
 288         }
 289         return val;
 290     }
 291 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.rdb.async;
  21  
  22  import com.dtstack.flink.sql.enums.ECacheContentType;
  23  import com.dtstack.flink.sql.metric.MetricConstant;
  24  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25  import com.dtstack.flink.sql.side.BaseSideInfo;
  26  import com.dtstack.flink.sql.side.CacheMissVal;
  27  import com.dtstack.flink.sql.side.cache.CacheObj;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;</span>
  29  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import com.dtstack.flink.sql.util.DateUtil;</span>
  31  import com.google.common.collect.Lists;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import com.google.common.collect.Maps;</span>
  33  import io.vertx.core.json.JsonArray;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import io.vertx.core.json.JsonObject;</span>
  35  import io.vertx.ext.sql.SQLClient;
  36  import io.vertx.ext.sql.SQLConnection;
  37  import org.apache.calcite.sql.JoinType;
  38  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 +import org.apache.flink.configuration.Configuration;</span>
  40  import org.apache.flink.metrics.Counter;
  41  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  42  import org.apache.flink.table.runtime.types.CRow;
  43  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  44  import org.apache.flink.types.Row;
  45  import org.slf4j.Logger;
  46  import org.slf4j.LoggerFactory;
  47  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import java.math.BigDecimal;</span>
  49  import java.sql.Timestamp;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import java.time.Instant;</span>
  51  import java.util.List;
  52  import java.util.Map;
  53  import java.util.concurrent.CountDownLatch;
  54  import java.util.concurrent.ScheduledFuture;
  55  import java.util.concurrent.atomic.AtomicBoolean;
  56  import java.util.concurrent.atomic.AtomicLong;
  57  
  58  /**
  59   * Date: 2018/11/26
  60   * Company: www.dtstack.com
  61   *
  62   * @author maqi
  63   */
  64  
  65  public class RdbAsyncReqRow extends BaseAsyncReqRow {
  66  
  67      private static final long serialVersionUID = 2098635244857937720L;
  68  
  69      private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  70  
  71      public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  72  
  73      public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
  74  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  75 -    public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  75 -    public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  76 +    public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  76 +    public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +    public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;</span>
  79  
  80      public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  81  
  82      public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  83  
<abbr title="  84      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  84      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvidðŸ”µ</abbr>
  85  
  86      public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  87  
  88      private transient SQLClient rdbSqlClient;
  89  
  90      private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  91  
  92      private final static AtomicLong FAIL_NUM = new AtomicLong(0);
  93  
  94      private Logger logger = LoggerFactory.getLogger(getClass());
  95  
<abbr title="  96      private Counter counter = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);">  96      private Counter counter = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_ðŸ”µ</abbr>
  97  
  98      public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  99          super(sideInfo);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +        init(sideInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +    protected void init(BaseSideInfo sideInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +        RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 107 +        int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 108 +        int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;"> 108 +        int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +        rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +    }</span>
 111  
 112      @Override
 113      protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 114  
 115      }
 116  
 117      @Override
<abbr title=" 118      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 118      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr>
 119  

 120          while (!CONN_STATUS.get()){//network is unhealth




 121              Thread.sleep(100);
 122          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +        Map&lt;String, Object&gt; params = formatInputParam(inputParams);</span>
 124          rdbSqlClient.getConnection(conn -&gt; {
 125              if(conn.failed()){
 126                  CONN_STATUS.set(false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -                connectWithRetry(inputParams, input, resultFuture, rdbSqlClient);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +                connectWithRetry(params, input, resultFuture, rdbSqlClient);</span>
 129                  return;
 130              }
 131              CONN_STATUS.set(true);
 132              ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 133              cancelTimerWhenComplete(resultFuture, timerFuture);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -            handleQuery(conn.result(), inputParams, input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +            handleQuery(conn.result(), params, input, resultFuture);</span>
 136          });
 137  
 138      }
 139  
<abbr title=" 140      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 140      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQðŸ”µ</abbr>
 141          AtomicLong failCounter = new AtomicLong(0);
 142          AtomicBoolean finishFlag = new AtomicBoolean(false);
 143          while(!finishFlag.get()){
 144              CountDownLatch latch = new CountDownLatch(1);
 145              rdbSqlClient.getConnection(conn -&gt; {
 146                  try {
 147                      if(conn.failed()){
 148                          if(failCounter.getAndIncrement() % 1000 == 0){
 149                              logger.error(&quot;getConnection error&quot;, conn.cause());
 150                          }
 151                          if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)){
<abbr title=" 152                              if(FAIL_NUM.incrementAndGet() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){"> 152                              if(FAIL_NUM.incrementAndGet() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAðŸ”µ</abbr>
 153                                  counter.inc();
 154                                  resultFuture.completeExceptionally(conn.cause());
 155                              } else {
 156                                  dealMissKey(input, resultFuture);
 157                              }

 158                              finishFlag.set(true);
 159                          }
 160                          conn.result().close();
 161                          return;
 162                      }
 163                      CONN_STATUS.set(true);
 164                      ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 165                      cancelTimerWhenComplete(resultFuture, timerFuture);
 166                      handleQuery(conn.result(), inputParams, input, resultFuture);
 167                      finishFlag.set(true);
 168                  } catch (Exception e) {
 169                      dealFillDataError(resultFuture, e, null);
 170                      logger.error(&quot;&quot;, e);

 171                  } finally {
 172                      latch.countDown();
 173                  }
 174              });
 175              //ä¸»çº¿ç¨‹é˜»å¡ž
 176              try {
 177                  latch.wait();
 178              } catch (InterruptedException e) {
 179                  logger.error(&quot;&quot;, e);
 180              }
 181          }
 182  
 183      }
 184  
 185      @Override
 186      public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 187          return StringUtils.join(inputParam.values(),&quot;_&quot;);
 188      }
 189  
 190      @Override
 191      public Row fillData(Row input, Object line) {
 192          JsonArray jsonArray = (JsonArray) line;
 193          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 194          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 195          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 196              Object obj = input.getField(entry.getValue());
<abbr title=" 197              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 197              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoðŸ”µ</abbr>
 198              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 199                  obj = ((Timestamp) obj).getTime();
 200              }
 201  
 202              row.setField(entry.getKey(), obj);
 203          }
 204  
 205          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 206              if (jsonArray == null) {
 207                  row.setField(entry.getKey(), null);
 208              } else {
<abbr title=" 209                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 209                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()ðŸ”µ</abbr>
 210                  row.setField(entry.getKey(), object);
 211              }
 212          }
 213  
 214          return row;
 215      }
 216  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +</span>
 218      @Override
 219      public void close() throws Exception {
 220          super.close();
 221          if (rdbSqlClient != null) {
 222              rdbSqlClient.close();
 223          }
 224  
 225      }
 226  
 227      public void setRdbSqlClient(SQLClient rdbSqlClient) {
 228          this.rdbSqlClient = rdbSqlClient;
 229      }
 230  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 231 -    private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 231 -    private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 232 +    private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 232 +    private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CðŸ”µ</abbr></span>
 233          String key = buildCacheKey(inputParams);
 234          JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 235          connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 236              if (rs.failed()) {
 237                  if(FAIL_NUM.incrementAndGet() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
 238                      LOG.error(&quot;Cannot retrieve the data from the database&quot;, rs.cause());
 239                      counter.inc();
 240                      resultFuture.completeExceptionally(rs.cause());
 241                  } else {
 242                      dealMissKey(input, resultFuture);
 243                  }

 244                  return;
 245              }
 246  
 247              List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 248  
 249              int resultSize = rs.result().getResults().size();
 250              if (resultSize &gt; 0) {
 251                  List&lt;CRow&gt; rowList = Lists.newArrayList();
 252  
 253                  for (JsonArray line : rs.result().getResults()) {
 254                      Row row = fillData(input.row(), line);
 255                      if (openCache()) {
 256                          cacheContent.add(line);
 257                      }
 258                      rowList.add(new CRow(row, input.change()));
 259                  }
 260  
 261                  if (openCache()) {
 262                      putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 263                  }
 264  
 265                  resultFuture.complete(rowList);
 266              } else {
 267                  dealMissKey(input, resultFuture);
 268                  if (openCache()) {
 269                      putCache(key, CacheMissVal.getMissKeyObj());
 270                  }
 271              }
 272  
 273              // and close the connection
 274              connection.close(done -&gt; {
 275                  if (done.failed()) {
 276                      throw new RuntimeException(done.cause());
 277                  }
 278              });
 279          });
 280      }
 281  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +    private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +        Map&lt;String, Object&gt; result = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +        inputParam.forEach((k,v) -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +            result.put(k, convertDataType(v));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +        return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +    private Object convertDataType(Object val) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +        if (val == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +        } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 295 +        } else if (val instanceof Boolean) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 296 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 297 +        } else if (val instanceof String) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 298 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 299 +        } else if (val instanceof Character) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 300 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 301 +        } else if (val instanceof CharSequence) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 302 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 303 +        } else if (val instanceof JsonObject) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +        } else if (val instanceof JsonArray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +        } else if (val instanceof Map) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +        } else if (val instanceof List) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +        } else if (val instanceof byte[]) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +        } else if (val instanceof Instant) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +        } else if (val instanceof Timestamp) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +            val = DateUtil.timestampToString((Timestamp) val);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +        } else if (val instanceof java.util.Date) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +            val = DateUtil.dateToString((java.util.Date)val);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +            val = val.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +        return val;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +    }</span>
 324  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.rdb.async;
  21  
  22  import com.dtstack.flink.sql.enums.ECacheContentType;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import com.dtstack.flink.sql.metric.MetricConstant;</span>
  24  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25  import com.dtstack.flink.sql.side.BaseSideInfo;
  26  import com.dtstack.flink.sql.side.CacheMissVal;
  27  import com.dtstack.flink.sql.side.cache.CacheObj;

  28  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;

  29  import com.google.common.collect.Lists;

  30  import io.vertx.core.json.JsonArray;

  31  import io.vertx.ext.sql.SQLClient;
  32  import io.vertx.ext.sql.SQLConnection;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import org.apache.calcite.sql.JoinType;</span>
  34  import org.apache.commons.lang3.StringUtils;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import org.apache.flink.metrics.Counter;</span>
  36  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  37  import org.apache.flink.table.runtime.types.CRow;
  38  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  39  import org.apache.flink.types.Row;
  40  import org.slf4j.Logger;
  41  import org.slf4j.LoggerFactory;
  42  

  43  import java.sql.Timestamp;

  44  import java.util.List;
  45  import java.util.Map;
  46  import java.util.concurrent.CountDownLatch;
  47  import java.util.concurrent.ScheduledFuture;
  48  import java.util.concurrent.atomic.AtomicBoolean;
  49  import java.util.concurrent.atomic.AtomicLong;
  50  
  51  /**
  52   * Date: 2018/11/26
  53   * Company: www.dtstack.com
  54   *
  55   * @author maqi
  56   */
  57  
  58  public class RdbAsyncReqRow extends BaseAsyncReqRow {
  59  
  60      private static final long serialVersionUID = 2098635244857937720L;
  61  
  62      private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  63  
  64      public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  65  
  66      public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
  67  
<abbr title="  68      public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  68      public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORðŸ”µ</abbr>



  69  
  70      public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  71  
  72      public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  73  
<abbr title="  74      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  74      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvidðŸ”µ</abbr>
  75  
  76      public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  77  
  78      private transient SQLClient rdbSqlClient;
  79  
  80      private final static AtomicBoolean CONN_STATUS = new AtomicBoolean(true);
  81  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -    private final static AtomicLong FAIL_NUM = new AtomicLong(0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -</span>
  84      private Logger logger = LoggerFactory.getLogger(getClass());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  85 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  86 -    private Counter counter = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);">  86 -    private Counter counter = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_ðŸ”µ</abbr></span>
  87  
  88      public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  89          super(sideInfo);
  90      }
  91  









  92  
  93      @Override
  94      protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
  95  
  96      }
  97  
  98      @Override
<abbr title="  99      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {">  99      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr>
 100  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +        AtomicLong networkLogCounter = new AtomicLong(0L);</span>
 102          while (!CONN_STATUS.get()){//network is unhealth
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +            //todo:ç»Ÿä¸€è®¡æ•°</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +            if(networkLogCounter.getAndIncrement() % 1000 == 0){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +                LOG.info(&quot;network unhealth to block task&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +            }</span>
 107              Thread.sleep(100);
 108          }

 109          rdbSqlClient.getConnection(conn -&gt; {
 110              if(conn.failed()){
 111                  CONN_STATUS.set(false);
 112                  connectWithRetry(inputParams, input, resultFuture, rdbSqlClient);

 113                  return;
 114              }
 115              CONN_STATUS.set(true);
 116              ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 117              cancelTimerWhenComplete(resultFuture, timerFuture);
 118              handleQuery(conn.result(), inputParams, input, resultFuture);

 119          });
 120  
 121      }
 122  
<abbr title=" 123      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 123      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQðŸ”µ</abbr>
 124          AtomicLong failCounter = new AtomicLong(0);
 125          AtomicBoolean finishFlag = new AtomicBoolean(false);
 126          while(!finishFlag.get()){
 127              CountDownLatch latch = new CountDownLatch(1);
 128              rdbSqlClient.getConnection(conn -&gt; {
 129                  try {
 130                      if(conn.failed()){
 131                          if(failCounter.getAndIncrement() % 1000 == 0){
 132                              logger.error(&quot;getConnection error&quot;, conn.cause());
 133                          }
 134                          if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getAsyncFailMaxNum(3L)){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 135 -                            if(FAIL_NUM.incrementAndGet() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){"> 135 -                            if(FAIL_NUM.incrementAndGet() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -                                counter.inc();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -                                resultFuture.completeExceptionally(conn.cause());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -                                dealMissKey(input, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +                            dealFillDataError(input, resultFuture, conn.cause());</span>
 142                              finishFlag.set(true);
 143                          }
 144                          conn.result().close();
 145                          return;
 146                      }
 147                      CONN_STATUS.set(true);
 148                      ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 149                      cancelTimerWhenComplete(resultFuture, timerFuture);
 150                      handleQuery(conn.result(), inputParams, input, resultFuture);
 151                      finishFlag.set(true);
 152                  } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -                    dealFillDataError(resultFuture, e, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -                    logger.error(&quot;&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +                    dealFillDataError(input, resultFuture, e);</span>
 156                  } finally {
 157                      latch.countDown();
 158                  }
 159              });
 160              //ä¸»çº¿ç¨‹é˜»å¡ž
 161              try {
 162                  latch.wait();
 163              } catch (InterruptedException e) {
 164                  logger.error(&quot;&quot;, e);
 165              }
 166          }
 167  
 168      }
 169  
 170      @Override
 171      public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 172          return StringUtils.join(inputParam.values(),&quot;_&quot;);
 173      }
 174  
 175      @Override
 176      public Row fillData(Row input, Object line) {
 177          JsonArray jsonArray = (JsonArray) line;
 178          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 179          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 180          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 181              Object obj = input.getField(entry.getValue());
<abbr title=" 182              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 182              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoðŸ”µ</abbr>
 183              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 184                  obj = ((Timestamp) obj).getTime();
 185              }
 186  
 187              row.setField(entry.getKey(), obj);
 188          }
 189  
 190          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 191              if (jsonArray == null) {
 192                  row.setField(entry.getKey(), null);
 193              } else {
<abbr title=" 194                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 194                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()ðŸ”µ</abbr>
 195                  row.setField(entry.getKey(), object);
 196              }
 197          }
 198  
 199          return row;
 200      }
 201  

 202      @Override
 203      public void close() throws Exception {
 204          super.close();
 205          if (rdbSqlClient != null) {
 206              rdbSqlClient.close();
 207          }
 208  
 209      }
 210  
 211      public void setRdbSqlClient(SQLClient rdbSqlClient) {
 212          this.rdbSqlClient = rdbSqlClient;
 213      }
 214  
<abbr title=" 215      private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 215      private void handleQuery(SQLConnection connection,Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRðŸ”µ</abbr>

 216          String key = buildCacheKey(inputParams);
 217          JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 218          connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 219              if (rs.failed()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -                if(FAIL_NUM.incrementAndGet() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 221 -                    LOG.error(&quot;Cannot retrieve the data from the database&quot;, rs.cause());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 222 -                    counter.inc();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 223 -                    resultFuture.completeExceptionally(rs.cause());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 225 -                    dealMissKey(input, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 226 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                dealFillDataError(input, resultFuture, rs.cause());</span>
 228                  return;
 229              }
 230  
 231              List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 232  
 233              int resultSize = rs.result().getResults().size();
 234              if (resultSize &gt; 0) {
 235                  List&lt;CRow&gt; rowList = Lists.newArrayList();
 236  
 237                  for (JsonArray line : rs.result().getResults()) {
 238                      Row row = fillData(input.row(), line);
 239                      if (openCache()) {
 240                          cacheContent.add(line);
 241                      }
 242                      rowList.add(new CRow(row, input.change()));
 243                  }
 244  
 245                  if (openCache()) {
 246                      putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 247                  }
 248  
 249                  resultFuture.complete(rowList);
 250              } else {
 251                  dealMissKey(input, resultFuture);
 252                  if (openCache()) {
 253                      putCache(key, CacheMissVal.getMissKeyObj());
 254                  }
 255              }
 256  
 257              // and close the connection
 258              connection.close(done -&gt; {
 259                  if (done.failed()) {
 260                      throw new RuntimeException(done.cause());
 261                  }
 262              });
 263          });
 264      }
 265  










































 266  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            