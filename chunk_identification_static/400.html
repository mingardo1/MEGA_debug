<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>400</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    400
                    <a href="399.html">prev</a>
                    <a href="401.html">next</a>
                    <a href="400_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_39363a4e113a35060cb4299806459463d4a75177_src/com/android/launcher3/Launcher.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;39363a4e113a35060cb4299806459463d4a75177:src/com/android/launcher3/Launcher.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;39363a4e113a35060cb4299806459463d4a75177^1:src/com/android/launcher3/Launcher.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;39363a4e113a35060cb4299806459463d4a75177^2:src/com/android/launcher3/Launcher.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;51ac5ce545ea800ca8378767a5d7ab17bb6bc884:src/com/android/launcher3/Launcher.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b], [j], [j], [sj], [sj], [sj], [sj], [sj], [sj], [sj], [j], [j], [j], [j], [j], [s], [s], [s], [s], [s], [s], [s]], subset: [[bs], [b], [b], [j], [j], [sj], [sj], [sj], [sj], [sj], [sj], [sj], [sj], [j], [j], [j], [j], [s], [s], [s], [s], [s]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 
   2 /*
   3  * Copyright (C) 2008 The Android Open Source Project
   4  *
   5  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   6  * you may not use this file except in compliance with the License.
   7  * You may obtain a copy of the License at
   8  *
   9  *      http://www.apache.org/licenses/LICENSE-2.0
  10  *
  11  * Unless required by applicable law or agreed to in writing, software
  12  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  13  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  14  * See the License for the specific language governing permissions and
  15  * limitations under the License.
  16  */
  17 
  18 package com.android.launcher3;
  19 
  20 import android.animation.Animator;
  21 import android.animation.AnimatorListenerAdapter;
  22 import android.animation.AnimatorSet;
  23 import android.animation.ObjectAnimator;
  24 import android.animation.PropertyValuesHolder;
  25 import android.animation.TimeInterpolator;
  26 import android.animation.ValueAnimator;
  27 import android.annotation.TargetApi;
  28 import android.app.Activity;
  29 import android.app.ActivityManager;
  30 import android.app.ActivityOptions;
  31 import android.app.AlertDialog;
  32 import android.app.SearchManager;
  33 import android.appwidget.AppWidgetHostView;
  34 import android.appwidget.AppWidgetManager;
  35 import android.appwidget.AppWidgetProviderInfo;
  36 import android.content.ActivityNotFoundException;
  37 import android.content.BroadcastReceiver;
  38 import android.content.ComponentCallbacks2;
  39 import android.content.ComponentName;
  40 import android.content.ContentResolver;
  41 import android.content.Context;
  42 import android.content.DialogInterface;
  43 import android.content.Intent;
  44 import android.content.IntentFilter;
  45 import android.content.SharedPreferences;
  46 import android.content.pm.ActivityInfo;
  47 import android.content.pm.ApplicationInfo;
  48 import android.content.pm.PackageManager;
  49 import android.content.pm.PackageManager.NameNotFoundException;
  50 import android.content.res.Configuration;
  51 import android.content.res.Resources;
  52 import android.database.ContentObserver;
  53 import android.graphics.Bitmap;
  54 import android.graphics.Canvas;
  55 import android.graphics.Color;
  56 import android.graphics.Point;
  57 import android.graphics.PorterDuff;
  58 import android.graphics.Rect;
  59 import android.graphics.drawable.Drawable;
  60 import android.net.Uri;
  61 import android.os.AsyncTask;
  62 import android.os.Build;
  63 import android.os.Bundle;
  64 import android.os.Environment;
  65 import android.os.Handler;
  66 import android.os.Message;
  67 import android.os.StrictMode;
  68 import android.os.SystemClock;
  69 import android.speech.RecognizerIntent;
  70 import android.text.Selection;
  71 import android.text.SpannableStringBuilder;
  72 import android.text.TextUtils;
  73 import android.text.method.TextKeyListener;
  74 import android.util.DisplayMetrics;
  75 import android.util.Log;
  76 import android.view.ContextThemeWrapper;
  77 import android.view.Display;
  78 import android.view.Gravity;
  79 import android.view.HapticFeedbackConstants;
  80 import android.view.KeyEvent;
  81 import android.view.LayoutInflater;
  82 import android.view.Menu;
  83 import android.view.MotionEvent;
  84 import android.view.Surface;
  85 import android.view.View;
  86 import android.view.View.OnClickListener;
  87 import android.view.View.OnLongClickListener;
  88 import android.view.ViewAnimationUtils;
  89 import android.view.ViewGroup;
  90 import android.view.ViewTreeObserver;
  91 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
  92 import android.view.Window;
  93 import android.view.WindowManager;
  94 import android.view.accessibility.AccessibilityEvent;
  95 import android.view.animation.AccelerateInterpolator;
  96 import android.view.animation.DecelerateInterpolator;
  97 import android.view.animation.Interpolator;
  98 import android.view.inputmethod.InputMethodManager;
  99 import android.widget.Advanceable;
 100 import android.widget.FrameLayout;
 101 import android.widget.ImageView;
 102 import android.widget.TextView;
 103 import android.widget.Toast;
 104 
 105 import com.android.launcher3.DropTarget.DragObject;
 106 import com.android.launcher3.PagedView.PageSwitchListener;
 107 import com.android.launcher3.compat.AppWidgetManagerCompat;
 108 import com.android.launcher3.compat.LauncherActivityInfoCompat;
 109 import com.android.launcher3.compat.LauncherAppsCompat;
 110 import com.android.launcher3.compat.PackageInstallerCompat;
 111 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
 112 import com.android.launcher3.compat.UserHandleCompat;
 113 import com.android.launcher3.compat.UserManagerCompat;
 114 
 115 import java.io.DataInputStream;
 116 import java.io.DataOutputStream;
 117 import java.io.File;
 118 import java.io.FileDescriptor;
 119 import java.io.FileNotFoundException;
 120 import java.io.FileOutputStream;
 121 import java.io.IOException;
 122 import java.io.PrintWriter;
 123 import java.lang.reflect.Field;
 124 import java.lang.reflect.InvocationTargetException;
 125 import java.lang.reflect.Method;
 126 import java.text.DateFormat;
 127 import java.util.ArrayList;
 128 import java.util.Collection;
 129 import java.util.Date;
 130 import java.util.HashMap;
 131 import java.util.List;
 132 import java.util.concurrent.atomic.AtomicInteger;
 133 
 134 /**
 135  * Default launcher application.
 136  */
 137 public class Launcher extends Activity
 138         implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,
 139                    View.OnTouchListener, PageSwitchListener, LauncherProviderChangeListener {
 140     static final String TAG = &quot;Launcher&quot;;
 141     static final boolean LOGD = false;
 142 
 143     static final boolean PROFILE_STARTUP = false;
 144     static final boolean DEBUG_WIDGETS = false;
 145     static final boolean DEBUG_STRICT_MODE = false;
 146     static final boolean DEBUG_RESUME_TIME = false;
 147     static final boolean DEBUG_DUMP_LOG = false;
 148 
 149     static final boolean ENABLE_DEBUG_INTENTS = false; // allow DebugIntents to run
 150 
 151     private static final int REQUEST_CREATE_SHORTCUT = 1;
 152     private static final int REQUEST_CREATE_APPWIDGET = 5;
 153     private static final int REQUEST_PICK_SHORTCUT = 7;
 154     private static final int REQUEST_PICK_APPWIDGET = 9;
 155     private static final int REQUEST_PICK_WALLPAPER = 10;
 156 
 157     private static final int REQUEST_BIND_APPWIDGET = 11;
 158     private static final int REQUEST_RECONFIGURE_APPWIDGET = 12;
 159 
 160     /**
 161      * IntentStarter uses request codes starting with this. This must be greater than all activity
 162      * request codes used internally.
 163      */
 164     protected static final int REQUEST_LAST = 100;
 165 
 166     static final String EXTRA_SHORTCUT_DUPLICATE = &quot;duplicate&quot;;
 167 
 168     static final int SCREEN_COUNT = 5;
 169     static final int DEFAULT_SCREEN = 2;
 170 
 171     private static final String PREFERENCES = &quot;launcher.preferences&quot;;
 172     // To turn on these properties, type
 173     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
 174     static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
 175     static final String DUMP_STATE_PROPERTY = &quot;launcher_dump_state&quot;;
 176     static final String DISABLE_ALL_APPS_PROPERTY = &quot;launcher_noallapps&quot;;
 177 
 178     // The Intent extra that defines whether to ignore the launch animation
 179     static final String INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION =
 180             &quot;com.android.launcher3.intent.extra.shortcut.INGORE_LAUNCH_ANIMATION&quot;;
 181 
 182     // Type: int
 183     private static final String RUNTIME_STATE_CURRENT_SCREEN = &quot;launcher.current_screen&quot;;
 184     // Type: int
 185     private static final String RUNTIME_STATE = &quot;launcher.state&quot;;
 186     // Type: int
 187     private static final String RUNTIME_STATE_PENDING_ADD_CONTAINER = &quot;launcher.add_container&quot;;
 188     // Type: int
 189     private static final String RUNTIME_STATE_PENDING_ADD_SCREEN = &quot;launcher.add_screen&quot;;
 190     // Type: int
 191     private static final String RUNTIME_STATE_PENDING_ADD_CELL_X = &quot;launcher.add_cell_x&quot;;
 192     // Type: int
 193     private static final String RUNTIME_STATE_PENDING_ADD_CELL_Y = &quot;launcher.add_cell_y&quot;;
 194     // Type: boolean
 195     private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME = &quot;launcher.rename_folder&quot;;
 196     // Type: long
 197     private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME_ID = &quot;launcher.rename_folder_id&quot;;
 198     // Type: int
 199     private static final String RUNTIME_STATE_PENDING_ADD_SPAN_X = &quot;launcher.add_span_x&quot;;
 200     // Type: int
 201     private static final String RUNTIME_STATE_PENDING_ADD_SPAN_Y = &quot;launcher.add_span_y&quot;;
 202     // Type: parcelable
 203     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_INFO = &quot;launcher.add_widget_info&quot;;
 204     // Type: parcelable
 205     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_ID = &quot;launcher.add_widget_id&quot;;
 206     // Type: int[]
 207     private static final String RUNTIME_STATE_VIEW_IDS = &quot;launcher.view_ids&quot;;
 208 
 209     static final String INTRO_SCREEN_DISMISSED = &quot;launcher.intro_screen_dismissed&quot;;
 210     static final String FIRST_RUN_ACTIVITY_DISPLAYED = &quot;launcher.first_run_activity_displayed&quot;;
 211 
 212     static final String FIRST_LOAD_COMPLETE = &quot;launcher.first_load_complete&quot;;
 213     static final String ACTION_FIRST_LOAD_COMPLETE =
 214             &quot;com.android.launcher3.action.FIRST_LOAD_COMPLETE&quot;;
 215 
 216     private static final String TOOLBAR_ICON_METADATA_NAME = &quot;com.android.launcher.toolbar_icon&quot;;
 217     private static final String TOOLBAR_SEARCH_ICON_METADATA_NAME =
 218             &quot;com.android.launcher.toolbar_search_icon&quot;;
 219     private static final String TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME =
 220             &quot;com.android.launcher.toolbar_voice_search_icon&quot;;
 221 
 222     public static final String SHOW_WEIGHT_WATCHER = &quot;debug.show_mem&quot;;
 223     public static final boolean SHOW_WEIGHT_WATCHER_DEFAULT = false;
 224 
 225     public static final String USER_HAS_MIGRATED = &quot;launcher.user_migrated_from_old_data&quot;;
 226 
 227     /** The different states that Launcher can be in. */
 228     private enum State { NONE, WORKSPACE, APPS_CUSTOMIZE, APPS_CUSTOMIZE_SPRING_LOADED };
 229     private State mState = State.WORKSPACE;
 230     private AnimatorSet mStateAnimation;
 231 
 232     private boolean mIsSafeModeEnabled;
 233 
 234     static final int APPWIDGET_HOST_ID = 1024;
 235     public static final int EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT = 300;
 236     private static final int ON_ACTIVITY_RESULT_ANIMATION_DELAY = 500;
 237     private static final int ACTIVITY_START_DELAY = 1000;
 238 
 239     private static final Object sLock = new Object();
 240     private static int sScreen = DEFAULT_SCREEN;
 241 
 242     private HashMap&lt;Integer, Integer&gt; mItemIdToViewId = new HashMap&lt;Integer, Integer&gt;();
 243     private static final AtomicInteger sNextGeneratedId = new AtomicInteger(1);
 244 
 245     // How long to wait before the new-shortcut animation automatically pans the workspace
 246     private static int NEW_APPS_PAGE_MOVE_DELAY = 500;
 247     private static int NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS = 5;
 248     private static int NEW_APPS_ANIMATION_DELAY = 500;
 249     private static final int SINGLE_FRAME_DELAY = 16;
 250 
 251     private final BroadcastReceiver mCloseSystemDialogsReceiver
 252             = new CloseSystemDialogsIntentReceiver();
 253     private final ContentObserver mWidgetObserver = new AppWidgetResetObserver();
 254 
 255     private LayoutInflater mInflater;
 256 
 257     private Workspace mWorkspace;
 258     private View mLauncherView;
 259     private View mPageIndicators;
 260     private DragLayer mDragLayer;
 261     private DragController mDragController;
 262     private View mWeightWatcher;
 263 
 264     private AppWidgetManagerCompat mAppWidgetManager;
 265     private LauncherAppWidgetHost mAppWidgetHost;
 266 
 267     private ItemInfo mPendingAddInfo = new ItemInfo();
 268     private AppWidgetProviderInfo mPendingAddWidgetInfo;
 269     private int mPendingAddWidgetId = -1;
 270 
 271     private int[] mTmpAddItemCellCoordinates = new int[2];
 272 
 273     private FolderInfo mFolderInfo;
 274 
 275     private Hotseat mHotseat;
 276     private ViewGroup mOverviewPanel;
 277 
 278     private View mAllAppsButton;
 279 
 280     private SearchDropTargetBar mSearchDropTargetBar;
 281     private AppsCustomizeTabHost mAppsCustomizeTabHost;
 282     private AppsCustomizePagedView mAppsCustomizeContent;
 283     private boolean mAutoAdvanceRunning = false;
 284     private View mQsb;
 285 
 286     private Bundle mSavedState;
 287     // We set the state in both onCreate and then onNewIntent in some cases, which causes both
 288     // scroll issues (because the workspace may not have been measured yet) and extra work.
 289     // Instead, just save the state that we need to restore Launcher to, and commit it in onResume.
 290     private State mOnResumeState = State.NONE;
 291 
 292     private SpannableStringBuilder mDefaultKeySsb = null;
 293 
 294     private boolean mWorkspaceLoading = true;
 295 
 296     private boolean mPaused = true;
 297     private boolean mRestoring;
 298     private boolean mWaitingForResult;
 299     private boolean mOnResumeNeedsLoad;
 300 
 301     private ArrayList&lt;Runnable&gt; mBindOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 302     private ArrayList&lt;Runnable&gt; mOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 303 
 304     private Bundle mSavedInstanceState;
 305 
 306     private LauncherModel mModel;
 307     private IconCache mIconCache;
 308     private boolean mUserPresent = true;
 309     private boolean mVisible = false;
 310     private boolean mHasFocus = false;
 311     private boolean mAttached = false;
 312 
 313     private static LocaleConfiguration sLocaleConfiguration = null;
 314 
 315     private static HashMap&lt;Long, FolderInfo&gt; sFolders = new HashMap&lt;Long, FolderInfo&gt;();
 316 
 317     private View.OnTouchListener mHapticFeedbackTouchListener;
 318 
 319     // Related to the auto-advancing of widgets
 320     private final int ADVANCE_MSG = 1;
 321     private final int mAdvanceInterval = 20000;
 322     private final int mAdvanceStagger = 250;
 323     private long mAutoAdvanceSentTime;
 324     private long mAutoAdvanceTimeLeft = -1;
 325     private HashMap&lt;View, AppWidgetProviderInfo&gt; mWidgetsToAdvance =
 326         new HashMap&lt;View, AppWidgetProviderInfo&gt;();
 327 
 328     // Determines how long to wait after a rotation before restoring the screen orientation to
 329     // match the sensor state.
 330     private final int mRestoreScreenOrientationDelay = 500;
 331 
 332     // External icons saved in case of resource changes, orientation, etc.
 333     private static Drawable.ConstantState[] sGlobalSearchIcon = new Drawable.ConstantState[2];
 334     private static Drawable.ConstantState[] sVoiceSearchIcon = new Drawable.ConstantState[2];
 335 
 336     private Drawable mWorkspaceBackgroundDrawable;
 337 
 338     private final ArrayList&lt;Integer&gt; mSynchronouslyBoundPages = new ArrayList&lt;Integer&gt;();
 339     private static final boolean DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE = false;
 340 
 341     static final ArrayList&lt;String&gt; sDumpLogs = new ArrayList&lt;String&gt;();
 342     static Date sDateStamp = new Date();
 343     static DateFormat sDateFormat =
 344             DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
 345     static long sRunStart = System.currentTimeMillis();
 346     static final String CORRUPTION_EMAIL_SENT_KEY = &quot;corruptionEmailSent&quot;;
 347 
 348     // We only want to get the SharedPreferences once since it does an FS stat each time we get
 349     // it from the context.
 350     private SharedPreferences mSharedPrefs;
 351 
 352     private static ArrayList&lt;ComponentName&gt; mIntentsOnWorkspaceFromUpgradePath = null;
 353 
 354     // Holds the page that we need to animate to, and the icon views that we need to animate up
 355     // when we scroll to that page on resume.
 356     private ImageView mFolderIconImageView;
 357     private Bitmap mFolderIconBitmap;
 358     private Canvas mFolderIconCanvas;
 359     private Rect mRectForFolderAnimation = new Rect();
 360 
 361     private BubbleTextView mWaitingForResume;
 362 
 363     private Runnable mBuildLayersRunnable = new Runnable() {
 364         public void run() {
 365             if (mWorkspace != null) {
 366                 mWorkspace.buildPageHardwareLayers();
 367             }
 368         }
 369     };
 370 
 371     private static PendingAddArguments sPendingAddItem;
 372 
 373     public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
 374 
 375     private static class PendingAddArguments {
 376         int requestCode;
 377         Intent intent;
 378         long container;
 379         long screenId;
 380         int cellX;
 381         int cellY;
 382         int appWidgetId;
 383     }
 384 
 385     private Stats mStats;
 386 
 387     FocusIndicatorView mFocusHandler;
 388 
 389     static boolean isPropertyEnabled(String propertyName) {
 390         return Log.isLoggable(propertyName, Log.VERBOSE);
 391     }
 392 
 393     @Override
 394     protected void onCreate(Bundle savedInstanceState) {
 395         if (DEBUG_STRICT_MODE) {
 396             StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
 397                     .detectDiskReads()
 398                     .detectDiskWrites()
 399                     .detectNetwork()   // or .detectAll() for all detectable problems
 400                     .penaltyLog()
 401                     .build());
 402             StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
 403                     .detectLeakedSqlLiteObjects()
 404                     .detectLeakedClosableObjects()
 405                     .penaltyLog()
 406                     .penaltyDeath()
 407                     .build());
 408         }
 409 
 410         super.onCreate(savedInstanceState);
 411 
 412         LauncherAppState.setApplicationContext(getApplicationContext());
 413         LauncherAppState app = LauncherAppState.getInstance();
 414         LauncherAppState.getLauncherProvider().setLauncherProviderChangeListener(this);
 415         // Determine the dynamic grid properties
 416         Point smallestSize = new Point();
 417         Point largestSize = new Point();
 418         Point realSize = new Point();
 419         Display display = getWindowManager().getDefaultDisplay();
 420         display.getCurrentSizeRange(smallestSize, largestSize);
 421         display.getRealSize(realSize);
 422         DisplayMetrics dm = new DisplayMetrics();
 423         display.getMetrics(dm);
 424 
 425         // Lazy-initialize the dynamic grid
 426         DeviceProfile grid = app.initDynamicGrid(this,
 427                 Math.min(smallestSize.x, smallestSize.y),
 428                 Math.min(largestSize.x, largestSize.y),
 429                 realSize.x, realSize.y,
 430                 dm.widthPixels, dm.heightPixels);
 431 
<abbr title=" 432         // the LauncherApplication should call this, but in case of Instrumentation it might not be present yet"> 432         // the LauncherApplication should call this, but in case of Instrumentation it might not be prese🔵</abbr>
 433         mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(),
 434                 Context.MODE_PRIVATE);
 435         mIsSafeModeEnabled = getPackageManager().isSafeMode();
 436         mModel = app.setLauncher(this);
 437         mIconCache = app.getIconCache();
 438         mIconCache.flushInvalidIcons(grid);
 439         mDragController = new DragController(this);
 440         mInflater = getLayoutInflater();
 441 
 442         mStats = new Stats(this);
 443 
 444         mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
 445 
 446         mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
 447         mAppWidgetHost.startListening();
 448 
 449         // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
 450         // this also ensures that any synchronous binding below doesn&#x27;t re-trigger another
 451         // LauncherModel load.
 452         mPaused = false;
 453 
 454         if (PROFILE_STARTUP) {
 455             android.os.Debug.startMethodTracing(
 456                     Environment.getExternalStorageDirectory() + &quot;/launcher&quot;);
 457         }
 458 
 459         checkForLocaleChange();
 460         setContentView(R.layout.launcher);
 461 
 462         setupViews();
 463         grid.layout(this);
 464 
 465         registerContentObservers();
 466 
 467         lockAllApps();
 468 
 469         mSavedState = savedInstanceState;
 470         restoreState(mSavedState);
 471 
 472         if (PROFILE_STARTUP) {
 473             android.os.Debug.stopMethodTracing();
 474         }
 475 
 476         if (!mRestoring) {
 477             if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
 478                 // If the user leaves launcher, then we should just load items asynchronously when
 479                 // they return.
 480                 mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
 481             } else {
 482                 // We only load the page synchronously if the user rotates (or triggers a
 483                 // configuration change) while launcher is in the foreground
 484                 mModel.startLoader(true, mWorkspace.getRestorePage());
 485             }
 486         }
 487 
 488         // For handling default keys
 489         mDefaultKeySsb = new SpannableStringBuilder();
 490         Selection.setSelection(mDefaultKeySsb, 0);
 491 
 492         IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
 493         registerReceiver(mCloseSystemDialogsReceiver, filter);
 494 
 495         updateGlobalIcons();
 496 
 497         // On large interfaces, we want the screen to auto-rotate based on the current orientation
 498         unlockScreenOrientation(true);
 499 
 500 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 501         if (shouldShowIntroScreen()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 502             showIntroScreen();</span>
 503 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 504         if (mModel.canMigrateFromOldLauncherDb()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 505             mLauncherClings.showMigrationCling();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 506         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 507             mLauncherClings.showFirstRunCling();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 508         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 509     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 510 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 511     protected void onUserLeaveHint() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 512         super.onUserLeaveHint();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 513         sPausedFromUserAction = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 514     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 515 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 516     /** To be overriden by subclasses to hint to Launcher that we have custom content */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 517     protected boolean hasCustomContentToLeft() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 518         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 519     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 520 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 521     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 522      * To be overridden by subclasses to create the custom content and call</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 523      * {@link #addToCustomContentPage}. This will only be invoked if</span>
 524 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 525         // The two first run cling paths are mutually exclusive, if the launcher is preinstalled</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 526         // on the device, then we always show the first run cling experience (or if there is no</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 527         // launcher2). Otherwise, we prompt the user upon started for migration</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 528         showFirstRunActivity();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 529         if (mLauncherClings.shouldShowFirstRunOrMigrationClings()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 530             if (mModel.canMigrateFromOldLauncherDb(this)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 531                 mLauncherClings.showMigrationCling();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 532             } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 533                 mLauncherClings.showFirstRunCling();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 534             }</span>
 535 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 536         } else {
 537 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 538             showFirstRunActivity();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 539             showFirstRunClings();</span>
 540 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 541 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 542     /** To be overriden by subclasses to hint to Launcher that we have custom content */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 543     protected boolean hasCustomContentToLeft() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 544         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 545     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 546 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 547     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 548      * To be overridden by subclasses to create the custom content and call</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 549      * {@link #addToCustomContentPage}. This will only be invoked if</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 550      * {@link #hasCustomContentToLeft()} is {@code true}.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 551      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 552     protected void addCustomContentToLeft() {</span>
 553 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 554             mLauncherClings.removeFirstRunAndMigrationClings();</span>
 555 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 556         }
 557     }
 558 
 559     @Override
 560     public void onLauncherProviderChange() { }
 561 
 562     /** To be overriden by subclasses to hint to Launcher that we have custom content */
 563     protected boolean hasCustomContentToLeft() {
 564         return false;
 565     }
 566 
 567     /**
 568      * To be overridden by subclasses to populate the custom content container and call
 569      * {@link #addToCustomContentPage}. This will only be invoked if
 570      * {@link #hasCustomContentToLeft()} is {@code true}.
 571      */
 572     protected void populateCustomContentContainer() {
 573     }
 574 
 575     /**
 576      * Invoked by subclasses to signal a change to the {@link #addCustomContentToLeft} value to
 577      * ensure the custom content page is added or removed if necessary.
 578      */
 579     protected void invalidateHasCustomContentToLeft() {
 580         if (mWorkspace == null || mWorkspace.getScreenOrder().isEmpty()) {
 581             // Not bound yet, wait for bindScreens to be called.
 582             return;
 583         }
 584 
 585         if (!mWorkspace.hasCustomContent() &amp;&amp; hasCustomContentToLeft()) {
 586             // Create the custom content page and call the subclass to populate it.
 587             mWorkspace.createCustomContentContainer();
 588             populateCustomContentContainer();
 589         } else if (mWorkspace.hasCustomContent() &amp;&amp; !hasCustomContentToLeft()) {
 590             mWorkspace.removeCustomContentPage();
 591         }
 592     }
 593 
 594     private void updateGlobalIcons() {
 595         boolean searchVisible = false;
 596         boolean voiceVisible = false;
 597         // If we have a saved version of these external icons, we load them up immediately
 598         int coi = getCurrentOrientationIndexForGlobalIcons();
 599         if (sGlobalSearchIcon[coi] == null || sVoiceSearchIcon[coi] == null) {
 600             searchVisible = updateGlobalSearchIcon();
 601             voiceVisible = updateVoiceSearchIcon(searchVisible);
 602         }
 603         if (sGlobalSearchIcon[coi] != null) {
 604              updateGlobalSearchIcon(sGlobalSearchIcon[coi]);
 605              searchVisible = true;
 606         }
 607         if (sVoiceSearchIcon[coi] != null) {
 608             updateVoiceSearchIcon(sVoiceSearchIcon[coi]);
 609             voiceVisible = true;
 610         }
 611         if (mSearchDropTargetBar != null) {
 612             mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
 613         }
 614     }
 615 
 616     private void checkForLocaleChange() {
 617         if (sLocaleConfiguration == null) {
 618             new AsyncTask&lt;Void, Void, LocaleConfiguration&gt;() {
 619                 @Override
 620                 protected LocaleConfiguration doInBackground(Void... unused) {
 621                     LocaleConfiguration localeConfiguration = new LocaleConfiguration();
 622                     readConfiguration(Launcher.this, localeConfiguration);
 623                     return localeConfiguration;
 624                 }
 625 
 626                 @Override
 627                 protected void onPostExecute(LocaleConfiguration result) {
 628                     sLocaleConfiguration = result;
 629                     checkForLocaleChange();  // recursive, but now with a locale configuration
 630                 }
 631             }.execute();
 632             return;
 633         }
 634 
 635         final Configuration configuration = getResources().getConfiguration();
 636 
 637         final String previousLocale = sLocaleConfiguration.locale;
 638         final String locale = configuration.locale.toString();
 639 
 640         final int previousMcc = sLocaleConfiguration.mcc;
 641         final int mcc = configuration.mcc;
 642 
 643         final int previousMnc = sLocaleConfiguration.mnc;
 644         final int mnc = configuration.mnc;
 645 
<abbr title=" 646         boolean localeChanged = !locale.equals(previousLocale) || mcc != previousMcc || mnc != previousMnc;"> 646         boolean localeChanged = !locale.equals(previousLocale) || mcc != previousMcc || mnc != previousMn🔵</abbr>
 647 
 648         if (localeChanged) {
 649             sLocaleConfiguration.locale = locale;
 650             sLocaleConfiguration.mcc = mcc;
 651             sLocaleConfiguration.mnc = mnc;
 652 
 653             mIconCache.flush();
 654 
 655             final LocaleConfiguration localeConfiguration = sLocaleConfiguration;
 656             new AsyncTask&lt;Void, Void, Void&gt;() {
 657                 public Void doInBackground(Void ... args) {
 658                     writeConfiguration(Launcher.this, localeConfiguration);
 659                     return null;
 660                 }
 661             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 662         }
 663     }
 664 
 665     private static class LocaleConfiguration {
 666         public String locale;
 667         public int mcc = -1;
 668         public int mnc = -1;
 669     }
 670 
 671     private static void readConfiguration(Context context, LocaleConfiguration configuration) {
 672         DataInputStream in = null;
 673         try {
 674             in = new DataInputStream(context.openFileInput(PREFERENCES));
 675             configuration.locale = in.readUTF();
 676             configuration.mcc = in.readInt();
 677             configuration.mnc = in.readInt();
 678         } catch (FileNotFoundException e) {
 679             // Ignore
 680         } catch (IOException e) {
 681             // Ignore
 682         } finally {
 683             if (in != null) {
 684                 try {
 685                     in.close();
 686                 } catch (IOException e) {
 687                     // Ignore
 688                 }
 689             }
 690         }
 691     }
 692 
 693     private static void writeConfiguration(Context context, LocaleConfiguration configuration) {
 694         DataOutputStream out = null;
 695         try {
 696             out = new DataOutputStream(context.openFileOutput(PREFERENCES, MODE_PRIVATE));
 697             out.writeUTF(configuration.locale);
 698             out.writeInt(configuration.mcc);
 699             out.writeInt(configuration.mnc);
 700             out.flush();
 701         } catch (FileNotFoundException e) {
 702             // Ignore
 703         } catch (IOException e) {
 704             //noinspection ResultOfMethodCallIgnored
 705             context.getFileStreamPath(PREFERENCES).delete();
 706         } finally {
 707             if (out != null) {
 708                 try {
 709                     out.close();
 710                 } catch (IOException e) {
 711                     // Ignore
 712                 }
 713             }
 714         }
 715     }
 716 
 717     public Stats getStats() {
 718         return mStats;
 719     }
 720 
 721     public LayoutInflater getInflater() {
 722         return mInflater;
 723     }
 724 
 725     boolean isDraggingEnabled() {
 726         // We prevent dragging when we are loading the workspace as it is possible to pick up a view
 727         // that is subsequently removed from the workspace in startBinding().
 728         return !mModel.isLoadingWorkspace();
 729     }
 730 
 731     static int getScreen() {
 732         synchronized (sLock) {
 733             return sScreen;
 734         }
 735     }
 736 
 737     static void setScreen(int screen) {
 738         synchronized (sLock) {
 739             sScreen = screen;
 740         }
 741     }
 742 
 743     public static int generateViewId() {
 744         if (Build.VERSION.SDK_INT &gt;= 17) {
 745             return View.generateViewId();
 746         } else {
 747             // View.generateViewId() is not available. The following fallback logic is a copy
 748             // of its implementation.
 749             for (;;) {
 750                 final int result = sNextGeneratedId.get();
 751                 // aapt-generated IDs have the high byte nonzero; clamp to the range under that.
 752                 int newValue = result + 1;
 753                 if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.
 754                 if (sNextGeneratedId.compareAndSet(result, newValue)) {
 755                     return result;
 756                 }
 757             }
 758         }
 759     }
 760 
 761     public int getViewIdForItem(ItemInfo info) {
 762         // This cast is safe given the &gt; 2B range for int.
 763         int itemId = (int) info.id;
 764         if (mItemIdToViewId.containsKey(itemId)) {
 765             return mItemIdToViewId.get(itemId);
 766         }
 767         int viewId = generateViewId();
 768         mItemIdToViewId.put(itemId, viewId);
 769         return viewId;
 770     }
 771 
 772     /**
 773      * Returns whether we should delay spring loaded mode -- for shortcuts and widgets that have
 774      * a configuration step, this allows the proper animations to run after other transitions.
 775      */
 776     private long completeAdd(PendingAddArguments args) {
 777         long screenId = args.screenId;
 778         if (args.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 779             // When the screen id represents an actual screen (as opposed to a rank) we make sure
 780             // that the drop page actually exists.
 781             screenId = ensurePendingDropLayoutExists(args.screenId);
 782         }
 783 
 784         switch (args.requestCode) {
 785             case REQUEST_CREATE_SHORTCUT:
 786                 completeAddShortcut(args.intent, args.container, screenId, args.cellX,
 787                         args.cellY);
 788                 break;
 789             case REQUEST_CREATE_APPWIDGET:
 790                 completeAddAppWidget(args.appWidgetId, args.container, screenId, null, null);
 791                 break;
 792             case REQUEST_RECONFIGURE_APPWIDGET:
 793                 completeRestoreAppWidget(args.appWidgetId);
 794                 break;
 795         }
 796         // Before adding this resetAddInfo(), after a shortcut was added to a workspace screen,
 797         // if you turned the screen off and then back while in All Apps, Launcher would not
 798         // return to the workspace. Clearing mAddInfo.container here fixes this issue
 799         resetAddInfo();
 800         return screenId;
 801     }
 802 
 803     @Override
 804     protected void onActivityResult(
 805             final int requestCode, final int resultCode, final Intent data) {
 806         // Reset the startActivity waiting flag
 807         setWaitingForResult(false);
 808         final int pendingAddWidgetId = mPendingAddWidgetId;
 809         mPendingAddWidgetId = -1;
 810 
 811         Runnable exitSpringLoaded = new Runnable() {
 812             @Override
 813             public void run() {
 814                 exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 815                         EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 816             }
 817         };
 818 
 819         if (requestCode == REQUEST_BIND_APPWIDGET) {
 820             final int appWidgetId = data != null ?
 821                     data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1) : -1;
 822             if (resultCode == RESULT_CANCELED) {
 823                 completeTwoStageWidgetDrop(RESULT_CANCELED, appWidgetId);
 824                 mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 825                         ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 826             } else if (resultCode == RESULT_OK) {
 827                 addAppWidgetImpl(appWidgetId, mPendingAddInfo, null,
 828                         mPendingAddWidgetInfo, ON_ACTIVITY_RESULT_ANIMATION_DELAY);
 829             }
 830             return;
 831         } else if (requestCode == REQUEST_PICK_WALLPAPER) {
 832             if (resultCode == RESULT_OK &amp;&amp; mWorkspace.isInOverviewMode()) {
 833                 mWorkspace.exitOverviewMode(false);
 834             }
 835             return;
 836         }
 837 
 838         boolean isWidgetDrop = (requestCode == REQUEST_PICK_APPWIDGET ||
 839                 requestCode == REQUEST_CREATE_APPWIDGET);
 840 
 841         final boolean workspaceLocked = isWorkspaceLocked();
 842         // We have special handling for widgets
 843         if (isWidgetDrop) {
 844             final int appWidgetId;
 845             int widgetId = data != null ? data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
 846                     : -1;
 847             if (widgetId &lt; 0) {
 848                 appWidgetId = pendingAddWidgetId;
 849             } else {
 850                 appWidgetId = widgetId;
 851             }
 852 
 853             final int result;
 854             if (appWidgetId &lt; 0 || resultCode == RESULT_CANCELED) {
 855                 Log.e(TAG, &quot;Error: appWidgetId (EXTRA_APPWIDGET_ID) was not &quot; +
 856                         &quot;returned from the widget configuration activity.&quot;);
 857                 result = RESULT_CANCELED;
 858                 completeTwoStageWidgetDrop(result, appWidgetId);
 859                 final Runnable onComplete = new Runnable() {
 860                     @Override
 861                     public void run() {
 862                         exitSpringLoadedDragModeDelayed(false, 0, null);
 863                     }
 864                 };
 865                 if (workspaceLocked) {
 866                     // No need to remove the empty screen if we&#x27;re mid-binding, as the
 867                     // the bind will not add the empty screen.
 868                     mWorkspace.postDelayed(onComplete, ON_ACTIVITY_RESULT_ANIMATION_DELAY);
 869                 } else {
 870                     mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete,
 871                             ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 872                 }
 873             } else {
 874                 if (!workspaceLocked) {
 875                     if (mPendingAddInfo.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 876                         // When the screen id represents an actual screen (as opposed to a rank)
 877                         // we make sure that the drop page actually exists.
 878                         mPendingAddInfo.screenId =
 879                                 ensurePendingDropLayoutExists(mPendingAddInfo.screenId);
 880                     }
 881                     final CellLayout dropLayout = mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
 882 
 883                     dropLayout.setDropPending(true);
 884                     final Runnable onComplete = new Runnable() {
 885                         @Override
 886                         public void run() {
 887                             completeTwoStageWidgetDrop(resultCode, appWidgetId);
 888                             dropLayout.setDropPending(false);
 889                         }
 890                     };
 891                     mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete,
 892                             ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 893                 } else {
 894                     PendingAddArguments args = preparePendingAddArgs(requestCode, data, appWidgetId,
 895                             mPendingAddInfo);
 896                     sPendingAddItem = args;
 897                 }
 898             }
 899             return;
 900         }
 901 
 902         if (requestCode == REQUEST_RECONFIGURE_APPWIDGET) {
 903             if (resultCode == RESULT_OK) {
 904                 // Update the widget view.
 905                 PendingAddArguments args = preparePendingAddArgs(requestCode, data,
 906                         pendingAddWidgetId, mPendingAddInfo);
 907                 if (workspaceLocked) {
 908                     sPendingAddItem = args;
 909                 } else {
 910                     completeAdd(args);
 911                 }
 912             }
 913             // Leave the widget in the pending state if the user canceled the configure.
 914             return;
 915         }
 916 
 917         // The pattern used here is that a user PICKs a specific application,
 918         // which, depending on the target, might need to CREATE the actual target.
 919 
 920         // For example, the user would PICK_SHORTCUT for &quot;Music playlist&quot;, and we
 921         // launch over to the Music app to actually CREATE_SHORTCUT.
 922         if (resultCode == RESULT_OK &amp;&amp; mPendingAddInfo.container != ItemInfo.NO_ID) {
 923             final PendingAddArguments args = preparePendingAddArgs(requestCode, data, -1,
 924                     mPendingAddInfo);
 925             if (isWorkspaceLocked()) {
 926                 sPendingAddItem = args;
 927             } else {
 928                 completeAdd(args);
 929                 mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 930                         ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 931             }
 932         } else if (resultCode == RESULT_CANCELED) {
 933             mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 934                     ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 935         }
 936         mDragLayer.clearAnimatedView();
 937     }
 938 
 939     private PendingAddArguments preparePendingAddArgs(int requestCode, Intent data, int
 940             appWidgetId, ItemInfo info) {
 941         PendingAddArguments args = new PendingAddArguments();
 942         args.requestCode = requestCode;
 943         args.intent = data;
 944         args.container = info.container;
 945         args.screenId = info.screenId;
 946         args.cellX = info.cellX;
 947         args.cellY = info.cellY;
 948         args.appWidgetId = appWidgetId;
 949         return args;
 950     }
 951 
 952     /**
 953      * Check to see if a given screen id exists. If not, create it at the end, return the new id.
 954      *
 955      * @param screenId the screen id to check
 956      * @return the new screen, or screenId if it exists
 957      */
 958     private long ensurePendingDropLayoutExists(long screenId) {
 959         CellLayout dropLayout =
 960                 (CellLayout) mWorkspace.getScreenWithId(screenId);
 961         if (dropLayout == null) {
 962             // it&#x27;s possible that the add screen was removed because it was
 963             // empty and a re-bind occurred
 964             mWorkspace.addExtraEmptyScreen();
 965             return mWorkspace.commitExtraEmptyScreen();
 966         } else {
 967             return screenId;
 968         }
 969     }
 970 
 971     private void completeTwoStageWidgetDrop(final int resultCode, final int appWidgetId) {
 972         CellLayout cellLayout =
 973                 (CellLayout) mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
 974         Runnable onCompleteRunnable = null;
 975         int animationType = 0;
 976 
 977         AppWidgetHostView boundWidget = null;
 978         if (resultCode == RESULT_OK) {
 979             animationType = Workspace.COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION;
 980             final AppWidgetHostView layout = mAppWidgetHost.createView(this, appWidgetId,
 981                     mPendingAddWidgetInfo);
 982             boundWidget = layout;
 983             onCompleteRunnable = new Runnable() {
 984                 @Override
 985                 public void run() {
 986                     completeAddAppWidget(appWidgetId, mPendingAddInfo.container,
 987                             mPendingAddInfo.screenId, layout, null);
 988                     exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 989                             EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 990                 }
 991             };
 992         } else if (resultCode == RESULT_CANCELED) {
 993             mAppWidgetHost.deleteAppWidgetId(appWidgetId);
 994             animationType = Workspace.CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION;
 995         }
 996         if (mDragLayer.getAnimatedView() != null) {
 997             mWorkspace.animateWidgetDrop(mPendingAddInfo, cellLayout,
 998                     (DragView) mDragLayer.getAnimatedView(), onCompleteRunnable,
 999                     animationType, boundWidget, true);
1000         } else if (onCompleteRunnable != null) {
1001             // The animated view may be null in the case of a rotation during widget configuration
1002             onCompleteRunnable.run();
1003         }
1004     }
1005 
1006     @Override
1007     protected void onStop() {
1008         super.onStop();
1009         FirstFrameAnimatorHelper.setIsVisible(false);
1010     }
1011 
1012     @Override
1013     protected void onStart() {
1014         super.onStart();
1015         FirstFrameAnimatorHelper.setIsVisible(true);
1016     }
1017 
1018     @Override
1019     protected void onResume() {
1020         long startTime = 0;
1021         if (DEBUG_RESUME_TIME) {
1022             startTime = System.currentTimeMillis();
1023             Log.v(TAG, &quot;Launcher.onResume()&quot;);
1024         }
1025         super.onResume();
1026 
1027         // Restore the previous launcher state
1028         if (mOnResumeState == State.WORKSPACE) {
1029             showWorkspace(false);
1030         } else if (mOnResumeState == State.APPS_CUSTOMIZE) {
1031             showAllApps(false, mAppsCustomizeContent.getContentType(), false);
1032         }
1033         mOnResumeState = State.NONE;
1034 
1035         // Background was set to gradient in onPause(), restore to black if in all apps.
1036         setWorkspaceBackground(mState == State.WORKSPACE);
1037 
1038         mPaused = false;
1039         if (mRestoring || mOnResumeNeedsLoad) {
1040             setWorkspaceLoading(true);
1041             mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
1042             mRestoring = false;
1043             mOnResumeNeedsLoad = false;
1044         }
1045         if (mBindOnResumeCallbacks.size() &gt; 0) {
1046             // We might have postponed some bind calls until onResume (see waitUntilResume) --
1047             // execute them here
1048             long startTimeCallbacks = 0;
1049             if (DEBUG_RESUME_TIME) {
1050                 startTimeCallbacks = System.currentTimeMillis();
1051             }
1052 
1053             if (mAppsCustomizeContent != null) {
1054                 mAppsCustomizeContent.setBulkBind(true);
1055             }
1056             for (int i = 0; i &lt; mBindOnResumeCallbacks.size(); i++) {
1057                 mBindOnResumeCallbacks.get(i).run();
1058             }
1059             if (mAppsCustomizeContent != null) {
1060                 mAppsCustomizeContent.setBulkBind(false);
1061             }
1062             mBindOnResumeCallbacks.clear();
1063             if (DEBUG_RESUME_TIME) {
1064                 Log.d(TAG, &quot;Time spent processing callbacks in onResume: &quot; +
1065                     (System.currentTimeMillis() - startTimeCallbacks));
1066             }
1067         }
1068         if (mOnResumeCallbacks.size() &gt; 0) {
1069             for (int i = 0; i &lt; mOnResumeCallbacks.size(); i++) {
1070                 mOnResumeCallbacks.get(i).run();
1071             }
1072             mOnResumeCallbacks.clear();
1073         }
1074 
1075         // Reset the pressed state of icons that were locked in the press state while activities
1076         // were launching
1077         if (mWaitingForResume != null) {
1078             // Resets the previous workspace icon press state
1079             mWaitingForResume.setStayPressed(false);
1080         }
1081 
1082         // It is possible that widgets can receive updates while launcher is not in the foreground.
1083         // Consequently, the widgets will be inflated in the orientation of the foreground activity
1084         // (framework issue). On resuming, we ensure that any widgets are inflated for the current
1085         // orientation.
1086         getWorkspace().reinflateWidgetsIfNecessary();
1087 
1088         // Process any items that were added while Launcher was away.
1089         InstallShortcutReceiver.disableAndFlushInstallQueue(this);
1090 
1091         // Update the voice search button proxy
1092         updateVoiceButtonProxyVisible(false);
1093 
1094         // Again, as with the above scenario, it&#x27;s possible that one or more of the global icons
1095         // were updated in the wrong orientation.
1096         updateGlobalIcons();
1097         if (DEBUG_RESUME_TIME) {
1098             Log.d(TAG, &quot;Time spent in onResume: &quot; + (System.currentTimeMillis() - startTime));
1099         }
1100 
1101         if (mWorkspace.getCustomContentCallbacks() != null) {
1102             // If we are resuming and the custom content is the current page, we call onShow().
1103             // It is also poassible that onShow will instead be called slightly after first layout
1104             // if PagedView#setRestorePage was set to the custom content page in onCreate().
1105             if (mWorkspace.isOnOrMovingToCustomContent()) {
1106                 mWorkspace.getCustomContentCallbacks().onShow(true);
1107             }
1108         }
1109         mWorkspace.updateInteractionForState();
1110         mWorkspace.onResume();
1111 
1112         PackageInstallerCompat.getInstance(this).onResume();
1113     }
1114 
1115     @Override
1116     protected void onPause() {
1117         // Ensure that items added to Launcher are queued until Launcher returns
1118         InstallShortcutReceiver.enableInstallQueue();
1119         PackageInstallerCompat.getInstance(this).onPause();
1120 
1121         super.onPause();
1122         mPaused = true;
1123         mDragController.cancelDrag();
1124         mDragController.resetLastGestureUpTime();
1125 
1126         // We call onHide() aggressively. The custom content callbacks should be able to
1127         // debounce excess onHide calls.
1128         if (mWorkspace.getCustomContentCallbacks() != null) {
1129             mWorkspace.getCustomContentCallbacks().onHide();
1130         }
1131     }
1132 
1133     QSBScroller mQsbScroller = new QSBScroller() {
1134         int scrollY = 0;
1135 
1136         @Override
1137         public void setScrollY(int scroll) {
1138             scrollY = scroll;
1139 
1140             if (mWorkspace.isOnOrMovingToCustomContent()) {
1141                 mSearchDropTargetBar.setTranslationY(- scrollY);
1142                 getQsbBar().setTranslationY(-scrollY);
1143             }
1144         }
1145     };
1146 
1147     public void resetQSBScroll() {
1148         mSearchDropTargetBar.animate().translationY(0).start();
1149         getQsbBar().animate().translationY(0).start();
1150     }
1151 
1152     public interface CustomContentCallbacks {
1153         // Custom content is completely shown. {@code fromResume} indicates whether this was caused
1154         // by a onResume or by scrolling otherwise.
1155         public void onShow(boolean fromResume);
1156 
1157         // Custom content is completely hidden
1158         public void onHide();
1159 
1160         // Custom content scroll progress changed. From 0 (not showing) to 1 (fully showing).
1161         public void onScrollProgressChanged(float progress);
1162 
1163         // Indicates whether the user is allowed to scroll away from the custom content.
1164         boolean isScrollingAllowed();
1165     }
1166 
1167     protected boolean hasSettings() {
1168         return false;
1169     }
1170 
1171     public interface QSBScroller {
1172         public void setScrollY(int scrollY);
1173     }
1174 
1175     public QSBScroller addToCustomContentPage(View customContent,
1176             CustomContentCallbacks callbacks, String description) {
1177         mWorkspace.addToCustomContentPage(customContent, callbacks, description);
1178         return mQsbScroller;
1179     }
1180 
1181     // The custom content needs to offset its content to account for the QSB
1182     public int getTopOffsetForCustomContent() {
1183         return mWorkspace.getPaddingTop();
1184     }
1185 
1186     @Override
1187     public Object onRetainNonConfigurationInstance() {
1188         // Flag the loader to stop early before switching
1189         if (mModel.isCurrentCallbacks(this)) {
1190             mModel.stopLoader();
1191         }
1192         if (mAppsCustomizeContent != null) {
1193             mAppsCustomizeContent.surrender();
1194         }
1195         return Boolean.TRUE;
1196     }
1197 
1198     // We can&#x27;t hide the IME if it was forced open.  So don&#x27;t bother
1199     @Override
1200     public void onWindowFocusChanged(boolean hasFocus) {
1201         super.onWindowFocusChanged(hasFocus);
1202         mHasFocus = hasFocus;
1203     }
1204 
1205     private boolean acceptFilter() {
1206         final InputMethodManager inputManager = (InputMethodManager)
1207                 getSystemService(Context.INPUT_METHOD_SERVICE);
1208         return !inputManager.isFullscreenMode();
1209     }
1210 
1211     @Override
1212     public boolean onKeyDown(int keyCode, KeyEvent event) {
1213         final int uniChar = event.getUnicodeChar();
1214         final boolean handled = super.onKeyDown(keyCode, event);
1215         final boolean isKeyNotWhitespace = uniChar &gt; 0 &amp;&amp; !Character.isWhitespace(uniChar);
1216         if (!handled &amp;&amp; acceptFilter() &amp;&amp; isKeyNotWhitespace) {
1217             boolean gotKey = TextKeyListener.getInstance().onKeyDown(mWorkspace, mDefaultKeySsb,
1218                     keyCode, event);
1219             if (gotKey &amp;&amp; mDefaultKeySsb != null &amp;&amp; mDefaultKeySsb.length() &gt; 0) {
1220                 // something usable has been typed - start a search
1221                 // the typed text will be retrieved and cleared by
1222                 // showSearchDialog()
1223                 // If there are multiple keystrokes before the search dialog takes focus,
1224                 // onSearchRequested() will be called for every keystroke,
1225                 // but it is idempotent, so it&#x27;s fine.
1226                 return onSearchRequested();
1227             }
1228         }
1229 
1230         // Eat the long press event so the keyboard doesn&#x27;t come up.
1231         if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.isLongPress()) {
1232             return true;
1233         }
1234 
1235         return handled;
1236     }
1237 
1238     private String getTypedText() {
1239         return mDefaultKeySsb.toString();
1240     }
1241 
1242     private void clearTypedText() {
1243         mDefaultKeySsb.clear();
1244         mDefaultKeySsb.clearSpans();
1245         Selection.setSelection(mDefaultKeySsb, 0);
1246     }
1247 
1248     /**
1249      * Given the integer (ordinal) value of a State enum instance, convert it to a variable of type
1250      * State
1251      */
1252     private static State intToState(int stateOrdinal) {
1253         State state = State.WORKSPACE;
1254         final State[] stateValues = State.values();
1255         for (int i = 0; i &lt; stateValues.length; i++) {
1256             if (stateValues[i].ordinal() == stateOrdinal) {
1257                 state = stateValues[i];
1258                 break;
1259             }
1260         }
1261         return state;
1262     }
1263 
1264     /**
1265      * Restores the previous state, if it exists.
1266      *
1267      * @param savedState The previous state.
1268      */
1269     @SuppressWarnings(&quot;unchecked&quot;)
1270     private void restoreState(Bundle savedState) {
1271         if (savedState == null) {
1272             return;
1273         }
1274 
1275         State state = intToState(savedState.getInt(RUNTIME_STATE, State.WORKSPACE.ordinal()));
1276         if (state == State.APPS_CUSTOMIZE) {
1277             mOnResumeState = State.APPS_CUSTOMIZE;
1278         }
1279 
1280         int currentScreen = savedState.getInt(RUNTIME_STATE_CURRENT_SCREEN,
1281                 PagedView.INVALID_RESTORE_PAGE);
1282         if (currentScreen != PagedView.INVALID_RESTORE_PAGE) {
1283             mWorkspace.setRestorePage(currentScreen);
1284         }
1285 
1286         final long pendingAddContainer = savedState.getLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, -1);
1287         final long pendingAddScreen = savedState.getLong(RUNTIME_STATE_PENDING_ADD_SCREEN, -1);
1288 
1289         if (pendingAddContainer != ItemInfo.NO_ID &amp;&amp; pendingAddScreen &gt; -1) {
1290             mPendingAddInfo.container = pendingAddContainer;
1291             mPendingAddInfo.screenId = pendingAddScreen;
1292             mPendingAddInfo.cellX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_X);
1293             mPendingAddInfo.cellY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_Y);
1294             mPendingAddInfo.spanX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_X);
1295             mPendingAddInfo.spanY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y);
1296             mPendingAddWidgetInfo = savedState.getParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO);
1297             mPendingAddWidgetId = savedState.getInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID);
1298             setWaitingForResult(true);
1299             mRestoring = true;
1300         }
1301 
1302         boolean renameFolder = savedState.getBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, false);
1303         if (renameFolder) {
1304             long id = savedState.getLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID);
1305             mFolderInfo = mModel.getFolderById(this, sFolders, id);
1306             mRestoring = true;
1307         }
1308 
1309         // Restore the AppsCustomize tab
1310         if (mAppsCustomizeTabHost != null) {
1311             String curTab = savedState.getString(&quot;apps_customize_currentTab&quot;);
1312             if (curTab != null) {
1313                 mAppsCustomizeTabHost.setContentTypeImmediate(
1314                         mAppsCustomizeTabHost.getContentTypeForTabTag(curTab));
1315                 mAppsCustomizeContent.loadAssociatedPages(
1316                         mAppsCustomizeContent.getCurrentPage());
1317             }
1318 
1319             int currentIndex = savedState.getInt(&quot;apps_customize_currentIndex&quot;);
1320             mAppsCustomizeContent.restorePageForIndex(currentIndex);
1321         }
1322         mItemIdToViewId = (HashMap&lt;Integer, Integer&gt;)
1323                 savedState.getSerializable(RUNTIME_STATE_VIEW_IDS);
1324     }
1325 
1326     /**
1327      * Finds all the views we need and configure them properly.
1328      */
1329     private void setupViews() {
1330         final DragController dragController = mDragController;
1331 
1332         mLauncherView = findViewById(R.id.launcher);
1333         mFocusHandler = (FocusIndicatorView) findViewById(R.id.focus_indicator);
1334         mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
1335         mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
1336         mWorkspace.setPageSwitchListener(this);
1337         mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);
1338 
1339         mLauncherView.setSystemUiVisibility(
1340                 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
1341         mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
1342 
1343         // Setup the drag layer
1344         mDragLayer.setup(this, dragController);
1345 
1346         // Setup the hotseat
1347         mHotseat = (Hotseat) findViewById(R.id.hotseat);
1348         if (mHotseat != null) {
1349             mHotseat.setup(this);
1350             mHotseat.setOnLongClickListener(this);
1351         }
1352 
1353         mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
1354         View widgetButton = findViewById(R.id.widget_button);
1355         widgetButton.setOnClickListener(new OnClickListener() {
1356             @Override
1357             public void onClick(View arg0) {
1358                 if (!mWorkspace.isSwitchingState()) {
1359                     onClickAddWidgetButton(arg0);
1360                 }
1361             }
1362         });
1363         widgetButton.setOnTouchListener(getHapticFeedbackTouchListener());
1364 
1365         View wallpaperButton = findViewById(R.id.wallpaper_button);
1366         wallpaperButton.setOnClickListener(new OnClickListener() {
1367             @Override
1368             public void onClick(View arg0) {
1369                 if (!mWorkspace.isSwitchingState()) {
1370                     onClickWallpaperPicker(arg0);
1371                 }
1372             }
1373         });
1374         wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
1375 
1376         View settingsButton = findViewById(R.id.settings_button);
1377         if (hasSettings()) {
1378             settingsButton.setOnClickListener(new OnClickListener() {
1379                 @Override
1380                 public void onClick(View arg0) {
1381                     if (!mWorkspace.isSwitchingState()) {
1382                         onClickSettingsButton(arg0);
1383                     }
1384                 }
1385             });
1386             settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
1387         } else {
1388             settingsButton.setVisibility(View.GONE);
1389             FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) widgetButton.getLayoutParams();
1390             lp.gravity = Gravity.END | Gravity.TOP;
1391             widgetButton.requestLayout();
1392         }
1393 
1394         mOverviewPanel.setAlpha(0f);
1395 
1396         // Setup the workspace
1397         mWorkspace.setHapticFeedbackEnabled(false);
1398         mWorkspace.setOnLongClickListener(this);
1399         mWorkspace.setup(dragController);
1400         dragController.addDragListener(mWorkspace);
1401 
1402         // Get the search/delete bar
1403         mSearchDropTargetBar = (SearchDropTargetBar)
1404                 mDragLayer.findViewById(R.id.search_drop_target_bar);
1405 
1406         // Setup AppsCustomize
1407         mAppsCustomizeTabHost = (AppsCustomizeTabHost) findViewById(R.id.apps_customize_pane);
1408         mAppsCustomizeContent = (AppsCustomizePagedView)
1409                 mAppsCustomizeTabHost.findViewById(R.id.apps_customize_pane_content);
1410         mAppsCustomizeContent.setup(this, dragController);
1411 
1412         // Setup the drag controller (drop targets have to be added in reverse order in priority)
1413         dragController.setDragScoller(mWorkspace);
1414         dragController.setScrollView(mDragLayer);
1415         dragController.setMoveTarget(mWorkspace);
1416         dragController.addDropTarget(mWorkspace);
1417         if (mSearchDropTargetBar != null) {
1418             mSearchDropTargetBar.setup(this, dragController);
1419         }
1420 
1421         if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
1422             Log.v(TAG, &quot;adding WeightWatcher&quot;);
1423             mWeightWatcher = new WeightWatcher(this);
1424             mWeightWatcher.setAlpha(0.5f);
1425             ((FrameLayout) mLauncherView).addView(mWeightWatcher,
1426                     new FrameLayout.LayoutParams(
1427                             FrameLayout.LayoutParams.MATCH_PARENT,
1428                             FrameLayout.LayoutParams.WRAP_CONTENT,
1429                             Gravity.BOTTOM)
1430             );
1431 
1432             boolean show = shouldShowWeightWatcher();
1433             mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
1434         }
1435     }
1436 
1437     /**
1438      * Sets the all apps button. This method is called from {@link Hotseat}.
1439      */
1440     public void setAllAppsButton(View allAppsButton) {
1441         mAllAppsButton = allAppsButton;
1442     }
1443 
1444     public View getAllAppsButton() {
1445         return mAllAppsButton;
1446     }
1447 
1448     /**
1449      * Creates a view representing a shortcut.
1450      *
1451      * @param info The data structure describing the shortcut.
1452      *
1453      * @return A View inflated from R.layout.application.
1454      */
1455     View createShortcut(ShortcutInfo info) {
1456         return createShortcut(R.layout.application,
1457                 (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
1458     }
1459 
1460     /**
1461      * Creates a view representing a shortcut inflated from the specified resource.
1462      *
1463      * @param layoutResId The id of the XML layout used to create the shortcut.
1464      * @param parent The group the shortcut belongs to.
1465      * @param info The data structure describing the shortcut.
1466      *
1467      * @return A View inflated from layoutResId.
1468      */
1469     View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) {
1470         BubbleTextView favorite = (BubbleTextView) mInflater.inflate(layoutResId, parent, false);
1471         favorite.applyFromShortcutInfo(info, mIconCache, true);
1472         favorite.setOnClickListener(this);
1473         favorite.setOnFocusChangeListener(mFocusHandler);
1474         return favorite;
1475     }
1476 
1477     /**
1478      * Add a shortcut to the workspace.
1479      *
1480      * @param data The intent describing the shortcut.
1481      * @param cellInfo The position on screen where to create the shortcut.
1482      */
1483     private void completeAddShortcut(Intent data, long container, long screenId, int cellX,
1484             int cellY) {
1485         int[] cellXY = mTmpAddItemCellCoordinates;
1486         int[] touchXY = mPendingAddInfo.dropPos;
1487         CellLayout layout = getCellLayout(container, screenId);
1488 
1489         boolean foundCellSpan = false;
1490 
1491         ShortcutInfo info = mModel.infoFromShortcutIntent(this, data, null);
1492         if (info == null) {
1493             return;
1494         }
1495         final View view = createShortcut(info);
1496 
1497         // First we check if we already know the exact location where we want to add this item.
1498         if (cellX &gt;= 0 &amp;&amp; cellY &gt;= 0) {
1499             cellXY[0] = cellX;
1500             cellXY[1] = cellY;
1501             foundCellSpan = true;
1502 
1503             // If appropriate, either create a folder or add to an existing folder
1504             if (mWorkspace.createUserFolderIfNecessary(view, container, layout, cellXY, 0,
1505                     true, null,null)) {
1506                 return;
1507             }
1508             DragObject dragObject = new DragObject();
1509             dragObject.dragInfo = info;
1510             if (mWorkspace.addToExistingFolderIfNecessary(view, layout, cellXY, 0, dragObject,
1511                     true)) {
1512                 return;
1513             }
1514         } else if (touchXY != null) {
1515             // when dragging and dropping, just find the closest free spot
1516             int[] result = layout.findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, cellXY);
1517             foundCellSpan = (result != null);
1518         } else {
1519             foundCellSpan = layout.findCellForSpan(cellXY, 1, 1);
1520         }
1521 
1522         if (!foundCellSpan) {
1523             showOutOfSpaceMessage(isHotseatLayout(layout));
1524             return;
1525         }
1526 
1527         LauncherModel.addItemToDatabase(this, info, container, screenId, cellXY[0], cellXY[1], false);
1528 
1529         if (!mRestoring) {
1530             mWorkspace.addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1,
1531                     isWorkspaceLocked());
1532         }
1533     }
1534 
1535     static int[] getSpanForWidget(Context context, ComponentName component, int minWidth,
1536             int minHeight) {
1537         Rect padding = AppWidgetHostView.getDefaultPaddingForWidget(context, component, null);
1538         // We want to account for the extra amount of padding that we are adding to the widget
1539         // to ensure that it gets the full amount of space that it has requested
1540         int requiredWidth = minWidth + padding.left + padding.right;
1541         int requiredHeight = minHeight + padding.top + padding.bottom;
1542         return CellLayout.rectToCell(requiredWidth, requiredHeight, null);
1543     }
1544 
1545     static int[] getSpanForWidget(Context context, AppWidgetProviderInfo info) {
1546         return getSpanForWidget(context, info.provider, info.minWidth, info.minHeight);
1547     }
1548 
1549     static int[] getMinSpanForWidget(Context context, AppWidgetProviderInfo info) {
1550         return getSpanForWidget(context, info.provider, info.minResizeWidth, info.minResizeHeight);
1551     }
1552 
1553     static int[] getSpanForWidget(Context context, PendingAddWidgetInfo info) {
1554         return getSpanForWidget(context, info.componentName, info.minWidth, info.minHeight);
1555     }
1556 
1557     static int[] getMinSpanForWidget(Context context, PendingAddWidgetInfo info) {
1558         return getSpanForWidget(context, info.componentName, info.minResizeWidth,
1559                 info.minResizeHeight);
1560     }
1561 
1562     /**
1563      * Add a widget to the workspace.
1564      *
1565      * @param appWidgetId The app widget id
1566      * @param cellInfo The position on screen where to create the widget.
1567      */
1568     private void completeAddAppWidget(final int appWidgetId, long container, long screenId,
1569             AppWidgetHostView hostView, AppWidgetProviderInfo appWidgetInfo) {
1570         if (appWidgetInfo == null) {
1571             appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
1572         }
1573 
1574         // Calculate the grid spans needed to fit this widget
1575         CellLayout layout = getCellLayout(container, screenId);
1576 
1577         int[] minSpanXY = getMinSpanForWidget(this, appWidgetInfo);
1578         int[] spanXY = getSpanForWidget(this, appWidgetInfo);
1579 
1580         // Try finding open space on Launcher screen
1581         // We have saved the position to which the widget was dragged-- this really only matters
1582         // if we are placing widgets on a &quot;spring-loaded&quot; screen
1583         int[] cellXY = mTmpAddItemCellCoordinates;
1584         int[] touchXY = mPendingAddInfo.dropPos;
1585         int[] finalSpan = new int[2];
1586         boolean foundCellSpan = false;
1587         if (mPendingAddInfo.cellX &gt;= 0 &amp;&amp; mPendingAddInfo.cellY &gt;= 0) {
1588             cellXY[0] = mPendingAddInfo.cellX;
1589             cellXY[1] = mPendingAddInfo.cellY;
1590             spanXY[0] = mPendingAddInfo.spanX;
1591             spanXY[1] = mPendingAddInfo.spanY;
1592             foundCellSpan = true;
1593         } else if (touchXY != null) {
1594             // when dragging and dropping, just find the closest free spot
1595             int[] result = layout.findNearestVacantArea(
1596                     touchXY[0], touchXY[1], minSpanXY[0], minSpanXY[1], spanXY[0],
1597                     spanXY[1], cellXY, finalSpan);
1598             spanXY[0] = finalSpan[0];
1599             spanXY[1] = finalSpan[1];
1600             foundCellSpan = (result != null);
1601         } else {
1602             foundCellSpan = layout.findCellForSpan(cellXY, minSpanXY[0], minSpanXY[1]);
1603         }
1604 
1605         if (!foundCellSpan) {
1606             if (appWidgetId != -1) {
1607                 // Deleting an app widget ID is a void call but writes to disk before returning
1608                 // to the caller...
1609                 new AsyncTask&lt;Void, Void, Void&gt;() {
1610                     public Void doInBackground(Void ... args) {
1611                         mAppWidgetHost.deleteAppWidgetId(appWidgetId);
1612                         return null;
1613                     }
1614                 }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
1615             }
1616             showOutOfSpaceMessage(isHotseatLayout(layout));
1617             return;
1618         }
1619 
1620         // Build Launcher-specific widget info and save to database
1621         LauncherAppWidgetInfo launcherInfo = new LauncherAppWidgetInfo(appWidgetId,
1622                 appWidgetInfo.provider);
1623         launcherInfo.spanX = spanXY[0];
1624         launcherInfo.spanY = spanXY[1];
1625         launcherInfo.minSpanX = mPendingAddInfo.minSpanX;
1626         launcherInfo.minSpanY = mPendingAddInfo.minSpanY;
1627         launcherInfo.user = mAppWidgetManager.getUser(appWidgetInfo);
1628 
1629         LauncherModel.addItemToDatabase(this, launcherInfo,
1630                 container, screenId, cellXY[0], cellXY[1], false);
1631 
1632         if (!mRestoring) {
1633             if (hostView == null) {
1634                 // Perform actual inflation because we&#x27;re live
1635                 launcherInfo.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);
1636                 launcherInfo.hostView.setAppWidget(appWidgetId, appWidgetInfo);
1637             } else {
1638                 // The AppWidgetHostView has already been inflated and instantiated
1639                 launcherInfo.hostView = hostView;
1640             }
1641 
1642             launcherInfo.hostView.setTag(launcherInfo);
1643             launcherInfo.hostView.setVisibility(View.VISIBLE);
1644             launcherInfo.notifyWidgetSizeChanged(this);
1645 
1646             mWorkspace.addInScreen(launcherInfo.hostView, container, screenId, cellXY[0], cellXY[1],
1647                     launcherInfo.spanX, launcherInfo.spanY, isWorkspaceLocked());
1648 
1649             addWidgetToAutoAdvanceIfNeeded(launcherInfo.hostView, appWidgetInfo);
1650         }
1651         resetAddInfo();
1652     }
1653 
1654     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
1655         @Override
1656         public void onReceive(Context context, Intent intent) {
1657             final String action = intent.getAction();
1658             if (Intent.ACTION_SCREEN_OFF.equals(action)) {
1659                 mUserPresent = false;
1660                 mDragLayer.clearAllResizeFrames();
1661                 updateRunning();
1662 
1663                 // Reset AllApps to its initial state only if we are not in the middle of
1664                 // processing a multi-step drop
1665                 if (mAppsCustomizeTabHost != null &amp;&amp; mPendingAddInfo.container == ItemInfo.NO_ID) {
1666                     showWorkspace(false);
1667                 }
1668             } else if (Intent.ACTION_USER_PRESENT.equals(action)) {
1669                 mUserPresent = true;
1670                 updateRunning();
1671             } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.DELETE_DATABASE.equals(action)) {
1672                 mModel.resetLoadedState(false, true);
1673                 mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,
1674                         LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE);
1675             } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.MIGRATE_DATABASE.equals(action)) {
1676                 mModel.resetLoadedState(false, true);
1677                 mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,
1678                         LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE
1679                                 | LauncherModel.LOADER_FLAG_MIGRATE_SHORTCUTS);
1680             } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)
1681                     || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) {
1682                 getModel().forceReload();
1683             }
1684         }
1685     };
1686 
1687     @Override
1688     public void onAttachedToWindow() {
1689         super.onAttachedToWindow();
1690 
1691         // Listen for broadcasts related to user-presence
1692         final IntentFilter filter = new IntentFilter();
1693         filter.addAction(Intent.ACTION_SCREEN_OFF);
1694         filter.addAction(Intent.ACTION_USER_PRESENT);
1695         // For handling managed profiles
1696         filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED);
1697         filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED);
1698         if (ENABLE_DEBUG_INTENTS) {
1699             filter.addAction(DebugIntents.DELETE_DATABASE);
1700             filter.addAction(DebugIntents.MIGRATE_DATABASE);
1701         }
1702         registerReceiver(mReceiver, filter);
1703         FirstFrameAnimatorHelper.initializeDrawListener(getWindow().getDecorView());
1704         setupTransparentSystemBarsForLmp();
1705         mAttached = true;
1706         mVisible = true;
1707     }
1708 
1709     /**
1710      * Sets up transparent navigation and status bars in LMP.
1711      * This method is a no-op for other platform versions.
1712      */
1713     @TargetApi(19)
1714     private void setupTransparentSystemBarsForLmp() {
1715         // TODO(sansid): use the APIs directly when compiling against L sdk.
1716         // Currently we use reflection to access the flags and the API to set the transparency
1717         // on the System bars.
1718         if (Utilities.isLmpOrAbove()) {
1719             try {
1720                 getWindow().getAttributes().systemUiVisibility |=
1721                         (View.SYSTEM_UI_FLAG_LAYOUT_STABLE
1722                                 | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
1723                                 | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
1724                 getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS
1725                         | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
1726                 Field drawsSysBackgroundsField = WindowManager.LayoutParams.class.getField(
1727                         &quot;FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS&quot;);
1728                 getWindow().addFlags(drawsSysBackgroundsField.getInt(null));
1729 
1730                 Method setStatusBarColorMethod =
1731                         Window.class.getDeclaredMethod(&quot;setStatusBarColor&quot;, int.class);
1732                 Method setNavigationBarColorMethod =
1733                         Window.class.getDeclaredMethod(&quot;setNavigationBarColor&quot;, int.class);
1734                 setStatusBarColorMethod.invoke(getWindow(), Color.TRANSPARENT);
1735                 setNavigationBarColorMethod.invoke(getWindow(), Color.TRANSPARENT);
1736             } catch (NoSuchFieldException e) {
1737                 Log.w(TAG, &quot;NoSuchFieldException while setting up transparent bars&quot;);
1738             } catch (NoSuchMethodException ex) {
1739                 Log.w(TAG, &quot;NoSuchMethodException while setting up transparent bars&quot;);
1740             } catch (IllegalAccessException e) {
1741                 Log.w(TAG, &quot;IllegalAccessException while setting up transparent bars&quot;);
1742             } catch (IllegalArgumentException e) {
1743                 Log.w(TAG, &quot;IllegalArgumentException while setting up transparent bars&quot;);
1744             } catch (InvocationTargetException e) {
1745                 Log.w(TAG, &quot;InvocationTargetException while setting up transparent bars&quot;);
1746             } finally {}
1747         }
1748     }
1749 
1750     @Override
1751     public void onDetachedFromWindow() {
1752         super.onDetachedFromWindow();
1753         mVisible = false;
1754 
1755         if (mAttached) {
1756             unregisterReceiver(mReceiver);
1757             mAttached = false;
1758         }
1759         updateRunning();
1760     }
1761 
1762     public void onWindowVisibilityChanged(int visibility) {
1763         mVisible = visibility == View.VISIBLE;
1764         updateRunning();
1765         // The following code used to be in onResume, but it turns out onResume is called when
1766         // you&#x27;re in All Apps and click home to go to the workspace. onWindowVisibilityChanged
1767         // is a more appropriate event to handle
1768         if (mVisible) {
1769             mAppsCustomizeTabHost.onWindowVisible();
1770             if (!mWorkspaceLoading) {
1771                 final ViewTreeObserver observer = mWorkspace.getViewTreeObserver();
1772                 // We want to let Launcher draw itself at least once before we force it to build
1773                 // layers on all the workspace pages, so that transitioning to Launcher from other
1774                 // apps is nice and speedy.
1775                 observer.addOnDrawListener(new ViewTreeObserver.OnDrawListener() {
1776                     private boolean mStarted = false;
1777                     public void onDraw() {
1778                         if (mStarted) return;
1779                         mStarted = true;
1780                         // We delay the layer building a bit in order to give
1781                         // other message processing a time to run.  In particular
1782                         // this avoids a delay in hiding the IME if it was
1783                         // currently shown, because doing that may involve
1784                         // some communication back with the app.
1785                         mWorkspace.postDelayed(mBuildLayersRunnable, 500);
1786                         final ViewTreeObserver.OnDrawListener listener = this;
1787                         mWorkspace.post(new Runnable() {
1788                                 public void run() {
1789                                     if (mWorkspace != null &amp;&amp;
1790                                             mWorkspace.getViewTreeObserver() != null) {
1791                                         mWorkspace.getViewTreeObserver().
1792                                                 removeOnDrawListener(listener);
1793                                     }
1794                                 }
1795                             });
1796                         return;
1797                     }
1798                 });
1799             }
1800             clearTypedText();
1801         }
1802     }
1803 
1804     private void sendAdvanceMessage(long delay) {
1805         mHandler.removeMessages(ADVANCE_MSG);
1806         Message msg = mHandler.obtainMessage(ADVANCE_MSG);
1807         mHandler.sendMessageDelayed(msg, delay);
1808         mAutoAdvanceSentTime = System.currentTimeMillis();
1809     }
1810 
1811     private void updateRunning() {
1812         boolean autoAdvanceRunning = mVisible &amp;&amp; mUserPresent &amp;&amp; !mWidgetsToAdvance.isEmpty();
1813         if (autoAdvanceRunning != mAutoAdvanceRunning) {
1814             mAutoAdvanceRunning = autoAdvanceRunning;
1815             if (autoAdvanceRunning) {
1816                 long delay = mAutoAdvanceTimeLeft == -1 ? mAdvanceInterval : mAutoAdvanceTimeLeft;
1817                 sendAdvanceMessage(delay);
1818             } else {
1819                 if (!mWidgetsToAdvance.isEmpty()) {
1820                     mAutoAdvanceTimeLeft = Math.max(0, mAdvanceInterval -
1821                             (System.currentTimeMillis() - mAutoAdvanceSentTime));
1822                 }
1823                 mHandler.removeMessages(ADVANCE_MSG);
1824                 mHandler.removeMessages(0); // Remove messages sent using postDelayed()
1825             }
1826         }
1827     }
1828 
1829     private final Handler mHandler = new Handler() {
1830         @Override
1831         public void handleMessage(Message msg) {
1832             if (msg.what == ADVANCE_MSG) {
1833                 int i = 0;
1834                 for (View key: mWidgetsToAdvance.keySet()) {
1835                     final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);
1836                     final int delay = mAdvanceStagger * i;
1837                     if (v instanceof Advanceable) {
1838                        postDelayed(new Runnable() {
1839                            public void run() {
1840                                ((Advanceable) v).advance();
1841                            }
1842                        }, delay);
1843                     }
1844                     i++;
1845                 }
1846                 sendAdvanceMessage(mAdvanceInterval);
1847             }
1848         }
1849     };
1850 
1851     void addWidgetToAutoAdvanceIfNeeded(View hostView, AppWidgetProviderInfo appWidgetInfo) {
1852         if (appWidgetInfo == null || appWidgetInfo.autoAdvanceViewId == -1) return;
1853         View v = hostView.findViewById(appWidgetInfo.autoAdvanceViewId);
1854         if (v instanceof Advanceable) {
1855             mWidgetsToAdvance.put(hostView, appWidgetInfo);
1856             ((Advanceable) v).fyiWillBeAdvancedByHostKThx();
1857             updateRunning();
1858         }
1859     }
1860 
1861     void removeWidgetToAutoAdvance(View hostView) {
1862         if (mWidgetsToAdvance.containsKey(hostView)) {
1863             mWidgetsToAdvance.remove(hostView);
1864             updateRunning();
1865         }
1866     }
1867 
1868     public void removeAppWidget(LauncherAppWidgetInfo launcherInfo) {
1869         removeWidgetToAutoAdvance(launcherInfo.hostView);
1870         launcherInfo.hostView = null;
1871     }
1872 
1873     void showOutOfSpaceMessage(boolean isHotseatLayout) {
1874         int strId = (isHotseatLayout ? R.string.hotseat_out_of_space : R.string.out_of_space);
1875         Toast.makeText(this, getString(strId), Toast.LENGTH_SHORT).show();
1876     }
1877 
1878     public DragLayer getDragLayer() {
1879         return mDragLayer;
1880     }
1881 
1882     public Workspace getWorkspace() {
1883         return mWorkspace;
1884     }
1885 
1886     public Hotseat getHotseat() {
1887         return mHotseat;
1888     }
1889 
1890     public ViewGroup getOverviewPanel() {
1891         return mOverviewPanel;
1892     }
1893 
1894     public SearchDropTargetBar getSearchBar() {
1895         return mSearchDropTargetBar;
1896     }
1897 
1898     public LauncherAppWidgetHost getAppWidgetHost() {
1899         return mAppWidgetHost;
1900     }
1901 
1902     public LauncherModel getModel() {
1903         return mModel;
1904     }
1905 
1906     protected SharedPreferences getSharedPrefs() {
1907         return mSharedPrefs;
1908     }
1909 
1910     public void closeSystemDialogs() {
1911         getWindow().closeAllPanels();
1912 
1913         // Whatever we were doing is hereby canceled.
1914         setWaitingForResult(false);
1915     }
1916 
1917     @Override
1918     protected void onNewIntent(Intent intent) {
1919         long startTime = 0;
1920         if (DEBUG_RESUME_TIME) {
1921             startTime = System.currentTimeMillis();
1922         }
1923         super.onNewIntent(intent);
1924 
1925         // Close the menu
1926         if (Intent.ACTION_MAIN.equals(intent.getAction())) {
1927             // also will cancel mWaitingForResult.
1928             closeSystemDialogs();
1929 
1930             final boolean alreadyOnHome = mHasFocus &amp;&amp; ((intent.getFlags() &amp;
1931                     Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT)
1932                     != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
1933 
1934             if (mWorkspace == null) {
1935                 // Can be cases where mWorkspace is null, this prevents a NPE
1936                 return;
1937             }
1938             Folder openFolder = mWorkspace.getOpenFolder();
1939             // In all these cases, only animate if we&#x27;re already on home
1940             mWorkspace.exitWidgetResizeMode();
1941             if (alreadyOnHome &amp;&amp; mState == State.WORKSPACE &amp;&amp; !mWorkspace.isTouchActive() &amp;&amp;
1942                     openFolder == null &amp;&amp; shouldMoveToDefaultScreenOnHomeIntent()) {
1943                 mWorkspace.moveToDefaultScreen(true);
1944             }
1945 
1946             closeFolder();
1947             exitSpringLoadedDragMode();
1948 
1949             // If we are already on home, then just animate back to the workspace,
1950             // otherwise, just wait until onResume to set the state back to Workspace
1951             if (alreadyOnHome) {
1952                 showWorkspace(true);
1953             } else {
1954                 mOnResumeState = State.WORKSPACE;
1955             }
1956 
1957             final View v = getWindow().peekDecorView();
1958             if (v != null &amp;&amp; v.getWindowToken() != null) {
1959                 InputMethodManager imm = (InputMethodManager)getSystemService(
1960                         INPUT_METHOD_SERVICE);
1961                 imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
1962             }
1963 
1964             // Reset the apps customize page
1965             if (!alreadyOnHome &amp;&amp; mAppsCustomizeTabHost != null) {
1966                 mAppsCustomizeTabHost.reset();
1967             }
1968 
1969             onHomeIntent();
1970         }
1971 
1972         if (DEBUG_RESUME_TIME) {
1973             Log.d(TAG, &quot;Time spent in onNewIntent: &quot; + (System.currentTimeMillis() - startTime));
1974         }
1975     }
1976 
1977     /**
1978      * Override point for subclasses to prevent movement to the default screen when the home
1979      * button is pressed. Used (for example) in GEL, to prevent movement during a search.
1980      */
1981     protected boolean shouldMoveToDefaultScreenOnHomeIntent() {
1982         return true;
1983     }
1984 
1985     /**
1986      * Override point for subclasses to provide custom behaviour for when a home intent is fired.
1987      */
1988     protected void onHomeIntent() {
1989         // Do nothing
1990     }
1991 
1992     @Override
1993     public void onRestoreInstanceState(Bundle state) {
1994         super.onRestoreInstanceState(state);
1995         for (int page: mSynchronouslyBoundPages) {
1996             mWorkspace.restoreInstanceStateForChild(page);
1997         }
1998     }
1999 
2000     @Override
2001     protected void onSaveInstanceState(Bundle outState) {
2002         if (mWorkspace.getChildCount() &gt; 0) {
2003             outState.putInt(RUNTIME_STATE_CURRENT_SCREEN,
2004                     mWorkspace.getCurrentPageOffsetFromCustomContent());
2005         }
2006         super.onSaveInstanceState(outState);
2007 
2008         outState.putInt(RUNTIME_STATE, mState.ordinal());
2009         // We close any open folder since it will not be re-opened, and we need to make sure
2010         // this state is reflected.
2011         closeFolder();
2012 
2013         if (mPendingAddInfo.container != ItemInfo.NO_ID &amp;&amp; mPendingAddInfo.screenId &gt; -1 &amp;&amp;
2014                 mWaitingForResult) {
2015             outState.putLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, mPendingAddInfo.container);
2016             outState.putLong(RUNTIME_STATE_PENDING_ADD_SCREEN, mPendingAddInfo.screenId);
2017             outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_X, mPendingAddInfo.cellX);
2018             outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_Y, mPendingAddInfo.cellY);
2019             outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_X, mPendingAddInfo.spanX);
2020             outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y, mPendingAddInfo.spanY);
2021             outState.putParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO, mPendingAddWidgetInfo);
2022             outState.putInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID, mPendingAddWidgetId);
2023         }
2024 
2025         if (mFolderInfo != null &amp;&amp; mWaitingForResult) {
2026             outState.putBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, true);
2027             outState.putLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID, mFolderInfo.id);
2028         }
2029 
2030         // Save the current AppsCustomize tab
2031         if (mAppsCustomizeTabHost != null) {
2032             AppsCustomizePagedView.ContentType type = mAppsCustomizeContent.getContentType();
2033             String currentTabTag = mAppsCustomizeTabHost.getTabTagForContentType(type);
2034             if (currentTabTag != null) {
2035                 outState.putString(&quot;apps_customize_currentTab&quot;, currentTabTag);
2036             }
2037             int currentIndex = mAppsCustomizeContent.getSaveInstanceStateIndex();
2038             outState.putInt(&quot;apps_customize_currentIndex&quot;, currentIndex);
2039         }
2040         outState.putSerializable(RUNTIME_STATE_VIEW_IDS, mItemIdToViewId);
2041     }
2042 
2043     @Override
2044     public void onDestroy() {
2045         super.onDestroy();
2046 
2047         // Remove all pending runnables
2048         mHandler.removeMessages(ADVANCE_MSG);
2049         mHandler.removeMessages(0);
2050         mWorkspace.removeCallbacks(mBuildLayersRunnable);
2051 
2052         // Stop callbacks from LauncherModel
2053         LauncherAppState app = (LauncherAppState.getInstance());
2054 
2055         // It&#x27;s possible to receive onDestroy after a new Launcher activity has
2056         // been created. In this case, don&#x27;t interfere with the new Launcher.
2057         if (mModel.isCurrentCallbacks(this)) {
2058             mModel.stopLoader();
2059             app.setLauncher(null);
2060         }
2061 
2062         try {
2063             mAppWidgetHost.stopListening();
2064         } catch (NullPointerException ex) {
2065             Log.w(TAG, &quot;problem while stopping AppWidgetHost during Launcher destruction&quot;, ex);
2066         }
2067         mAppWidgetHost = null;
2068 
2069         mWidgetsToAdvance.clear();
2070 
2071         TextKeyListener.getInstance().release();
2072 
2073         // Disconnect any of the callbacks and drawables associated with ItemInfos on the workspace
2074         // to prevent leaking Launcher activities on orientation change.
2075         if (mModel != null) {
2076             mModel.unbindItemInfosAndClearQueuedBindRunnables();
2077         }
2078 
2079         getContentResolver().unregisterContentObserver(mWidgetObserver);
2080         unregisterReceiver(mCloseSystemDialogsReceiver);
2081 
2082         mDragLayer.clearAllResizeFrames();
2083         ((ViewGroup) mWorkspace.getParent()).removeAllViews();
2084         mWorkspace.removeAllWorkspaceScreens();
2085         mWorkspace = null;
2086         mDragController = null;
2087 
2088         PackageInstallerCompat.getInstance(this).onStop();
2089         LauncherAnimUtils.onDestroyActivity();
2090     }
2091 
2092     public DragController getDragController() {
2093         return mDragController;
2094     }
2095 
2096     @Override
2097     public void startActivityForResult(Intent intent, int requestCode) {
2098         if (requestCode &gt;= 0) {
2099             setWaitingForResult(true);
2100         }
2101         super.startActivityForResult(intent, requestCode);
2102     }
2103 
2104     /**
2105      * Indicates that we want global search for this activity by setting the globalSearch
2106      * argument for {@link #startSearch} to true.
2107      */
2108     @Override
2109     public void startSearch(String initialQuery, boolean selectInitialQuery,
2110             Bundle appSearchData, boolean globalSearch) {
2111 
2112         showWorkspace(true);
2113 
2114         if (initialQuery == null) {
2115             // Use any text typed in the launcher as the initial query
2116             initialQuery = getTypedText();
2117         }
2118         if (appSearchData == null) {
2119             appSearchData = new Bundle();
2120             appSearchData.putString(&quot;source&quot;, &quot;launcher-search&quot;);
2121         }
2122         Rect sourceBounds = new Rect();
2123         if (mSearchDropTargetBar != null) {
2124             sourceBounds = mSearchDropTargetBar.getSearchBarBounds();
2125         }
2126 
2127         boolean clearTextImmediately = startSearch(initialQuery, selectInitialQuery,
2128                 appSearchData, sourceBounds);
2129         if (clearTextImmediately) {
2130             clearTypedText();
2131         }
2132     }
2133 
2134     /**
2135      * Start a text search.
2136      *
2137      * @return {@code true} if the search will start immediately, so any further keypresses
2138      * will be handled directly by the search UI. {@code false} if {@link Launcher} should continue
2139      * to buffer keypresses.
2140      */
2141     public boolean startSearch(String initialQuery,
2142             boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2143         startGlobalSearch(initialQuery, selectInitialQuery,
2144                 appSearchData, sourceBounds);
2145         return false;
2146     }
2147 
2148     /**
2149      * Starts the global search activity. This code is a copied from SearchManager
2150      */
2151     private void startGlobalSearch(String initialQuery,
2152             boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2153         final SearchManager searchManager =
2154             (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2155         ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
2156         if (globalSearchActivity == null) {
2157             Log.w(TAG, &quot;No global search activity found.&quot;);
2158             return;
2159         }
2160         Intent intent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
2161         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2162         intent.setComponent(globalSearchActivity);
2163         // Make sure that we have a Bundle to put source in
2164         if (appSearchData == null) {
2165             appSearchData = new Bundle();
2166         } else {
2167             appSearchData = new Bundle(appSearchData);
2168         }
2169         // Set source to package name of app that starts global search, if not set already.
2170         if (!appSearchData.containsKey(&quot;source&quot;)) {
2171             appSearchData.putString(&quot;source&quot;, getPackageName());
2172         }
2173         intent.putExtra(SearchManager.APP_DATA, appSearchData);
2174         if (!TextUtils.isEmpty(initialQuery)) {
2175             intent.putExtra(SearchManager.QUERY, initialQuery);
2176         }
2177         if (selectInitialQuery) {
2178             intent.putExtra(SearchManager.EXTRA_SELECT_QUERY, selectInitialQuery);
2179         }
2180         intent.setSourceBounds(sourceBounds);
2181         try {
2182             startActivity(intent);
2183         } catch (ActivityNotFoundException ex) {
2184             Log.e(TAG, &quot;Global search activity not found: &quot; + globalSearchActivity);
2185         }
2186     }
2187 
2188     public boolean isOnCustomContent() {
2189         return mWorkspace.isOnOrMovingToCustomContent();
2190     }
2191 
2192     @Override
2193     public boolean onPrepareOptionsMenu(Menu menu) {
2194         super.onPrepareOptionsMenu(menu);
2195         if (!isOnCustomContent()) {
2196             // Close any open folders
2197             closeFolder();
2198             // Stop resizing any widgets
2199             mWorkspace.exitWidgetResizeMode();
2200             if (!mWorkspace.isInOverviewMode()) {
2201                 // Show the overview mode
2202                 showOverviewMode(true);
2203             } else {
2204                 showWorkspace(true);
2205             }
2206         }
2207         return false;
2208     }
2209 
2210     @Override
2211     public boolean onSearchRequested() {
2212         startSearch(null, false, null, true);
2213         // Use a custom animation for launching search
2214         return true;
2215     }
2216 
2217     public boolean isWorkspaceLocked() {
2218         return mWorkspaceLoading || mWaitingForResult;
2219     }
2220 
2221     public boolean isWorkspaceLoading() {
2222         return mWorkspaceLoading;
2223     }
2224 
2225     private void setWorkspaceLoading(boolean value) {
2226         boolean isLocked = isWorkspaceLocked();
2227         mWorkspaceLoading = value;
2228         if (isLocked != isWorkspaceLocked()) {
2229             onWorkspaceLockedChanged();
2230         }
2231     }
2232 
2233     private void setWaitingForResult(boolean value) {
2234         boolean isLocked = isWorkspaceLocked();
2235         mWaitingForResult = value;
2236         if (isLocked != isWorkspaceLocked()) {
2237             onWorkspaceLockedChanged();
2238         }
2239     }
2240 
2241     protected void onWorkspaceLockedChanged() { }
2242 
2243     private void resetAddInfo() {
2244         mPendingAddInfo.container = ItemInfo.NO_ID;
2245         mPendingAddInfo.screenId = -1;
2246         mPendingAddInfo.cellX = mPendingAddInfo.cellY = -1;
2247         mPendingAddInfo.spanX = mPendingAddInfo.spanY = -1;
2248         mPendingAddInfo.minSpanX = mPendingAddInfo.minSpanY = -1;
2249         mPendingAddInfo.dropPos = null;
2250     }
2251 
2252     void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2253             final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo) {
2254         addAppWidgetImpl(appWidgetId, info, boundWidget, appWidgetInfo, 0);
2255     }
2256 
2257     void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2258             final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo, int
2259             delay) {
2260         if (appWidgetInfo.configure != null) {
2261             mPendingAddWidgetInfo = appWidgetInfo;
2262             mPendingAddWidgetId = appWidgetId;
2263 
2264             // Launch over to configure widget, if needed
2265             mAppWidgetManager.startConfigActivity(appWidgetInfo, appWidgetId, this,
2266                     mAppWidgetHost, REQUEST_CREATE_APPWIDGET);
2267 
2268         } else {
2269             // Otherwise just add it
2270             Runnable onComplete = new Runnable() {
2271                 @Override
2272                 public void run() {
2273                     // Exit spring loaded mode if necessary after adding the widget
2274                     exitSpringLoadedDragModeDelayed(true, EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
2275                             null);
2276                 }
2277             };
2278             completeAddAppWidget(appWidgetId, info.container, info.screenId, boundWidget,
2279                     appWidgetInfo);
2280             mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete, delay, false);
2281         }
2282     }
2283 
2284     protected void moveToCustomContentScreen(boolean animate) {
2285         // Close any folders that may be open.
2286         closeFolder();
2287         mWorkspace.moveToCustomContentScreen(animate);
2288     }
2289     /**
2290      * Process a shortcut drop.
2291      *
2292      * @param componentName The name of the component
2293      * @param screenId The ID of the screen where it should be added
2294      * @param cell The cell it should be added to, optional
2295      * @param position The location on the screen where it was dropped, optional
2296      */
2297     void processShortcutFromDrop(ComponentName componentName, long container, long screenId,
2298             int[] cell, int[] loc) {
2299         resetAddInfo();
2300         mPendingAddInfo.container = container;
2301         mPendingAddInfo.screenId = screenId;
2302         mPendingAddInfo.dropPos = loc;
2303 
2304         if (cell != null) {
2305             mPendingAddInfo.cellX = cell[0];
2306             mPendingAddInfo.cellY = cell[1];
2307         }
2308 
2309         Intent createShortcutIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2310         createShortcutIntent.setComponent(componentName);
2311         processShortcut(createShortcutIntent);
2312     }
2313 
2314     /**
2315      * Process a widget drop.
2316      *
2317      * @param info The PendingAppWidgetInfo of the widget being added.
2318      * @param screenId The ID of the screen where it should be added
2319      * @param cell The cell it should be added to, optional
2320      * @param position The location on the screen where it was dropped, optional
2321      */
2322     void addAppWidgetFromDrop(PendingAddWidgetInfo info, long container, long screenId,
2323             int[] cell, int[] span, int[] loc) {
2324         resetAddInfo();
2325         mPendingAddInfo.container = info.container = container;
2326         mPendingAddInfo.screenId = info.screenId = screenId;
2327         mPendingAddInfo.dropPos = loc;
2328         mPendingAddInfo.minSpanX = info.minSpanX;
2329         mPendingAddInfo.minSpanY = info.minSpanY;
2330 
2331         if (cell != null) {
2332             mPendingAddInfo.cellX = cell[0];
2333             mPendingAddInfo.cellY = cell[1];
2334         }
2335         if (span != null) {
2336             mPendingAddInfo.spanX = span[0];
2337             mPendingAddInfo.spanY = span[1];
2338         }
2339 
2340         AppWidgetHostView hostView = info.boundWidget;
2341         int appWidgetId;
2342         if (hostView != null) {
2343             appWidgetId = hostView.getAppWidgetId();
2344             addAppWidgetImpl(appWidgetId, info, hostView, info.info);
2345         } else {
2346             // In this case, we either need to start an activity to get permission to bind
2347             // the widget, or we need to start an activity to configure the widget, or both.
2348             appWidgetId = getAppWidgetHost().allocateAppWidgetId();
2349             Bundle options = info.bindOptions;
2350 
2351             boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
2352                     appWidgetId, info.info, options);
2353             if (success) {
2354                 addAppWidgetImpl(appWidgetId, info, null, info.info);
2355             } else {
2356                 mPendingAddWidgetInfo = info.info;
2357                 Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);
2358                 intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
2359                 intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName);
2360                 mAppWidgetManager.getUser(mPendingAddWidgetInfo)
2361                     .addToIntent(intent, AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE);
2362                 // TODO: we need to make sure that this accounts for the options bundle.
2363                 // intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);
2364                 startActivityForResult(intent, REQUEST_BIND_APPWIDGET);
2365             }
2366         }
2367     }
2368 
2369     void processShortcut(Intent intent) {
2370         Utilities.startActivityForResultSafely(this, intent, REQUEST_CREATE_SHORTCUT);
2371     }
2372 
2373     void processWallpaper(Intent intent) {
2374         startActivityForResult(intent, REQUEST_PICK_WALLPAPER);
2375     }
2376 
2377     FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX,
2378             int cellY) {
2379         final FolderInfo folderInfo = new FolderInfo();
2380         folderInfo.title = getText(R.string.folder_name);
2381 
2382         // Update the model
2383         LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId, cellX, cellY,
2384                 false);
2385         sFolders.put(folderInfo.id, folderInfo);
2386 
2387         // Create the view
2388         FolderIcon newFolder =
2389             FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
2390         mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1,
2391                 isWorkspaceLocked());
2392         // Force measure the new folder icon
2393         CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
2394         parent.getShortcutsAndWidgets().measureChild(newFolder);
2395         return newFolder;
2396     }
2397 
2398     void removeFolder(FolderInfo folder) {
2399         sFolders.remove(folder.id);
2400     }
2401 
2402     protected ComponentName getWallpaperPickerComponent() {
2403         return new ComponentName(getPackageName(), LauncherWallpaperPickerActivity.class.getName());
2404     }
2405 
2406     /**
2407      * Registers various content observers. The current implementation registers
2408      * only a favorites observer to keep track of the favorites applications.
2409      */
2410     private void registerContentObservers() {
2411         ContentResolver resolver = getContentResolver();
2412         resolver.registerContentObserver(LauncherProvider.CONTENT_APPWIDGET_RESET_URI,
2413                 true, mWidgetObserver);
2414     }
2415 
2416     @Override
2417     public boolean dispatchKeyEvent(KeyEvent event) {
2418         if (event.getAction() == KeyEvent.ACTION_DOWN) {
2419             switch (event.getKeyCode()) {
2420                 case KeyEvent.KEYCODE_HOME:
2421                     return true;
2422                 case KeyEvent.KEYCODE_VOLUME_DOWN:
2423                     if (isPropertyEnabled(DUMP_STATE_PROPERTY)) {
2424                         dumpState();
2425                         return true;
2426                     }
2427                     break;
2428             }
2429         } else if (event.getAction() == KeyEvent.ACTION_UP) {
2430             switch (event.getKeyCode()) {
2431                 case KeyEvent.KEYCODE_HOME:
2432                     return true;
2433             }
2434         }
2435 
2436         return super.dispatchKeyEvent(event);
2437     }
2438 
2439     @Override
2440     public void onBackPressed() {
2441         if (isAllAppsVisible()) {
2442             if (mAppsCustomizeContent.getContentType() ==
2443                     AppsCustomizePagedView.ContentType.Applications) {
2444                 showWorkspace(true);
2445             } else {
2446                 showOverviewMode(true);
2447             }
2448         } else if (mWorkspace.isInOverviewMode()) {
2449             mWorkspace.exitOverviewMode(true);
2450         } else if (mWorkspace.getOpenFolder() != null) {
2451             Folder openFolder = mWorkspace.getOpenFolder();
2452             if (openFolder.isEditingName()) {
2453                 openFolder.dismissEditingName();
2454             } else {
2455                 closeFolder();
2456             }
2457         } else {
2458             mWorkspace.exitWidgetResizeMode();
2459 
2460             // Back button is a no-op here, but give at least some feedback for the button press
2461             mWorkspace.showOutlinesTemporarily();
2462         }
2463     }
2464 
2465     /**
2466      * Re-listen when widgets are reset.
2467      */
2468     private void onAppWidgetReset() {
2469         if (mAppWidgetHost != null) {
2470             mAppWidgetHost.startListening();
2471         }
2472     }
2473 
2474     /**
2475      * Launches the intent referred by the clicked shortcut.
2476      *
2477      * @param v The view representing the clicked shortcut.
2478      */
2479     public void onClick(View v) {
2480         // Make sure that rogue clicks don&#x27;t get through while allapps is launching, or after the
2481         // view has detached (it&#x27;s possible for this to happen if the view is removed mid touch).
2482         if (v.getWindowToken() == null) {
2483             return;
2484         }
2485 
2486         if (!mWorkspace.isFinishedSwitchingState()) {
2487             return;
2488         }
2489 
2490         if (v instanceof Workspace) {
2491             if (mWorkspace.isInOverviewMode()) {
2492                 mWorkspace.exitOverviewMode(true);
2493             }
2494             return;
2495         }
2496 
2497         if (v instanceof CellLayout) {
2498             if (mWorkspace.isInOverviewMode()) {
2499                 mWorkspace.exitOverviewMode(mWorkspace.indexOfChild(v), true);
2500             }
2501         }
2502 
2503         Object tag = v.getTag();
2504         if (tag instanceof ShortcutInfo) {
2505             onClickAppShortcut(v);
2506         } else if (tag instanceof FolderInfo) {
2507             if (v instanceof FolderIcon) {
2508                 onClickFolderIcon(v);
2509             }
2510         } else if (v == mAllAppsButton) {
2511             onClickAllAppsButton(v);
2512         } else if (tag instanceof AppInfo) {
2513             startAppShortcutOrInfoActivity(v);
2514         } else if (tag instanceof LauncherAppWidgetInfo) {
2515             if (v instanceof PendingAppWidgetHostView) {
2516                 onClickPendingWidget((PendingAppWidgetHostView) v);
2517             }
2518         }
2519     }
2520 
2521     public void onClickPagedViewIcon(View v) {
2522         startAppShortcutOrInfoActivity(v);
2523     }
2524 
2525     public boolean onTouch(View v, MotionEvent event) {
2526         return false;
2527     }
2528 
2529     /**
2530      * Event handler for the app widget view which has not fully restored.
2531      */
2532     public void onClickPendingWidget(final PendingAppWidgetHostView v) {
2533         final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
2534         if (v.isReadyForClickSetup()) {
2535             int widgetId = info.appWidgetId;
2536             AppWidgetProviderInfo appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(widgetId);
2537             if (appWidgetInfo != null) {
2538                 mPendingAddWidgetInfo = appWidgetInfo;
2539                 mPendingAddInfo.copyFrom(info);
2540                 mPendingAddWidgetId = widgetId;
2541 
2542                 AppWidgetManagerCompat.getInstance(this).startConfigActivity(appWidgetInfo,
2543                         info.appWidgetId, this, mAppWidgetHost, REQUEST_RECONFIGURE_APPWIDGET);
2544             }
2545         } else if (info.installProgress &lt; 0) {
2546             // The install has not been queued
2547             final String packageName = info.providerName.getPackageName();
2548             showBrokenAppInstallDialog(packageName,
2549                 new DialogInterface.OnClickListener() {
2550                     public void onClick(DialogInterface dialog, int id) {
2551                         startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
2552                     }
2553                 });
2554         } else {
2555             // Download has started.
2556             final String packageName = info.providerName.getPackageName();
2557             startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
2558         }
2559     }
2560 
2561     /**
2562      * Event handler for the search button
2563      *
2564      * @param v The view that was clicked.
2565      */
2566     public void onClickSearchButton(View v) {
2567         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2568 
2569         onSearchRequested();
2570     }
2571 
2572     /**
2573      * Event handler for the voice button
2574      *
2575      * @param v The view that was clicked.
2576      */
2577     public void onClickVoiceButton(View v) {
2578         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2579 
2580         startVoice();
2581     }
2582 
2583     public void startVoice() {
2584         try {
2585             final SearchManager searchManager =
2586                     (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2587             ComponentName activityName = searchManager.getGlobalSearchActivity();
2588             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2589             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2590             if (activityName != null) {
2591                 intent.setPackage(activityName.getPackageName());
2592             }
2593             startActivity(null, intent, &quot;onClickVoiceButton&quot;);
2594         } catch (ActivityNotFoundException e) {
2595             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2596             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2597             startActivitySafely(null, intent, &quot;onClickVoiceButton&quot;);
2598         }
2599     }
2600 
2601     /**
2602      * Event handler for the &quot;grid&quot; button that appears on the home screen, which
2603      * enters all apps mode.
2604      *
2605      * @param v The view that was clicked.
2606      */
2607     protected void onClickAllAppsButton(View v) {
2608         if (LOGD) Log.d(TAG, &quot;onClickAllAppsButton&quot;);
2609         if (isAllAppsVisible()) {
2610             showWorkspace(true);
2611         } else {
2612             showAllApps(true, AppsCustomizePagedView.ContentType.Applications, false);
2613         }
2614     }
2615 
2616     private void showBrokenAppInstallDialog(final String packageName,
2617             DialogInterface.OnClickListener onSearchClickListener) {
2618         new AlertDialog.Builder(new ContextThemeWrapper(this, android.R.style.Theme_DeviceDefault))
2619             .setTitle(R.string.abandoned_promises_title)
2620             .setMessage(R.string.abandoned_promise_explanation)
2621             .setPositiveButton(R.string.abandoned_search, onSearchClickListener)
2622             .setNeutralButton(R.string.abandoned_clean_this,
2623                 new DialogInterface.OnClickListener() {
2624                     public void onClick(DialogInterface dialog, int id) {
2625                         final UserHandleCompat user = UserHandleCompat.myUserHandle();
2626                         mWorkspace.removeAbandonedPromise(packageName, user);
2627                     }
2628                 })
2629             .create().show();
2630         return;
2631     }
2632 
2633     /**
2634      * Event handler for an app shortcut click.
2635      *
2636      * @param v The view that was clicked. Must be a tagged with a {@link ShortcutInfo}.
2637      */
2638     protected void onClickAppShortcut(final View v) {
2639         if (LOGD) Log.d(TAG, &quot;onClickAppShortcut&quot;);
2640         Object tag = v.getTag();
2641         if (!(tag instanceof ShortcutInfo)) {
2642             throw new IllegalArgumentException(&quot;Input must be a Shortcut&quot;);
2643         }
2644 
2645         // Open shortcut
2646         final ShortcutInfo shortcut = (ShortcutInfo) tag;
2647         final Intent intent = shortcut.intent;
2648 
2649         // Check for special shortcuts
2650         if (intent.getComponent() != null) {
2651             final String shortcutClass = intent.getComponent().getClassName();
2652 
2653             if (shortcutClass.equals(MemoryDumpActivity.class.getName())) {
2654                 MemoryDumpActivity.startDump(this);
2655                 return;
2656             } else if (shortcutClass.equals(ToggleWeightWatcher.class.getName())) {
2657                 toggleShowWeightWatcher();
2658                 return;
2659             }
2660         }
2661 
2662         // Check for abandoned promise
2663         if ((v instanceof BubbleTextView)
2664                 &amp;&amp; shortcut.isPromise()
2665                 &amp;&amp; !shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE)) {
2666             showBrokenAppInstallDialog(
2667                     shortcut.getTargetComponent().getPackageName(),
2668                     new DialogInterface.OnClickListener() {
2669                         public void onClick(DialogInterface dialog, int id) {
2670                             startAppShortcutOrInfoActivity(v);
2671                         }
2672                     });
2673             return;
2674         }
2675 
2676         // Start activities
2677         startAppShortcutOrInfoActivity(v);
2678     }
2679 
2680     private void startAppShortcutOrInfoActivity(View v) {
2681         Object tag = v.getTag();
2682         final ShortcutInfo shortcut;
2683         final Intent intent;
2684         if (tag instanceof ShortcutInfo) {
2685             shortcut = (ShortcutInfo) tag;
2686             intent = shortcut.intent;
2687             int[] pos = new int[2];
2688             v.getLocationOnScreen(pos);
2689             intent.setSourceBounds(new Rect(pos[0], pos[1],
2690                     pos[0] + v.getWidth(), pos[1] + v.getHeight()));
2691 
2692         } else if (tag instanceof AppInfo) {
2693             shortcut = null;
2694             intent = ((AppInfo) tag).intent;
2695         } else {
2696             throw new IllegalArgumentException(&quot;Input must be a Shortcut or AppInfo&quot;);
2697         }
2698 
2699         boolean success = startActivitySafely(v, intent, tag);
2700         mStats.recordLaunch(intent, shortcut);
2701 
2702         if (success &amp;&amp; v instanceof BubbleTextView) {
2703             mWaitingForResume = (BubbleTextView) v;
2704             mWaitingForResume.setStayPressed(true);
2705         }
2706     }
2707 
2708     /**
2709      * Event handler for a folder icon click.
2710      *
2711      * @param v The view that was clicked. Must be an instance of {@link FolderIcon}.
2712      */
2713     protected void onClickFolderIcon(View v) {
2714         if (LOGD) Log.d(TAG, &quot;onClickFolder&quot;);
2715         if (!(v instanceof FolderIcon)){
2716             throw new IllegalArgumentException(&quot;Input must be a FolderIcon&quot;);
2717         }
2718 
2719         FolderIcon folderIcon = (FolderIcon) v;
2720         final FolderInfo info = folderIcon.getFolderInfo();
2721         Folder openFolder = mWorkspace.getFolderForTag(info);
2722 
2723         // If the folder info reports that the associated folder is open, then verify that
2724         // it is actually opened. There have been a few instances where this gets out of sync.
2725         if (info.opened &amp;&amp; openFolder == null) {
2726             Log.d(TAG, &quot;Folder info marked as open, but associated folder is not open. Screen: &quot;
2727                     + info.screenId + &quot; (&quot; + info.cellX + &quot;, &quot; + info.cellY + &quot;)&quot;);
2728             info.opened = false;
2729         }
2730 
2731         if (!info.opened &amp;&amp; !folderIcon.getFolder().isDestroyed()) {
2732             // Close any open folder
2733             closeFolder();
2734             // Open the requested folder
2735             openFolder(folderIcon);
2736         } else {
2737             // Find the open folder...
2738             int folderScreen;
2739             if (openFolder != null) {
2740                 folderScreen = mWorkspace.getPageForView(openFolder);
2741                 // .. and close it
2742                 closeFolder(openFolder);
2743                 if (folderScreen != mWorkspace.getCurrentPage()) {
2744                     // Close any folder open on the current screen
2745                     closeFolder();
2746                     // Pull the folder onto this screen
2747                     openFolder(folderIcon);
2748                 }
2749             }
2750         }
2751     }
2752 
2753     /**
2754      * Event handler for the (Add) Widgets button that appears after a long press
2755      * on the home screen.
2756      */
2757     protected void onClickAddWidgetButton(View view) {
2758         if (LOGD) Log.d(TAG, &quot;onClickAddWidgetButton&quot;);
2759         showAllApps(true, AppsCustomizePagedView.ContentType.Widgets, true);
2760     }
2761 
2762     /**
2763      * Event handler for the wallpaper picker button that appears after a long press
2764      * on the home screen.
2765      */
2766     protected void onClickWallpaperPicker(View v) {
2767         if (LOGD) Log.d(TAG, &quot;onClickWallpaperPicker&quot;);
2768         final Intent pickWallpaper = new Intent(Intent.ACTION_SET_WALLPAPER);
2769         pickWallpaper.setComponent(getWallpaperPickerComponent());
2770         startActivityForResult(pickWallpaper, REQUEST_PICK_WALLPAPER);
2771     }
2772 
2773     /**
2774      * Event handler for a click on the settings button that appears after a long press
2775      * on the home screen.
2776      */
2777     protected void onClickSettingsButton(View v) {
2778         if (LOGD) Log.d(TAG, &quot;onClickSettingsButton&quot;);
2779     }
2780 
2781     public void onTouchDownAllAppsButton(View v) {
2782         // Provide the same haptic feedback that the system offers for virtual keys.
2783         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2784     }
2785 
2786     public void performHapticFeedbackOnTouchDown(View v) {
2787         // Provide the same haptic feedback that the system offers for virtual keys.
2788         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2789     }
2790 
2791     public View.OnTouchListener getHapticFeedbackTouchListener() {
2792         if (mHapticFeedbackTouchListener == null) {
2793             mHapticFeedbackTouchListener = new View.OnTouchListener() {
2794                 @Override
2795                 public boolean onTouch(View v, MotionEvent event) {
2796                     if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
2797                         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2798                     }
2799                     return false;
2800                 }
2801             };
2802         }
2803         return mHapticFeedbackTouchListener;
2804     }
2805 
2806     public void onDragStarted(View view) {}
2807 
2808     /**
2809      * Called when the user stops interacting with the launcher.
2810      * This implies that the user is now on the homescreen and is not doing housekeeping.
2811      */
2812     protected void onInteractionEnd() {}
2813 
2814     /**
2815      * Called when the user starts interacting with the launcher.
2816      * The possible interactions are:
2817      *  - open all apps
2818      *  - reorder an app shortcut, or a widget
2819      *  - open the overview mode.
2820      * This is a good time to stop doing things that only make sense
2821      * when the user is on the homescreen and not doing housekeeping.
2822      */
2823     protected void onInteractionBegin() {}
2824 
2825     void startApplicationDetailsActivity(ComponentName componentName, UserHandleCompat user) {
2826         String packageName = componentName.getPackageName();
2827         try {
2828             LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
2829             UserManagerCompat userManager = UserManagerCompat.getInstance(this);
2830             launcherApps.showAppDetailsForProfile(componentName, user);
2831         } catch (SecurityException e) {
2832             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2833             Log.e(TAG, &quot;Launcher does not have permission to launch settings&quot;);
2834         } catch (ActivityNotFoundException e) {
2835             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2836             Log.e(TAG, &quot;Unable to launch settings&quot;);
2837         }
2838     }
2839 
2840     // returns true if the activity was started
2841     boolean startApplicationUninstallActivity(ComponentName componentName, int flags,
2842             UserHandleCompat user) {
2843         if ((flags &amp; AppInfo.DOWNLOADED_FLAG) == 0) {
2844             // System applications cannot be installed. For now, show a toast explaining that.
2845             // We may give them the option of disabling apps this way.
2846             int messageId = R.string.uninstall_system_app_text;
2847             Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show();
2848             return false;
2849         } else {
2850             String packageName = componentName.getPackageName();
2851             String className = componentName.getClassName();
2852             Intent intent = new Intent(
2853                     Intent.ACTION_DELETE, Uri.fromParts(&quot;package&quot;, packageName, className));
2854             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
2855                     Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
2856             if (user != null) {
2857                 user.addToIntent(intent, Intent.EXTRA_USER);
2858             }
2859             startActivity(intent);
2860             return true;
2861         }
2862     }
2863 
2864     boolean startActivity(View v, Intent intent, Object tag) {
2865         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2866         try {
2867             // Only launch using the new animation if the shortcut has not opted out (this is a
2868             // private contract between launcher and may be ignored in the future).
2869             boolean useLaunchAnimation = (v != null) &amp;&amp;
2870                     !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);
2871             LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
2872             UserManagerCompat userManager = UserManagerCompat.getInstance(this);
2873 
2874             UserHandleCompat user = null;
2875             if (intent.hasExtra(AppInfo.EXTRA_PROFILE)) {
2876                 long serialNumber = intent.getLongExtra(AppInfo.EXTRA_PROFILE, -1);
2877                 user = userManager.getUserForSerialNumber(serialNumber);
2878             }
2879 
2880             Bundle optsBundle = null;
2881             if (useLaunchAnimation) {
2882                 ActivityOptions opts = Utilities.isLmpOrAbove() ?
<abbr title="2883                         ActivityOptions.makeCustomAnimation(this, R.anim.task_open_enter, R.anim.no_anim) :">2883                         ActivityOptions.makeCustomAnimation(this, R.anim.task_open_enter, R.anim.no_anim)🔵</abbr>
<abbr title="2884                         ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());">2884                         ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasured🔵</abbr>
2885                 optsBundle = opts.toBundle();
2886             }
2887 
2888             if (user == null || user.equals(UserHandleCompat.myUserHandle())) {
2889                 // Could be launching some bookkeeping activity
2890                 startActivity(intent, optsBundle);
2891             } else {
2892                 // TODO Component can be null when shortcuts are supported for secondary user
2893                 launcherApps.startActivityForProfile(intent.getComponent(), user,
2894                         intent.getSourceBounds(), optsBundle);
2895             }
2896             return true;
2897         } catch (SecurityException e) {
2898             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2899             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
2900                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
2901                     &quot;or use the exported attribute for this activity. &quot;
2902                     + &quot;tag=&quot;+ tag + &quot; intent=&quot; + intent, e);
2903         }
2904         return false;
2905     }
2906 
2907     boolean startActivitySafely(View v, Intent intent, Object tag) {
2908         boolean success = false;
2909         if (mIsSafeModeEnabled &amp;&amp; !Utilities.isSystemApp(this, intent)) {
2910             Toast.makeText(this, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show();
2911             return false;
2912         }
2913         try {
2914             success = startActivity(v, intent, tag);
2915         } catch (ActivityNotFoundException e) {
2916             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2917             Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);
2918         }
2919         return success;
2920     }
2921 
2922     /**
2923      * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView
2924      * in the DragLayer in the exact absolute location of the original FolderIcon.
2925      */
2926     private void copyFolderIconToImage(FolderIcon fi) {
2927         final int width = fi.getMeasuredWidth();
2928         final int height = fi.getMeasuredHeight();
2929 
2930         // Lazy load ImageView, Bitmap and Canvas
2931         if (mFolderIconImageView == null) {
2932             mFolderIconImageView = new ImageView(this);
2933         }
2934         if (mFolderIconBitmap == null || mFolderIconBitmap.getWidth() != width ||
2935                 mFolderIconBitmap.getHeight() != height) {
2936             mFolderIconBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
2937             mFolderIconCanvas = new Canvas(mFolderIconBitmap);
2938         }
2939 
2940         DragLayer.LayoutParams lp;
2941         if (mFolderIconImageView.getLayoutParams() instanceof DragLayer.LayoutParams) {
2942             lp = (DragLayer.LayoutParams) mFolderIconImageView.getLayoutParams();
2943         } else {
2944             lp = new DragLayer.LayoutParams(width, height);
2945         }
2946 
2947         // The layout from which the folder is being opened may be scaled, adjust the starting
2948         // view size by this scale factor.
2949         float scale = mDragLayer.getDescendantRectRelativeToSelf(fi, mRectForFolderAnimation);
2950         lp.customPosition = true;
2951         lp.x = mRectForFolderAnimation.left;
2952         lp.y = mRectForFolderAnimation.top;
2953         lp.width = (int) (scale * width);
2954         lp.height = (int) (scale * height);
2955 
2956         mFolderIconCanvas.drawColor(0, PorterDuff.Mode.CLEAR);
2957         fi.draw(mFolderIconCanvas);
2958         mFolderIconImageView.setImageBitmap(mFolderIconBitmap);
2959         if (fi.getFolder() != null) {
2960             mFolderIconImageView.setPivotX(fi.getFolder().getPivotXForIconAnimation());
2961             mFolderIconImageView.setPivotY(fi.getFolder().getPivotYForIconAnimation());
2962         }
2963         // Just in case this image view is still in the drag layer from a previous animation,
2964         // we remove it and re-add it.
2965         if (mDragLayer.indexOfChild(mFolderIconImageView) != -1) {
2966             mDragLayer.removeView(mFolderIconImageView);
2967         }
2968         mDragLayer.addView(mFolderIconImageView, lp);
2969         if (fi.getFolder() != null) {
2970             fi.getFolder().bringToFront();
2971         }
2972     }
2973 
2974     private void growAndFadeOutFolderIcon(FolderIcon fi) {
2975         if (fi == null) return;
2976         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0);
2977         PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.5f);
2978         PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.5f);
2979 
2980         FolderInfo info = (FolderInfo) fi.getTag();
2981         if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2982             CellLayout cl = (CellLayout) fi.getParent().getParent();
2983             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) fi.getLayoutParams();
2984             cl.setFolderLeaveBehindCell(lp.cellX, lp.cellY);
2985         }
2986 
2987         // Push an ImageView copy of the FolderIcon into the DragLayer and hide the original
2988         copyFolderIconToImage(fi);
2989         fi.setVisibility(View.INVISIBLE);
2990 
2991         ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
2992                 scaleX, scaleY);
2993         if (Utilities.isLmpOrAbove()) {
2994             oa.setInterpolator(new LogDecelerateInterpolator(100, 0));
2995         }
2996         oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
2997         oa.start();
2998     }
2999 
3000     private void shrinkAndFadeInFolderIcon(final FolderIcon fi) {
3001         if (fi == null) return;
3002         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f);
3003         PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f);
3004         PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.0f);
3005 
3006         final CellLayout cl = (CellLayout) fi.getParent().getParent();
3007 
3008         // We remove and re-draw the FolderIcon in-case it has changed
3009         mDragLayer.removeView(mFolderIconImageView);
3010         copyFolderIconToImage(fi);
3011         ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
3012                 scaleX, scaleY);
3013         oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
3014         oa.addListener(new AnimatorListenerAdapter() {
3015             @Override
3016             public void onAnimationEnd(Animator animation) {
3017                 if (cl != null) {
3018                     cl.clearFolderLeaveBehind();
3019                     // Remove the ImageView copy of the FolderIcon and make the original visible.
3020                     mDragLayer.removeView(mFolderIconImageView);
3021                     fi.setVisibility(View.VISIBLE);
3022                 }
3023             }
3024         });
3025         oa.start();
3026     }
3027 
3028     /**
3029      * Opens the user folder described by the specified tag. The opening of the folder
3030      * is animated relative to the specified View. If the View is null, no animation
3031      * is played.
3032      *
3033      * @param folderInfo The FolderInfo describing the folder to open.
3034      */
3035     public void openFolder(FolderIcon folderIcon) {
3036         Folder folder = folderIcon.getFolder();
3037         FolderInfo info = folder.mInfo;
3038 
3039         info.opened = true;
3040 
3041         // Just verify that the folder hasn&#x27;t already been added to the DragLayer.
3042         // There was a one-off crash where the folder had a parent already.
3043         if (folder.getParent() == null) {
3044             mDragLayer.addView(folder);
3045             mDragController.addDropTarget((DropTarget) folder);
3046         } else {
3047             Log.w(TAG, &quot;Opening folder (&quot; + folder + &quot;) which already has a parent (&quot; +
3048                     folder.getParent() + &quot;).&quot;);
3049         }
3050         folder.animateOpen();
3051         growAndFadeOutFolderIcon(folderIcon);
3052 
3053         // Notify the accessibility manager that this folder &quot;window&quot; has appeared and occluded
3054         // the workspace items
3055         folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3056         getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
3057     }
3058 
3059     public void closeFolder() {
3060         Folder folder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
3061         if (folder != null) {
3062             if (folder.isEditingName()) {
3063                 folder.dismissEditingName();
3064             }
3065             closeFolder(folder);
3066         }
3067     }
3068 
3069     void closeFolder(Folder folder) {
3070         folder.getInfo().opened = false;
3071 
3072         ViewGroup parent = (ViewGroup) folder.getParent().getParent();
3073         if (parent != null) {
3074             FolderIcon fi = (FolderIcon) mWorkspace.getViewForTag(folder.mInfo);
3075             shrinkAndFadeInFolderIcon(fi);
3076         }
3077         folder.animateClosed();
3078 
3079         // Notify the accessibility manager that this folder &quot;window&quot; has disappeard and no
3080         // longer occludeds the workspace items
3081         getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3082     }
3083 
3084     public boolean onLongClick(View v) {
3085         if (!isDraggingEnabled()) return false;
3086         if (isWorkspaceLocked()) return false;
3087         if (mState != State.WORKSPACE) return false;
3088 
3089         if (v instanceof Workspace) {
3090             if (!mWorkspace.isInOverviewMode()) {
3091                 if (mWorkspace.enterOverviewMode()) {
3092                     mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
3093                             HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
3094                     return true;
3095                 } else {
3096                     return false;
3097                 }
3098             } else {
3099                 return false;
3100             }
3101         }
3102 
3103         CellLayout.CellInfo longClickCellInfo = null;
3104         View itemUnderLongClick = null;
3105         if (v.getTag() instanceof ItemInfo) {
3106             ItemInfo info = (ItemInfo) v.getTag();
3107             longClickCellInfo = new CellLayout.CellInfo(v, info);;
3108             itemUnderLongClick = longClickCellInfo.cell;
3109             resetAddInfo();
3110         }
3111 
3112         // The hotseat touch handling does not go through Workspace, and we always allow long press
3113         // on hotseat items.
3114         final boolean inHotseat = isHotseatLayout(v);
3115         boolean allowLongPress = inHotseat || mWorkspace.allowLongPress();
3116         if (allowLongPress &amp;&amp; !mDragController.isDragging()) {
3117             if (itemUnderLongClick == null) {
3118                 // User long pressed on empty space
3119                 mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
3120                         HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
3121                 if (mWorkspace.isInOverviewMode()) {
3122                     mWorkspace.startReordering(v);
3123                 } else {
3124                     mWorkspace.enterOverviewMode();
3125                 }
3126             } else {
3127                 final boolean isAllAppsButton = inHotseat &amp;&amp; isAllAppsButtonRank(
3128                         mHotseat.getOrderInHotseat(
3129                                 longClickCellInfo.cellX,
3130                                 longClickCellInfo.cellY));
3131                 if (!(itemUnderLongClick instanceof Folder || isAllAppsButton)) {
3132                     // User long pressed on an item
3133                     mWorkspace.startDrag(longClickCellInfo);
3134                 }
3135             }
3136         }
3137         return true;
3138     }
3139 
3140     boolean isHotseatLayout(View layout) {
3141         return mHotseat != null &amp;&amp; layout != null &amp;&amp;
3142                 (layout instanceof CellLayout) &amp;&amp; (layout == mHotseat.getLayout());
3143     }
3144 
3145     /**
3146      * Returns the CellLayout of the specified container at the specified screen.
3147      */
3148     CellLayout getCellLayout(long container, long screenId) {
3149         if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
3150             if (mHotseat != null) {
3151                 return mHotseat.getLayout();
3152             } else {
3153                 return null;
3154             }
3155         } else {
3156             return (CellLayout) mWorkspace.getScreenWithId(screenId);
3157         }
3158     }
3159 
3160     public boolean isAllAppsVisible() {
3161         return (mState == State.APPS_CUSTOMIZE) || (mOnResumeState == State.APPS_CUSTOMIZE);
3162     }
3163 
3164     private void setWorkspaceBackground(boolean workspace) {
3165         mLauncherView.setBackground(workspace ?
3166                 mWorkspaceBackgroundDrawable : null);
3167     }
3168 
3169     protected void changeWallpaperVisiblity(boolean visible) {
3170         int wpflags = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
3171         int curflags = getWindow().getAttributes().flags
3172                 &amp; WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
3173         if (wpflags != curflags) {
3174             getWindow().setFlags(wpflags, WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
3175         }
3176         setWorkspaceBackground(visible);
3177     }
3178 
3179     private void dispatchOnLauncherTransitionPrepare(View v, boolean animated, boolean toWorkspace) {
3180         if (v instanceof LauncherTransitionable) {
3181             ((LauncherTransitionable) v).onLauncherTransitionPrepare(this, animated, toWorkspace);
3182         }
3183     }
3184 
3185     private void dispatchOnLauncherTransitionStart(View v, boolean animated, boolean toWorkspace) {
3186         if (v instanceof LauncherTransitionable) {
3187             ((LauncherTransitionable) v).onLauncherTransitionStart(this, animated, toWorkspace);
3188         }
3189 
3190         // Update the workspace transition step as well
3191         dispatchOnLauncherTransitionStep(v, 0f);
3192     }
3193 
3194     private void dispatchOnLauncherTransitionStep(View v, float t) {
3195         if (v instanceof LauncherTransitionable) {
3196             ((LauncherTransitionable) v).onLauncherTransitionStep(this, t);
3197         }
3198     }
3199 
3200     private void dispatchOnLauncherTransitionEnd(View v, boolean animated, boolean toWorkspace) {
3201         if (v instanceof LauncherTransitionable) {
3202             ((LauncherTransitionable) v).onLauncherTransitionEnd(this, animated, toWorkspace);
3203         }
3204 
3205         // Update the workspace transition step as well
3206         dispatchOnLauncherTransitionStep(v, 1f);
3207     }
3208 
3209     /**
3210      * Things to test when changing the following seven functions.
3211      *   - Home from workspace
3212      *          - from center screen
3213      *          - from other screens
3214      *   - Home from all apps
3215      *          - from center screen
3216      *          - from other screens
3217      *   - Back from all apps
3218      *          - from center screen
3219      *          - from other screens
3220      *   - Launch app from workspace and quit
3221      *          - with back
3222      *          - with home
3223      *   - Launch app from all apps and quit
3224      *          - with back
3225      *          - with home
3226      *   - Go to a screen that&#x27;s not the default, then all
3227      *     apps, and launch and app, and go back
3228      *          - with back
3229      *          -with home
3230      *   - On workspace, long press power and go back
3231      *          - with back
3232      *          - with home
3233      *   - On all apps, long press power and go back
3234      *          - with back
3235      *          - with home
3236      *   - On workspace, power off
3237      *   - On all apps, power off
3238      *   - Launch an app and turn off the screen while in that app
3239      *          - Go back with home key
3240      *          - Go back with back key  TODO: make this not go to workspace
3241      *          - From all apps
3242      *          - From workspace
3243      *   - Enter and exit car mode (becuase it causes an extra configuration changed)
3244      *          - From all apps
3245      *          - From the center workspace
3246      *          - From another workspace
3247      */
3248 
3249     /**
3250      * Zoom the camera out from the workspace to reveal &#x27;toView&#x27;.
3251      * Assumes that the view to show is anchored at either the very top or very bottom
3252      * of the screen.
3253      */
3254     private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded) {
3255         AppsCustomizePagedView.ContentType contentType = mAppsCustomizeContent.getContentType();
3256         showAppsCustomizeHelper(animated, springLoaded, contentType);
3257     }
3258 
3259     private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded,
3260                                          final AppsCustomizePagedView.ContentType contentType) {
3261         if (mStateAnimation != null) {
3262             mStateAnimation.setDuration(0);
3263             mStateAnimation.cancel();
3264             mStateAnimation = null;
3265         }
3266 
3267         boolean material = Utilities.isLmpOrAbove();
3268 
3269         final Resources res = getResources();
3270 
3271         final int duration = res.getInteger(R.integer.config_appsCustomizeZoomInTime);
3272         final int fadeDuration = res.getInteger(R.integer.config_appsCustomizeFadeInTime);
3273         final int revealDuration = res.getInteger(R.integer.config_appsCustomizeRevealTime);
3274         final int itemsAlphaStagger =
3275                 res.getInteger(R.integer.config_appsCustomizeItemsAlphaStagger);
3276 
3277         final float scale = (float) res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3278         final View fromView = mWorkspace;
3279         final AppsCustomizeTabHost toView = mAppsCustomizeTabHost;
3280 
3281         final ArrayList&lt;View&gt; layerViews = new ArrayList&lt;View&gt;();
3282 
3283         Workspace.State workspaceState = contentType == AppsCustomizePagedView.ContentType.Widgets ?
3284                 Workspace.State.OVERVIEW_HIDDEN : Workspace.State.NORMAL_HIDDEN;
3285         Animator workspaceAnim =
3286                 mWorkspace.getChangeStateAnimation(workspaceState, animated, layerViews);
3287         if (!LauncherAppState.isDisableAllApps()
3288                 || contentType == AppsCustomizePagedView.ContentType.Widgets) {
3289             // Set the content type for the all apps/widgets space
3290             mAppsCustomizeTabHost.setContentTypeImmediate(contentType);
3291         }
3292 
3293         // If for some reason our views aren&#x27;t initialized, don&#x27;t animate
3294         boolean initialized = getAllAppsButton() != null;
3295 
3296         if (animated &amp;&amp; initialized) {
3297             mStateAnimation = LauncherAnimUtils.createAnimatorSet();
3298             final AppsCustomizePagedView content = (AppsCustomizePagedView)
3299                     toView.findViewById(R.id.apps_customize_pane_content);
3300 
3301             final View page = content.getPageAt(content.getCurrentPage());
3302             final View revealView = toView.findViewById(R.id.fake_page);
3303 
3304             final float initialPanelAlpha = 1f;
3305 
3306             final boolean isWidgetTray = contentType == AppsCustomizePagedView.ContentType.Widgets;
3307             if (isWidgetTray) {
3308                 revealView.setBackground(res.getDrawable(R.drawable.quantum_panel_dark));
3309             } else {
3310                 revealView.setBackground(res.getDrawable(R.drawable.quantum_panel));
3311             }
3312 
3313             // Hide the real page background, and swap in the fake one
3314             content.setPageBackgroundsVisible(false);
3315             revealView.setVisibility(View.VISIBLE);
3316             // We need to hide this view as the animation start will be posted.
3317             revealView.setAlpha(0);
3318 
3319             int width = revealView.getMeasuredWidth();
3320             int height = revealView.getMeasuredHeight();
3321             float revealRadius = (float) Math.sqrt((width * width) / 4 + (height * height) / 4);
3322 
3323             revealView.setTranslationY(0);
3324             revealView.setTranslationX(0);
3325 
3326             // Get the y delta between the center of the page and the center of the all apps button
3327             int[] allAppsToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView,
3328                     getAllAppsButton(), null);
3329 
3330             float alpha = 0;
3331             float xDrift = 0;
3332             float yDrift = 0;
3333             if (material) {
3334                 alpha = isWidgetTray ? 0.3f : 1f;
3335                 yDrift = isWidgetTray ? height / 2 : allAppsToPanelDelta[1];
3336                 xDrift = isWidgetTray ? 0 : allAppsToPanelDelta[0];
3337             } else {
3338                 yDrift = 2 * height / 3;
3339                 xDrift = 0;
3340             }
3341             final float initAlpha = alpha;
3342 
3343             revealView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3344             layerViews.add(revealView);
3345             PropertyValuesHolder panelAlpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, initAlpha, 1f);
3346             PropertyValuesHolder panelDriftY =
3347                     PropertyValuesHolder.ofFloat(&quot;translationY&quot;, yDrift, 0);
3348             PropertyValuesHolder panelDriftX =
3349                     PropertyValuesHolder.ofFloat(&quot;translationX&quot;, xDrift, 0);
3350 
3351             ObjectAnimator panelAlphaAndDrift = ObjectAnimator.ofPropertyValuesHolder(revealView,
3352                     panelAlpha, panelDriftY, panelDriftX);
3353 
3354             panelAlphaAndDrift.setDuration(revealDuration);
3355             panelAlphaAndDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));
3356 
3357             mStateAnimation.play(panelAlphaAndDrift);
3358 
3359             if (page != null) {
3360                 page.setVisibility(View.VISIBLE);
3361                 page.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3362                 layerViews.add(page);
3363 
3364                 ObjectAnimator pageDrift = ObjectAnimator.ofFloat(page, &quot;translationY&quot;, yDrift, 0);
3365                 page.setTranslationY(yDrift);
3366                 pageDrift.setDuration(revealDuration);
3367                 pageDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));
3368                 pageDrift.setStartDelay(itemsAlphaStagger);
3369                 mStateAnimation.play(pageDrift);
3370 
3371                 page.setAlpha(0f);
3372                 ObjectAnimator itemsAlpha = ObjectAnimator.ofFloat(page, &quot;alpha&quot;, 0f, 1f);
3373                 itemsAlpha.setDuration(revealDuration);
3374                 itemsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));
3375                 itemsAlpha.setStartDelay(itemsAlphaStagger);
3376                 mStateAnimation.play(itemsAlpha);
3377             }
3378 
3379             View pageIndicators = toView.findViewById(R.id.apps_customize_page_indicator);
3380             pageIndicators.setAlpha(0.01f);
3381             ObjectAnimator indicatorsAlpha =
3382                     ObjectAnimator.ofFloat(pageIndicators, &quot;alpha&quot;, 1f);
3383             indicatorsAlpha.setDuration(revealDuration);
3384             mStateAnimation.play(indicatorsAlpha);
3385 
3386             if (material) {
3387                 final View allApps = getAllAppsButton();
3388                 int allAppsButtonSize = LauncherAppState.getInstance().
3389                         getDynamicGrid().getDeviceProfile().allAppsButtonVisualSize;
3390                 float startRadius = isWidgetTray ? 0 : allAppsButtonSize / 2;
3391                 Animator reveal = ViewAnimationUtils.createCircularReveal(revealView, width / 2,
3392                                 height / 2, startRadius, revealRadius);
3393                 reveal.setDuration(revealDuration);
3394                 reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
3395 
3396                 reveal.addListener(new AnimatorListenerAdapter() {
3397                     public void onAnimationStart(Animator animation) {
3398                         if (!isWidgetTray) {
3399                             allApps.setVisibility(View.INVISIBLE);
3400                         }
3401                     }
3402                     public void onAnimationEnd(Animator animation) {
3403                         if (!isWidgetTray) {
3404                             allApps.setVisibility(View.VISIBLE);
3405                         }
3406                     }
3407                 });
3408                 mStateAnimation.play(reveal);
3409             }
3410 
3411             mStateAnimation.addListener(new AnimatorListenerAdapter() {
3412                 @Override
3413                 public void onAnimationEnd(Animator animation) {
3414                     dispatchOnLauncherTransitionEnd(fromView, animated, false);
3415                     dispatchOnLauncherTransitionEnd(toView, animated, false);
3416 
3417                     revealView.setVisibility(View.INVISIBLE);
3418                     revealView.setLayerType(View.LAYER_TYPE_NONE, null);
3419                     if (page != null) {
3420                         page.setLayerType(View.LAYER_TYPE_NONE, null);
3421                     }
3422                     content.setPageBackgroundsVisible(true);
3423 
3424                     // Hide the search bar
3425                     if (mSearchDropTargetBar != null) {
3426                         mSearchDropTargetBar.hideSearchBar(false);
3427                     }
3428                 }
3429 
3430             });
3431 
3432             if (workspaceAnim != null) {
3433                 mStateAnimation.play(workspaceAnim);
3434             }
3435 
3436             dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3437             dispatchOnLauncherTransitionPrepare(toView, animated, false);
3438             final AnimatorSet stateAnimation = mStateAnimation;
3439             final Runnable startAnimRunnable = new Runnable() {
3440                 public void run() {
3441                     // Check that mStateAnimation hasn&#x27;t changed while
3442                     // we waited for a layout/draw pass
3443                     if (mStateAnimation != stateAnimation)
3444                         return;
3445                     dispatchOnLauncherTransitionStart(fromView, animated, false);
3446                     dispatchOnLauncherTransitionStart(toView, animated, false);
3447 
3448                     revealView.setAlpha(initAlpha);
3449                     if (Utilities.isLmpOrAbove()) {
3450                         for (int i = 0; i &lt; layerViews.size(); i++) {
3451                             View v = layerViews.get(i);
3452                             if (v != null) {
3453                                 boolean attached = true;
3454                                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
3455                                     attached = v.isAttachedToWindow();
3456                                 }
3457                                 if (attached) v.buildLayer();
3458                             }
3459                         }
3460                     }
3461                     mStateAnimation.start();
3462                 }
3463             };
3464             toView.bringToFront();
3465             toView.setVisibility(View.VISIBLE);
3466             toView.post(startAnimRunnable);
3467         } else {
3468             toView.setTranslationX(0.0f);
3469             toView.setTranslationY(0.0f);
3470             toView.setScaleX(1.0f);
3471             toView.setScaleY(1.0f);
3472             toView.setVisibility(View.VISIBLE);
3473             toView.bringToFront();
3474 
3475             if (!springLoaded &amp;&amp; !LauncherAppState.getInstance().isScreenLarge()) {
3476                 // Hide the search bar
3477                 if (mSearchDropTargetBar != null) {
3478                     mSearchDropTargetBar.hideSearchBar(false);
3479                 }
3480             }
3481             dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3482             dispatchOnLauncherTransitionStart(fromView, animated, false);
3483             dispatchOnLauncherTransitionEnd(fromView, animated, false);
3484             dispatchOnLauncherTransitionPrepare(toView, animated, false);
3485             dispatchOnLauncherTransitionStart(toView, animated, false);
3486             dispatchOnLauncherTransitionEnd(toView, animated, false);
3487         }
3488     }
3489 
3490     /**
3491      * Zoom the camera back into the workspace, hiding &#x27;fromView&#x27;.
3492      * This is the opposite of showAppsCustomizeHelper.
3493      * @param animated If true, the transition will be animated.
3494      */
3495     private void hideAppsCustomizeHelper(Workspace.State toState, final boolean animated,
3496             final boolean springLoaded, final Runnable onCompleteRunnable) {
3497 
3498         if (mStateAnimation != null) {
3499             mStateAnimation.setDuration(0);
3500             mStateAnimation.cancel();
3501             mStateAnimation = null;
3502         }
3503 
3504         boolean material = Utilities.isLmpOrAbove();
3505         Resources res = getResources();
3506 
3507         final int duration = res.getInteger(R.integer.config_appsCustomizeZoomOutTime);
3508         final int fadeOutDuration = res.getInteger(R.integer.config_appsCustomizeFadeOutTime);
3509         final int revealDuration = res.getInteger(R.integer.config_appsCustomizeConcealTime);
3510         final int itemsAlphaStagger =
3511                 res.getInteger(R.integer.config_appsCustomizeItemsAlphaStagger);
3512 
3513         final float scaleFactor = (float)
3514                 res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3515         final View fromView = mAppsCustomizeTabHost;
3516         final View toView = mWorkspace;
3517         Animator workspaceAnim = null;
3518         final ArrayList&lt;View&gt; layerViews = new ArrayList&lt;View&gt;();
3519 
3520         if (toState == Workspace.State.NORMAL) {
3521             workspaceAnim = mWorkspace.getChangeStateAnimation(
3522                     toState, animated, layerViews);
3523         } else if (toState == Workspace.State.SPRING_LOADED ||
3524                 toState == Workspace.State.OVERVIEW) {
3525             workspaceAnim = mWorkspace.getChangeStateAnimation(
3526                     toState, animated, layerViews);
3527         }
3528 
3529         // If for some reason our views aren&#x27;t initialized, don&#x27;t animate
3530         boolean initialized = getAllAppsButton() != null;
3531 
3532         if (animated &amp;&amp; initialized) {
3533             mStateAnimation = LauncherAnimUtils.createAnimatorSet();
3534             if (workspaceAnim != null) {
3535                 mStateAnimation.play(workspaceAnim);
3536             }
3537 
3538             final AppsCustomizePagedView content = (AppsCustomizePagedView)
3539                     fromView.findViewById(R.id.apps_customize_pane_content);
3540 
3541             final View page = content.getPageAt(content.getNextPage());
3542 
3543             // We need to hide side pages of the Apps / Widget tray to avoid some ugly edge cases
3544             int count = content.getChildCount();
3545             for (int i = 0; i &lt; count; i++) {
3546                 View child = content.getChildAt(i);
3547                 if (child != page) {
3548                     child.setVisibility(View.INVISIBLE);
3549                 }
3550             }
3551             final View revealView = fromView.findViewById(R.id.fake_page);
3552 
3553             // hideAppsCustomizeHelper is called in some cases when it is already hidden
3554             // don&#x27;t perform all these no-op animations. In particularly, this was causing
3555             // the all-apps button to pop in and out.
3556             if (fromView.getVisibility() == View.VISIBLE) {
3557                 AppsCustomizePagedView.ContentType contentType = content.getContentType();
3558                 final boolean isWidgetTray =
3559                         contentType == AppsCustomizePagedView.ContentType.Widgets;
3560 
3561                 if (isWidgetTray) {
3562                     revealView.setBackground(res.getDrawable(R.drawable.quantum_panel_dark));
3563                 } else {
3564                     revealView.setBackground(res.getDrawable(R.drawable.quantum_panel));
3565                 }
3566 
3567                 int width = revealView.getMeasuredWidth();
3568                 int height = revealView.getMeasuredHeight();
3569                 float revealRadius = (float) Math.sqrt((width * width) / 4 + (height * height) / 4);
3570 
3571                 // Hide the real page background, and swap in the fake one
3572                 revealView.setVisibility(View.VISIBLE);
3573                 content.setPageBackgroundsVisible(false);
3574 
3575                 final View allAppsButton = getAllAppsButton();
3576                 revealView.setTranslationY(0);
3577                 int[] allAppsToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView,
3578                         allAppsButton, null);
3579 
3580                 float xDrift = 0;
3581                 float yDrift = 0;
3582                 if (material) {
3583                     yDrift = isWidgetTray ? height / 2 : allAppsToPanelDelta[1];
3584                     xDrift = isWidgetTray ? 0 : allAppsToPanelDelta[0];
3585                 } else {
3586                     yDrift = 5 * height / 4;
3587                     xDrift = 0;
3588                 }
3589 
3590                 revealView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3591                 TimeInterpolator decelerateInterpolator = material ?
3592                         new LogDecelerateInterpolator(100, 0) :
3593                         new LogDecelerateInterpolator(30, 0);
3594 
3595                 // The vertical motion of the apps panel should be delayed by one frame
3596                 // from the conceal animation in order to give the right feel. We correpsondingly
3597                 // shorten the duration so that the slide and conceal end at the same time.
3598                 ObjectAnimator panelDriftY = LauncherAnimUtils.ofFloat(revealView, &quot;translationY&quot;,
3599                         0, yDrift);
3600                 panelDriftY.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3601                 panelDriftY.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3602                 panelDriftY.setInterpolator(decelerateInterpolator);
3603                 mStateAnimation.play(panelDriftY);
3604 
3605                 ObjectAnimator panelDriftX = LauncherAnimUtils.ofFloat(revealView, &quot;translationX&quot;,
3606                         0, xDrift);
3607                 panelDriftX.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3608                 panelDriftX.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3609                 panelDriftX.setInterpolator(decelerateInterpolator);
3610                 mStateAnimation.play(panelDriftX);
3611 
3612                 if (isWidgetTray || !material) {
3613                     float finalAlpha = material ? 0.4f : 0f;
3614                     revealView.setAlpha(1f);
3615                     ObjectAnimator panelAlpha = LauncherAnimUtils.ofFloat(revealView, &quot;alpha&quot;,
3616                             1f, finalAlpha);
3617                     panelAlpha.setDuration(revealDuration);
3618                     panelAlpha.setInterpolator(material ? decelerateInterpolator :
3619                         new AccelerateInterpolator(1.5f));
3620                     mStateAnimation.play(panelAlpha);
3621                 }
3622 
3623                 if (page != null) {
3624                     page.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3625 
3626                     ObjectAnimator pageDrift = LauncherAnimUtils.ofFloat(page, &quot;translationY&quot;,
3627                             0, yDrift);
3628                     page.setTranslationY(0);
3629                     pageDrift.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3630                     pageDrift.setInterpolator(decelerateInterpolator);
3631                     pageDrift.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3632                     mStateAnimation.play(pageDrift);
3633 
3634                     page.setAlpha(1f);
3635                     ObjectAnimator itemsAlpha = LauncherAnimUtils.ofFloat(page, &quot;alpha&quot;, 1f, 0f);
3636                     itemsAlpha.setDuration(100);
3637                     itemsAlpha.setInterpolator(decelerateInterpolator);
3638                     mStateAnimation.play(itemsAlpha);
3639                 }
3640 
3641                 View pageIndicators = fromView.findViewById(R.id.apps_customize_page_indicator);
3642                 pageIndicators.setAlpha(1f);
3643                 ObjectAnimator indicatorsAlpha =
3644                         LauncherAnimUtils.ofFloat(pageIndicators, &quot;alpha&quot;, 0f);
3645                 indicatorsAlpha.setDuration(revealDuration);
3646                 indicatorsAlpha.setInterpolator(new DecelerateInterpolator(1.5f));
3647                 mStateAnimation.play(indicatorsAlpha);
3648 
3649                 width = revealView.getMeasuredWidth();
3650 
3651                 if (material) {
3652                     if (!isWidgetTray) {
3653                         allAppsButton.setVisibility(View.INVISIBLE);
3654                     }
3655                     int allAppsButtonSize = LauncherAppState.getInstance().
3656                             getDynamicGrid().getDeviceProfile().allAppsButtonVisualSize;
3657                     float finalRadius = isWidgetTray ? 0 : allAppsButtonSize / 2;
3658                     Animator reveal =
3659                             LauncherAnimUtils.createCircularReveal(revealView, width / 2,
3660                                     height / 2, revealRadius, finalRadius);
3661                     reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
3662                     reveal.setDuration(revealDuration);
3663                     reveal.setStartDelay(itemsAlphaStagger);
3664 
3665                     reveal.addListener(new AnimatorListenerAdapter() {
3666                         public void onAnimationEnd(Animator animation) {
3667                             revealView.setVisibility(View.INVISIBLE);
3668                             if (!isWidgetTray) {
3669                                 allAppsButton.setVisibility(View.VISIBLE);
3670                             }
3671                         }
3672                     });
3673 
3674                     mStateAnimation.play(reveal);
3675                 }
3676 
3677                 dispatchOnLauncherTransitionPrepare(fromView, animated, true);
3678                 dispatchOnLauncherTransitionPrepare(toView, animated, true);
3679                 mAppsCustomizeContent.stopScrolling();
3680             }
3681 
3682             mStateAnimation.addListener(new AnimatorListenerAdapter() {
3683                 @Override
3684                 public void onAnimationEnd(Animator animation) {
3685                     fromView.setVisibility(View.GONE);
3686                     dispatchOnLauncherTransitionEnd(fromView, animated, true);
3687                     dispatchOnLauncherTransitionEnd(toView, animated, true);
3688                     if (onCompleteRunnable != null) {
3689                         onCompleteRunnable.run();
3690                     }
3691 
3692                     revealView.setLayerType(View.LAYER_TYPE_NONE, null);
3693                     if (page != null) {
3694                         page.setLayerType(View.LAYER_TYPE_NONE, null);
3695                     }
3696                     content.setPageBackgroundsVisible(true);
3697                     // Unhide side pages
3698                     int count = content.getChildCount();
3699                     for (int i = 0; i &lt; count; i++) {
3700                         View child = content.getChildAt(i);
3701                         child.setVisibility(View.VISIBLE);
3702                     }
3703 
3704                     // Reset page transforms
3705                     if (page != null) {
3706                         page.setTranslationX(0);
3707                         page.setTranslationY(0);
3708                         page.setAlpha(1);
3709                     }
3710                     content.setCurrentPage(content.getNextPage());
3711 
3712                     mAppsCustomizeContent.updateCurrentPageScroll();
3713                 }
3714             });
3715 
3716             final AnimatorSet stateAnimation = mStateAnimation;
3717             final Runnable startAnimRunnable = new Runnable() {
3718                 public void run() {
3719                     // Check that mStateAnimation hasn&#x27;t changed while
3720                     // we waited for a layout/draw pass
3721                     if (mStateAnimation != stateAnimation)
3722                         return;
3723                     dispatchOnLauncherTransitionStart(fromView, animated, false);
3724                     dispatchOnLauncherTransitionStart(toView, animated, false);
3725 
3726                     if (Utilities.isLmpOrAbove()) {
3727                         for (int i = 0; i &lt; layerViews.size(); i++) {
3728                             View v = layerViews.get(i);
3729                             if (v != null) {
3730                                 boolean attached = true;
3731                                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
3732                                     attached = v.isAttachedToWindow();
3733                                 }
3734                                 if (attached) v.buildLayer();
3735                             }
3736                         }
3737                     }
3738                     mStateAnimation.start();
3739                 }
3740             };
3741             fromView.post(startAnimRunnable);
3742         } else {
3743             fromView.setVisibility(View.GONE);
3744             dispatchOnLauncherTransitionPrepare(fromView, animated, true);
3745             dispatchOnLauncherTransitionStart(fromView, animated, true);
3746             dispatchOnLauncherTransitionEnd(fromView, animated, true);
3747             dispatchOnLauncherTransitionPrepare(toView, animated, true);
3748             dispatchOnLauncherTransitionStart(toView, animated, true);
3749             dispatchOnLauncherTransitionEnd(toView, animated, true);
3750         }
3751     }
3752 
3753     @Override
3754     public void onTrimMemory(int level) {
3755         super.onTrimMemory(level);
3756         if (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
3757             mAppsCustomizeTabHost.onTrimMemory();
3758         }
3759     }
3760 
3761     protected void showWorkspace(boolean animated) {
3762         showWorkspace(animated, null);
3763     }
3764 
3765     protected void showWorkspace() {
3766         showWorkspace(true);
3767     }
3768 
3769     void showWorkspace(boolean animated, Runnable onCompleteRunnable) {
3770         if (mState != State.WORKSPACE || mWorkspace.getState() != Workspace.State.NORMAL) {
3771             boolean wasInSpringLoadedMode = (mState != State.WORKSPACE);
3772             mWorkspace.setVisibility(View.VISIBLE);
3773             hideAppsCustomizeHelper(Workspace.State.NORMAL, animated, false, onCompleteRunnable);
3774 
3775             // Show the search bar (only animate if we were showing the drop target bar in spring
3776             // loaded mode)
3777             if (mSearchDropTargetBar != null) {
3778                 mSearchDropTargetBar.showSearchBar(animated &amp;&amp; wasInSpringLoadedMode);
3779             }
3780 
3781             // Set focus to the AppsCustomize button
3782             if (mAllAppsButton != null) {
3783                 mAllAppsButton.requestFocus();
3784             }
3785         }
3786 
3787         // Change the state *after* we&#x27;ve called all the transition code
3788         mState = State.WORKSPACE;
3789 
3790         // Resume the auto-advance of widgets
3791         mUserPresent = true;
3792         updateRunning();
3793 
3794         // Send an accessibility event to announce the context change
3795         getWindow().getDecorView()
3796                 .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3797 
3798         onWorkspaceShown(animated);
3799     }
3800 
3801     void showOverviewMode(boolean animated) {
3802         mWorkspace.setVisibility(View.VISIBLE);
3803         hideAppsCustomizeHelper(Workspace.State.OVERVIEW, animated, false, null);
3804         mState = State.WORKSPACE;
3805         onWorkspaceShown(animated);
3806     }
3807 
3808     public void onWorkspaceShown(boolean animated) {
3809     }
3810 
3811     void showAllApps(boolean animated, AppsCustomizePagedView.ContentType contentType,
3812                      boolean resetPageToZero) {
3813         if (mState != State.WORKSPACE) return;
3814 
3815         if (resetPageToZero) {
3816             mAppsCustomizeTabHost.reset();
3817         }
3818         showAppsCustomizeHelper(animated, false, contentType);
3819         mAppsCustomizeTabHost.post(new Runnable() {
3820             @Override
3821             public void run() {
3822                 // We post this in-case the all apps view isn&#x27;t yet constructed.
3823                 mAppsCustomizeTabHost.requestFocus();
3824             }
3825         });
3826 
3827         // Change the state *after* we&#x27;ve called all the transition code
3828         mState = State.APPS_CUSTOMIZE;
3829 
3830         // Pause the auto-advance of widgets until we are out of AllApps
3831         mUserPresent = false;
3832         updateRunning();
3833         closeFolder();
3834 
3835         // Send an accessibility event to announce the context change
3836         getWindow().getDecorView()
3837                 .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3838     }
3839 
3840     void enterSpringLoadedDragMode() {
3841         if (isAllAppsVisible()) {
3842             hideAppsCustomizeHelper(Workspace.State.SPRING_LOADED, true, true, null);
3843             mState = State.APPS_CUSTOMIZE_SPRING_LOADED;
3844         }
3845     }
3846 
3847     void exitSpringLoadedDragModeDelayed(final boolean successfulDrop, int delay,
3848             final Runnable onCompleteRunnable) {
3849         if (mState != State.APPS_CUSTOMIZE_SPRING_LOADED) return;
3850 
3851         mHandler.postDelayed(new Runnable() {
3852             @Override
3853             public void run() {
3854                 if (successfulDrop) {
3855                     // Before we show workspace, hide all apps again because
3856                     // exitSpringLoadedDragMode made it visible. This is a bit hacky; we should
3857                     // clean up our state transition functions
3858                     mAppsCustomizeTabHost.setVisibility(View.GONE);
3859                     showWorkspace(true, onCompleteRunnable);
3860                 } else {
3861                     exitSpringLoadedDragMode();
3862                 }
3863             }
3864         }, delay);
3865     }
3866 
3867     void exitSpringLoadedDragMode() {
3868         if (mState == State.APPS_CUSTOMIZE_SPRING_LOADED) {
3869             final boolean animated = true;
3870             final boolean springLoaded = true;
3871             showAppsCustomizeHelper(animated, springLoaded);
3872             mState = State.APPS_CUSTOMIZE;
3873         }
3874         // Otherwise, we are not in spring loaded mode, so don&#x27;t do anything.
3875     }
3876 
3877     void lockAllApps() {
3878         // TODO
3879     }
3880 
3881     void unlockAllApps() {
3882         // TODO
3883     }
3884 
3885     /**
3886      * Hides the hotseat area.
3887      */
3888     void hideHotseat(boolean animated) {
3889         if (!LauncherAppState.getInstance().isScreenLarge()) {
3890             if (animated) {
3891                 if (mHotseat.getAlpha() != 0f) {
3892                     int duration = 0;
3893                     if (mSearchDropTargetBar != null) {
3894                         duration = mSearchDropTargetBar.getTransitionOutDuration();
3895                     }
3896                     mHotseat.animate().alpha(0f).setDuration(duration);
3897                 }
3898             } else {
3899                 mHotseat.setAlpha(0f);
3900             }
3901         }
3902     }
3903 
3904     /**
3905      * Add an item from all apps or customize onto the given workspace screen.
3906      * If layout is null, add to the current screen.
3907      */
3908     void addExternalItemToScreen(ItemInfo itemInfo, final CellLayout layout) {
3909         if (!mWorkspace.addExternalItemToScreen(itemInfo, layout)) {
3910             showOutOfSpaceMessage(isHotseatLayout(layout));
3911         }
3912     }
3913 
3914     /** Maps the current orientation to an index for referencing orientation correct global icons */
3915     private int getCurrentOrientationIndexForGlobalIcons() {
3916         // default - 0, landscape - 1
3917         switch (getResources().getConfiguration().orientation) {
3918         case Configuration.ORIENTATION_LANDSCAPE:
3919             return 1;
3920         default:
3921             return 0;
3922         }
3923     }
3924 
3925     private Drawable getExternalPackageToolbarIcon(ComponentName activityName, String resourceName) {
3926         try {
3927             PackageManager packageManager = getPackageManager();
3928             // Look for the toolbar icon specified in the activity meta-data
3929             Bundle metaData = packageManager.getActivityInfo(
3930                     activityName, PackageManager.GET_META_DATA).metaData;
3931             if (metaData != null) {
3932                 int iconResId = metaData.getInt(resourceName);
3933                 if (iconResId != 0) {
3934                     Resources res = packageManager.getResourcesForActivity(activityName);
3935                     return res.getDrawable(iconResId);
3936                 }
3937             }
3938         } catch (NameNotFoundException e) {
3939             // This can happen if the activity defines an invalid drawable
3940             Log.w(TAG, &quot;Failed to load toolbar icon; &quot; + activityName.flattenToShortString() +
3941                     &quot; not found&quot;, e);
3942         } catch (Resources.NotFoundException nfe) {
3943             // This can happen if the activity defines an invalid drawable
3944             Log.w(TAG, &quot;Failed to load toolbar icon from &quot; + activityName.flattenToShortString(),
3945                     nfe);
3946         }
3947         return null;
3948     }
3949 
3950     // if successful in getting icon, return it; otherwise, set button to use default drawable
3951     private Drawable.ConstantState updateTextButtonWithIconFromExternalActivity(
3952             int buttonId, ComponentName activityName, int fallbackDrawableId,
3953             String toolbarResourceName) {
3954         Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
3955         Resources r = getResources();
3956         int w = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_width);
3957         int h = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_height);
3958 
3959         TextView button = (TextView) findViewById(buttonId);
3960         // If we were unable to find the icon via the meta-data, use a generic one
3961         if (toolbarIcon == null) {
3962             toolbarIcon = r.getDrawable(fallbackDrawableId);
3963             toolbarIcon.setBounds(0, 0, w, h);
3964             if (button != null) {
3965                 button.setCompoundDrawables(toolbarIcon, null, null, null);
3966             }
3967             return null;
3968         } else {
3969             toolbarIcon.setBounds(0, 0, w, h);
3970             if (button != null) {
3971                 button.setCompoundDrawables(toolbarIcon, null, null, null);
3972             }
3973             return toolbarIcon.getConstantState();
3974         }
3975     }
3976 
3977     // if successful in getting icon, return it; otherwise, set button to use default drawable
3978     private Drawable.ConstantState updateButtonWithIconFromExternalActivity(
3979             int buttonId, ComponentName activityName, int fallbackDrawableId,
3980             String toolbarResourceName) {
3981         ImageView button = (ImageView) findViewById(buttonId);
3982         Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
3983 
3984         if (button != null) {
3985             // If we were unable to find the icon via the meta-data, use a
3986             // generic one
3987             if (toolbarIcon == null) {
3988                 button.setImageResource(fallbackDrawableId);
3989             } else {
3990                 button.setImageDrawable(toolbarIcon);
3991             }
3992         }
3993 
3994         return toolbarIcon != null ? toolbarIcon.getConstantState() : null;
3995 
3996     }
3997 
3998     private void updateTextButtonWithDrawable(int buttonId, Drawable d) {
3999         TextView button = (TextView) findViewById(buttonId);
4000         button.setCompoundDrawables(d, null, null, null);
4001     }
4002 
4003     private void updateButtonWithDrawable(int buttonId, Drawable.ConstantState d) {
4004         ImageView button = (ImageView) findViewById(buttonId);
4005         button.setImageDrawable(d.newDrawable(getResources()));
4006     }
4007 
4008     private void invalidatePressedFocusedStates(View container, View button) {
4009         if (container instanceof HolographicLinearLayout) {
4010             HolographicLinearLayout layout = (HolographicLinearLayout) container;
4011             layout.invalidatePressedFocusedStates();
4012         } else if (button instanceof HolographicImageView) {
4013             HolographicImageView view = (HolographicImageView) button;
4014             view.invalidatePressedFocusedStates();
4015         }
4016     }
4017 
4018     public View getQsbBar() {
4019         if (mQsb == null) {
4020             mQsb = mInflater.inflate(R.layout.qsb, mSearchDropTargetBar, false);
4021             mSearchDropTargetBar.addView(mQsb);
4022         }
4023         return mQsb;
4024     }
4025 
4026     protected boolean updateGlobalSearchIcon() {
4027         final View searchButtonContainer = findViewById(R.id.search_button_container);
4028         final ImageView searchButton = (ImageView) findViewById(R.id.search_button);
4029         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4030         final View voiceButton = findViewById(R.id.voice_button);
4031 
4032         final SearchManager searchManager =
4033                 (SearchManager) getSystemService(Context.SEARCH_SERVICE);
4034         ComponentName activityName = searchManager.getGlobalSearchActivity();
4035         if (activityName != null) {
4036             int coi = getCurrentOrientationIndexForGlobalIcons();
4037             sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4038                     R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
4039                     TOOLBAR_SEARCH_ICON_METADATA_NAME);
4040             if (sGlobalSearchIcon[coi] == null) {
4041                 sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4042                         R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
4043                         TOOLBAR_ICON_METADATA_NAME);
4044             }
4045 
4046             if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.VISIBLE);
4047             searchButton.setVisibility(View.VISIBLE);
4048             invalidatePressedFocusedStates(searchButtonContainer, searchButton);
4049             return true;
4050         } else {
4051             // We disable both search and voice search when there is no global search provider
4052             if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.GONE);
4053             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
4054             if (searchButton != null) searchButton.setVisibility(View.GONE);
4055             if (voiceButton != null) voiceButton.setVisibility(View.GONE);
4056             updateVoiceButtonProxyVisible(false);
4057             return false;
4058         }
4059     }
4060 
4061     protected void updateGlobalSearchIcon(Drawable.ConstantState d) {
4062         final View searchButtonContainer = findViewById(R.id.search_button_container);
4063         final View searchButton = (ImageView) findViewById(R.id.search_button);
4064         updateButtonWithDrawable(R.id.search_button, d);
4065         invalidatePressedFocusedStates(searchButtonContainer, searchButton);
4066     }
4067 
4068     protected boolean updateVoiceSearchIcon(boolean searchVisible) {
4069         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4070         final View voiceButton = findViewById(R.id.voice_button);
4071 
4072         // We only show/update the voice search icon if the search icon is enabled as well
4073         final SearchManager searchManager =
4074                 (SearchManager) getSystemService(Context.SEARCH_SERVICE);
4075         ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
4076 
4077         ComponentName activityName = null;
4078         if (globalSearchActivity != null) {
4079             // Check if the global search activity handles voice search
4080             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
4081             intent.setPackage(globalSearchActivity.getPackageName());
4082             activityName = intent.resolveActivity(getPackageManager());
4083         }
4084 
4085         if (activityName == null) {
4086             // Fallback: check if an activity other than the global search activity
4087             // resolves this
4088             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
4089             activityName = intent.resolveActivity(getPackageManager());
4090         }
4091         if (searchVisible &amp;&amp; activityName != null) {
4092             int coi = getCurrentOrientationIndexForGlobalIcons();
4093             sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4094                     R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
4095                     TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME);
4096             if (sVoiceSearchIcon[coi] == null) {
4097                 sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4098                         R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
4099                         TOOLBAR_ICON_METADATA_NAME);
4100             }
4101             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.VISIBLE);
4102             voiceButton.setVisibility(View.VISIBLE);
4103             updateVoiceButtonProxyVisible(false);
4104             invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
4105             return true;
4106         } else {
4107             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
4108             if (voiceButton != null) voiceButton.setVisibility(View.GONE);
4109             updateVoiceButtonProxyVisible(false);
4110             return false;
4111         }
4112     }
4113 
4114     protected void updateVoiceSearchIcon(Drawable.ConstantState d) {
4115         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4116         final View voiceButton = findViewById(R.id.voice_button);
4117         updateButtonWithDrawable(R.id.voice_button, d);
4118         invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
4119     }
4120 
4121     public void updateVoiceButtonProxyVisible(boolean forceDisableVoiceButtonProxy) {
4122         final View voiceButtonProxy = findViewById(R.id.voice_button_proxy);
4123         if (voiceButtonProxy != null) {
4124             boolean visible = !forceDisableVoiceButtonProxy &amp;&amp;
4125                     mWorkspace.shouldVoiceButtonProxyBeVisible();
4126             voiceButtonProxy.setVisibility(visible ? View.VISIBLE : View.GONE);
4127             voiceButtonProxy.bringToFront();
4128         }
4129     }
4130 
4131     /**
<abbr title="4132      * This is an overrid eot disable the voice button proxy.  If disabled is true, then the voice button proxy">4132      * This is an overrid eot disable the voice button proxy.  If disabled is true, then the voice button🔵</abbr>
4133      * will be hidden regardless of what shouldVoiceButtonProxyBeVisible() returns.
4134      */
4135     public void disableVoiceButtonProxy(boolean disabled) {
4136         updateVoiceButtonProxyVisible(disabled);
4137     }
4138 
4139     @Override
4140     public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
4141         final boolean result = super.dispatchPopulateAccessibilityEvent(event);
4142         final List&lt;CharSequence&gt; text = event.getText();
4143         text.clear();
4144         // Populate event with a fake title based on the current state.
4145         if (mState == State.APPS_CUSTOMIZE) {
4146             text.add(mAppsCustomizeTabHost.getContentTag());
4147         } else {
4148             text.add(getString(R.string.all_apps_home_button_label));
4149         }
4150         return result;
4151     }
4152 
4153     /**
4154      * Receives notifications when system dialogs are to be closed.
4155      */
4156     private class CloseSystemDialogsIntentReceiver extends BroadcastReceiver {
4157         @Override
4158         public void onReceive(Context context, Intent intent) {
4159             closeSystemDialogs();
4160         }
4161     }
4162 
4163     /**
4164      * Receives notifications whenever the appwidgets are reset.
4165      */
4166     private class AppWidgetResetObserver extends ContentObserver {
4167         public AppWidgetResetObserver() {
4168             super(new Handler());
4169         }
4170 
4171         @Override
4172         public void onChange(boolean selfChange) {
4173             onAppWidgetReset();
4174         }
4175     }
4176 
4177     /**
4178      * If the activity is currently paused, signal that we need to run the passed Runnable
4179      * in onResume.
4180      *
4181      * This needs to be called from incoming places where resources might have been loaded
4182      * while we are paused.  That is becaues the Configuration might be wrong
4183      * when we&#x27;re not running, and if it comes back to what it was when we
4184      * were paused, we are not restarted.
4185      *
4186      * Implementation of the method from LauncherModel.Callbacks.
4187      *
4188      * @return true if we are currently paused.  The caller might be able to
4189      * skip some work in that case since we will come back again.
4190      */
4191     private boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) {
4192         if (mPaused) {
4193             Log.i(TAG, &quot;Deferring update until onResume&quot;);
4194             if (deletePreviousRunnables) {
4195                 while (mBindOnResumeCallbacks.remove(run)) {
4196                 }
4197             }
4198             mBindOnResumeCallbacks.add(run);
4199             return true;
4200         } else {
4201             return false;
4202         }
4203     }
4204 
4205     private boolean waitUntilResume(Runnable run) {
4206         return waitUntilResume(run, false);
4207     }
4208 
4209     public void addOnResumeCallback(Runnable run) {
4210         mOnResumeCallbacks.add(run);
4211     }
4212 
4213     /**
4214      * If the activity is currently paused, signal that we need to re-run the loader
4215      * in onResume.
4216      *
4217      * This needs to be called from incoming places where resources might have been loaded
4218      * while we are paused.  That is becaues the Configuration might be wrong
4219      * when we&#x27;re not running, and if it comes back to what it was when we
4220      * were paused, we are not restarted.
4221      *
4222      * Implementation of the method from LauncherModel.Callbacks.
4223      *
4224      * @return true if we are currently paused.  The caller might be able to
4225      * skip some work in that case since we will come back again.
4226      */
4227     public boolean setLoadOnResume() {
4228         if (mPaused) {
4229             Log.i(TAG, &quot;setLoadOnResume&quot;);
4230             mOnResumeNeedsLoad = true;
4231             return true;
4232         } else {
4233             return false;
4234         }
4235     }
4236 
4237     /**
4238      * Implementation of the method from LauncherModel.Callbacks.
4239      */
4240     public int getCurrentWorkspaceScreen() {
4241         if (mWorkspace != null) {
4242             return mWorkspace.getCurrentPage();
4243         } else {
4244             return SCREEN_COUNT / 2;
4245         }
4246     }
4247 
4248     /**
4249      * Refreshes the shortcuts shown on the workspace.
4250      *
4251      * Implementation of the method from LauncherModel.Callbacks.
4252      */
4253     public void startBinding() {
4254         setWorkspaceLoading(true);
4255 
4256         // If we&#x27;re starting binding all over again, clear any bind calls we&#x27;d postponed in
4257         // the past (see waitUntilResume) -- we don&#x27;t need them since we&#x27;re starting binding
4258         // from scratch again
4259         mBindOnResumeCallbacks.clear();
4260 
4261         // Clear the workspace because it&#x27;s going to be rebound
4262         mWorkspace.clearDropTargets();
4263         mWorkspace.removeAllWorkspaceScreens();
4264 
4265         mWidgetsToAdvance.clear();
4266         if (mHotseat != null) {
4267             mHotseat.resetLayout();
4268         }
4269     }
4270 
4271     @Override
4272     public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
4273         bindAddScreens(orderedScreenIds);
4274 
4275         // If there are no screens, we need to have an empty screen
4276         if (orderedScreenIds.size() == 0) {
4277             mWorkspace.addExtraEmptyScreen();
4278         }
4279 
4280         // Create the custom content page (this call updates mDefaultScreen which calls
4281         // setCurrentPage() so ensure that all pages are added before calling this).
4282         if (hasCustomContentToLeft()) {
4283             mWorkspace.createCustomContentContainer();
4284             populateCustomContentContainer();
4285         }
4286     }
4287 
4288     @Override
4289     public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
4290         // Log to disk
4291         Launcher.addDumpLog(TAG, &quot;11683562 - bindAddScreens()&quot;, true);
4292         Launcher.addDumpLog(TAG, &quot;11683562 -   orderedScreenIds: &quot; +
4293                 TextUtils.join(&quot;, &quot;, orderedScreenIds), true);
4294         int count = orderedScreenIds.size();
4295         for (int i = 0; i &lt; count; i++) {
4296             mWorkspace.insertNewWorkspaceScreenBeforeEmptyScreen(orderedScreenIds.get(i));
4297         }
4298     }
4299 
4300     private boolean shouldShowWeightWatcher() {
4301         String spKey = LauncherAppState.getSharedPreferencesKey();
4302         SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
4303         boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, SHOW_WEIGHT_WATCHER_DEFAULT);
4304 
4305         return show;
4306     }
4307 
4308     private void toggleShowWeightWatcher() {
4309         String spKey = LauncherAppState.getSharedPreferencesKey();
4310         SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
4311         boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, true);
4312 
4313         show = !show;
4314 
4315         SharedPreferences.Editor editor = sp.edit();
4316         editor.putBoolean(SHOW_WEIGHT_WATCHER, show);
4317         editor.commit();
4318 
4319         if (mWeightWatcher != null) {
4320             mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
4321         }
4322     }
4323 
4324     public void bindAppsAdded(final ArrayList&lt;Long&gt; newScreens,
4325                               final ArrayList&lt;ItemInfo&gt; addNotAnimated,
4326                               final ArrayList&lt;ItemInfo&gt; addAnimated,
4327                               final ArrayList&lt;AppInfo&gt; addedApps) {
4328         Runnable r = new Runnable() {
4329             public void run() {
4330                 bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
4331             }
4332         };
4333         if (waitUntilResume(r)) {
4334             return;
4335         }
4336 
4337         // Add the new screens
4338         if (newScreens != null) {
4339             bindAddScreens(newScreens);
4340         }
4341 
4342         // We add the items without animation on non-visible pages, and with
4343         // animations on the new page (which we will try and snap to).
4344         if (addNotAnimated != null &amp;&amp; !addNotAnimated.isEmpty()) {
4345             bindItems(addNotAnimated, 0,
4346                     addNotAnimated.size(), false);
4347         }
4348         if (addAnimated != null &amp;&amp; !addAnimated.isEmpty()) {
4349             bindItems(addAnimated, 0,
4350                     addAnimated.size(), true);
4351         }
4352 
4353         // Remove the extra empty screen
4354         mWorkspace.removeExtraEmptyScreen(false, false);
4355 
4356         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4357                 addedApps != null &amp;&amp; mAppsCustomizeContent != null) {
4358             mAppsCustomizeContent.addApps(addedApps);
4359         }
4360     }
4361 
4362     /**
4363      * Bind the items start-end from the list.
4364      *
4365      * Implementation of the method from LauncherModel.Callbacks.
4366      */
4367     public void bindItems(final ArrayList&lt;ItemInfo&gt; shortcuts, final int start, final int end,
4368                           final boolean forceAnimateIcons) {
4369         Runnable r = new Runnable() {
4370             public void run() {
4371                 bindItems(shortcuts, start, end, forceAnimateIcons);
4372             }
4373         };
4374         if (waitUntilResume(r)) {
4375             return;
4376         }
4377 
4378         // Get the list of added shortcuts and intersect them with the set of shortcuts here
4379         final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
4380         final Collection&lt;Animator&gt; bounceAnims = new ArrayList&lt;Animator&gt;();
4381         final boolean animateIcons = forceAnimateIcons &amp;&amp; canRunNewAppsAnimation();
4382         Workspace workspace = mWorkspace;
4383         long newShortcutsScreenId = -1;
4384         for (int i = start; i &lt; end; i++) {
4385             final ItemInfo item = shortcuts.get(i);
4386 
4387             // Short circuit if we are loading dock items for a configuration which has no dock
4388             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
4389                     mHotseat == null) {
4390                 continue;
4391             }
4392 
4393             switch (item.itemType) {
4394                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
4395                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
4396                     ShortcutInfo info = (ShortcutInfo) item;
4397                     View shortcut = createShortcut(info);
4398 
4399                     /*
4400                      * TODO: FIX collision case
4401                      */
4402                     if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
4403                         CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
4404                         if (cl != null &amp;&amp; cl.isOccupied(item.cellX, item.cellY)) {
4405                             View v = cl.getChildAt(item.cellX, item.cellY);
4406                             Object tag = v.getTag();
4407                             String desc = &quot;Collision while binding workspace item: &quot; + item
4408                                     + &quot;. Collides with &quot; + tag;
4409                             if (LauncherAppState.isDogfoodBuild()) {
4410                                 throw (new RuntimeException(desc));
4411                             } else {
4412                                 Log.d(TAG, desc);
4413                             }
4414                         }
4415                     }
4416 
4417                     workspace.addInScreenFromBind(shortcut, item.container, item.screenId, item.cellX,
4418                             item.cellY, 1, 1);
4419                     if (animateIcons) {
4420                         // Animate all the applications up now
4421                         shortcut.setAlpha(0f);
4422                         shortcut.setScaleX(0f);
4423                         shortcut.setScaleY(0f);
4424                         bounceAnims.add(createNewAppBounceAnimation(shortcut, i));
4425                         newShortcutsScreenId = item.screenId;
4426                     }
4427                     break;
4428                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
4429                     FolderIcon newFolder = FolderIcon.fromXml(R.layout.folder_icon, this,
4430                             (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()),
4431                             (FolderInfo) item, mIconCache);
4432                     workspace.addInScreenFromBind(newFolder, item.container, item.screenId, item.cellX,
4433                             item.cellY, 1, 1);
4434                     break;
4435                 default:
4436                     throw new RuntimeException(&quot;Invalid Item Type&quot;);
4437             }
4438         }
4439 
4440         if (animateIcons) {
4441             // Animate to the correct page
4442             if (newShortcutsScreenId &gt; -1) {
4443                 long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
4444                 final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
4445                 final Runnable startBounceAnimRunnable = new Runnable() {
4446                     public void run() {
4447                         anim.playTogether(bounceAnims);
4448                         anim.start();
4449                     }
4450                 };
4451                 if (newShortcutsScreenId != currentScreenId) {
4452                     // We post the animation slightly delayed to prevent slowdowns
4453                     // when we are loading right after we return to launcher.
4454                     mWorkspace.postDelayed(new Runnable() {
4455                         public void run() {
4456                             if (mWorkspace != null) {
4457                                 mWorkspace.snapToPage(newScreenIndex);
4458                                 mWorkspace.postDelayed(startBounceAnimRunnable,
4459                                         NEW_APPS_ANIMATION_DELAY);
4460                             }
4461                         }
4462                     }, NEW_APPS_PAGE_MOVE_DELAY);
4463                 } else {
4464                     mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
4465                 }
4466             }
4467         }
4468         workspace.requestLayout();
4469     }
4470 
4471     /**
4472      * Implementation of the method from LauncherModel.Callbacks.
4473      */
4474     public void bindFolders(final HashMap&lt;Long, FolderInfo&gt; folders) {
4475         Runnable r = new Runnable() {
4476             public void run() {
4477                 bindFolders(folders);
4478             }
4479         };
4480         if (waitUntilResume(r)) {
4481             return;
4482         }
4483         sFolders.clear();
4484         sFolders.putAll(folders);
4485     }
4486 
4487     /**
4488      * Add the views for a widget to the workspace.
4489      *
4490      * Implementation of the method from LauncherModel.Callbacks.
4491      */
4492     public void bindAppWidget(final LauncherAppWidgetInfo item) {
4493         Runnable r = new Runnable() {
4494             public void run() {
4495                 bindAppWidget(item);
4496             }
4497         };
4498         if (waitUntilResume(r)) {
4499             return;
4500         }
4501 
4502         final long start = DEBUG_WIDGETS ? SystemClock.uptimeMillis() : 0;
4503         if (DEBUG_WIDGETS) {
4504             Log.d(TAG, &quot;bindAppWidget: &quot; + item);
4505         }
4506         final Workspace workspace = mWorkspace;
4507 
4508         AppWidgetProviderInfo appWidgetInfo;
4509         if (((item.restoreStatus &amp; LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0) &amp;&amp;
4510                 ((item.restoreStatus &amp; LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) != 0)) {
4511 
4512             appWidgetInfo = mModel.findAppWidgetProviderInfoWithComponent(this, item.providerName);
4513             if (appWidgetInfo == null) {
4514                 if (DEBUG_WIDGETS) {
4515                     Log.d(TAG, &quot;Removing restored widget: id=&quot; + item.appWidgetId
4516                             + &quot; belongs to component &quot; + item.providerName
4517                             + &quot;, as the povider is null&quot;);
4518                 }
4519                 LauncherModel.deleteItemFromDatabase(this, item);
4520                 return;
4521             }
4522             // Note: This assumes that the id remap broadcast is received before this step.
4523             // If that is not the case, the id remap will be ignored and user may see the
4524             // click to setup view.
4525             PendingAddWidgetInfo pendingInfo = new PendingAddWidgetInfo(appWidgetInfo, null, null);
4526             pendingInfo.spanX = item.spanX;
4527             pendingInfo.spanY = item.spanY;
4528             pendingInfo.minSpanX = item.minSpanX;
4529             pendingInfo.minSpanY = item.minSpanY;
4530             Bundle options =
4531                     AppsCustomizePagedView.getDefaultOptionsForWidget(this, pendingInfo);
4532 
4533             int newWidgetId = mAppWidgetHost.allocateAppWidgetId();
4534             boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
4535                     newWidgetId, appWidgetInfo, options);
4536 
4537             // TODO consider showing a permission dialog when the widget is clicked.
4538             if (!success) {
4539                 mAppWidgetHost.deleteAppWidgetId(newWidgetId);
4540                 if (DEBUG_WIDGETS) {
4541                     Log.d(TAG, &quot;Removing restored widget: id=&quot; + item.appWidgetId
4542                             + &quot; belongs to component &quot; + item.providerName
4543                             + &quot;, as the launcher is unable to bing a new widget id&quot;);
4544                 }
4545                 LauncherModel.deleteItemFromDatabase(this, item);
4546                 return;
4547             }
4548 
4549             item.appWidgetId = newWidgetId;
4550 
4551             // If the widget has a configure activity, it is still needs to set it up, otherwise
4552             // the widget is ready to go.
4553             item.restoreStatus = (appWidgetInfo.configure == null)
4554                     ? LauncherAppWidgetInfo.RESTORE_COMPLETED
4555                     : LauncherAppWidgetInfo.FLAG_UI_NOT_READY;
4556 
4557             LauncherModel.updateItemInDatabase(this, item);
4558         }
4559 
4560         if (item.restoreStatus == LauncherAppWidgetInfo.RESTORE_COMPLETED) {
4561             final int appWidgetId = item.appWidgetId;
4562             appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
4563             if (DEBUG_WIDGETS) {
<abbr title="4564                 Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.provider);">4564                 Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidget🔵</abbr>
4565             }
4566 
4567             item.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);
4568         } else {
4569             appWidgetInfo = null;
4570             PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item);
4571             view.updateIcon(mIconCache);
4572             item.hostView = view;
4573             item.hostView.updateAppWidget(null);
4574             item.hostView.setOnClickListener(this);
4575         }
4576 
4577         item.hostView.setTag(item);
4578         item.onBindAppWidget(this);
4579 
4580         workspace.addInScreen(item.hostView, item.container, item.screenId, item.cellX,
4581                 item.cellY, item.spanX, item.spanY, false);
4582         addWidgetToAutoAdvanceIfNeeded(item.hostView, appWidgetInfo);
4583 
4584         workspace.requestLayout();
4585 
4586         if (DEBUG_WIDGETS) {
4587             Log.d(TAG, &quot;bound widget id=&quot;+item.appWidgetId+&quot; in &quot;
4588                     + (SystemClock.uptimeMillis()-start) + &quot;ms&quot;);
4589         }
4590     }
4591 
4592     /**
4593      * Restores a pending widget.
4594      *
4595      * @param appWidgetId The app widget id
4596      * @param cellInfo The position on screen where to create the widget.
4597      */
4598     private void completeRestoreAppWidget(final int appWidgetId) {
4599         LauncherAppWidgetHostView view = mWorkspace.getWidgetForAppWidgetId(appWidgetId);
4600         if ((view == null) || !(view instanceof PendingAppWidgetHostView)) {
4601             Log.e(TAG, &quot;Widget update called, when the widget no longer exists.&quot;);
4602             return;
4603         }
4604 
4605         LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) view.getTag();
4606         info.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;
4607 
4608         mWorkspace.reinflateWidgetsIfNecessary();
4609         LauncherModel.updateItemInDatabase(this, info);
4610     }
4611 
4612     public void onPageBoundSynchronously(int page) {
4613         mSynchronouslyBoundPages.add(page);
4614     }
4615 
4616     /**
4617      * Callback saying that there aren&#x27;t any more items to bind.
4618      *
4619      * Implementation of the method from LauncherModel.Callbacks.
4620      */
4621     public void finishBindingItems(final boolean upgradePath) {
4622         Runnable r = new Runnable() {
4623             public void run() {
4624                 finishBindingItems(upgradePath);
4625             }
4626         };
4627         if (waitUntilResume(r)) {
4628             return;
4629         }
4630         if (mSavedState != null) {
4631             if (!mWorkspace.hasFocus()) {
4632                 mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
4633             }
4634             mSavedState = null;
4635         }
4636 
4637         mWorkspace.restoreInstanceStateForRemainingPages();
4638 
4639         setWorkspaceLoading(false);
4640         sendLoadingCompleteBroadcastIfNecessary();
4641 
4642         // If we received the result of any pending adds while the loader was running (e.g. the
4643         // widget configuration forced an orientation change), process them now.
4644         if (sPendingAddItem != null) {
4645             final long screenId = completeAdd(sPendingAddItem);
4646 
4647             // TODO: this moves the user to the page where the pending item was added. Ideally,
4648             // the screen would be guaranteed to exist after bind, and the page would be set through
4649             // the workspace restore process.
4650             mWorkspace.post(new Runnable() {
4651                 @Override
4652                 public void run() {
4653                     mWorkspace.snapToScreenId(screenId);
4654                 }
4655             });
4656             sPendingAddItem = null;
4657         }
4658 
4659         if (upgradePath) {
4660             mWorkspace.getUniqueComponents(true, null);
4661             mIntentsOnWorkspaceFromUpgradePath = mWorkspace.getUniqueComponents(true, null);
4662         }
4663         PackageInstallerCompat.getInstance(this).onFinishBind();
4664         mModel.recheckRestoredItems(this);
4665     }
4666 
4667     private void sendLoadingCompleteBroadcastIfNecessary() {
4668         if (!mSharedPrefs.getBoolean(FIRST_LOAD_COMPLETE, false)) {
4669             String permission =
4670                     getResources().getString(R.string.receive_first_load_broadcast_permission);
4671             Intent intent = new Intent(ACTION_FIRST_LOAD_COMPLETE);
4672             sendBroadcast(intent, permission);
4673             SharedPreferences.Editor editor = mSharedPrefs.edit();
4674             editor.putBoolean(FIRST_LOAD_COMPLETE, true);
4675             editor.apply();
4676         }
4677     }
4678 
4679     public boolean isAllAppsButtonRank(int rank) {
4680         if (mHotseat != null) {
4681             return mHotseat.isAllAppsButtonRank(rank);
4682         }
4683         return false;
4684     }
4685 
4686     private boolean canRunNewAppsAnimation() {
4687         long diff = System.currentTimeMillis() - mDragController.getLastGestureUpTime();
4688         return diff &gt; (NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS * 1000);
4689     }
4690 
4691     private ValueAnimator createNewAppBounceAnimation(View v, int i) {
4692         ValueAnimator bounceAnim = LauncherAnimUtils.ofPropertyValuesHolder(v,
4693                 PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1f),
4694                 PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f),
4695                 PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f));
4696         bounceAnim.setDuration(InstallShortcutReceiver.NEW_SHORTCUT_BOUNCE_DURATION);
4697         bounceAnim.setStartDelay(i * InstallShortcutReceiver.NEW_SHORTCUT_STAGGER_DELAY);
4698         bounceAnim.setInterpolator(new SmoothPagedView.OvershootInterpolator());
4699         return bounceAnim;
4700     }
4701 
4702     public boolean useVerticalBarLayout() {
4703         return LauncherAppState.getInstance().getDynamicGrid().
4704                 getDeviceProfile().isVerticalBarLayout();
4705     }
4706 
4707     protected Rect getSearchBarBounds() {
4708         return LauncherAppState.getInstance().getDynamicGrid().
4709                 getDeviceProfile().getSearchBarBounds();
4710     }
4711 
4712     @Override
4713     public void bindSearchablesChanged() {
4714         boolean searchVisible = updateGlobalSearchIcon();
4715         boolean voiceVisible = updateVoiceSearchIcon(searchVisible);
4716         if (mSearchDropTargetBar != null) {
4717             mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
4718         }
4719     }
4720 
4721     /**
4722      * Add the icons for all apps.
4723      *
4724      * Implementation of the method from LauncherModel.Callbacks.
4725      */
4726     public void bindAllApplications(final ArrayList&lt;AppInfo&gt; apps) {
4727         if (LauncherAppState.isDisableAllApps()) {
4728             if (mIntentsOnWorkspaceFromUpgradePath != null) {
4729                 if (LauncherModel.UPGRADE_USE_MORE_APPS_FOLDER) {
4730                     getHotseat().addAllAppsFolder(mIconCache, apps,
4731                             mIntentsOnWorkspaceFromUpgradePath, Launcher.this, mWorkspace);
4732                 }
4733                 mIntentsOnWorkspaceFromUpgradePath = null;
4734             }
4735             if (mAppsCustomizeContent != null) {
4736                 mAppsCustomizeContent.onPackagesUpdated(
4737                         LauncherModel.getSortedWidgetsAndShortcuts(this));
4738             }
4739         } else {
4740             if (mAppsCustomizeContent != null) {
4741                 mAppsCustomizeContent.setApps(apps);
4742                 mAppsCustomizeContent.onPackagesUpdated(
4743                         LauncherModel.getSortedWidgetsAndShortcuts(this));
4744             }
4745         }
4746     }
4747 
4748     /**
4749      * A package was updated.
4750      *
4751      * Implementation of the method from LauncherModel.Callbacks.
4752      */
4753     public void bindAppsUpdated(final ArrayList&lt;AppInfo&gt; apps) {
4754         Runnable r = new Runnable() {
4755             public void run() {
4756                 bindAppsUpdated(apps);
4757             }
4758         };
4759         if (waitUntilResume(r)) {
4760             return;
4761         }
4762 
4763         if (mWorkspace != null) {
4764             mWorkspace.updateShortcutsAndWidgets(apps);
4765         }
4766 
4767         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4768                 mAppsCustomizeContent != null) {
4769             mAppsCustomizeContent.updateApps(apps);
4770         }
4771     }
4772 
4773     /**
4774      * Packages were restored
4775      */
4776     public void bindAppsRestored(final ArrayList&lt;AppInfo&gt; apps) {
4777         Runnable r = new Runnable() {
4778             public void run() {
4779                 bindAppsRestored(apps);
4780             }
4781         };
4782         if (waitUntilResume(r)) {
4783             return;
4784         }
4785 
4786         if (mWorkspace != null) {
4787             mWorkspace.updateShortcutsAndWidgets(apps);
4788         }
4789     }
4790 
4791     /**
4792      * Update the state of a package, typically related to install state.
4793      *
4794      * Implementation of the method from LauncherModel.Callbacks.
4795      */
4796     @Override
4797     public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo) {
4798         if (mWorkspace != null) {
4799             mWorkspace.updatePackageState(installInfo);
4800         }
4801     }
4802 
4803     /**
4804      * Update the label and icon of all the icons in a package
4805      *
4806      * Implementation of the method from LauncherModel.Callbacks.
4807      */
4808     @Override
4809     public void updatePackageBadge(String packageName) {
4810         if (mWorkspace != null) {
4811             mWorkspace.updatePackageBadge(packageName, UserHandleCompat.myUserHandle());
4812         }
4813     }
4814 
4815     /**
4816      * A package was uninstalled.  We take both the super set of packageNames
4817      * in addition to specific applications to remove, the reason being that
4818      * this can be called when a package is updated as well.  In that scenario,
4819      * we only remove specific components from the workspace, where as
4820      * package-removal should clear all items by package name.
4821      *
4822      * Implementation of the method from LauncherModel.Callbacks.
4823      */
4824     public void bindComponentsRemoved(final ArrayList&lt;String&gt; packageNames,
4825             final ArrayList&lt;AppInfo&gt; appInfos, final UserHandleCompat user) {
4826         Runnable r = new Runnable() {
4827             public void run() {
4828                 bindComponentsRemoved(packageNames, appInfos, user);
4829             }
4830         };
4831         if (waitUntilResume(r)) {
4832             return;
4833         }
4834 
4835         if (!packageNames.isEmpty()) {
4836             mWorkspace.removeItemsByPackageName(packageNames, user);
4837         }
4838         if (!appInfos.isEmpty()) {
4839             mWorkspace.removeItemsByApplicationInfo(appInfos, user);
4840         }
4841 
4842         // Notify the drag controller
4843         mDragController.onAppsRemoved(packageNames, appInfos);
4844 
4845         // Update AllApps
4846         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4847                 mAppsCustomizeContent != null) {
4848             mAppsCustomizeContent.removeApps(appInfos);
4849         }
4850     }
4851 
4852     /**
4853      * A number of packages were updated.
4854      */
4855     private ArrayList&lt;Object&gt; mWidgetsAndShortcuts;
4856     private Runnable mBindPackagesUpdatedRunnable = new Runnable() {
4857             public void run() {
4858                 bindPackagesUpdated(mWidgetsAndShortcuts);
4859                 mWidgetsAndShortcuts = null;
4860             }
4861         };
4862     public void bindPackagesUpdated(final ArrayList&lt;Object&gt; widgetsAndShortcuts) {
4863         if (waitUntilResume(mBindPackagesUpdatedRunnable, true)) {
4864             mWidgetsAndShortcuts = widgetsAndShortcuts;
4865             return;
4866         }
4867 
4868         // Update the widgets pane
4869         if (mAppsCustomizeContent != null) {
4870             mAppsCustomizeContent.onPackagesUpdated(widgetsAndShortcuts);
4871         }
4872     }
4873 
4874     private int mapConfigurationOriActivityInfoOri(int configOri) {
4875         final Display d = getWindowManager().getDefaultDisplay();
4876         int naturalOri = Configuration.ORIENTATION_LANDSCAPE;
4877         switch (d.getRotation()) {
4878         case Surface.ROTATION_0:
4879         case Surface.ROTATION_180:
4880             // We are currently in the same basic orientation as the natural orientation
4881             naturalOri = configOri;
4882             break;
4883         case Surface.ROTATION_90:
4884         case Surface.ROTATION_270:
4885             // We are currently in the other basic orientation to the natural orientation
4886             naturalOri = (configOri == Configuration.ORIENTATION_LANDSCAPE) ?
4887                     Configuration.ORIENTATION_PORTRAIT : Configuration.ORIENTATION_LANDSCAPE;
4888             break;
4889         }
4890 
4891         int[] oriMap = {
4892                 ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
4893                 ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE,
4894                 ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
4895                 ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
4896         };
4897         // Since the map starts at portrait, we need to offset if this device&#x27;s natural orientation
4898         // is landscape.
4899         int indexOffset = 0;
4900         if (naturalOri == Configuration.ORIENTATION_LANDSCAPE) {
4901             indexOffset = 1;
4902         }
4903         return oriMap[(d.getRotation() + indexOffset) % 4];
4904     }
4905 
4906     public boolean isRotationEnabled() {
4907         boolean enableRotation = sForceEnableRotation ||
4908                 getResources().getBoolean(R.bool.allow_rotation);
4909         return enableRotation;
4910     }
4911     public void lockScreenOrientation() {
4912         if (isRotationEnabled()) {
4913             setRequestedOrientation(mapConfigurationOriActivityInfoOri(getResources()
4914                     .getConfiguration().orientation));
4915         }
4916     }
4917     public void unlockScreenOrientation(boolean immediate) {
4918         if (isRotationEnabled()) {
4919             if (immediate) {
4920                 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
4921             } else {
4922                 mHandler.postDelayed(new Runnable() {
4923                     public void run() {
4924                         setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
4925                     }
4926                 }, mRestoreScreenOrientationDelay);
4927             }
4928         }
4929     }
4930 
4931     /**
4932      * Called when the SearchBar hint should be changed.
4933      *
4934      * @param hint the hint to be displayed in the search bar.
4935      */
4936     protected void onSearchBarHintChanged(String hint) {
4937 
4938     }
4939 
4940     protected boolean isLauncherPreinstalled() {
4941         PackageManager pm = getPackageManager();
4942         try {
4943             ApplicationInfo ai = pm.getApplicationInfo(getComponentName().getPackageName(), 0);
4944             if ((ai.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
4945                 return true;
4946             } else {
4947                 return false;
4948             }
4949         } catch (NameNotFoundException e) {
4950             e.printStackTrace();
4951             return false;
4952         }
4953     }
4954 
4955 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4956     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4957      * This method indicates whether or not we should suggest default wallpaper dimensions</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4958      * when our wallpaper cropper was not yet used to set a wallpaper.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4959      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4960     protected boolean overrideWallpaperDimensions() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4961         return true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4962     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4963 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4964     protected boolean shouldClingFocusHotseatApp() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4965         return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4966     }</span>
4967 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4968         mLauncherClings.dismissFirstRunCling(v);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4969     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4970     public void dismissMigrationClingCopyApps(View v) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4971         mLauncherClings.dismissMigrationClingCopyApps(v);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4972     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4973     public void dismissMigrationClingUseDefault(View v) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4974         mLauncherClings.dismissMigrationClingUseDefault(v);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4975     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4976     public void dismissMigrationWorkspaceCling(View v) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4977         mLauncherClings.dismissMigrationWorkspaceCling(v);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4978     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4979     public void dismissWorkspaceCling(View v) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4980         mLauncherClings.dismissWorkspaceCling(v);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4981     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4982     public void dismissFolderCling(View v) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4983         mLauncherClings.dismissFolderCling(v);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4984     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4985 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4986     private boolean shouldRunFirstRunActivity() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4987         return !ActivityManager.isRunningInTestHarness();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4988     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4989 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4990     public void showFirstRunActivity() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4991         if (shouldRunFirstRunActivity() &amp;&amp; hasFirstRunActivity()</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4992                 &amp;&amp; !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4993             Intent firstRunIntent = getFirstRunActivity();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4994             if (firstRunIntent != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4995                 startActivity(firstRunIntent);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4996                 markFirstRunActivityShown();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4997             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4998         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4999     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5000 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5001     private void markFirstRunActivityShown() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5002         SharedPreferences.Editor editor = mSharedPrefs.edit();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5003         editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5004         editor.apply();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5005     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5006 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5007     void showWorkspaceSearchAndHotseat() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5008         mWorkspace.setAlpha(1f);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5009         mHotseat.setAlpha(1f);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5010         mPageIndicators.setAlpha(1f);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5011         mSearchDropTargetBar.showSearchBar(false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5012     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5013 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5014     void hideWorkspaceSearchAndHotseat() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5015         mWorkspace.setAlpha(0f);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5016         mHotseat.setAlpha(0f);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5017         mPageIndicators.setAlpha(0f);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5018         mSearchDropTargetBar.hideSearchBar(false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5019     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5020 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5021 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5022     public ItemInfo createAppDragInfo(Intent appLaunchIntent) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5023         ResolveInfo ri = getPackageManager().resolveActivity(appLaunchIntent, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5024         if (ri == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5025             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5026         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5027         return new AppInfo(getPackageManager(), ri, mIconCache, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5028     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5029 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5030     public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5031             Bitmap icon) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5032         return new ShortcutInfo(shortcutIntent, caption, icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5033     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5034 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5035     public void startDrag(View dragView, ItemInfo dragInfo, DragSource source) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5036         dragView.setTag(dragInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5037         mWorkspace.onDragStartedWithItem(dragView);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5038         mWorkspace.beginDragShared(dragView, source);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5039     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5040 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5041     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5042      * Prints out out state for debugging.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5043      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5044     public void dumpState() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5045         Log.d(TAG, &quot;BEGIN launcher3 dump state for launcher &quot; + this);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5046         Log.d(TAG, &quot;mSavedState=&quot; + mSavedState);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5047         Log.d(TAG, &quot;mWorkspaceLoading=&quot; + mWorkspaceLoading);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5048         Log.d(TAG, &quot;mRestoring=&quot; + mRestoring);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5049         Log.d(TAG, &quot;mWaitingForResult=&quot; + mWaitingForResult);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5050         Log.d(TAG, &quot;mSavedInstanceState=&quot; + mSavedInstanceState);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5051         Log.d(TAG, &quot;sFolders.size=&quot; + sFolders.size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5052         mModel.dumpState();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5053 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5054         if (mAppsCustomizeContent != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5055             mAppsCustomizeContent.dumpState();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5056         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5057         Log.d(TAG, &quot;END launcher3 dump state&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5058     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5059 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5060     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5061     public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5062         super.dump(prefix, fd, writer, args);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5063         synchronized (sDumpLogs) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5064             writer.println(&quot; &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5065             writer.println(&quot;Debug logs: &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5066             for (int i = 0; i &lt; sDumpLogs.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5067                 writer.println(&quot;  &quot; + sDumpLogs.get(i));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5068             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5069         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5070     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5071 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5072     public static void dumpDebugLogsToConsole() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5073         if (DEBUG_DUMP_LOG) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5074             synchronized (sDumpLogs) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5075                 Log.d(TAG, &quot;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5076                 Log.d(TAG, &quot;*********************&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5077                 Log.d(TAG, &quot;Launcher debug logs: &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5078                 for (int i = 0; i &lt; sDumpLogs.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5079                     Log.d(TAG, &quot;  &quot; + sDumpLogs.get(i));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5080                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5081                 Log.d(TAG, &quot;*********************&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5082                 Log.d(TAG, &quot;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5083             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5084         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5085     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5086 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5087     public static void addDumpLog(String tag, String log, boolean debugLog) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5088         addDumpLog(tag, log, null, debugLog);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5089     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5090 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5091     public static void addDumpLog(String tag, String log, Exception e, boolean debugLog) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5092         if (debugLog) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5093             if (e != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5094                 Log.d(tag, log, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5095             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5096                 Log.d(tag, log);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5097             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5098         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5099         if (DEBUG_DUMP_LOG) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5100             sDateStamp.setTime(System.currentTimeMillis());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5101             synchronized (sDumpLogs) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5102                 sDumpLogs.add(sDateFormat.format(sDateStamp) + &quot;: &quot; + tag + &quot;, &quot; + log</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5103                     + (e == null ? &quot;&quot; : (&quot;, Exception: &quot; + e)));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5104             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5105         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5106     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5107 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5108     public void dumpLogsToLocalData() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5109         if (DEBUG_DUMP_LOG) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5110             new AsyncTask&lt;Void, Void, Void&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5111                 public Void doInBackground(Void ... args) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5112                     boolean success = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5113                     sDateStamp.setTime(sRunStart);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5114                     String FILENAME = sDateStamp.getMonth() + &quot;-&quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5115                             + sDateStamp.getDay() + &quot;_&quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5116                             + sDateStamp.getHours() + &quot;-&quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5117                             + sDateStamp.getMinutes() + &quot;_&quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5118                             + sDateStamp.getSeconds() + &quot;.txt&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5119 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5120                     FileOutputStream fos = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5121                     File outFile = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5122                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5123                         outFile = new File(getFilesDir(), FILENAME);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5124                         outFile.createNewFile();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5125                         fos = new FileOutputStream(outFile);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5126                     } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5127                         e.printStackTrace();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5128                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5129                     if (fos != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5130                         PrintWriter writer = new PrintWriter(fos);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5131 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5132                         writer.println(&quot; &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5133                         writer.println(&quot;Debug logs: &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5134                         synchronized (sDumpLogs) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5135                             for (int i = 0; i &lt; sDumpLogs.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5136                                 writer.println(&quot;  &quot; + sDumpLogs.get(i));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5137                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5138                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5139                         writer.close();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5140                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5141                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5142                         if (fos != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5143                             fos.close();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5144                             success = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5145                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5146                     } catch (IOException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5147                         e.printStackTrace();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5148                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5149                     return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5150                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5151             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5152         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5153     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5154 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5155 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5156 interface LauncherTransitionable {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5157     View getContent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5158     void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5159     void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5160     void onLauncherTransitionStep(Launcher l, float t);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5161     void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5162 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5163 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5164 interface DebugIntents {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5165     static final String DELETE_DATABASE = &quot;com.android.launcher3.action.DELETE_DATABASE&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5166     static final String MIGRATE_DATABASE = &quot;com.android.launcher3.action.MIGRATE_DATABASE&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5167 }</span>
5168 =======
5169 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
5170     protected String getFirstRunClingSearchBarHint() {
5171         return &quot;&quot;;
5172     }
5173     protected String getFirstRunCustomContentHint() {
5174         return &quot;&quot;;
5175     }
5176     protected int getFirstRunFocusedHotseatAppDrawableId() {
5177         return -1;
5178     }
5179     protected ComponentName getFirstRunFocusedHotseatAppComponentName() {
5180         return null;
5181     }
5182     protected int getFirstRunFocusedHotseatAppRank() {
5183         return -1;
5184     }
5185     protected String getFirstRunFocusedHotseatAppBubbleTitle() {
5186         return &quot;&quot;;
5187     }
5188     protected String getFirstRunFocusedHotseatAppBubbleDescription() {
5189         return &quot;&quot;;
5190     }
5191 
5192     /**
5193      * To be overridden by subclasses to indicate that there is an activity to launch
5194      * before showing the standard launcher experience.
5195      */
5196     protected boolean hasFirstRunActivity() {
5197         return false;
5198     }
5199 
5200     /**
5201      * To be overridden by subclasses to launch any first run activity
5202      */
5203     protected Intent getFirstRunActivity() {
5204         return null;
5205     }
5206 
5207     private boolean shouldRunFirstRunActivity() {
5208         return !ActivityManager.isRunningInTestHarness() &amp;&amp;
5209                 !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);
5210     }
5211 
5212     protected boolean hasRunFirstRunActivity() {
5213         return mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);
5214     }
5215 
5216     public boolean showFirstRunActivity() {
5217         if (shouldRunFirstRunActivity() &amp;&amp;
5218                 hasFirstRunActivity()) {
5219             Intent firstRunIntent = getFirstRunActivity();
5220             if (firstRunIntent != null) {
5221                 startActivity(firstRunIntent);
5222                 markFirstRunActivityShown();
5223                 return true;
5224             }
5225         }
5226         return false;
5227     }
5228 
5229     private void markFirstRunActivityShown() {
5230         SharedPreferences.Editor editor = mSharedPrefs.edit();
5231         editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);
5232         editor.apply();
5233     }
5234 
5235     /**
5236      * To be overridden by subclasses to indicate that there is an in-activity full-screen intro
5237      * screen that must be displayed and dismissed.
5238      */
5239     protected boolean hasDismissableIntroScreen() {
5240         return false;
5241     }
5242 
5243     /**
5244      * Full screen intro screen to be shown and dismissed before the launcher can be used.
5245      */
5246     protected View getIntroScreen() {
5247         return null;
5248     }
5249 
5250     /**
5251      * To be overriden by subclasses to indicate whether the in-activity intro screen has been
5252      * dismissed. This method is ignored if #hasDismissableIntroScreen returns false.
5253      */
5254     private boolean shouldShowIntroScreen() {
5255         return hasDismissableIntroScreen() &amp;&amp;
5256                 !mSharedPrefs.getBoolean(INTRO_SCREEN_DISMISSED, false);
5257     }
5258 
5259     protected void showIntroScreen() {
5260         View introScreen = getIntroScreen();
5261         changeWallpaperVisiblity(false);
5262         if (introScreen != null) {
5263             mDragLayer.showOverlayView(introScreen);
5264         }
5265     }
5266 
5267     public void dismissIntroScreen() {
5268         markIntroScreenDismissed();
5269         if (showFirstRunActivity()) {
5270             // We delay hiding the intro view until the first run activity is showing. This
5271             // avoids a blip.
5272             mWorkspace.postDelayed(new Runnable() {
5273                 @Override
5274                 public void run() {
5275                     mDragLayer.dismissOverlayView();
5276                     showFirstRunClings();
5277                 }
5278             }, ACTIVITY_START_DELAY);
5279         } else {
5280             mDragLayer.dismissOverlayView();
5281             showFirstRunClings();
5282         }
5283         changeWallpaperVisiblity(true);
5284     }
5285 
5286     private void markIntroScreenDismissed() {
5287         SharedPreferences.Editor editor = mSharedPrefs.edit();
5288         editor.putBoolean(INTRO_SCREEN_DISMISSED, true);
5289         editor.apply();
5290     }
5291 
5292     private void showFirstRunClings() {
5293         // The two first run cling paths are mutually exclusive, if the launcher is preinstalled
5294         // on the device, then we always show the first run cling experience (or if there is no
5295         // launcher2). Otherwise, we prompt the user upon started for migration
5296         LauncherClings launcherClings = new LauncherClings(this);
5297         if (launcherClings.shouldShowFirstRunOrMigrationClings()) {
5298             if (mModel.canMigrateFromOldLauncherDb(this)) {
5299                 launcherClings.showMigrationCling();
5300             } else {
5301                 launcherClings.showLongPressCling(true);
5302             }
5303         }
5304     }
5305 
5306     void showWorkspaceSearchAndHotseat() {
5307         if (mWorkspace != null) mWorkspace.setAlpha(1f);
5308         if (mHotseat != null) mHotseat.setAlpha(1f);
5309         if (mPageIndicators != null) mPageIndicators.setAlpha(1f);
5310         if (mSearchDropTargetBar != null) mSearchDropTargetBar.showSearchBar(false);
5311     }
5312 
5313     void hideWorkspaceSearchAndHotseat() {
5314         if (mWorkspace != null) mWorkspace.setAlpha(0f);
5315         if (mHotseat != null) mHotseat.setAlpha(0f);
5316         if (mPageIndicators != null) mPageIndicators.setAlpha(0f);
5317         if (mSearchDropTargetBar != null) mSearchDropTargetBar.hideSearchBar(false);
5318     }
5319 
5320     public ItemInfo createAppDragInfo(Intent appLaunchIntent) {
5321         // Called from search suggestion, not supported in other profiles.
5322         final UserHandleCompat myUser = UserHandleCompat.myUserHandle();
5323         LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
5324         LauncherActivityInfoCompat activityInfo = launcherApps.resolveActivity(appLaunchIntent,
5325                 myUser);
5326         if (activityInfo == null) {
5327             return null;
5328         }
5329         return new AppInfo(this, activityInfo, myUser, mIconCache, null);
5330     }
5331 
5332     public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
5333             Bitmap icon) {
5334         // Called from search suggestion, not supported in other profiles.
5335         return createShortcutDragInfo(shortcutIntent, caption, icon,
5336                 UserHandleCompat.myUserHandle());
5337     }
5338 
5339     public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
5340             Bitmap icon, UserHandleCompat user) {
5341         UserManagerCompat userManager = UserManagerCompat.getInstance(this);
5342         CharSequence contentDescription = userManager.getBadgedLabelForUser(caption, user);
5343         return new ShortcutInfo(shortcutIntent, caption, contentDescription, icon, user);
5344     }
5345 
5346     protected void moveWorkspaceToDefaultScreen() {
5347         mWorkspace.moveToDefaultScreen(false);
5348     }
5349 
5350     public void startDrag(View dragView, ItemInfo dragInfo, DragSource source) {
5351         dragView.setTag(dragInfo);
5352         mWorkspace.onExternalDragStartedWithItem(dragView);
5353         mWorkspace.beginExternalDragShared(dragView, source);
5354     }
5355 
5356     @Override
5357     public void onPageSwitch(View newPage, int newPageIndex) {
5358     }
5359 
5360     /**
5361      * Prints out out state for debugging.
5362      */
5363     public void dumpState() {
5364         Log.d(TAG, &quot;BEGIN launcher3 dump state for launcher &quot; + this);
5365         Log.d(TAG, &quot;mSavedState=&quot; + mSavedState);
5366         Log.d(TAG, &quot;mWorkspaceLoading=&quot; + mWorkspaceLoading);
5367         Log.d(TAG, &quot;mRestoring=&quot; + mRestoring);
5368         Log.d(TAG, &quot;mWaitingForResult=&quot; + mWaitingForResult);
5369         Log.d(TAG, &quot;mSavedInstanceState=&quot; + mSavedInstanceState);
5370         Log.d(TAG, &quot;sFolders.size=&quot; + sFolders.size());
5371         mModel.dumpState();
5372 
5373         if (mAppsCustomizeContent != null) {
5374             mAppsCustomizeContent.dumpState();
5375         }
5376         Log.d(TAG, &quot;END launcher3 dump state&quot;);
5377     }
5378 
5379     @Override
5380     public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
5381         super.dump(prefix, fd, writer, args);
5382         synchronized (sDumpLogs) {
5383             writer.println(&quot; &quot;);
5384             writer.println(&quot;Debug logs: &quot;);
5385             for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5386                 writer.println(&quot;  &quot; + sDumpLogs.get(i));
5387             }
5388         }
5389     }
5390 
5391     public static void dumpDebugLogsToConsole() {
5392         if (DEBUG_DUMP_LOG) {
5393             synchronized (sDumpLogs) {
5394                 Log.d(TAG, &quot;&quot;);
5395                 Log.d(TAG, &quot;*********************&quot;);
5396                 Log.d(TAG, &quot;Launcher debug logs: &quot;);
5397                 for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5398                     Log.d(TAG, &quot;  &quot; + sDumpLogs.get(i));
5399                 }
5400                 Log.d(TAG, &quot;*********************&quot;);
5401                 Log.d(TAG, &quot;&quot;);
5402             }
5403         }
5404     }
5405 
5406     public static void addDumpLog(String tag, String log, boolean debugLog) {
5407         addDumpLog(tag, log, null, debugLog);
5408     }
5409 
5410     public static void addDumpLog(String tag, String log, Exception e, boolean debugLog) {
5411         if (debugLog) {
5412             if (e != null) {
5413                 Log.d(tag, log, e);
5414             } else {
5415                 Log.d(tag, log);
5416             }
5417         }
5418         if (DEBUG_DUMP_LOG) {
5419             sDateStamp.setTime(System.currentTimeMillis());
5420             synchronized (sDumpLogs) {
5421                 sDumpLogs.add(sDateFormat.format(sDateStamp) + &quot;: &quot; + tag + &quot;, &quot; + log
5422                     + (e == null ? &quot;&quot; : (&quot;, Exception: &quot; + e)));
5423             }
5424         }
5425     }
5426 
5427     public void dumpLogsToLocalData() {
5428         if (DEBUG_DUMP_LOG) {
5429             new AsyncTask&lt;Void, Void, Void&gt;() {
5430                 public Void doInBackground(Void ... args) {
5431                     boolean success = false;
5432                     sDateStamp.setTime(sRunStart);
5433                     String FILENAME = sDateStamp.getMonth() + &quot;-&quot;
5434                             + sDateStamp.getDay() + &quot;_&quot;
5435                             + sDateStamp.getHours() + &quot;-&quot;
5436                             + sDateStamp.getMinutes() + &quot;_&quot;
5437                             + sDateStamp.getSeconds() + &quot;.txt&quot;;
5438 
5439                     FileOutputStream fos = null;
5440                     File outFile = null;
5441                     try {
5442                         outFile = new File(getFilesDir(), FILENAME);
5443                         outFile.createNewFile();
5444                         fos = new FileOutputStream(outFile);
5445                     } catch (Exception e) {
5446                         e.printStackTrace();
5447                     }
5448                     if (fos != null) {
5449                         PrintWriter writer = new PrintWriter(fos);
5450 
5451                         writer.println(&quot; &quot;);
5452                         writer.println(&quot;Debug logs: &quot;);
5453                         synchronized (sDumpLogs) {
5454                             for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5455                                 writer.println(&quot;  &quot; + sDumpLogs.get(i));
5456                             }
5457                         }
5458                         writer.close();
5459                     }
5460                     try {
5461                         if (fos != null) {
5462                             fos.close();
5463                             success = true;
5464                         }
5465                     } catch (IOException e) {
5466                         e.printStackTrace();
5467                     }
5468                     return null;
5469                 }
5470             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
5471         }
5472     }
5473 }
5474 
5475 interface LauncherTransitionable {
5476     View getContent();
5477     void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace);
5478     void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace);
5479     void onLauncherTransitionStep(Launcher l, float t);
5480     void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace);
5481 }
5482 
5483 interface DebugIntents {
5484     static final String DELETE_DATABASE = &quot;com.android.launcher3.action.DELETE_DATABASE&quot;;
5485     static final String MIGRATE_DATABASE = &quot;com.android.launcher3.action.MIGRATE_DATABASE&quot;;
5486 }</pre></td>
                            <td><pre>   1 
   2 /*
   3  * Copyright (C) 2008 The Android Open Source Project
   4  *
   5  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   6  * you may not use this file except in compliance with the License.
   7  * You may obtain a copy of the License at
   8  *
   9  *      http://www.apache.org/licenses/LICENSE-2.0
  10  *
  11  * Unless required by applicable law or agreed to in writing, software
  12  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  13  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  14  * See the License for the specific language governing permissions and
  15  * limitations under the License.
  16  */
  17 
  18 package com.android.launcher3;
  19 
  20 import android.animation.Animator;
  21 import android.animation.AnimatorListenerAdapter;
  22 import android.animation.AnimatorSet;
  23 import android.animation.ObjectAnimator;
  24 import android.animation.PropertyValuesHolder;
  25 import android.animation.TimeInterpolator;
  26 import android.animation.ValueAnimator;
  27 import android.annotation.TargetApi;
  28 import android.app.Activity;
  29 import android.app.ActivityManager;
  30 import android.app.ActivityOptions;
  31 import android.app.AlertDialog;
  32 import android.app.SearchManager;
  33 import android.appwidget.AppWidgetHostView;
  34 import android.appwidget.AppWidgetManager;
  35 import android.appwidget.AppWidgetProviderInfo;
  36 import android.content.ActivityNotFoundException;
  37 import android.content.BroadcastReceiver;
  38 import android.content.ComponentCallbacks2;
  39 import android.content.ComponentName;
  40 import android.content.ContentResolver;
  41 import android.content.Context;
  42 import android.content.DialogInterface;
  43 import android.content.Intent;
  44 import android.content.IntentFilter;
  45 import android.content.SharedPreferences;
  46 import android.content.pm.ActivityInfo;
  47 import android.content.pm.ApplicationInfo;
  48 import android.content.pm.PackageManager;
  49 import android.content.pm.PackageManager.NameNotFoundException;
  50 import android.content.res.Configuration;
  51 import android.content.res.Resources;
  52 import android.database.ContentObserver;
  53 import android.graphics.Bitmap;
  54 import android.graphics.Canvas;
  55 import android.graphics.Color;
  56 import android.graphics.Point;
  57 import android.graphics.PorterDuff;
  58 import android.graphics.Rect;
  59 import android.graphics.drawable.Drawable;
  60 import android.net.Uri;
  61 import android.os.AsyncTask;
  62 import android.os.Build;
  63 import android.os.Bundle;
  64 import android.os.Environment;
  65 import android.os.Handler;
  66 import android.os.Message;
  67 import android.os.StrictMode;
  68 import android.os.SystemClock;
  69 import android.speech.RecognizerIntent;
  70 import android.text.Selection;
  71 import android.text.SpannableStringBuilder;
  72 import android.text.TextUtils;
  73 import android.text.method.TextKeyListener;
  74 import android.util.DisplayMetrics;
  75 import android.util.Log;
  76 import android.view.ContextThemeWrapper;
  77 import android.view.Display;
  78 import android.view.Gravity;
  79 import android.view.HapticFeedbackConstants;
  80 import android.view.KeyEvent;
  81 import android.view.LayoutInflater;
  82 import android.view.Menu;
  83 import android.view.MotionEvent;
  84 import android.view.Surface;
  85 import android.view.View;
  86 import android.view.View.OnClickListener;
  87 import android.view.View.OnLongClickListener;
  88 import android.view.ViewAnimationUtils;
  89 import android.view.ViewGroup;
  90 import android.view.ViewTreeObserver;
  91 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
  92 import android.view.Window;
  93 import android.view.WindowManager;
  94 import android.view.accessibility.AccessibilityEvent;
  95 import android.view.animation.AccelerateInterpolator;
  96 import android.view.animation.DecelerateInterpolator;
  97 import android.view.animation.Interpolator;
  98 import android.view.inputmethod.InputMethodManager;
  99 import android.widget.Advanceable;
 100 import android.widget.FrameLayout;
 101 import android.widget.ImageView;
 102 import android.widget.TextView;
 103 import android.widget.Toast;
 104 
 105 import com.android.launcher3.DropTarget.DragObject;
 106 import com.android.launcher3.PagedView.PageSwitchListener;
 107 import com.android.launcher3.compat.AppWidgetManagerCompat;
 108 import com.android.launcher3.compat.LauncherActivityInfoCompat;
 109 import com.android.launcher3.compat.LauncherAppsCompat;
 110 import com.android.launcher3.compat.PackageInstallerCompat;
 111 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
 112 import com.android.launcher3.compat.UserHandleCompat;
 113 import com.android.launcher3.compat.UserManagerCompat;
 114 
 115 import java.io.DataInputStream;
 116 import java.io.DataOutputStream;
 117 import java.io.File;
 118 import java.io.FileDescriptor;
 119 import java.io.FileNotFoundException;
 120 import java.io.FileOutputStream;
 121 import java.io.IOException;
 122 import java.io.PrintWriter;
 123 import java.lang.reflect.Field;
 124 import java.lang.reflect.InvocationTargetException;
 125 import java.lang.reflect.Method;
 126 import java.text.DateFormat;
 127 import java.util.ArrayList;
 128 import java.util.Collection;
 129 import java.util.Date;
 130 import java.util.HashMap;
 131 import java.util.List;
 132 import java.util.concurrent.atomic.AtomicInteger;
 133 
 134 
 135 /**
 136  * Default launcher application.
 137  */
 138 public class Launcher extends Activity
 139         implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,
 140                    View.OnTouchListener, PageSwitchListener, LauncherProviderChangeListener {
 141     static final String TAG = &quot;Launcher&quot;;
 142     static final boolean LOGD = false;
 143 
 144     static final boolean PROFILE_STARTUP = false;
 145     static final boolean DEBUG_WIDGETS = false;
 146     static final boolean DEBUG_STRICT_MODE = false;
 147     static final boolean DEBUG_RESUME_TIME = false;
 148     static final boolean DEBUG_DUMP_LOG = false;
 149 
 150     static final boolean ENABLE_DEBUG_INTENTS = false; // allow DebugIntents to run
 151 
 152     private static final int REQUEST_CREATE_SHORTCUT = 1;
 153     private static final int REQUEST_CREATE_APPWIDGET = 5;
 154     private static final int REQUEST_PICK_SHORTCUT = 7;
 155     private static final int REQUEST_PICK_APPWIDGET = 9;
 156     private static final int REQUEST_PICK_WALLPAPER = 10;
 157 
 158     private static final int REQUEST_BIND_APPWIDGET = 11;
 159     private static final int REQUEST_RECONFIGURE_APPWIDGET = 12;
 160 
 161     /**
 162      * IntentStarter uses request codes starting with this. This must be greater than all activity
 163      * request codes used internally.
 164      */
 165     protected static final int REQUEST_LAST = 100;
 166 
 167     static final String EXTRA_SHORTCUT_DUPLICATE = &quot;duplicate&quot;;
 168 
 169     static final int SCREEN_COUNT = 5;
 170     static final int DEFAULT_SCREEN = 2;
 171 
 172     private static final String PREFERENCES = &quot;launcher.preferences&quot;;
 173     // To turn on these properties, type
 174     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
 175     static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
 176     static final String DUMP_STATE_PROPERTY = &quot;launcher_dump_state&quot;;
 177     static final String DISABLE_ALL_APPS_PROPERTY = &quot;launcher_noallapps&quot;;
 178 
 179     // The Intent extra that defines whether to ignore the launch animation
 180     static final String INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION =
 181             &quot;com.android.launcher3.intent.extra.shortcut.INGORE_LAUNCH_ANIMATION&quot;;
 182 
 183     // Type: int
 184     private static final String RUNTIME_STATE_CURRENT_SCREEN = &quot;launcher.current_screen&quot;;
 185     // Type: int
 186     private static final String RUNTIME_STATE = &quot;launcher.state&quot;;
 187     // Type: int
 188     private static final String RUNTIME_STATE_PENDING_ADD_CONTAINER = &quot;launcher.add_container&quot;;
 189     // Type: int
 190     private static final String RUNTIME_STATE_PENDING_ADD_SCREEN = &quot;launcher.add_screen&quot;;
 191     // Type: int
 192     private static final String RUNTIME_STATE_PENDING_ADD_CELL_X = &quot;launcher.add_cell_x&quot;;
 193     // Type: int
 194     private static final String RUNTIME_STATE_PENDING_ADD_CELL_Y = &quot;launcher.add_cell_y&quot;;
 195     // Type: boolean
 196     private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME = &quot;launcher.rename_folder&quot;;
 197     // Type: long
 198     private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME_ID = &quot;launcher.rename_folder_id&quot;;
 199     // Type: int
 200     private static final String RUNTIME_STATE_PENDING_ADD_SPAN_X = &quot;launcher.add_span_x&quot;;
 201     // Type: int
 202     private static final String RUNTIME_STATE_PENDING_ADD_SPAN_Y = &quot;launcher.add_span_y&quot;;
 203     // Type: parcelable
 204     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_INFO = &quot;launcher.add_widget_info&quot;;
 205     // Type: parcelable
 206     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_ID = &quot;launcher.add_widget_id&quot;;
 207     // Type: int[]
 208     private static final String RUNTIME_STATE_VIEW_IDS = &quot;launcher.view_ids&quot;;
 209 
 210     static final String INTRO_SCREEN_DISMISSED = &quot;launcher.intro_screen_dismissed&quot;;
 211     static final String FIRST_RUN_ACTIVITY_DISPLAYED = &quot;launcher.first_run_activity_displayed&quot;;
 212 
 213     static final String FIRST_LOAD_COMPLETE = &quot;launcher.first_load_complete&quot;;
 214     static final String ACTION_FIRST_LOAD_COMPLETE =
 215             &quot;com.android.launcher3.action.FIRST_LOAD_COMPLETE&quot;;
 216 
 217     private static final String TOOLBAR_ICON_METADATA_NAME = &quot;com.android.launcher.toolbar_icon&quot;;
 218     private static final String TOOLBAR_SEARCH_ICON_METADATA_NAME =
 219             &quot;com.android.launcher.toolbar_search_icon&quot;;
 220     private static final String TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME =
 221             &quot;com.android.launcher.toolbar_voice_search_icon&quot;;
 222 
 223     public static final String SHOW_WEIGHT_WATCHER = &quot;debug.show_mem&quot;;
 224     public static final boolean SHOW_WEIGHT_WATCHER_DEFAULT = false;
 225 
 226     public static final String USER_HAS_MIGRATED = &quot;launcher.user_migrated_from_old_data&quot;;
 227 
 228     /** The different states that Launcher can be in. */
 229     private enum State { NONE, WORKSPACE, APPS_CUSTOMIZE, APPS_CUSTOMIZE_SPRING_LOADED };;
 230     private State mState = State.WORKSPACE;
 231     private AnimatorSet mStateAnimation;
 232 
 233     private boolean mIsSafeModeEnabled;
 234 
 235     static final int APPWIDGET_HOST_ID = 1024;
 236     public static final int EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT = 300;
 237     private static final int ON_ACTIVITY_RESULT_ANIMATION_DELAY = 500;
 238     private static final int ACTIVITY_START_DELAY = 1000;
 239 
 240     private static final Object sLock = new Object();
 241     private static int sScreen = DEFAULT_SCREEN;
 242 
 243     private HashMap&lt;Integer, Integer&gt; mItemIdToViewId = new HashMap&lt;Integer, Integer&gt;();
 244     private static final AtomicInteger sNextGeneratedId = new AtomicInteger(1);
 245 
 246     // How long to wait before the new-shortcut animation automatically pans the workspace
 247     private static int NEW_APPS_PAGE_MOVE_DELAY = 500;
 248     private static int NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS = 5;
 249     private static int NEW_APPS_ANIMATION_DELAY = 500;
 250     private static final int SINGLE_FRAME_DELAY = 16;
 251 
 252     private final BroadcastReceiver mCloseSystemDialogsReceiver
 253             = new CloseSystemDialogsIntentReceiver();
 254     private final ContentObserver mWidgetObserver = new AppWidgetResetObserver();
 255 
 256     private LayoutInflater mInflater;
 257 
 258     private Workspace mWorkspace;
 259     private View mLauncherView;
 260     private View mPageIndicators;
 261     private DragLayer mDragLayer;
 262     private DragController mDragController;
 263     private View mWeightWatcher;
 264     private LauncherClings mLauncherClings;
 265 
 266     private AppWidgetManagerCompat mAppWidgetManager;
 267     private LauncherAppWidgetHost mAppWidgetHost;
 268 
 269     private ItemInfo mPendingAddInfo = new ItemInfo();
 270     private AppWidgetProviderInfo mPendingAddWidgetInfo;
 271     private int mPendingAddWidgetId = -1;
 272 
 273     private int[] mTmpAddItemCellCoordinates = new int[2];
 274 
 275     private FolderInfo mFolderInfo;
 276 
 277     private Hotseat mHotseat;
 278     private ViewGroup mOverviewPanel;
 279 
 280     private View mAllAppsButton;
 281 
 282     private SearchDropTargetBar mSearchDropTargetBar;
 283     private AppsCustomizeTabHost mAppsCustomizeTabHost;
 284     private AppsCustomizePagedView mAppsCustomizeContent;
 285     private boolean mAutoAdvanceRunning = false;
 286     private View mQsb;
 287 
 288     private Bundle mSavedState;
 289     // We set the state in both onCreate and then onNewIntent in some cases, which causes both
 290     // scroll issues (because the workspace may not have been measured yet) and extra work.
 291     // Instead, just save the state that we need to restore Launcher to, and commit it in onResume.
 292     private State mOnResumeState = State.NONE;
 293 
 294     private SpannableStringBuilder mDefaultKeySsb = null;
 295 
 296     private boolean mWorkspaceLoading = true;
 297 
 298     private boolean mPaused = true;
 299     private boolean mRestoring;
 300     private boolean mWaitingForResult;
 301     private boolean mOnResumeNeedsLoad;
 302 
 303     private ArrayList&lt;Runnable&gt; mBindOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 304     private ArrayList&lt;Runnable&gt; mOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 305 
 306     private Bundle mSavedInstanceState;
 307 
 308     private LauncherModel mModel;
 309     private IconCache mIconCache;
 310     private boolean mUserPresent = true;
 311     private boolean mVisible = false;
 312     private boolean mHasFocus = false;
 313     private boolean mAttached = false;
 314 
 315     private static LocaleConfiguration sLocaleConfiguration = null;
 316 
 317     private static HashMap&lt;Long, FolderInfo&gt; sFolders = new HashMap&lt;Long, FolderInfo&gt;();
 318 
 319     private View.OnTouchListener mHapticFeedbackTouchListener;
 320 
 321     // Related to the auto-advancing of widgets
 322     private final int ADVANCE_MSG = 1;
 323     private final int mAdvanceInterval = 20000;
 324     private final int mAdvanceStagger = 250;
 325     private long mAutoAdvanceSentTime;
 326     private long mAutoAdvanceTimeLeft = -1;
 327     private HashMap&lt;View, AppWidgetProviderInfo&gt; mWidgetsToAdvance =
 328         new HashMap&lt;View, AppWidgetProviderInfo&gt;();
 329 
 330     // Determines how long to wait after a rotation before restoring the screen orientation to
 331     // match the sensor state.
 332     private final int mRestoreScreenOrientationDelay = 500;
 333 
 334     // External icons saved in case of resource changes, orientation, etc.
 335     private static Drawable.ConstantState[] sGlobalSearchIcon = new Drawable.ConstantState[2];
 336     private static Drawable.ConstantState[] sVoiceSearchIcon = new Drawable.ConstantState[2];
 337 
 338     private Drawable mWorkspaceBackgroundDrawable;
 339 
 340     private final ArrayList&lt;Integer&gt; mSynchronouslyBoundPages = new ArrayList&lt;Integer&gt;();
 341     private static final boolean DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE = false;
 342 
 343     static final ArrayList&lt;String&gt; sDumpLogs = new ArrayList&lt;String&gt;();
 344     static Date sDateStamp = new Date();
 345     static DateFormat sDateFormat =
 346             DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
 347     static long sRunStart = System.currentTimeMillis();
 348     static final String CORRUPTION_EMAIL_SENT_KEY = &quot;corruptionEmailSent&quot;;
 349 
 350     // We only want to get the SharedPreferences once since it does an FS stat each time we get
 351     // it from the context.
 352     private SharedPreferences mSharedPrefs;
 353 
 354     private static ArrayList&lt;ComponentName&gt; mIntentsOnWorkspaceFromUpgradePath = null;
 355 
 356     // Holds the page that we need to animate to, and the icon views that we need to animate up
 357     // when we scroll to that page on resume.
 358     private ImageView mFolderIconImageView;
 359     private Bitmap mFolderIconBitmap;
 360     private Canvas mFolderIconCanvas;
 361     private Rect mRectForFolderAnimation = new Rect();
 362 
 363     private BubbleTextView mWaitingForResume;
 364 
 365     private Runnable mBuildLayersRunnable = new Runnable() {
 366         public void run() {
 367             if (mWorkspace != null) {
 368                 mWorkspace.buildPageHardwareLayers();
 369             }
 370         }
 371     };
 372 
 373     private static PendingAddArguments sPendingAddItem;
 374 
 375     public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
 376 
 377     private static class PendingAddArguments {
 378         int requestCode;
 379         Intent intent;
 380         long container;
 381         long screenId;
 382         int cellX;
 383         int cellY;
 384         int appWidgetId;
 385     }
 386 
 387     private Stats mStats;
 388 
 389     FocusIndicatorView mFocusHandler;
 390 
 391     static boolean isPropertyEnabled(String propertyName) {
 392         return Log.isLoggable(propertyName, Log.VERBOSE);
 393     }
 394 
 395     @Override
 396     protected void onCreate(Bundle savedInstanceState) {
 397         if (DEBUG_STRICT_MODE) {
 398             StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
 399                     .detectDiskReads()
 400                     .detectDiskWrites()
 401                     .detectNetwork()   // or .detectAll() for all detectable problems
 402                     .penaltyLog()
 403                     .build());
 404             StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
 405                     .detectLeakedSqlLiteObjects()
 406                     .detectLeakedClosableObjects()
 407                     .penaltyLog()
 408                     .penaltyDeath()
 409                     .build());
 410         }
 411 
 412         super.onCreate(savedInstanceState);
 413 
 414         LauncherAppState.setApplicationContext(getApplicationContext());
 415         LauncherAppState app = LauncherAppState.getInstance();
 416         LauncherAppState.getLauncherProvider().setLauncherProviderChangeListener(this);
 417         // Determine the dynamic grid properties
 418         Point smallestSize = new Point();
 419         Point largestSize = new Point();
 420         Point realSize = new Point();
 421         Display display = getWindowManager().getDefaultDisplay();
 422         display.getCurrentSizeRange(smallestSize, largestSize);
 423         display.getRealSize(realSize);
 424         DisplayMetrics dm = new DisplayMetrics();
 425         display.getMetrics(dm);
 426 
 427         // Lazy-initialize the dynamic grid
 428         DeviceProfile grid = app.initDynamicGrid(this,
 429                 Math.min(smallestSize.x, smallestSize.y),
 430                 Math.min(largestSize.x, largestSize.y),
 431                 realSize.x, realSize.y,
 432                 dm.widthPixels, dm.heightPixels);
 433 
<abbr title=" 434         // the LauncherApplication should call this, but in case of Instrumentation it might not be present yet"> 434         // the LauncherApplication should call this, but in case of Instrumentation it might not be prese🔵</abbr>
 435         mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(),
 436                 Context.MODE_PRIVATE);
 437         mIsSafeModeEnabled = getPackageManager().isSafeMode();
 438         mModel = app.setLauncher(this);
 439         mIconCache = app.getIconCache();
 440         mIconCache.flushInvalidIcons(grid);
 441         mDragController = new DragController(this);
 442         mLauncherClings = new LauncherClings(this);
 443         mInflater = getLayoutInflater();
 444 
 445         mStats = new Stats(this);
 446 
 447         mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
 448 
 449         mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
 450         mAppWidgetHost.startListening();
 451 
 452         // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
 453         // this also ensures that any synchronous binding below doesn&#x27;t re-trigger another
 454         // LauncherModel load.
 455         mPaused = false;
 456 
 457         if (PROFILE_STARTUP) {
 458             android.os.Debug.startMethodTracing(
 459                     Environment.getExternalStorageDirectory() + &quot;/launcher&quot;);
 460         }
 461 
 462         checkForLocaleChange();
 463         setContentView(R.layout.launcher);
 464 
 465         setupViews();
 466         grid.layout(this);
 467 
 468         registerContentObservers();
 469 
 470         lockAllApps();
 471 
 472         mSavedState = savedInstanceState;
 473         restoreState(mSavedState);
 474 
 475         if (PROFILE_STARTUP) {
 476             android.os.Debug.stopMethodTracing();
 477         }
 478 
 479         if (!mRestoring) {
 480             if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
 481                 // If the user leaves launcher, then we should just load items asynchronously when
 482                 // they return.
 483                 mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
 484             } else {
 485                 // We only load the page synchronously if the user rotates (or triggers a
 486                 // configuration change) while launcher is in the foreground
 487                 mModel.startLoader(true, mWorkspace.getRestorePage());
 488             }
 489         }
 490 
 491         // For handling default keys
 492         mDefaultKeySsb = new SpannableStringBuilder();
 493         Selection.setSelection(mDefaultKeySsb, 0);
 494 
 495         IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
 496         registerReceiver(mCloseSystemDialogsReceiver, filter);
 497 
 498         updateGlobalIcons();
 499 
 500         // On large interfaces, we want the screen to auto-rotate based on the current orientation
 501         unlockScreenOrientation(true);
 502 
 503 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 504         if (shouldShowIntroScreen()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 505             showIntroScreen();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 506         } else {</span>
 507 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 508         showFirstRunActivity();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 509         showFirstRunCling();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 510     }</span>
 511 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 512         // The two first run cling paths are mutually exclusive, if the launcher is preinstalled</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 513         // on the device, then we always show the first run cling experience (or if there is no</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 514         // launcher2). Otherwise, we prompt the user upon started for migration</span>
 515 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 516         showFirstRunActivity();
 517 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 518             showFirstRunClings();</span>
 519 ||||||| BASE
 520 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 521         if (mLauncherClings.shouldShowFirstRunOrMigrationClings()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 522             if (mModel.canMigrateFromOldLauncherDb(this)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 523                 mLauncherClings.showMigrationCling();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 524             } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 525                 mLauncherClings.showFirstRunCling();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 526             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 527         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 528             mLauncherClings.removeFirstRunAndMigrationClings();</span>
 529 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 530         }
 531     }
 532 
 533     @Override
 534     public void onLauncherProviderChange() { }
 535 
 536     /** To be overriden by subclasses to hint to Launcher that we have custom content */
 537     protected boolean hasCustomContentToLeft() {
 538         return false;
 539     }
 540 
 541     /**
 542      * To be overridden by subclasses to populate the custom content container and call
 543      * {@link #addToCustomContentPage}. This will only be invoked if
 544      * {@link #hasCustomContentToLeft()} is {@code true}.
 545      */
 546     protected void populateCustomContentContainer() {
 547     }
 548 
 549     /**
 550      * To be overridden by subclasses to indicate that there is an activity to launch
 551      * before showing the standard launcher experience.
 552      */
 553     protected boolean hasFirstRunActivity() {
 554         return false;
 555     }
 556 
 557     /**
 558      * To be overridden by subclasses to launch any first run activity
 559      */
 560     protected Intent getFirstRunActivity() {
 561         return null;
 562     }
 563 
 564     /**
 565      * Invoked by subclasses to signal a change to the {@link #addCustomContentToLeft} value to
 566      * ensure the custom content page is added or removed if necessary.
 567      */
 568     protected void invalidateHasCustomContentToLeft() {
 569         if (mWorkspace == null || mWorkspace.getScreenOrder().isEmpty()) {
 570             // Not bound yet, wait for bindScreens to be called.
 571             return;
 572         }
 573 
 574         if (!mWorkspace.hasCustomContent() &amp;&amp; hasCustomContentToLeft()) {
 575             // Create the custom content page and call the subclass to populate it.
 576             mWorkspace.createCustomContentContainer();
 577             populateCustomContentContainer();
 578         } else if (mWorkspace.hasCustomContent() &amp;&amp; !hasCustomContentToLeft()) {
 579             mWorkspace.removeCustomContentPage();
 580         }
 581     }
 582 
 583     private void updateGlobalIcons() {
 584         boolean searchVisible = false;
 585         boolean voiceVisible = false;
 586         // If we have a saved version of these external icons, we load them up immediately
 587         int coi = getCurrentOrientationIndexForGlobalIcons();
 588         if (sGlobalSearchIcon[coi] == null || sVoiceSearchIcon[coi] == null) {
 589             searchVisible = updateGlobalSearchIcon();
 590             voiceVisible = updateVoiceSearchIcon(searchVisible);
 591         }
 592         if (sGlobalSearchIcon[coi] != null) {
 593              updateGlobalSearchIcon(sGlobalSearchIcon[coi]);
 594              searchVisible = true;
 595         }
 596         if (sVoiceSearchIcon[coi] != null) {
 597             updateVoiceSearchIcon(sVoiceSearchIcon[coi]);
 598             voiceVisible = true;
 599         }
 600         if (mSearchDropTargetBar != null) {
 601             mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
 602         }
 603     }
 604 
 605     private void checkForLocaleChange() {
 606         if (sLocaleConfiguration == null) {
 607             new AsyncTask&lt;Void, Void, LocaleConfiguration&gt;() {
 608                 @Override
 609                 protected LocaleConfiguration doInBackground(Void... unused) {
 610                     LocaleConfiguration localeConfiguration = new LocaleConfiguration();
 611                     readConfiguration(Launcher.this, localeConfiguration);
 612                     return localeConfiguration;
 613                 }
 614 
 615                 @Override
 616                 protected void onPostExecute(LocaleConfiguration result) {
 617                     sLocaleConfiguration = result;
 618                     checkForLocaleChange();  // recursive, but now with a locale configuration
 619                 }
 620             }.execute();
 621             return;
 622         }
 623 
 624         final Configuration configuration = getResources().getConfiguration();
 625 
 626         final String previousLocale = sLocaleConfiguration.locale;
 627         final String locale = configuration.locale.toString();
 628 
 629         final int previousMcc = sLocaleConfiguration.mcc;
 630         final int mcc = configuration.mcc;
 631 
 632         final int previousMnc = sLocaleConfiguration.mnc;
 633         final int mnc = configuration.mnc;
 634 
<abbr title=" 635         boolean localeChanged = !locale.equals(previousLocale) || mcc != previousMcc || mnc != previousMnc;"> 635         boolean localeChanged = !locale.equals(previousLocale) || mcc != previousMcc || mnc != previousMn🔵</abbr>
 636 
 637         if (localeChanged) {
 638             sLocaleConfiguration.locale = locale;
 639             sLocaleConfiguration.mcc = mcc;
 640             sLocaleConfiguration.mnc = mnc;
 641 
 642             mIconCache.flush();
 643 
 644             final LocaleConfiguration localeConfiguration = sLocaleConfiguration;
 645             new AsyncTask&lt;Void, Void, Void&gt;() {
 646                 public Void doInBackground(Void ... args) {
 647                     writeConfiguration(Launcher.this, localeConfiguration);
 648                     return null;
 649                 }
 650             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 651         }
 652     }
 653 
 654     private static class LocaleConfiguration {
 655         public String locale;
 656         public int mcc = -1;
 657         public int mnc = -1;
 658     }
 659 
 660     private static void readConfiguration(Context context, LocaleConfiguration configuration) {
 661         DataInputStream in = null;
 662         try {
 663             in = new DataInputStream(context.openFileInput(PREFERENCES));
 664             configuration.locale = in.readUTF();
 665             configuration.mcc = in.readInt();
 666             configuration.mnc = in.readInt();
 667         } catch (FileNotFoundException e) {
 668             // Ignore
 669         } catch (IOException e) {
 670             // Ignore
 671         } finally {
 672             if (in != null) {
 673                 try {
 674                     in.close();
 675                 } catch (IOException e) {
 676                     // Ignore
 677                 }
 678             }
 679         }
 680     }
 681 
 682     private static void writeConfiguration(Context context, LocaleConfiguration configuration) {
 683         DataOutputStream out = null;
 684         try {
 685             out = new DataOutputStream(context.openFileOutput(PREFERENCES, MODE_PRIVATE));
 686             out.writeUTF(configuration.locale);
 687             out.writeInt(configuration.mcc);
 688             out.writeInt(configuration.mnc);
 689             out.flush();
 690         } catch (FileNotFoundException e) {
 691             // Ignore
 692         } catch (IOException e) {
 693             //noinspection ResultOfMethodCallIgnored
 694             context.getFileStreamPath(PREFERENCES).delete();
 695         } finally {
 696             if (out != null) {
 697                 try {
 698                     out.close();
 699                 } catch (IOException e) {
 700                     // Ignore
 701                 }
 702             }
 703         }
 704     }
 705 
 706     public Stats getStats() {
 707         return mStats;
 708     }
 709 
 710     public LayoutInflater getInflater() {
 711         return mInflater;
 712     }
 713 
 714     boolean isDraggingEnabled() {
 715         // We prevent dragging when we are loading the workspace as it is possible to pick up a view
 716         // that is subsequently removed from the workspace in startBinding().
 717         return !mModel.isLoadingWorkspace();
 718     }
 719 
 720     static int getScreen() {
 721         synchronized (sLock) {
 722             return sScreen;
 723         }
 724     }
 725 
 726     static void setScreen(int screen) {
 727         synchronized (sLock) {
 728             sScreen = screen;
 729         }
 730     }
 731 
 732     public static int generateViewId() {
 733         if (Build.VERSION.SDK_INT &gt;= 17) {
 734             return View.generateViewId();
 735         } else {
 736             // View.generateViewId() is not available. The following fallback logic is a copy
 737             // of its implementation.
 738         for (;;) {
 739             final int result = sNextGeneratedId.get();
 740             // aapt-generated IDs have the high byte nonzero; clamp to the range under that.
 741             int newValue = result + 1;
 742             if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.
 743             if (sNextGeneratedId.compareAndSet(result, newValue)) {
 744                 return result;
 745             }
 746         }
 747     }
 748     }
 749 
 750     public int getViewIdForItem(ItemInfo info) {
 751         // This cast is safe given the &gt; 2B range for int.
 752         int itemId = (int) info.id;
 753         if (mItemIdToViewId.containsKey(itemId)) {
 754             return mItemIdToViewId.get(itemId);
 755         }
 756         int viewId = generateViewId();
 757         mItemIdToViewId.put(itemId, viewId);
 758         return viewId;
 759     }
 760 
 761     /**
 762      * Returns whether we should delay spring loaded mode -- for shortcuts and widgets that have
 763      * a configuration step, this allows the proper animations to run after other transitions.
 764      */
 765     private long completeAdd(PendingAddArguments args) {
 766         long screenId = args.screenId;
 767         if (args.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 768             // When the screen id represents an actual screen (as opposed to a rank) we make sure
 769             // that the drop page actually exists.
 770             screenId = ensurePendingDropLayoutExists(args.screenId);
 771         }
 772 
 773         switch (args.requestCode) {
 774             case REQUEST_CREATE_SHORTCUT:
 775                 completeAddShortcut(args.intent, args.container, screenId, args.cellX,
 776                         args.cellY);
 777                 break;
 778             case REQUEST_CREATE_APPWIDGET:
 779                 completeAddAppWidget(args.appWidgetId, args.container, screenId, null, null);
 780                 break;
 781             case REQUEST_RECONFIGURE_APPWIDGET:
 782                 completeRestoreAppWidget(args.appWidgetId);
 783                 break;
 784         }
 785         // Before adding this resetAddInfo(), after a shortcut was added to a workspace screen,
 786         // if you turned the screen off and then back while in All Apps, Launcher would not
 787         // return to the workspace. Clearing mAddInfo.container here fixes this issue
 788         resetAddInfo();
 789         return screenId;
 790     }
 791 
 792     @Override
 793     protected void onActivityResult(
 794             final int requestCode, final int resultCode, final Intent data) {
 795         // Reset the startActivity waiting flag
 796         setWaitingForResult(false);
 797         final int pendingAddWidgetId = mPendingAddWidgetId;
 798         mPendingAddWidgetId = -1;
 799 
 800         Runnable exitSpringLoaded = new Runnable() {
 801             @Override
 802             public void run() {
 803                 exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 804                         EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 805             }
 806         };
 807 
 808         if (requestCode == REQUEST_BIND_APPWIDGET) {
 809             final int appWidgetId = data != null ?
 810                     data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1) : -1;
 811             if (resultCode == RESULT_CANCELED) {
 812                 completeTwoStageWidgetDrop(RESULT_CANCELED, appWidgetId);
 813                 mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 814                         ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 815             } else if (resultCode == RESULT_OK) {
 816                 addAppWidgetImpl(appWidgetId, mPendingAddInfo, null,
 817                         mPendingAddWidgetInfo, ON_ACTIVITY_RESULT_ANIMATION_DELAY);
 818             }
 819             return;
 820         } else if (requestCode == REQUEST_PICK_WALLPAPER) {
 821             if (resultCode == RESULT_OK &amp;&amp; mWorkspace.isInOverviewMode()) {
 822                 mWorkspace.exitOverviewMode(false);
 823             }
 824             return;
 825         }
 826 
 827         boolean isWidgetDrop = (requestCode == REQUEST_PICK_APPWIDGET ||
 828                 requestCode == REQUEST_CREATE_APPWIDGET);
 829 
 830         final boolean workspaceLocked = isWorkspaceLocked();
 831         // We have special handling for widgets
 832         if (isWidgetDrop) {
 833             final int appWidgetId;
 834             int widgetId = data != null ? data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
 835                     : -1;
 836             if (widgetId &lt; 0) {
 837                 appWidgetId = pendingAddWidgetId;
 838             } else {
 839                 appWidgetId = widgetId;
 840             }
 841 
 842             final int result;
 843             if (appWidgetId &lt; 0 || resultCode == RESULT_CANCELED) {
 844                 Log.e(TAG, &quot;Error: appWidgetId (EXTRA_APPWIDGET_ID) was not &quot; +
 845                         &quot;returned from the widget configuration activity.&quot;);
 846                 result = RESULT_CANCELED;
 847                 completeTwoStageWidgetDrop(result, appWidgetId);
 848                 final Runnable onComplete = new Runnable() {
 849                     @Override
 850                     public void run() {
 851                         exitSpringLoadedDragModeDelayed(false, 0, null);
 852                     }
 853                 };
 854                 if (workspaceLocked) {
 855                     // No need to remove the empty screen if we&#x27;re mid-binding, as the
 856                     // the bind will not add the empty screen.
 857                     mWorkspace.postDelayed(onComplete, ON_ACTIVITY_RESULT_ANIMATION_DELAY);
 858             } else {
 859                     mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete,
 860                             ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 861                 }
 862             } else {
 863                 if (!workspaceLocked) {
 864                     if (mPendingAddInfo.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 865                         // When the screen id represents an actual screen (as opposed to a rank)
 866                         // we make sure that the drop page actually exists.
 867                         mPendingAddInfo.screenId =
 868                                 ensurePendingDropLayoutExists(mPendingAddInfo.screenId);
 869                     }
 870                     final CellLayout dropLayout = mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
 871 
 872                 dropLayout.setDropPending(true);
 873                     final Runnable onComplete = new Runnable() {
 874                     @Override
 875                     public void run() {
 876                             completeTwoStageWidgetDrop(resultCode, appWidgetId);
 877                         dropLayout.setDropPending(false);
 878                     }
 879                 };
 880                     mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete,
 881                             ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 882                 } else {
 883                     PendingAddArguments args = preparePendingAddArgs(requestCode, data, appWidgetId,
 884                             mPendingAddInfo);
 885                     sPendingAddItem = args;
 886             }
 887             }
 888             return;
 889         }
 890 
 891         if (requestCode == REQUEST_RECONFIGURE_APPWIDGET) {
 892             if (resultCode == RESULT_OK) {
 893                 // Update the widget view.
 894                 PendingAddArguments args = preparePendingAddArgs(requestCode, data,
 895                         pendingAddWidgetId, mPendingAddInfo);
 896                 if (workspaceLocked) {
 897                     sPendingAddItem = args;
 898                 } else {
 899                     completeAdd(args);
 900                 }
 901             }
 902             // Leave the widget in the pending state if the user canceled the configure.
 903             return;
 904         }
 905 
 906         // The pattern used here is that a user PICKs a specific application,
 907         // which, depending on the target, might need to CREATE the actual target.
 908 
 909         // For example, the user would PICK_SHORTCUT for &quot;Music playlist&quot;, and we
 910         // launch over to the Music app to actually CREATE_SHORTCUT.
 911         if (resultCode == RESULT_OK &amp;&amp; mPendingAddInfo.container != ItemInfo.NO_ID) {
 912             final PendingAddArguments args = preparePendingAddArgs(requestCode, data, -1,
 913                     mPendingAddInfo);
 914             if (isWorkspaceLocked()) {
 915                 sPendingAddItem = args;
 916             } else {
 917                 completeAdd(args);
 918                 mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 919                     ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 920             }
 921         } else if (resultCode == RESULT_CANCELED) {
 922             mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 923                     ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 924         }
 925         mDragLayer.clearAnimatedView();
 926     }
 927 
 928     private PendingAddArguments preparePendingAddArgs(int requestCode, Intent data, int
 929             appWidgetId, ItemInfo info) {
 930         PendingAddArguments args = new PendingAddArguments();
 931         args.requestCode = requestCode;
 932         args.intent = data;
 933         args.container = info.container;
 934         args.screenId = info.screenId;
 935         args.cellX = info.cellX;
 936         args.cellY = info.cellY;
 937         args.appWidgetId = appWidgetId;
 938         return args;
 939     }
 940 
 941     /**
 942      * Check to see if a given screen id exists. If not, create it at the end, return the new id.
 943      *
 944      * @param screenId the screen id to check
 945      * @return the new screen, or screenId if it exists
 946      */
 947     private long ensurePendingDropLayoutExists(long screenId) {
 948         CellLayout dropLayout =
 949                 (CellLayout) mWorkspace.getScreenWithId(screenId);
 950         if (dropLayout == null) {
 951             // it&#x27;s possible that the add screen was removed because it was
 952             // empty and a re-bind occurred
 953             mWorkspace.addExtraEmptyScreen();
 954             return mWorkspace.commitExtraEmptyScreen();
 955         } else {
 956             return screenId;
 957         }
 958     }
 959 
 960     private void completeTwoStageWidgetDrop(final int resultCode, final int appWidgetId) {
 961         CellLayout cellLayout =
 962                 (CellLayout) mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
 963         Runnable onCompleteRunnable = null;
 964         int animationType = 0;
 965 
 966         AppWidgetHostView boundWidget = null;
 967         if (resultCode == RESULT_OK) {
 968             animationType = Workspace.COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION;
 969             final AppWidgetHostView layout = mAppWidgetHost.createView(this, appWidgetId,
 970                     mPendingAddWidgetInfo);
 971             boundWidget = layout;
 972             onCompleteRunnable = new Runnable() {
 973                 @Override
 974                 public void run() {
 975                     completeAddAppWidget(appWidgetId, mPendingAddInfo.container,
 976                             mPendingAddInfo.screenId, layout, null);
 977                     exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 978                             EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 979                 }
 980             };
 981         } else if (resultCode == RESULT_CANCELED) {
 982             mAppWidgetHost.deleteAppWidgetId(appWidgetId);
 983             animationType = Workspace.CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION;
 984         }
 985         if (mDragLayer.getAnimatedView() != null) {
 986             mWorkspace.animateWidgetDrop(mPendingAddInfo, cellLayout,
 987                     (DragView) mDragLayer.getAnimatedView(), onCompleteRunnable,
 988                     animationType, boundWidget, true);
 989         } else if (onCompleteRunnable != null) {
 990             // The animated view may be null in the case of a rotation during widget configuration
 991             onCompleteRunnable.run();
 992         }
 993     }
 994 
 995     @Override
 996     protected void onStop() {
 997         super.onStop();
 998         FirstFrameAnimatorHelper.setIsVisible(false);
 999     }
1000 
1001     @Override
1002     protected void onStart() {
1003         super.onStart();
1004         FirstFrameAnimatorHelper.setIsVisible(true);
1005     }
1006 
1007     @Override
1008     protected void onResume() {
1009         long startTime = 0;
1010         if (DEBUG_RESUME_TIME) {
1011             startTime = System.currentTimeMillis();
1012             Log.v(TAG, &quot;Launcher.onResume()&quot;);
1013         }
1014         super.onResume();
1015 
1016         // Restore the previous launcher state
1017         if (mOnResumeState == State.WORKSPACE) {
1018             showWorkspace(false);
1019         } else if (mOnResumeState == State.APPS_CUSTOMIZE) {
1020             showAllApps(false, mAppsCustomizeContent.getContentType(), false);
1021         }
1022         mOnResumeState = State.NONE;
1023 
1024         // Background was set to gradient in onPause(), restore to black if in all apps.
1025         setWorkspaceBackground(mState == State.WORKSPACE);
1026 
1027         mPaused = false;
1028         if (mRestoring || mOnResumeNeedsLoad) {
1029             setWorkspaceLoading(true);
1030             mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
1031             mRestoring = false;
1032             mOnResumeNeedsLoad = false;
1033         }
1034         if (mBindOnResumeCallbacks.size() &gt; 0) {
1035             // We might have postponed some bind calls until onResume (see waitUntilResume) --
1036             // execute them here
1037             long startTimeCallbacks = 0;
1038             if (DEBUG_RESUME_TIME) {
1039                 startTimeCallbacks = System.currentTimeMillis();
1040             }
1041 
1042             if (mAppsCustomizeContent != null) {
1043                 mAppsCustomizeContent.setBulkBind(true);
1044             }
1045             for (int i = 0; i &lt; mBindOnResumeCallbacks.size(); i++) {
1046                 mBindOnResumeCallbacks.get(i).run();
1047             }
1048             if (mAppsCustomizeContent != null) {
1049                 mAppsCustomizeContent.setBulkBind(false);
1050             }
1051             mBindOnResumeCallbacks.clear();
1052             if (DEBUG_RESUME_TIME) {
1053                 Log.d(TAG, &quot;Time spent processing callbacks in onResume: &quot; +
1054                     (System.currentTimeMillis() - startTimeCallbacks));
1055             }
1056         }
1057         if (mOnResumeCallbacks.size() &gt; 0) {
1058             for (int i = 0; i &lt; mOnResumeCallbacks.size(); i++) {
1059                 mOnResumeCallbacks.get(i).run();
1060             }
1061             mOnResumeCallbacks.clear();
1062         }
1063 
1064         // Reset the pressed state of icons that were locked in the press state while activities
1065         // were launching
1066         if (mWaitingForResume != null) {
1067             // Resets the previous workspace icon press state
1068             mWaitingForResume.setStayPressed(false);
1069         }
1070 
1071         // It is possible that widgets can receive updates while launcher is not in the foreground.
1072         // Consequently, the widgets will be inflated in the orientation of the foreground activity
1073         // (framework issue). On resuming, we ensure that any widgets are inflated for the current
1074         // orientation.
1075         getWorkspace().reinflateWidgetsIfNecessary();
1076 
1077         // Process any items that were added while Launcher was away.
1078         InstallShortcutReceiver.disableAndFlushInstallQueue(this);
1079 
1080         // Update the voice search button proxy
1081         updateVoiceButtonProxyVisible(false);
1082 
1083         // Again, as with the above scenario, it&#x27;s possible that one or more of the global icons
1084         // were updated in the wrong orientation.
1085         updateGlobalIcons();
1086         if (DEBUG_RESUME_TIME) {
1087             Log.d(TAG, &quot;Time spent in onResume: &quot; + (System.currentTimeMillis() - startTime));
1088         }
1089 
1090         if (mWorkspace.getCustomContentCallbacks() != null) {
1091             // If we are resuming and the custom content is the current page, we call onShow().
1092             // It is also poassible that onShow will instead be called slightly after first layout
1093             // if PagedView#setRestorePage was set to the custom content page in onCreate().
1094             if (mWorkspace.isOnOrMovingToCustomContent()) {
1095                 mWorkspace.getCustomContentCallbacks().onShow(true);
1096             }
1097         }
1098         mWorkspace.updateInteractionForState();
1099         mWorkspace.onResume();
1100 
1101         PackageInstallerCompat.getInstance(this).onResume();
1102     }
1103 
1104     @Override
1105     protected void onPause() {
1106         // Ensure that items added to Launcher are queued until Launcher returns
1107         InstallShortcutReceiver.enableInstallQueue();
1108         PackageInstallerCompat.getInstance(this).onPause();
1109 
1110         super.onPause();
1111         mPaused = true;
1112         mDragController.cancelDrag();
1113         mDragController.resetLastGestureUpTime();
1114 
1115         // We call onHide() aggressively. The custom content callbacks should be able to
1116         // debounce excess onHide calls.
1117         if (mWorkspace.getCustomContentCallbacks() != null) {
1118             mWorkspace.getCustomContentCallbacks().onHide();
1119         }
1120     }
1121 
1122     QSBScroller mQsbScroller = new QSBScroller() {
1123         int scrollY = 0;
1124 
1125         @Override
1126         public void setScrollY(int scroll) {
1127             scrollY = scroll;
1128 
1129             if (mWorkspace.isOnOrMovingToCustomContent()) {
1130                 mSearchDropTargetBar.setTranslationY(- scrollY);
1131                 getQsbBar().setTranslationY(-scrollY);
1132             }
1133         }
1134     };
1135 
1136     public void resetQSBScroll() {
1137         mSearchDropTargetBar.animate().translationY(0).start();
1138         getQsbBar().animate().translationY(0).start();
1139     }
1140 
1141     public interface CustomContentCallbacks {
1142         // Custom content is completely shown. {@code fromResume} indicates whether this was caused
1143         // by a onResume or by scrolling otherwise.
1144         public void onShow(boolean fromResume);
1145 
1146         // Custom content is completely hidden
1147         public void onHide();
1148 
1149         // Custom content scroll progress changed. From 0 (not showing) to 1 (fully showing).
1150         public void onScrollProgressChanged(float progress);
1151 
1152         // Indicates whether the user is allowed to scroll away from the custom content.
1153         boolean isScrollingAllowed();
1154     }
1155 
1156     protected boolean hasSettings() {
1157         return false;
1158     }
1159 
1160     public interface QSBScroller {
1161         public void setScrollY(int scrollY);
1162     }
1163 
1164     public QSBScroller addToCustomContentPage(View customContent,
1165             CustomContentCallbacks callbacks, String description) {
1166         mWorkspace.addToCustomContentPage(customContent, callbacks, description);
1167         return mQsbScroller;
1168     }
1169 
1170     // The custom content needs to offset its content to account for the QSB
1171     public int getTopOffsetForCustomContent() {
1172         return mWorkspace.getPaddingTop();
1173     }
1174 
1175     @Override
1176     public Object onRetainNonConfigurationInstance() {
1177         // Flag the loader to stop early before switching
1178         if (mModel.isCurrentCallbacks(this)) {
1179         mModel.stopLoader();
1180         }
1181         if (mAppsCustomizeContent != null) {
1182             mAppsCustomizeContent.surrender();
1183         }
1184         return Boolean.TRUE;
1185     }
1186 
1187     // We can&#x27;t hide the IME if it was forced open.  So don&#x27;t bother
1188     @Override
1189     public void onWindowFocusChanged(boolean hasFocus) {
1190         super.onWindowFocusChanged(hasFocus);
1191         mHasFocus = hasFocus;
1192     }
1193 
1194     private boolean acceptFilter() {
1195         final InputMethodManager inputManager = (InputMethodManager)
1196                 getSystemService(Context.INPUT_METHOD_SERVICE);
1197         return !inputManager.isFullscreenMode();
1198     }
1199 
1200     @Override
1201     public boolean onKeyDown(int keyCode, KeyEvent event) {
1202         final int uniChar = event.getUnicodeChar();
1203         final boolean handled = super.onKeyDown(keyCode, event);
1204         final boolean isKeyNotWhitespace = uniChar &gt; 0 &amp;&amp; !Character.isWhitespace(uniChar);
1205         if (!handled &amp;&amp; acceptFilter() &amp;&amp; isKeyNotWhitespace) {
1206             boolean gotKey = TextKeyListener.getInstance().onKeyDown(mWorkspace, mDefaultKeySsb,
1207                     keyCode, event);
1208             if (gotKey &amp;&amp; mDefaultKeySsb != null &amp;&amp; mDefaultKeySsb.length() &gt; 0) {
1209                 // something usable has been typed - start a search
1210                 // the typed text will be retrieved and cleared by
1211                 // showSearchDialog()
1212                 // If there are multiple keystrokes before the search dialog takes focus,
1213                 // onSearchRequested() will be called for every keystroke,
1214                 // but it is idempotent, so it&#x27;s fine.
1215                 return onSearchRequested();
1216             }
1217         }
1218 
1219         // Eat the long press event so the keyboard doesn&#x27;t come up.
1220         if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.isLongPress()) {
1221             return true;
1222         }
1223 
1224         return handled;
1225     }
1226 
1227     private String getTypedText() {
1228         return mDefaultKeySsb.toString();
1229     }
1230 
1231     private void clearTypedText() {
1232         mDefaultKeySsb.clear();
1233         mDefaultKeySsb.clearSpans();
1234         Selection.setSelection(mDefaultKeySsb, 0);
1235     }
1236 
1237     /**
1238      * Given the integer (ordinal) value of a State enum instance, convert it to a variable of type
1239      * State
1240      */
1241     private static State intToState(int stateOrdinal) {
1242         State state = State.WORKSPACE;
1243         final State[] stateValues = State.values();
1244         for (int i = 0; i &lt; stateValues.length; i++) {
1245             if (stateValues[i].ordinal() == stateOrdinal) {
1246                 state = stateValues[i];
1247                 break;
1248             }
1249         }
1250         return state;
1251     }
1252 
1253     /**
1254      * Restores the previous state, if it exists.
1255      *
1256      * @param savedState The previous state.
1257      */
1258     @SuppressWarnings(&quot;unchecked&quot;)
1259     private void restoreState(Bundle savedState) {
1260         if (savedState == null) {
1261             return;
1262         }
1263 
1264         State state = intToState(savedState.getInt(RUNTIME_STATE, State.WORKSPACE.ordinal()));
1265         if (state == State.APPS_CUSTOMIZE) {
1266             mOnResumeState = State.APPS_CUSTOMIZE;
1267         }
1268 
1269         int currentScreen = savedState.getInt(RUNTIME_STATE_CURRENT_SCREEN,
1270                 PagedView.INVALID_RESTORE_PAGE);
1271         if (currentScreen != PagedView.INVALID_RESTORE_PAGE) {
1272             mWorkspace.setRestorePage(currentScreen);
1273         }
1274 
1275         final long pendingAddContainer = savedState.getLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, -1);
1276         final long pendingAddScreen = savedState.getLong(RUNTIME_STATE_PENDING_ADD_SCREEN, -1);
1277 
1278         if (pendingAddContainer != ItemInfo.NO_ID &amp;&amp; pendingAddScreen &gt; -1) {
1279             mPendingAddInfo.container = pendingAddContainer;
1280             mPendingAddInfo.screenId = pendingAddScreen;
1281             mPendingAddInfo.cellX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_X);
1282             mPendingAddInfo.cellY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_Y);
1283             mPendingAddInfo.spanX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_X);
1284             mPendingAddInfo.spanY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y);
1285             mPendingAddWidgetInfo = savedState.getParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO);
1286             mPendingAddWidgetId = savedState.getInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID);
1287             setWaitingForResult(true);
1288             mRestoring = true;
1289         }
1290 
1291         boolean renameFolder = savedState.getBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, false);
1292         if (renameFolder) {
1293             long id = savedState.getLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID);
1294             mFolderInfo = mModel.getFolderById(this, sFolders, id);
1295             mRestoring = true;
1296         }
1297 
1298         // Restore the AppsCustomize tab
1299         if (mAppsCustomizeTabHost != null) {
1300             String curTab = savedState.getString(&quot;apps_customize_currentTab&quot;);
1301             if (curTab != null) {
1302                 mAppsCustomizeTabHost.setContentTypeImmediate(
1303                         mAppsCustomizeTabHost.getContentTypeForTabTag(curTab));
1304                 mAppsCustomizeContent.loadAssociatedPages(
1305                         mAppsCustomizeContent.getCurrentPage());
1306             }
1307 
1308             int currentIndex = savedState.getInt(&quot;apps_customize_currentIndex&quot;);
1309             mAppsCustomizeContent.restorePageForIndex(currentIndex);
1310         }
1311         mItemIdToViewId = (HashMap&lt;Integer, Integer&gt;)
1312                 savedState.getSerializable(RUNTIME_STATE_VIEW_IDS);
1313     }
1314 
1315     /**
1316      * Finds all the views we need and configure them properly.
1317      */
1318     private void setupViews() {
1319         final DragController dragController = mDragController;
1320 
1321         mLauncherView = findViewById(R.id.launcher);
1322         mFocusHandler = (FocusIndicatorView) findViewById(R.id.focus_indicator);
1323         mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
1324         mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
1325 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1326         mWorkspace.setPageSwitchListener(this);</span>
1327 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1328 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1329         mLauncherView.setSystemUiVisibility(</span>
1330 =======
1331 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1332         mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);
1333 
1334         mLauncherView.setSystemUiVisibility(
1335                 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
1336         mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
1337 
1338         // Setup the drag layer
1339         mDragLayer.setup(this, dragController);
1340 
1341         // Setup the hotseat
1342         mHotseat = (Hotseat) findViewById(R.id.hotseat);
1343         if (mHotseat != null) {
1344             mHotseat.setup(this);
1345             mHotseat.setOnLongClickListener(this);
1346         }
1347 
1348         mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
1349         View widgetButton = findViewById(R.id.widget_button);
1350         widgetButton.setOnClickListener(new OnClickListener() {
1351             @Override
1352             public void onClick(View arg0) {
1353                 if (!mWorkspace.isSwitchingState()) {
1354                     onClickAddWidgetButton(arg0);
1355                 }
1356             }
1357         });
1358         widgetButton.setOnTouchListener(getHapticFeedbackTouchListener());
1359 
1360         View wallpaperButton = findViewById(R.id.wallpaper_button);
1361         wallpaperButton.setOnClickListener(new OnClickListener() {
1362             @Override
1363             public void onClick(View arg0) {
1364                 if (!mWorkspace.isSwitchingState()) {
1365                     onClickWallpaperPicker(arg0);
1366                 }
1367             }
1368         });
1369         wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
1370 
1371         View settingsButton = findViewById(R.id.settings_button);
1372         if (hasSettings()) {
1373         settingsButton.setOnClickListener(new OnClickListener() {
1374             @Override
1375             public void onClick(View arg0) {
1376                 if (!mWorkspace.isSwitchingState()) {
1377                         onClickSettingsButton(arg0);
1378                 }
1379             }
1380         });
1381         settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
1382         } else {
1383             settingsButton.setVisibility(View.GONE);
1384             FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) widgetButton.getLayoutParams();
1385             lp.gravity = Gravity.END | Gravity.TOP;
1386             widgetButton.requestLayout();
1387         }
1388 
1389         mOverviewPanel.setAlpha(0f);
1390 
1391         // Setup the workspace
1392         mWorkspace.setHapticFeedbackEnabled(false);
1393         mWorkspace.setOnLongClickListener(this);
1394         mWorkspace.setup(dragController);
1395         dragController.addDragListener(mWorkspace);
1396 
1397         // Get the search/delete bar
1398         mSearchDropTargetBar = (SearchDropTargetBar)
1399                 mDragLayer.findViewById(R.id.search_drop_target_bar);
1400 
1401         // Setup AppsCustomize
1402         mAppsCustomizeTabHost = (AppsCustomizeTabHost) findViewById(R.id.apps_customize_pane);
1403         mAppsCustomizeContent = (AppsCustomizePagedView)
1404                 mAppsCustomizeTabHost.findViewById(R.id.apps_customize_pane_content);
1405         mAppsCustomizeContent.setup(this, dragController);
1406 
1407         // Setup the drag controller (drop targets have to be added in reverse order in priority)
1408         dragController.setDragScoller(mWorkspace);
1409         dragController.setScrollView(mDragLayer);
1410         dragController.setMoveTarget(mWorkspace);
1411         dragController.addDropTarget(mWorkspace);
1412         if (mSearchDropTargetBar != null) {
1413             mSearchDropTargetBar.setup(this, dragController);
1414         }
1415 
1416         if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
1417             Log.v(TAG, &quot;adding WeightWatcher&quot;);
1418             mWeightWatcher = new WeightWatcher(this);
1419             mWeightWatcher.setAlpha(0.5f);
1420             ((FrameLayout) mLauncherView).addView(mWeightWatcher,
1421                     new FrameLayout.LayoutParams(
1422                             FrameLayout.LayoutParams.MATCH_PARENT,
1423                             FrameLayout.LayoutParams.WRAP_CONTENT,
1424                             Gravity.BOTTOM)
1425             );
1426 
1427             boolean show = shouldShowWeightWatcher();
1428             mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
1429         }
1430     }
1431 
1432     /**
1433      * Sets the all apps button. This method is called from {@link Hotseat}.
1434      */
1435     public void setAllAppsButton(View allAppsButton) {
1436         mAllAppsButton = allAppsButton;
1437     }
1438 
1439     public View getAllAppsButton() {
1440         return mAllAppsButton;
1441     }
1442 
1443     /**
1444      * Creates a view representing a shortcut.
1445      *
1446      * @param info The data structure describing the shortcut.
1447      *
1448      * @return A View inflated from R.layout.application.
1449      */
1450     View createShortcut(ShortcutInfo info) {
1451         return createShortcut(R.layout.application,
1452                 (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
1453     }
1454 
1455     /**
1456      * Creates a view representing a shortcut inflated from the specified resource.
1457      *
1458      * @param layoutResId The id of the XML layout used to create the shortcut.
1459      * @param parent The group the shortcut belongs to.
1460      * @param info The data structure describing the shortcut.
1461      *
1462      * @return A View inflated from layoutResId.
1463      */
1464     View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) {
1465         BubbleTextView favorite = (BubbleTextView) mInflater.inflate(layoutResId, parent, false);
1466         favorite.applyFromShortcutInfo(info, mIconCache, true);
1467         favorite.setOnClickListener(this);
1468         favorite.setOnFocusChangeListener(mFocusHandler);
1469         return favorite;
1470     }
1471 
1472     /**
1473      * Add a shortcut to the workspace.
1474      *
1475      * @param data The intent describing the shortcut.
1476      * @param cellInfo The position on screen where to create the shortcut.
1477      */
1478     private void completeAddShortcut(Intent data, long container, long screenId, int cellX,
1479             int cellY) {
1480         int[] cellXY = mTmpAddItemCellCoordinates;
1481         int[] touchXY = mPendingAddInfo.dropPos;
1482         CellLayout layout = getCellLayout(container, screenId);
1483 
1484         boolean foundCellSpan = false;
1485 
1486         ShortcutInfo info = mModel.infoFromShortcutIntent(this, data, null);
1487         if (info == null) {
1488             return;
1489         }
1490         final View view = createShortcut(info);
1491 
1492         // First we check if we already know the exact location where we want to add this item.
1493         if (cellX &gt;= 0 &amp;&amp; cellY &gt;= 0) {
1494             cellXY[0] = cellX;
1495             cellXY[1] = cellY;
1496             foundCellSpan = true;
1497 
1498             // If appropriate, either create a folder or add to an existing folder
1499             if (mWorkspace.createUserFolderIfNecessary(view, container, layout, cellXY, 0,
1500                     true, null,null)) {
1501                 return;
1502             }
1503             DragObject dragObject = new DragObject();
1504             dragObject.dragInfo = info;
1505             if (mWorkspace.addToExistingFolderIfNecessary(view, layout, cellXY, 0, dragObject,
1506                     true)) {
1507                 return;
1508             }
1509         } else if (touchXY != null) {
1510             // when dragging and dropping, just find the closest free spot
1511             int[] result = layout.findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, cellXY);
1512             foundCellSpan = (result != null);
1513         } else {
1514             foundCellSpan = layout.findCellForSpan(cellXY, 1, 1);
1515         }
1516 
1517         if (!foundCellSpan) {
1518             showOutOfSpaceMessage(isHotseatLayout(layout));
1519             return;
1520         }
1521 
1522         LauncherModel.addItemToDatabase(this, info, container, screenId, cellXY[0], cellXY[1], false);
1523 
1524         if (!mRestoring) {
1525             mWorkspace.addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1,
1526                     isWorkspaceLocked());
1527         }
1528     }
1529 
1530     static int[] getSpanForWidget(Context context, ComponentName component, int minWidth,
1531             int minHeight) {
1532         Rect padding = AppWidgetHostView.getDefaultPaddingForWidget(context, component, null);
1533         // We want to account for the extra amount of padding that we are adding to the widget
1534         // to ensure that it gets the full amount of space that it has requested
1535         int requiredWidth = minWidth + padding.left + padding.right;
1536         int requiredHeight = minHeight + padding.top + padding.bottom;
1537         return CellLayout.rectToCell(requiredWidth, requiredHeight, null);
1538     }
1539 
1540     static int[] getSpanForWidget(Context context, AppWidgetProviderInfo info) {
1541         return getSpanForWidget(context, info.provider, info.minWidth, info.minHeight);
1542     }
1543 
1544     static int[] getMinSpanForWidget(Context context, AppWidgetProviderInfo info) {
1545         return getSpanForWidget(context, info.provider, info.minResizeWidth, info.minResizeHeight);
1546     }
1547 
1548     static int[] getSpanForWidget(Context context, PendingAddWidgetInfo info) {
1549         return getSpanForWidget(context, info.componentName, info.minWidth, info.minHeight);
1550     }
1551 
1552     static int[] getMinSpanForWidget(Context context, PendingAddWidgetInfo info) {
1553         return getSpanForWidget(context, info.componentName, info.minResizeWidth,
1554                 info.minResizeHeight);
1555     }
1556 
1557     /**
1558      * Add a widget to the workspace.
1559      *
1560      * @param appWidgetId The app widget id
1561      * @param cellInfo The position on screen where to create the widget.
1562      */
1563     private void completeAddAppWidget(final int appWidgetId, long container, long screenId,
1564             AppWidgetHostView hostView, AppWidgetProviderInfo appWidgetInfo) {
1565         if (appWidgetInfo == null) {
1566             appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
1567         }
1568 
1569         // Calculate the grid spans needed to fit this widget
1570         CellLayout layout = getCellLayout(container, screenId);
1571 
1572         int[] minSpanXY = getMinSpanForWidget(this, appWidgetInfo);
1573         int[] spanXY = getSpanForWidget(this, appWidgetInfo);
1574 
1575         // Try finding open space on Launcher screen
1576         // We have saved the position to which the widget was dragged-- this really only matters
1577         // if we are placing widgets on a &quot;spring-loaded&quot; screen
1578         int[] cellXY = mTmpAddItemCellCoordinates;
1579         int[] touchXY = mPendingAddInfo.dropPos;
1580         int[] finalSpan = new int[2];
1581         boolean foundCellSpan = false;
1582         if (mPendingAddInfo.cellX &gt;= 0 &amp;&amp; mPendingAddInfo.cellY &gt;= 0) {
1583             cellXY[0] = mPendingAddInfo.cellX;
1584             cellXY[1] = mPendingAddInfo.cellY;
1585             spanXY[0] = mPendingAddInfo.spanX;
1586             spanXY[1] = mPendingAddInfo.spanY;
1587             foundCellSpan = true;
1588         } else if (touchXY != null) {
1589             // when dragging and dropping, just find the closest free spot
1590             int[] result = layout.findNearestVacantArea(
1591                     touchXY[0], touchXY[1], minSpanXY[0], minSpanXY[1], spanXY[0],
1592                     spanXY[1], cellXY, finalSpan);
1593             spanXY[0] = finalSpan[0];
1594             spanXY[1] = finalSpan[1];
1595             foundCellSpan = (result != null);
1596         } else {
1597             foundCellSpan = layout.findCellForSpan(cellXY, minSpanXY[0], minSpanXY[1]);
1598         }
1599 
1600         if (!foundCellSpan) {
1601             if (appWidgetId != -1) {
1602                 // Deleting an app widget ID is a void call but writes to disk before returning
1603                 // to the caller...
1604                 new AsyncTask&lt;Void, Void, Void&gt;() {
1605                     public Void doInBackground(Void ... args) {
1606                         mAppWidgetHost.deleteAppWidgetId(appWidgetId);
1607                         return null;
1608                     }
1609                 }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
1610             }
1611             showOutOfSpaceMessage(isHotseatLayout(layout));
1612             return;
1613         }
1614 
1615         // Build Launcher-specific widget info and save to database
1616         LauncherAppWidgetInfo launcherInfo = new LauncherAppWidgetInfo(appWidgetId,
1617                 appWidgetInfo.provider);
1618         launcherInfo.spanX = spanXY[0];
1619         launcherInfo.spanY = spanXY[1];
1620         launcherInfo.minSpanX = mPendingAddInfo.minSpanX;
1621         launcherInfo.minSpanY = mPendingAddInfo.minSpanY;
1622         launcherInfo.user = mAppWidgetManager.getUser(appWidgetInfo);
1623 
1624         LauncherModel.addItemToDatabase(this, launcherInfo,
1625                 container, screenId, cellXY[0], cellXY[1], false);
1626 
1627         if (!mRestoring) {
1628             if (hostView == null) {
1629                 // Perform actual inflation because we&#x27;re live
1630                 launcherInfo.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);
1631                 launcherInfo.hostView.setAppWidget(appWidgetId, appWidgetInfo);
1632             } else {
1633                 // The AppWidgetHostView has already been inflated and instantiated
1634                 launcherInfo.hostView = hostView;
1635             }
1636 
1637             launcherInfo.hostView.setTag(launcherInfo);
1638             launcherInfo.hostView.setVisibility(View.VISIBLE);
1639             launcherInfo.notifyWidgetSizeChanged(this);
1640 
1641             mWorkspace.addInScreen(launcherInfo.hostView, container, screenId, cellXY[0], cellXY[1],
1642                     launcherInfo.spanX, launcherInfo.spanY, isWorkspaceLocked());
1643 
1644             addWidgetToAutoAdvanceIfNeeded(launcherInfo.hostView, appWidgetInfo);
1645         }
1646         resetAddInfo();
1647     }
1648 
1649     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
1650         @Override
1651         public void onReceive(Context context, Intent intent) {
1652             final String action = intent.getAction();
1653             if (Intent.ACTION_SCREEN_OFF.equals(action)) {
1654                 mUserPresent = false;
1655                 mDragLayer.clearAllResizeFrames();
1656                 updateRunning();
1657 
1658                 // Reset AllApps to its initial state only if we are not in the middle of
1659                 // processing a multi-step drop
1660                 if (mAppsCustomizeTabHost != null &amp;&amp; mPendingAddInfo.container == ItemInfo.NO_ID) {
1661                     showWorkspace(false);
1662                 }
1663             } else if (Intent.ACTION_USER_PRESENT.equals(action)) {
1664                 mUserPresent = true;
1665                 updateRunning();
1666             } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.DELETE_DATABASE.equals(action)) {
1667                 mModel.resetLoadedState(false, true);
1668                 mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,
1669                         LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE);
1670             } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.MIGRATE_DATABASE.equals(action)) {
1671                 mModel.resetLoadedState(false, true);
1672                 mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,
1673                         LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE
1674                                 | LauncherModel.LOADER_FLAG_MIGRATE_SHORTCUTS);
1675 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1676             } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1677                     || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1678                 getModel().forceReload();</span>
1679 ||||||| BASE
1680 =======
1681 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1682             }
1683         }
1684     };
1685 
1686     @Override
1687     public void onAttachedToWindow() {
1688         super.onAttachedToWindow();
1689 
1690         // Listen for broadcasts related to user-presence
1691         final IntentFilter filter = new IntentFilter();
1692         filter.addAction(Intent.ACTION_SCREEN_OFF);
1693         filter.addAction(Intent.ACTION_USER_PRESENT);
1694 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1695         // For handling managed profiles</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1696         filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1697         filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED);</span>
1698 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1699         registerReceiver(mReceiver, filter);</span>
1700 =======
1701 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1702         if (ENABLE_DEBUG_INTENTS) {
1703             filter.addAction(DebugIntents.DELETE_DATABASE);
1704             filter.addAction(DebugIntents.MIGRATE_DATABASE);
1705         }
1706         registerReceiver(mReceiver, filter);
1707         FirstFrameAnimatorHelper.initializeDrawListener(getWindow().getDecorView());
1708         setupTransparentSystemBarsForLmp();
1709         mAttached = true;
1710         mVisible = true;
1711     }
1712 
1713     /**
1714      * Sets up transparent navigation and status bars in LMP.
1715      * This method is a no-op for other platform versions.
1716      */
1717     @TargetApi(19)
1718     private void setupTransparentSystemBarsForLmp() {
1719         // TODO(sansid): use the APIs directly when compiling against L sdk.
1720         // Currently we use reflection to access the flags and the API to set the transparency
1721         // on the System bars.
1722         if (Utilities.isLmpOrAbove()) {
1723             try {
1724                 getWindow().getAttributes().systemUiVisibility |=
1725                         (View.SYSTEM_UI_FLAG_LAYOUT_STABLE
1726                                 | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
1727                                 | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
1728                 getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS
1729                         | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
1730                 Field drawsSysBackgroundsField = WindowManager.LayoutParams.class.getField(
1731                         &quot;FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS&quot;);
1732                 getWindow().addFlags(drawsSysBackgroundsField.getInt(null));
1733 
1734                 Method setStatusBarColorMethod =
1735                         Window.class.getDeclaredMethod(&quot;setStatusBarColor&quot;, int.class);
1736                 Method setNavigationBarColorMethod =
1737                         Window.class.getDeclaredMethod(&quot;setNavigationBarColor&quot;, int.class);
1738                 setStatusBarColorMethod.invoke(getWindow(), Color.TRANSPARENT);
1739                 setNavigationBarColorMethod.invoke(getWindow(), Color.TRANSPARENT);
1740             } catch (NoSuchFieldException e) {
1741                 Log.w(TAG, &quot;NoSuchFieldException while setting up transparent bars&quot;);
1742             } catch (NoSuchMethodException ex) {
1743                 Log.w(TAG, &quot;NoSuchMethodException while setting up transparent bars&quot;);
1744             } catch (IllegalAccessException e) {
1745                 Log.w(TAG, &quot;IllegalAccessException while setting up transparent bars&quot;);
1746             } catch (IllegalArgumentException e) {
1747                 Log.w(TAG, &quot;IllegalArgumentException while setting up transparent bars&quot;);
1748             } catch (InvocationTargetException e) {
1749                 Log.w(TAG, &quot;InvocationTargetException while setting up transparent bars&quot;);
1750             } finally {}
1751         }
1752     }
1753 
1754     @Override
1755     public void onDetachedFromWindow() {
1756         super.onDetachedFromWindow();
1757         mVisible = false;
1758 
1759         if (mAttached) {
1760             unregisterReceiver(mReceiver);
1761             mAttached = false;
1762         }
1763         updateRunning();
1764     }
1765 
1766     public void onWindowVisibilityChanged(int visibility) {
1767         mVisible = visibility == View.VISIBLE;
1768         updateRunning();
1769         // The following code used to be in onResume, but it turns out onResume is called when
1770         // you&#x27;re in All Apps and click home to go to the workspace. onWindowVisibilityChanged
1771         // is a more appropriate event to handle
1772         if (mVisible) {
1773             mAppsCustomizeTabHost.onWindowVisible();
1774             if (!mWorkspaceLoading) {
1775                 final ViewTreeObserver observer = mWorkspace.getViewTreeObserver();
1776                 // We want to let Launcher draw itself at least once before we force it to build
1777                 // layers on all the workspace pages, so that transitioning to Launcher from other
1778                 // apps is nice and speedy.
1779                 observer.addOnDrawListener(new ViewTreeObserver.OnDrawListener() {
1780                     private boolean mStarted = false;
1781                     public void onDraw() {
1782                         if (mStarted) return;
1783                         mStarted = true;
1784                         // We delay the layer building a bit in order to give
1785                         // other message processing a time to run.  In particular
1786                         // this avoids a delay in hiding the IME if it was
1787                         // currently shown, because doing that may involve
1788                         // some communication back with the app.
1789                         mWorkspace.postDelayed(mBuildLayersRunnable, 500);
1790                         final ViewTreeObserver.OnDrawListener listener = this;
1791                         mWorkspace.post(new Runnable() {
1792                                 public void run() {
1793                                     if (mWorkspace != null &amp;&amp;
1794                                             mWorkspace.getViewTreeObserver() != null) {
1795                                         mWorkspace.getViewTreeObserver().
1796                                                 removeOnDrawListener(listener);
1797                                     }
1798                                 }
1799                             });
1800                         return;
1801                     }
1802                 });
1803             }
1804             clearTypedText();
1805         }
1806     }
1807 
1808     private void sendAdvanceMessage(long delay) {
1809         mHandler.removeMessages(ADVANCE_MSG);
1810         Message msg = mHandler.obtainMessage(ADVANCE_MSG);
1811         mHandler.sendMessageDelayed(msg, delay);
1812         mAutoAdvanceSentTime = System.currentTimeMillis();
1813     }
1814 
1815     private void updateRunning() {
1816         boolean autoAdvanceRunning = mVisible &amp;&amp; mUserPresent &amp;&amp; !mWidgetsToAdvance.isEmpty();
1817         if (autoAdvanceRunning != mAutoAdvanceRunning) {
1818             mAutoAdvanceRunning = autoAdvanceRunning;
1819             if (autoAdvanceRunning) {
1820                 long delay = mAutoAdvanceTimeLeft == -1 ? mAdvanceInterval : mAutoAdvanceTimeLeft;
1821                 sendAdvanceMessage(delay);
1822             } else {
1823                 if (!mWidgetsToAdvance.isEmpty()) {
1824                     mAutoAdvanceTimeLeft = Math.max(0, mAdvanceInterval -
1825                             (System.currentTimeMillis() - mAutoAdvanceSentTime));
1826                 }
1827                 mHandler.removeMessages(ADVANCE_MSG);
1828                 mHandler.removeMessages(0); // Remove messages sent using postDelayed()
1829             }
1830         }
1831     }
1832 
1833     private final Handler mHandler = new Handler() {
1834         @Override
1835         public void handleMessage(Message msg) {
1836             if (msg.what == ADVANCE_MSG) {
1837                 int i = 0;
1838                 for (View key: mWidgetsToAdvance.keySet()) {
1839                     final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);
1840                     final int delay = mAdvanceStagger * i;
1841                     if (v instanceof Advanceable) {
1842                        postDelayed(new Runnable() {
1843                            public void run() {
1844                                ((Advanceable) v).advance();
1845                            }
1846                        }, delay);
1847                     }
1848                     i++;
1849                 }
1850                 sendAdvanceMessage(mAdvanceInterval);
1851             }
1852         }
1853     };
1854 
1855     void addWidgetToAutoAdvanceIfNeeded(View hostView, AppWidgetProviderInfo appWidgetInfo) {
1856         if (appWidgetInfo == null || appWidgetInfo.autoAdvanceViewId == -1) return;
1857         View v = hostView.findViewById(appWidgetInfo.autoAdvanceViewId);
1858         if (v instanceof Advanceable) {
1859             mWidgetsToAdvance.put(hostView, appWidgetInfo);
1860             ((Advanceable) v).fyiWillBeAdvancedByHostKThx();
1861             updateRunning();
1862         }
1863     }
1864 
1865     void removeWidgetToAutoAdvance(View hostView) {
1866         if (mWidgetsToAdvance.containsKey(hostView)) {
1867             mWidgetsToAdvance.remove(hostView);
1868             updateRunning();
1869         }
1870     }
1871 
1872     public void removeAppWidget(LauncherAppWidgetInfo launcherInfo) {
1873         removeWidgetToAutoAdvance(launcherInfo.hostView);
1874         launcherInfo.hostView = null;
1875     }
1876 
1877     void showOutOfSpaceMessage(boolean isHotseatLayout) {
1878         int strId = (isHotseatLayout ? R.string.hotseat_out_of_space : R.string.out_of_space);
1879         Toast.makeText(this, getString(strId), Toast.LENGTH_SHORT).show();
1880     }
1881 
1882     public DragLayer getDragLayer() {
1883         return mDragLayer;
1884     }
1885 
1886     public Workspace getWorkspace() {
1887         return mWorkspace;
1888     }
1889 
1890     public Hotseat getHotseat() {
1891         return mHotseat;
1892     }
1893 
1894 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1895 public ViewGroup getOverviewPanel() {</span>
1896 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1897 View getOverviewPanel() {</span>
1898 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1899 public View getOverviewPanel() {</span>
1900 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1901         return mOverviewPanel;
1902     }
1903 
1904     public SearchDropTargetBar getSearchBar() {
1905         return mSearchDropTargetBar;
1906     }
1907 
1908     public LauncherAppWidgetHost getAppWidgetHost() {
1909         return mAppWidgetHost;
1910     }
1911 
1912     public LauncherModel getModel() {
1913         return mModel;
1914     }
1915 
1916     public LauncherClings getLauncherClings() {
1917         return mLauncherClings;
1918     }
1919 
1920     protected SharedPreferences getSharedPrefs() {
1921         return mSharedPrefs;
1922     }
1923 
1924     public void closeSystemDialogs() {
1925         getWindow().closeAllPanels();
1926 
1927         // Whatever we were doing is hereby canceled.
1928         setWaitingForResult(false);
1929     }
1930 
1931     @Override
1932     protected void onNewIntent(Intent intent) {
1933         long startTime = 0;
1934         if (DEBUG_RESUME_TIME) {
1935             startTime = System.currentTimeMillis();
1936         }
1937         super.onNewIntent(intent);
1938 
1939         // Close the menu
1940         if (Intent.ACTION_MAIN.equals(intent.getAction())) {
1941             // also will cancel mWaitingForResult.
1942             closeSystemDialogs();
1943 
1944             final boolean alreadyOnHome = mHasFocus &amp;&amp; ((intent.getFlags() &amp;
1945                     Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT)
1946                     != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
1947 
1948             if (mWorkspace == null) {
1949                 // Can be cases where mWorkspace is null, this prevents a NPE
1950                 return;
1951             }
1952             Folder openFolder = mWorkspace.getOpenFolder();
1953             // In all these cases, only animate if we&#x27;re already on home
1954             mWorkspace.exitWidgetResizeMode();
1955             if (alreadyOnHome &amp;&amp; mState == State.WORKSPACE &amp;&amp; !mWorkspace.isTouchActive() &amp;&amp;
1956                     openFolder == null &amp;&amp; shouldMoveToDefaultScreenOnHomeIntent()) {
1957                 mWorkspace.moveToDefaultScreen(true);
1958             }
1959 
1960             closeFolder();
1961             exitSpringLoadedDragMode();
1962 
1963             // If we are already on home, then just animate back to the workspace,
1964             // otherwise, just wait until onResume to set the state back to Workspace
1965             if (alreadyOnHome) {
1966                 showWorkspace(true);
1967             } else {
1968                 mOnResumeState = State.WORKSPACE;
1969             }
1970 
1971             final View v = getWindow().peekDecorView();
1972             if (v != null &amp;&amp; v.getWindowToken() != null) {
1973                 InputMethodManager imm = (InputMethodManager)getSystemService(
1974                         INPUT_METHOD_SERVICE);
1975                 imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
1976             }
1977 
1978             // Reset the apps customize page
1979             if (!alreadyOnHome &amp;&amp; mAppsCustomizeTabHost != null) {
1980                 mAppsCustomizeTabHost.reset();
1981             }
1982 
1983             onHomeIntent();
1984         }
1985 
1986         if (DEBUG_RESUME_TIME) {
1987             Log.d(TAG, &quot;Time spent in onNewIntent: &quot; + (System.currentTimeMillis() - startTime));
1988         }
1989     }
1990 
1991     /**
1992      * Override point for subclasses to prevent movement to the default screen when the home
1993      * button is pressed. Used (for example) in GEL, to prevent movement during a search.
1994      */
1995     protected boolean shouldMoveToDefaultScreenOnHomeIntent() {
1996         return true;
1997     }
1998 
1999     /**
2000      * Override point for subclasses to provide custom behaviour for when a home intent is fired.
2001      */
2002     protected void onHomeIntent() {
2003         // Do nothing
2004     }
2005 
2006     @Override
2007     public void onRestoreInstanceState(Bundle state) {
2008         super.onRestoreInstanceState(state);
2009         for (int page: mSynchronouslyBoundPages) {
2010             mWorkspace.restoreInstanceStateForChild(page);
2011         }
2012     }
2013 
2014     @Override
2015     protected void onSaveInstanceState(Bundle outState) {
2016         if (mWorkspace.getChildCount() &gt; 0) {
2017             outState.putInt(RUNTIME_STATE_CURRENT_SCREEN,
2018                     mWorkspace.getCurrentPageOffsetFromCustomContent());
2019         }
2020         super.onSaveInstanceState(outState);
2021 
2022         outState.putInt(RUNTIME_STATE, mState.ordinal());
2023         // We close any open folder since it will not be re-opened, and we need to make sure
2024         // this state is reflected.
2025         closeFolder();
2026 
2027         if (mPendingAddInfo.container != ItemInfo.NO_ID &amp;&amp; mPendingAddInfo.screenId &gt; -1 &amp;&amp;
2028                 mWaitingForResult) {
2029             outState.putLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, mPendingAddInfo.container);
2030             outState.putLong(RUNTIME_STATE_PENDING_ADD_SCREEN, mPendingAddInfo.screenId);
2031             outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_X, mPendingAddInfo.cellX);
2032             outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_Y, mPendingAddInfo.cellY);
2033             outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_X, mPendingAddInfo.spanX);
2034             outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y, mPendingAddInfo.spanY);
2035             outState.putParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO, mPendingAddWidgetInfo);
2036             outState.putInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID, mPendingAddWidgetId);
2037         }
2038 
2039         if (mFolderInfo != null &amp;&amp; mWaitingForResult) {
2040             outState.putBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, true);
2041             outState.putLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID, mFolderInfo.id);
2042         }
2043 
2044         // Save the current AppsCustomize tab
2045         if (mAppsCustomizeTabHost != null) {
2046             AppsCustomizePagedView.ContentType type = mAppsCustomizeContent.getContentType();
2047             String currentTabTag = mAppsCustomizeTabHost.getTabTagForContentType(type);
2048             if (currentTabTag != null) {
2049                 outState.putString(&quot;apps_customize_currentTab&quot;, currentTabTag);
2050             }
2051             int currentIndex = mAppsCustomizeContent.getSaveInstanceStateIndex();
2052             outState.putInt(&quot;apps_customize_currentIndex&quot;, currentIndex);
2053         }
2054         outState.putSerializable(RUNTIME_STATE_VIEW_IDS, mItemIdToViewId);
2055     }
2056 
2057     @Override
2058     public void onDestroy() {
2059         super.onDestroy();
2060 
2061         // Remove all pending runnables
2062         mHandler.removeMessages(ADVANCE_MSG);
2063         mHandler.removeMessages(0);
2064         mWorkspace.removeCallbacks(mBuildLayersRunnable);
2065 
2066         // Stop callbacks from LauncherModel
2067         LauncherAppState app = (LauncherAppState.getInstance());
2068 
2069         // It&#x27;s possible to receive onDestroy after a new Launcher activity has
2070         // been created. In this case, don&#x27;t interfere with the new Launcher.
2071         if (mModel.isCurrentCallbacks(this)) {
2072         mModel.stopLoader();
2073         app.setLauncher(null);
2074         }
2075 
2076         try {
2077             mAppWidgetHost.stopListening();
2078         } catch (NullPointerException ex) {
2079             Log.w(TAG, &quot;problem while stopping AppWidgetHost during Launcher destruction&quot;, ex);
2080         }
2081         mAppWidgetHost = null;
2082 
2083         mWidgetsToAdvance.clear();
2084 
2085         TextKeyListener.getInstance().release();
2086 
2087         // Disconnect any of the callbacks and drawables associated with ItemInfos on the workspace
2088         // to prevent leaking Launcher activities on orientation change.
2089         if (mModel != null) {
2090             mModel.unbindItemInfosAndClearQueuedBindRunnables();
2091         }
2092 
2093         getContentResolver().unregisterContentObserver(mWidgetObserver);
2094         unregisterReceiver(mCloseSystemDialogsReceiver);
2095 
2096         mDragLayer.clearAllResizeFrames();
2097         ((ViewGroup) mWorkspace.getParent()).removeAllViews();
2098         mWorkspace.removeAllWorkspaceScreens();
2099         mWorkspace = null;
2100         mDragController = null;
2101 
2102         PackageInstallerCompat.getInstance(this).onStop();
2103         LauncherAnimUtils.onDestroyActivity();
2104     }
2105 
2106     public DragController getDragController() {
2107         return mDragController;
2108     }
2109 
2110     @Override
2111     public void startActivityForResult(Intent intent, int requestCode) {
2112         if (requestCode &gt;= 0) {
2113             setWaitingForResult(true);
2114         }
2115         super.startActivityForResult(intent, requestCode);
2116     }
2117 
2118     /**
2119      * Indicates that we want global search for this activity by setting the globalSearch
2120      * argument for {@link #startSearch} to true.
2121      */
2122     @Override
2123     public void startSearch(String initialQuery, boolean selectInitialQuery,
2124             Bundle appSearchData, boolean globalSearch) {
2125 
2126         showWorkspace(true);
2127 
2128         if (initialQuery == null) {
2129             // Use any text typed in the launcher as the initial query
2130             initialQuery = getTypedText();
2131         }
2132         if (appSearchData == null) {
2133             appSearchData = new Bundle();
2134             appSearchData.putString(&quot;source&quot;, &quot;launcher-search&quot;);
2135         }
2136         Rect sourceBounds = new Rect();
2137         if (mSearchDropTargetBar != null) {
2138             sourceBounds = mSearchDropTargetBar.getSearchBarBounds();
2139         }
2140 
2141         boolean clearTextImmediately = startSearch(initialQuery, selectInitialQuery,
2142                 appSearchData, sourceBounds);
2143         if (clearTextImmediately) {
2144             clearTypedText();
2145         }
2146     }
2147 
2148     /**
2149      * Start a text search.
2150      *
2151      * @return {@code true} if the search will start immediately, so any further keypresses
2152      * will be handled directly by the search UI. {@code false} if {@link Launcher} should continue
2153      * to buffer keypresses.
2154      */
2155     public boolean startSearch(String initialQuery,
2156             boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2157         startGlobalSearch(initialQuery, selectInitialQuery,
2158                 appSearchData, sourceBounds);
2159         return false;
2160     }
2161 
2162     /**
2163      * Starts the global search activity. This code is a copied from SearchManager
2164      */
2165     private void startGlobalSearch(String initialQuery,
2166             boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2167         final SearchManager searchManager =
2168             (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2169         ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
2170         if (globalSearchActivity == null) {
2171             Log.w(TAG, &quot;No global search activity found.&quot;);
2172             return;
2173         }
2174         Intent intent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
2175         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2176         intent.setComponent(globalSearchActivity);
2177         // Make sure that we have a Bundle to put source in
2178         if (appSearchData == null) {
2179             appSearchData = new Bundle();
2180         } else {
2181             appSearchData = new Bundle(appSearchData);
2182         }
2183         // Set source to package name of app that starts global search, if not set already.
2184         if (!appSearchData.containsKey(&quot;source&quot;)) {
2185             appSearchData.putString(&quot;source&quot;, getPackageName());
2186         }
2187         intent.putExtra(SearchManager.APP_DATA, appSearchData);
2188         if (!TextUtils.isEmpty(initialQuery)) {
2189             intent.putExtra(SearchManager.QUERY, initialQuery);
2190         }
2191         if (selectInitialQuery) {
2192             intent.putExtra(SearchManager.EXTRA_SELECT_QUERY, selectInitialQuery);
2193         }
2194         intent.setSourceBounds(sourceBounds);
2195         try {
2196             startActivity(intent);
2197         } catch (ActivityNotFoundException ex) {
2198             Log.e(TAG, &quot;Global search activity not found: &quot; + globalSearchActivity);
2199         }
2200     }
2201 
2202     public boolean isOnCustomContent() {
2203         return mWorkspace.isOnOrMovingToCustomContent();
2204     }
2205 
2206     @Override
2207     public boolean onPrepareOptionsMenu(Menu menu) {
2208         super.onPrepareOptionsMenu(menu);
2209         if (!isOnCustomContent()) {
2210             // Close any open folders
2211             closeFolder();
2212             // Stop resizing any widgets
2213             mWorkspace.exitWidgetResizeMode();
2214             if (!mWorkspace.isInOverviewMode()) {
2215                 // Show the overview mode
2216         showOverviewMode(true);
2217             } else {
2218                 showWorkspace(true);
2219             }
2220         }
2221         return false;
2222     }
2223 
2224     @Override
2225     public boolean onSearchRequested() {
2226         startSearch(null, false, null, true);
2227         // Use a custom animation for launching search
2228         return true;
2229     }
2230 
2231     public boolean isWorkspaceLocked() {
2232         return mWorkspaceLoading || mWaitingForResult;
2233     }
2234 
2235     public boolean isWorkspaceLoading() {
2236         return mWorkspaceLoading;
2237     }
2238 
2239     private void setWorkspaceLoading(boolean value) {
2240         boolean isLocked = isWorkspaceLocked();
2241         mWorkspaceLoading = value;
2242         if (isLocked != isWorkspaceLocked()) {
2243             onWorkspaceLockedChanged();
2244         }
2245     }
2246 
2247     private void setWaitingForResult(boolean value) {
2248         boolean isLocked = isWorkspaceLocked();
2249         mWaitingForResult = value;
2250         if (isLocked != isWorkspaceLocked()) {
2251             onWorkspaceLockedChanged();
2252         }
2253     }
2254 
2255     protected void onWorkspaceLockedChanged() { }
2256 
2257     private void resetAddInfo() {
2258         mPendingAddInfo.container = ItemInfo.NO_ID;
2259         mPendingAddInfo.screenId = -1;
2260         mPendingAddInfo.cellX = mPendingAddInfo.cellY = -1;
2261         mPendingAddInfo.spanX = mPendingAddInfo.spanY = -1;
2262         mPendingAddInfo.minSpanX = mPendingAddInfo.minSpanY = -1;
2263         mPendingAddInfo.dropPos = null;
2264     }
2265 
2266     void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2267             final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo) {
2268         addAppWidgetImpl(appWidgetId, info, boundWidget, appWidgetInfo, 0);
2269     }
2270 
2271     void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2272             final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo, int
2273             delay) {
2274         if (appWidgetInfo.configure != null) {
2275             mPendingAddWidgetInfo = appWidgetInfo;
2276             mPendingAddWidgetId = appWidgetId;
2277 
2278             // Launch over to configure widget, if needed
2279             mAppWidgetManager.startConfigActivity(appWidgetInfo, appWidgetId, this,
2280                     mAppWidgetHost, REQUEST_CREATE_APPWIDGET);
2281 
2282         } else {
2283             // Otherwise just add it
2284             Runnable onComplete = new Runnable() {
2285                 @Override
2286                 public void run() {
2287                     // Exit spring loaded mode if necessary after adding the widget
2288                     exitSpringLoadedDragModeDelayed(true, EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
2289                             null);
2290                 }
2291             };
2292             completeAddAppWidget(appWidgetId, info.container, info.screenId, boundWidget,
2293                     appWidgetInfo);
2294             mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete, delay, false);
2295         }
2296     }
2297 
2298     protected void moveToCustomContentScreen(boolean animate) {
2299         // Close any folders that may be open.
2300         closeFolder();
2301         mWorkspace.moveToCustomContentScreen(animate);
2302     }
2303     /**
2304      * Process a shortcut drop.
2305      *
2306      * @param componentName The name of the component
2307      * @param screenId The ID of the screen where it should be added
2308      * @param cell The cell it should be added to, optional
2309      * @param position The location on the screen where it was dropped, optional
2310      */
2311     void processShortcutFromDrop(ComponentName componentName, long container, long screenId,
2312             int[] cell, int[] loc) {
2313         resetAddInfo();
2314         mPendingAddInfo.container = container;
2315         mPendingAddInfo.screenId = screenId;
2316         mPendingAddInfo.dropPos = loc;
2317 
2318         if (cell != null) {
2319             mPendingAddInfo.cellX = cell[0];
2320             mPendingAddInfo.cellY = cell[1];
2321         }
2322 
2323         Intent createShortcutIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2324         createShortcutIntent.setComponent(componentName);
2325         processShortcut(createShortcutIntent);
2326     }
2327 
2328     /**
2329      * Process a widget drop.
2330      *
2331      * @param info The PendingAppWidgetInfo of the widget being added.
2332      * @param screenId The ID of the screen where it should be added
2333      * @param cell The cell it should be added to, optional
2334      * @param position The location on the screen where it was dropped, optional
2335      */
2336     void addAppWidgetFromDrop(PendingAddWidgetInfo info, long container, long screenId,
2337             int[] cell, int[] span, int[] loc) {
2338         resetAddInfo();
2339         mPendingAddInfo.container = info.container = container;
2340         mPendingAddInfo.screenId = info.screenId = screenId;
2341         mPendingAddInfo.dropPos = loc;
2342         mPendingAddInfo.minSpanX = info.minSpanX;
2343         mPendingAddInfo.minSpanY = info.minSpanY;
2344 
2345         if (cell != null) {
2346             mPendingAddInfo.cellX = cell[0];
2347             mPendingAddInfo.cellY = cell[1];
2348         }
2349         if (span != null) {
2350             mPendingAddInfo.spanX = span[0];
2351             mPendingAddInfo.spanY = span[1];
2352         }
2353 
2354         AppWidgetHostView hostView = info.boundWidget;
2355         int appWidgetId;
2356         if (hostView != null) {
2357             appWidgetId = hostView.getAppWidgetId();
2358             addAppWidgetImpl(appWidgetId, info, hostView, info.info);
2359         } else {
2360             // In this case, we either need to start an activity to get permission to bind
2361             // the widget, or we need to start an activity to configure the widget, or both.
2362             appWidgetId = getAppWidgetHost().allocateAppWidgetId();
2363             Bundle options = info.bindOptions;
2364 
2365             boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
2366                     appWidgetId, info.info, options);
2367             if (success) {
2368                 addAppWidgetImpl(appWidgetId, info, null, info.info);
2369             } else {
2370                 mPendingAddWidgetInfo = info.info;
2371                 Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);
2372                 intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
2373                 intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName);
2374                 mAppWidgetManager.getUser(mPendingAddWidgetInfo)
2375                     .addToIntent(intent, AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE);
2376                 // TODO: we need to make sure that this accounts for the options bundle.
2377                 // intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);
2378                 startActivityForResult(intent, REQUEST_BIND_APPWIDGET);
2379             }
2380         }
2381     }
2382 
2383     void processShortcut(Intent intent) {
2384             Utilities.startActivityForResultSafely(this, intent, REQUEST_CREATE_SHORTCUT);
2385         }
2386 
2387     void processWallpaper(Intent intent) {
2388         startActivityForResult(intent, REQUEST_PICK_WALLPAPER);
2389     }
2390 
2391     FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX,
2392             int cellY) {
2393         final FolderInfo folderInfo = new FolderInfo();
2394         folderInfo.title = getText(R.string.folder_name);
2395 
2396         // Update the model
2397         LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId, cellX, cellY,
2398                 false);
2399         sFolders.put(folderInfo.id, folderInfo);
2400 
2401         // Create the view
2402         FolderIcon newFolder =
2403             FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
2404         mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1,
2405                 isWorkspaceLocked());
2406         // Force measure the new folder icon
2407         CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
2408         parent.getShortcutsAndWidgets().measureChild(newFolder);
2409         return newFolder;
2410     }
2411 
2412     void removeFolder(FolderInfo folder) {
2413         sFolders.remove(folder.id);
2414     }
2415 
2416     protected ComponentName getWallpaperPickerComponent() {
2417         return new ComponentName(getPackageName(), LauncherWallpaperPickerActivity.class.getName());
2418     }
2419 
2420     /**
2421      * Registers various content observers. The current implementation registers
2422      * only a favorites observer to keep track of the favorites applications.
2423      */
2424     private void registerContentObservers() {
2425         ContentResolver resolver = getContentResolver();
2426         resolver.registerContentObserver(LauncherProvider.CONTENT_APPWIDGET_RESET_URI,
2427                 true, mWidgetObserver);
2428     }
2429 
2430     @Override
2431     public boolean dispatchKeyEvent(KeyEvent event) {
2432         if (event.getAction() == KeyEvent.ACTION_DOWN) {
2433             switch (event.getKeyCode()) {
2434                 case KeyEvent.KEYCODE_HOME:
2435                     return true;
2436                 case KeyEvent.KEYCODE_VOLUME_DOWN:
2437                     if (isPropertyEnabled(DUMP_STATE_PROPERTY)) {
2438                         dumpState();
2439                         return true;
2440                     }
2441                     break;
2442             }
2443         } else if (event.getAction() == KeyEvent.ACTION_UP) {
2444             switch (event.getKeyCode()) {
2445                 case KeyEvent.KEYCODE_HOME:
2446                     return true;
2447             }
2448         }
2449 
2450         return super.dispatchKeyEvent(event);
2451     }
2452 
2453     @Override
2454     public void onBackPressed() {
2455         if (isAllAppsVisible()) {
2456             if (mAppsCustomizeContent.getContentType() ==
2457                     AppsCustomizePagedView.ContentType.Applications) {
2458                 showWorkspace(true);
2459             } else {
2460                 showOverviewMode(true);
2461             }
2462         } else if (mWorkspace.isInOverviewMode()) {
2463             mWorkspace.exitOverviewMode(true);
2464         } else if (mWorkspace.getOpenFolder() != null) {
2465             Folder openFolder = mWorkspace.getOpenFolder();
2466             if (openFolder.isEditingName()) {
2467                 openFolder.dismissEditingName();
2468             } else {
2469                 closeFolder();
2470             }
2471         } else {
2472             mWorkspace.exitWidgetResizeMode();
2473 
2474             // Back button is a no-op here, but give at least some feedback for the button press
2475             mWorkspace.showOutlinesTemporarily();
2476         }
2477     }
2478 
2479     /**
2480      * Re-listen when widgets are reset.
2481      */
2482     private void onAppWidgetReset() {
2483         if (mAppWidgetHost != null) {
2484             mAppWidgetHost.startListening();
2485         }
2486     }
2487 
2488     /**
2489      * Launches the intent referred by the clicked shortcut.
2490      *
2491      * @param v The view representing the clicked shortcut.
2492      */
2493     public void onClick(View v) {
2494         // Make sure that rogue clicks don&#x27;t get through while allapps is launching, or after the
2495         // view has detached (it&#x27;s possible for this to happen if the view is removed mid touch).
2496         if (v.getWindowToken() == null) {
2497             return;
2498         }
2499 
2500         if (!mWorkspace.isFinishedSwitchingState()) {
2501             return;
2502         }
2503 
2504         if (v instanceof Workspace) {
2505             if (mWorkspace.isInOverviewMode()) {
2506                 mWorkspace.exitOverviewMode(true);
2507             }
2508             return;
2509         }
2510 
2511         if (v instanceof CellLayout) {
2512             if (mWorkspace.isInOverviewMode()) {
2513                 mWorkspace.exitOverviewMode(mWorkspace.indexOfChild(v), true);
2514             }
2515         }
2516 
2517         Object tag = v.getTag();
2518         if (tag instanceof ShortcutInfo) {
2519             onClickAppShortcut(v);
2520         } else if (tag instanceof FolderInfo) {
2521             if (v instanceof FolderIcon) {
2522                 onClickFolderIcon(v);
2523             }
2524         } else if (v == mAllAppsButton) {
2525                 onClickAllAppsButton(v);
2526         } else if (tag instanceof AppInfo) {
2527             startAppShortcutOrInfoActivity(v);
2528         } else if (tag instanceof LauncherAppWidgetInfo) {
2529             if (v instanceof PendingAppWidgetHostView) {
2530                 onClickPendingWidget((PendingAppWidgetHostView) v);
2531             }
2532         }
2533     }
2534 
2535     public void onClickPagedViewIcon(View v) {
2536         startAppShortcutOrInfoActivity(v);
2537     }
2538 
2539     public boolean onTouch(View v, MotionEvent event) {
2540         return false;
2541     }
2542 
2543     /**
2544      * Event handler for the app widget view which has not fully restored.
2545      */
2546     public void onClickPendingWidget(final PendingAppWidgetHostView v) {
2547         final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
2548         if (v.isReadyForClickSetup()) {
2549             int widgetId = info.appWidgetId;
2550             AppWidgetProviderInfo appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(widgetId);
2551             if (appWidgetInfo != null) {
2552                 mPendingAddWidgetInfo = appWidgetInfo;
2553                 mPendingAddInfo.copyFrom(info);
2554                 mPendingAddWidgetId = widgetId;
2555 
2556                 AppWidgetManagerCompat.getInstance(this).startConfigActivity(appWidgetInfo,
2557                         info.appWidgetId, this, mAppWidgetHost, REQUEST_RECONFIGURE_APPWIDGET);
2558             }
2559         } else if (info.installProgress &lt; 0) {
2560             // The install has not been queued
2561             final String packageName = info.providerName.getPackageName();
2562             showBrokenAppInstallDialog(packageName,
2563                 new DialogInterface.OnClickListener() {
2564                     public void onClick(DialogInterface dialog, int id) {
2565                         startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
2566                     }
2567                 });
2568         } else {
2569             // Download has started.
2570             final String packageName = info.providerName.getPackageName();
2571             startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
2572         }
2573     }
2574 
2575     /**
2576      * Event handler for the search button
2577      *
2578      * @param v The view that was clicked.
2579      */
2580     public void onClickSearchButton(View v) {
2581         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2582 
2583         onSearchRequested();
2584     }
2585 
2586     /**
2587      * Event handler for the voice button
2588      *
2589      * @param v The view that was clicked.
2590      */
2591     public void onClickVoiceButton(View v) {
2592         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2593 
2594         startVoice();
2595     }
2596 
2597     public void startVoice() {
2598         try {
2599             final SearchManager searchManager =
2600                     (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2601             ComponentName activityName = searchManager.getGlobalSearchActivity();
2602             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2603             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2604             if (activityName != null) {
2605                 intent.setPackage(activityName.getPackageName());
2606             }
2607             startActivity(null, intent, &quot;onClickVoiceButton&quot;);
2608         } catch (ActivityNotFoundException e) {
2609             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2610             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2611             startActivitySafely(null, intent, &quot;onClickVoiceButton&quot;);
2612         }
2613     }
2614 
2615     /**
2616      * Event handler for the &quot;grid&quot; button that appears on the home screen, which
2617      * enters all apps mode.
2618      *
2619      * @param v The view that was clicked.
2620      */
2621     protected void onClickAllAppsButton(View v) {
2622         if (LOGD) Log.d(TAG, &quot;onClickAllAppsButton&quot;);
2623         if (isAllAppsVisible()) {
2624             showWorkspace(true);
2625         } else {
2626         showAllApps(true, AppsCustomizePagedView.ContentType.Applications, false);
2627     }
2628     }
2629 
2630     private void showBrokenAppInstallDialog(final String packageName,
2631             DialogInterface.OnClickListener onSearchClickListener) {
2632         new AlertDialog.Builder(new ContextThemeWrapper(this, android.R.style.Theme_DeviceDefault))
2633             .setTitle(R.string.abandoned_promises_title)
2634             .setMessage(R.string.abandoned_promise_explanation)
2635             .setPositiveButton(R.string.abandoned_search, onSearchClickListener)
2636             .setNeutralButton(R.string.abandoned_clean_this,
2637                 new DialogInterface.OnClickListener() {
2638                     public void onClick(DialogInterface dialog, int id) {
2639                         final UserHandleCompat user = UserHandleCompat.myUserHandle();
2640                         mWorkspace.removeAbandonedPromise(packageName, user);
2641                     }
2642                 })
2643             .create().show();
2644         return;
2645     }
2646 
2647     /**
2648      * Event handler for an app shortcut click.
2649      *
2650      * @param v The view that was clicked. Must be a tagged with a {@link ShortcutInfo}.
2651      */
2652     protected void onClickAppShortcut(final View v) {
2653         if (LOGD) Log.d(TAG, &quot;onClickAppShortcut&quot;);
2654         Object tag = v.getTag();
2655         if (!(tag instanceof ShortcutInfo)) {
2656             throw new IllegalArgumentException(&quot;Input must be a Shortcut&quot;);
2657         }
2658 
2659         // Open shortcut
2660         final ShortcutInfo shortcut = (ShortcutInfo) tag;
2661         final Intent intent = shortcut.intent;
2662 
2663         // Check for special shortcuts
2664         if (intent.getComponent() != null) {
2665             final String shortcutClass = intent.getComponent().getClassName();
2666 
2667             if (shortcutClass.equals(MemoryDumpActivity.class.getName())) {
2668                 MemoryDumpActivity.startDump(this);
2669                 return;
2670             } else if (shortcutClass.equals(ToggleWeightWatcher.class.getName())) {
2671                 toggleShowWeightWatcher();
2672                 return;
2673             }
2674         }
2675 
2676         // Check for abandoned promise
2677         if ((v instanceof BubbleTextView)
2678                 &amp;&amp; shortcut.isPromise()
2679                 &amp;&amp; !shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE)) {
2680             showBrokenAppInstallDialog(
2681                     shortcut.getTargetComponent().getPackageName(),
2682                     new DialogInterface.OnClickListener() {
2683                         public void onClick(DialogInterface dialog, int id) {
2684                             startAppShortcutOrInfoActivity(v);
2685                         }
2686                     });
2687             return;
2688         }
2689 
2690         // Start activities
2691         startAppShortcutOrInfoActivity(v);
2692     }
2693 
2694     private void startAppShortcutOrInfoActivity(View v) {
2695         Object tag = v.getTag();
2696         final ShortcutInfo shortcut;
2697         final Intent intent;
2698         if (tag instanceof ShortcutInfo) {
2699             shortcut = (ShortcutInfo) tag;
2700             intent = shortcut.intent;
2701             int[] pos = new int[2];
2702             v.getLocationOnScreen(pos);
2703             intent.setSourceBounds(new Rect(pos[0], pos[1],
2704                     pos[0] + v.getWidth(), pos[1] + v.getHeight()));
2705 
2706         } else if (tag instanceof AppInfo) {
2707             shortcut = null;
2708             intent = ((AppInfo) tag).intent;
2709         } else {
2710             throw new IllegalArgumentException(&quot;Input must be a Shortcut or AppInfo&quot;);
2711         }
2712 
2713         boolean success = startActivitySafely(v, intent, tag);
2714         mStats.recordLaunch(intent, shortcut);
2715 
2716         if (success &amp;&amp; v instanceof BubbleTextView) {
2717             mWaitingForResume = (BubbleTextView) v;
2718             mWaitingForResume.setStayPressed(true);
2719         }
2720     }
2721 
2722     /**
2723      * Event handler for a folder icon click.
2724      *
2725      * @param v The view that was clicked. Must be an instance of {@link FolderIcon}.
2726      */
2727     protected void onClickFolderIcon(View v) {
2728         if (LOGD) Log.d(TAG, &quot;onClickFolder&quot;);
2729         if (!(v instanceof FolderIcon)){
2730             throw new IllegalArgumentException(&quot;Input must be a FolderIcon&quot;);
2731         }
2732 
2733         FolderIcon folderIcon = (FolderIcon) v;
2734         final FolderInfo info = folderIcon.getFolderInfo();
2735         Folder openFolder = mWorkspace.getFolderForTag(info);
2736 
2737         // If the folder info reports that the associated folder is open, then verify that
2738         // it is actually opened. There have been a few instances where this gets out of sync.
2739         if (info.opened &amp;&amp; openFolder == null) {
2740             Log.d(TAG, &quot;Folder info marked as open, but associated folder is not open. Screen: &quot;
2741                     + info.screenId + &quot; (&quot; + info.cellX + &quot;, &quot; + info.cellY + &quot;)&quot;);
2742             info.opened = false;
2743         }
2744 
2745         if (!info.opened &amp;&amp; !folderIcon.getFolder().isDestroyed()) {
2746             // Close any open folder
2747             closeFolder();
2748             // Open the requested folder
2749             openFolder(folderIcon);
2750         } else {
2751             // Find the open folder...
2752             int folderScreen;
2753             if (openFolder != null) {
2754                 folderScreen = mWorkspace.getPageForView(openFolder);
2755                 // .. and close it
2756                 closeFolder(openFolder);
2757                 if (folderScreen != mWorkspace.getCurrentPage()) {
2758                     // Close any folder open on the current screen
2759                     closeFolder();
2760                     // Pull the folder onto this screen
2761                     openFolder(folderIcon);
2762                 }
2763             }
2764         }
2765     }
2766 
2767     /**
2768      * Event handler for the (Add) Widgets button that appears after a long press
2769      * on the home screen.
2770      */
2771     protected void onClickAddWidgetButton(View view) {
2772         if (LOGD) Log.d(TAG, &quot;onClickAddWidgetButton&quot;);
2773         showAllApps(true, AppsCustomizePagedView.ContentType.Widgets, true);
2774     }
2775 
2776     /**
2777      * Event handler for the wallpaper picker button that appears after a long press
2778      * on the home screen.
2779      */
2780     protected void onClickWallpaperPicker(View v) {
2781         if (LOGD) Log.d(TAG, &quot;onClickWallpaperPicker&quot;);
2782         final Intent pickWallpaper = new Intent(Intent.ACTION_SET_WALLPAPER);
2783         pickWallpaper.setComponent(getWallpaperPickerComponent());
2784         startActivityForResult(pickWallpaper, REQUEST_PICK_WALLPAPER);
2785     }
2786 
2787     /**
2788      * Event handler for a click on the settings button that appears after a long press
2789      * on the home screen.
2790      */
2791     protected void onClickSettingsButton(View v) {
2792         if (LOGD) Log.d(TAG, &quot;onClickSettingsButton&quot;);
2793     }
2794 
2795     public void onTouchDownAllAppsButton(View v) {
2796         // Provide the same haptic feedback that the system offers for virtual keys.
2797         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2798     }
2799 
2800     public void performHapticFeedbackOnTouchDown(View v) {
2801         // Provide the same haptic feedback that the system offers for virtual keys.
2802         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2803     }
2804 
2805     public View.OnTouchListener getHapticFeedbackTouchListener() {
2806         if (mHapticFeedbackTouchListener == null) {
2807             mHapticFeedbackTouchListener = new View.OnTouchListener() {
2808                 @Override
2809                 public boolean onTouch(View v, MotionEvent event) {
2810                     if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
2811                         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2812                     }
2813                     return false;
2814                 }
2815             };
2816         }
2817         return mHapticFeedbackTouchListener;
2818     }
2819 
2820     public void onDragStarted(View view) {}
2821 
2822     /**
2823      * Called when the user stops interacting with the launcher.
2824      * This implies that the user is now on the homescreen and is not doing housekeeping.
2825      */
2826     protected void onInteractionEnd() {}
2827 
2828     /**
2829      * Called when the user starts interacting with the launcher.
2830      * The possible interactions are:
2831      *  - open all apps
2832      *  - reorder an app shortcut, or a widget
2833      *  - open the overview mode.
2834      * This is a good time to stop doing things that only make sense
2835      * when the user is on the homescreen and not doing housekeeping.
2836      */
2837     protected void onInteractionBegin() {}
2838 
2839     void startApplicationDetailsActivity(ComponentName componentName, UserHandleCompat user) {
2840         String packageName = componentName.getPackageName();
2841         try {
2842             LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
2843             UserManagerCompat userManager = UserManagerCompat.getInstance(this);
2844             launcherApps.showAppDetailsForProfile(componentName, user);
2845         } catch (SecurityException e) {
2846             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2847             Log.e(TAG, &quot;Launcher does not have permission to launch settings&quot;);
2848         } catch (ActivityNotFoundException e) {
2849             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2850             Log.e(TAG, &quot;Unable to launch settings&quot;);
2851         }
2852     }
2853 
2854     // returns true if the activity was started
2855     boolean startApplicationUninstallActivity(ComponentName componentName, int flags,
2856             UserHandleCompat user) {
2857         if ((flags &amp; AppInfo.DOWNLOADED_FLAG) == 0) {
2858             // System applications cannot be installed. For now, show a toast explaining that.
2859             // We may give them the option of disabling apps this way.
2860             int messageId = R.string.uninstall_system_app_text;
2861             Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show();
2862             return false;
2863         } else {
2864             String packageName = componentName.getPackageName();
2865             String className = componentName.getClassName();
2866             Intent intent = new Intent(
2867                     Intent.ACTION_DELETE, Uri.fromParts(&quot;package&quot;, packageName, className));
2868             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
2869                     Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
2870             if (user != null) {
2871                 user.addToIntent(intent, Intent.EXTRA_USER);
2872             }
2873             startActivity(intent);
2874             return true;
2875         }
2876     }
2877 
2878     boolean startActivity(View v, Intent intent, Object tag) {
2879         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2880         try {
2881             // Only launch using the new animation if the shortcut has not opted out (this is a
2882             // private contract between launcher and may be ignored in the future).
2883             boolean useLaunchAnimation = (v != null) &amp;&amp;
2884                     !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);
2885             LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
2886             UserManagerCompat userManager = UserManagerCompat.getInstance(this);
2887 
2888             UserHandleCompat user = null;
2889             if (intent.hasExtra(AppInfo.EXTRA_PROFILE)) {
2890                 long serialNumber = intent.getLongExtra(AppInfo.EXTRA_PROFILE, -1);
2891                 user = userManager.getUserForSerialNumber(serialNumber);
2892             }
2893 
2894             Bundle optsBundle = null;
2895             if (useLaunchAnimation) {
2896                 ActivityOptions opts = Utilities.isLmpOrAbove() ?
<abbr title="2897                         ActivityOptions.makeCustomAnimation(this, R.anim.task_open_enter, R.anim.no_anim) :">2897                         ActivityOptions.makeCustomAnimation(this, R.anim.task_open_enter, R.anim.no_anim)🔵</abbr>
<abbr title="2898                         ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());">2898                         ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasured🔵</abbr>
2899                 optsBundle = opts.toBundle();
2900             }
2901 
2902             if (user == null || user.equals(UserHandleCompat.myUserHandle())) {
2903                 // Could be launching some bookkeeping activity
2904                 startActivity(intent, optsBundle);
2905             } else {
2906                 // TODO Component can be null when shortcuts are supported for secondary user
2907                 launcherApps.startActivityForProfile(intent.getComponent(), user,
2908                         intent.getSourceBounds(), optsBundle);
2909             }
2910             return true;
2911         } catch (SecurityException e) {
2912             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2913             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
2914                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
2915                     &quot;or use the exported attribute for this activity. &quot;
2916                     + &quot;tag=&quot;+ tag + &quot; intent=&quot; + intent, e);
2917         }
2918         return false;
2919     }
2920 
2921     boolean startActivitySafely(View v, Intent intent, Object tag) {
2922         boolean success = false;
2923         if (mIsSafeModeEnabled &amp;&amp; !Utilities.isSystemApp(this, intent)) {
2924             Toast.makeText(this, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show();
2925             return false;
2926         }
2927         try {
2928             success = startActivity(v, intent, tag);
2929         } catch (ActivityNotFoundException e) {
2930             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2931             Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);
2932         }
2933         return success;
2934     }
2935 
2936     /**
2937      * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView
2938      * in the DragLayer in the exact absolute location of the original FolderIcon.
2939      */
2940     private void copyFolderIconToImage(FolderIcon fi) {
2941         final int width = fi.getMeasuredWidth();
2942         final int height = fi.getMeasuredHeight();
2943 
2944         // Lazy load ImageView, Bitmap and Canvas
2945         if (mFolderIconImageView == null) {
2946             mFolderIconImageView = new ImageView(this);
2947         }
2948         if (mFolderIconBitmap == null || mFolderIconBitmap.getWidth() != width ||
2949                 mFolderIconBitmap.getHeight() != height) {
2950             mFolderIconBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
2951             mFolderIconCanvas = new Canvas(mFolderIconBitmap);
2952         }
2953 
2954         DragLayer.LayoutParams lp;
2955         if (mFolderIconImageView.getLayoutParams() instanceof DragLayer.LayoutParams) {
2956             lp = (DragLayer.LayoutParams) mFolderIconImageView.getLayoutParams();
2957         } else {
2958             lp = new DragLayer.LayoutParams(width, height);
2959         }
2960 
2961         // The layout from which the folder is being opened may be scaled, adjust the starting
2962         // view size by this scale factor.
2963         float scale = mDragLayer.getDescendantRectRelativeToSelf(fi, mRectForFolderAnimation);
2964         lp.customPosition = true;
2965         lp.x = mRectForFolderAnimation.left;
2966         lp.y = mRectForFolderAnimation.top;
2967         lp.width = (int) (scale * width);
2968         lp.height = (int) (scale * height);
2969 
2970         mFolderIconCanvas.drawColor(0, PorterDuff.Mode.CLEAR);
2971         fi.draw(mFolderIconCanvas);
2972         mFolderIconImageView.setImageBitmap(mFolderIconBitmap);
2973         if (fi.getFolder() != null) {
2974             mFolderIconImageView.setPivotX(fi.getFolder().getPivotXForIconAnimation());
2975             mFolderIconImageView.setPivotY(fi.getFolder().getPivotYForIconAnimation());
2976         }
2977         // Just in case this image view is still in the drag layer from a previous animation,
2978         // we remove it and re-add it.
2979         if (mDragLayer.indexOfChild(mFolderIconImageView) != -1) {
2980             mDragLayer.removeView(mFolderIconImageView);
2981         }
2982         mDragLayer.addView(mFolderIconImageView, lp);
2983         if (fi.getFolder() != null) {
2984             fi.getFolder().bringToFront();
2985         }
2986     }
2987 
2988     private void growAndFadeOutFolderIcon(FolderIcon fi) {
2989         if (fi == null) return;
2990         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0);
2991         PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.5f);
2992         PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.5f);
2993 
2994         FolderInfo info = (FolderInfo) fi.getTag();
2995         if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2996             CellLayout cl = (CellLayout) fi.getParent().getParent();
2997             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) fi.getLayoutParams();
2998             cl.setFolderLeaveBehindCell(lp.cellX, lp.cellY);
2999         }
3000 
3001         // Push an ImageView copy of the FolderIcon into the DragLayer and hide the original
3002         copyFolderIconToImage(fi);
3003         fi.setVisibility(View.INVISIBLE);
3004 
3005         ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
3006                 scaleX, scaleY);
3007         if (Utilities.isLmpOrAbove()) {
3008             oa.setInterpolator(new LogDecelerateInterpolator(100, 0));
3009         }
3010         oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
3011         oa.start();
3012     }
3013 
3014     private void shrinkAndFadeInFolderIcon(final FolderIcon fi) {
3015         if (fi == null) return;
3016         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f);
3017         PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f);
3018         PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.0f);
3019 
3020         final CellLayout cl = (CellLayout) fi.getParent().getParent();
3021 
3022         // We remove and re-draw the FolderIcon in-case it has changed
3023         mDragLayer.removeView(mFolderIconImageView);
3024         copyFolderIconToImage(fi);
3025         ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
3026                 scaleX, scaleY);
3027         oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
3028         oa.addListener(new AnimatorListenerAdapter() {
3029             @Override
3030             public void onAnimationEnd(Animator animation) {
3031                 if (cl != null) {
3032                     cl.clearFolderLeaveBehind();
3033                     // Remove the ImageView copy of the FolderIcon and make the original visible.
3034                     mDragLayer.removeView(mFolderIconImageView);
3035                     fi.setVisibility(View.VISIBLE);
3036                 }
3037             }
3038         });
3039         oa.start();
3040     }
3041 
3042     /**
3043      * Opens the user folder described by the specified tag. The opening of the folder
3044      * is animated relative to the specified View. If the View is null, no animation
3045      * is played.
3046      *
3047      * @param folderInfo The FolderInfo describing the folder to open.
3048      */
3049     public void openFolder(FolderIcon folderIcon) {
3050         Folder folder = folderIcon.getFolder();
3051         FolderInfo info = folder.mInfo;
3052 
3053         info.opened = true;
3054 
3055         // Just verify that the folder hasn&#x27;t already been added to the DragLayer.
3056         // There was a one-off crash where the folder had a parent already.
3057         if (folder.getParent() == null) {
3058             mDragLayer.addView(folder);
3059             mDragController.addDropTarget((DropTarget) folder);
3060         } else {
3061             Log.w(TAG, &quot;Opening folder (&quot; + folder + &quot;) which already has a parent (&quot; +
3062                     folder.getParent() + &quot;).&quot;);
3063         }
3064         folder.animateOpen();
3065         growAndFadeOutFolderIcon(folderIcon);
3066 
3067         // Notify the accessibility manager that this folder &quot;window&quot; has appeared and occluded
3068         // the workspace items
3069         folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3070         getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
3071     }
3072 
3073     public void closeFolder() {
3074         Folder folder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
3075         if (folder != null) {
3076             if (folder.isEditingName()) {
3077                 folder.dismissEditingName();
3078             }
3079             closeFolder(folder);
3080 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
3081 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3082 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3083             // Dismiss the folder cling</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3084             dismissFolderCling(null);</span>
3085 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3086 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3087             // Dismiss the folder cling</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3088             mLauncherClings.dismissFolderCling(null);</span>
3089 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
3090         }
3091     }
3092 
3093     void closeFolder(Folder folder) {
3094         folder.getInfo().opened = false;
3095 
3096         ViewGroup parent = (ViewGroup) folder.getParent().getParent();
3097         if (parent != null) {
3098             FolderIcon fi = (FolderIcon) mWorkspace.getViewForTag(folder.mInfo);
3099             shrinkAndFadeInFolderIcon(fi);
3100         }
3101         folder.animateClosed();
3102 
3103         // Notify the accessibility manager that this folder &quot;window&quot; has disappeard and no
3104         // longer occludeds the workspace items
3105         getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3106     }
3107 
3108     public boolean onLongClick(View v) {
3109         if (!isDraggingEnabled()) return false;
3110         if (isWorkspaceLocked()) return false;
3111         if (mState != State.WORKSPACE) return false;
3112 
3113         if (v instanceof Workspace) {
3114             if (!mWorkspace.isInOverviewMode()) {
3115                 if (mWorkspace.enterOverviewMode()) {
3116                     mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
3117                             HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
3118                     return true;
3119                 } else {
3120                     return false;
3121                 }
3122             } else {
3123                 return false;
3124             }
3125         }
3126 
3127         CellLayout.CellInfo longClickCellInfo = null;
3128         View itemUnderLongClick = null;
3129         if (v.getTag() instanceof ItemInfo) {
3130             ItemInfo info = (ItemInfo) v.getTag();
3131             longClickCellInfo = new CellLayout.CellInfo(v, info);;
3132             itemUnderLongClick = longClickCellInfo.cell;
3133         resetAddInfo();
3134         }
3135 
3136         // The hotseat touch handling does not go through Workspace, and we always allow long press
3137         // on hotseat items.
3138         final boolean inHotseat = isHotseatLayout(v);
3139         boolean allowLongPress = inHotseat || mWorkspace.allowLongPress();
3140         if (allowLongPress &amp;&amp; !mDragController.isDragging()) {
3141             if (itemUnderLongClick == null) {
3142                 // User long pressed on empty space
3143                 mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
3144                         HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
3145                 if (mWorkspace.isInOverviewMode()) {
3146                     mWorkspace.startReordering(v);
3147                 } else {
3148                     mWorkspace.enterOverviewMode();
3149                 }
3150             } else {
3151                 final boolean isAllAppsButton = inHotseat &amp;&amp; isAllAppsButtonRank(
3152                         mHotseat.getOrderInHotseat(
3153                                 longClickCellInfo.cellX,
3154                                 longClickCellInfo.cellY));
3155                 if (!(itemUnderLongClick instanceof Folder || isAllAppsButton)) {
3156                     // User long pressed on an item
3157                     mWorkspace.startDrag(longClickCellInfo);
3158                 }
3159             }
3160         }
3161         return true;
3162     }
3163 
3164     boolean isHotseatLayout(View layout) {
3165         return mHotseat != null &amp;&amp; layout != null &amp;&amp;
3166                 (layout instanceof CellLayout) &amp;&amp; (layout == mHotseat.getLayout());
3167     }
3168 
3169     /**
3170      * Returns the CellLayout of the specified container at the specified screen.
3171      */
3172     CellLayout getCellLayout(long container, long screenId) {
3173         if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
3174             if (mHotseat != null) {
3175                 return mHotseat.getLayout();
3176             } else {
3177                 return null;
3178             }
3179         } else {
3180             return (CellLayout) mWorkspace.getScreenWithId(screenId);
3181         }
3182     }
3183 
3184     public boolean isAllAppsVisible() {
3185         return (mState == State.APPS_CUSTOMIZE) || (mOnResumeState == State.APPS_CUSTOMIZE);
3186     }
3187 
3188     private void setWorkspaceBackground(boolean workspace) {
3189         mLauncherView.setBackground(workspace ?
3190                 mWorkspaceBackgroundDrawable : null);
3191     }
3192 
3193     protected void changeWallpaperVisiblity(boolean visible) {
3194         int wpflags = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
3195         int curflags = getWindow().getAttributes().flags
3196                 &amp; WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
3197         if (wpflags != curflags) {
3198             getWindow().setFlags(wpflags, WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
3199         }
3200         setWorkspaceBackground(visible);
3201     }
3202 
3203     private void dispatchOnLauncherTransitionPrepare(View v, boolean animated, boolean toWorkspace) {
3204         if (v instanceof LauncherTransitionable) {
3205             ((LauncherTransitionable) v).onLauncherTransitionPrepare(this, animated, toWorkspace);
3206         }
3207     }
3208 
3209     private void dispatchOnLauncherTransitionStart(View v, boolean animated, boolean toWorkspace) {
3210         if (v instanceof LauncherTransitionable) {
3211             ((LauncherTransitionable) v).onLauncherTransitionStart(this, animated, toWorkspace);
3212         }
3213 
3214         // Update the workspace transition step as well
3215         dispatchOnLauncherTransitionStep(v, 0f);
3216     }
3217 
3218     private void dispatchOnLauncherTransitionStep(View v, float t) {
3219         if (v instanceof LauncherTransitionable) {
3220             ((LauncherTransitionable) v).onLauncherTransitionStep(this, t);
3221         }
3222     }
3223 
3224     private void dispatchOnLauncherTransitionEnd(View v, boolean animated, boolean toWorkspace) {
3225         if (v instanceof LauncherTransitionable) {
3226             ((LauncherTransitionable) v).onLauncherTransitionEnd(this, animated, toWorkspace);
3227         }
3228 
3229         // Update the workspace transition step as well
3230         dispatchOnLauncherTransitionStep(v, 1f);
3231     }
3232 
3233     /**
3234      * Things to test when changing the following seven functions.
3235      *   - Home from workspace
3236      *          - from center screen
3237      *          - from other screens
3238      *   - Home from all apps
3239      *          - from center screen
3240      *          - from other screens
3241      *   - Back from all apps
3242      *          - from center screen
3243      *          - from other screens
3244      *   - Launch app from workspace and quit
3245      *          - with back
3246      *          - with home
3247      *   - Launch app from all apps and quit
3248      *          - with back
3249      *          - with home
3250      *   - Go to a screen that&#x27;s not the default, then all
3251      *     apps, and launch and app, and go back
3252      *          - with back
3253      *          -with home
3254      *   - On workspace, long press power and go back
3255      *          - with back
3256      *          - with home
3257      *   - On all apps, long press power and go back
3258      *          - with back
3259      *          - with home
3260      *   - On workspace, power off
3261      *   - On all apps, power off
3262      *   - Launch an app and turn off the screen while in that app
3263      *          - Go back with home key
3264      *          - Go back with back key  TODO: make this not go to workspace
3265      *          - From all apps
3266      *          - From workspace
3267      *   - Enter and exit car mode (becuase it causes an extra configuration changed)
3268      *          - From all apps
3269      *          - From the center workspace
3270      *          - From another workspace
3271      */
3272 
3273     /**
3274      * Zoom the camera out from the workspace to reveal &#x27;toView&#x27;.
3275      * Assumes that the view to show is anchored at either the very top or very bottom
3276      * of the screen.
3277      */
3278     private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded) {
3279         AppsCustomizePagedView.ContentType contentType = mAppsCustomizeContent.getContentType();
3280         showAppsCustomizeHelper(animated, springLoaded, contentType);
3281     }
3282 
3283     private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded,
3284                                          final AppsCustomizePagedView.ContentType contentType) {
3285         if (mStateAnimation != null) {
3286             mStateAnimation.setDuration(0);
3287             mStateAnimation.cancel();
3288             mStateAnimation = null;
3289         }
3290 
3291         boolean material = Utilities.isLmpOrAbove();
3292 
3293         final Resources res = getResources();
3294 
3295         final int duration = res.getInteger(R.integer.config_appsCustomizeZoomInTime);
3296         final int fadeDuration = res.getInteger(R.integer.config_appsCustomizeFadeInTime);
3297         final int revealDuration = res.getInteger(R.integer.config_appsCustomizeRevealTime);
3298         final int itemsAlphaStagger =
3299                 res.getInteger(R.integer.config_appsCustomizeItemsAlphaStagger);
3300 
3301         final float scale = (float) res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3302         final View fromView = mWorkspace;
3303         final AppsCustomizeTabHost toView = mAppsCustomizeTabHost;
3304 
3305         final ArrayList&lt;View&gt; layerViews = new ArrayList&lt;View&gt;();
3306 
3307         Workspace.State workspaceState = contentType == AppsCustomizePagedView.ContentType.Widgets ?
3308                 Workspace.State.OVERVIEW_HIDDEN : Workspace.State.NORMAL_HIDDEN;
3309         Animator workspaceAnim =
3310 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3311                 mWorkspace.getChangeStateAnimation(workspaceState, animated, layerViews);</span>
3312 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3313                 mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, animated);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3314         if (!AppsCustomizePagedView.DISABLE_ALL_APPS</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3315                 || contentType == AppsCustomizePagedView.ContentType.Widgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3316             // Set the content type for the all apps/widgets space</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3317             mAppsCustomizeTabHost.setContentTypeImmediate(contentType);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3318         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3319 </span>
3320 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3321                 mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, animated);</span>
3322 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
3323         if (!LauncherAppState.isDisableAllApps()
3324                 || contentType == AppsCustomizePagedView.ContentType.Widgets) {
3325             // Set the content type for the all apps/widgets space
3326             mAppsCustomizeTabHost.setContentTypeImmediate(contentType);
3327         }
3328 
3329         // If for some reason our views aren&#x27;t initialized, don&#x27;t animate
3330         boolean initialized = getAllAppsButton() != null;
3331 
3332         if (animated &amp;&amp; initialized) {
3333             mStateAnimation = LauncherAnimUtils.createAnimatorSet();
3334             final AppsCustomizePagedView content = (AppsCustomizePagedView)
3335                     toView.findViewById(R.id.apps_customize_pane_content);
3336 
3337             final View page = content.getPageAt(content.getCurrentPage());
3338             final View revealView = toView.findViewById(R.id.fake_page);
3339 
3340             final float initialPanelAlpha = 1f;
3341 
3342             final boolean isWidgetTray = contentType == AppsCustomizePagedView.ContentType.Widgets;
3343             if (isWidgetTray) {
3344                 revealView.setBackground(res.getDrawable(R.drawable.quantum_panel_dark));
3345             } else {
3346                 revealView.setBackground(res.getDrawable(R.drawable.quantum_panel));
3347                     }
3348 
3349             // Hide the real page background, and swap in the fake one
3350             content.setPageBackgroundsVisible(false);
3351             revealView.setVisibility(View.VISIBLE);
3352             // We need to hide this view as the animation start will be posted.
3353             revealView.setAlpha(0);
3354 
3355             int width = revealView.getMeasuredWidth();
3356             int height = revealView.getMeasuredHeight();
3357             float revealRadius = (float) Math.sqrt((width * width) / 4 + (height * height) / 4);
3358 
3359             revealView.setTranslationY(0);
3360             revealView.setTranslationX(0);
3361 
3362             // Get the y delta between the center of the page and the center of the all apps button
3363             int[] allAppsToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView,
3364                     getAllAppsButton(), null);
3365 
3366             float alpha = 0;
3367             float xDrift = 0;
3368             float yDrift = 0;
3369             if (material) {
3370                 alpha = isWidgetTray ? 0.3f : 1f;
3371                 yDrift = isWidgetTray ? height / 2 : allAppsToPanelDelta[1];
3372                 xDrift = isWidgetTray ? 0 : allAppsToPanelDelta[0];
3373             } else {
3374                 yDrift = 2 * height / 3;
3375                 xDrift = 0;
3376             }
3377             final float initAlpha = alpha;
3378 
3379             revealView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3380             layerViews.add(revealView);
3381             PropertyValuesHolder panelAlpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, initAlpha, 1f);
3382             PropertyValuesHolder panelDriftY =
3383                     PropertyValuesHolder.ofFloat(&quot;translationY&quot;, yDrift, 0);
3384             PropertyValuesHolder panelDriftX =
3385                     PropertyValuesHolder.ofFloat(&quot;translationX&quot;, xDrift, 0);
3386 
3387             ObjectAnimator panelAlphaAndDrift = ObjectAnimator.ofPropertyValuesHolder(revealView,
3388                     panelAlpha, panelDriftY, panelDriftX);
3389 
3390             panelAlphaAndDrift.setDuration(revealDuration);
3391             panelAlphaAndDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));
3392 
3393             mStateAnimation.play(panelAlphaAndDrift);
3394 
3395             if (page != null) {
3396                 page.setVisibility(View.VISIBLE);
3397                 page.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3398                 layerViews.add(page);
3399 
3400                 ObjectAnimator pageDrift = ObjectAnimator.ofFloat(page, &quot;translationY&quot;, yDrift, 0);
3401                 page.setTranslationY(yDrift);
3402                 pageDrift.setDuration(revealDuration);
3403                 pageDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));
3404                 pageDrift.setStartDelay(itemsAlphaStagger);
3405                 mStateAnimation.play(pageDrift);
3406 
3407                 page.setAlpha(0f);
3408                 ObjectAnimator itemsAlpha = ObjectAnimator.ofFloat(page, &quot;alpha&quot;, 0f, 1f);
3409                 itemsAlpha.setDuration(revealDuration);
3410                 itemsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));
3411                 itemsAlpha.setStartDelay(itemsAlphaStagger);
3412                 mStateAnimation.play(itemsAlpha);
3413             }
3414 
3415             View pageIndicators = toView.findViewById(R.id.apps_customize_page_indicator);
3416             pageIndicators.setAlpha(0.01f);
3417             ObjectAnimator indicatorsAlpha =
3418                     ObjectAnimator.ofFloat(pageIndicators, &quot;alpha&quot;, 1f);
3419             indicatorsAlpha.setDuration(revealDuration);
3420             mStateAnimation.play(indicatorsAlpha);
3421 
3422             if (material) {
3423                 final View allApps = getAllAppsButton();
3424                 int allAppsButtonSize = LauncherAppState.getInstance().
3425                         getDynamicGrid().getDeviceProfile().allAppsButtonVisualSize;
3426                 float startRadius = isWidgetTray ? 0 : allAppsButtonSize / 2;
3427                 Animator reveal = ViewAnimationUtils.createCircularReveal(revealView, width / 2,
3428                                 height / 2, startRadius, revealRadius);
3429                 reveal.setDuration(revealDuration);
3430                 reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
3431 
3432                 reveal.addListener(new AnimatorListenerAdapter() {
3433                     public void onAnimationStart(Animator animation) {
3434                         if (!isWidgetTray) {
3435                             allApps.setVisibility(View.INVISIBLE);
3436                         }
3437                     }
3438                     public void onAnimationEnd(Animator animation) {
3439                         if (!isWidgetTray) {
3440                             allApps.setVisibility(View.VISIBLE);
3441                         }
3442                 }
3443             });
3444                 mStateAnimation.play(reveal);
3445             }
3446 
3447             mStateAnimation.addListener(new AnimatorListenerAdapter() {
3448                 @Override
3449                 public void onAnimationEnd(Animator animation) {
3450                     dispatchOnLauncherTransitionEnd(fromView, animated, false);
3451                     dispatchOnLauncherTransitionEnd(toView, animated, false);
3452 
3453                     revealView.setVisibility(View.INVISIBLE);
3454                     revealView.setLayerType(View.LAYER_TYPE_NONE, null);
3455                     if (page != null) {
3456                         page.setLayerType(View.LAYER_TYPE_NONE, null);
3457                     }
3458                     content.setPageBackgroundsVisible(true);
3459 
3460                     // Hide the search bar
3461                     if (mSearchDropTargetBar != null) {
3462                         mSearchDropTargetBar.hideSearchBar(false);
3463                     }
3464                 }
3465 
3466             });
3467 
3468             if (workspaceAnim != null) {
3469                 mStateAnimation.play(workspaceAnim);
3470             }
3471 
3472             dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3473             dispatchOnLauncherTransitionPrepare(toView, animated, false);
3474             final AnimatorSet stateAnimation = mStateAnimation;
3475             final Runnable startAnimRunnable = new Runnable() {
3476                 public void run() {
3477                     // Check that mStateAnimation hasn&#x27;t changed while
3478                     // we waited for a layout/draw pass
3479                     if (mStateAnimation != stateAnimation)
3480                         return;
3481                     dispatchOnLauncherTransitionStart(fromView, animated, false);
3482                     dispatchOnLauncherTransitionStart(toView, animated, false);
3483 
3484                     revealView.setAlpha(initAlpha);
3485                     if (Utilities.isLmpOrAbove()) {
3486                         for (int i = 0; i &lt; layerViews.size(); i++) {
3487                             View v = layerViews.get(i);
3488                             if (v != null) {
3489                                 boolean attached = true;
3490                                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
3491                                     attached = v.isAttachedToWindow();
3492                                 }
3493                                 if (attached) v.buildLayer();
3494                             }
3495                         }
3496                     }
3497                     mStateAnimation.start();
3498                 }
3499             };
3500             toView.bringToFront();
3501             toView.setVisibility(View.VISIBLE);
3502             toView.post(startAnimRunnable);
3503         } else {
3504             toView.setTranslationX(0.0f);
3505             toView.setTranslationY(0.0f);
3506             toView.setScaleX(1.0f);
3507             toView.setScaleY(1.0f);
3508             toView.setVisibility(View.VISIBLE);
3509             toView.bringToFront();
3510 
3511             if (!springLoaded &amp;&amp; !LauncherAppState.getInstance().isScreenLarge()) {
3512                 // Hide the search bar
3513                 if (mSearchDropTargetBar != null) {
3514                     mSearchDropTargetBar.hideSearchBar(false);
3515                 }
3516             }
3517             dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3518             dispatchOnLauncherTransitionStart(fromView, animated, false);
3519             dispatchOnLauncherTransitionEnd(fromView, animated, false);
3520             dispatchOnLauncherTransitionPrepare(toView, animated, false);
3521             dispatchOnLauncherTransitionStart(toView, animated, false);
3522             dispatchOnLauncherTransitionEnd(toView, animated, false);
3523         }
3524     }
3525 
3526     /**
3527      * Zoom the camera back into the workspace, hiding &#x27;fromView&#x27;.
3528      * This is the opposite of showAppsCustomizeHelper.
3529      * @param animated If true, the transition will be animated.
3530      */
3531     private void hideAppsCustomizeHelper(Workspace.State toState, final boolean animated,
3532             final boolean springLoaded, final Runnable onCompleteRunnable) {
3533 
3534         if (mStateAnimation != null) {
3535             mStateAnimation.setDuration(0);
3536             mStateAnimation.cancel();
3537             mStateAnimation = null;
3538         }
3539 
3540         boolean material = Utilities.isLmpOrAbove();
3541         Resources res = getResources();
3542 
3543         final int duration = res.getInteger(R.integer.config_appsCustomizeZoomOutTime);
3544         final int fadeOutDuration = res.getInteger(R.integer.config_appsCustomizeFadeOutTime);
3545         final int revealDuration = res.getInteger(R.integer.config_appsCustomizeConcealTime);
3546         final int itemsAlphaStagger =
3547                 res.getInteger(R.integer.config_appsCustomizeItemsAlphaStagger);
3548 
3549         final float scaleFactor = (float)
3550                 res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3551         final View fromView = mAppsCustomizeTabHost;
3552         final View toView = mWorkspace;
3553         Animator workspaceAnim = null;
3554         final ArrayList&lt;View&gt; layerViews = new ArrayList&lt;View&gt;();
3555 
3556         if (toState == Workspace.State.NORMAL) {
3557             workspaceAnim = mWorkspace.getChangeStateAnimation(
3558                     toState, animated, layerViews);
3559         } else if (toState == Workspace.State.SPRING_LOADED ||
3560                 toState == Workspace.State.OVERVIEW) {
3561             workspaceAnim = mWorkspace.getChangeStateAnimation(
3562                     toState, animated, layerViews);
3563         }
3564 
3565         // If for some reason our views aren&#x27;t initialized, don&#x27;t animate
3566         boolean initialized = getAllAppsButton() != null;
3567 
3568         if (animated &amp;&amp; initialized) {
3569             mStateAnimation = LauncherAnimUtils.createAnimatorSet();
3570             if (workspaceAnim != null) {
3571                 mStateAnimation.play(workspaceAnim);
3572             }
3573 
3574             final AppsCustomizePagedView content = (AppsCustomizePagedView)
3575                     fromView.findViewById(R.id.apps_customize_pane_content);
3576 
3577             final View page = content.getPageAt(content.getNextPage());
3578 
3579             // We need to hide side pages of the Apps / Widget tray to avoid some ugly edge cases
3580             int count = content.getChildCount();
3581             for (int i = 0; i &lt; count; i++) {
3582                 View child = content.getChildAt(i);
3583                 if (child != page) {
3584                     child.setVisibility(View.INVISIBLE);
3585                 }
3586             }
3587             final View revealView = fromView.findViewById(R.id.fake_page);
3588 
3589             // hideAppsCustomizeHelper is called in some cases when it is already hidden
3590             // don&#x27;t perform all these no-op animations. In particularly, this was causing
3591             // the all-apps button to pop in and out.
3592             if (fromView.getVisibility() == View.VISIBLE) {
3593                 AppsCustomizePagedView.ContentType contentType = content.getContentType();
3594                 final boolean isWidgetTray =
3595                         contentType == AppsCustomizePagedView.ContentType.Widgets;
3596 
3597                 if (isWidgetTray) {
3598                     revealView.setBackground(res.getDrawable(R.drawable.quantum_panel_dark));
3599                 } else {
3600                     revealView.setBackground(res.getDrawable(R.drawable.quantum_panel));
3601                 }
3602 
3603                 int width = revealView.getMeasuredWidth();
3604                 int height = revealView.getMeasuredHeight();
3605                 float revealRadius = (float) Math.sqrt((width * width) / 4 + (height * height) / 4);
3606 
3607                 // Hide the real page background, and swap in the fake one
3608                 revealView.setVisibility(View.VISIBLE);
3609                 content.setPageBackgroundsVisible(false);
3610 
3611                 final View allAppsButton = getAllAppsButton();
3612                 revealView.setTranslationY(0);
3613                 int[] allAppsToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView,
3614                         allAppsButton, null);
3615 
3616                 float xDrift = 0;
3617                 float yDrift = 0;
3618                 if (material) {
3619                     yDrift = isWidgetTray ? height / 2 : allAppsToPanelDelta[1];
3620                     xDrift = isWidgetTray ? 0 : allAppsToPanelDelta[0];
3621                 } else {
3622                     yDrift = 5 * height / 4;
3623                     xDrift = 0;
3624                 }
3625 
3626                 revealView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3627                 TimeInterpolator decelerateInterpolator = material ?
3628                         new LogDecelerateInterpolator(100, 0) :
3629                         new LogDecelerateInterpolator(30, 0);
3630 
3631                 // The vertical motion of the apps panel should be delayed by one frame
3632                 // from the conceal animation in order to give the right feel. We correpsondingly
3633                 // shorten the duration so that the slide and conceal end at the same time.
3634                 ObjectAnimator panelDriftY = LauncherAnimUtils.ofFloat(revealView, &quot;translationY&quot;,
3635                         0, yDrift);
3636                 panelDriftY.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3637                 panelDriftY.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3638                 panelDriftY.setInterpolator(decelerateInterpolator);
3639                 mStateAnimation.play(panelDriftY);
3640 
3641                 ObjectAnimator panelDriftX = LauncherAnimUtils.ofFloat(revealView, &quot;translationX&quot;,
3642                         0, xDrift);
3643                 panelDriftX.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3644                 panelDriftX.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3645                 panelDriftX.setInterpolator(decelerateInterpolator);
3646                 mStateAnimation.play(panelDriftX);
3647 
3648                 if (isWidgetTray || !material) {
3649                     float finalAlpha = material ? 0.4f : 0f;
3650                     revealView.setAlpha(1f);
3651                     ObjectAnimator panelAlpha = LauncherAnimUtils.ofFloat(revealView, &quot;alpha&quot;,
3652                             1f, finalAlpha);
3653                     panelAlpha.setDuration(revealDuration);
3654                     panelAlpha.setInterpolator(material ? decelerateInterpolator :
3655                         new AccelerateInterpolator(1.5f));
3656                     mStateAnimation.play(panelAlpha);
3657                 }
3658 
3659                 if (page != null) {
3660                     page.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3661 
3662                     ObjectAnimator pageDrift = LauncherAnimUtils.ofFloat(page, &quot;translationY&quot;,
3663                             0, yDrift);
3664                     page.setTranslationY(0);
3665                     pageDrift.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3666                     pageDrift.setInterpolator(decelerateInterpolator);
3667                     pageDrift.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3668                     mStateAnimation.play(pageDrift);
3669 
3670                     page.setAlpha(1f);
3671                     ObjectAnimator itemsAlpha = LauncherAnimUtils.ofFloat(page, &quot;alpha&quot;, 1f, 0f);
3672                     itemsAlpha.setDuration(100);
3673                     itemsAlpha.setInterpolator(decelerateInterpolator);
3674                     mStateAnimation.play(itemsAlpha);
3675                 }
3676 
3677                 View pageIndicators = fromView.findViewById(R.id.apps_customize_page_indicator);
3678                 pageIndicators.setAlpha(1f);
3679                 ObjectAnimator indicatorsAlpha =
3680                         LauncherAnimUtils.ofFloat(pageIndicators, &quot;alpha&quot;, 0f);
3681                 indicatorsAlpha.setDuration(revealDuration);
3682                 indicatorsAlpha.setInterpolator(new DecelerateInterpolator(1.5f));
3683                 mStateAnimation.play(indicatorsAlpha);
3684 
3685                 width = revealView.getMeasuredWidth();
3686 
3687                 if (material) {
3688                     if (!isWidgetTray) {
3689                         allAppsButton.setVisibility(View.INVISIBLE);
3690                     }
3691                     int allAppsButtonSize = LauncherAppState.getInstance().
3692                             getDynamicGrid().getDeviceProfile().allAppsButtonVisualSize;
3693                     float finalRadius = isWidgetTray ? 0 : allAppsButtonSize / 2;
3694                     Animator reveal =
3695                             LauncherAnimUtils.createCircularReveal(revealView, width / 2,
3696                                     height / 2, revealRadius, finalRadius);
3697                     reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
3698                     reveal.setDuration(revealDuration);
3699                     reveal.setStartDelay(itemsAlphaStagger);
3700 
3701                     reveal.addListener(new AnimatorListenerAdapter() {
3702                         public void onAnimationEnd(Animator animation) {
3703                             revealView.setVisibility(View.INVISIBLE);
3704                             if (!isWidgetTray) {
3705                                 allAppsButton.setVisibility(View.VISIBLE);
3706                             }
3707                 }
3708             });
3709 
3710                     mStateAnimation.play(reveal);
3711                 }
3712 
3713             dispatchOnLauncherTransitionPrepare(fromView, animated, true);
3714             dispatchOnLauncherTransitionPrepare(toView, animated, true);
3715             mAppsCustomizeContent.stopScrolling();
3716             }
3717 
3718             mStateAnimation.addListener(new AnimatorListenerAdapter() {
3719                 @Override
3720                 public void onAnimationEnd(Animator animation) {
3721                     fromView.setVisibility(View.GONE);
3722                     dispatchOnLauncherTransitionEnd(fromView, animated, true);
3723                     dispatchOnLauncherTransitionEnd(toView, animated, true);
3724                     if (onCompleteRunnable != null) {
3725                         onCompleteRunnable.run();
3726                     }
3727 
3728                     revealView.setLayerType(View.LAYER_TYPE_NONE, null);
3729                     if (page != null) {
3730                         page.setLayerType(View.LAYER_TYPE_NONE, null);
3731                     }
3732                     content.setPageBackgroundsVisible(true);
3733                     // Unhide side pages
3734                     int count = content.getChildCount();
3735                     for (int i = 0; i &lt; count; i++) {
3736                         View child = content.getChildAt(i);
3737                         child.setVisibility(View.VISIBLE);
3738                     }
3739 
3740                     // Reset page transforms
3741                     if (page != null) {
3742                         page.setTranslationX(0);
3743                         page.setTranslationY(0);
3744                         page.setAlpha(1);
3745                     }
3746                     content.setCurrentPage(content.getNextPage());
3747 
3748                     mAppsCustomizeContent.updateCurrentPageScroll();
3749                 }
3750             });
3751 
3752             final AnimatorSet stateAnimation = mStateAnimation;
3753             final Runnable startAnimRunnable = new Runnable() {
3754                 public void run() {
3755                     // Check that mStateAnimation hasn&#x27;t changed while
3756                     // we waited for a layout/draw pass
3757                     if (mStateAnimation != stateAnimation)
3758                         return;
3759                     dispatchOnLauncherTransitionStart(fromView, animated, false);
3760                     dispatchOnLauncherTransitionStart(toView, animated, false);
3761 
3762                     if (Utilities.isLmpOrAbove()) {
3763                         for (int i = 0; i &lt; layerViews.size(); i++) {
3764                             View v = layerViews.get(i);
3765                             if (v != null) {
3766                                 boolean attached = true;
3767                                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
3768                                     attached = v.isAttachedToWindow();
3769             }
3770                                 if (attached) v.buildLayer();
3771                             }
3772                         }
3773                     }
3774                     mStateAnimation.start();
3775                 }
3776             };
3777             fromView.post(startAnimRunnable);
3778         } else {
3779             fromView.setVisibility(View.GONE);
3780             dispatchOnLauncherTransitionPrepare(fromView, animated, true);
3781             dispatchOnLauncherTransitionStart(fromView, animated, true);
3782             dispatchOnLauncherTransitionEnd(fromView, animated, true);
3783             dispatchOnLauncherTransitionPrepare(toView, animated, true);
3784             dispatchOnLauncherTransitionStart(toView, animated, true);
3785             dispatchOnLauncherTransitionEnd(toView, animated, true);
3786         }
3787     }
3788 
3789     @Override
3790     public void onTrimMemory(int level) {
3791         super.onTrimMemory(level);
3792         if (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
3793             mAppsCustomizeTabHost.onTrimMemory();
3794         }
3795     }
3796 
3797     protected void showWorkspace(boolean animated) {
3798         showWorkspace(animated, null);
3799     }
3800 
3801     protected void showWorkspace() {
3802         showWorkspace(true);
3803     }
3804 
3805     void showWorkspace(boolean animated, Runnable onCompleteRunnable) {
3806         if (mState != State.WORKSPACE || mWorkspace.getState() != Workspace.State.NORMAL) {
3807             boolean wasInSpringLoadedMode = (mState != State.WORKSPACE);
3808             mWorkspace.setVisibility(View.VISIBLE);
3809             hideAppsCustomizeHelper(Workspace.State.NORMAL, animated, false, onCompleteRunnable);
3810 
3811             // Show the search bar (only animate if we were showing the drop target bar in spring
3812             // loaded mode)
3813             if (mSearchDropTargetBar != null) {
3814                 mSearchDropTargetBar.showSearchBar(animated &amp;&amp; wasInSpringLoadedMode);
3815             }
3816 
3817             // Set focus to the AppsCustomize button
3818             if (mAllAppsButton != null) {
3819                 mAllAppsButton.requestFocus();
3820             }
3821         }
3822 
3823         // Change the state *after* we&#x27;ve called all the transition code
3824         mState = State.WORKSPACE;
3825 
3826         // Resume the auto-advance of widgets
3827         mUserPresent = true;
3828         updateRunning();
3829 
3830         // Send an accessibility event to announce the context change
3831         getWindow().getDecorView()
3832                 .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3833 
3834         onWorkspaceShown(animated);
3835     }
3836 
3837     void showOverviewMode(boolean animated) {
3838         mWorkspace.setVisibility(View.VISIBLE);
3839         hideAppsCustomizeHelper(Workspace.State.OVERVIEW, animated, false, null);
3840         mState = State.WORKSPACE;
3841         onWorkspaceShown(animated);
3842     }
3843 
3844     public void onWorkspaceShown(boolean animated) {
3845     }
3846 
3847     void showAllApps(boolean animated, AppsCustomizePagedView.ContentType contentType,
3848                      boolean resetPageToZero) {
3849         if (mState != State.WORKSPACE) return;
3850 
3851         if (resetPageToZero) {
3852             mAppsCustomizeTabHost.reset();
3853         }
3854         showAppsCustomizeHelper(animated, false, contentType);
3855         mAppsCustomizeTabHost.post(new Runnable() {
3856             @Override
3857             public void run() {
3858                 // We post this in-case the all apps view isn&#x27;t yet constructed.
3859         mAppsCustomizeTabHost.requestFocus();
3860             }
3861         });
3862 
3863         // Change the state *after* we&#x27;ve called all the transition code
3864         mState = State.APPS_CUSTOMIZE;
3865 
3866         // Pause the auto-advance of widgets until we are out of AllApps
3867         mUserPresent = false;
3868         updateRunning();
3869         closeFolder();
3870 
3871         // Send an accessibility event to announce the context change
3872         getWindow().getDecorView()
3873                 .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3874     }
3875 
3876     void enterSpringLoadedDragMode() {
3877         if (isAllAppsVisible()) {
3878             hideAppsCustomizeHelper(Workspace.State.SPRING_LOADED, true, true, null);
3879             mState = State.APPS_CUSTOMIZE_SPRING_LOADED;
3880         }
3881     }
3882 
3883     void exitSpringLoadedDragModeDelayed(final boolean successfulDrop, int delay,
3884             final Runnable onCompleteRunnable) {
3885         if (mState != State.APPS_CUSTOMIZE_SPRING_LOADED) return;
3886 
3887         mHandler.postDelayed(new Runnable() {
3888             @Override
3889             public void run() {
3890                 if (successfulDrop) {
3891                     // Before we show workspace, hide all apps again because
3892                     // exitSpringLoadedDragMode made it visible. This is a bit hacky; we should
3893                     // clean up our state transition functions
3894                     mAppsCustomizeTabHost.setVisibility(View.GONE);
3895                     showWorkspace(true, onCompleteRunnable);
3896                 } else {
3897                     exitSpringLoadedDragMode();
3898                 }
3899             }
3900         }, delay);
3901     }
3902 
3903     void exitSpringLoadedDragMode() {
3904         if (mState == State.APPS_CUSTOMIZE_SPRING_LOADED) {
3905             final boolean animated = true;
3906             final boolean springLoaded = true;
3907             showAppsCustomizeHelper(animated, springLoaded);
3908             mState = State.APPS_CUSTOMIZE;
3909         }
3910         // Otherwise, we are not in spring loaded mode, so don&#x27;t do anything.
3911     }
3912 
3913     void lockAllApps() {
3914         // TODO
3915     }
3916 
3917     void unlockAllApps() {
3918         // TODO
3919     }
3920 
3921     /**
3922      * Hides the hotseat area.
3923      */
3924     void hideHotseat(boolean animated) {
3925         if (!LauncherAppState.getInstance().isScreenLarge()) {
3926             if (animated) {
3927                 if (mHotseat.getAlpha() != 0f) {
3928                     int duration = 0;
3929                     if (mSearchDropTargetBar != null) {
3930                         duration = mSearchDropTargetBar.getTransitionOutDuration();
3931                     }
3932                     mHotseat.animate().alpha(0f).setDuration(duration);
3933                 }
3934             } else {
3935                 mHotseat.setAlpha(0f);
3936             }
3937         }
3938     }
3939 
3940     /**
3941      * Add an item from all apps or customize onto the given workspace screen.
3942      * If layout is null, add to the current screen.
3943      */
3944     void addExternalItemToScreen(ItemInfo itemInfo, final CellLayout layout) {
3945         if (!mWorkspace.addExternalItemToScreen(itemInfo, layout)) {
3946             showOutOfSpaceMessage(isHotseatLayout(layout));
3947         }
3948     }
3949 
3950     /** Maps the current orientation to an index for referencing orientation correct global icons */
3951     private int getCurrentOrientationIndexForGlobalIcons() {
3952         // default - 0, landscape - 1
3953         switch (getResources().getConfiguration().orientation) {
3954         case Configuration.ORIENTATION_LANDSCAPE:
3955             return 1;
3956         default:
3957             return 0;
3958         }
3959     }
3960 
3961     private Drawable getExternalPackageToolbarIcon(ComponentName activityName, String resourceName) {
3962         try {
3963             PackageManager packageManager = getPackageManager();
3964             // Look for the toolbar icon specified in the activity meta-data
3965             Bundle metaData = packageManager.getActivityInfo(
3966                     activityName, PackageManager.GET_META_DATA).metaData;
3967             if (metaData != null) {
3968                 int iconResId = metaData.getInt(resourceName);
3969                 if (iconResId != 0) {
3970                     Resources res = packageManager.getResourcesForActivity(activityName);
3971                     return res.getDrawable(iconResId);
3972                 }
3973             }
3974         } catch (NameNotFoundException e) {
3975             // This can happen if the activity defines an invalid drawable
3976             Log.w(TAG, &quot;Failed to load toolbar icon; &quot; + activityName.flattenToShortString() +
3977                     &quot; not found&quot;, e);
3978         } catch (Resources.NotFoundException nfe) {
3979             // This can happen if the activity defines an invalid drawable
3980             Log.w(TAG, &quot;Failed to load toolbar icon from &quot; + activityName.flattenToShortString(),
3981                     nfe);
3982         }
3983         return null;
3984     }
3985 
3986     // if successful in getting icon, return it; otherwise, set button to use default drawable
3987     private Drawable.ConstantState updateTextButtonWithIconFromExternalActivity(
3988             int buttonId, ComponentName activityName, int fallbackDrawableId,
3989             String toolbarResourceName) {
3990         Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
3991         Resources r = getResources();
3992         int w = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_width);
3993         int h = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_height);
3994 
3995         TextView button = (TextView) findViewById(buttonId);
3996         // If we were unable to find the icon via the meta-data, use a generic one
3997         if (toolbarIcon == null) {
3998             toolbarIcon = r.getDrawable(fallbackDrawableId);
3999             toolbarIcon.setBounds(0, 0, w, h);
4000             if (button != null) {
4001                 button.setCompoundDrawables(toolbarIcon, null, null, null);
4002             }
4003             return null;
4004         } else {
4005             toolbarIcon.setBounds(0, 0, w, h);
4006             if (button != null) {
4007                 button.setCompoundDrawables(toolbarIcon, null, null, null);
4008             }
4009             return toolbarIcon.getConstantState();
4010         }
4011     }
4012 
4013     // if successful in getting icon, return it; otherwise, set button to use default drawable
4014     private Drawable.ConstantState updateButtonWithIconFromExternalActivity(
4015             int buttonId, ComponentName activityName, int fallbackDrawableId,
4016             String toolbarResourceName) {
4017         ImageView button = (ImageView) findViewById(buttonId);
4018         Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
4019 
4020         if (button != null) {
4021             // If we were unable to find the icon via the meta-data, use a
4022             // generic one
4023             if (toolbarIcon == null) {
4024                 button.setImageResource(fallbackDrawableId);
4025             } else {
4026                 button.setImageDrawable(toolbarIcon);
4027             }
4028         }
4029 
4030         return toolbarIcon != null ? toolbarIcon.getConstantState() : null;
4031 
4032     }
4033 
4034     private void updateTextButtonWithDrawable(int buttonId, Drawable d) {
4035         TextView button = (TextView) findViewById(buttonId);
4036         button.setCompoundDrawables(d, null, null, null);
4037     }
4038 
4039     private void updateButtonWithDrawable(int buttonId, Drawable.ConstantState d) {
4040         ImageView button = (ImageView) findViewById(buttonId);
4041         button.setImageDrawable(d.newDrawable(getResources()));
4042     }
4043 
4044     private void invalidatePressedFocusedStates(View container, View button) {
4045         if (container instanceof HolographicLinearLayout) {
4046             HolographicLinearLayout layout = (HolographicLinearLayout) container;
4047             layout.invalidatePressedFocusedStates();
4048         } else if (button instanceof HolographicImageView) {
4049             HolographicImageView view = (HolographicImageView) button;
4050             view.invalidatePressedFocusedStates();
4051         }
4052     }
4053 
4054     public View getQsbBar() {
4055         if (mQsb == null) {
4056             mQsb = mInflater.inflate(R.layout.qsb, mSearchDropTargetBar, false);
4057             mSearchDropTargetBar.addView(mQsb);
4058         }
4059         return mQsb;
4060     }
4061 
4062     protected boolean updateGlobalSearchIcon() {
4063         final View searchButtonContainer = findViewById(R.id.search_button_container);
4064         final ImageView searchButton = (ImageView) findViewById(R.id.search_button);
4065         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4066         final View voiceButton = findViewById(R.id.voice_button);
4067 
4068         final SearchManager searchManager =
4069                 (SearchManager) getSystemService(Context.SEARCH_SERVICE);
4070         ComponentName activityName = searchManager.getGlobalSearchActivity();
4071         if (activityName != null) {
4072             int coi = getCurrentOrientationIndexForGlobalIcons();
4073             sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4074                     R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
4075                     TOOLBAR_SEARCH_ICON_METADATA_NAME);
4076             if (sGlobalSearchIcon[coi] == null) {
4077                 sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4078                         R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
4079                         TOOLBAR_ICON_METADATA_NAME);
4080             }
4081 
4082             if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.VISIBLE);
4083             searchButton.setVisibility(View.VISIBLE);
4084             invalidatePressedFocusedStates(searchButtonContainer, searchButton);
4085             return true;
4086         } else {
4087             // We disable both search and voice search when there is no global search provider
4088             if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.GONE);
4089             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
4090             if (searchButton != null) searchButton.setVisibility(View.GONE);
4091             if (voiceButton != null) voiceButton.setVisibility(View.GONE);
4092             updateVoiceButtonProxyVisible(false);
4093             return false;
4094         }
4095     }
4096 
4097     protected void updateGlobalSearchIcon(Drawable.ConstantState d) {
4098         final View searchButtonContainer = findViewById(R.id.search_button_container);
4099         final View searchButton = (ImageView) findViewById(R.id.search_button);
4100         updateButtonWithDrawable(R.id.search_button, d);
4101         invalidatePressedFocusedStates(searchButtonContainer, searchButton);
4102     }
4103 
4104     protected boolean updateVoiceSearchIcon(boolean searchVisible) {
4105         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4106         final View voiceButton = findViewById(R.id.voice_button);
4107 
4108         // We only show/update the voice search icon if the search icon is enabled as well
4109         final SearchManager searchManager =
4110                 (SearchManager) getSystemService(Context.SEARCH_SERVICE);
4111         ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
4112 
4113         ComponentName activityName = null;
4114         if (globalSearchActivity != null) {
4115             // Check if the global search activity handles voice search
4116             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
4117             intent.setPackage(globalSearchActivity.getPackageName());
4118             activityName = intent.resolveActivity(getPackageManager());
4119         }
4120 
4121         if (activityName == null) {
4122             // Fallback: check if an activity other than the global search activity
4123             // resolves this
4124             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
4125             activityName = intent.resolveActivity(getPackageManager());
4126         }
4127         if (searchVisible &amp;&amp; activityName != null) {
4128             int coi = getCurrentOrientationIndexForGlobalIcons();
4129             sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4130                     R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
4131                     TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME);
4132             if (sVoiceSearchIcon[coi] == null) {
4133                 sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4134                         R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
4135                         TOOLBAR_ICON_METADATA_NAME);
4136             }
4137             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.VISIBLE);
4138             voiceButton.setVisibility(View.VISIBLE);
4139             updateVoiceButtonProxyVisible(false);
4140             invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
4141             return true;
4142         } else {
4143             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
4144             if (voiceButton != null) voiceButton.setVisibility(View.GONE);
4145             updateVoiceButtonProxyVisible(false);
4146             return false;
4147         }
4148     }
4149 
4150     protected void updateVoiceSearchIcon(Drawable.ConstantState d) {
4151         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4152         final View voiceButton = findViewById(R.id.voice_button);
4153         updateButtonWithDrawable(R.id.voice_button, d);
4154         invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
4155     }
4156 
4157     public void updateVoiceButtonProxyVisible(boolean forceDisableVoiceButtonProxy) {
4158         final View voiceButtonProxy = findViewById(R.id.voice_button_proxy);
4159         if (voiceButtonProxy != null) {
4160             boolean visible = !forceDisableVoiceButtonProxy &amp;&amp;
4161                     mWorkspace.shouldVoiceButtonProxyBeVisible();
4162             voiceButtonProxy.setVisibility(visible ? View.VISIBLE : View.GONE);
4163             voiceButtonProxy.bringToFront();
4164         }
4165     }
4166 
4167     /**
<abbr title="4168      * This is an overrid eot disable the voice button proxy.  If disabled is true, then the voice button proxy">4168      * This is an overrid eot disable the voice button proxy.  If disabled is true, then the voice button🔵</abbr>
4169      * will be hidden regardless of what shouldVoiceButtonProxyBeVisible() returns.
4170      */
4171     public void disableVoiceButtonProxy(boolean disabled) {
4172         updateVoiceButtonProxyVisible(disabled);
4173     }
4174 
4175     @Override
4176     public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
4177         final boolean result = super.dispatchPopulateAccessibilityEvent(event);
4178         final List&lt;CharSequence&gt; text = event.getText();
4179         text.clear();
4180         // Populate event with a fake title based on the current state.
4181         if (mState == State.APPS_CUSTOMIZE) {
4182             text.add(mAppsCustomizeTabHost.getContentTag());
4183         } else {
4184             text.add(getString(R.string.all_apps_home_button_label));
4185         }
4186         return result;
4187     }
4188 
4189     /**
4190      * Receives notifications when system dialogs are to be closed.
4191      */
4192     private class CloseSystemDialogsIntentReceiver extends BroadcastReceiver {
4193         @Override
4194         public void onReceive(Context context, Intent intent) {
4195             closeSystemDialogs();
4196         }
4197     }
4198 
4199     /**
4200      * Receives notifications whenever the appwidgets are reset.
4201      */
4202     private class AppWidgetResetObserver extends ContentObserver {
4203         public AppWidgetResetObserver() {
4204             super(new Handler());
4205         }
4206 
4207         @Override
4208         public void onChange(boolean selfChange) {
4209             onAppWidgetReset();
4210         }
4211     }
4212 
4213     /**
4214      * If the activity is currently paused, signal that we need to run the passed Runnable
4215      * in onResume.
4216      *
4217      * This needs to be called from incoming places where resources might have been loaded
4218      * while we are paused.  That is becaues the Configuration might be wrong
4219      * when we&#x27;re not running, and if it comes back to what it was when we
4220      * were paused, we are not restarted.
4221      *
4222      * Implementation of the method from LauncherModel.Callbacks.
4223      *
4224      * @return true if we are currently paused.  The caller might be able to
4225      * skip some work in that case since we will come back again.
4226      */
4227     private boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) {
4228         if (mPaused) {
4229             Log.i(TAG, &quot;Deferring update until onResume&quot;);
4230             if (deletePreviousRunnables) {
4231                 while (mBindOnResumeCallbacks.remove(run)) {
4232                 }
4233             }
4234             mBindOnResumeCallbacks.add(run);
4235             return true;
4236         } else {
4237             return false;
4238         }
4239     }
4240 
4241     private boolean waitUntilResume(Runnable run) {
4242         return waitUntilResume(run, false);
4243     }
4244 
4245     public void addOnResumeCallback(Runnable run) {
4246         mOnResumeCallbacks.add(run);
4247     }
4248 
4249     /**
4250      * If the activity is currently paused, signal that we need to re-run the loader
4251      * in onResume.
4252      *
4253      * This needs to be called from incoming places where resources might have been loaded
4254      * while we are paused.  That is becaues the Configuration might be wrong
4255      * when we&#x27;re not running, and if it comes back to what it was when we
4256      * were paused, we are not restarted.
4257      *
4258      * Implementation of the method from LauncherModel.Callbacks.
4259      *
4260      * @return true if we are currently paused.  The caller might be able to
4261      * skip some work in that case since we will come back again.
4262      */
4263     public boolean setLoadOnResume() {
4264         if (mPaused) {
4265             Log.i(TAG, &quot;setLoadOnResume&quot;);
4266             mOnResumeNeedsLoad = true;
4267             return true;
4268         } else {
4269             return false;
4270         }
4271     }
4272 
4273     /**
4274      * Implementation of the method from LauncherModel.Callbacks.
4275      */
4276     public int getCurrentWorkspaceScreen() {
4277         if (mWorkspace != null) {
4278             return mWorkspace.getCurrentPage();
4279         } else {
4280             return SCREEN_COUNT / 2;
4281         }
4282     }
4283 
4284     /**
4285      * Refreshes the shortcuts shown on the workspace.
4286      *
4287      * Implementation of the method from LauncherModel.Callbacks.
4288      */
4289     public void startBinding() {
4290         setWorkspaceLoading(true);
4291 
4292         // If we&#x27;re starting binding all over again, clear any bind calls we&#x27;d postponed in
4293         // the past (see waitUntilResume) -- we don&#x27;t need them since we&#x27;re starting binding
4294         // from scratch again
4295         mBindOnResumeCallbacks.clear();
4296 
4297         // Clear the workspace because it&#x27;s going to be rebound
4298         mWorkspace.clearDropTargets();
4299         mWorkspace.removeAllWorkspaceScreens();
4300 
4301         mWidgetsToAdvance.clear();
4302         if (mHotseat != null) {
4303             mHotseat.resetLayout();
4304         }
4305     }
4306 
4307     @Override
4308     public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
4309         bindAddScreens(orderedScreenIds);
4310 
4311         // If there are no screens, we need to have an empty screen
4312         if (orderedScreenIds.size() == 0) {
4313             mWorkspace.addExtraEmptyScreen();
4314         }
4315 
4316         // Create the custom content page (this call updates mDefaultScreen which calls
4317         // setCurrentPage() so ensure that all pages are added before calling this).
4318         if (hasCustomContentToLeft()) {
4319             mWorkspace.createCustomContentContainer();
4320             populateCustomContentContainer();
4321         }
4322     }
4323 
4324     @Override
4325     public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
4326         // Log to disk
4327         Launcher.addDumpLog(TAG, &quot;11683562 - bindAddScreens()&quot;, true);
4328         Launcher.addDumpLog(TAG, &quot;11683562 -   orderedScreenIds: &quot; +
4329                 TextUtils.join(&quot;, &quot;, orderedScreenIds), true);
4330         int count = orderedScreenIds.size();
4331         for (int i = 0; i &lt; count; i++) {
4332             mWorkspace.insertNewWorkspaceScreenBeforeEmptyScreen(orderedScreenIds.get(i));
4333         }
4334     }
4335 
4336     private boolean shouldShowWeightWatcher() {
4337         String spKey = LauncherAppState.getSharedPreferencesKey();
4338         SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
4339         boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, SHOW_WEIGHT_WATCHER_DEFAULT);
4340 
4341         return show;
4342     }
4343 
4344     private void toggleShowWeightWatcher() {
4345         String spKey = LauncherAppState.getSharedPreferencesKey();
4346         SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
4347         boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, true);
4348 
4349         show = !show;
4350 
4351         SharedPreferences.Editor editor = sp.edit();
4352         editor.putBoolean(SHOW_WEIGHT_WATCHER, show);
4353         editor.commit();
4354 
4355         if (mWeightWatcher != null) {
4356             mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
4357         }
4358     }
4359 
4360     public void bindAppsAdded(final ArrayList&lt;Long&gt; newScreens,
4361                               final ArrayList&lt;ItemInfo&gt; addNotAnimated,
4362                               final ArrayList&lt;ItemInfo&gt; addAnimated,
4363                               final ArrayList&lt;AppInfo&gt; addedApps) {
4364         Runnable r = new Runnable() {
4365             public void run() {
4366                 bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
4367             }
4368         };
4369         if (waitUntilResume(r)) {
4370             return;
4371         }
4372 
4373         // Add the new screens
4374         if (newScreens != null) {
4375         bindAddScreens(newScreens);
4376         }
4377 
4378         // We add the items without animation on non-visible pages, and with
4379         // animations on the new page (which we will try and snap to).
4380         if (addNotAnimated != null &amp;&amp; !addNotAnimated.isEmpty()) {
4381             bindItems(addNotAnimated, 0,
4382                     addNotAnimated.size(), false);
4383         }
4384         if (addAnimated != null &amp;&amp; !addAnimated.isEmpty()) {
4385             bindItems(addAnimated, 0,
4386                     addAnimated.size(), true);
4387         }
4388 
4389         // Remove the extra empty screen
4390         mWorkspace.removeExtraEmptyScreen(false, false);
4391 
4392         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4393                 addedApps != null &amp;&amp; mAppsCustomizeContent != null) {
4394             mAppsCustomizeContent.addApps(addedApps);
4395         }
4396     }
4397 
4398     /**
4399      * Bind the items start-end from the list.
4400      *
4401      * Implementation of the method from LauncherModel.Callbacks.
4402      */
4403     public void bindItems(final ArrayList&lt;ItemInfo&gt; shortcuts, final int start, final int end,
4404                           final boolean forceAnimateIcons) {
4405         Runnable r = new Runnable() {
4406             public void run() {
4407                 bindItems(shortcuts, start, end, forceAnimateIcons);
4408             }
4409         };
4410         if (waitUntilResume(r)) {
4411             return;
4412         }
4413 
4414         // Get the list of added shortcuts and intersect them with the set of shortcuts here
4415         final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
4416         final Collection&lt;Animator&gt; bounceAnims = new ArrayList&lt;Animator&gt;();
4417         final boolean animateIcons = forceAnimateIcons &amp;&amp; canRunNewAppsAnimation();
4418         Workspace workspace = mWorkspace;
4419         long newShortcutsScreenId = -1;
4420         for (int i = start; i &lt; end; i++) {
4421             final ItemInfo item = shortcuts.get(i);
4422 
4423             // Short circuit if we are loading dock items for a configuration which has no dock
4424             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
4425                     mHotseat == null) {
4426                 continue;
4427             }
4428 
4429             switch (item.itemType) {
4430                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
4431                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
4432                     ShortcutInfo info = (ShortcutInfo) item;
4433                     View shortcut = createShortcut(info);
4434 
4435                     /*
4436                      * TODO: FIX collision case
4437                      */
4438                     if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
4439                         CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
4440                         if (cl != null &amp;&amp; cl.isOccupied(item.cellX, item.cellY)) {
4441                             View v = cl.getChildAt(item.cellX, item.cellY);
4442                             Object tag = v.getTag();
4443                             String desc = &quot;Collision while binding workspace item: &quot; + item
4444                                     + &quot;. Collides with &quot; + tag;
4445                             if (LauncherAppState.isDogfoodBuild()) {
4446                                 throw (new RuntimeException(desc));
4447                             } else {
4448                                 Log.d(TAG, desc);
4449                             }
4450                         }
4451                     }
4452 
4453                     workspace.addInScreenFromBind(shortcut, item.container, item.screenId, item.cellX,
4454                             item.cellY, 1, 1);
4455                     if (animateIcons) {
4456                         // Animate all the applications up now
4457                         shortcut.setAlpha(0f);
4458                         shortcut.setScaleX(0f);
4459                         shortcut.setScaleY(0f);
4460                         bounceAnims.add(createNewAppBounceAnimation(shortcut, i));
4461                         newShortcutsScreenId = item.screenId;
4462                     }
4463                     break;
4464                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
4465                     FolderIcon newFolder = FolderIcon.fromXml(R.layout.folder_icon, this,
4466                             (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()),
4467                             (FolderInfo) item, mIconCache);
4468                     workspace.addInScreenFromBind(newFolder, item.container, item.screenId, item.cellX,
4469                             item.cellY, 1, 1);
4470                     break;
4471                 default:
4472                     throw new RuntimeException(&quot;Invalid Item Type&quot;);
4473             }
4474         }
4475 
4476         if (animateIcons) {
4477             // Animate to the correct page
4478             if (newShortcutsScreenId &gt; -1) {
4479                 long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
4480                 final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
4481                 final Runnable startBounceAnimRunnable = new Runnable() {
4482                     public void run() {
4483                         anim.playTogether(bounceAnims);
4484                         anim.start();
4485                     }
4486                 };
4487                 if (newShortcutsScreenId != currentScreenId) {
4488                     // We post the animation slightly delayed to prevent slowdowns
4489                     // when we are loading right after we return to launcher.
4490                     mWorkspace.postDelayed(new Runnable() {
4491                         public void run() {
4492                             if (mWorkspace != null) {
4493                             mWorkspace.snapToPage(newScreenIndex);
4494                             mWorkspace.postDelayed(startBounceAnimRunnable,
4495                                     NEW_APPS_ANIMATION_DELAY);
4496                         }
4497                         }
4498                     }, NEW_APPS_PAGE_MOVE_DELAY);
4499                 } else {
4500                     mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
4501                 }
4502             }
4503         }
4504         workspace.requestLayout();
4505     }
4506 
4507     /**
4508      * Implementation of the method from LauncherModel.Callbacks.
4509      */
4510     public void bindFolders(final HashMap&lt;Long, FolderInfo&gt; folders) {
4511         Runnable r = new Runnable() {
4512             public void run() {
4513                 bindFolders(folders);
4514             }
4515         };
4516         if (waitUntilResume(r)) {
4517             return;
4518         }
4519         sFolders.clear();
4520         sFolders.putAll(folders);
4521     }
4522 
4523     /**
4524      * Add the views for a widget to the workspace.
4525      *
4526      * Implementation of the method from LauncherModel.Callbacks.
4527      */
4528     public void bindAppWidget(final LauncherAppWidgetInfo item) {
4529         Runnable r = new Runnable() {
4530             public void run() {
4531                 bindAppWidget(item);
4532             }
4533         };
4534         if (waitUntilResume(r)) {
4535             return;
4536         }
4537 
4538         final long start = DEBUG_WIDGETS ? SystemClock.uptimeMillis() : 0;
4539         if (DEBUG_WIDGETS) {
4540             Log.d(TAG, &quot;bindAppWidget: &quot; + item);
4541         }
4542         final Workspace workspace = mWorkspace;
4543 
4544         AppWidgetProviderInfo appWidgetInfo;
4545         if (((item.restoreStatus &amp; LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0) &amp;&amp;
4546                 ((item.restoreStatus &amp; LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) != 0)) {
4547 
4548             appWidgetInfo = mModel.findAppWidgetProviderInfoWithComponent(this, item.providerName);
4549             if (appWidgetInfo == null) {
4550                 if (DEBUG_WIDGETS) {
4551                     Log.d(TAG, &quot;Removing restored widget: id=&quot; + item.appWidgetId
4552                             + &quot; belongs to component &quot; + item.providerName
4553                             + &quot;, as the povider is null&quot;);
4554                 }
4555                 LauncherModel.deleteItemFromDatabase(this, item);
4556                 return;
4557             }
4558             // Note: This assumes that the id remap broadcast is received before this step.
4559             // If that is not the case, the id remap will be ignored and user may see the
4560             // click to setup view.
4561             PendingAddWidgetInfo pendingInfo = new PendingAddWidgetInfo(appWidgetInfo, null, null);
4562             pendingInfo.spanX = item.spanX;
4563             pendingInfo.spanY = item.spanY;
4564             pendingInfo.minSpanX = item.minSpanX;
4565             pendingInfo.minSpanY = item.minSpanY;
4566             Bundle options =
4567                     AppsCustomizePagedView.getDefaultOptionsForWidget(this, pendingInfo);
4568 
4569             int newWidgetId = mAppWidgetHost.allocateAppWidgetId();
4570             boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
4571                     newWidgetId, appWidgetInfo, options);
4572 
4573             // TODO consider showing a permission dialog when the widget is clicked.
4574             if (!success) {
4575                 mAppWidgetHost.deleteAppWidgetId(newWidgetId);
4576                 if (DEBUG_WIDGETS) {
4577                     Log.d(TAG, &quot;Removing restored widget: id=&quot; + item.appWidgetId
4578                             + &quot; belongs to component &quot; + item.providerName
4579                             + &quot;, as the launcher is unable to bing a new widget id&quot;);
4580                 }
4581                 LauncherModel.deleteItemFromDatabase(this, item);
4582                 return;
4583             }
4584 
4585             item.appWidgetId = newWidgetId;
4586 
4587             // If the widget has a configure activity, it is still needs to set it up, otherwise
4588             // the widget is ready to go.
4589             item.restoreStatus = (appWidgetInfo.configure == null)
4590                     ? LauncherAppWidgetInfo.RESTORE_COMPLETED
4591                     : LauncherAppWidgetInfo.FLAG_UI_NOT_READY;
4592 
4593             LauncherModel.updateItemInDatabase(this, item);
4594         }
4595 
4596         if (item.restoreStatus == LauncherAppWidgetInfo.RESTORE_COMPLETED) {
4597         final int appWidgetId = item.appWidgetId;
4598             appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
4599         if (DEBUG_WIDGETS) {
<abbr title="4600             Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.provider);">4600             Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo🔵</abbr>
4601         }
4602 
4603         item.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);
4604         } else {
4605             appWidgetInfo = null;
4606             PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item);
4607             view.updateIcon(mIconCache);
4608             item.hostView = view;
4609             item.hostView.updateAppWidget(null);
4610             item.hostView.setOnClickListener(this);
4611         }
4612 
4613         item.hostView.setTag(item);
4614         item.onBindAppWidget(this);
4615 
4616         workspace.addInScreen(item.hostView, item.container, item.screenId, item.cellX,
4617                 item.cellY, item.spanX, item.spanY, false);
4618         addWidgetToAutoAdvanceIfNeeded(item.hostView, appWidgetInfo);
4619 
4620         workspace.requestLayout();
4621 
4622         if (DEBUG_WIDGETS) {
4623             Log.d(TAG, &quot;bound widget id=&quot;+item.appWidgetId+&quot; in &quot;
4624                     + (SystemClock.uptimeMillis()-start) + &quot;ms&quot;);
4625         }
4626     }
4627 
4628     /**
4629      * Restores a pending widget.
4630      *
4631      * @param appWidgetId The app widget id
4632      * @param cellInfo The position on screen where to create the widget.
4633      */
4634     private void completeRestoreAppWidget(final int appWidgetId) {
4635         LauncherAppWidgetHostView view = mWorkspace.getWidgetForAppWidgetId(appWidgetId);
4636         if ((view == null) || !(view instanceof PendingAppWidgetHostView)) {
4637             Log.e(TAG, &quot;Widget update called, when the widget no longer exists.&quot;);
4638             return;
4639         }
4640 
4641         LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) view.getTag();
4642         info.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;
4643 
4644         mWorkspace.reinflateWidgetsIfNecessary();
4645         LauncherModel.updateItemInDatabase(this, info);
4646     }
4647 
4648     public void onPageBoundSynchronously(int page) {
4649         mSynchronouslyBoundPages.add(page);
4650     }
4651 
4652     /**
4653      * Callback saying that there aren&#x27;t any more items to bind.
4654      *
4655      * Implementation of the method from LauncherModel.Callbacks.
4656      */
4657     public void finishBindingItems(final boolean upgradePath) {
4658         Runnable r = new Runnable() {
4659             public void run() {
4660                 finishBindingItems(upgradePath);
4661             }
4662         };
4663         if (waitUntilResume(r)) {
4664             return;
4665         }
4666         if (mSavedState != null) {
4667             if (!mWorkspace.hasFocus()) {
4668                 mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
4669             }
4670             mSavedState = null;
4671         }
4672 
4673         mWorkspace.restoreInstanceStateForRemainingPages();
4674 
4675         setWorkspaceLoading(false);
4676         sendLoadingCompleteBroadcastIfNecessary();
4677 
4678         // If we received the result of any pending adds while the loader was running (e.g. the
4679         // widget configuration forced an orientation change), process them now.
4680         if (sPendingAddItem != null) {
4681             final long screenId = completeAdd(sPendingAddItem);
4682 
4683             // TODO: this moves the user to the page where the pending item was added. Ideally,
4684             // the screen would be guaranteed to exist after bind, and the page would be set through
4685             // the workspace restore process.
4686             mWorkspace.post(new Runnable() {
4687                 @Override
4688                 public void run() {
4689                     mWorkspace.snapToScreenId(screenId);
4690                 }
4691             });
4692             sPendingAddItem = null;
4693         }
4694 
4695         if (upgradePath) {
4696             mWorkspace.getUniqueComponents(true, null);
4697             mIntentsOnWorkspaceFromUpgradePath = mWorkspace.getUniqueComponents(true, null);
4698         }
4699         PackageInstallerCompat.getInstance(this).onFinishBind();
4700         mModel.recheckRestoredItems(this);
4701     }
4702 
4703     private void sendLoadingCompleteBroadcastIfNecessary() {
4704         if (!mSharedPrefs.getBoolean(FIRST_LOAD_COMPLETE, false)) {
4705             String permission =
4706                     getResources().getString(R.string.receive_first_load_broadcast_permission);
4707             Intent intent = new Intent(ACTION_FIRST_LOAD_COMPLETE);
4708             sendBroadcast(intent, permission);
4709             SharedPreferences.Editor editor = mSharedPrefs.edit();
4710             editor.putBoolean(FIRST_LOAD_COMPLETE, true);
4711             editor.apply();
4712         }
4713     }
4714 
4715     public boolean isAllAppsButtonRank(int rank) {
4716         if (mHotseat != null) {
4717             return mHotseat.isAllAppsButtonRank(rank);
4718         }
4719         return false;
4720     }
4721 
4722     private boolean canRunNewAppsAnimation() {
4723         long diff = System.currentTimeMillis() - mDragController.getLastGestureUpTime();
4724         return diff &gt; (NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS * 1000);
4725     }
4726 
4727     private ValueAnimator createNewAppBounceAnimation(View v, int i) {
4728         ValueAnimator bounceAnim = LauncherAnimUtils.ofPropertyValuesHolder(v,
4729                 PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1f),
4730                 PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f),
4731                 PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f));
4732         bounceAnim.setDuration(InstallShortcutReceiver.NEW_SHORTCUT_BOUNCE_DURATION);
4733         bounceAnim.setStartDelay(i * InstallShortcutReceiver.NEW_SHORTCUT_STAGGER_DELAY);
4734         bounceAnim.setInterpolator(new SmoothPagedView.OvershootInterpolator());
4735         return bounceAnim;
4736     }
4737 
4738     public boolean useVerticalBarLayout() {
4739         return LauncherAppState.getInstance().getDynamicGrid().
4740                 getDeviceProfile().isVerticalBarLayout();
4741     }
4742 
4743     protected Rect getSearchBarBounds() {
4744         return LauncherAppState.getInstance().getDynamicGrid().
4745                 getDeviceProfile().getSearchBarBounds();
4746     }
4747 
4748     @Override
4749     public void bindSearchablesChanged() {
4750         boolean searchVisible = updateGlobalSearchIcon();
4751         boolean voiceVisible = updateVoiceSearchIcon(searchVisible);
4752         if (mSearchDropTargetBar != null) {
4753             mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
4754         }
4755     }
4756 
4757     /**
4758      * Add the icons for all apps.
4759      *
4760      * Implementation of the method from LauncherModel.Callbacks.
4761      */
4762     public void bindAllApplications(final ArrayList&lt;AppInfo&gt; apps) {
4763         if (LauncherAppState.isDisableAllApps()) {
4764             if (mIntentsOnWorkspaceFromUpgradePath != null) {
4765                 if (LauncherModel.UPGRADE_USE_MORE_APPS_FOLDER) {
4766                     getHotseat().addAllAppsFolder(mIconCache, apps,
4767                             mIntentsOnWorkspaceFromUpgradePath, Launcher.this, mWorkspace);
4768                 }
4769                 mIntentsOnWorkspaceFromUpgradePath = null;
4770             }
4771             if (mAppsCustomizeContent != null) {
4772                 mAppsCustomizeContent.onPackagesUpdated(
4773                         LauncherModel.getSortedWidgetsAndShortcuts(this));
4774             }
4775         } else {
4776             if (mAppsCustomizeContent != null) {
4777                 mAppsCustomizeContent.setApps(apps);
4778                 mAppsCustomizeContent.onPackagesUpdated(
4779                         LauncherModel.getSortedWidgetsAndShortcuts(this));
4780             }
4781         }
4782     }
4783 
4784     /**
4785      * A package was updated.
4786      *
4787      * Implementation of the method from LauncherModel.Callbacks.
4788      */
4789     public void bindAppsUpdated(final ArrayList&lt;AppInfo&gt; apps) {
4790         Runnable r = new Runnable() {
4791             public void run() {
4792                 bindAppsUpdated(apps);
4793             }
4794         };
4795         if (waitUntilResume(r)) {
4796             return;
4797         }
4798 
4799         if (mWorkspace != null) {
4800             mWorkspace.updateShortcutsAndWidgets(apps);
4801         }
4802 
4803         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4804                 mAppsCustomizeContent != null) {
4805             mAppsCustomizeContent.updateApps(apps);
4806         }
4807     }
4808 
4809     /**
4810      * Packages were restored
4811      */
4812     public void bindAppsRestored(final ArrayList&lt;AppInfo&gt; apps) {
4813         Runnable r = new Runnable() {
4814             public void run() {
4815                 bindAppsRestored(apps);
4816             }
4817         };
4818         if (waitUntilResume(r)) {
4819             return;
4820         }
4821 
4822         if (mWorkspace != null) {
4823             mWorkspace.updateShortcutsAndWidgets(apps);
4824         }
4825     }
4826 
4827     /**
4828      * Update the state of a package, typically related to install state.
4829      *
4830      * Implementation of the method from LauncherModel.Callbacks.
4831      */
4832     @Override
4833     public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo) {
4834         if (mWorkspace != null) {
4835             mWorkspace.updatePackageState(installInfo);
4836         }
4837     }
4838 
4839     /**
4840      * Update the label and icon of all the icons in a package
4841      *
4842      * Implementation of the method from LauncherModel.Callbacks.
4843      */
4844     @Override
4845     public void updatePackageBadge(String packageName) {
4846         if (mWorkspace != null) {
4847             mWorkspace.updatePackageBadge(packageName, UserHandleCompat.myUserHandle());
4848         }
4849     }
4850 
4851     /**
4852      * A package was uninstalled.  We take both the super set of packageNames
4853      * in addition to specific applications to remove, the reason being that
4854      * this can be called when a package is updated as well.  In that scenario,
4855      * we only remove specific components from the workspace, where as
4856      * package-removal should clear all items by package name.
4857      *
4858      * Implementation of the method from LauncherModel.Callbacks.
4859      */
4860     public void bindComponentsRemoved(final ArrayList&lt;String&gt; packageNames,
4861             final ArrayList&lt;AppInfo&gt; appInfos, final UserHandleCompat user) {
4862         Runnable r = new Runnable() {
4863             public void run() {
4864                 bindComponentsRemoved(packageNames, appInfos, user);
4865             }
4866         };
4867         if (waitUntilResume(r)) {
4868             return;
4869         }
4870 
4871         if (!packageNames.isEmpty()) {
4872             mWorkspace.removeItemsByPackageName(packageNames, user);
4873         }
4874         if (!appInfos.isEmpty()) {
4875             mWorkspace.removeItemsByApplicationInfo(appInfos, user);
4876         }
4877 
4878         // Notify the drag controller
4879         mDragController.onAppsRemoved(packageNames, appInfos);
4880 
4881         // Update AllApps
4882         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4883                 mAppsCustomizeContent != null) {
4884             mAppsCustomizeContent.removeApps(appInfos);
4885         }
4886     }
4887 
4888     /**
4889      * A number of packages were updated.
4890      */
4891     private ArrayList&lt;Object&gt; mWidgetsAndShortcuts;
4892     private Runnable mBindPackagesUpdatedRunnable = new Runnable() {
4893             public void run() {
4894                 bindPackagesUpdated(mWidgetsAndShortcuts);
4895                 mWidgetsAndShortcuts = null;
4896             }
4897         };
4898     public void bindPackagesUpdated(final ArrayList&lt;Object&gt; widgetsAndShortcuts) {
4899         if (waitUntilResume(mBindPackagesUpdatedRunnable, true)) {
4900             mWidgetsAndShortcuts = widgetsAndShortcuts;
4901             return;
4902         }
4903 
4904         // Update the widgets pane
4905         if (mAppsCustomizeContent != null) {
4906             mAppsCustomizeContent.onPackagesUpdated(widgetsAndShortcuts);
4907         }
4908     }
4909 
4910     private int mapConfigurationOriActivityInfoOri(int configOri) {
4911         final Display d = getWindowManager().getDefaultDisplay();
4912         int naturalOri = Configuration.ORIENTATION_LANDSCAPE;
4913         switch (d.getRotation()) {
4914         case Surface.ROTATION_0:
4915         case Surface.ROTATION_180:
4916             // We are currently in the same basic orientation as the natural orientation
4917             naturalOri = configOri;
4918             break;
4919         case Surface.ROTATION_90:
4920         case Surface.ROTATION_270:
4921             // We are currently in the other basic orientation to the natural orientation
4922             naturalOri = (configOri == Configuration.ORIENTATION_LANDSCAPE) ?
4923                     Configuration.ORIENTATION_PORTRAIT : Configuration.ORIENTATION_LANDSCAPE;
4924             break;
4925         }
4926 
4927         int[] oriMap = {
4928                 ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
4929                 ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE,
4930                 ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
4931                 ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
4932         };
4933         // Since the map starts at portrait, we need to offset if this device&#x27;s natural orientation
4934         // is landscape.
4935         int indexOffset = 0;
4936         if (naturalOri == Configuration.ORIENTATION_LANDSCAPE) {
4937             indexOffset = 1;
4938         }
4939         return oriMap[(d.getRotation() + indexOffset) % 4];
4940     }
4941 
4942     public boolean isRotationEnabled() {
4943         boolean enableRotation = sForceEnableRotation ||
4944                 getResources().getBoolean(R.bool.allow_rotation);
4945         return enableRotation;
4946     }
4947     public void lockScreenOrientation() {
4948         if (isRotationEnabled()) {
4949             setRequestedOrientation(mapConfigurationOriActivityInfoOri(getResources()
4950                     .getConfiguration().orientation));
4951         }
4952     }
4953     public void unlockScreenOrientation(boolean immediate) {
4954         if (isRotationEnabled()) {
4955             if (immediate) {
4956                 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
4957             } else {
4958                 mHandler.postDelayed(new Runnable() {
4959                     public void run() {
4960                         setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
4961                     }
4962                 }, mRestoreScreenOrientationDelay);
4963             }
4964         }
4965     }
4966 
4967     /**
4968      * Called when the SearchBar hint should be changed.
4969      *
4970      * @param hint the hint to be displayed in the search bar.
4971      */
4972     protected void onSearchBarHintChanged(String hint) {
4973 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4974 </span>
4975 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4976         Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
4977 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">4978         mLauncherClings.updateSearchBarHint(hint);</span>
4979 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
4980     }
4981 
4982     protected boolean isLauncherPreinstalled() {
4983         PackageManager pm = getPackageManager();
4984         try {
4985             ApplicationInfo ai = pm.getApplicationInfo(getComponentName().getPackageName(), 0);
4986             if ((ai.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
4987                 return true;
4988             } else {
4989                 return false;
4990             }
4991         } catch (NameNotFoundException e) {
4992             e.printStackTrace();
4993             return false;
4994         }
4995     }
4996 
4997     /**
4998      * This method indicates whether or not we should suggest default wallpaper dimensions
4999      * when our wallpaper cropper was not yet used to set a wallpaper.
5000      */
5001     protected boolean overrideWallpaperDimensions() {
5002         return true;
5003     }
5004 
5005     protected boolean shouldClingFocusHotseatApp() {
5006         return false;
5007     }
5008     protected String getFirstRunClingSearchBarHint() {
5009         return &quot;&quot;;
5010     }
5011     protected String getFirstRunCustomContentHint() {
5012         return &quot;&quot;;
5013     }
5014     protected int getFirstRunFocusedHotseatAppDrawableId() {
5015         return -1;
5016     }
5017     protected ComponentName getFirstRunFocusedHotseatAppComponentName() {
5018         return null;
5019     }
5020     protected int getFirstRunFocusedHotseatAppRank() {
5021         return -1;
5022     }
5023     protected String getFirstRunFocusedHotseatAppBubbleTitle() {
5024         return &quot;&quot;;
5025     }
5026     protected String getFirstRunFocusedHotseatAppBubbleDescription() {
5027         return &quot;&quot;;
5028     }
5029 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
5030 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5031 public void dismissFirstRunCling(View v) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5032         Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5033         Runnable cb = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5034             public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5035                 // Show the workspace cling next</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5036                 showFirstRunWorkspaceCling();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5037             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5038         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5039         dismissCling(cling, cb, Cling.FIRST_RUN_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5040                 DISMISS_CLING_DURATION, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5041 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5042         // Fade out the search bar for the workspace cling coming up</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5043         mSearchDropTargetBar.hideSearchBar(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5044     }</span>
5045 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5046 public void dismissFirstRunCling(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5047         mLauncherClings.dismissFirstRunCling(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5048     }</span>
5049 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
5050 
5051     public void dismissMigrationClingCopyApps(View v) {
5052         mLauncherClings.dismissMigrationClingCopyApps(v);
5053     }
5054     public void dismissMigrationClingUseDefault(View v) {
5055         mLauncherClings.dismissMigrationClingUseDefault(v);
5056     }
5057     public void dismissMigrationWorkspaceCling(View v) {
5058         mLauncherClings.dismissMigrationWorkspaceCling(v);
5059     }
5060 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
5061 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5062 public void dismissWorkspaceCling(View v) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5063         Cling cling = (Cling) findViewById(R.id.workspace_cling);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5064         Runnable cb = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5065         if (v == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5066             cb = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5067                 public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5068                     mWorkspace.enterOverviewMode();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5069                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5070             };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5071         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5072         dismissCling(cling, cb, Cling.WORKSPACE_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5073                 DISMISS_CLING_DURATION, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5074 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5075         // Fade in the search bar</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5076         mSearchDropTargetBar.showSearchBar(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5077     }</span>
5078 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5079 public void dismissWorkspaceCling(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5080         mLauncherClings.dismissWorkspaceCling(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5081     }</span>
5082 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
5083 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
5084 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5085 public void dismissFolderCling(View v) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5086         Cling cling = (Cling) findViewById(R.id.folder_cling);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5087         dismissCling(cling, null, Cling.FOLDER_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5088                 DISMISS_CLING_DURATION, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">5089     }</span>
5090 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5091 public void dismissFolderCling(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5092         mLauncherClings.dismissFolderCling(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5093     }</span>
5094 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
5095 
5096 
5097     private boolean shouldRunFirstRunActivity() {
5098         return !ActivityManager.isRunningInTestHarness() &amp;&amp;
5099                 !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);
5100     }
5101 
5102     protected boolean hasRunFirstRunActivity() {
5103         return mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);
5104     }
5105 
5106     public boolean showFirstRunActivity() {
5107         if (shouldRunFirstRunActivity() &amp;&amp;
5108                 hasFirstRunActivity()) {
5109             Intent firstRunIntent = getFirstRunActivity();
5110             if (firstRunIntent != null) {
5111                 startActivity(firstRunIntent);
5112                 markFirstRunActivityShown();
5113                 return true;
5114             }
5115         }
5116         return false;
5117     }
5118 
5119     private void markFirstRunActivityShown() {
5120         SharedPreferences.Editor editor = mSharedPrefs.edit();
5121         editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);
5122         editor.apply();
5123     }
5124 
5125     /**
5126      * To be overridden by subclasses to indicate that there is an in-activity full-screen intro
5127      * screen that must be displayed and dismissed.
5128      */
5129     protected boolean hasDismissableIntroScreen() {
5130         return false;
5131     }
5132 
5133     /**
5134      * Full screen intro screen to be shown and dismissed before the launcher can be used.
5135      */
5136     protected View getIntroScreen() {
5137         return null;
5138     }
5139 
5140     /**
5141      * To be overriden by subclasses to indicate whether the in-activity intro screen has been
5142      * dismissed. This method is ignored if #hasDismissableIntroScreen returns false.
5143      */
5144     private boolean shouldShowIntroScreen() {
5145         return hasDismissableIntroScreen() &amp;&amp;
5146                 !mSharedPrefs.getBoolean(INTRO_SCREEN_DISMISSED, false);
5147     }
5148 
5149     protected void showIntroScreen() {
5150         View introScreen = getIntroScreen();
5151         changeWallpaperVisiblity(false);
5152         if (introScreen != null) {
5153             mDragLayer.showOverlayView(introScreen);
5154         }
5155     }
5156 
5157     public void dismissIntroScreen() {
5158         markIntroScreenDismissed();
5159         if (showFirstRunActivity()) {
5160             // We delay hiding the intro view until the first run activity is showing. This
5161             // avoids a blip.
5162             mWorkspace.postDelayed(new Runnable() {
5163                 @Override
5164                 public void run() {
5165                     mDragLayer.dismissOverlayView();
5166                     showFirstRunClings();
5167                 }
5168             }, ACTIVITY_START_DELAY);
5169         } else {
5170             mDragLayer.dismissOverlayView();
5171             showFirstRunClings();
5172         }
5173         changeWallpaperVisiblity(true);
5174     }
5175 
5176     private void markIntroScreenDismissed() {
5177         SharedPreferences.Editor editor = mSharedPrefs.edit();
5178         editor.putBoolean(INTRO_SCREEN_DISMISSED, true);
5179         editor.apply();
5180     }
5181 
5182     private void showFirstRunClings() {
5183         // The two first run cling paths are mutually exclusive, if the launcher is preinstalled
5184         // on the device, then we always show the first run cling experience (or if there is no
5185         // launcher2). Otherwise, we prompt the user upon started for migration
5186         LauncherClings launcherClings = new LauncherClings(this);
5187         if (launcherClings.shouldShowFirstRunOrMigrationClings()) {
5188             if (mModel.canMigrateFromOldLauncherDb(this)) {
5189                 launcherClings.showMigrationCling();
5190             } else {
5191                 launcherClings.showLongPressCling(true);
5192             }
5193         }
5194     }
5195 
5196     void showWorkspaceSearchAndHotseat() {
5197 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5198         if (mWorkspace != null) mWorkspace.setAlpha(1f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5199         if (mHotseat != null) mHotseat.setAlpha(1f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5200         if (mPageIndicators != null) mPageIndicators.setAlpha(1f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5201         if (mSearchDropTargetBar != null) mSearchDropTargetBar.showSearchBar(false);</span>
5202 ||||||| BASE
5203 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5204         mWorkspace.setAlpha(1f);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5205         mHotseat.setAlpha(1f);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5206         mPageIndicators.setAlpha(1f);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5207         mSearchDropTargetBar.showSearchBar(false);</span>
5208 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
5209     }
5210 
5211     void hideWorkspaceSearchAndHotseat() {
5212 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5213         if (mWorkspace != null) mWorkspace.setAlpha(0f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5214         if (mHotseat != null) mHotseat.setAlpha(0f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5215         if (mPageIndicators != null) mPageIndicators.setAlpha(0f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5216         if (mSearchDropTargetBar != null) mSearchDropTargetBar.hideSearchBar(false);</span>
5217 ||||||| BASE
5218 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5219         mWorkspace.setAlpha(0f);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5220         mHotseat.setAlpha(0f);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5221         mPageIndicators.setAlpha(0f);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5222         mSearchDropTargetBar.hideSearchBar(false);</span>
5223 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
5224     }
5225 
5226 
5227     public ItemInfo createAppDragInfo(Intent appLaunchIntent) {
5228         // Called from search suggestion, not supported in other profiles.
5229         final UserHandleCompat myUser = UserHandleCompat.myUserHandle();
5230         LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
5231         LauncherActivityInfoCompat activityInfo = launcherApps.resolveActivity(appLaunchIntent,
5232                 myUser);
5233         if (activityInfo == null) {
5234             return null;
5235         }
5236         return new AppInfo(this, activityInfo, myUser, mIconCache, null);
5237     }
5238 
5239     public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
5240             Bitmap icon) {
5241         // Called from search suggestion, not supported in other profiles.
5242         return createShortcutDragInfo(shortcutIntent, caption, icon,
5243                 UserHandleCompat.myUserHandle());
5244     }
5245 
5246     public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
5247             Bitmap icon, UserHandleCompat user) {
5248         UserManagerCompat userManager = UserManagerCompat.getInstance(this);
5249         CharSequence contentDescription = userManager.getBadgedLabelForUser(caption, user);
5250         return new ShortcutInfo(shortcutIntent, caption, contentDescription, icon, user);
5251     }
5252 
5253     protected void moveWorkspaceToDefaultScreen() {
5254         mWorkspace.moveToDefaultScreen(false);
5255     }
5256 
5257     public void startDrag(View dragView, ItemInfo dragInfo, DragSource source) {
5258         dragView.setTag(dragInfo);
5259         mWorkspace.onExternalDragStartedWithItem(dragView);
5260         mWorkspace.beginExternalDragShared(dragView, source);
5261     }
5262 
5263     @Override
5264     public void onPageSwitch(View newPage, int newPageIndex) {
5265     }
5266 
5267     /**
5268      * Prints out out state for debugging.
5269      */
5270     public void dumpState() {
5271         Log.d(TAG, &quot;BEGIN launcher3 dump state for launcher &quot; + this);
5272         Log.d(TAG, &quot;mSavedState=&quot; + mSavedState);
5273         Log.d(TAG, &quot;mWorkspaceLoading=&quot; + mWorkspaceLoading);
5274         Log.d(TAG, &quot;mRestoring=&quot; + mRestoring);
5275         Log.d(TAG, &quot;mWaitingForResult=&quot; + mWaitingForResult);
5276         Log.d(TAG, &quot;mSavedInstanceState=&quot; + mSavedInstanceState);
5277         Log.d(TAG, &quot;sFolders.size=&quot; + sFolders.size());
5278         mModel.dumpState();
5279 
5280         if (mAppsCustomizeContent != null) {
5281             mAppsCustomizeContent.dumpState();
5282         }
5283         Log.d(TAG, &quot;END launcher3 dump state&quot;);
5284     }
5285 
5286     @Override
5287     public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
5288         super.dump(prefix, fd, writer, args);
5289         synchronized (sDumpLogs) {
5290             writer.println(&quot; &quot;);
5291             writer.println(&quot;Debug logs: &quot;);
5292             for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5293                 writer.println(&quot;  &quot; + sDumpLogs.get(i));
5294             }
5295         }
5296     }
5297 
5298     public static void dumpDebugLogsToConsole() {
5299         if (DEBUG_DUMP_LOG) {
5300             synchronized (sDumpLogs) {
5301                 Log.d(TAG, &quot;&quot;);
5302                 Log.d(TAG, &quot;*********************&quot;);
5303                 Log.d(TAG, &quot;Launcher debug logs: &quot;);
5304                 for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5305                     Log.d(TAG, &quot;  &quot; + sDumpLogs.get(i));
5306                 }
5307                 Log.d(TAG, &quot;*********************&quot;);
5308                 Log.d(TAG, &quot;&quot;);
5309             }
5310         }
5311     }
5312 
5313     public static void addDumpLog(String tag, String log, boolean debugLog) {
5314         addDumpLog(tag, log, null, debugLog);
5315     }
5316 
5317     public static void addDumpLog(String tag, String log, Exception e, boolean debugLog) {
5318         if (debugLog) {
5319             if (e != null) {
5320                 Log.d(tag, log, e);
5321             } else {
5322                 Log.d(tag, log);
5323             }
5324         }
5325         if (DEBUG_DUMP_LOG) {
5326             sDateStamp.setTime(System.currentTimeMillis());
5327             synchronized (sDumpLogs) {
5328                 sDumpLogs.add(sDateFormat.format(sDateStamp) + &quot;: &quot; + tag + &quot;, &quot; + log
5329                     + (e == null ? &quot;&quot; : (&quot;, Exception: &quot; + e)));
5330             }
5331         }
5332     }
5333 
5334     public void dumpLogsToLocalData() {
5335         if (DEBUG_DUMP_LOG) {
5336             new AsyncTask&lt;Void, Void, Void&gt;() {
5337                 public Void doInBackground(Void ... args) {
5338                     boolean success = false;
5339                     sDateStamp.setTime(sRunStart);
5340                     String FILENAME = sDateStamp.getMonth() + &quot;-&quot;
5341                             + sDateStamp.getDay() + &quot;_&quot;
5342                             + sDateStamp.getHours() + &quot;-&quot;
5343                             + sDateStamp.getMinutes() + &quot;_&quot;
5344                             + sDateStamp.getSeconds() + &quot;.txt&quot;;
5345 
5346                     FileOutputStream fos = null;
5347                     File outFile = null;
5348                     try {
5349                         outFile = new File(getFilesDir(), FILENAME);
5350                         outFile.createNewFile();
5351                         fos = new FileOutputStream(outFile);
5352                     } catch (Exception e) {
5353                         e.printStackTrace();
5354                     }
5355                     if (fos != null) {
5356                         PrintWriter writer = new PrintWriter(fos);
5357 
5358                         writer.println(&quot; &quot;);
5359                         writer.println(&quot;Debug logs: &quot;);
5360                         synchronized (sDumpLogs) {
5361                             for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5362                                 writer.println(&quot;  &quot; + sDumpLogs.get(i));
5363                             }
5364                         }
5365                         writer.close();
5366                     }
5367                     try {
5368                         if (fos != null) {
5369                             fos.close();
5370                             success = true;
5371                         }
5372                     } catch (IOException e) {
5373                         e.printStackTrace();
5374                     }
5375                     return null;
5376                 }
5377             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
5378         }
5379     }
5380 }
5381 
5382 interface LauncherTransitionable {
5383     View getContent();
5384     void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace);
5385     void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace);
5386     void onLauncherTransitionStep(Launcher l, float t);
5387     void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace);
5388 }
5389 
5390 interface DebugIntents {
5391     static final String DELETE_DATABASE = &quot;com.android.launcher3.action.DELETE_DATABASE&quot;;
5392     static final String MIGRATE_DATABASE = &quot;com.android.launcher3.action.MIGRATE_DATABASE&quot;;
5393 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.animation.Animator;
  19 import android.animation.AnimatorListenerAdapter;
  20 import android.animation.AnimatorSet;
  21 import android.animation.ObjectAnimator;
  22 import android.animation.PropertyValuesHolder;
  23 import android.animation.TimeInterpolator;
  24 import android.animation.ValueAnimator;
  25 import android.annotation.TargetApi;
  26 import android.app.Activity;
  27 import android.app.ActivityManager;
  28 import android.app.ActivityOptions;
  29 import android.app.AlertDialog;
  30 import android.app.SearchManager;
  31 import android.appwidget.AppWidgetHostView;
  32 import android.appwidget.AppWidgetManager;
  33 import android.appwidget.AppWidgetProviderInfo;
  34 import android.content.ActivityNotFoundException;
  35 import android.content.BroadcastReceiver;
  36 import android.content.ComponentCallbacks2;
  37 import android.content.ComponentName;
  38 import android.content.ContentResolver;
  39 import android.content.Context;
  40 import android.content.DialogInterface;
  41 import android.content.Intent;
  42 import android.content.IntentFilter;
  43 import android.content.SharedPreferences;
  44 import android.content.pm.ActivityInfo;
  45 import android.content.pm.ApplicationInfo;
  46 import android.content.pm.PackageManager.NameNotFoundException;
  47 import android.content.pm.PackageManager;
  48 import android.content.res.Configuration;
  49 import android.content.res.Resources;
  50 import android.database.ContentObserver;
  51 import android.graphics.Bitmap;
  52 import android.graphics.Canvas;
  53 import android.graphics.Color;
  54 import android.graphics.Point;
  55 import android.graphics.PorterDuff;
  56 import android.graphics.Rect;
  57 import android.graphics.drawable.Drawable;
  58 import android.net.Uri;
  59 import android.os.AsyncTask;
  60 import android.os.Build;
  61 import android.os.Bundle;
  62 import android.os.Environment;
  63 import android.os.Handler;
  64 import android.os.Message;
  65 import android.os.StrictMode;
  66 import android.os.SystemClock;
  67 import android.speech.RecognizerIntent;
  68 import android.text.Selection;
  69 import android.text.SpannableStringBuilder;
  70 import android.text.TextUtils;
  71 import android.text.method.TextKeyListener;
  72 import android.util.DisplayMetrics;
  73 import android.util.Log;
  74 import android.view.ContextThemeWrapper;
  75 import android.view.Display;
  76 import android.view.Gravity;
  77 import android.view.HapticFeedbackConstants;
  78 import android.view.KeyEvent;
  79 import android.view.LayoutInflater;
  80 import android.view.Menu;
  81 import android.view.MotionEvent;
  82 import android.view.Surface;
  83 import android.view.View.OnClickListener;
  84 import android.view.View.OnLongClickListener;
  85 import android.view.View;
  86 import android.view.ViewAnimationUtils;
  87 import android.view.ViewGroup;
  88 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
  89 import android.view.ViewTreeObserver;
  90 import android.view.Window;
  91 import android.view.WindowManager;
  92 import android.view.accessibility.AccessibilityEvent;
  93 import android.view.animation.AccelerateInterpolator;
  94 import android.view.animation.DecelerateInterpolator;
  95 import android.view.animation.Interpolator;
  96 import android.view.inputmethod.InputMethodManager;
  97 import android.widget.Advanceable;
  98 import android.widget.FrameLayout;
  99 import android.widget.ImageView;
 100 import android.widget.TextView;
 101 import android.widget.Toast;
 102 import com.android.launcher3.DropTarget.DragObject;
 103 import com.android.launcher3.PagedView.PageSwitchListener;
 104 import com.android.launcher3.compat.AppWidgetManagerCompat;
 105 import com.android.launcher3.compat.LauncherActivityInfoCompat;
 106 import com.android.launcher3.compat.LauncherAppsCompat;
 107 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
 108 import com.android.launcher3.compat.PackageInstallerCompat;
 109 import com.android.launcher3.compat.UserHandleCompat;
 110 import com.android.launcher3.compat.UserManagerCompat;
 111 import java.io.DataInputStream;
 112 import java.io.DataOutputStream;
 113 import java.io.File;
 114 import java.io.FileDescriptor;
 115 import java.io.FileNotFoundException;
 116 import java.io.FileOutputStream;
 117 import java.io.IOException;
 118 import java.io.PrintWriter;
 119 import java.lang.reflect.Field;
 120 import java.lang.reflect.InvocationTargetException;
 121 import java.lang.reflect.Method;
 122 import java.text.DateFormat;
 123 import java.util.ArrayList;
 124 import java.util.Collection;
 125 import java.util.Date;
 126 import java.util.HashMap;
 127 import java.util.List;
 128 import java.util.concurrent.atomic.AtomicInteger;
 129 
 130 
 131 interface DebugIntents {
 132     public static final String DELETE_DATABASE = &quot;com.android.launcher3.action.DELETE_DATABASE&quot;;
 133 
 134     public static final String MIGRATE_DATABASE = &quot;com.android.launcher3.action.MIGRATE_DATABASE&quot;;
 135 }
 136 
 137 /**
 138  * Default launcher application.
 139  */
 140 public class Launcher extends Activity
 141         implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,
 142                    View.OnTouchListener, PageSwitchListener, LauncherProviderChangeListener {
 143     static final String TAG = &quot;Launcher&quot;;
 144     static final boolean LOGD = false;
 145 
 146     static final boolean PROFILE_STARTUP = false;
 147     static final boolean DEBUG_WIDGETS = false;
 148     static final boolean DEBUG_STRICT_MODE = false;
 149     static final boolean DEBUG_RESUME_TIME = false;
 150     static final boolean DEBUG_DUMP_LOG = false;
 151 
 152     static final boolean ENABLE_DEBUG_INTENTS = false; // allow DebugIntents to run
 153 
 154     private static final int REQUEST_CREATE_SHORTCUT = 1;
 155     private static final int REQUEST_CREATE_APPWIDGET = 5;
 156     private static final int REQUEST_PICK_SHORTCUT = 7;
 157     private static final int REQUEST_PICK_APPWIDGET = 9;
 158     private static final int REQUEST_PICK_WALLPAPER = 10;
 159 
 160     private static final int REQUEST_BIND_APPWIDGET = 11;
 161     private static final int REQUEST_RECONFIGURE_APPWIDGET = 12;
 162 
 163     /**
 164      * IntentStarter uses request codes starting with this. This must be greater than all activity
 165      * request codes used internally.
 166      */
 167     protected static final int REQUEST_LAST = 100;
 168 
 169     static final String EXTRA_SHORTCUT_DUPLICATE = &quot;duplicate&quot;;
 170 
 171     static final int SCREEN_COUNT = 5;
 172     static final int DEFAULT_SCREEN = 2;
 173 
 174     private static final String PREFERENCES = &quot;launcher.preferences&quot;;
 175     // To turn on these properties, type
 176     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
 177     static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
 178     static final String DUMP_STATE_PROPERTY = &quot;launcher_dump_state&quot;;
 179     static final String DISABLE_ALL_APPS_PROPERTY = &quot;launcher_noallapps&quot;;
 180 
 181     // The Intent extra that defines whether to ignore the launch animation
 182     static final String INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION =
 183             &quot;com.android.launcher3.intent.extra.shortcut.INGORE_LAUNCH_ANIMATION&quot;;
 184 
 185     // Type: int
 186     private static final String RUNTIME_STATE_CURRENT_SCREEN = &quot;launcher.current_screen&quot;;
 187     // Type: int
 188     private static final String RUNTIME_STATE = &quot;launcher.state&quot;;
 189     // Type: int
 190     private static final String RUNTIME_STATE_PENDING_ADD_CONTAINER = &quot;launcher.add_container&quot;;
 191     // Type: int
 192     private static final String RUNTIME_STATE_PENDING_ADD_SCREEN = &quot;launcher.add_screen&quot;;
 193     // Type: int
 194     private static final String RUNTIME_STATE_PENDING_ADD_CELL_X = &quot;launcher.add_cell_x&quot;;
 195     // Type: int
 196     private static final String RUNTIME_STATE_PENDING_ADD_CELL_Y = &quot;launcher.add_cell_y&quot;;
 197     // Type: boolean
 198     private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME = &quot;launcher.rename_folder&quot;;
 199     // Type: long
 200     private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME_ID = &quot;launcher.rename_folder_id&quot;;
 201     // Type: int
 202     private static final String RUNTIME_STATE_PENDING_ADD_SPAN_X = &quot;launcher.add_span_x&quot;;
 203     // Type: int
 204     private static final String RUNTIME_STATE_PENDING_ADD_SPAN_Y = &quot;launcher.add_span_y&quot;;
 205     // Type: parcelable
 206     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_INFO = &quot;launcher.add_widget_info&quot;;
 207     // Type: parcelable
 208     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_ID = &quot;launcher.add_widget_id&quot;;
 209     // Type: int[]
 210     private static final String RUNTIME_STATE_VIEW_IDS = &quot;launcher.view_ids&quot;;
 211 
 212     static final String INTRO_SCREEN_DISMISSED = &quot;launcher.intro_screen_dismissed&quot;;
 213     static final String FIRST_RUN_ACTIVITY_DISPLAYED = &quot;launcher.first_run_activity_displayed&quot;;
 214 
 215     static final String FIRST_LOAD_COMPLETE = &quot;launcher.first_load_complete&quot;;
 216     static final String ACTION_FIRST_LOAD_COMPLETE =
 217             &quot;com.android.launcher3.action.FIRST_LOAD_COMPLETE&quot;;
 218 
 219     private static final String TOOLBAR_ICON_METADATA_NAME = &quot;com.android.launcher.toolbar_icon&quot;;
 220     private static final String TOOLBAR_SEARCH_ICON_METADATA_NAME =
 221             &quot;com.android.launcher.toolbar_search_icon&quot;;
 222     private static final String TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME =
 223             &quot;com.android.launcher.toolbar_voice_search_icon&quot;;
 224 
 225     public static final String SHOW_WEIGHT_WATCHER = &quot;debug.show_mem&quot;;
 226     public static final boolean SHOW_WEIGHT_WATCHER_DEFAULT = false;
 227 
 228     public static final String USER_HAS_MIGRATED = &quot;launcher.user_migrated_from_old_data&quot;;
 229 
 230     /** The different states that Launcher can be in. */
 231     private enum State { NONE, WORKSPACE, APPS_CUSTOMIZE, APPS_CUSTOMIZE_SPRING_LOADED };
 232     private State mState = State.WORKSPACE;
 233     private AnimatorSet mStateAnimation;
 234 
 235     private boolean mIsSafeModeEnabled;
 236 
 237     static final int APPWIDGET_HOST_ID = 1024;
 238     public static final int EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT = 300;
 239     private static final int ON_ACTIVITY_RESULT_ANIMATION_DELAY = 500;
 240 
 241 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 242     private static final int ACTIVITY_START_DELAY = 1000;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 243 </span>
 244 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 245 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 245 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 246 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 247 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 248 </span>
 249 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 250 
 251     private static final Object sLock = new Object();
 252     private static int sScreen = DEFAULT_SCREEN;
 253 
 254     private HashMap&lt;Integer, Integer&gt; mItemIdToViewId = new HashMap&lt;Integer, Integer&gt;();
 255     private static final AtomicInteger sNextGeneratedId = new AtomicInteger(1);
 256 
 257     // How long to wait before the new-shortcut animation automatically pans the workspace
 258     private static int NEW_APPS_PAGE_MOVE_DELAY = 500;
 259     private static int NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS = 5;
 260     private static int NEW_APPS_ANIMATION_DELAY = 500;
 261     private static final int SINGLE_FRAME_DELAY = 16;
 262 
 263     private final BroadcastReceiver mCloseSystemDialogsReceiver
 264             = new CloseSystemDialogsIntentReceiver();
 265     private final ContentObserver mWidgetObserver = new AppWidgetResetObserver();
 266 
 267     private LayoutInflater mInflater;
 268 
 269     private Workspace mWorkspace;
 270     private View mLauncherView;
 271     private View mPageIndicators;
 272     private DragLayer mDragLayer;
 273     private DragController mDragController;
 274     private View mWeightWatcher;
 275     private LauncherClings mLauncherClings;
 276 
 277     private AppWidgetManagerCompat mAppWidgetManager;
 278     private LauncherAppWidgetHost mAppWidgetHost;
 279 
 280     private ItemInfo mPendingAddInfo = new ItemInfo();
 281     private AppWidgetProviderInfo mPendingAddWidgetInfo;
 282     private int mPendingAddWidgetId = -1;
 283 
 284     private int[] mTmpAddItemCellCoordinates = new int[2];
 285 
 286     private FolderInfo mFolderInfo;
 287 
 288     private Hotseat mHotseat;
 289     private ViewGroup mOverviewPanel;
 290 
 291     private View mAllAppsButton;
 292 
 293     private SearchDropTargetBar mSearchDropTargetBar;
 294     private AppsCustomizeTabHost mAppsCustomizeTabHost;
 295     private AppsCustomizePagedView mAppsCustomizeContent;
 296     private boolean mAutoAdvanceRunning = false;
 297     private View mQsb;
 298 
 299     private Bundle mSavedState;
 300     // We set the state in both onCreate and then onNewIntent in some cases, which causes both
 301     // scroll issues (because the workspace may not have been measured yet) and extra work.
 302     // Instead, just save the state that we need to restore Launcher to, and commit it in onResume.
 303     private State mOnResumeState = State.NONE;
 304 
 305     private SpannableStringBuilder mDefaultKeySsb = null;
 306 
 307     private boolean mWorkspaceLoading = true;
 308 
 309     private boolean mPaused = true;
 310     private boolean mRestoring;
 311     private boolean mWaitingForResult;
 312     private boolean mOnResumeNeedsLoad;
 313 
 314     private ArrayList&lt;Runnable&gt; mBindOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 315     private ArrayList&lt;Runnable&gt; mOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 316 
 317     private Bundle mSavedInstanceState;
 318 
 319     private LauncherModel mModel;
 320     private IconCache mIconCache;
 321     private boolean mUserPresent = true;
 322     private boolean mVisible = false;
 323     private boolean mHasFocus = false;
 324     private boolean mAttached = false;
 325 
 326     private static LocaleConfiguration sLocaleConfiguration = null;
 327 
 328     private static HashMap&lt;Long, FolderInfo&gt; sFolders = new HashMap&lt;Long, FolderInfo&gt;();
 329 
 330     private View.OnTouchListener mHapticFeedbackTouchListener;
 331 
 332     // Related to the auto-advancing of widgets
 333     private final int ADVANCE_MSG = 1;
 334     private final int mAdvanceInterval = 20000;
 335     private final int mAdvanceStagger = 250;
 336     private long mAutoAdvanceSentTime;
 337     private long mAutoAdvanceTimeLeft = -1;
 338     private HashMap&lt;View, AppWidgetProviderInfo&gt; mWidgetsToAdvance =
 339         new HashMap&lt;View, AppWidgetProviderInfo&gt;();
 340 
 341     // Determines how long to wait after a rotation before restoring the screen orientation to
 342     // match the sensor state.
 343     private final int mRestoreScreenOrientationDelay = 500;
 344 
 345     // External icons saved in case of resource changes, orientation, etc.
 346     private static Drawable.ConstantState[] sGlobalSearchIcon = new Drawable.ConstantState[2];
 347     private static Drawable.ConstantState[] sVoiceSearchIcon = new Drawable.ConstantState[2];
 348 
 349     private Drawable mWorkspaceBackgroundDrawable;
 350 
 351     private final ArrayList&lt;Integer&gt; mSynchronouslyBoundPages = new ArrayList&lt;Integer&gt;();
 352     private static final boolean DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE = false;
 353 
 354     static final ArrayList&lt;String&gt; sDumpLogs = new ArrayList&lt;String&gt;();
 355     static Date sDateStamp = new Date();
 356     static DateFormat sDateFormat =
 357             DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
 358     static long sRunStart = System.currentTimeMillis();
 359     static final String CORRUPTION_EMAIL_SENT_KEY = &quot;corruptionEmailSent&quot;;
 360 
 361     // We only want to get the SharedPreferences once since it does an FS stat each time we get
 362     // it from the context.
 363     private SharedPreferences mSharedPrefs;
 364 
 365     private static ArrayList&lt;ComponentName&gt; mIntentsOnWorkspaceFromUpgradePath = null;
 366 
 367     // Holds the page that we need to animate to, and the icon views that we need to animate up
 368     // when we scroll to that page on resume.
 369     private ImageView mFolderIconImageView;
 370     private Bitmap mFolderIconBitmap;
 371     private Canvas mFolderIconCanvas;
 372     private Rect mRectForFolderAnimation = new Rect();
 373 
 374     private BubbleTextView mWaitingForResume;
 375 
 376     private Runnable mBuildLayersRunnable = new Runnable() {
 377         public void run() {
 378             if (mWorkspace != null) {
 379                 mWorkspace.buildPageHardwareLayers();
 380             }
 381         }
 382     };
 383 
 384     private static PendingAddArguments sPendingAddItem;
 385 
 386     public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
 387 
 388     private static class PendingAddArguments {
 389         int requestCode;
 390         Intent intent;
 391         long container;
 392         long screenId;
 393         int cellX;
 394         int cellY;
 395         int appWidgetId;
 396     }
 397 
 398     private Stats mStats;
 399 
 400 
 401 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 402     FocusIndicatorView mFocusHandler;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 403 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 404 </span>
 405 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 406 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 406 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 407 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 408 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 409 </span>
 410 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 411     static boolean isPropertyEnabled(String propertyName) {
 412         return Log.isLoggable(propertyName, Log.VERBOSE);
 413     }
 414 
 415     @Override
 416     protected void onCreate(Bundle savedInstanceState) {
 417         if (DEBUG_STRICT_MODE) {
 418             StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
 419                     .detectDiskReads()
 420                     .detectDiskWrites()
 421                     .detectNetwork()   // or .detectAll() for all detectable problems
 422                     .penaltyLog()
 423                     .build());
 424             StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
 425                     .detectLeakedSqlLiteObjects()
 426                     .detectLeakedClosableObjects()
 427                     .penaltyLog()
 428                     .penaltyDeath()
 429                     .build());
 430         }
 431 
 432         super.onCreate(savedInstanceState);
 433 
 434         LauncherAppState.setApplicationContext(getApplicationContext());
 435         LauncherAppState app = LauncherAppState.getInstance();
 436         LauncherAppState.getLauncherProvider().setLauncherProviderChangeListener(this);
 437         // Determine the dynamic grid properties
 438         Point smallestSize = new Point();
 439         Point largestSize = new Point();
 440         Point realSize = new Point();
 441         Display display = getWindowManager().getDefaultDisplay();
 442         display.getCurrentSizeRange(smallestSize, largestSize);
 443         display.getRealSize(realSize);
 444         DisplayMetrics dm = new DisplayMetrics();
 445         display.getMetrics(dm);
 446 
 447         // Lazy-initialize the dynamic grid
 448         DeviceProfile grid = app.initDynamicGrid(this,
 449                 Math.min(smallestSize.x, smallestSize.y),
 450                 Math.min(largestSize.x, largestSize.y),
 451                 realSize.x, realSize.y,
 452                 dm.widthPixels, dm.heightPixels);
 453 
<abbr title=" 454         // the LauncherApplication should call this, but in case of Instrumentation it might not be present yet"> 454         // the LauncherApplication should call this, but in case of Instrumentation it might not be prese🔵</abbr>
 455         mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(),
 456                 Context.MODE_PRIVATE);
 457         mIsSafeModeEnabled = getPackageManager().isSafeMode();
 458         mModel = app.setLauncher(this);
 459         mIconCache = app.getIconCache();
 460         mIconCache.flushInvalidIcons(grid);
 461         mDragController = new DragController(this);
 462         mLauncherClings = new LauncherClings(this);
 463         mInflater = getLayoutInflater();
 464 
 465         mStats = new Stats(this);
 466 
 467         mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
 468 
 469         mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
 470         mAppWidgetHost.startListening();
 471 
 472         // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
 473         // this also ensures that any synchronous binding below doesn&#x27;t re-trigger another
 474         // LauncherModel load.
 475         mPaused = false;
 476 
 477         if (PROFILE_STARTUP) {
 478             android.os.Debug.startMethodTracing(
 479                     Environment.getExternalStorageDirectory() + &quot;/launcher&quot;);
 480         }
 481 
 482         checkForLocaleChange();
 483         setContentView(R.layout.launcher);
 484 
 485         setupViews();
 486         grid.layout(this);
 487 
 488         registerContentObservers();
 489 
 490         lockAllApps();
 491 
 492         mSavedState = savedInstanceState;
 493         restoreState(mSavedState);
 494 
 495         if (PROFILE_STARTUP) {
 496             android.os.Debug.stopMethodTracing();
 497         }
 498 
 499         if (!mRestoring) {
 500             if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
 501                 // If the user leaves launcher, then we should just load items asynchronously when
 502                 // they return.
 503                 mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
 504             } else {
 505                 // We only load the page synchronously if the user rotates (or triggers a
 506                 // configuration change) while launcher is in the foreground
 507                 mModel.startLoader(true, mWorkspace.getRestorePage());
 508             }
 509         }
 510 
 511         // For handling default keys
 512         mDefaultKeySsb = new SpannableStringBuilder();
 513         Selection.setSelection(mDefaultKeySsb, 0);
 514 
 515         IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
 516         registerReceiver(mCloseSystemDialogsReceiver, filter);
 517 
 518         updateGlobalIcons();
 519 
 520         // On large interfaces, we want the screen to auto-rotate based on the current orientation
 521         unlockScreenOrientation(true);
 522 
 523 
 524 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 525         if (shouldShowIntroScreen()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 526             showIntroScreen();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 527         } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 528             showFirstRunActivity();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 529             showFirstRunClings();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 530 </span>
 531 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 532 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 532 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 533 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 534 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 535         // The two first run cling paths are mutually exclusive, if the launcher is preinstalled</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 536         // on the device, then we always show the first run cling experience (or if there is no</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 537         // launcher2). Otherwise, we prompt the user upon started for migration</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 538         showFirstRunActivity();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 539         if (mLauncherClings.shouldShowFirstRunOrMigrationClings()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 540             if (mModel.canMigrateFromOldLauncherDb(this)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 541                 mLauncherClings.showMigrationCling();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 542             } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 543                 mLauncherClings.showFirstRunCling();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 544             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 545         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 546             mLauncherClings.removeFirstRunAndMigrationClings();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 547 </span>
 548 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 549         }
 550     }
 551 
 552     @Override
 553     public void onLauncherProviderChange() { }
 554 
 555     /** To be overriden by subclasses to hint to Launcher that we have custom content */
 556     protected boolean hasCustomContentToLeft() {
 557         return false;
 558     }
 559 
 560     /**
 561      * To be overridden by subclasses to populate the custom content container and call
 562      * {@link #addToCustomContentPage}. This will only be invoked if
 563      * {@link #hasCustomContentToLeft()} is {@code true}.
 564      */
 565     protected void populateCustomContentContainer() {
 566     }
 567 
 568     /**
 569      * Invoked by subclasses to signal a change to the {@link #addCustomContentToLeft} value to
 570      * ensure the custom content page is added or removed if necessary.
 571      */
 572     protected void invalidateHasCustomContentToLeft() {
 573         if (mWorkspace == null || mWorkspace.getScreenOrder().isEmpty()) {
 574             // Not bound yet, wait for bindScreens to be called.
 575             return;
 576         }
 577 
 578         if (!mWorkspace.hasCustomContent() &amp;&amp; hasCustomContentToLeft()) {
 579             // Create the custom content page and call the subclass to populate it.
 580             mWorkspace.createCustomContentContainer();
 581             populateCustomContentContainer();
 582         } else if (mWorkspace.hasCustomContent() &amp;&amp; !hasCustomContentToLeft()) {
 583             mWorkspace.removeCustomContentPage();
 584         }
 585     }
 586 
 587     private void updateGlobalIcons() {
 588         boolean searchVisible = false;
 589         boolean voiceVisible = false;
 590         // If we have a saved version of these external icons, we load them up immediately
 591         int coi = getCurrentOrientationIndexForGlobalIcons();
 592         if (sGlobalSearchIcon[coi] == null || sVoiceSearchIcon[coi] == null) {
 593             searchVisible = updateGlobalSearchIcon();
 594             voiceVisible = updateVoiceSearchIcon(searchVisible);
 595         }
 596         if (sGlobalSearchIcon[coi] != null) {
 597              updateGlobalSearchIcon(sGlobalSearchIcon[coi]);
 598              searchVisible = true;
 599         }
 600         if (sVoiceSearchIcon[coi] != null) {
 601             updateVoiceSearchIcon(sVoiceSearchIcon[coi]);
 602             voiceVisible = true;
 603         }
 604         if (mSearchDropTargetBar != null) {
 605             mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
 606         }
 607     }
 608 
 609     private void checkForLocaleChange() {
 610         if (sLocaleConfiguration == null) {
 611             new AsyncTask&lt;Void, Void, LocaleConfiguration&gt;() {
 612                 @Override
 613                 protected LocaleConfiguration doInBackground(Void... unused) {
 614                     LocaleConfiguration localeConfiguration = new LocaleConfiguration();
 615                     readConfiguration(Launcher.this, localeConfiguration);
 616                     return localeConfiguration;
 617                 }
 618 
 619                 @Override
 620                 protected void onPostExecute(LocaleConfiguration result) {
 621                     sLocaleConfiguration = result;
 622                     checkForLocaleChange();  // recursive, but now with a locale configuration
 623                 }
 624             }.execute();
 625             return;
 626         }
 627 
 628         final Configuration configuration = getResources().getConfiguration();
 629 
 630         final String previousLocale = sLocaleConfiguration.locale;
 631         final String locale = configuration.locale.toString();
 632 
 633         final int previousMcc = sLocaleConfiguration.mcc;
 634         final int mcc = configuration.mcc;
 635 
 636         final int previousMnc = sLocaleConfiguration.mnc;
 637         final int mnc = configuration.mnc;
 638 
<abbr title=" 639         boolean localeChanged = !locale.equals(previousLocale) || mcc != previousMcc || mnc != previousMnc;"> 639         boolean localeChanged = !locale.equals(previousLocale) || mcc != previousMcc || mnc != previousMn🔵</abbr>
 640 
 641         if (localeChanged) {
 642             sLocaleConfiguration.locale = locale;
 643             sLocaleConfiguration.mcc = mcc;
 644             sLocaleConfiguration.mnc = mnc;
 645 
 646             mIconCache.flush();
 647 
 648             final LocaleConfiguration localeConfiguration = sLocaleConfiguration;
 649             new AsyncTask&lt;Void, Void, Void&gt;() {
 650                 public Void doInBackground(Void ... args) {
 651                     writeConfiguration(Launcher.this, localeConfiguration);
 652                     return null;
 653                 }
 654             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 655         }
 656     }
 657 
 658     private static class LocaleConfiguration {
 659         public String locale;
 660         public int mcc = -1;
 661         public int mnc = -1;
 662     }
 663 
 664     private static void readConfiguration(Context context, LocaleConfiguration configuration) {
 665         DataInputStream in = null;
 666         try {
 667             in = new DataInputStream(context.openFileInput(PREFERENCES));
 668             configuration.locale = in.readUTF();
 669             configuration.mcc = in.readInt();
 670             configuration.mnc = in.readInt();
 671         } catch (FileNotFoundException e) {
 672             // Ignore
 673         } catch (IOException e) {
 674             // Ignore
 675         } finally {
 676             if (in != null) {
 677                 try {
 678                     in.close();
 679                 } catch (IOException e) {
 680                     // Ignore
 681                 }
 682             }
 683         }
 684     }
 685 
 686     private static void writeConfiguration(Context context, LocaleConfiguration configuration) {
 687         DataOutputStream out = null;
 688         try {
 689             out = new DataOutputStream(context.openFileOutput(PREFERENCES, MODE_PRIVATE));
 690             out.writeUTF(configuration.locale);
 691             out.writeInt(configuration.mcc);
 692             out.writeInt(configuration.mnc);
 693             out.flush();
 694         } catch (FileNotFoundException e) {
 695             // Ignore
 696         } catch (IOException e) {
 697             //noinspection ResultOfMethodCallIgnored
 698             context.getFileStreamPath(PREFERENCES).delete();
 699         } finally {
 700             if (out != null) {
 701                 try {
 702                     out.close();
 703                 } catch (IOException e) {
 704                     // Ignore
 705                 }
 706             }
 707         }
 708     }
 709 
 710     public Stats getStats() {
 711         return mStats;
 712     }
 713 
 714     public LayoutInflater getInflater() {
 715         return mInflater;
 716     }
 717 
 718     boolean isDraggingEnabled() {
 719         // We prevent dragging when we are loading the workspace as it is possible to pick up a view
 720         // that is subsequently removed from the workspace in startBinding().
 721         return !mModel.isLoadingWorkspace();
 722     }
 723 
 724     static int getScreen() {
 725         synchronized (sLock) {
 726             return sScreen;
 727         }
 728     }
 729 
 730     static void setScreen(int screen) {
 731         synchronized (sLock) {
 732             sScreen = screen;
 733         }
 734     }
 735 
 736     public static int generateViewId() {
 737         if (Build.VERSION.SDK_INT &gt;= 17) {
 738             return View.generateViewId();
 739         } else {
 740             // View.generateViewId() is not available. The following fallback logic is a copy
 741             // of its implementation.
 742             for (;;) {
 743                 final int result = sNextGeneratedId.get();
 744                 // aapt-generated IDs have the high byte nonzero; clamp to the range under that.
 745                 int newValue = result + 1;
 746                 if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.
 747                 if (sNextGeneratedId.compareAndSet(result, newValue)) {
 748                     return result;
 749                 }
 750             }
 751         }
 752     }
 753 
 754     public int getViewIdForItem(ItemInfo info) {
 755         // This cast is safe given the &gt; 2B range for int.
 756         int itemId = (int) info.id;
 757         if (mItemIdToViewId.containsKey(itemId)) {
 758             return mItemIdToViewId.get(itemId);
 759         }
 760         int viewId = generateViewId();
 761         mItemIdToViewId.put(itemId, viewId);
 762         return viewId;
 763     }
 764 
 765     /**
 766      * Returns whether we should delay spring loaded mode -- for shortcuts and widgets that have
 767      * a configuration step, this allows the proper animations to run after other transitions.
 768      */
 769     private long completeAdd(PendingAddArguments args) {
 770         long screenId = args.screenId;
 771         if (args.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 772             // When the screen id represents an actual screen (as opposed to a rank) we make sure
 773             // that the drop page actually exists.
 774             screenId = ensurePendingDropLayoutExists(args.screenId);
 775         }
 776 
 777         switch (args.requestCode) {
 778             case REQUEST_CREATE_SHORTCUT:
 779                 completeAddShortcut(args.intent, args.container, screenId, args.cellX,
 780                         args.cellY);
 781                 break;
 782             case REQUEST_CREATE_APPWIDGET:
 783                 completeAddAppWidget(args.appWidgetId, args.container, screenId, null, null);
 784                 break;
 785             case REQUEST_RECONFIGURE_APPWIDGET:
 786                 completeRestoreAppWidget(args.appWidgetId);
 787                 break;
 788         }
 789         // Before adding this resetAddInfo(), after a shortcut was added to a workspace screen,
 790         // if you turned the screen off and then back while in All Apps, Launcher would not
 791         // return to the workspace. Clearing mAddInfo.container here fixes this issue
 792         resetAddInfo();
 793         return screenId;
 794     }
 795 
 796     @Override
 797     protected void onActivityResult(
 798             final int requestCode, final int resultCode, final Intent data) {
 799         // Reset the startActivity waiting flag
 800         setWaitingForResult(false);
 801         final int pendingAddWidgetId = mPendingAddWidgetId;
 802         mPendingAddWidgetId = -1;
 803 
 804         Runnable exitSpringLoaded = new Runnable() {
 805             @Override
 806             public void run() {
 807                 exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 808                         EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 809             }
 810         };
 811 
 812         if (requestCode == REQUEST_BIND_APPWIDGET) {
 813             final int appWidgetId = data != null ?
 814                     data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1) : -1;
 815             if (resultCode == RESULT_CANCELED) {
 816                 completeTwoStageWidgetDrop(RESULT_CANCELED, appWidgetId);
 817                 mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 818                         ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 819             } else if (resultCode == RESULT_OK) {
 820                 addAppWidgetImpl(appWidgetId, mPendingAddInfo, null,
 821                         mPendingAddWidgetInfo, ON_ACTIVITY_RESULT_ANIMATION_DELAY);
 822             }
 823             return;
 824         } else if (requestCode == REQUEST_PICK_WALLPAPER) {
 825             if (resultCode == RESULT_OK &amp;&amp; mWorkspace.isInOverviewMode()) {
 826                 mWorkspace.exitOverviewMode(false);
 827             }
 828             return;
 829         }
 830 
 831         boolean isWidgetDrop = (requestCode == REQUEST_PICK_APPWIDGET ||
 832                 requestCode == REQUEST_CREATE_APPWIDGET);
 833 
 834         final boolean workspaceLocked = isWorkspaceLocked();
 835         // We have special handling for widgets
 836         if (isWidgetDrop) {
 837             final int appWidgetId;
 838             int widgetId = data != null ? data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
 839                     : -1;
 840             if (widgetId &lt; 0) {
 841                 appWidgetId = pendingAddWidgetId;
 842             } else {
 843                 appWidgetId = widgetId;
 844             }
 845 
 846             final int result;
 847             if (appWidgetId &lt; 0 || resultCode == RESULT_CANCELED) {
 848                 Log.e(TAG, &quot;Error: appWidgetId (EXTRA_APPWIDGET_ID) was not &quot; +
 849                         &quot;returned from the widget configuration activity.&quot;);
 850                 result = RESULT_CANCELED;
 851                 completeTwoStageWidgetDrop(result, appWidgetId);
 852                 final Runnable onComplete = new Runnable() {
 853                     @Override
 854                     public void run() {
 855                         exitSpringLoadedDragModeDelayed(false, 0, null);
 856                     }
 857                 };
 858                 if (workspaceLocked) {
 859                     // No need to remove the empty screen if we&#x27;re mid-binding, as the
 860                     // the bind will not add the empty screen.
 861                     mWorkspace.postDelayed(onComplete, ON_ACTIVITY_RESULT_ANIMATION_DELAY);
 862                 } else {
 863                     mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete,
 864                             ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 865                 }
 866             } else {
 867                 if (!workspaceLocked) {
 868                     if (mPendingAddInfo.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 869                         // When the screen id represents an actual screen (as opposed to a rank)
 870                         // we make sure that the drop page actually exists.
 871                         mPendingAddInfo.screenId =
 872                                 ensurePendingDropLayoutExists(mPendingAddInfo.screenId);
 873                     }
 874                     final CellLayout dropLayout = mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
 875 
 876                     dropLayout.setDropPending(true);
 877                     final Runnable onComplete = new Runnable() {
 878                         @Override
 879                         public void run() {
 880                             completeTwoStageWidgetDrop(resultCode, appWidgetId);
 881                             dropLayout.setDropPending(false);
 882                         }
 883                     };
 884                     mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete,
 885                             ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 886                 } else {
 887                     PendingAddArguments args = preparePendingAddArgs(requestCode, data, appWidgetId,
 888                             mPendingAddInfo);
 889                     sPendingAddItem = args;
 890                 }
 891             }
 892             return;
 893         }
 894 
 895         if (requestCode == REQUEST_RECONFIGURE_APPWIDGET) {
 896             if (resultCode == RESULT_OK) {
 897                 // Update the widget view.
 898                 PendingAddArguments args = preparePendingAddArgs(requestCode, data,
 899                         pendingAddWidgetId, mPendingAddInfo);
 900                 if (workspaceLocked) {
 901                     sPendingAddItem = args;
 902                 } else {
 903                     completeAdd(args);
 904                 }
 905             }
 906             // Leave the widget in the pending state if the user canceled the configure.
 907             return;
 908         }
 909 
 910         // The pattern used here is that a user PICKs a specific application,
 911         // which, depending on the target, might need to CREATE the actual target.
 912 
 913         // For example, the user would PICK_SHORTCUT for &quot;Music playlist&quot;, and we
 914         // launch over to the Music app to actually CREATE_SHORTCUT.
 915         if (resultCode == RESULT_OK &amp;&amp; mPendingAddInfo.container != ItemInfo.NO_ID) {
 916             final PendingAddArguments args = preparePendingAddArgs(requestCode, data, -1,
 917                     mPendingAddInfo);
 918             if (isWorkspaceLocked()) {
 919                 sPendingAddItem = args;
 920             } else {
 921                 completeAdd(args);
 922                 mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 923                         ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 924             }
 925         } else if (resultCode == RESULT_CANCELED) {
 926             mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,
 927                     ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 928         }
 929         mDragLayer.clearAnimatedView();
 930     }
 931 
 932     private PendingAddArguments preparePendingAddArgs(int requestCode, Intent data, int
 933             appWidgetId, ItemInfo info) {
 934         PendingAddArguments args = new PendingAddArguments();
 935         args.requestCode = requestCode;
 936         args.intent = data;
 937         args.container = info.container;
 938         args.screenId = info.screenId;
 939         args.cellX = info.cellX;
 940         args.cellY = info.cellY;
 941         args.appWidgetId = appWidgetId;
 942         return args;
 943     }
 944 
 945     /**
 946      * Check to see if a given screen id exists. If not, create it at the end, return the new id.
 947      *
 948      * @param screenId the screen id to check
 949      * @return the new screen, or screenId if it exists
 950      */
 951     private long ensurePendingDropLayoutExists(long screenId) {
 952         CellLayout dropLayout =
 953                 (CellLayout) mWorkspace.getScreenWithId(screenId);
 954         if (dropLayout == null) {
 955             // it&#x27;s possible that the add screen was removed because it was
 956             // empty and a re-bind occurred
 957             mWorkspace.addExtraEmptyScreen();
 958             return mWorkspace.commitExtraEmptyScreen();
 959         } else {
 960             return screenId;
 961         }
 962     }
 963 
 964     private void completeTwoStageWidgetDrop(final int resultCode, final int appWidgetId) {
 965         CellLayout cellLayout =
 966                 (CellLayout) mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
 967         Runnable onCompleteRunnable = null;
 968         int animationType = 0;
 969 
 970         AppWidgetHostView boundWidget = null;
 971         if (resultCode == RESULT_OK) {
 972             animationType = Workspace.COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION;
 973             final AppWidgetHostView layout = mAppWidgetHost.createView(this, appWidgetId,
 974                     mPendingAddWidgetInfo);
 975             boundWidget = layout;
 976             onCompleteRunnable = new Runnable() {
 977                 @Override
 978                 public void run() {
 979                     completeAddAppWidget(appWidgetId, mPendingAddInfo.container,
 980                             mPendingAddInfo.screenId, layout, null);
 981                     exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 982                             EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 983                 }
 984             };
 985         } else if (resultCode == RESULT_CANCELED) {
 986             mAppWidgetHost.deleteAppWidgetId(appWidgetId);
 987             animationType = Workspace.CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION;
 988         }
 989         if (mDragLayer.getAnimatedView() != null) {
 990             mWorkspace.animateWidgetDrop(mPendingAddInfo, cellLayout,
 991                     (DragView) mDragLayer.getAnimatedView(), onCompleteRunnable,
 992                     animationType, boundWidget, true);
 993         } else if (onCompleteRunnable != null) {
 994             // The animated view may be null in the case of a rotation during widget configuration
 995             onCompleteRunnable.run();
 996         }
 997     }
 998 
 999     @Override
1000     protected void onStop() {
1001         super.onStop();
1002         FirstFrameAnimatorHelper.setIsVisible(false);
1003     }
1004 
1005     @Override
1006     protected void onStart() {
1007         super.onStart();
1008         FirstFrameAnimatorHelper.setIsVisible(true);
1009     }
1010 
1011     @Override
1012     protected void onResume() {
1013         long startTime = 0;
1014         if (DEBUG_RESUME_TIME) {
1015             startTime = System.currentTimeMillis();
1016             Log.v(TAG, &quot;Launcher.onResume()&quot;);
1017         }
1018         super.onResume();
1019 
1020         // Restore the previous launcher state
1021         if (mOnResumeState == State.WORKSPACE) {
1022             showWorkspace(false);
1023         } else if (mOnResumeState == State.APPS_CUSTOMIZE) {
1024             showAllApps(false, mAppsCustomizeContent.getContentType(), false);
1025         }
1026         mOnResumeState = State.NONE;
1027 
1028         // Background was set to gradient in onPause(), restore to black if in all apps.
1029         setWorkspaceBackground(mState == State.WORKSPACE);
1030 
1031         mPaused = false;
1032         if (mRestoring || mOnResumeNeedsLoad) {
1033             setWorkspaceLoading(true);
1034             mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
1035             mRestoring = false;
1036             mOnResumeNeedsLoad = false;
1037         }
1038         if (mBindOnResumeCallbacks.size() &gt; 0) {
1039             // We might have postponed some bind calls until onResume (see waitUntilResume) --
1040             // execute them here
1041             long startTimeCallbacks = 0;
1042             if (DEBUG_RESUME_TIME) {
1043                 startTimeCallbacks = System.currentTimeMillis();
1044             }
1045 
1046             if (mAppsCustomizeContent != null) {
1047                 mAppsCustomizeContent.setBulkBind(true);
1048             }
1049             for (int i = 0; i &lt; mBindOnResumeCallbacks.size(); i++) {
1050                 mBindOnResumeCallbacks.get(i).run();
1051             }
1052             if (mAppsCustomizeContent != null) {
1053                 mAppsCustomizeContent.setBulkBind(false);
1054             }
1055             mBindOnResumeCallbacks.clear();
1056             if (DEBUG_RESUME_TIME) {
1057                 Log.d(TAG, &quot;Time spent processing callbacks in onResume: &quot; +
1058                     (System.currentTimeMillis() - startTimeCallbacks));
1059             }
1060         }
1061         if (mOnResumeCallbacks.size() &gt; 0) {
1062             for (int i = 0; i &lt; mOnResumeCallbacks.size(); i++) {
1063                 mOnResumeCallbacks.get(i).run();
1064             }
1065             mOnResumeCallbacks.clear();
1066         }
1067 
1068         // Reset the pressed state of icons that were locked in the press state while activities
1069         // were launching
1070         if (mWaitingForResume != null) {
1071             // Resets the previous workspace icon press state
1072             mWaitingForResume.setStayPressed(false);
1073         }
1074 
1075         // It is possible that widgets can receive updates while launcher is not in the foreground.
1076         // Consequently, the widgets will be inflated in the orientation of the foreground activity
1077         // (framework issue). On resuming, we ensure that any widgets are inflated for the current
1078         // orientation.
1079         getWorkspace().reinflateWidgetsIfNecessary();
1080 
1081         // Process any items that were added while Launcher was away.
1082         InstallShortcutReceiver.disableAndFlushInstallQueue(this);
1083 
1084         // Update the voice search button proxy
1085         updateVoiceButtonProxyVisible(false);
1086 
1087         // Again, as with the above scenario, it&#x27;s possible that one or more of the global icons
1088         // were updated in the wrong orientation.
1089         updateGlobalIcons();
1090         if (DEBUG_RESUME_TIME) {
1091             Log.d(TAG, &quot;Time spent in onResume: &quot; + (System.currentTimeMillis() - startTime));
1092         }
1093 
1094         if (mWorkspace.getCustomContentCallbacks() != null) {
1095             // If we are resuming and the custom content is the current page, we call onShow().
1096             // It is also poassible that onShow will instead be called slightly after first layout
1097             // if PagedView#setRestorePage was set to the custom content page in onCreate().
1098             if (mWorkspace.isOnOrMovingToCustomContent()) {
1099                 mWorkspace.getCustomContentCallbacks().onShow(true);
1100             }
1101         }
1102         mWorkspace.updateInteractionForState();
1103         mWorkspace.onResume();
1104 
1105         PackageInstallerCompat.getInstance(this).onResume();
1106     }
1107 
1108     @Override
1109     protected void onPause() {
1110         // Ensure that items added to Launcher are queued until Launcher returns
1111         InstallShortcutReceiver.enableInstallQueue();
1112         PackageInstallerCompat.getInstance(this).onPause();
1113 
1114         super.onPause();
1115         mPaused = true;
1116         mDragController.cancelDrag();
1117         mDragController.resetLastGestureUpTime();
1118 
1119         // We call onHide() aggressively. The custom content callbacks should be able to
1120         // debounce excess onHide calls.
1121         if (mWorkspace.getCustomContentCallbacks() != null) {
1122             mWorkspace.getCustomContentCallbacks().onHide();
1123         }
1124     }
1125 
1126     QSBScroller mQsbScroller = new QSBScroller() {
1127         int scrollY = 0;
1128 
1129         @Override
1130         public void setScrollY(int scroll) {
1131             scrollY = scroll;
1132 
1133             if (mWorkspace.isOnOrMovingToCustomContent()) {
1134                 mSearchDropTargetBar.setTranslationY(- scrollY);
1135                 getQsbBar().setTranslationY(-scrollY);
1136             }
1137         }
1138     };
1139 
1140     public void resetQSBScroll() {
1141         mSearchDropTargetBar.animate().translationY(0).start();
1142         getQsbBar().animate().translationY(0).start();
1143     }
1144 
1145     public interface CustomContentCallbacks {
1146         // Custom content is completely shown. {@code fromResume} indicates whether this was caused
1147         // by a onResume or by scrolling otherwise.
1148         public void onShow(boolean fromResume);
1149 
1150         // Custom content is completely hidden
1151         public void onHide();
1152 
1153         // Custom content scroll progress changed. From 0 (not showing) to 1 (fully showing).
1154         public void onScrollProgressChanged(float progress);
1155 
1156         // Indicates whether the user is allowed to scroll away from the custom content.
1157         boolean isScrollingAllowed();
1158     }
1159 
1160     protected boolean hasSettings() {
1161         return false;
1162     }
1163 
1164     public interface QSBScroller {
1165         public void setScrollY(int scrollY);
1166     }
1167 
1168     public QSBScroller addToCustomContentPage(View customContent,
1169             CustomContentCallbacks callbacks, String description) {
1170         mWorkspace.addToCustomContentPage(customContent, callbacks, description);
1171         return mQsbScroller;
1172     }
1173 
1174     // The custom content needs to offset its content to account for the QSB
1175     public int getTopOffsetForCustomContent() {
1176         return mWorkspace.getPaddingTop();
1177     }
1178 
1179     @Override
1180     public Object onRetainNonConfigurationInstance() {
1181         // Flag the loader to stop early before switching
1182         if (mModel.isCurrentCallbacks(this)) {
1183             mModel.stopLoader();
1184         }
1185         if (mAppsCustomizeContent != null) {
1186             mAppsCustomizeContent.surrender();
1187         }
1188         return Boolean.TRUE;
1189     }
1190 
1191     // We can&#x27;t hide the IME if it was forced open.  So don&#x27;t bother
1192     @Override
1193     public void onWindowFocusChanged(boolean hasFocus) {
1194         super.onWindowFocusChanged(hasFocus);
1195         mHasFocus = hasFocus;
1196     }
1197 
1198     private boolean acceptFilter() {
1199         final InputMethodManager inputManager = (InputMethodManager)
1200                 getSystemService(Context.INPUT_METHOD_SERVICE);
1201         return !inputManager.isFullscreenMode();
1202     }
1203 
1204     @Override
1205     public boolean onKeyDown(int keyCode, KeyEvent event) {
1206         final int uniChar = event.getUnicodeChar();
1207         final boolean handled = super.onKeyDown(keyCode, event);
1208         final boolean isKeyNotWhitespace = uniChar &gt; 0 &amp;&amp; !Character.isWhitespace(uniChar);
1209         if (!handled &amp;&amp; acceptFilter() &amp;&amp; isKeyNotWhitespace) {
1210             boolean gotKey = TextKeyListener.getInstance().onKeyDown(mWorkspace, mDefaultKeySsb,
1211                     keyCode, event);
1212             if (gotKey &amp;&amp; mDefaultKeySsb != null &amp;&amp; mDefaultKeySsb.length() &gt; 0) {
1213                 // something usable has been typed - start a search
1214                 // the typed text will be retrieved and cleared by
1215                 // showSearchDialog()
1216                 // If there are multiple keystrokes before the search dialog takes focus,
1217                 // onSearchRequested() will be called for every keystroke,
1218                 // but it is idempotent, so it&#x27;s fine.
1219                 return onSearchRequested();
1220             }
1221         }
1222 
1223         // Eat the long press event so the keyboard doesn&#x27;t come up.
1224         if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.isLongPress()) {
1225             return true;
1226         }
1227 
1228         return handled;
1229     }
1230 
1231     private String getTypedText() {
1232         return mDefaultKeySsb.toString();
1233     }
1234 
1235     private void clearTypedText() {
1236         mDefaultKeySsb.clear();
1237         mDefaultKeySsb.clearSpans();
1238         Selection.setSelection(mDefaultKeySsb, 0);
1239     }
1240 
1241     /**
1242      * Given the integer (ordinal) value of a State enum instance, convert it to a variable of type
1243      * State
1244      */
1245     private static State intToState(int stateOrdinal) {
1246         State state = State.WORKSPACE;
1247         final State[] stateValues = State.values();
1248         for (int i = 0; i &lt; stateValues.length; i++) {
1249             if (stateValues[i].ordinal() == stateOrdinal) {
1250                 state = stateValues[i];
1251                 break;
1252             }
1253         }
1254         return state;
1255     }
1256 
1257     /**
1258      * Restores the previous state, if it exists.
1259      *
1260      * @param savedState The previous state.
1261      */
1262     @SuppressWarnings(&quot;unchecked&quot;)
1263     private void restoreState(Bundle savedState) {
1264         if (savedState == null) {
1265             return;
1266         }
1267 
1268         State state = intToState(savedState.getInt(RUNTIME_STATE, State.WORKSPACE.ordinal()));
1269         if (state == State.APPS_CUSTOMIZE) {
1270             mOnResumeState = State.APPS_CUSTOMIZE;
1271         }
1272 
1273         int currentScreen = savedState.getInt(RUNTIME_STATE_CURRENT_SCREEN,
1274                 PagedView.INVALID_RESTORE_PAGE);
1275         if (currentScreen != PagedView.INVALID_RESTORE_PAGE) {
1276             mWorkspace.setRestorePage(currentScreen);
1277         }
1278 
1279         final long pendingAddContainer = savedState.getLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, -1);
1280         final long pendingAddScreen = savedState.getLong(RUNTIME_STATE_PENDING_ADD_SCREEN, -1);
1281 
1282         if (pendingAddContainer != ItemInfo.NO_ID &amp;&amp; pendingAddScreen &gt; -1) {
1283             mPendingAddInfo.container = pendingAddContainer;
1284             mPendingAddInfo.screenId = pendingAddScreen;
1285             mPendingAddInfo.cellX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_X);
1286             mPendingAddInfo.cellY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_Y);
1287             mPendingAddInfo.spanX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_X);
1288             mPendingAddInfo.spanY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y);
1289             mPendingAddWidgetInfo = savedState.getParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO);
1290             mPendingAddWidgetId = savedState.getInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID);
1291             setWaitingForResult(true);
1292             mRestoring = true;
1293         }
1294 
1295         boolean renameFolder = savedState.getBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, false);
1296         if (renameFolder) {
1297             long id = savedState.getLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID);
1298             mFolderInfo = mModel.getFolderById(this, sFolders, id);
1299             mRestoring = true;
1300         }
1301 
1302         // Restore the AppsCustomize tab
1303         if (mAppsCustomizeTabHost != null) {
1304             String curTab = savedState.getString(&quot;apps_customize_currentTab&quot;);
1305             if (curTab != null) {
1306                 mAppsCustomizeTabHost.setContentTypeImmediate(
1307                         mAppsCustomizeTabHost.getContentTypeForTabTag(curTab));
1308                 mAppsCustomizeContent.loadAssociatedPages(
1309                         mAppsCustomizeContent.getCurrentPage());
1310             }
1311 
1312             int currentIndex = savedState.getInt(&quot;apps_customize_currentIndex&quot;);
1313             mAppsCustomizeContent.restorePageForIndex(currentIndex);
1314         }
1315         mItemIdToViewId = (HashMap&lt;Integer, Integer&gt;)
1316                 savedState.getSerializable(RUNTIME_STATE_VIEW_IDS);
1317     }
1318 
1319     /**
1320      * Finds all the views we need and configure them properly.
1321      */
1322     private void setupViews() {
1323         final DragController dragController = mDragController;
1324 
1325         mLauncherView = findViewById(R.id.launcher);
1326         mFocusHandler = (FocusIndicatorView) findViewById(R.id.focus_indicator);
1327         mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
1328         mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
1329 
1330 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1331         mWorkspace.setPageSwitchListener(this);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1332 </span>
1333 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1334 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">1334 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
1335 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1336 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1337 </span>
1338 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
1339         mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);
1340 
1341         mLauncherView.setSystemUiVisibility(
1342                 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
1343         mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
1344 
1345         // Setup the drag layer
1346         mDragLayer.setup(this, dragController);
1347 
1348         // Setup the hotseat
1349         mHotseat = (Hotseat) findViewById(R.id.hotseat);
1350         if (mHotseat != null) {
1351             mHotseat.setup(this);
1352             mHotseat.setOnLongClickListener(this);
1353         }
1354 
1355         mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
1356         View widgetButton = findViewById(R.id.widget_button);
1357         widgetButton.setOnClickListener(new OnClickListener() {
1358             @Override
1359             public void onClick(View arg0) {
1360                 if (!mWorkspace.isSwitchingState()) {
1361                     onClickAddWidgetButton(arg0);
1362                 }
1363             }
1364         });
1365         widgetButton.setOnTouchListener(getHapticFeedbackTouchListener());
1366 
1367         View wallpaperButton = findViewById(R.id.wallpaper_button);
1368         wallpaperButton.setOnClickListener(new OnClickListener() {
1369             @Override
1370             public void onClick(View arg0) {
1371                 if (!mWorkspace.isSwitchingState()) {
1372                     onClickWallpaperPicker(arg0);
1373                 }
1374             }
1375         });
1376         wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
1377 
1378         View settingsButton = findViewById(R.id.settings_button);
1379         if (hasSettings()) {
1380             settingsButton.setOnClickListener(new OnClickListener() {
1381                 @Override
1382                 public void onClick(View arg0) {
1383                     if (!mWorkspace.isSwitchingState()) {
1384                         onClickSettingsButton(arg0);
1385                     }
1386                 }
1387             });
1388             settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
1389         } else {
1390             settingsButton.setVisibility(View.GONE);
1391             FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) widgetButton.getLayoutParams();
1392             lp.gravity = Gravity.END | Gravity.TOP;
1393             widgetButton.requestLayout();
1394         }
1395 
1396         mOverviewPanel.setAlpha(0f);
1397 
1398         // Setup the workspace
1399         mWorkspace.setHapticFeedbackEnabled(false);
1400         mWorkspace.setOnLongClickListener(this);
1401         mWorkspace.setup(dragController);
1402         dragController.addDragListener(mWorkspace);
1403 
1404         // Get the search/delete bar
1405         mSearchDropTargetBar = (SearchDropTargetBar)
1406                 mDragLayer.findViewById(R.id.search_drop_target_bar);
1407 
1408         // Setup AppsCustomize
1409         mAppsCustomizeTabHost = (AppsCustomizeTabHost) findViewById(R.id.apps_customize_pane);
1410         mAppsCustomizeContent = (AppsCustomizePagedView)
1411                 mAppsCustomizeTabHost.findViewById(R.id.apps_customize_pane_content);
1412         mAppsCustomizeContent.setup(this, dragController);
1413 
1414         // Setup the drag controller (drop targets have to be added in reverse order in priority)
1415         dragController.setDragScoller(mWorkspace);
1416         dragController.setScrollView(mDragLayer);
1417         dragController.setMoveTarget(mWorkspace);
1418         dragController.addDropTarget(mWorkspace);
1419         if (mSearchDropTargetBar != null) {
1420             mSearchDropTargetBar.setup(this, dragController);
1421         }
1422 
1423         if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
1424             Log.v(TAG, &quot;adding WeightWatcher&quot;);
1425             mWeightWatcher = new WeightWatcher(this);
1426             mWeightWatcher.setAlpha(0.5f);
1427             ((FrameLayout) mLauncherView).addView(mWeightWatcher,
1428                     new FrameLayout.LayoutParams(
1429                             FrameLayout.LayoutParams.MATCH_PARENT,
1430                             FrameLayout.LayoutParams.WRAP_CONTENT,
1431                             Gravity.BOTTOM)
1432             );
1433 
1434             boolean show = shouldShowWeightWatcher();
1435             mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
1436         }
1437     }
1438 
1439     /**
1440      * Sets the all apps button. This method is called from {@link Hotseat}.
1441      */
1442     public void setAllAppsButton(View allAppsButton) {
1443         mAllAppsButton = allAppsButton;
1444     }
1445 
1446     public View getAllAppsButton() {
1447         return mAllAppsButton;
1448     }
1449 
1450     /**
1451      * Creates a view representing a shortcut.
1452      *
1453      * @param info The data structure describing the shortcut.
1454      *
1455      * @return A View inflated from R.layout.application.
1456      */
1457     View createShortcut(ShortcutInfo info) {
1458         return createShortcut(R.layout.application,
1459                 (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
1460     }
1461 
1462     /**
1463      * Creates a view representing a shortcut inflated from the specified resource.
1464      *
1465      * @param layoutResId The id of the XML layout used to create the shortcut.
1466      * @param parent The group the shortcut belongs to.
1467      * @param info The data structure describing the shortcut.
1468      *
1469      * @return A View inflated from layoutResId.
1470      */
1471     View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) {
1472         BubbleTextView favorite = (BubbleTextView) mInflater.inflate(layoutResId, parent, false);
1473         favorite.applyFromShortcutInfo(info, mIconCache, true);
1474         favorite.setOnClickListener(this);
1475         favorite.setOnFocusChangeListener(mFocusHandler);
1476         return favorite;
1477     }
1478 
1479     /**
1480      * Add a shortcut to the workspace.
1481      *
1482      * @param data The intent describing the shortcut.
1483      * @param cellInfo The position on screen where to create the shortcut.
1484      */
1485     private void completeAddShortcut(Intent data, long container, long screenId, int cellX,
1486             int cellY) {
1487         int[] cellXY = mTmpAddItemCellCoordinates;
1488         int[] touchXY = mPendingAddInfo.dropPos;
1489         CellLayout layout = getCellLayout(container, screenId);
1490 
1491         boolean foundCellSpan = false;
1492 
1493         ShortcutInfo info = mModel.infoFromShortcutIntent(this, data, null);
1494         if (info == null) {
1495             return;
1496         }
1497         final View view = createShortcut(info);
1498 
1499         // First we check if we already know the exact location where we want to add this item.
1500         if (cellX &gt;= 0 &amp;&amp; cellY &gt;= 0) {
1501             cellXY[0] = cellX;
1502             cellXY[1] = cellY;
1503             foundCellSpan = true;
1504 
1505             // If appropriate, either create a folder or add to an existing folder
1506             if (mWorkspace.createUserFolderIfNecessary(view, container, layout, cellXY, 0,
1507                     true, null,null)) {
1508                 return;
1509             }
1510             DragObject dragObject = new DragObject();
1511             dragObject.dragInfo = info;
1512             if (mWorkspace.addToExistingFolderIfNecessary(view, layout, cellXY, 0, dragObject,
1513                     true)) {
1514                 return;
1515             }
1516         } else if (touchXY != null) {
1517             // when dragging and dropping, just find the closest free spot
1518             int[] result = layout.findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, cellXY);
1519             foundCellSpan = (result != null);
1520         } else {
1521             foundCellSpan = layout.findCellForSpan(cellXY, 1, 1);
1522         }
1523 
1524         if (!foundCellSpan) {
1525             showOutOfSpaceMessage(isHotseatLayout(layout));
1526             return;
1527         }
1528 
1529         LauncherModel.addItemToDatabase(this, info, container, screenId, cellXY[0], cellXY[1], false);
1530 
1531         if (!mRestoring) {
1532             mWorkspace.addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1,
1533                     isWorkspaceLocked());
1534         }
1535     }
1536 
1537     static int[] getSpanForWidget(Context context, ComponentName component, int minWidth,
1538             int minHeight) {
1539         Rect padding = AppWidgetHostView.getDefaultPaddingForWidget(context, component, null);
1540         // We want to account for the extra amount of padding that we are adding to the widget
1541         // to ensure that it gets the full amount of space that it has requested
1542         int requiredWidth = minWidth + padding.left + padding.right;
1543         int requiredHeight = minHeight + padding.top + padding.bottom;
1544         return CellLayout.rectToCell(requiredWidth, requiredHeight, null);
1545     }
1546 
1547     static int[] getSpanForWidget(Context context, AppWidgetProviderInfo info) {
1548         return getSpanForWidget(context, info.provider, info.minWidth, info.minHeight);
1549     }
1550 
1551     static int[] getMinSpanForWidget(Context context, AppWidgetProviderInfo info) {
1552         return getSpanForWidget(context, info.provider, info.minResizeWidth, info.minResizeHeight);
1553     }
1554 
1555     static int[] getSpanForWidget(Context context, PendingAddWidgetInfo info) {
1556         return getSpanForWidget(context, info.componentName, info.minWidth, info.minHeight);
1557     }
1558 
1559     static int[] getMinSpanForWidget(Context context, PendingAddWidgetInfo info) {
1560         return getSpanForWidget(context, info.componentName, info.minResizeWidth,
1561                 info.minResizeHeight);
1562     }
1563 
1564     /**
1565      * Add a widget to the workspace.
1566      *
1567      * @param appWidgetId The app widget id
1568      * @param cellInfo The position on screen where to create the widget.
1569      */
1570     private void completeAddAppWidget(final int appWidgetId, long container, long screenId,
1571             AppWidgetHostView hostView, AppWidgetProviderInfo appWidgetInfo) {
1572         if (appWidgetInfo == null) {
1573             appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
1574         }
1575 
1576         // Calculate the grid spans needed to fit this widget
1577         CellLayout layout = getCellLayout(container, screenId);
1578 
1579         int[] minSpanXY = getMinSpanForWidget(this, appWidgetInfo);
1580         int[] spanXY = getSpanForWidget(this, appWidgetInfo);
1581 
1582         // Try finding open space on Launcher screen
1583         // We have saved the position to which the widget was dragged-- this really only matters
1584         // if we are placing widgets on a &quot;spring-loaded&quot; screen
1585         int[] cellXY = mTmpAddItemCellCoordinates;
1586         int[] touchXY = mPendingAddInfo.dropPos;
1587         int[] finalSpan = new int[2];
1588         boolean foundCellSpan = false;
1589         if (mPendingAddInfo.cellX &gt;= 0 &amp;&amp; mPendingAddInfo.cellY &gt;= 0) {
1590             cellXY[0] = mPendingAddInfo.cellX;
1591             cellXY[1] = mPendingAddInfo.cellY;
1592             spanXY[0] = mPendingAddInfo.spanX;
1593             spanXY[1] = mPendingAddInfo.spanY;
1594             foundCellSpan = true;
1595         } else if (touchXY != null) {
1596             // when dragging and dropping, just find the closest free spot
1597             int[] result = layout.findNearestVacantArea(
1598                     touchXY[0], touchXY[1], minSpanXY[0], minSpanXY[1], spanXY[0],
1599                     spanXY[1], cellXY, finalSpan);
1600             spanXY[0] = finalSpan[0];
1601             spanXY[1] = finalSpan[1];
1602             foundCellSpan = (result != null);
1603         } else {
1604             foundCellSpan = layout.findCellForSpan(cellXY, minSpanXY[0], minSpanXY[1]);
1605         }
1606 
1607         if (!foundCellSpan) {
1608             if (appWidgetId != -1) {
1609                 // Deleting an app widget ID is a void call but writes to disk before returning
1610                 // to the caller...
1611                 new AsyncTask&lt;Void, Void, Void&gt;() {
1612                     public Void doInBackground(Void ... args) {
1613                         mAppWidgetHost.deleteAppWidgetId(appWidgetId);
1614                         return null;
1615                     }
1616                 }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
1617             }
1618             showOutOfSpaceMessage(isHotseatLayout(layout));
1619             return;
1620         }
1621 
1622         // Build Launcher-specific widget info and save to database
1623         LauncherAppWidgetInfo launcherInfo = new LauncherAppWidgetInfo(appWidgetId,
1624                 appWidgetInfo.provider);
1625         launcherInfo.spanX = spanXY[0];
1626         launcherInfo.spanY = spanXY[1];
1627         launcherInfo.minSpanX = mPendingAddInfo.minSpanX;
1628         launcherInfo.minSpanY = mPendingAddInfo.minSpanY;
1629         launcherInfo.user = mAppWidgetManager.getUser(appWidgetInfo);
1630 
1631         LauncherModel.addItemToDatabase(this, launcherInfo,
1632                 container, screenId, cellXY[0], cellXY[1], false);
1633 
1634         if (!mRestoring) {
1635             if (hostView == null) {
1636                 // Perform actual inflation because we&#x27;re live
1637                 launcherInfo.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);
1638                 launcherInfo.hostView.setAppWidget(appWidgetId, appWidgetInfo);
1639             } else {
1640                 // The AppWidgetHostView has already been inflated and instantiated
1641                 launcherInfo.hostView = hostView;
1642             }
1643 
1644             launcherInfo.hostView.setTag(launcherInfo);
1645             launcherInfo.hostView.setVisibility(View.VISIBLE);
1646             launcherInfo.notifyWidgetSizeChanged(this);
1647 
1648             mWorkspace.addInScreen(launcherInfo.hostView, container, screenId, cellXY[0], cellXY[1],
1649                     launcherInfo.spanX, launcherInfo.spanY, isWorkspaceLocked());
1650 
1651             addWidgetToAutoAdvanceIfNeeded(launcherInfo.hostView, appWidgetInfo);
1652         }
1653         resetAddInfo();
1654     }
1655 
1656     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
1657         @Override
1658         public void onReceive(Context context, Intent intent) {
1659             final String action = intent.getAction();
1660             if (Intent.ACTION_SCREEN_OFF.equals(action)) {
1661                 mUserPresent = false;
1662                 mDragLayer.clearAllResizeFrames();
1663                 updateRunning();
1664 
1665                 // Reset AllApps to its initial state only if we are not in the middle of
1666                 // processing a multi-step drop
1667                 if (mAppsCustomizeTabHost != null &amp;&amp; mPendingAddInfo.container == ItemInfo.NO_ID) {
1668                     showWorkspace(false);
1669                 }
1670             } else if (Intent.ACTION_USER_PRESENT.equals(action)) {
1671                 mUserPresent = true;
1672                 updateRunning();
1673             } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.DELETE_DATABASE.equals(action)) {
1674                 mModel.resetLoadedState(false, true);
1675                 mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,
1676                         LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE);
1677             } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.MIGRATE_DATABASE.equals(action)) {
1678                 mModel.resetLoadedState(false, true);
1679                 mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,
1680                         LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE
1681                                 | LauncherModel.LOADER_FLAG_MIGRATE_SHORTCUTS);
1682 
1683 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1684             } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1685                     || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1686                 getModel().forceReload();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1687 </span>
1688 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1689 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">1689 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
1690 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1691 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1692 </span>
1693 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
1694             }
1695         }
1696     };
1697 
1698     @Override
1699     public void onAttachedToWindow() {
1700         super.onAttachedToWindow();
1701 
1702         // Listen for broadcasts related to user-presence
1703         final IntentFilter filter = new IntentFilter();
1704         filter.addAction(Intent.ACTION_SCREEN_OFF);
1705         filter.addAction(Intent.ACTION_USER_PRESENT);
1706 
1707 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1708         // For handling managed profiles</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1709         filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1710         filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1711 </span>
1712 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1713 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">1713 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
1714 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1715 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1716 </span>
1717 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
1718         if (ENABLE_DEBUG_INTENTS) {
1719             filter.addAction(DebugIntents.DELETE_DATABASE);
1720             filter.addAction(DebugIntents.MIGRATE_DATABASE);
1721         }
1722         registerReceiver(mReceiver, filter);
1723         FirstFrameAnimatorHelper.initializeDrawListener(getWindow().getDecorView());
1724         setupTransparentSystemBarsForLmp();
1725         mAttached = true;
1726         mVisible = true;
1727     }
1728 
1729     /**
1730      * Sets up transparent navigation and status bars in LMP.
1731      * This method is a no-op for other platform versions.
1732      */
1733     @TargetApi(19)
1734     private void setupTransparentSystemBarsForLmp() {
1735         // TODO(sansid): use the APIs directly when compiling against L sdk.
1736         // Currently we use reflection to access the flags and the API to set the transparency
1737         // on the System bars.
1738         if (Utilities.isLmpOrAbove()) {
1739             try {
1740                 getWindow().getAttributes().systemUiVisibility |=
1741                         (View.SYSTEM_UI_FLAG_LAYOUT_STABLE
1742                                 | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
1743                                 | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
1744                 getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS
1745                         | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
1746                 Field drawsSysBackgroundsField = WindowManager.LayoutParams.class.getField(
1747                         &quot;FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS&quot;);
1748                 getWindow().addFlags(drawsSysBackgroundsField.getInt(null));
1749 
1750                 Method setStatusBarColorMethod =
1751                         Window.class.getDeclaredMethod(&quot;setStatusBarColor&quot;, int.class);
1752                 Method setNavigationBarColorMethod =
1753                         Window.class.getDeclaredMethod(&quot;setNavigationBarColor&quot;, int.class);
1754                 setStatusBarColorMethod.invoke(getWindow(), Color.TRANSPARENT);
1755                 setNavigationBarColorMethod.invoke(getWindow(), Color.TRANSPARENT);
1756             } catch (NoSuchFieldException e) {
1757                 Log.w(TAG, &quot;NoSuchFieldException while setting up transparent bars&quot;);
1758             } catch (NoSuchMethodException ex) {
1759                 Log.w(TAG, &quot;NoSuchMethodException while setting up transparent bars&quot;);
1760             } catch (IllegalAccessException e) {
1761                 Log.w(TAG, &quot;IllegalAccessException while setting up transparent bars&quot;);
1762             } catch (IllegalArgumentException e) {
1763                 Log.w(TAG, &quot;IllegalArgumentException while setting up transparent bars&quot;);
1764             } catch (InvocationTargetException e) {
1765                 Log.w(TAG, &quot;InvocationTargetException while setting up transparent bars&quot;);
1766             } finally {}
1767         }
1768     }
1769 
1770     @Override
1771     public void onDetachedFromWindow() {
1772         super.onDetachedFromWindow();
1773         mVisible = false;
1774 
1775         if (mAttached) {
1776             unregisterReceiver(mReceiver);
1777             mAttached = false;
1778         }
1779         updateRunning();
1780     }
1781 
1782     public void onWindowVisibilityChanged(int visibility) {
1783         mVisible = visibility == View.VISIBLE;
1784         updateRunning();
1785         // The following code used to be in onResume, but it turns out onResume is called when
1786         // you&#x27;re in All Apps and click home to go to the workspace. onWindowVisibilityChanged
1787         // is a more appropriate event to handle
1788         if (mVisible) {
1789             mAppsCustomizeTabHost.onWindowVisible();
1790             if (!mWorkspaceLoading) {
1791                 final ViewTreeObserver observer = mWorkspace.getViewTreeObserver();
1792                 // We want to let Launcher draw itself at least once before we force it to build
1793                 // layers on all the workspace pages, so that transitioning to Launcher from other
1794                 // apps is nice and speedy.
1795                 observer.addOnDrawListener(new ViewTreeObserver.OnDrawListener() {
1796                     private boolean mStarted = false;
1797                     public void onDraw() {
1798                         if (mStarted) return;
1799                         mStarted = true;
1800                         // We delay the layer building a bit in order to give
1801                         // other message processing a time to run.  In particular
1802                         // this avoids a delay in hiding the IME if it was
1803                         // currently shown, because doing that may involve
1804                         // some communication back with the app.
1805                         mWorkspace.postDelayed(mBuildLayersRunnable, 500);
1806                         final ViewTreeObserver.OnDrawListener listener = this;
1807                         mWorkspace.post(new Runnable() {
1808                                 public void run() {
1809                                     if (mWorkspace != null &amp;&amp;
1810                                             mWorkspace.getViewTreeObserver() != null) {
1811                                         mWorkspace.getViewTreeObserver().
1812                                                 removeOnDrawListener(listener);
1813                                     }
1814                                 }
1815                             });
1816                         return;
1817                     }
1818                 });
1819             }
1820             clearTypedText();
1821         }
1822     }
1823 
1824     private void sendAdvanceMessage(long delay) {
1825         mHandler.removeMessages(ADVANCE_MSG);
1826         Message msg = mHandler.obtainMessage(ADVANCE_MSG);
1827         mHandler.sendMessageDelayed(msg, delay);
1828         mAutoAdvanceSentTime = System.currentTimeMillis();
1829     }
1830 
1831     private void updateRunning() {
1832         boolean autoAdvanceRunning = mVisible &amp;&amp; mUserPresent &amp;&amp; !mWidgetsToAdvance.isEmpty();
1833         if (autoAdvanceRunning != mAutoAdvanceRunning) {
1834             mAutoAdvanceRunning = autoAdvanceRunning;
1835             if (autoAdvanceRunning) {
1836                 long delay = mAutoAdvanceTimeLeft == -1 ? mAdvanceInterval : mAutoAdvanceTimeLeft;
1837                 sendAdvanceMessage(delay);
1838             } else {
1839                 if (!mWidgetsToAdvance.isEmpty()) {
1840                     mAutoAdvanceTimeLeft = Math.max(0, mAdvanceInterval -
1841                             (System.currentTimeMillis() - mAutoAdvanceSentTime));
1842                 }
1843                 mHandler.removeMessages(ADVANCE_MSG);
1844                 mHandler.removeMessages(0); // Remove messages sent using postDelayed()
1845             }
1846         }
1847     }
1848 
1849     private final Handler mHandler = new Handler() {
1850         @Override
1851         public void handleMessage(Message msg) {
1852             if (msg.what == ADVANCE_MSG) {
1853                 int i = 0;
1854                 for (View key: mWidgetsToAdvance.keySet()) {
1855                     final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);
1856                     final int delay = mAdvanceStagger * i;
1857                     if (v instanceof Advanceable) {
1858                        postDelayed(new Runnable() {
1859                            public void run() {
1860                                ((Advanceable) v).advance();
1861                            }
1862                        }, delay);
1863                     }
1864                     i++;
1865                 }
1866                 sendAdvanceMessage(mAdvanceInterval);
1867             }
1868         }
1869     };
1870 
1871     void addWidgetToAutoAdvanceIfNeeded(View hostView, AppWidgetProviderInfo appWidgetInfo) {
1872         if (appWidgetInfo == null || appWidgetInfo.autoAdvanceViewId == -1) return;
1873         View v = hostView.findViewById(appWidgetInfo.autoAdvanceViewId);
1874         if (v instanceof Advanceable) {
1875             mWidgetsToAdvance.put(hostView, appWidgetInfo);
1876             ((Advanceable) v).fyiWillBeAdvancedByHostKThx();
1877             updateRunning();
1878         }
1879     }
1880 
1881     void removeWidgetToAutoAdvance(View hostView) {
1882         if (mWidgetsToAdvance.containsKey(hostView)) {
1883             mWidgetsToAdvance.remove(hostView);
1884             updateRunning();
1885         }
1886     }
1887 
1888     public void removeAppWidget(LauncherAppWidgetInfo launcherInfo) {
1889         removeWidgetToAutoAdvance(launcherInfo.hostView);
1890         launcherInfo.hostView = null;
1891     }
1892 
1893     void showOutOfSpaceMessage(boolean isHotseatLayout) {
1894         int strId = (isHotseatLayout ? R.string.hotseat_out_of_space : R.string.out_of_space);
1895         Toast.makeText(this, getString(strId), Toast.LENGTH_SHORT).show();
1896     }
1897 
1898     public DragLayer getDragLayer() {
1899         return mDragLayer;
1900     }
1901 
1902     public Workspace getWorkspace() {
1903         return mWorkspace;
1904     }
1905 
1906     public Hotseat getHotseat() {
1907         return mHotseat;
1908     }
1909 
1910 
1911 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1912     public ViewGroup getOverviewPanel() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1913 </span>
1914 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1915 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">1915 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
1916 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1917 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1918     public View getOverviewPanel() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1919 </span>
1920 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
1921         return mOverviewPanel;
1922     }
1923 
1924     public SearchDropTargetBar getSearchBar() {
1925         return mSearchDropTargetBar;
1926     }
1927 
1928     public LauncherAppWidgetHost getAppWidgetHost() {
1929         return mAppWidgetHost;
1930     }
1931 
1932     public LauncherModel getModel() {
1933         return mModel;
1934     }
1935 
1936 
1937 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1938 </span>
1939 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1940 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">1940 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
1941 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1942 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1943     public LauncherClings getLauncherClings() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1944         return mLauncherClings;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1945     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1946 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1947 </span>
1948 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
1949     protected SharedPreferences getSharedPrefs() {
1950         return mSharedPrefs;
1951     }
1952 
1953     public void closeSystemDialogs() {
1954         getWindow().closeAllPanels();
1955 
1956         // Whatever we were doing is hereby canceled.
1957         setWaitingForResult(false);
1958     }
1959 
1960     @Override
1961     protected void onNewIntent(Intent intent) {
1962         long startTime = 0;
1963         if (DEBUG_RESUME_TIME) {
1964             startTime = System.currentTimeMillis();
1965         }
1966         super.onNewIntent(intent);
1967 
1968         // Close the menu
1969         if (Intent.ACTION_MAIN.equals(intent.getAction())) {
1970             // also will cancel mWaitingForResult.
1971             closeSystemDialogs();
1972 
1973             final boolean alreadyOnHome = mHasFocus &amp;&amp; ((intent.getFlags() &amp;
1974                     Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT)
1975                     != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
1976 
1977             if (mWorkspace == null) {
1978                 // Can be cases where mWorkspace is null, this prevents a NPE
1979                 return;
1980             }
1981             Folder openFolder = mWorkspace.getOpenFolder();
1982             // In all these cases, only animate if we&#x27;re already on home
1983             mWorkspace.exitWidgetResizeMode();
1984             if (alreadyOnHome &amp;&amp; mState == State.WORKSPACE &amp;&amp; !mWorkspace.isTouchActive() &amp;&amp;
1985                     openFolder == null &amp;&amp; shouldMoveToDefaultScreenOnHomeIntent()) {
1986                 mWorkspace.moveToDefaultScreen(true);
1987             }
1988 
1989             closeFolder();
1990             exitSpringLoadedDragMode();
1991 
1992             // If we are already on home, then just animate back to the workspace,
1993             // otherwise, just wait until onResume to set the state back to Workspace
1994             if (alreadyOnHome) {
1995                 showWorkspace(true);
1996             } else {
1997                 mOnResumeState = State.WORKSPACE;
1998             }
1999 
2000             final View v = getWindow().peekDecorView();
2001             if (v != null &amp;&amp; v.getWindowToken() != null) {
2002                 InputMethodManager imm = (InputMethodManager)getSystemService(
2003                         INPUT_METHOD_SERVICE);
2004                 imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
2005             }
2006 
2007             // Reset the apps customize page
2008             if (!alreadyOnHome &amp;&amp; mAppsCustomizeTabHost != null) {
2009                 mAppsCustomizeTabHost.reset();
2010             }
2011 
2012             onHomeIntent();
2013         }
2014 
2015         if (DEBUG_RESUME_TIME) {
2016             Log.d(TAG, &quot;Time spent in onNewIntent: &quot; + (System.currentTimeMillis() - startTime));
2017         }
2018     }
2019 
2020     /**
2021      * Override point for subclasses to prevent movement to the default screen when the home
2022      * button is pressed. Used (for example) in GEL, to prevent movement during a search.
2023      */
2024     protected boolean shouldMoveToDefaultScreenOnHomeIntent() {
2025         return true;
2026     }
2027 
2028     /**
2029      * Override point for subclasses to provide custom behaviour for when a home intent is fired.
2030      */
2031     protected void onHomeIntent() {
2032         // Do nothing
2033     }
2034 
2035     @Override
2036     public void onRestoreInstanceState(Bundle state) {
2037         super.onRestoreInstanceState(state);
2038         for (int page: mSynchronouslyBoundPages) {
2039             mWorkspace.restoreInstanceStateForChild(page);
2040         }
2041     }
2042 
2043     @Override
2044     protected void onSaveInstanceState(Bundle outState) {
2045         if (mWorkspace.getChildCount() &gt; 0) {
2046             outState.putInt(RUNTIME_STATE_CURRENT_SCREEN,
2047                     mWorkspace.getCurrentPageOffsetFromCustomContent());
2048         }
2049         super.onSaveInstanceState(outState);
2050 
2051         outState.putInt(RUNTIME_STATE, mState.ordinal());
2052         // We close any open folder since it will not be re-opened, and we need to make sure
2053         // this state is reflected.
2054         closeFolder();
2055 
2056         if (mPendingAddInfo.container != ItemInfo.NO_ID &amp;&amp; mPendingAddInfo.screenId &gt; -1 &amp;&amp;
2057                 mWaitingForResult) {
2058             outState.putLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, mPendingAddInfo.container);
2059             outState.putLong(RUNTIME_STATE_PENDING_ADD_SCREEN, mPendingAddInfo.screenId);
2060             outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_X, mPendingAddInfo.cellX);
2061             outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_Y, mPendingAddInfo.cellY);
2062             outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_X, mPendingAddInfo.spanX);
2063             outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y, mPendingAddInfo.spanY);
2064             outState.putParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO, mPendingAddWidgetInfo);
2065             outState.putInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID, mPendingAddWidgetId);
2066         }
2067 
2068         if (mFolderInfo != null &amp;&amp; mWaitingForResult) {
2069             outState.putBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, true);
2070             outState.putLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID, mFolderInfo.id);
2071         }
2072 
2073         // Save the current AppsCustomize tab
2074         if (mAppsCustomizeTabHost != null) {
2075             AppsCustomizePagedView.ContentType type = mAppsCustomizeContent.getContentType();
2076             String currentTabTag = mAppsCustomizeTabHost.getTabTagForContentType(type);
2077             if (currentTabTag != null) {
2078                 outState.putString(&quot;apps_customize_currentTab&quot;, currentTabTag);
2079             }
2080             int currentIndex = mAppsCustomizeContent.getSaveInstanceStateIndex();
2081             outState.putInt(&quot;apps_customize_currentIndex&quot;, currentIndex);
2082         }
2083         outState.putSerializable(RUNTIME_STATE_VIEW_IDS, mItemIdToViewId);
2084     }
2085 
2086     @Override
2087     public void onDestroy() {
2088         super.onDestroy();
2089 
2090         // Remove all pending runnables
2091         mHandler.removeMessages(ADVANCE_MSG);
2092         mHandler.removeMessages(0);
2093         mWorkspace.removeCallbacks(mBuildLayersRunnable);
2094 
2095         // Stop callbacks from LauncherModel
2096         LauncherAppState app = (LauncherAppState.getInstance());
2097 
2098         // It&#x27;s possible to receive onDestroy after a new Launcher activity has
2099         // been created. In this case, don&#x27;t interfere with the new Launcher.
2100         if (mModel.isCurrentCallbacks(this)) {
2101             mModel.stopLoader();
2102             app.setLauncher(null);
2103         }
2104 
2105         try {
2106             mAppWidgetHost.stopListening();
2107         } catch (NullPointerException ex) {
2108             Log.w(TAG, &quot;problem while stopping AppWidgetHost during Launcher destruction&quot;, ex);
2109         }
2110         mAppWidgetHost = null;
2111 
2112         mWidgetsToAdvance.clear();
2113 
2114         TextKeyListener.getInstance().release();
2115 
2116         // Disconnect any of the callbacks and drawables associated with ItemInfos on the workspace
2117         // to prevent leaking Launcher activities on orientation change.
2118         if (mModel != null) {
2119             mModel.unbindItemInfosAndClearQueuedBindRunnables();
2120         }
2121 
2122         getContentResolver().unregisterContentObserver(mWidgetObserver);
2123         unregisterReceiver(mCloseSystemDialogsReceiver);
2124 
2125         mDragLayer.clearAllResizeFrames();
2126         ((ViewGroup) mWorkspace.getParent()).removeAllViews();
2127         mWorkspace.removeAllWorkspaceScreens();
2128         mWorkspace = null;
2129         mDragController = null;
2130 
2131         PackageInstallerCompat.getInstance(this).onStop();
2132         LauncherAnimUtils.onDestroyActivity();
2133     }
2134 
2135     public DragController getDragController() {
2136         return mDragController;
2137     }
2138 
2139     @Override
2140     public void startActivityForResult(Intent intent, int requestCode) {
2141         if (requestCode &gt;= 0) {
2142             setWaitingForResult(true);
2143         }
2144         super.startActivityForResult(intent, requestCode);
2145     }
2146 
2147     /**
2148      * Indicates that we want global search for this activity by setting the globalSearch
2149      * argument for {@link #startSearch} to true.
2150      */
2151     @Override
2152     public void startSearch(String initialQuery, boolean selectInitialQuery,
2153             Bundle appSearchData, boolean globalSearch) {
2154 
2155         showWorkspace(true);
2156 
2157         if (initialQuery == null) {
2158             // Use any text typed in the launcher as the initial query
2159             initialQuery = getTypedText();
2160         }
2161         if (appSearchData == null) {
2162             appSearchData = new Bundle();
2163             appSearchData.putString(&quot;source&quot;, &quot;launcher-search&quot;);
2164         }
2165         Rect sourceBounds = new Rect();
2166         if (mSearchDropTargetBar != null) {
2167             sourceBounds = mSearchDropTargetBar.getSearchBarBounds();
2168         }
2169 
2170         boolean clearTextImmediately = startSearch(initialQuery, selectInitialQuery,
2171                 appSearchData, sourceBounds);
2172         if (clearTextImmediately) {
2173             clearTypedText();
2174         }
2175     }
2176 
2177     /**
2178      * Start a text search.
2179      *
2180      * @return {@code true} if the search will start immediately, so any further keypresses
2181      * will be handled directly by the search UI. {@code false} if {@link Launcher} should continue
2182      * to buffer keypresses.
2183      */
2184     public boolean startSearch(String initialQuery,
2185             boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2186         startGlobalSearch(initialQuery, selectInitialQuery,
2187                 appSearchData, sourceBounds);
2188         return false;
2189     }
2190 
2191     /**
2192      * Starts the global search activity. This code is a copied from SearchManager
2193      */
2194     private void startGlobalSearch(String initialQuery,
2195             boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2196         final SearchManager searchManager =
2197             (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2198         ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
2199         if (globalSearchActivity == null) {
2200             Log.w(TAG, &quot;No global search activity found.&quot;);
2201             return;
2202         }
2203         Intent intent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
2204         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2205         intent.setComponent(globalSearchActivity);
2206         // Make sure that we have a Bundle to put source in
2207         if (appSearchData == null) {
2208             appSearchData = new Bundle();
2209         } else {
2210             appSearchData = new Bundle(appSearchData);
2211         }
2212         // Set source to package name of app that starts global search, if not set already.
2213         if (!appSearchData.containsKey(&quot;source&quot;)) {
2214             appSearchData.putString(&quot;source&quot;, getPackageName());
2215         }
2216         intent.putExtra(SearchManager.APP_DATA, appSearchData);
2217         if (!TextUtils.isEmpty(initialQuery)) {
2218             intent.putExtra(SearchManager.QUERY, initialQuery);
2219         }
2220         if (selectInitialQuery) {
2221             intent.putExtra(SearchManager.EXTRA_SELECT_QUERY, selectInitialQuery);
2222         }
2223         intent.setSourceBounds(sourceBounds);
2224         try {
2225             startActivity(intent);
2226         } catch (ActivityNotFoundException ex) {
2227             Log.e(TAG, &quot;Global search activity not found: &quot; + globalSearchActivity);
2228         }
2229     }
2230 
2231     public boolean isOnCustomContent() {
2232         return mWorkspace.isOnOrMovingToCustomContent();
2233     }
2234 
2235     @Override
2236     public boolean onPrepareOptionsMenu(Menu menu) {
2237         super.onPrepareOptionsMenu(menu);
2238         if (!isOnCustomContent()) {
2239             // Close any open folders
2240             closeFolder();
2241             // Stop resizing any widgets
2242             mWorkspace.exitWidgetResizeMode();
2243             if (!mWorkspace.isInOverviewMode()) {
2244                 // Show the overview mode
2245                 showOverviewMode(true);
2246             } else {
2247                 showWorkspace(true);
2248             }
2249         }
2250         return false;
2251     }
2252 
2253     @Override
2254     public boolean onSearchRequested() {
2255         startSearch(null, false, null, true);
2256         // Use a custom animation for launching search
2257         return true;
2258     }
2259 
2260     public boolean isWorkspaceLocked() {
2261         return mWorkspaceLoading || mWaitingForResult;
2262     }
2263 
2264     public boolean isWorkspaceLoading() {
2265         return mWorkspaceLoading;
2266     }
2267 
2268     private void setWorkspaceLoading(boolean value) {
2269         boolean isLocked = isWorkspaceLocked();
2270         mWorkspaceLoading = value;
2271         if (isLocked != isWorkspaceLocked()) {
2272             onWorkspaceLockedChanged();
2273         }
2274     }
2275 
2276     private void setWaitingForResult(boolean value) {
2277         boolean isLocked = isWorkspaceLocked();
2278         mWaitingForResult = value;
2279         if (isLocked != isWorkspaceLocked()) {
2280             onWorkspaceLockedChanged();
2281         }
2282     }
2283 
2284     protected void onWorkspaceLockedChanged() { }
2285 
2286     private void resetAddInfo() {
2287         mPendingAddInfo.container = ItemInfo.NO_ID;
2288         mPendingAddInfo.screenId = -1;
2289         mPendingAddInfo.cellX = mPendingAddInfo.cellY = -1;
2290         mPendingAddInfo.spanX = mPendingAddInfo.spanY = -1;
2291         mPendingAddInfo.minSpanX = mPendingAddInfo.minSpanY = -1;
2292         mPendingAddInfo.dropPos = null;
2293     }
2294 
2295     void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2296             final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo) {
2297         addAppWidgetImpl(appWidgetId, info, boundWidget, appWidgetInfo, 0);
2298     }
2299 
2300     void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2301             final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo, int
2302             delay) {
2303         if (appWidgetInfo.configure != null) {
2304             mPendingAddWidgetInfo = appWidgetInfo;
2305             mPendingAddWidgetId = appWidgetId;
2306 
2307             // Launch over to configure widget, if needed
2308             mAppWidgetManager.startConfigActivity(appWidgetInfo, appWidgetId, this,
2309                     mAppWidgetHost, REQUEST_CREATE_APPWIDGET);
2310 
2311         } else {
2312             // Otherwise just add it
2313             Runnable onComplete = new Runnable() {
2314                 @Override
2315                 public void run() {
2316                     // Exit spring loaded mode if necessary after adding the widget
2317                     exitSpringLoadedDragModeDelayed(true, EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
2318                             null);
2319                 }
2320             };
2321             completeAddAppWidget(appWidgetId, info.container, info.screenId, boundWidget,
2322                     appWidgetInfo);
2323             mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete, delay, false);
2324         }
2325     }
2326 
2327     protected void moveToCustomContentScreen(boolean animate) {
2328         // Close any folders that may be open.
2329         closeFolder();
2330         mWorkspace.moveToCustomContentScreen(animate);
2331     }
2332     /**
2333      * Process a shortcut drop.
2334      *
2335      * @param componentName The name of the component
2336      * @param screenId The ID of the screen where it should be added
2337      * @param cell The cell it should be added to, optional
2338      * @param position The location on the screen where it was dropped, optional
2339      */
2340     void processShortcutFromDrop(ComponentName componentName, long container, long screenId,
2341             int[] cell, int[] loc) {
2342         resetAddInfo();
2343         mPendingAddInfo.container = container;
2344         mPendingAddInfo.screenId = screenId;
2345         mPendingAddInfo.dropPos = loc;
2346 
2347         if (cell != null) {
2348             mPendingAddInfo.cellX = cell[0];
2349             mPendingAddInfo.cellY = cell[1];
2350         }
2351 
2352         Intent createShortcutIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2353         createShortcutIntent.setComponent(componentName);
2354         processShortcut(createShortcutIntent);
2355     }
2356 
2357     /**
2358      * Process a widget drop.
2359      *
2360      * @param info The PendingAppWidgetInfo of the widget being added.
2361      * @param screenId The ID of the screen where it should be added
2362      * @param cell The cell it should be added to, optional
2363      * @param position The location on the screen where it was dropped, optional
2364      */
2365     void addAppWidgetFromDrop(PendingAddWidgetInfo info, long container, long screenId,
2366             int[] cell, int[] span, int[] loc) {
2367         resetAddInfo();
2368         mPendingAddInfo.container = info.container = container;
2369         mPendingAddInfo.screenId = info.screenId = screenId;
2370         mPendingAddInfo.dropPos = loc;
2371         mPendingAddInfo.minSpanX = info.minSpanX;
2372         mPendingAddInfo.minSpanY = info.minSpanY;
2373 
2374         if (cell != null) {
2375             mPendingAddInfo.cellX = cell[0];
2376             mPendingAddInfo.cellY = cell[1];
2377         }
2378         if (span != null) {
2379             mPendingAddInfo.spanX = span[0];
2380             mPendingAddInfo.spanY = span[1];
2381         }
2382 
2383         AppWidgetHostView hostView = info.boundWidget;
2384         int appWidgetId;
2385         if (hostView != null) {
2386             appWidgetId = hostView.getAppWidgetId();
2387             addAppWidgetImpl(appWidgetId, info, hostView, info.info);
2388         } else {
2389             // In this case, we either need to start an activity to get permission to bind
2390             // the widget, or we need to start an activity to configure the widget, or both.
2391             appWidgetId = getAppWidgetHost().allocateAppWidgetId();
2392             Bundle options = info.bindOptions;
2393 
2394             boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
2395                     appWidgetId, info.info, options);
2396             if (success) {
2397                 addAppWidgetImpl(appWidgetId, info, null, info.info);
2398             } else {
2399                 mPendingAddWidgetInfo = info.info;
2400                 Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);
2401                 intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
2402                 intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName);
2403                 mAppWidgetManager.getUser(mPendingAddWidgetInfo)
2404                     .addToIntent(intent, AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE);
2405                 // TODO: we need to make sure that this accounts for the options bundle.
2406                 // intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);
2407                 startActivityForResult(intent, REQUEST_BIND_APPWIDGET);
2408             }
2409         }
2410     }
2411 
2412     void processShortcut(Intent intent) {
2413         Utilities.startActivityForResultSafely(this, intent, REQUEST_CREATE_SHORTCUT);
2414     }
2415 
2416     void processWallpaper(Intent intent) {
2417         startActivityForResult(intent, REQUEST_PICK_WALLPAPER);
2418     }
2419 
2420     FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX,
2421             int cellY) {
2422         final FolderInfo folderInfo = new FolderInfo();
2423         folderInfo.title = getText(R.string.folder_name);
2424 
2425         // Update the model
2426         LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId, cellX, cellY,
2427                 false);
2428         sFolders.put(folderInfo.id, folderInfo);
2429 
2430         // Create the view
2431         FolderIcon newFolder =
2432             FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
2433         mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1,
2434                 isWorkspaceLocked());
2435         // Force measure the new folder icon
2436         CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
2437         parent.getShortcutsAndWidgets().measureChild(newFolder);
2438         return newFolder;
2439     }
2440 
2441     void removeFolder(FolderInfo folder) {
2442         sFolders.remove(folder.id);
2443     }
2444 
2445     protected ComponentName getWallpaperPickerComponent() {
2446         return new ComponentName(getPackageName(), LauncherWallpaperPickerActivity.class.getName());
2447     }
2448 
2449     /**
2450      * Registers various content observers. The current implementation registers
2451      * only a favorites observer to keep track of the favorites applications.
2452      */
2453     private void registerContentObservers() {
2454         ContentResolver resolver = getContentResolver();
2455         resolver.registerContentObserver(LauncherProvider.CONTENT_APPWIDGET_RESET_URI,
2456                 true, mWidgetObserver);
2457     }
2458 
2459     @Override
2460     public boolean dispatchKeyEvent(KeyEvent event) {
2461         if (event.getAction() == KeyEvent.ACTION_DOWN) {
2462             switch (event.getKeyCode()) {
2463                 case KeyEvent.KEYCODE_HOME:
2464                     return true;
2465                 case KeyEvent.KEYCODE_VOLUME_DOWN:
2466                     if (isPropertyEnabled(DUMP_STATE_PROPERTY)) {
2467                         dumpState();
2468                         return true;
2469                     }
2470                     break;
2471             }
2472         } else if (event.getAction() == KeyEvent.ACTION_UP) {
2473             switch (event.getKeyCode()) {
2474                 case KeyEvent.KEYCODE_HOME:
2475                     return true;
2476             }
2477         }
2478 
2479         return super.dispatchKeyEvent(event);
2480     }
2481 
2482     @Override
2483     public void onBackPressed() {
2484         if (isAllAppsVisible()) {
2485             if (mAppsCustomizeContent.getContentType() ==
2486                     AppsCustomizePagedView.ContentType.Applications) {
2487                 showWorkspace(true);
2488             } else {
2489                 showOverviewMode(true);
2490             }
2491         } else if (mWorkspace.isInOverviewMode()) {
2492             mWorkspace.exitOverviewMode(true);
2493         } else if (mWorkspace.getOpenFolder() != null) {
2494             Folder openFolder = mWorkspace.getOpenFolder();
2495             if (openFolder.isEditingName()) {
2496                 openFolder.dismissEditingName();
2497             } else {
2498                 closeFolder();
2499             }
2500         } else {
2501             mWorkspace.exitWidgetResizeMode();
2502 
2503             // Back button is a no-op here, but give at least some feedback for the button press
2504             mWorkspace.showOutlinesTemporarily();
2505         }
2506     }
2507 
2508     /**
2509      * Re-listen when widgets are reset.
2510      */
2511     private void onAppWidgetReset() {
2512         if (mAppWidgetHost != null) {
2513             mAppWidgetHost.startListening();
2514         }
2515     }
2516 
2517     /**
2518      * Launches the intent referred by the clicked shortcut.
2519      *
2520      * @param v The view representing the clicked shortcut.
2521      */
2522     public void onClick(View v) {
2523         // Make sure that rogue clicks don&#x27;t get through while allapps is launching, or after the
2524         // view has detached (it&#x27;s possible for this to happen if the view is removed mid touch).
2525         if (v.getWindowToken() == null) {
2526             return;
2527         }
2528 
2529         if (!mWorkspace.isFinishedSwitchingState()) {
2530             return;
2531         }
2532 
2533         if (v instanceof Workspace) {
2534             if (mWorkspace.isInOverviewMode()) {
2535                 mWorkspace.exitOverviewMode(true);
2536             }
2537             return;
2538         }
2539 
2540         if (v instanceof CellLayout) {
2541             if (mWorkspace.isInOverviewMode()) {
2542                 mWorkspace.exitOverviewMode(mWorkspace.indexOfChild(v), true);
2543             }
2544         }
2545 
2546         Object tag = v.getTag();
2547         if (tag instanceof ShortcutInfo) {
2548             onClickAppShortcut(v);
2549         } else if (tag instanceof FolderInfo) {
2550             if (v instanceof FolderIcon) {
2551                 onClickFolderIcon(v);
2552             }
2553         } else if (v == mAllAppsButton) {
2554             onClickAllAppsButton(v);
2555         } else if (tag instanceof AppInfo) {
2556             startAppShortcutOrInfoActivity(v);
2557         } else if (tag instanceof LauncherAppWidgetInfo) {
2558             if (v instanceof PendingAppWidgetHostView) {
2559                 onClickPendingWidget((PendingAppWidgetHostView) v);
2560             }
2561         }
2562     }
2563 
2564     public void onClickPagedViewIcon(View v) {
2565         startAppShortcutOrInfoActivity(v);
2566     }
2567 
2568     public boolean onTouch(View v, MotionEvent event) {
2569         return false;
2570     }
2571 
2572     /**
2573      * Event handler for the app widget view which has not fully restored.
2574      */
2575     public void onClickPendingWidget(final PendingAppWidgetHostView v) {
2576         final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
2577         if (v.isReadyForClickSetup()) {
2578             int widgetId = info.appWidgetId;
2579             AppWidgetProviderInfo appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(widgetId);
2580             if (appWidgetInfo != null) {
2581                 mPendingAddWidgetInfo = appWidgetInfo;
2582                 mPendingAddInfo.copyFrom(info);
2583                 mPendingAddWidgetId = widgetId;
2584 
2585                 AppWidgetManagerCompat.getInstance(this).startConfigActivity(appWidgetInfo,
2586                         info.appWidgetId, this, mAppWidgetHost, REQUEST_RECONFIGURE_APPWIDGET);
2587             }
2588         } else if (info.installProgress &lt; 0) {
2589             // The install has not been queued
2590             final String packageName = info.providerName.getPackageName();
2591             showBrokenAppInstallDialog(packageName,
2592                 new DialogInterface.OnClickListener() {
2593                     public void onClick(DialogInterface dialog, int id) {
2594                         startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
2595                     }
2596                 });
2597         } else {
2598             // Download has started.
2599             final String packageName = info.providerName.getPackageName();
2600             startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
2601         }
2602     }
2603 
2604     /**
2605      * Event handler for the search button
2606      *
2607      * @param v The view that was clicked.
2608      */
2609     public void onClickSearchButton(View v) {
2610         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2611 
2612         onSearchRequested();
2613     }
2614 
2615     /**
2616      * Event handler for the voice button
2617      *
2618      * @param v The view that was clicked.
2619      */
2620     public void onClickVoiceButton(View v) {
2621         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2622 
2623         startVoice();
2624     }
2625 
2626     public void startVoice() {
2627         try {
2628             final SearchManager searchManager =
2629                     (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2630             ComponentName activityName = searchManager.getGlobalSearchActivity();
2631             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2632             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2633             if (activityName != null) {
2634                 intent.setPackage(activityName.getPackageName());
2635             }
2636             startActivity(null, intent, &quot;onClickVoiceButton&quot;);
2637         } catch (ActivityNotFoundException e) {
2638             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2639             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2640             startActivitySafely(null, intent, &quot;onClickVoiceButton&quot;);
2641         }
2642     }
2643 
2644     /**
2645      * Event handler for the &quot;grid&quot; button that appears on the home screen, which
2646      * enters all apps mode.
2647      *
2648      * @param v The view that was clicked.
2649      */
2650     protected void onClickAllAppsButton(View v) {
2651         if (LOGD) Log.d(TAG, &quot;onClickAllAppsButton&quot;);
2652         if (isAllAppsVisible()) {
2653             showWorkspace(true);
2654         } else {
2655             showAllApps(true, AppsCustomizePagedView.ContentType.Applications, false);
2656         }
2657     }
2658 
2659     private void showBrokenAppInstallDialog(final String packageName,
2660             DialogInterface.OnClickListener onSearchClickListener) {
2661         new AlertDialog.Builder(new ContextThemeWrapper(this, android.R.style.Theme_DeviceDefault))
2662             .setTitle(R.string.abandoned_promises_title)
2663             .setMessage(R.string.abandoned_promise_explanation)
2664             .setPositiveButton(R.string.abandoned_search, onSearchClickListener)
2665             .setNeutralButton(R.string.abandoned_clean_this,
2666                 new DialogInterface.OnClickListener() {
2667                     public void onClick(DialogInterface dialog, int id) {
2668                         final UserHandleCompat user = UserHandleCompat.myUserHandle();
2669                         mWorkspace.removeAbandonedPromise(packageName, user);
2670                     }
2671                 })
2672             .create().show();
2673         return;
2674     }
2675 
2676     /**
2677      * Event handler for an app shortcut click.
2678      *
2679      * @param v The view that was clicked. Must be a tagged with a {@link ShortcutInfo}.
2680      */
2681     protected void onClickAppShortcut(final View v) {
2682         if (LOGD) Log.d(TAG, &quot;onClickAppShortcut&quot;);
2683         Object tag = v.getTag();
2684         if (!(tag instanceof ShortcutInfo)) {
2685             throw new IllegalArgumentException(&quot;Input must be a Shortcut&quot;);
2686         }
2687 
2688         // Open shortcut
2689         final ShortcutInfo shortcut = (ShortcutInfo) tag;
2690         final Intent intent = shortcut.intent;
2691 
2692         // Check for special shortcuts
2693         if (intent.getComponent() != null) {
2694             final String shortcutClass = intent.getComponent().getClassName();
2695 
2696             if (shortcutClass.equals(MemoryDumpActivity.class.getName())) {
2697                 MemoryDumpActivity.startDump(this);
2698                 return;
2699             } else if (shortcutClass.equals(ToggleWeightWatcher.class.getName())) {
2700                 toggleShowWeightWatcher();
2701                 return;
2702             }
2703         }
2704 
2705         // Check for abandoned promise
2706         if ((v instanceof BubbleTextView)
2707                 &amp;&amp; shortcut.isPromise()
2708                 &amp;&amp; !shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE)) {
2709             showBrokenAppInstallDialog(
2710                     shortcut.getTargetComponent().getPackageName(),
2711                     new DialogInterface.OnClickListener() {
2712                         public void onClick(DialogInterface dialog, int id) {
2713                             startAppShortcutOrInfoActivity(v);
2714                         }
2715                     });
2716             return;
2717         }
2718 
2719         // Start activities
2720         startAppShortcutOrInfoActivity(v);
2721     }
2722 
2723     private void startAppShortcutOrInfoActivity(View v) {
2724         Object tag = v.getTag();
2725         final ShortcutInfo shortcut;
2726         final Intent intent;
2727         if (tag instanceof ShortcutInfo) {
2728             shortcut = (ShortcutInfo) tag;
2729             intent = shortcut.intent;
2730             int[] pos = new int[2];
2731             v.getLocationOnScreen(pos);
2732             intent.setSourceBounds(new Rect(pos[0], pos[1],
2733                     pos[0] + v.getWidth(), pos[1] + v.getHeight()));
2734 
2735         } else if (tag instanceof AppInfo) {
2736             shortcut = null;
2737             intent = ((AppInfo) tag).intent;
2738         } else {
2739             throw new IllegalArgumentException(&quot;Input must be a Shortcut or AppInfo&quot;);
2740         }
2741 
2742         boolean success = startActivitySafely(v, intent, tag);
2743         mStats.recordLaunch(intent, shortcut);
2744 
2745         if (success &amp;&amp; v instanceof BubbleTextView) {
2746             mWaitingForResume = (BubbleTextView) v;
2747             mWaitingForResume.setStayPressed(true);
2748         }
2749     }
2750 
2751     /**
2752      * Event handler for a folder icon click.
2753      *
2754      * @param v The view that was clicked. Must be an instance of {@link FolderIcon}.
2755      */
2756     protected void onClickFolderIcon(View v) {
2757         if (LOGD) Log.d(TAG, &quot;onClickFolder&quot;);
2758         if (!(v instanceof FolderIcon)){
2759             throw new IllegalArgumentException(&quot;Input must be a FolderIcon&quot;);
2760         }
2761 
2762         FolderIcon folderIcon = (FolderIcon) v;
2763         final FolderInfo info = folderIcon.getFolderInfo();
2764         Folder openFolder = mWorkspace.getFolderForTag(info);
2765 
2766         // If the folder info reports that the associated folder is open, then verify that
2767         // it is actually opened. There have been a few instances where this gets out of sync.
2768         if (info.opened &amp;&amp; openFolder == null) {
2769             Log.d(TAG, &quot;Folder info marked as open, but associated folder is not open. Screen: &quot;
2770                     + info.screenId + &quot; (&quot; + info.cellX + &quot;, &quot; + info.cellY + &quot;)&quot;);
2771             info.opened = false;
2772         }
2773 
2774         if (!info.opened &amp;&amp; !folderIcon.getFolder().isDestroyed()) {
2775             // Close any open folder
2776             closeFolder();
2777             // Open the requested folder
2778             openFolder(folderIcon);
2779         } else {
2780             // Find the open folder...
2781             int folderScreen;
2782             if (openFolder != null) {
2783                 folderScreen = mWorkspace.getPageForView(openFolder);
2784                 // .. and close it
2785                 closeFolder(openFolder);
2786                 if (folderScreen != mWorkspace.getCurrentPage()) {
2787                     // Close any folder open on the current screen
2788                     closeFolder();
2789                     // Pull the folder onto this screen
2790                     openFolder(folderIcon);
2791                 }
2792             }
2793         }
2794     }
2795 
2796     /**
2797      * Event handler for the (Add) Widgets button that appears after a long press
2798      * on the home screen.
2799      */
2800     protected void onClickAddWidgetButton(View view) {
2801         if (LOGD) Log.d(TAG, &quot;onClickAddWidgetButton&quot;);
2802         showAllApps(true, AppsCustomizePagedView.ContentType.Widgets, true);
2803     }
2804 
2805     /**
2806      * Event handler for the wallpaper picker button that appears after a long press
2807      * on the home screen.
2808      */
2809     protected void onClickWallpaperPicker(View v) {
2810         if (LOGD) Log.d(TAG, &quot;onClickWallpaperPicker&quot;);
2811         final Intent pickWallpaper = new Intent(Intent.ACTION_SET_WALLPAPER);
2812         pickWallpaper.setComponent(getWallpaperPickerComponent());
2813         startActivityForResult(pickWallpaper, REQUEST_PICK_WALLPAPER);
2814     }
2815 
2816     /**
2817      * Event handler for a click on the settings button that appears after a long press
2818      * on the home screen.
2819      */
2820     protected void onClickSettingsButton(View v) {
2821         if (LOGD) Log.d(TAG, &quot;onClickSettingsButton&quot;);
2822     }
2823 
2824     public void onTouchDownAllAppsButton(View v) {
2825         // Provide the same haptic feedback that the system offers for virtual keys.
2826         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2827     }
2828 
2829     public void performHapticFeedbackOnTouchDown(View v) {
2830         // Provide the same haptic feedback that the system offers for virtual keys.
2831         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2832     }
2833 
2834     public View.OnTouchListener getHapticFeedbackTouchListener() {
2835         if (mHapticFeedbackTouchListener == null) {
2836             mHapticFeedbackTouchListener = new View.OnTouchListener() {
2837                 @Override
2838                 public boolean onTouch(View v, MotionEvent event) {
2839                     if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
2840                         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2841                     }
2842                     return false;
2843                 }
2844             };
2845         }
2846         return mHapticFeedbackTouchListener;
2847     }
2848 
2849     public void onDragStarted(View view) {}
2850 
2851     /**
2852      * Called when the user stops interacting with the launcher.
2853      * This implies that the user is now on the homescreen and is not doing housekeeping.
2854      */
2855     protected void onInteractionEnd() {}
2856 
2857     /**
2858      * Called when the user starts interacting with the launcher.
2859      * The possible interactions are:
2860      *  - open all apps
2861      *  - reorder an app shortcut, or a widget
2862      *  - open the overview mode.
2863      * This is a good time to stop doing things that only make sense
2864      * when the user is on the homescreen and not doing housekeeping.
2865      */
2866     protected void onInteractionBegin() {}
2867 
2868     void startApplicationDetailsActivity(ComponentName componentName, UserHandleCompat user) {
2869         String packageName = componentName.getPackageName();
2870         try {
2871             LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
2872             UserManagerCompat userManager = UserManagerCompat.getInstance(this);
2873             launcherApps.showAppDetailsForProfile(componentName, user);
2874         } catch (SecurityException e) {
2875             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2876             Log.e(TAG, &quot;Launcher does not have permission to launch settings&quot;);
2877         } catch (ActivityNotFoundException e) {
2878             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2879             Log.e(TAG, &quot;Unable to launch settings&quot;);
2880         }
2881     }
2882 
2883     // returns true if the activity was started
2884     boolean startApplicationUninstallActivity(ComponentName componentName, int flags,
2885             UserHandleCompat user) {
2886         if ((flags &amp; AppInfo.DOWNLOADED_FLAG) == 0) {
2887             // System applications cannot be installed. For now, show a toast explaining that.
2888             // We may give them the option of disabling apps this way.
2889             int messageId = R.string.uninstall_system_app_text;
2890             Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show();
2891             return false;
2892         } else {
2893             String packageName = componentName.getPackageName();
2894             String className = componentName.getClassName();
2895             Intent intent = new Intent(
2896                     Intent.ACTION_DELETE, Uri.fromParts(&quot;package&quot;, packageName, className));
2897             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
2898                     Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
2899             if (user != null) {
2900                 user.addToIntent(intent, Intent.EXTRA_USER);
2901             }
2902             startActivity(intent);
2903             return true;
2904         }
2905     }
2906 
2907     boolean startActivity(View v, Intent intent, Object tag) {
2908         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2909         try {
2910             // Only launch using the new animation if the shortcut has not opted out (this is a
2911             // private contract between launcher and may be ignored in the future).
2912             boolean useLaunchAnimation = (v != null) &amp;&amp;
2913                     !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);
2914             LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
2915             UserManagerCompat userManager = UserManagerCompat.getInstance(this);
2916 
2917             UserHandleCompat user = null;
2918             if (intent.hasExtra(AppInfo.EXTRA_PROFILE)) {
2919                 long serialNumber = intent.getLongExtra(AppInfo.EXTRA_PROFILE, -1);
2920                 user = userManager.getUserForSerialNumber(serialNumber);
2921             }
2922 
2923             Bundle optsBundle = null;
2924             if (useLaunchAnimation) {
2925                 ActivityOptions opts = Utilities.isLmpOrAbove() ?
<abbr title="2926                         ActivityOptions.makeCustomAnimation(this, R.anim.task_open_enter, R.anim.no_anim) :">2926                         ActivityOptions.makeCustomAnimation(this, R.anim.task_open_enter, R.anim.no_anim)🔵</abbr>
<abbr title="2927                         ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());">2927                         ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasured🔵</abbr>
2928                 optsBundle = opts.toBundle();
2929             }
2930 
2931             if (user == null || user.equals(UserHandleCompat.myUserHandle())) {
2932                 // Could be launching some bookkeeping activity
2933                 startActivity(intent, optsBundle);
2934             } else {
2935                 // TODO Component can be null when shortcuts are supported for secondary user
2936                 launcherApps.startActivityForProfile(intent.getComponent(), user,
2937                         intent.getSourceBounds(), optsBundle);
2938             }
2939             return true;
2940         } catch (SecurityException e) {
2941             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2942             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
2943                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
2944                     &quot;or use the exported attribute for this activity. &quot;
2945                     + &quot;tag=&quot;+ tag + &quot; intent=&quot; + intent, e);
2946         }
2947         return false;
2948     }
2949 
2950     boolean startActivitySafely(View v, Intent intent, Object tag) {
2951         boolean success = false;
2952         if (mIsSafeModeEnabled &amp;&amp; !Utilities.isSystemApp(this, intent)) {
2953             Toast.makeText(this, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show();
2954             return false;
2955         }
2956         try {
2957             success = startActivity(v, intent, tag);
2958         } catch (ActivityNotFoundException e) {
2959             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2960             Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);
2961         }
2962         return success;
2963     }
2964 
2965     /**
2966      * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView
2967      * in the DragLayer in the exact absolute location of the original FolderIcon.
2968      */
2969     private void copyFolderIconToImage(FolderIcon fi) {
2970         final int width = fi.getMeasuredWidth();
2971         final int height = fi.getMeasuredHeight();
2972 
2973         // Lazy load ImageView, Bitmap and Canvas
2974         if (mFolderIconImageView == null) {
2975             mFolderIconImageView = new ImageView(this);
2976         }
2977         if (mFolderIconBitmap == null || mFolderIconBitmap.getWidth() != width ||
2978                 mFolderIconBitmap.getHeight() != height) {
2979             mFolderIconBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
2980             mFolderIconCanvas = new Canvas(mFolderIconBitmap);
2981         }
2982 
2983         DragLayer.LayoutParams lp;
2984         if (mFolderIconImageView.getLayoutParams() instanceof DragLayer.LayoutParams) {
2985             lp = (DragLayer.LayoutParams) mFolderIconImageView.getLayoutParams();
2986         } else {
2987             lp = new DragLayer.LayoutParams(width, height);
2988         }
2989 
2990         // The layout from which the folder is being opened may be scaled, adjust the starting
2991         // view size by this scale factor.
2992         float scale = mDragLayer.getDescendantRectRelativeToSelf(fi, mRectForFolderAnimation);
2993         lp.customPosition = true;
2994         lp.x = mRectForFolderAnimation.left;
2995         lp.y = mRectForFolderAnimation.top;
2996         lp.width = (int) (scale * width);
2997         lp.height = (int) (scale * height);
2998 
2999         mFolderIconCanvas.drawColor(0, PorterDuff.Mode.CLEAR);
3000         fi.draw(mFolderIconCanvas);
3001         mFolderIconImageView.setImageBitmap(mFolderIconBitmap);
3002         if (fi.getFolder() != null) {
3003             mFolderIconImageView.setPivotX(fi.getFolder().getPivotXForIconAnimation());
3004             mFolderIconImageView.setPivotY(fi.getFolder().getPivotYForIconAnimation());
3005         }
3006         // Just in case this image view is still in the drag layer from a previous animation,
3007         // we remove it and re-add it.
3008         if (mDragLayer.indexOfChild(mFolderIconImageView) != -1) {
3009             mDragLayer.removeView(mFolderIconImageView);
3010         }
3011         mDragLayer.addView(mFolderIconImageView, lp);
3012         if (fi.getFolder() != null) {
3013             fi.getFolder().bringToFront();
3014         }
3015     }
3016 
3017     private void growAndFadeOutFolderIcon(FolderIcon fi) {
3018         if (fi == null) return;
3019         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0);
3020         PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.5f);
3021         PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.5f);
3022 
3023         FolderInfo info = (FolderInfo) fi.getTag();
3024         if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
3025             CellLayout cl = (CellLayout) fi.getParent().getParent();
3026             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) fi.getLayoutParams();
3027             cl.setFolderLeaveBehindCell(lp.cellX, lp.cellY);
3028         }
3029 
3030         // Push an ImageView copy of the FolderIcon into the DragLayer and hide the original
3031         copyFolderIconToImage(fi);
3032         fi.setVisibility(View.INVISIBLE);
3033 
3034         ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
3035                 scaleX, scaleY);
3036         if (Utilities.isLmpOrAbove()) {
3037             oa.setInterpolator(new LogDecelerateInterpolator(100, 0));
3038         }
3039         oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
3040         oa.start();
3041     }
3042 
3043     private void shrinkAndFadeInFolderIcon(final FolderIcon fi) {
3044         if (fi == null) return;
3045         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f);
3046         PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f);
3047         PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.0f);
3048 
3049         final CellLayout cl = (CellLayout) fi.getParent().getParent();
3050 
3051         // We remove and re-draw the FolderIcon in-case it has changed
3052         mDragLayer.removeView(mFolderIconImageView);
3053         copyFolderIconToImage(fi);
3054         ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
3055                 scaleX, scaleY);
3056         oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
3057         oa.addListener(new AnimatorListenerAdapter() {
3058             @Override
3059             public void onAnimationEnd(Animator animation) {
3060                 if (cl != null) {
3061                     cl.clearFolderLeaveBehind();
3062                     // Remove the ImageView copy of the FolderIcon and make the original visible.
3063                     mDragLayer.removeView(mFolderIconImageView);
3064                     fi.setVisibility(View.VISIBLE);
3065                 }
3066             }
3067         });
3068         oa.start();
3069     }
3070 
3071     /**
3072      * Opens the user folder described by the specified tag. The opening of the folder
3073      * is animated relative to the specified View. If the View is null, no animation
3074      * is played.
3075      *
3076      * @param folderInfo The FolderInfo describing the folder to open.
3077      */
3078     public void openFolder(FolderIcon folderIcon) {
3079         Folder folder = folderIcon.getFolder();
3080         FolderInfo info = folder.mInfo;
3081 
3082         info.opened = true;
3083 
3084         // Just verify that the folder hasn&#x27;t already been added to the DragLayer.
3085         // There was a one-off crash where the folder had a parent already.
3086         if (folder.getParent() == null) {
3087             mDragLayer.addView(folder);
3088             mDragController.addDropTarget((DropTarget) folder);
3089         } else {
3090             Log.w(TAG, &quot;Opening folder (&quot; + folder + &quot;) which already has a parent (&quot; +
3091                     folder.getParent() + &quot;).&quot;);
3092         }
3093         folder.animateOpen();
3094         growAndFadeOutFolderIcon(folderIcon);
3095 
3096         // Notify the accessibility manager that this folder &quot;window&quot; has appeared and occluded
3097         // the workspace items
3098         folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3099         getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
3100     }
3101 
3102     public void closeFolder() {
3103         Folder folder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
3104         if (folder != null) {
3105             if (folder.isEditingName()) {
3106                 folder.dismissEditingName();
3107             }
3108             closeFolder(folder);
3109 
3110 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3111 </span>
3112 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="3113 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">3113 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
3114 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3115 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3116 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3117             // Dismiss the folder cling</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3118             mLauncherClings.dismissFolderCling(null);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3119 </span>
3120 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
3121         }
3122     }
3123 
3124     void closeFolder(Folder folder) {
3125         folder.getInfo().opened = false;
3126 
3127         ViewGroup parent = (ViewGroup) folder.getParent().getParent();
3128         if (parent != null) {
3129             FolderIcon fi = (FolderIcon) mWorkspace.getViewForTag(folder.mInfo);
3130             shrinkAndFadeInFolderIcon(fi);
3131         }
3132         folder.animateClosed();
3133 
3134         // Notify the accessibility manager that this folder &quot;window&quot; has disappeard and no
3135         // longer occludeds the workspace items
3136         getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3137     }
3138 
3139     public boolean onLongClick(View v) {
3140         if (!isDraggingEnabled()) return false;
3141         if (isWorkspaceLocked()) return false;
3142         if (mState != State.WORKSPACE) return false;
3143 
3144         if (v instanceof Workspace) {
3145             if (!mWorkspace.isInOverviewMode()) {
3146                 if (mWorkspace.enterOverviewMode()) {
3147                     mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
3148                             HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
3149                     return true;
3150                 } else {
3151                     return false;
3152                 }
3153             } else {
3154                 return false;
3155             }
3156         }
3157 
3158         CellLayout.CellInfo longClickCellInfo = null;
3159         View itemUnderLongClick = null;
3160         if (v.getTag() instanceof ItemInfo) {
3161             ItemInfo info = (ItemInfo) v.getTag();
3162             longClickCellInfo = new CellLayout.CellInfo(v, info);;
3163             itemUnderLongClick = longClickCellInfo.cell;
3164             resetAddInfo();
3165         }
3166 
3167         // The hotseat touch handling does not go through Workspace, and we always allow long press
3168         // on hotseat items.
3169         final boolean inHotseat = isHotseatLayout(v);
3170         boolean allowLongPress = inHotseat || mWorkspace.allowLongPress();
3171         if (allowLongPress &amp;&amp; !mDragController.isDragging()) {
3172             if (itemUnderLongClick == null) {
3173                 // User long pressed on empty space
3174                 mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
3175                         HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
3176                 if (mWorkspace.isInOverviewMode()) {
3177                     mWorkspace.startReordering(v);
3178                 } else {
3179                     mWorkspace.enterOverviewMode();
3180                 }
3181             } else {
3182                 final boolean isAllAppsButton = inHotseat &amp;&amp; isAllAppsButtonRank(
3183                         mHotseat.getOrderInHotseat(
3184                                 longClickCellInfo.cellX,
3185                                 longClickCellInfo.cellY));
3186                 if (!(itemUnderLongClick instanceof Folder || isAllAppsButton)) {
3187                     // User long pressed on an item
3188                     mWorkspace.startDrag(longClickCellInfo);
3189                 }
3190             }
3191         }
3192         return true;
3193     }
3194 
3195     boolean isHotseatLayout(View layout) {
3196         return mHotseat != null &amp;&amp; layout != null &amp;&amp;
3197                 (layout instanceof CellLayout) &amp;&amp; (layout == mHotseat.getLayout());
3198     }
3199 
3200     /**
3201      * Returns the CellLayout of the specified container at the specified screen.
3202      */
3203     CellLayout getCellLayout(long container, long screenId) {
3204         if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
3205             if (mHotseat != null) {
3206                 return mHotseat.getLayout();
3207             } else {
3208                 return null;
3209             }
3210         } else {
3211             return (CellLayout) mWorkspace.getScreenWithId(screenId);
3212         }
3213     }
3214 
3215     public boolean isAllAppsVisible() {
3216         return (mState == State.APPS_CUSTOMIZE) || (mOnResumeState == State.APPS_CUSTOMIZE);
3217     }
3218 
3219     private void setWorkspaceBackground(boolean workspace) {
3220         mLauncherView.setBackground(workspace ?
3221                 mWorkspaceBackgroundDrawable : null);
3222     }
3223 
3224     protected void changeWallpaperVisiblity(boolean visible) {
3225         int wpflags = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
3226         int curflags = getWindow().getAttributes().flags
3227                 &amp; WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
3228         if (wpflags != curflags) {
3229             getWindow().setFlags(wpflags, WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
3230         }
3231         setWorkspaceBackground(visible);
3232     }
3233 
3234     private void dispatchOnLauncherTransitionPrepare(View v, boolean animated, boolean toWorkspace) {
3235         if (v instanceof LauncherTransitionable) {
3236             ((LauncherTransitionable) v).onLauncherTransitionPrepare(this, animated, toWorkspace);
3237         }
3238     }
3239 
3240     private void dispatchOnLauncherTransitionStart(View v, boolean animated, boolean toWorkspace) {
3241         if (v instanceof LauncherTransitionable) {
3242             ((LauncherTransitionable) v).onLauncherTransitionStart(this, animated, toWorkspace);
3243         }
3244 
3245         // Update the workspace transition step as well
3246         dispatchOnLauncherTransitionStep(v, 0f);
3247     }
3248 
3249     private void dispatchOnLauncherTransitionStep(View v, float t) {
3250         if (v instanceof LauncherTransitionable) {
3251             ((LauncherTransitionable) v).onLauncherTransitionStep(this, t);
3252         }
3253     }
3254 
3255     private void dispatchOnLauncherTransitionEnd(View v, boolean animated, boolean toWorkspace) {
3256         if (v instanceof LauncherTransitionable) {
3257             ((LauncherTransitionable) v).onLauncherTransitionEnd(this, animated, toWorkspace);
3258         }
3259 
3260         // Update the workspace transition step as well
3261         dispatchOnLauncherTransitionStep(v, 1f);
3262     }
3263 
3264     /**
3265      * Things to test when changing the following seven functions.
3266      *   - Home from workspace
3267      *          - from center screen
3268      *          - from other screens
3269      *   - Home from all apps
3270      *          - from center screen
3271      *          - from other screens
3272      *   - Back from all apps
3273      *          - from center screen
3274      *          - from other screens
3275      *   - Launch app from workspace and quit
3276      *          - with back
3277      *          - with home
3278      *   - Launch app from all apps and quit
3279      *          - with back
3280      *          - with home
3281      *   - Go to a screen that&#x27;s not the default, then all
3282      *     apps, and launch and app, and go back
3283      *          - with back
3284      *          -with home
3285      *   - On workspace, long press power and go back
3286      *          - with back
3287      *          - with home
3288      *   - On all apps, long press power and go back
3289      *          - with back
3290      *          - with home
3291      *   - On workspace, power off
3292      *   - On all apps, power off
3293      *   - Launch an app and turn off the screen while in that app
3294      *          - Go back with home key
3295      *          - Go back with back key  TODO: make this not go to workspace
3296      *          - From all apps
3297      *          - From workspace
3298      *   - Enter and exit car mode (becuase it causes an extra configuration changed)
3299      *          - From all apps
3300      *          - From the center workspace
3301      *          - From another workspace
3302      */
3303 
3304     /**
3305      * Zoom the camera out from the workspace to reveal &#x27;toView&#x27;.
3306      * Assumes that the view to show is anchored at either the very top or very bottom
3307      * of the screen.
3308      */
3309     private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded) {
3310         AppsCustomizePagedView.ContentType contentType = mAppsCustomizeContent.getContentType();
3311         showAppsCustomizeHelper(animated, springLoaded, contentType);
3312     }
3313 
3314     private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded,
3315                                          final AppsCustomizePagedView.ContentType contentType) {
3316         if (mStateAnimation != null) {
3317             mStateAnimation.setDuration(0);
3318             mStateAnimation.cancel();
3319             mStateAnimation = null;
3320         }
3321 
3322         boolean material = Utilities.isLmpOrAbove();
3323 
3324         final Resources res = getResources();
3325 
3326         final int duration = res.getInteger(R.integer.config_appsCustomizeZoomInTime);
3327         final int fadeDuration = res.getInteger(R.integer.config_appsCustomizeFadeInTime);
3328         final int revealDuration = res.getInteger(R.integer.config_appsCustomizeRevealTime);
3329         final int itemsAlphaStagger =
3330                 res.getInteger(R.integer.config_appsCustomizeItemsAlphaStagger);
3331 
3332         final float scale = (float) res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3333         final View fromView = mWorkspace;
3334         final AppsCustomizeTabHost toView = mAppsCustomizeTabHost;
3335 
3336         final ArrayList&lt;View&gt; layerViews = new ArrayList&lt;View&gt;();
3337 
3338         Workspace.State workspaceState = contentType == AppsCustomizePagedView.ContentType.Widgets ?
3339                 Workspace.State.OVERVIEW_HIDDEN : Workspace.State.NORMAL_HIDDEN;
3340         Animator workspaceAnim =
3341 
3342 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3343                 mWorkspace.getChangeStateAnimation(workspaceState, animated, layerViews);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3344 </span>
3345 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="3346 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">3346 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
3347 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3348 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3349                 mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, animated);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3350 </span>
3351 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
3352         if (!LauncherAppState.isDisableAllApps()
3353                 || contentType == AppsCustomizePagedView.ContentType.Widgets) {
3354             // Set the content type for the all apps/widgets space
3355             mAppsCustomizeTabHost.setContentTypeImmediate(contentType);
3356         }
3357 
3358         // If for some reason our views aren&#x27;t initialized, don&#x27;t animate
3359         boolean initialized = getAllAppsButton() != null;
3360 
3361         if (animated &amp;&amp; initialized) {
3362             mStateAnimation = LauncherAnimUtils.createAnimatorSet();
3363             final AppsCustomizePagedView content = (AppsCustomizePagedView)
3364                     toView.findViewById(R.id.apps_customize_pane_content);
3365 
3366             final View page = content.getPageAt(content.getCurrentPage());
3367             final View revealView = toView.findViewById(R.id.fake_page);
3368 
3369             final float initialPanelAlpha = 1f;
3370 
3371             final boolean isWidgetTray = contentType == AppsCustomizePagedView.ContentType.Widgets;
3372             if (isWidgetTray) {
3373                 revealView.setBackground(res.getDrawable(R.drawable.quantum_panel_dark));
3374             } else {
3375                 revealView.setBackground(res.getDrawable(R.drawable.quantum_panel));
3376             }
3377 
3378             // Hide the real page background, and swap in the fake one
3379             content.setPageBackgroundsVisible(false);
3380             revealView.setVisibility(View.VISIBLE);
3381             // We need to hide this view as the animation start will be posted.
3382             revealView.setAlpha(0);
3383 
3384             int width = revealView.getMeasuredWidth();
3385             int height = revealView.getMeasuredHeight();
3386             float revealRadius = (float) Math.sqrt((width * width) / 4 + (height * height) / 4);
3387 
3388             revealView.setTranslationY(0);
3389             revealView.setTranslationX(0);
3390 
3391             // Get the y delta between the center of the page and the center of the all apps button
3392             int[] allAppsToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView,
3393                     getAllAppsButton(), null);
3394 
3395             float alpha = 0;
3396             float xDrift = 0;
3397             float yDrift = 0;
3398             if (material) {
3399                 alpha = isWidgetTray ? 0.3f : 1f;
3400                 yDrift = isWidgetTray ? height / 2 : allAppsToPanelDelta[1];
3401                 xDrift = isWidgetTray ? 0 : allAppsToPanelDelta[0];
3402             } else {
3403                 yDrift = 2 * height / 3;
3404                 xDrift = 0;
3405             }
3406             final float initAlpha = alpha;
3407 
3408             revealView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3409             layerViews.add(revealView);
3410             PropertyValuesHolder panelAlpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, initAlpha, 1f);
3411             PropertyValuesHolder panelDriftY =
3412                     PropertyValuesHolder.ofFloat(&quot;translationY&quot;, yDrift, 0);
3413             PropertyValuesHolder panelDriftX =
3414                     PropertyValuesHolder.ofFloat(&quot;translationX&quot;, xDrift, 0);
3415 
3416             ObjectAnimator panelAlphaAndDrift = ObjectAnimator.ofPropertyValuesHolder(revealView,
3417                     panelAlpha, panelDriftY, panelDriftX);
3418 
3419             panelAlphaAndDrift.setDuration(revealDuration);
3420             panelAlphaAndDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));
3421 
3422             mStateAnimation.play(panelAlphaAndDrift);
3423 
3424             if (page != null) {
3425                 page.setVisibility(View.VISIBLE);
3426                 page.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3427                 layerViews.add(page);
3428 
3429                 ObjectAnimator pageDrift = ObjectAnimator.ofFloat(page, &quot;translationY&quot;, yDrift, 0);
3430                 page.setTranslationY(yDrift);
3431                 pageDrift.setDuration(revealDuration);
3432                 pageDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));
3433                 pageDrift.setStartDelay(itemsAlphaStagger);
3434                 mStateAnimation.play(pageDrift);
3435 
3436                 page.setAlpha(0f);
3437                 ObjectAnimator itemsAlpha = ObjectAnimator.ofFloat(page, &quot;alpha&quot;, 0f, 1f);
3438                 itemsAlpha.setDuration(revealDuration);
3439                 itemsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));
3440                 itemsAlpha.setStartDelay(itemsAlphaStagger);
3441                 mStateAnimation.play(itemsAlpha);
3442             }
3443 
3444             View pageIndicators = toView.findViewById(R.id.apps_customize_page_indicator);
3445             pageIndicators.setAlpha(0.01f);
3446             ObjectAnimator indicatorsAlpha =
3447                     ObjectAnimator.ofFloat(pageIndicators, &quot;alpha&quot;, 1f);
3448             indicatorsAlpha.setDuration(revealDuration);
3449             mStateAnimation.play(indicatorsAlpha);
3450 
3451             if (material) {
3452                 final View allApps = getAllAppsButton();
3453                 int allAppsButtonSize = LauncherAppState.getInstance().
3454                         getDynamicGrid().getDeviceProfile().allAppsButtonVisualSize;
3455                 float startRadius = isWidgetTray ? 0 : allAppsButtonSize / 2;
3456                 Animator reveal = ViewAnimationUtils.createCircularReveal(revealView, width / 2,
3457                                 height / 2, startRadius, revealRadius);
3458                 reveal.setDuration(revealDuration);
3459                 reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
3460 
3461                 reveal.addListener(new AnimatorListenerAdapter() {
3462                     public void onAnimationStart(Animator animation) {
3463                         if (!isWidgetTray) {
3464                             allApps.setVisibility(View.INVISIBLE);
3465                         }
3466                     }
3467                     public void onAnimationEnd(Animator animation) {
3468                         if (!isWidgetTray) {
3469                             allApps.setVisibility(View.VISIBLE);
3470                         }
3471                     }
3472                 });
3473                 mStateAnimation.play(reveal);
3474             }
3475 
3476             mStateAnimation.addListener(new AnimatorListenerAdapter() {
3477                 @Override
3478                 public void onAnimationEnd(Animator animation) {
3479                     dispatchOnLauncherTransitionEnd(fromView, animated, false);
3480                     dispatchOnLauncherTransitionEnd(toView, animated, false);
3481 
3482                     revealView.setVisibility(View.INVISIBLE);
3483                     revealView.setLayerType(View.LAYER_TYPE_NONE, null);
3484                     if (page != null) {
3485                         page.setLayerType(View.LAYER_TYPE_NONE, null);
3486                     }
3487                     content.setPageBackgroundsVisible(true);
3488 
3489                     // Hide the search bar
3490                     if (mSearchDropTargetBar != null) {
3491                         mSearchDropTargetBar.hideSearchBar(false);
3492                     }
3493                 }
3494 
3495             });
3496 
3497             if (workspaceAnim != null) {
3498                 mStateAnimation.play(workspaceAnim);
3499             }
3500 
3501             dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3502             dispatchOnLauncherTransitionPrepare(toView, animated, false);
3503             final AnimatorSet stateAnimation = mStateAnimation;
3504             final Runnable startAnimRunnable = new Runnable() {
3505                 public void run() {
3506                     // Check that mStateAnimation hasn&#x27;t changed while
3507                     // we waited for a layout/draw pass
3508                     if (mStateAnimation != stateAnimation)
3509                         return;
3510                     dispatchOnLauncherTransitionStart(fromView, animated, false);
3511                     dispatchOnLauncherTransitionStart(toView, animated, false);
3512 
3513                     revealView.setAlpha(initAlpha);
3514                     if (Utilities.isLmpOrAbove()) {
3515                         for (int i = 0; i &lt; layerViews.size(); i++) {
3516                             View v = layerViews.get(i);
3517                             if (v != null) {
3518                                 boolean attached = true;
3519                                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
3520                                     attached = v.isAttachedToWindow();
3521                                 }
3522                                 if (attached) v.buildLayer();
3523                             }
3524                         }
3525                     }
3526                     mStateAnimation.start();
3527                 }
3528             };
3529             toView.bringToFront();
3530             toView.setVisibility(View.VISIBLE);
3531             toView.post(startAnimRunnable);
3532         } else {
3533             toView.setTranslationX(0.0f);
3534             toView.setTranslationY(0.0f);
3535             toView.setScaleX(1.0f);
3536             toView.setScaleY(1.0f);
3537             toView.setVisibility(View.VISIBLE);
3538             toView.bringToFront();
3539 
3540             if (!springLoaded &amp;&amp; !LauncherAppState.getInstance().isScreenLarge()) {
3541                 // Hide the search bar
3542                 if (mSearchDropTargetBar != null) {
3543                     mSearchDropTargetBar.hideSearchBar(false);
3544                 }
3545             }
3546             dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3547             dispatchOnLauncherTransitionStart(fromView, animated, false);
3548             dispatchOnLauncherTransitionEnd(fromView, animated, false);
3549             dispatchOnLauncherTransitionPrepare(toView, animated, false);
3550             dispatchOnLauncherTransitionStart(toView, animated, false);
3551             dispatchOnLauncherTransitionEnd(toView, animated, false);
3552         }
3553     }
3554 
3555     /**
3556      * Zoom the camera back into the workspace, hiding &#x27;fromView&#x27;.
3557      * This is the opposite of showAppsCustomizeHelper.
3558      * @param animated If true, the transition will be animated.
3559      */
3560     private void hideAppsCustomizeHelper(Workspace.State toState, final boolean animated,
3561             final boolean springLoaded, final Runnable onCompleteRunnable) {
3562 
3563         if (mStateAnimation != null) {
3564             mStateAnimation.setDuration(0);
3565             mStateAnimation.cancel();
3566             mStateAnimation = null;
3567         }
3568 
3569         boolean material = Utilities.isLmpOrAbove();
3570         Resources res = getResources();
3571 
3572         final int duration = res.getInteger(R.integer.config_appsCustomizeZoomOutTime);
3573         final int fadeOutDuration = res.getInteger(R.integer.config_appsCustomizeFadeOutTime);
3574         final int revealDuration = res.getInteger(R.integer.config_appsCustomizeConcealTime);
3575         final int itemsAlphaStagger =
3576                 res.getInteger(R.integer.config_appsCustomizeItemsAlphaStagger);
3577 
3578         final float scaleFactor = (float)
3579                 res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3580         final View fromView = mAppsCustomizeTabHost;
3581         final View toView = mWorkspace;
3582         Animator workspaceAnim = null;
3583         final ArrayList&lt;View&gt; layerViews = new ArrayList&lt;View&gt;();
3584 
3585         if (toState == Workspace.State.NORMAL) {
3586             workspaceAnim = mWorkspace.getChangeStateAnimation(
3587                     toState, animated, layerViews);
3588         } else if (toState == Workspace.State.SPRING_LOADED ||
3589                 toState == Workspace.State.OVERVIEW) {
3590             workspaceAnim = mWorkspace.getChangeStateAnimation(
3591                     toState, animated, layerViews);
3592         }
3593 
3594         // If for some reason our views aren&#x27;t initialized, don&#x27;t animate
3595         boolean initialized = getAllAppsButton() != null;
3596 
3597         if (animated &amp;&amp; initialized) {
3598             mStateAnimation = LauncherAnimUtils.createAnimatorSet();
3599             if (workspaceAnim != null) {
3600                 mStateAnimation.play(workspaceAnim);
3601             }
3602 
3603             final AppsCustomizePagedView content = (AppsCustomizePagedView)
3604                     fromView.findViewById(R.id.apps_customize_pane_content);
3605 
3606             final View page = content.getPageAt(content.getNextPage());
3607 
3608             // We need to hide side pages of the Apps / Widget tray to avoid some ugly edge cases
3609             int count = content.getChildCount();
3610             for (int i = 0; i &lt; count; i++) {
3611                 View child = content.getChildAt(i);
3612                 if (child != page) {
3613                     child.setVisibility(View.INVISIBLE);
3614                 }
3615             }
3616             final View revealView = fromView.findViewById(R.id.fake_page);
3617 
3618             // hideAppsCustomizeHelper is called in some cases when it is already hidden
3619             // don&#x27;t perform all these no-op animations. In particularly, this was causing
3620             // the all-apps button to pop in and out.
3621             if (fromView.getVisibility() == View.VISIBLE) {
3622                 AppsCustomizePagedView.ContentType contentType = content.getContentType();
3623                 final boolean isWidgetTray =
3624                         contentType == AppsCustomizePagedView.ContentType.Widgets;
3625 
3626                 if (isWidgetTray) {
3627                     revealView.setBackground(res.getDrawable(R.drawable.quantum_panel_dark));
3628                 } else {
3629                     revealView.setBackground(res.getDrawable(R.drawable.quantum_panel));
3630                 }
3631 
3632                 int width = revealView.getMeasuredWidth();
3633                 int height = revealView.getMeasuredHeight();
3634                 float revealRadius = (float) Math.sqrt((width * width) / 4 + (height * height) / 4);
3635 
3636                 // Hide the real page background, and swap in the fake one
3637                 revealView.setVisibility(View.VISIBLE);
3638                 content.setPageBackgroundsVisible(false);
3639 
3640                 final View allAppsButton = getAllAppsButton();
3641                 revealView.setTranslationY(0);
3642                 int[] allAppsToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView,
3643                         allAppsButton, null);
3644 
3645                 float xDrift = 0;
3646                 float yDrift = 0;
3647                 if (material) {
3648                     yDrift = isWidgetTray ? height / 2 : allAppsToPanelDelta[1];
3649                     xDrift = isWidgetTray ? 0 : allAppsToPanelDelta[0];
3650                 } else {
3651                     yDrift = 5 * height / 4;
3652                     xDrift = 0;
3653                 }
3654 
3655                 revealView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3656                 TimeInterpolator decelerateInterpolator = material ?
3657                         new LogDecelerateInterpolator(100, 0) :
3658                         new LogDecelerateInterpolator(30, 0);
3659 
3660                 // The vertical motion of the apps panel should be delayed by one frame
3661                 // from the conceal animation in order to give the right feel. We correpsondingly
3662                 // shorten the duration so that the slide and conceal end at the same time.
3663                 ObjectAnimator panelDriftY = LauncherAnimUtils.ofFloat(revealView, &quot;translationY&quot;,
3664                         0, yDrift);
3665                 panelDriftY.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3666                 panelDriftY.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3667                 panelDriftY.setInterpolator(decelerateInterpolator);
3668                 mStateAnimation.play(panelDriftY);
3669 
3670                 ObjectAnimator panelDriftX = LauncherAnimUtils.ofFloat(revealView, &quot;translationX&quot;,
3671                         0, xDrift);
3672                 panelDriftX.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3673                 panelDriftX.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3674                 panelDriftX.setInterpolator(decelerateInterpolator);
3675                 mStateAnimation.play(panelDriftX);
3676 
3677                 if (isWidgetTray || !material) {
3678                     float finalAlpha = material ? 0.4f : 0f;
3679                     revealView.setAlpha(1f);
3680                     ObjectAnimator panelAlpha = LauncherAnimUtils.ofFloat(revealView, &quot;alpha&quot;,
3681                             1f, finalAlpha);
3682                     panelAlpha.setDuration(revealDuration);
3683                     panelAlpha.setInterpolator(material ? decelerateInterpolator :
3684                         new AccelerateInterpolator(1.5f));
3685                     mStateAnimation.play(panelAlpha);
3686                 }
3687 
3688                 if (page != null) {
3689                     page.setLayerType(View.LAYER_TYPE_HARDWARE, null);
3690 
3691                     ObjectAnimator pageDrift = LauncherAnimUtils.ofFloat(page, &quot;translationY&quot;,
3692                             0, yDrift);
3693                     page.setTranslationY(0);
3694                     pageDrift.setDuration(revealDuration - SINGLE_FRAME_DELAY);
3695                     pageDrift.setInterpolator(decelerateInterpolator);
3696                     pageDrift.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);
3697                     mStateAnimation.play(pageDrift);
3698 
3699                     page.setAlpha(1f);
3700                     ObjectAnimator itemsAlpha = LauncherAnimUtils.ofFloat(page, &quot;alpha&quot;, 1f, 0f);
3701                     itemsAlpha.setDuration(100);
3702                     itemsAlpha.setInterpolator(decelerateInterpolator);
3703                     mStateAnimation.play(itemsAlpha);
3704                 }
3705 
3706                 View pageIndicators = fromView.findViewById(R.id.apps_customize_page_indicator);
3707                 pageIndicators.setAlpha(1f);
3708                 ObjectAnimator indicatorsAlpha =
3709                         LauncherAnimUtils.ofFloat(pageIndicators, &quot;alpha&quot;, 0f);
3710                 indicatorsAlpha.setDuration(revealDuration);
3711                 indicatorsAlpha.setInterpolator(new DecelerateInterpolator(1.5f));
3712                 mStateAnimation.play(indicatorsAlpha);
3713 
3714                 width = revealView.getMeasuredWidth();
3715 
3716                 if (material) {
3717                     if (!isWidgetTray) {
3718                         allAppsButton.setVisibility(View.INVISIBLE);
3719                     }
3720                     int allAppsButtonSize = LauncherAppState.getInstance().
3721                             getDynamicGrid().getDeviceProfile().allAppsButtonVisualSize;
3722                     float finalRadius = isWidgetTray ? 0 : allAppsButtonSize / 2;
3723                     Animator reveal =
3724                             LauncherAnimUtils.createCircularReveal(revealView, width / 2,
3725                                     height / 2, revealRadius, finalRadius);
3726                     reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
3727                     reveal.setDuration(revealDuration);
3728                     reveal.setStartDelay(itemsAlphaStagger);
3729 
3730                     reveal.addListener(new AnimatorListenerAdapter() {
3731                         public void onAnimationEnd(Animator animation) {
3732                             revealView.setVisibility(View.INVISIBLE);
3733                             if (!isWidgetTray) {
3734                                 allAppsButton.setVisibility(View.VISIBLE);
3735                             }
3736                         }
3737                     });
3738 
3739                     mStateAnimation.play(reveal);
3740                 }
3741 
3742                 dispatchOnLauncherTransitionPrepare(fromView, animated, true);
3743                 dispatchOnLauncherTransitionPrepare(toView, animated, true);
3744                 mAppsCustomizeContent.stopScrolling();
3745             }
3746 
3747             mStateAnimation.addListener(new AnimatorListenerAdapter() {
3748                 @Override
3749                 public void onAnimationEnd(Animator animation) {
3750                     fromView.setVisibility(View.GONE);
3751                     dispatchOnLauncherTransitionEnd(fromView, animated, true);
3752                     dispatchOnLauncherTransitionEnd(toView, animated, true);
3753                     if (onCompleteRunnable != null) {
3754                         onCompleteRunnable.run();
3755                     }
3756 
3757                     revealView.setLayerType(View.LAYER_TYPE_NONE, null);
3758                     if (page != null) {
3759                         page.setLayerType(View.LAYER_TYPE_NONE, null);
3760                     }
3761                     content.setPageBackgroundsVisible(true);
3762                     // Unhide side pages
3763                     int count = content.getChildCount();
3764                     for (int i = 0; i &lt; count; i++) {
3765                         View child = content.getChildAt(i);
3766                         child.setVisibility(View.VISIBLE);
3767                     }
3768 
3769                     // Reset page transforms
3770                     if (page != null) {
3771                         page.setTranslationX(0);
3772                         page.setTranslationY(0);
3773                         page.setAlpha(1);
3774                     }
3775                     content.setCurrentPage(content.getNextPage());
3776 
3777                     mAppsCustomizeContent.updateCurrentPageScroll();
3778                 }
3779             });
3780 
3781             final AnimatorSet stateAnimation = mStateAnimation;
3782             final Runnable startAnimRunnable = new Runnable() {
3783                 public void run() {
3784                     // Check that mStateAnimation hasn&#x27;t changed while
3785                     // we waited for a layout/draw pass
3786                     if (mStateAnimation != stateAnimation)
3787                         return;
3788                     dispatchOnLauncherTransitionStart(fromView, animated, false);
3789                     dispatchOnLauncherTransitionStart(toView, animated, false);
3790 
3791                     if (Utilities.isLmpOrAbove()) {
3792                         for (int i = 0; i &lt; layerViews.size(); i++) {
3793                             View v = layerViews.get(i);
3794                             if (v != null) {
3795                                 boolean attached = true;
3796                                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
3797                                     attached = v.isAttachedToWindow();
3798                                 }
3799                                 if (attached) v.buildLayer();
3800                             }
3801                         }
3802                     }
3803                     mStateAnimation.start();
3804                 }
3805             };
3806             fromView.post(startAnimRunnable);
3807         } else {
3808             fromView.setVisibility(View.GONE);
3809             dispatchOnLauncherTransitionPrepare(fromView, animated, true);
3810             dispatchOnLauncherTransitionStart(fromView, animated, true);
3811             dispatchOnLauncherTransitionEnd(fromView, animated, true);
3812             dispatchOnLauncherTransitionPrepare(toView, animated, true);
3813             dispatchOnLauncherTransitionStart(toView, animated, true);
3814             dispatchOnLauncherTransitionEnd(toView, animated, true);
3815         }
3816     }
3817 
3818     @Override
3819     public void onTrimMemory(int level) {
3820         super.onTrimMemory(level);
3821         if (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
3822             mAppsCustomizeTabHost.onTrimMemory();
3823         }
3824     }
3825 
3826     protected void showWorkspace(boolean animated) {
3827         showWorkspace(animated, null);
3828     }
3829 
3830     protected void showWorkspace() {
3831         showWorkspace(true);
3832     }
3833 
3834     void showWorkspace(boolean animated, Runnable onCompleteRunnable) {
3835         if (mState != State.WORKSPACE || mWorkspace.getState() != Workspace.State.NORMAL) {
3836             boolean wasInSpringLoadedMode = (mState != State.WORKSPACE);
3837             mWorkspace.setVisibility(View.VISIBLE);
3838             hideAppsCustomizeHelper(Workspace.State.NORMAL, animated, false, onCompleteRunnable);
3839 
3840             // Show the search bar (only animate if we were showing the drop target bar in spring
3841             // loaded mode)
3842             if (mSearchDropTargetBar != null) {
3843                 mSearchDropTargetBar.showSearchBar(animated &amp;&amp; wasInSpringLoadedMode);
3844             }
3845 
3846             // Set focus to the AppsCustomize button
3847             if (mAllAppsButton != null) {
3848                 mAllAppsButton.requestFocus();
3849             }
3850         }
3851 
3852         // Change the state *after* we&#x27;ve called all the transition code
3853         mState = State.WORKSPACE;
3854 
3855         // Resume the auto-advance of widgets
3856         mUserPresent = true;
3857         updateRunning();
3858 
3859         // Send an accessibility event to announce the context change
3860         getWindow().getDecorView()
3861                 .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3862 
3863         onWorkspaceShown(animated);
3864     }
3865 
3866     void showOverviewMode(boolean animated) {
3867         mWorkspace.setVisibility(View.VISIBLE);
3868         hideAppsCustomizeHelper(Workspace.State.OVERVIEW, animated, false, null);
3869         mState = State.WORKSPACE;
3870         onWorkspaceShown(animated);
3871     }
3872 
3873     public void onWorkspaceShown(boolean animated) {
3874     }
3875 
3876     void showAllApps(boolean animated, AppsCustomizePagedView.ContentType contentType,
3877                      boolean resetPageToZero) {
3878         if (mState != State.WORKSPACE) return;
3879 
3880         if (resetPageToZero) {
3881             mAppsCustomizeTabHost.reset();
3882         }
3883         showAppsCustomizeHelper(animated, false, contentType);
3884         mAppsCustomizeTabHost.post(new Runnable() {
3885             @Override
3886             public void run() {
3887                 // We post this in-case the all apps view isn&#x27;t yet constructed.
3888                 mAppsCustomizeTabHost.requestFocus();
3889             }
3890         });
3891 
3892         // Change the state *after* we&#x27;ve called all the transition code
3893         mState = State.APPS_CUSTOMIZE;
3894 
3895         // Pause the auto-advance of widgets until we are out of AllApps
3896         mUserPresent = false;
3897         updateRunning();
3898         closeFolder();
3899 
3900         // Send an accessibility event to announce the context change
3901         getWindow().getDecorView()
3902                 .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3903     }
3904 
3905     void enterSpringLoadedDragMode() {
3906         if (isAllAppsVisible()) {
3907             hideAppsCustomizeHelper(Workspace.State.SPRING_LOADED, true, true, null);
3908             mState = State.APPS_CUSTOMIZE_SPRING_LOADED;
3909         }
3910     }
3911 
3912     void exitSpringLoadedDragModeDelayed(final boolean successfulDrop, int delay,
3913             final Runnable onCompleteRunnable) {
3914         if (mState != State.APPS_CUSTOMIZE_SPRING_LOADED) return;
3915 
3916         mHandler.postDelayed(new Runnable() {
3917             @Override
3918             public void run() {
3919                 if (successfulDrop) {
3920                     // Before we show workspace, hide all apps again because
3921                     // exitSpringLoadedDragMode made it visible. This is a bit hacky; we should
3922                     // clean up our state transition functions
3923                     mAppsCustomizeTabHost.setVisibility(View.GONE);
3924                     showWorkspace(true, onCompleteRunnable);
3925                 } else {
3926                     exitSpringLoadedDragMode();
3927                 }
3928             }
3929         }, delay);
3930     }
3931 
3932     void exitSpringLoadedDragMode() {
3933         if (mState == State.APPS_CUSTOMIZE_SPRING_LOADED) {
3934             final boolean animated = true;
3935             final boolean springLoaded = true;
3936             showAppsCustomizeHelper(animated, springLoaded);
3937             mState = State.APPS_CUSTOMIZE;
3938         }
3939         // Otherwise, we are not in spring loaded mode, so don&#x27;t do anything.
3940     }
3941 
3942     void lockAllApps() {
3943         // TODO
3944     }
3945 
3946     void unlockAllApps() {
3947         // TODO
3948     }
3949 
3950     /**
3951      * Hides the hotseat area.
3952      */
3953     void hideHotseat(boolean animated) {
3954         if (!LauncherAppState.getInstance().isScreenLarge()) {
3955             if (animated) {
3956                 if (mHotseat.getAlpha() != 0f) {
3957                     int duration = 0;
3958                     if (mSearchDropTargetBar != null) {
3959                         duration = mSearchDropTargetBar.getTransitionOutDuration();
3960                     }
3961                     mHotseat.animate().alpha(0f).setDuration(duration);
3962                 }
3963             } else {
3964                 mHotseat.setAlpha(0f);
3965             }
3966         }
3967     }
3968 
3969     /**
3970      * Add an item from all apps or customize onto the given workspace screen.
3971      * If layout is null, add to the current screen.
3972      */
3973     void addExternalItemToScreen(ItemInfo itemInfo, final CellLayout layout) {
3974         if (!mWorkspace.addExternalItemToScreen(itemInfo, layout)) {
3975             showOutOfSpaceMessage(isHotseatLayout(layout));
3976         }
3977     }
3978 
3979     /** Maps the current orientation to an index for referencing orientation correct global icons */
3980     private int getCurrentOrientationIndexForGlobalIcons() {
3981         // default - 0, landscape - 1
3982         switch (getResources().getConfiguration().orientation) {
3983         case Configuration.ORIENTATION_LANDSCAPE:
3984             return 1;
3985         default:
3986             return 0;
3987         }
3988     }
3989 
3990     private Drawable getExternalPackageToolbarIcon(ComponentName activityName, String resourceName) {
3991         try {
3992             PackageManager packageManager = getPackageManager();
3993             // Look for the toolbar icon specified in the activity meta-data
3994             Bundle metaData = packageManager.getActivityInfo(
3995                     activityName, PackageManager.GET_META_DATA).metaData;
3996             if (metaData != null) {
3997                 int iconResId = metaData.getInt(resourceName);
3998                 if (iconResId != 0) {
3999                     Resources res = packageManager.getResourcesForActivity(activityName);
4000                     return res.getDrawable(iconResId);
4001                 }
4002             }
4003         } catch (NameNotFoundException e) {
4004             // This can happen if the activity defines an invalid drawable
4005             Log.w(TAG, &quot;Failed to load toolbar icon; &quot; + activityName.flattenToShortString() +
4006                     &quot; not found&quot;, e);
4007         } catch (Resources.NotFoundException nfe) {
4008             // This can happen if the activity defines an invalid drawable
4009             Log.w(TAG, &quot;Failed to load toolbar icon from &quot; + activityName.flattenToShortString(),
4010                     nfe);
4011         }
4012         return null;
4013     }
4014 
4015     // if successful in getting icon, return it; otherwise, set button to use default drawable
4016     private Drawable.ConstantState updateTextButtonWithIconFromExternalActivity(
4017             int buttonId, ComponentName activityName, int fallbackDrawableId,
4018             String toolbarResourceName) {
4019         Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
4020         Resources r = getResources();
4021         int w = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_width);
4022         int h = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_height);
4023 
4024         TextView button = (TextView) findViewById(buttonId);
4025         // If we were unable to find the icon via the meta-data, use a generic one
4026         if (toolbarIcon == null) {
4027             toolbarIcon = r.getDrawable(fallbackDrawableId);
4028             toolbarIcon.setBounds(0, 0, w, h);
4029             if (button != null) {
4030                 button.setCompoundDrawables(toolbarIcon, null, null, null);
4031             }
4032             return null;
4033         } else {
4034             toolbarIcon.setBounds(0, 0, w, h);
4035             if (button != null) {
4036                 button.setCompoundDrawables(toolbarIcon, null, null, null);
4037             }
4038             return toolbarIcon.getConstantState();
4039         }
4040     }
4041 
4042     // if successful in getting icon, return it; otherwise, set button to use default drawable
4043     private Drawable.ConstantState updateButtonWithIconFromExternalActivity(
4044             int buttonId, ComponentName activityName, int fallbackDrawableId,
4045             String toolbarResourceName) {
4046         ImageView button = (ImageView) findViewById(buttonId);
4047         Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
4048 
4049         if (button != null) {
4050             // If we were unable to find the icon via the meta-data, use a
4051             // generic one
4052             if (toolbarIcon == null) {
4053                 button.setImageResource(fallbackDrawableId);
4054             } else {
4055                 button.setImageDrawable(toolbarIcon);
4056             }
4057         }
4058 
4059         return toolbarIcon != null ? toolbarIcon.getConstantState() : null;
4060 
4061     }
4062 
4063     private void updateTextButtonWithDrawable(int buttonId, Drawable d) {
4064         TextView button = (TextView) findViewById(buttonId);
4065         button.setCompoundDrawables(d, null, null, null);
4066     }
4067 
4068     private void updateButtonWithDrawable(int buttonId, Drawable.ConstantState d) {
4069         ImageView button = (ImageView) findViewById(buttonId);
4070         button.setImageDrawable(d.newDrawable(getResources()));
4071     }
4072 
4073     private void invalidatePressedFocusedStates(View container, View button) {
4074         if (container instanceof HolographicLinearLayout) {
4075             HolographicLinearLayout layout = (HolographicLinearLayout) container;
4076             layout.invalidatePressedFocusedStates();
4077         } else if (button instanceof HolographicImageView) {
4078             HolographicImageView view = (HolographicImageView) button;
4079             view.invalidatePressedFocusedStates();
4080         }
4081     }
4082 
4083     public View getQsbBar() {
4084         if (mQsb == null) {
4085             mQsb = mInflater.inflate(R.layout.qsb, mSearchDropTargetBar, false);
4086             mSearchDropTargetBar.addView(mQsb);
4087         }
4088         return mQsb;
4089     }
4090 
4091     protected boolean updateGlobalSearchIcon() {
4092         final View searchButtonContainer = findViewById(R.id.search_button_container);
4093         final ImageView searchButton = (ImageView) findViewById(R.id.search_button);
4094         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4095         final View voiceButton = findViewById(R.id.voice_button);
4096 
4097         final SearchManager searchManager =
4098                 (SearchManager) getSystemService(Context.SEARCH_SERVICE);
4099         ComponentName activityName = searchManager.getGlobalSearchActivity();
4100         if (activityName != null) {
4101             int coi = getCurrentOrientationIndexForGlobalIcons();
4102             sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4103                     R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
4104                     TOOLBAR_SEARCH_ICON_METADATA_NAME);
4105             if (sGlobalSearchIcon[coi] == null) {
4106                 sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4107                         R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
4108                         TOOLBAR_ICON_METADATA_NAME);
4109             }
4110 
4111             if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.VISIBLE);
4112             searchButton.setVisibility(View.VISIBLE);
4113             invalidatePressedFocusedStates(searchButtonContainer, searchButton);
4114             return true;
4115         } else {
4116             // We disable both search and voice search when there is no global search provider
4117             if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.GONE);
4118             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
4119             if (searchButton != null) searchButton.setVisibility(View.GONE);
4120             if (voiceButton != null) voiceButton.setVisibility(View.GONE);
4121             updateVoiceButtonProxyVisible(false);
4122             return false;
4123         }
4124     }
4125 
4126     protected void updateGlobalSearchIcon(Drawable.ConstantState d) {
4127         final View searchButtonContainer = findViewById(R.id.search_button_container);
4128         final View searchButton = (ImageView) findViewById(R.id.search_button);
4129         updateButtonWithDrawable(R.id.search_button, d);
4130         invalidatePressedFocusedStates(searchButtonContainer, searchButton);
4131     }
4132 
4133     protected boolean updateVoiceSearchIcon(boolean searchVisible) {
4134         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4135         final View voiceButton = findViewById(R.id.voice_button);
4136 
4137         // We only show/update the voice search icon if the search icon is enabled as well
4138         final SearchManager searchManager =
4139                 (SearchManager) getSystemService(Context.SEARCH_SERVICE);
4140         ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
4141 
4142         ComponentName activityName = null;
4143         if (globalSearchActivity != null) {
4144             // Check if the global search activity handles voice search
4145             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
4146             intent.setPackage(globalSearchActivity.getPackageName());
4147             activityName = intent.resolveActivity(getPackageManager());
4148         }
4149 
4150         if (activityName == null) {
4151             // Fallback: check if an activity other than the global search activity
4152             // resolves this
4153             Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
4154             activityName = intent.resolveActivity(getPackageManager());
4155         }
4156         if (searchVisible &amp;&amp; activityName != null) {
4157             int coi = getCurrentOrientationIndexForGlobalIcons();
4158             sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4159                     R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
4160                     TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME);
4161             if (sVoiceSearchIcon[coi] == null) {
4162                 sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4163                         R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
4164                         TOOLBAR_ICON_METADATA_NAME);
4165             }
4166             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.VISIBLE);
4167             voiceButton.setVisibility(View.VISIBLE);
4168             updateVoiceButtonProxyVisible(false);
4169             invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
4170             return true;
4171         } else {
4172             if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
4173             if (voiceButton != null) voiceButton.setVisibility(View.GONE);
4174             updateVoiceButtonProxyVisible(false);
4175             return false;
4176         }
4177     }
4178 
4179     protected void updateVoiceSearchIcon(Drawable.ConstantState d) {
4180         final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4181         final View voiceButton = findViewById(R.id.voice_button);
4182         updateButtonWithDrawable(R.id.voice_button, d);
4183         invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
4184     }
4185 
4186     public void updateVoiceButtonProxyVisible(boolean forceDisableVoiceButtonProxy) {
4187         final View voiceButtonProxy = findViewById(R.id.voice_button_proxy);
4188         if (voiceButtonProxy != null) {
4189             boolean visible = !forceDisableVoiceButtonProxy &amp;&amp;
4190                     mWorkspace.shouldVoiceButtonProxyBeVisible();
4191             voiceButtonProxy.setVisibility(visible ? View.VISIBLE : View.GONE);
4192             voiceButtonProxy.bringToFront();
4193         }
4194     }
4195 
4196     /**
<abbr title="4197      * This is an overrid eot disable the voice button proxy.  If disabled is true, then the voice button proxy">4197      * This is an overrid eot disable the voice button proxy.  If disabled is true, then the voice button🔵</abbr>
4198      * will be hidden regardless of what shouldVoiceButtonProxyBeVisible() returns.
4199      */
4200     public void disableVoiceButtonProxy(boolean disabled) {
4201         updateVoiceButtonProxyVisible(disabled);
4202     }
4203 
4204     @Override
4205     public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
4206         final boolean result = super.dispatchPopulateAccessibilityEvent(event);
4207         final List&lt;CharSequence&gt; text = event.getText();
4208         text.clear();
4209         // Populate event with a fake title based on the current state.
4210         if (mState == State.APPS_CUSTOMIZE) {
4211             text.add(mAppsCustomizeTabHost.getContentTag());
4212         } else {
4213             text.add(getString(R.string.all_apps_home_button_label));
4214         }
4215         return result;
4216     }
4217 
4218     /**
4219      * Receives notifications when system dialogs are to be closed.
4220      */
4221     private class CloseSystemDialogsIntentReceiver extends BroadcastReceiver {
4222         @Override
4223         public void onReceive(Context context, Intent intent) {
4224             closeSystemDialogs();
4225         }
4226     }
4227 
4228     /**
4229      * Receives notifications whenever the appwidgets are reset.
4230      */
4231     private class AppWidgetResetObserver extends ContentObserver {
4232         public AppWidgetResetObserver() {
4233             super(new Handler());
4234         }
4235 
4236         @Override
4237         public void onChange(boolean selfChange) {
4238             onAppWidgetReset();
4239         }
4240     }
4241 
4242     /**
4243      * If the activity is currently paused, signal that we need to run the passed Runnable
4244      * in onResume.
4245      *
4246      * This needs to be called from incoming places where resources might have been loaded
4247      * while we are paused.  That is becaues the Configuration might be wrong
4248      * when we&#x27;re not running, and if it comes back to what it was when we
4249      * were paused, we are not restarted.
4250      *
4251      * Implementation of the method from LauncherModel.Callbacks.
4252      *
4253      * @return true if we are currently paused.  The caller might be able to
4254      * skip some work in that case since we will come back again.
4255      */
4256     private boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) {
4257         if (mPaused) {
4258             Log.i(TAG, &quot;Deferring update until onResume&quot;);
4259             if (deletePreviousRunnables) {
4260                 while (mBindOnResumeCallbacks.remove(run)) {
4261                 }
4262             }
4263             mBindOnResumeCallbacks.add(run);
4264             return true;
4265         } else {
4266             return false;
4267         }
4268     }
4269 
4270     private boolean waitUntilResume(Runnable run) {
4271         return waitUntilResume(run, false);
4272     }
4273 
4274     public void addOnResumeCallback(Runnable run) {
4275         mOnResumeCallbacks.add(run);
4276     }
4277 
4278     /**
4279      * If the activity is currently paused, signal that we need to re-run the loader
4280      * in onResume.
4281      *
4282      * This needs to be called from incoming places where resources might have been loaded
4283      * while we are paused.  That is becaues the Configuration might be wrong
4284      * when we&#x27;re not running, and if it comes back to what it was when we
4285      * were paused, we are not restarted.
4286      *
4287      * Implementation of the method from LauncherModel.Callbacks.
4288      *
4289      * @return true if we are currently paused.  The caller might be able to
4290      * skip some work in that case since we will come back again.
4291      */
4292     public boolean setLoadOnResume() {
4293         if (mPaused) {
4294             Log.i(TAG, &quot;setLoadOnResume&quot;);
4295             mOnResumeNeedsLoad = true;
4296             return true;
4297         } else {
4298             return false;
4299         }
4300     }
4301 
4302     /**
4303      * Implementation of the method from LauncherModel.Callbacks.
4304      */
4305     public int getCurrentWorkspaceScreen() {
4306         if (mWorkspace != null) {
4307             return mWorkspace.getCurrentPage();
4308         } else {
4309             return SCREEN_COUNT / 2;
4310         }
4311     }
4312 
4313     /**
4314      * Refreshes the shortcuts shown on the workspace.
4315      *
4316      * Implementation of the method from LauncherModel.Callbacks.
4317      */
4318     public void startBinding() {
4319         setWorkspaceLoading(true);
4320 
4321         // If we&#x27;re starting binding all over again, clear any bind calls we&#x27;d postponed in
4322         // the past (see waitUntilResume) -- we don&#x27;t need them since we&#x27;re starting binding
4323         // from scratch again
4324         mBindOnResumeCallbacks.clear();
4325 
4326         // Clear the workspace because it&#x27;s going to be rebound
4327         mWorkspace.clearDropTargets();
4328         mWorkspace.removeAllWorkspaceScreens();
4329 
4330         mWidgetsToAdvance.clear();
4331         if (mHotseat != null) {
4332             mHotseat.resetLayout();
4333         }
4334     }
4335 
4336     @Override
4337     public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
4338         bindAddScreens(orderedScreenIds);
4339 
4340         // If there are no screens, we need to have an empty screen
4341         if (orderedScreenIds.size() == 0) {
4342             mWorkspace.addExtraEmptyScreen();
4343         }
4344 
4345         // Create the custom content page (this call updates mDefaultScreen which calls
4346         // setCurrentPage() so ensure that all pages are added before calling this).
4347         if (hasCustomContentToLeft()) {
4348             mWorkspace.createCustomContentContainer();
4349             populateCustomContentContainer();
4350         }
4351     }
4352 
4353     @Override
4354     public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
4355         // Log to disk
4356         Launcher.addDumpLog(TAG, &quot;11683562 - bindAddScreens()&quot;, true);
4357         Launcher.addDumpLog(TAG, &quot;11683562 -   orderedScreenIds: &quot; +
4358                 TextUtils.join(&quot;, &quot;, orderedScreenIds), true);
4359         int count = orderedScreenIds.size();
4360         for (int i = 0; i &lt; count; i++) {
4361             mWorkspace.insertNewWorkspaceScreenBeforeEmptyScreen(orderedScreenIds.get(i));
4362         }
4363     }
4364 
4365     private boolean shouldShowWeightWatcher() {
4366         String spKey = LauncherAppState.getSharedPreferencesKey();
4367         SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
4368         boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, SHOW_WEIGHT_WATCHER_DEFAULT);
4369 
4370         return show;
4371     }
4372 
4373     private void toggleShowWeightWatcher() {
4374         String spKey = LauncherAppState.getSharedPreferencesKey();
4375         SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
4376         boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, true);
4377 
4378         show = !show;
4379 
4380         SharedPreferences.Editor editor = sp.edit();
4381         editor.putBoolean(SHOW_WEIGHT_WATCHER, show);
4382         editor.commit();
4383 
4384         if (mWeightWatcher != null) {
4385             mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
4386         }
4387     }
4388 
4389     public void bindAppsAdded(final ArrayList&lt;Long&gt; newScreens,
4390                               final ArrayList&lt;ItemInfo&gt; addNotAnimated,
4391                               final ArrayList&lt;ItemInfo&gt; addAnimated,
4392                               final ArrayList&lt;AppInfo&gt; addedApps) {
4393         Runnable r = new Runnable() {
4394             public void run() {
4395                 bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
4396             }
4397         };
4398         if (waitUntilResume(r)) {
4399             return;
4400         }
4401 
4402         // Add the new screens
4403         if (newScreens != null) {
4404             bindAddScreens(newScreens);
4405         }
4406 
4407         // We add the items without animation on non-visible pages, and with
4408         // animations on the new page (which we will try and snap to).
4409         if (addNotAnimated != null &amp;&amp; !addNotAnimated.isEmpty()) {
4410             bindItems(addNotAnimated, 0,
4411                     addNotAnimated.size(), false);
4412         }
4413         if (addAnimated != null &amp;&amp; !addAnimated.isEmpty()) {
4414             bindItems(addAnimated, 0,
4415                     addAnimated.size(), true);
4416         }
4417 
4418         // Remove the extra empty screen
4419         mWorkspace.removeExtraEmptyScreen(false, false);
4420 
4421         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4422                 addedApps != null &amp;&amp; mAppsCustomizeContent != null) {
4423             mAppsCustomizeContent.addApps(addedApps);
4424         }
4425     }
4426 
4427     /**
4428      * Bind the items start-end from the list.
4429      *
4430      * Implementation of the method from LauncherModel.Callbacks.
4431      */
4432     public void bindItems(final ArrayList&lt;ItemInfo&gt; shortcuts, final int start, final int end,
4433                           final boolean forceAnimateIcons) {
4434         Runnable r = new Runnable() {
4435             public void run() {
4436                 bindItems(shortcuts, start, end, forceAnimateIcons);
4437             }
4438         };
4439         if (waitUntilResume(r)) {
4440             return;
4441         }
4442 
4443         // Get the list of added shortcuts and intersect them with the set of shortcuts here
4444         final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
4445         final Collection&lt;Animator&gt; bounceAnims = new ArrayList&lt;Animator&gt;();
4446         final boolean animateIcons = forceAnimateIcons &amp;&amp; canRunNewAppsAnimation();
4447         Workspace workspace = mWorkspace;
4448         long newShortcutsScreenId = -1;
4449         for (int i = start; i &lt; end; i++) {
4450             final ItemInfo item = shortcuts.get(i);
4451 
4452             // Short circuit if we are loading dock items for a configuration which has no dock
4453             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
4454                     mHotseat == null) {
4455                 continue;
4456             }
4457 
4458             switch (item.itemType) {
4459                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
4460                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
4461                     ShortcutInfo info = (ShortcutInfo) item;
4462                     View shortcut = createShortcut(info);
4463 
4464                     /*
4465                      * TODO: FIX collision case
4466                      */
4467                     if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
4468                         CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
4469                         if (cl != null &amp;&amp; cl.isOccupied(item.cellX, item.cellY)) {
4470                             View v = cl.getChildAt(item.cellX, item.cellY);
4471                             Object tag = v.getTag();
4472                             String desc = &quot;Collision while binding workspace item: &quot; + item
4473                                     + &quot;. Collides with &quot; + tag;
4474                             if (LauncherAppState.isDogfoodBuild()) {
4475                                 throw (new RuntimeException(desc));
4476                             } else {
4477                                 Log.d(TAG, desc);
4478                             }
4479                         }
4480                     }
4481 
4482                     workspace.addInScreenFromBind(shortcut, item.container, item.screenId, item.cellX,
4483                             item.cellY, 1, 1);
4484                     if (animateIcons) {
4485                         // Animate all the applications up now
4486                         shortcut.setAlpha(0f);
4487                         shortcut.setScaleX(0f);
4488                         shortcut.setScaleY(0f);
4489                         bounceAnims.add(createNewAppBounceAnimation(shortcut, i));
4490                         newShortcutsScreenId = item.screenId;
4491                     }
4492                     break;
4493                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
4494                     FolderIcon newFolder = FolderIcon.fromXml(R.layout.folder_icon, this,
4495                             (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()),
4496                             (FolderInfo) item, mIconCache);
4497                     workspace.addInScreenFromBind(newFolder, item.container, item.screenId, item.cellX,
4498                             item.cellY, 1, 1);
4499                     break;
4500                 default:
4501                     throw new RuntimeException(&quot;Invalid Item Type&quot;);
4502             }
4503         }
4504 
4505         if (animateIcons) {
4506             // Animate to the correct page
4507             if (newShortcutsScreenId &gt; -1) {
4508                 long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
4509                 final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
4510                 final Runnable startBounceAnimRunnable = new Runnable() {
4511                     public void run() {
4512                         anim.playTogether(bounceAnims);
4513                         anim.start();
4514                     }
4515                 };
4516                 if (newShortcutsScreenId != currentScreenId) {
4517                     // We post the animation slightly delayed to prevent slowdowns
4518                     // when we are loading right after we return to launcher.
4519                     mWorkspace.postDelayed(new Runnable() {
4520                         public void run() {
4521                             if (mWorkspace != null) {
4522                                 mWorkspace.snapToPage(newScreenIndex);
4523                                 mWorkspace.postDelayed(startBounceAnimRunnable,
4524                                         NEW_APPS_ANIMATION_DELAY);
4525                             }
4526                         }
4527                     }, NEW_APPS_PAGE_MOVE_DELAY);
4528                 } else {
4529                     mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
4530                 }
4531             }
4532         }
4533         workspace.requestLayout();
4534     }
4535 
4536     /**
4537      * Implementation of the method from LauncherModel.Callbacks.
4538      */
4539     public void bindFolders(final HashMap&lt;Long, FolderInfo&gt; folders) {
4540         Runnable r = new Runnable() {
4541             public void run() {
4542                 bindFolders(folders);
4543             }
4544         };
4545         if (waitUntilResume(r)) {
4546             return;
4547         }
4548         sFolders.clear();
4549         sFolders.putAll(folders);
4550     }
4551 
4552     /**
4553      * Add the views for a widget to the workspace.
4554      *
4555      * Implementation of the method from LauncherModel.Callbacks.
4556      */
4557     public void bindAppWidget(final LauncherAppWidgetInfo item) {
4558         Runnable r = new Runnable() {
4559             public void run() {
4560                 bindAppWidget(item);
4561             }
4562         };
4563         if (waitUntilResume(r)) {
4564             return;
4565         }
4566 
4567         final long start = DEBUG_WIDGETS ? SystemClock.uptimeMillis() : 0;
4568         if (DEBUG_WIDGETS) {
4569             Log.d(TAG, &quot;bindAppWidget: &quot; + item);
4570         }
4571         final Workspace workspace = mWorkspace;
4572 
4573         AppWidgetProviderInfo appWidgetInfo;
4574         if (((item.restoreStatus &amp; LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0) &amp;&amp;
4575                 ((item.restoreStatus &amp; LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) != 0)) {
4576 
4577             appWidgetInfo = mModel.findAppWidgetProviderInfoWithComponent(this, item.providerName);
4578             if (appWidgetInfo == null) {
4579                 if (DEBUG_WIDGETS) {
4580                     Log.d(TAG, &quot;Removing restored widget: id=&quot; + item.appWidgetId
4581                             + &quot; belongs to component &quot; + item.providerName
4582                             + &quot;, as the povider is null&quot;);
4583                 }
4584                 LauncherModel.deleteItemFromDatabase(this, item);
4585                 return;
4586             }
4587             // Note: This assumes that the id remap broadcast is received before this step.
4588             // If that is not the case, the id remap will be ignored and user may see the
4589             // click to setup view.
4590             PendingAddWidgetInfo pendingInfo = new PendingAddWidgetInfo(appWidgetInfo, null, null);
4591             pendingInfo.spanX = item.spanX;
4592             pendingInfo.spanY = item.spanY;
4593             pendingInfo.minSpanX = item.minSpanX;
4594             pendingInfo.minSpanY = item.minSpanY;
4595             Bundle options =
4596                     AppsCustomizePagedView.getDefaultOptionsForWidget(this, pendingInfo);
4597 
4598             int newWidgetId = mAppWidgetHost.allocateAppWidgetId();
4599             boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
4600                     newWidgetId, appWidgetInfo, options);
4601 
4602             // TODO consider showing a permission dialog when the widget is clicked.
4603             if (!success) {
4604                 mAppWidgetHost.deleteAppWidgetId(newWidgetId);
4605                 if (DEBUG_WIDGETS) {
4606                     Log.d(TAG, &quot;Removing restored widget: id=&quot; + item.appWidgetId
4607                             + &quot; belongs to component &quot; + item.providerName
4608                             + &quot;, as the launcher is unable to bing a new widget id&quot;);
4609                 }
4610                 LauncherModel.deleteItemFromDatabase(this, item);
4611                 return;
4612             }
4613 
4614             item.appWidgetId = newWidgetId;
4615 
4616             // If the widget has a configure activity, it is still needs to set it up, otherwise
4617             // the widget is ready to go.
4618             item.restoreStatus = (appWidgetInfo.configure == null)
4619                     ? LauncherAppWidgetInfo.RESTORE_COMPLETED
4620                     : LauncherAppWidgetInfo.FLAG_UI_NOT_READY;
4621 
4622             LauncherModel.updateItemInDatabase(this, item);
4623         }
4624 
4625         if (item.restoreStatus == LauncherAppWidgetInfo.RESTORE_COMPLETED) {
4626             final int appWidgetId = item.appWidgetId;
4627             appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
4628             if (DEBUG_WIDGETS) {
<abbr title="4629                 Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.provider);">4629                 Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidget🔵</abbr>
4630             }
4631 
4632             item.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);
4633         } else {
4634             appWidgetInfo = null;
4635             PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item);
4636             view.updateIcon(mIconCache);
4637             item.hostView = view;
4638             item.hostView.updateAppWidget(null);
4639             item.hostView.setOnClickListener(this);
4640         }
4641 
4642         item.hostView.setTag(item);
4643         item.onBindAppWidget(this);
4644 
4645         workspace.addInScreen(item.hostView, item.container, item.screenId, item.cellX,
4646                 item.cellY, item.spanX, item.spanY, false);
4647         addWidgetToAutoAdvanceIfNeeded(item.hostView, appWidgetInfo);
4648 
4649         workspace.requestLayout();
4650 
4651         if (DEBUG_WIDGETS) {
4652             Log.d(TAG, &quot;bound widget id=&quot;+item.appWidgetId+&quot; in &quot;
4653                     + (SystemClock.uptimeMillis()-start) + &quot;ms&quot;);
4654         }
4655     }
4656 
4657     /**
4658      * Restores a pending widget.
4659      *
4660      * @param appWidgetId The app widget id
4661      * @param cellInfo The position on screen where to create the widget.
4662      */
4663     private void completeRestoreAppWidget(final int appWidgetId) {
4664         LauncherAppWidgetHostView view = mWorkspace.getWidgetForAppWidgetId(appWidgetId);
4665         if ((view == null) || !(view instanceof PendingAppWidgetHostView)) {
4666             Log.e(TAG, &quot;Widget update called, when the widget no longer exists.&quot;);
4667             return;
4668         }
4669 
4670         LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) view.getTag();
4671         info.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;
4672 
4673         mWorkspace.reinflateWidgetsIfNecessary();
4674         LauncherModel.updateItemInDatabase(this, info);
4675     }
4676 
4677     public void onPageBoundSynchronously(int page) {
4678         mSynchronouslyBoundPages.add(page);
4679     }
4680 
4681     /**
4682      * Callback saying that there aren&#x27;t any more items to bind.
4683      *
4684      * Implementation of the method from LauncherModel.Callbacks.
4685      */
4686     public void finishBindingItems(final boolean upgradePath) {
4687         Runnable r = new Runnable() {
4688             public void run() {
4689                 finishBindingItems(upgradePath);
4690             }
4691         };
4692         if (waitUntilResume(r)) {
4693             return;
4694         }
4695         if (mSavedState != null) {
4696             if (!mWorkspace.hasFocus()) {
4697                 mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
4698             }
4699             mSavedState = null;
4700         }
4701 
4702         mWorkspace.restoreInstanceStateForRemainingPages();
4703 
4704         setWorkspaceLoading(false);
4705         sendLoadingCompleteBroadcastIfNecessary();
4706 
4707         // If we received the result of any pending adds while the loader was running (e.g. the
4708         // widget configuration forced an orientation change), process them now.
4709         if (sPendingAddItem != null) {
4710             final long screenId = completeAdd(sPendingAddItem);
4711 
4712             // TODO: this moves the user to the page where the pending item was added. Ideally,
4713             // the screen would be guaranteed to exist after bind, and the page would be set through
4714             // the workspace restore process.
4715             mWorkspace.post(new Runnable() {
4716                 @Override
4717                 public void run() {
4718                     mWorkspace.snapToScreenId(screenId);
4719                 }
4720             });
4721             sPendingAddItem = null;
4722         }
4723 
4724         if (upgradePath) {
4725             mWorkspace.getUniqueComponents(true, null);
4726             mIntentsOnWorkspaceFromUpgradePath = mWorkspace.getUniqueComponents(true, null);
4727         }
4728         PackageInstallerCompat.getInstance(this).onFinishBind();
4729         mModel.recheckRestoredItems(this);
4730     }
4731 
4732     private void sendLoadingCompleteBroadcastIfNecessary() {
4733         if (!mSharedPrefs.getBoolean(FIRST_LOAD_COMPLETE, false)) {
4734             String permission =
4735                     getResources().getString(R.string.receive_first_load_broadcast_permission);
4736             Intent intent = new Intent(ACTION_FIRST_LOAD_COMPLETE);
4737             sendBroadcast(intent, permission);
4738             SharedPreferences.Editor editor = mSharedPrefs.edit();
4739             editor.putBoolean(FIRST_LOAD_COMPLETE, true);
4740             editor.apply();
4741         }
4742     }
4743 
4744     public boolean isAllAppsButtonRank(int rank) {
4745         if (mHotseat != null) {
4746             return mHotseat.isAllAppsButtonRank(rank);
4747         }
4748         return false;
4749     }
4750 
4751     private boolean canRunNewAppsAnimation() {
4752         long diff = System.currentTimeMillis() - mDragController.getLastGestureUpTime();
4753         return diff &gt; (NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS * 1000);
4754     }
4755 
4756     private ValueAnimator createNewAppBounceAnimation(View v, int i) {
4757         ValueAnimator bounceAnim = LauncherAnimUtils.ofPropertyValuesHolder(v,
4758                 PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1f),
4759                 PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f),
4760                 PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f));
4761         bounceAnim.setDuration(InstallShortcutReceiver.NEW_SHORTCUT_BOUNCE_DURATION);
4762         bounceAnim.setStartDelay(i * InstallShortcutReceiver.NEW_SHORTCUT_STAGGER_DELAY);
4763         bounceAnim.setInterpolator(new SmoothPagedView.OvershootInterpolator());
4764         return bounceAnim;
4765     }
4766 
4767     public boolean useVerticalBarLayout() {
4768         return LauncherAppState.getInstance().getDynamicGrid().
4769                 getDeviceProfile().isVerticalBarLayout();
4770     }
4771 
4772     protected Rect getSearchBarBounds() {
4773         return LauncherAppState.getInstance().getDynamicGrid().
4774                 getDeviceProfile().getSearchBarBounds();
4775     }
4776 
4777     @Override
4778     public void bindSearchablesChanged() {
4779         boolean searchVisible = updateGlobalSearchIcon();
4780         boolean voiceVisible = updateVoiceSearchIcon(searchVisible);
4781         if (mSearchDropTargetBar != null) {
4782             mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
4783         }
4784     }
4785 
4786     /**
4787      * Add the icons for all apps.
4788      *
4789      * Implementation of the method from LauncherModel.Callbacks.
4790      */
4791     public void bindAllApplications(final ArrayList&lt;AppInfo&gt; apps) {
4792         if (LauncherAppState.isDisableAllApps()) {
4793             if (mIntentsOnWorkspaceFromUpgradePath != null) {
4794                 if (LauncherModel.UPGRADE_USE_MORE_APPS_FOLDER) {
4795                     getHotseat().addAllAppsFolder(mIconCache, apps,
4796                             mIntentsOnWorkspaceFromUpgradePath, Launcher.this, mWorkspace);
4797                 }
4798                 mIntentsOnWorkspaceFromUpgradePath = null;
4799             }
4800             if (mAppsCustomizeContent != null) {
4801                 mAppsCustomizeContent.onPackagesUpdated(
4802                         LauncherModel.getSortedWidgetsAndShortcuts(this));
4803             }
4804         } else {
4805             if (mAppsCustomizeContent != null) {
4806                 mAppsCustomizeContent.setApps(apps);
4807                 mAppsCustomizeContent.onPackagesUpdated(
4808                         LauncherModel.getSortedWidgetsAndShortcuts(this));
4809             }
4810         }
4811     }
4812 
4813     /**
4814      * A package was updated.
4815      *
4816      * Implementation of the method from LauncherModel.Callbacks.
4817      */
4818     public void bindAppsUpdated(final ArrayList&lt;AppInfo&gt; apps) {
4819         Runnable r = new Runnable() {
4820             public void run() {
4821                 bindAppsUpdated(apps);
4822             }
4823         };
4824         if (waitUntilResume(r)) {
4825             return;
4826         }
4827 
4828         if (mWorkspace != null) {
4829             mWorkspace.updateShortcutsAndWidgets(apps);
4830         }
4831 
4832         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4833                 mAppsCustomizeContent != null) {
4834             mAppsCustomizeContent.updateApps(apps);
4835         }
4836     }
4837 
4838     /**
4839      * Packages were restored
4840      */
4841     public void bindAppsRestored(final ArrayList&lt;AppInfo&gt; apps) {
4842         Runnable r = new Runnable() {
4843             public void run() {
4844                 bindAppsRestored(apps);
4845             }
4846         };
4847         if (waitUntilResume(r)) {
4848             return;
4849         }
4850 
4851         if (mWorkspace != null) {
4852             mWorkspace.updateShortcutsAndWidgets(apps);
4853         }
4854     }
4855 
4856     /**
4857      * Update the state of a package, typically related to install state.
4858      *
4859      * Implementation of the method from LauncherModel.Callbacks.
4860      */
4861     @Override
4862     public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo) {
4863         if (mWorkspace != null) {
4864             mWorkspace.updatePackageState(installInfo);
4865         }
4866     }
4867 
4868     /**
4869      * Update the label and icon of all the icons in a package
4870      *
4871      * Implementation of the method from LauncherModel.Callbacks.
4872      */
4873     @Override
4874     public void updatePackageBadge(String packageName) {
4875         if (mWorkspace != null) {
4876             mWorkspace.updatePackageBadge(packageName, UserHandleCompat.myUserHandle());
4877         }
4878     }
4879 
4880     /**
4881      * A package was uninstalled.  We take both the super set of packageNames
4882      * in addition to specific applications to remove, the reason being that
4883      * this can be called when a package is updated as well.  In that scenario,
4884      * we only remove specific components from the workspace, where as
4885      * package-removal should clear all items by package name.
4886      *
4887      * Implementation of the method from LauncherModel.Callbacks.
4888      */
4889     public void bindComponentsRemoved(final ArrayList&lt;String&gt; packageNames,
4890             final ArrayList&lt;AppInfo&gt; appInfos, final UserHandleCompat user) {
4891         Runnable r = new Runnable() {
4892             public void run() {
4893                 bindComponentsRemoved(packageNames, appInfos, user);
4894             }
4895         };
4896         if (waitUntilResume(r)) {
4897             return;
4898         }
4899 
4900         if (!packageNames.isEmpty()) {
4901             mWorkspace.removeItemsByPackageName(packageNames, user);
4902         }
4903         if (!appInfos.isEmpty()) {
4904             mWorkspace.removeItemsByApplicationInfo(appInfos, user);
4905         }
4906 
4907         // Notify the drag controller
4908         mDragController.onAppsRemoved(packageNames, appInfos);
4909 
4910         // Update AllApps
4911         if (!LauncherAppState.isDisableAllApps() &amp;&amp;
4912                 mAppsCustomizeContent != null) {
4913             mAppsCustomizeContent.removeApps(appInfos);
4914         }
4915     }
4916 
4917     /**
4918      * A number of packages were updated.
4919      */
4920     private ArrayList&lt;Object&gt; mWidgetsAndShortcuts;
4921     private Runnable mBindPackagesUpdatedRunnable = new Runnable() {
4922             public void run() {
4923                 bindPackagesUpdated(mWidgetsAndShortcuts);
4924                 mWidgetsAndShortcuts = null;
4925             }
4926         };
4927     public void bindPackagesUpdated(final ArrayList&lt;Object&gt; widgetsAndShortcuts) {
4928         if (waitUntilResume(mBindPackagesUpdatedRunnable, true)) {
4929             mWidgetsAndShortcuts = widgetsAndShortcuts;
4930             return;
4931         }
4932 
4933         // Update the widgets pane
4934         if (mAppsCustomizeContent != null) {
4935             mAppsCustomizeContent.onPackagesUpdated(widgetsAndShortcuts);
4936         }
4937     }
4938 
4939     private int mapConfigurationOriActivityInfoOri(int configOri) {
4940         final Display d = getWindowManager().getDefaultDisplay();
4941         int naturalOri = Configuration.ORIENTATION_LANDSCAPE;
4942         switch (d.getRotation()) {
4943         case Surface.ROTATION_0:
4944         case Surface.ROTATION_180:
4945             // We are currently in the same basic orientation as the natural orientation
4946             naturalOri = configOri;
4947             break;
4948         case Surface.ROTATION_90:
4949         case Surface.ROTATION_270:
4950             // We are currently in the other basic orientation to the natural orientation
4951             naturalOri = (configOri == Configuration.ORIENTATION_LANDSCAPE) ?
4952                     Configuration.ORIENTATION_PORTRAIT : Configuration.ORIENTATION_LANDSCAPE;
4953             break;
4954         }
4955 
4956         int[] oriMap = {
4957                 ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
4958                 ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE,
4959                 ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
4960                 ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
4961         };
4962         // Since the map starts at portrait, we need to offset if this device&#x27;s natural orientation
4963         // is landscape.
4964         int indexOffset = 0;
4965         if (naturalOri == Configuration.ORIENTATION_LANDSCAPE) {
4966             indexOffset = 1;
4967         }
4968         return oriMap[(d.getRotation() + indexOffset) % 4];
4969     }
4970 
4971     public boolean isRotationEnabled() {
4972         boolean enableRotation = sForceEnableRotation ||
4973                 getResources().getBoolean(R.bool.allow_rotation);
4974         return enableRotation;
4975     }
4976     public void lockScreenOrientation() {
4977         if (isRotationEnabled()) {
4978             setRequestedOrientation(mapConfigurationOriActivityInfoOri(getResources()
4979                     .getConfiguration().orientation));
4980         }
4981     }
4982     public void unlockScreenOrientation(boolean immediate) {
4983         if (isRotationEnabled()) {
4984             if (immediate) {
4985                 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
4986             } else {
4987                 mHandler.postDelayed(new Runnable() {
4988                     public void run() {
4989                         setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
4990                     }
4991                 }, mRestoreScreenOrientationDelay);
4992             }
4993         }
4994     }
4995 
4996     /**
4997      * Called when the SearchBar hint should be changed.
4998      *
4999      * @param hint the hint to be displayed in the search bar.
5000      */
5001     protected void onSearchBarHintChanged(String hint) {
5002 
5003 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5004 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5005 </span>
5006 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="5007 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">5007 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
5008 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5009 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5010         mLauncherClings.updateSearchBarHint(hint);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5011 </span>
5012 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
5013     }
5014 
5015     protected boolean isLauncherPreinstalled() {
5016         PackageManager pm = getPackageManager();
5017         try {
5018             ApplicationInfo ai = pm.getApplicationInfo(getComponentName().getPackageName(), 0);
5019             if ((ai.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
5020                 return true;
5021             } else {
5022                 return false;
5023             }
5024         } catch (NameNotFoundException e) {
5025             e.printStackTrace();
5026             return false;
5027         }
5028     }
5029 
5030     /**
5031      * This method indicates whether or not we should suggest default wallpaper dimensions
5032      * when our wallpaper cropper was not yet used to set a wallpaper.
5033      */
5034     protected boolean overrideWallpaperDimensions() {
5035         return true;
5036     }
5037 
5038     protected boolean shouldClingFocusHotseatApp() {
5039         return false;
5040     }
5041     protected String getFirstRunClingSearchBarHint() {
5042         return &quot;&quot;;
5043     }
5044     protected String getFirstRunCustomContentHint() {
5045         return &quot;&quot;;
5046     }
5047     protected int getFirstRunFocusedHotseatAppDrawableId() {
5048         return -1;
5049     }
5050     protected ComponentName getFirstRunFocusedHotseatAppComponentName() {
5051         return null;
5052     }
5053     protected int getFirstRunFocusedHotseatAppRank() {
5054         return -1;
5055     }
5056     protected String getFirstRunFocusedHotseatAppBubbleTitle() {
5057         return &quot;&quot;;
5058     }
5059     protected String getFirstRunFocusedHotseatAppBubbleDescription() {
5060         return &quot;&quot;;
5061     }
5062 
5063 
5064 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5065     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5066      * To be overridden by subclasses to indicate that there is an activity to launch</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5067      * before showing the standard launcher experience.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5068      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5069     protected boolean hasFirstRunActivity() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5070         return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5071     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5072 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5073     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5074      * To be overridden by subclasses to launch any first run activity</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5075      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5076     protected Intent getFirstRunActivity() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5077         return null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5078     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5079 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5080     private boolean shouldRunFirstRunActivity() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5081         return !ActivityManager.isRunningInTestHarness() &amp;&amp;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5082                 !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5083     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5084 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5085     protected boolean hasRunFirstRunActivity() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5086         return mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5087     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5088 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5089     public boolean showFirstRunActivity() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5090         if (shouldRunFirstRunActivity() &amp;&amp;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5091                 hasFirstRunActivity()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5092             Intent firstRunIntent = getFirstRunActivity();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5093             if (firstRunIntent != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5094                 startActivity(firstRunIntent);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5095                 markFirstRunActivityShown();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5096                 return true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5097             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5098         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5099         return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5100     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5101 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5102     private void markFirstRunActivityShown() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5103         SharedPreferences.Editor editor = mSharedPrefs.edit();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5104         editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5105         editor.apply();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5106 </span>
5107 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="5108 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">5108 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
5109 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5110 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5111     public void dismissFirstRunCling(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5112         mLauncherClings.dismissFirstRunCling(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5113     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5114     public void dismissMigrationClingCopyApps(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5115         mLauncherClings.dismissMigrationClingCopyApps(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5116     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5117     public void dismissMigrationClingUseDefault(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5118         mLauncherClings.dismissMigrationClingUseDefault(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5119     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5120     public void dismissMigrationWorkspaceCling(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5121         mLauncherClings.dismissMigrationWorkspaceCling(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5122 </span>
5123 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
5124     }
5125 
5126 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5127 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5128     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5129      * To be overridden by subclasses to indicate that there is an in-activity full-screen intro</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5130      * screen that must be displayed and dismissed.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5131      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5132     protected boolean hasDismissableIntroScreen() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5133         return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5134     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5135 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5136     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5137      * Full screen intro screen to be shown and dismissed before the launcher can be used.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5138      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5139     protected View getIntroScreen() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5140         return null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5141     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5142 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5143     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5144      * To be overriden by subclasses to indicate whether the in-activity intro screen has been</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5145      * dismissed. This method is ignored if #hasDismissableIntroScreen returns false.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5146      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5147     private boolean shouldShowIntroScreen() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5148         return hasDismissableIntroScreen() &amp;&amp;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5149                 !mSharedPrefs.getBoolean(INTRO_SCREEN_DISMISSED, false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5150     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5151 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5152     protected void showIntroScreen() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5153         View introScreen = getIntroScreen();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5154         changeWallpaperVisiblity(false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5155         if (introScreen != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5156             mDragLayer.showOverlayView(introScreen);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5157         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5158 </span>
5159 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="5160 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">5160 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
5161 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5162 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5163     public void dismissWorkspaceCling(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5164         mLauncherClings.dismissWorkspaceCling(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5165 </span>
5166 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
5167     }
5168 
5169 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5170 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5171     public void dismissIntroScreen() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5172         markIntroScreenDismissed();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5173         if (showFirstRunActivity()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5174             // We delay hiding the intro view until the first run activity is showing. This</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5175             // avoids a blip.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5176             mWorkspace.postDelayed(new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5177                 @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5178                 public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5179                     mDragLayer.dismissOverlayView();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5180                     showFirstRunClings();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5181                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5182             }, ACTIVITY_START_DELAY);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5183         } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5184             mDragLayer.dismissOverlayView();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5185             showFirstRunClings();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5186         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5187         changeWallpaperVisiblity(true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5188     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5189 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5190     private void markIntroScreenDismissed() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5191         SharedPreferences.Editor editor = mSharedPrefs.edit();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5192         editor.putBoolean(INTRO_SCREEN_DISMISSED, true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5193         editor.apply();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5194     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5195 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5196     private void showFirstRunClings() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5197         // The two first run cling paths are mutually exclusive, if the launcher is preinstalled</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5198         // on the device, then we always show the first run cling experience (or if there is no</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5199         // launcher2). Otherwise, we prompt the user upon started for migration</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5200         LauncherClings launcherClings = new LauncherClings(this);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5201         if (launcherClings.shouldShowFirstRunOrMigrationClings()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5202             if (mModel.canMigrateFromOldLauncherDb(this)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5203                 launcherClings.showMigrationCling();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5204             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5205                 launcherClings.showLongPressCling(true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5206             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5207         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5208     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5209 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5210     void showWorkspaceSearchAndHotseat() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5211         if (mWorkspace != null) mWorkspace.setAlpha(1f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5212         if (mHotseat != null) mHotseat.setAlpha(1f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5213         if (mPageIndicators != null) mPageIndicators.setAlpha(1f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5214         if (mSearchDropTargetBar != null) mSearchDropTargetBar.showSearchBar(false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5215     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5216 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5217     void hideWorkspaceSearchAndHotseat() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5218         if (mWorkspace != null) mWorkspace.setAlpha(0f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5219         if (mHotseat != null) mHotseat.setAlpha(0f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5220         if (mPageIndicators != null) mPageIndicators.setAlpha(0f);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5221         if (mSearchDropTargetBar != null) mSearchDropTargetBar.hideSearchBar(false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">5222 </span>
5223 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="5224 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">5224 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
5225 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5226 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5227     public void dismissFolderCling(View v) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5228         mLauncherClings.dismissFolderCling(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">5229 </span>
5230 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
5231     }
5232 
5233     private boolean shouldRunFirstRunActivity() {
5234         return !ActivityManager.isRunningInTestHarness();
5235     }
5236 
5237     public void showFirstRunActivity() {
5238         if (shouldRunFirstRunActivity() &amp;&amp; hasFirstRunActivity()
5239                 &amp;&amp; !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false)) {
5240             Intent firstRunIntent = getFirstRunActivity();
5241             if (firstRunIntent != null) {
5242                 startActivity(firstRunIntent);
5243                 markFirstRunActivityShown();
5244             }
5245         }
5246     }
5247 
5248     private void markFirstRunActivityShown() {
5249         SharedPreferences.Editor editor = mSharedPrefs.edit();
5250         editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);
5251         editor.apply();
5252     }
5253 
5254     void showWorkspaceSearchAndHotseat() {
5255         mWorkspace.setAlpha(1f);
5256         mHotseat.setAlpha(1f);
5257         mPageIndicators.setAlpha(1f);
5258         mSearchDropTargetBar.showSearchBar(false);
5259     }
5260 
5261     void hideWorkspaceSearchAndHotseat() {
5262         mWorkspace.setAlpha(0f);
5263         mHotseat.setAlpha(0f);
5264         mPageIndicators.setAlpha(0f);
5265         mSearchDropTargetBar.hideSearchBar(false);
5266     }
5267 
5268 
5269     public ItemInfo createAppDragInfo(Intent appLaunchIntent) {
5270         // Called from search suggestion, not supported in other profiles.
5271         final UserHandleCompat myUser = UserHandleCompat.myUserHandle();
5272         LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
5273         LauncherActivityInfoCompat activityInfo = launcherApps.resolveActivity(appLaunchIntent,
5274                 myUser);
5275         if (activityInfo == null) {
5276             return null;
5277         }
5278         return new AppInfo(this, activityInfo, myUser, mIconCache, null);
5279     }
5280 
5281     public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
5282             Bitmap icon) {
5283         // Called from search suggestion, not supported in other profiles.
5284         return createShortcutDragInfo(shortcutIntent, caption, icon,
5285                 UserHandleCompat.myUserHandle());
5286     }
5287 
5288     public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
5289             Bitmap icon, UserHandleCompat user) {
5290         UserManagerCompat userManager = UserManagerCompat.getInstance(this);
5291         CharSequence contentDescription = userManager.getBadgedLabelForUser(caption, user);
5292         return new ShortcutInfo(shortcutIntent, caption, contentDescription, icon, user);
5293     }
5294 
5295     protected void moveWorkspaceToDefaultScreen() {
5296         mWorkspace.moveToDefaultScreen(false);
5297     }
5298 
5299     public void startDrag(View dragView, ItemInfo dragInfo, DragSource source) {
5300         dragView.setTag(dragInfo);
5301         mWorkspace.onExternalDragStartedWithItem(dragView);
5302         mWorkspace.beginExternalDragShared(dragView, source);
5303     }
5304 
5305     @Override
5306     public void onPageSwitch(View newPage, int newPageIndex) {
5307     }
5308 
5309     /**
5310      * Prints out out state for debugging.
5311      */
5312     public void dumpState() {
5313         Log.d(TAG, &quot;BEGIN launcher3 dump state for launcher &quot; + this);
5314         Log.d(TAG, &quot;mSavedState=&quot; + mSavedState);
5315         Log.d(TAG, &quot;mWorkspaceLoading=&quot; + mWorkspaceLoading);
5316         Log.d(TAG, &quot;mRestoring=&quot; + mRestoring);
5317         Log.d(TAG, &quot;mWaitingForResult=&quot; + mWaitingForResult);
5318         Log.d(TAG, &quot;mSavedInstanceState=&quot; + mSavedInstanceState);
5319         Log.d(TAG, &quot;sFolders.size=&quot; + sFolders.size());
5320         mModel.dumpState();
5321 
5322         if (mAppsCustomizeContent != null) {
5323             mAppsCustomizeContent.dumpState();
5324         }
5325         Log.d(TAG, &quot;END launcher3 dump state&quot;);
5326     }
5327 
5328     @Override
5329     public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
5330         super.dump(prefix, fd, writer, args);
5331         synchronized (sDumpLogs) {
5332             writer.println(&quot; &quot;);
5333             writer.println(&quot;Debug logs: &quot;);
5334             for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5335                 writer.println(&quot;  &quot; + sDumpLogs.get(i));
5336             }
5337         }
5338     }
5339 
5340     public static void dumpDebugLogsToConsole() {
5341         if (DEBUG_DUMP_LOG) {
5342             synchronized (sDumpLogs) {
5343                 Log.d(TAG, &quot;&quot;);
5344                 Log.d(TAG, &quot;*********************&quot;);
5345                 Log.d(TAG, &quot;Launcher debug logs: &quot;);
5346                 for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5347                     Log.d(TAG, &quot;  &quot; + sDumpLogs.get(i));
5348                 }
5349                 Log.d(TAG, &quot;*********************&quot;);
5350                 Log.d(TAG, &quot;&quot;);
5351             }
5352         }
5353     }
5354 
5355     public static void addDumpLog(String tag, String log, boolean debugLog) {
5356         addDumpLog(tag, log, null, debugLog);
5357     }
5358 
5359     public static void addDumpLog(String tag, String log, Exception e, boolean debugLog) {
5360         if (debugLog) {
5361             if (e != null) {
5362                 Log.d(tag, log, e);
5363             } else {
5364                 Log.d(tag, log);
5365             }
5366         }
5367         if (DEBUG_DUMP_LOG) {
5368             sDateStamp.setTime(System.currentTimeMillis());
5369             synchronized (sDumpLogs) {
5370                 sDumpLogs.add(sDateFormat.format(sDateStamp) + &quot;: &quot; + tag + &quot;, &quot; + log
5371                     + (e == null ? &quot;&quot; : (&quot;, Exception: &quot; + e)));
5372             }
5373         }
5374     }
5375 
5376     public void dumpLogsToLocalData() {
5377         if (DEBUG_DUMP_LOG) {
5378             new AsyncTask&lt;Void, Void, Void&gt;() {
5379                 public Void doInBackground(Void ... args) {
5380                     boolean success = false;
5381                     sDateStamp.setTime(sRunStart);
5382                     String FILENAME = sDateStamp.getMonth() + &quot;-&quot;
5383                             + sDateStamp.getDay() + &quot;_&quot;
5384                             + sDateStamp.getHours() + &quot;-&quot;
5385                             + sDateStamp.getMinutes() + &quot;_&quot;
5386                             + sDateStamp.getSeconds() + &quot;.txt&quot;;
5387 
5388                     FileOutputStream fos = null;
5389                     File outFile = null;
5390                     try {
5391                         outFile = new File(getFilesDir(), FILENAME);
5392                         outFile.createNewFile();
5393                         fos = new FileOutputStream(outFile);
5394                     } catch (Exception e) {
5395                         e.printStackTrace();
5396                     }
5397                     if (fos != null) {
5398                         PrintWriter writer = new PrintWriter(fos);
5399 
5400                         writer.println(&quot; &quot;);
5401                         writer.println(&quot;Debug logs: &quot;);
5402                         synchronized (sDumpLogs) {
5403                             for (int i = 0; i &lt; sDumpLogs.size(); i++) {
5404                                 writer.println(&quot;  &quot; + sDumpLogs.get(i));
5405                             }
5406                         }
5407                         writer.close();
5408                     }
5409                     try {
5410                         if (fos != null) {
5411                             fos.close();
5412                             success = true;
5413                         }
5414                     } catch (IOException e) {
5415                         e.printStackTrace();
5416                     }
5417                     return null;
5418                 }
5419             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
5420         }
5421     }
5422 }
5423 
5424 interface LauncherTransitionable {
5425     public abstract View getContent();
5426 
5427     public abstract void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace);
5428 
5429     public abstract void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace);
5430 
5431     public abstract void onLauncherTransitionStep(Launcher l, float t);
5432 
5433     public abstract void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace);
5434 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  
   2  /*
   3   * Copyright (C) 2008 The Android Open Source Project
   4   *
   5   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   6   * you may not use this file except in compliance with the License.
   7   * You may obtain a copy of the License at
   8   *
   9   *      http://www.apache.org/licenses/LICENSE-2.0
  10   *
  11   * Unless required by applicable law or agreed to in writing, software
  12   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  13   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  14   * See the License for the specific language governing permissions and
  15   * limitations under the License.
  16   */
  17  
  18  package com.android.launcher3;
  19  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -import android.accounts.Account;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import android.accounts.AccountManager;</span>
  22  import android.animation.Animator;
  23  import android.animation.AnimatorListenerAdapter;
  24  import android.animation.AnimatorSet;
  25  import android.animation.ObjectAnimator;
  26  import android.animation.PropertyValuesHolder;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import android.animation.TimeInterpolator;</span>
  28  import android.animation.ValueAnimator;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import android.animation.ValueAnimator.AnimatorUpdateListener;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import android.annotation.TargetApi;</span>
  31  import android.app.Activity;
  32  import android.app.ActivityManager;
  33  import android.app.ActivityOptions;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import android.app.AlertDialog;</span>
  35  import android.app.SearchManager;
  36  import android.appwidget.AppWidgetHostView;
  37  import android.appwidget.AppWidgetManager;
  38  import android.appwidget.AppWidgetProviderInfo;
  39  import android.content.ActivityNotFoundException;
  40  import android.content.BroadcastReceiver;
  41  import android.content.ComponentCallbacks2;
  42  import android.content.ComponentName;
  43  import android.content.ContentResolver;
  44  import android.content.Context;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import android.content.DialogInterface;</span>
  46  import android.content.Intent;
  47  import android.content.IntentFilter;
  48  import android.content.SharedPreferences;
  49  import android.content.pm.ActivityInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import android.content.pm.ApplicationInfo;</span>
  51  import android.content.pm.PackageManager;
  52  import android.content.pm.PackageManager.NameNotFoundException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import android.content.pm.ResolveInfo;</span>
  54  import android.content.res.Configuration;
  55  import android.content.res.Resources;
  56  import android.database.ContentObserver;
  57  import android.graphics.Bitmap;
  58  import android.graphics.Canvas;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +import android.graphics.Color;</span>
  60  import android.graphics.Point;
  61  import android.graphics.PorterDuff;
  62  import android.graphics.Rect;
  63  import android.graphics.drawable.Drawable;
  64  import android.net.Uri;
  65  import android.os.AsyncTask;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  66 +import android.os.Build;</span>
  67  import android.os.Bundle;
  68  import android.os.Environment;
  69  import android.os.Handler;
  70  import android.os.Message;
  71  import android.os.StrictMode;
  72  import android.os.SystemClock;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -import android.provider.Settings;</span>
  74  import android.speech.RecognizerIntent;
  75  import android.text.Selection;
  76  import android.text.SpannableStringBuilder;
  77  import android.text.TextUtils;
  78  import android.text.method.TextKeyListener;
  79  import android.util.DisplayMetrics;
  80  import android.util.Log;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +import android.view.ContextThemeWrapper;</span>
  82  import android.view.Display;
  83  import android.view.Gravity;
  84  import android.view.HapticFeedbackConstants;
  85  import android.view.KeyEvent;
  86  import android.view.LayoutInflater;
  87  import android.view.Menu;
  88  import android.view.MotionEvent;
  89  import android.view.Surface;
  90  import android.view.View;
  91  import android.view.View.OnClickListener;
  92  import android.view.View.OnLongClickListener;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +import android.view.ViewAnimationUtils;</span>
  94  import android.view.ViewGroup;
  95  import android.view.ViewTreeObserver;
  96  import android.view.ViewTreeObserver.OnGlobalLayoutListener;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +import android.view.Window;</span>
  98  import android.view.WindowManager;
  99  import android.view.accessibility.AccessibilityEvent;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -import android.view.accessibility.AccessibilityManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -import android.view.animation.AccelerateDecelerateInterpolator;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +import android.view.animation.AccelerateInterpolator;</span>
 103  import android.view.animation.DecelerateInterpolator;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +import android.view.animation.Interpolator;</span>
 105  import android.view.inputmethod.InputMethodManager;
 106  import android.widget.Advanceable;
 107  import android.widget.FrameLayout;
 108  import android.widget.ImageView;
 109  import android.widget.TextView;
 110  import android.widget.Toast;
 111  
 112  import com.android.launcher3.DropTarget.DragObject;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +import com.android.launcher3.PagedView.PageSwitchListener;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +import com.android.launcher3.compat.AppWidgetManagerCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +import com.android.launcher3.compat.LauncherActivityInfoCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +import com.android.launcher3.compat.LauncherAppsCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +import com.android.launcher3.compat.PackageInstallerCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +import com.android.launcher3.compat.UserHandleCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +import com.android.launcher3.compat.UserManagerCompat;</span>
 121  
 122  import java.io.DataInputStream;
 123  import java.io.DataOutputStream;
 124  import java.io.File;
 125  import java.io.FileDescriptor;
 126  import java.io.FileNotFoundException;
 127  import java.io.FileOutputStream;
 128  import java.io.IOException;
 129  import java.io.PrintWriter;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +import java.lang.reflect.Field;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +import java.lang.reflect.InvocationTargetException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +import java.lang.reflect.Method;</span>
 133  import java.text.DateFormat;
 134  import java.util.ArrayList;
 135  import java.util.Collection;
 136  import java.util.Date;
 137  import java.util.HashMap;
 138  import java.util.List;
 139  import java.util.concurrent.atomic.AtomicInteger;
 140  

 141  /**
 142   * Default launcher application.
 143   */
 144  public class Launcher extends Activity
 145          implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -                   View.OnTouchListener {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +                   View.OnTouchListener, PageSwitchListener, LauncherProviderChangeListener {</span>
 148      static final String TAG = &quot;Launcher&quot;;
 149      static final boolean LOGD = false;
 150  
 151      static final boolean PROFILE_STARTUP = false;
 152      static final boolean DEBUG_WIDGETS = false;
 153      static final boolean DEBUG_STRICT_MODE = false;
 154      static final boolean DEBUG_RESUME_TIME = false;
 155      static final boolean DEBUG_DUMP_LOG = false;
 156  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +    static final boolean ENABLE_DEBUG_INTENTS = false; // allow DebugIntents to run</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +</span>
 159      private static final int REQUEST_CREATE_SHORTCUT = 1;
 160      private static final int REQUEST_CREATE_APPWIDGET = 5;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -    private static final int REQUEST_PICK_APPLICATION = 6;</span>
 162      private static final int REQUEST_PICK_SHORTCUT = 7;
 163      private static final int REQUEST_PICK_APPWIDGET = 9;
 164      private static final int REQUEST_PICK_WALLPAPER = 10;
 165  
 166      private static final int REQUEST_BIND_APPWIDGET = 11;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +    private static final int REQUEST_RECONFIGURE_APPWIDGET = 12;</span>
 168  
 169      /**
 170       * IntentStarter uses request codes starting with this. This must be greater than all activity
 171       * request codes used internally.
 172       */
 173      protected static final int REQUEST_LAST = 100;
 174  
 175      static final String EXTRA_SHORTCUT_DUPLICATE = &quot;duplicate&quot;;
 176  
 177      static final int SCREEN_COUNT = 5;
 178      static final int DEFAULT_SCREEN = 2;
 179  
 180      private static final String PREFERENCES = &quot;launcher.preferences&quot;;
 181      // To turn on these properties, type
 182      // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
 183      static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
 184      static final String DUMP_STATE_PROPERTY = &quot;launcher_dump_state&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +    static final String DISABLE_ALL_APPS_PROPERTY = &quot;launcher_noallapps&quot;;</span>
 186  
 187      // The Intent extra that defines whether to ignore the launch animation
 188      static final String INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION =
 189              &quot;com.android.launcher3.intent.extra.shortcut.INGORE_LAUNCH_ANIMATION&quot;;
 190  
 191      // Type: int
 192      private static final String RUNTIME_STATE_CURRENT_SCREEN = &quot;launcher.current_screen&quot;;
 193      // Type: int
 194      private static final String RUNTIME_STATE = &quot;launcher.state&quot;;
 195      // Type: int
 196      private static final String RUNTIME_STATE_PENDING_ADD_CONTAINER = &quot;launcher.add_container&quot;;
 197      // Type: int
 198      private static final String RUNTIME_STATE_PENDING_ADD_SCREEN = &quot;launcher.add_screen&quot;;
 199      // Type: int
 200      private static final String RUNTIME_STATE_PENDING_ADD_CELL_X = &quot;launcher.add_cell_x&quot;;
 201      // Type: int
 202      private static final String RUNTIME_STATE_PENDING_ADD_CELL_Y = &quot;launcher.add_cell_y&quot;;
 203      // Type: boolean
 204      private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME = &quot;launcher.rename_folder&quot;;
 205      // Type: long
 206      private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME_ID = &quot;launcher.rename_folder_id&quot;;
 207      // Type: int
 208      private static final String RUNTIME_STATE_PENDING_ADD_SPAN_X = &quot;launcher.add_span_x&quot;;
 209      // Type: int
 210      private static final String RUNTIME_STATE_PENDING_ADD_SPAN_Y = &quot;launcher.add_span_y&quot;;
 211      // Type: parcelable
 212      private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_INFO = &quot;launcher.add_widget_info&quot;;
 213      // Type: parcelable
 214      private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_ID = &quot;launcher.add_widget_id&quot;;
 215      // Type: int[]
 216      private static final String RUNTIME_STATE_VIEW_IDS = &quot;launcher.view_ids&quot;;
 217  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +    static final String INTRO_SCREEN_DISMISSED = &quot;launcher.intro_screen_dismissed&quot;;</span>
 220      static final String FIRST_RUN_ACTIVITY_DISPLAYED = &quot;launcher.first_run_activity_displayed&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +    static final String FIRST_LOAD_COMPLETE = &quot;launcher.first_load_complete&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +    static final String ACTION_FIRST_LOAD_COMPLETE =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +            &quot;com.android.launcher3.action.FIRST_LOAD_COMPLETE&quot;;</span>
 225  
 226      private static final String TOOLBAR_ICON_METADATA_NAME = &quot;com.android.launcher.toolbar_icon&quot;;
 227      private static final String TOOLBAR_SEARCH_ICON_METADATA_NAME =
 228              &quot;com.android.launcher.toolbar_search_icon&quot;;
 229      private static final String TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME =
 230              &quot;com.android.launcher.toolbar_voice_search_icon&quot;;
 231  
 232      public static final String SHOW_WEIGHT_WATCHER = &quot;debug.show_mem&quot;;
 233      public static final boolean SHOW_WEIGHT_WATCHER_DEFAULT = false;
 234  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +    public static final String USER_HAS_MIGRATED = &quot;launcher.user_migrated_from_old_data&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +</span>
 237      /** The different states that Launcher can be in. */
 238      private enum State { NONE, WORKSPACE, APPS_CUSTOMIZE, APPS_CUSTOMIZE_SPRING_LOADED };
 239      private State mState = State.WORKSPACE;
 240      private AnimatorSet mStateAnimation;
 241  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +    private boolean mIsSafeModeEnabled;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +</span>
 244      static final int APPWIDGET_HOST_ID = 1024;
 245      public static final int EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT = 300;
 246      private static final int ON_ACTIVITY_RESULT_ANIMATION_DELAY = 500;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -    private static final int SHOW_CLING_DURATION = 250;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 248 -    private static final int DISMISS_CLING_DURATION = 200;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +    private static final int ACTIVITY_START_DELAY = 1000;</span>
 250  
 251      private static final Object sLock = new Object();
 252      private static int sScreen = DEFAULT_SCREEN;
 253  
 254      private HashMap&lt;Integer, Integer&gt; mItemIdToViewId = new HashMap&lt;Integer, Integer&gt;();
 255      private static final AtomicInteger sNextGeneratedId = new AtomicInteger(1);
 256  
 257      // How long to wait before the new-shortcut animation automatically pans the workspace
 258      private static int NEW_APPS_PAGE_MOVE_DELAY = 500;
 259      private static int NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS = 5;
 260      private static int NEW_APPS_ANIMATION_DELAY = 500;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +    private static final int SINGLE_FRAME_DELAY = 16;</span>
 262  
 263      private final BroadcastReceiver mCloseSystemDialogsReceiver
 264              = new CloseSystemDialogsIntentReceiver();
 265      private final ContentObserver mWidgetObserver = new AppWidgetResetObserver();
 266  
 267      private LayoutInflater mInflater;
 268  
 269      private Workspace mWorkspace;
 270      private View mLauncherView;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +    private View mPageIndicators;</span>
 272      private DragLayer mDragLayer;
 273      private DragController mDragController;
 274      private View mWeightWatcher;

 275  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 276 -    private AppWidgetManager mAppWidgetManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +    private AppWidgetManagerCompat mAppWidgetManager;</span>
 278      private LauncherAppWidgetHost mAppWidgetHost;
 279  
 280      private ItemInfo mPendingAddInfo = new ItemInfo();
 281      private AppWidgetProviderInfo mPendingAddWidgetInfo;
 282      private int mPendingAddWidgetId = -1;
 283  
 284      private int[] mTmpAddItemCellCoordinates = new int[2];
 285  
 286      private FolderInfo mFolderInfo;
 287  
 288      private Hotseat mHotseat;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 289 -    private View mOverviewPanel;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +    private ViewGroup mOverviewPanel;</span>
 291  
 292      private View mAllAppsButton;
 293  
 294      private SearchDropTargetBar mSearchDropTargetBar;
 295      private AppsCustomizeTabHost mAppsCustomizeTabHost;
 296      private AppsCustomizePagedView mAppsCustomizeContent;
 297      private boolean mAutoAdvanceRunning = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 298 -    private View mQsbBar;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 299 +    private View mQsb;</span>
 300  
 301      private Bundle mSavedState;
 302      // We set the state in both onCreate and then onNewIntent in some cases, which causes both
 303      // scroll issues (because the workspace may not have been measured yet) and extra work.
 304      // Instead, just save the state that we need to restore Launcher to, and commit it in onResume.
 305      private State mOnResumeState = State.NONE;
 306  
 307      private SpannableStringBuilder mDefaultKeySsb = null;
 308  
 309      private boolean mWorkspaceLoading = true;
 310  
 311      private boolean mPaused = true;
 312      private boolean mRestoring;
 313      private boolean mWaitingForResult;
 314      private boolean mOnResumeNeedsLoad;
 315  
 316      private ArrayList&lt;Runnable&gt; mBindOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 317      private ArrayList&lt;Runnable&gt; mOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 318 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 319 -    // Keep track of whether the user has left launcher</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 320 -    private static boolean sPausedFromUserAction = false;</span>
 321  
 322      private Bundle mSavedInstanceState;
 323  
 324      private LauncherModel mModel;
 325      private IconCache mIconCache;
 326      private boolean mUserPresent = true;
 327      private boolean mVisible = false;
 328      private boolean mHasFocus = false;
 329      private boolean mAttached = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 330 -    private static final boolean DISABLE_CLINGS = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 331 -    private static final boolean DISABLE_CUSTOM_CLINGS = true;</span>
 332  
 333      private static LocaleConfiguration sLocaleConfiguration = null;
 334  
 335      private static HashMap&lt;Long, FolderInfo&gt; sFolders = new HashMap&lt;Long, FolderInfo&gt;();
 336  
 337      private View.OnTouchListener mHapticFeedbackTouchListener;
 338  
 339      // Related to the auto-advancing of widgets
 340      private final int ADVANCE_MSG = 1;
 341      private final int mAdvanceInterval = 20000;
 342      private final int mAdvanceStagger = 250;
 343      private long mAutoAdvanceSentTime;
 344      private long mAutoAdvanceTimeLeft = -1;
 345      private HashMap&lt;View, AppWidgetProviderInfo&gt; mWidgetsToAdvance =
 346          new HashMap&lt;View, AppWidgetProviderInfo&gt;();
 347  
 348      // Determines how long to wait after a rotation before restoring the screen orientation to
 349      // match the sensor state.
 350      private final int mRestoreScreenOrientationDelay = 500;
 351  
 352      // External icons saved in case of resource changes, orientation, etc.
 353      private static Drawable.ConstantState[] sGlobalSearchIcon = new Drawable.ConstantState[2];
 354      private static Drawable.ConstantState[] sVoiceSearchIcon = new Drawable.ConstantState[2];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 355 -    private static Drawable.ConstantState[] sAppMarketIcon = new Drawable.ConstantState[2];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 356 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -    private Intent mAppMarketIntent = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 358 -    private static final boolean DISABLE_MARKET_BUTTON = true;</span>
 359  
 360      private Drawable mWorkspaceBackgroundDrawable;
 361  
 362      private final ArrayList&lt;Integer&gt; mSynchronouslyBoundPages = new ArrayList&lt;Integer&gt;();
 363      private static final boolean DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE = false;
 364  
 365      static final ArrayList&lt;String&gt; sDumpLogs = new ArrayList&lt;String&gt;();
 366      static Date sDateStamp = new Date();
 367      static DateFormat sDateFormat =
 368              DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
 369      static long sRunStart = System.currentTimeMillis();
 370      static final String CORRUPTION_EMAIL_SENT_KEY = &quot;corruptionEmailSent&quot;;
 371  
 372      // We only want to get the SharedPreferences once since it does an FS stat each time we get
 373      // it from the context.
 374      private SharedPreferences mSharedPrefs;
 375  
 376      private static ArrayList&lt;ComponentName&gt; mIntentsOnWorkspaceFromUpgradePath = null;
 377  
 378      // Holds the page that we need to animate to, and the icon views that we need to animate up
 379      // when we scroll to that page on resume.
 380      private ImageView mFolderIconImageView;
 381      private Bitmap mFolderIconBitmap;
 382      private Canvas mFolderIconCanvas;
 383      private Rect mRectForFolderAnimation = new Rect();
 384  
 385      private BubbleTextView mWaitingForResume;
 386  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 387 -    private HideFromAccessibilityHelper mHideFromAccessibilityHelper</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 388 -        = new HideFromAccessibilityHelper();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -</span>
 390      private Runnable mBuildLayersRunnable = new Runnable() {
 391          public void run() {
 392              if (mWorkspace != null) {
 393                  mWorkspace.buildPageHardwareLayers();
 394              }
 395          }
 396      };
 397  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 398 -    private static ArrayList&lt;PendingAddArguments&gt; sPendingAddList</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 399 -            = new ArrayList&lt;PendingAddArguments&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 400 +    private static PendingAddArguments sPendingAddItem;</span>
 401  
 402      public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
 403  
 404      private static class PendingAddArguments {
 405          int requestCode;
 406          Intent intent;
 407          long container;
 408          long screenId;
 409          int cellX;
 410          int cellY;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 411 +        int appWidgetId;</span>
 412      }
 413  
 414      private Stats mStats;
 415  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 416 -    private static boolean isPropertyEnabled(String propertyName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 417 +    FocusIndicatorView mFocusHandler;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +    static boolean isPropertyEnabled(String propertyName) {</span>
 420          return Log.isLoggable(propertyName, Log.VERBOSE);
 421      }
 422  
 423      @Override
 424      protected void onCreate(Bundle savedInstanceState) {
 425          if (DEBUG_STRICT_MODE) {
 426              StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
 427                      .detectDiskReads()
 428                      .detectDiskWrites()
 429                      .detectNetwork()   // or .detectAll() for all detectable problems
 430                      .penaltyLog()
 431                      .build());
 432              StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
 433                      .detectLeakedSqlLiteObjects()
 434                      .detectLeakedClosableObjects()
 435                      .penaltyLog()
 436                      .penaltyDeath()
 437                      .build());
 438          }
 439  
 440          super.onCreate(savedInstanceState);
 441  
 442          LauncherAppState.setApplicationContext(getApplicationContext());
 443          LauncherAppState app = LauncherAppState.getInstance();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 444 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 445 +        LauncherAppState.getLauncherProvider().setLauncherProviderChangeListener(this);</span>
 446          // Determine the dynamic grid properties
 447          Point smallestSize = new Point();
 448          Point largestSize = new Point();
 449          Point realSize = new Point();
 450          Display display = getWindowManager().getDefaultDisplay();
 451          display.getCurrentSizeRange(smallestSize, largestSize);
 452          display.getRealSize(realSize);
 453          DisplayMetrics dm = new DisplayMetrics();
 454          display.getMetrics(dm);
 455  
 456          // Lazy-initialize the dynamic grid
 457          DeviceProfile grid = app.initDynamicGrid(this,
 458                  Math.min(smallestSize.x, smallestSize.y),
 459                  Math.min(largestSize.x, largestSize.y),
 460                  realSize.x, realSize.y,
 461                  dm.widthPixels, dm.heightPixels);
 462  
 463          // the LauncherApplication should call this, but in case of Instrumentation it might not be present yet
 464          mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(),
 465                  Context.MODE_PRIVATE);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 466 +        mIsSafeModeEnabled = getPackageManager().isSafeMode();</span>
 467          mModel = app.setLauncher(this);
 468          mIconCache = app.getIconCache();
 469          mIconCache.flushInvalidIcons(grid);
 470          mDragController = new DragController(this);

 471          mInflater = getLayoutInflater();
 472  
 473          mStats = new Stats(this);
 474  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 475 -        mAppWidgetManager = AppWidgetManager.getInstance(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 476 +        mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);</span>
 477  
 478          mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
 479          mAppWidgetHost.startListening();
 480  
 481          // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
 482          // this also ensures that any synchronous binding below doesn&#x27;t re-trigger another
 483          // LauncherModel load.
 484          mPaused = false;
 485  
 486          if (PROFILE_STARTUP) {
 487              android.os.Debug.startMethodTracing(
 488                      Environment.getExternalStorageDirectory() + &quot;/launcher&quot;);
 489          }
 490  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 491 -</span>
 492          checkForLocaleChange();
 493          setContentView(R.layout.launcher);
 494  
 495          setupViews();
 496          grid.layout(this);
 497  
 498          registerContentObservers();
 499  
 500          lockAllApps();
 501  
 502          mSavedState = savedInstanceState;
 503          restoreState(mSavedState);
 504  
 505          if (PROFILE_STARTUP) {
 506              android.os.Debug.stopMethodTracing();
 507          }
 508  
 509          if (!mRestoring) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 510 -            if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE || sPausedFromUserAction) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 511 +            if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {</span>
 512                  // If the user leaves launcher, then we should just load items asynchronously when
 513                  // they return.
 514                  mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
 515              } else {
 516                  // We only load the page synchronously if the user rotates (or triggers a
 517                  // configuration change) while launcher is in the foreground
 518                  mModel.startLoader(true, mWorkspace.getRestorePage());
 519              }
 520          }
 521  
 522          // For handling default keys
 523          mDefaultKeySsb = new SpannableStringBuilder();
 524          Selection.setSelection(mDefaultKeySsb, 0);
 525  
 526          IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
 527          registerReceiver(mCloseSystemDialogsReceiver, filter);
 528  
 529          updateGlobalIcons();
 530  
 531          // On large interfaces, we want the screen to auto-rotate based on the current orientation
 532          unlockScreenOrientation(true);
 533  



<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 534 -        showFirstRunActivity();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 535 -        showFirstRunCling();</span>









<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 536 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 537 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 538 -    protected void onUserLeaveHint() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 539 -        super.onUserLeaveHint();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 540 -        sPausedFromUserAction = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 541 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 542 +        if (shouldShowIntroScreen()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 543 +            showIntroScreen();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 544 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 545 +            showFirstRunActivity();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 546 +            showFirstRunClings();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 547 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 548 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 550 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 551 +    public void onLauncherProviderChange() { }</span>
 552  
 553      /** To be overriden by subclasses to hint to Launcher that we have custom content */
 554      protected boolean hasCustomContentToLeft() {
 555          return false;
 556      }
 557  
 558      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -     * To be overridden by subclasses to create the custom content and call</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 560 +     * To be overridden by subclasses to populate the custom content container and call</span>
 561       * {@link #addToCustomContentPage}. This will only be invoked if
 562       * {@link #hasCustomContentToLeft()} is {@code true}.
 563       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -    protected void addCustomContentToLeft() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -     * To be overridden by subclasses to indicate that there is an activity to launch</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -     * before showing the standard launcher experience.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -    protected boolean hasFirstRunActivity() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -     * To be overridden by subclasses to launch any first run activity</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -    protected Intent getFirstRunActivity() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 579 -        return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +    protected void populateCustomContentContainer() {</span>
 581      }
 582  
 583      /**
 584       * Invoked by subclasses to signal a change to the {@link #addCustomContentToLeft} value to
 585       * ensure the custom content page is added or removed if necessary.
 586       */
 587      protected void invalidateHasCustomContentToLeft() {
 588          if (mWorkspace == null || mWorkspace.getScreenOrder().isEmpty()) {
 589              // Not bound yet, wait for bindScreens to be called.
 590              return;
 591          }
 592  
 593          if (!mWorkspace.hasCustomContent() &amp;&amp; hasCustomContentToLeft()) {
 594              // Create the custom content page and call the subclass to populate it.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 595 -            mWorkspace.createCustomContentPage();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 596 -            addCustomContentToLeft();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +            mWorkspace.createCustomContentContainer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +            populateCustomContentContainer();</span>
 599          } else if (mWorkspace.hasCustomContent() &amp;&amp; !hasCustomContentToLeft()) {
 600              mWorkspace.removeCustomContentPage();
 601          }
 602      }
 603  
 604      private void updateGlobalIcons() {
 605          boolean searchVisible = false;
 606          boolean voiceVisible = false;
 607          // If we have a saved version of these external icons, we load them up immediately
 608          int coi = getCurrentOrientationIndexForGlobalIcons();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 609 -        if (sGlobalSearchIcon[coi] == null || sVoiceSearchIcon[coi] == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 610 -                sAppMarketIcon[coi] == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 611 -            if (!DISABLE_MARKET_BUTTON) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 612 -                updateAppMarketIcon();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 613 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 614 +        if (sGlobalSearchIcon[coi] == null || sVoiceSearchIcon[coi] == null) {</span>
 615              searchVisible = updateGlobalSearchIcon();
 616              voiceVisible = updateVoiceSearchIcon(searchVisible);
 617          }
 618          if (sGlobalSearchIcon[coi] != null) {
 619               updateGlobalSearchIcon(sGlobalSearchIcon[coi]);
 620               searchVisible = true;
 621          }
 622          if (sVoiceSearchIcon[coi] != null) {
 623              updateVoiceSearchIcon(sVoiceSearchIcon[coi]);
 624              voiceVisible = true;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -        if (!DISABLE_MARKET_BUTTON &amp;&amp; sAppMarketIcon[coi] != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -            updateAppMarketIcon(sAppMarketIcon[coi]);</span>
 628          }
 629          if (mSearchDropTargetBar != null) {
 630              mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
 631          }
 632      }
 633  
 634      private void checkForLocaleChange() {
 635          if (sLocaleConfiguration == null) {
 636              new AsyncTask&lt;Void, Void, LocaleConfiguration&gt;() {
 637                  @Override
 638                  protected LocaleConfiguration doInBackground(Void... unused) {
 639                      LocaleConfiguration localeConfiguration = new LocaleConfiguration();
 640                      readConfiguration(Launcher.this, localeConfiguration);
 641                      return localeConfiguration;
 642                  }
 643  
 644                  @Override
 645                  protected void onPostExecute(LocaleConfiguration result) {
 646                      sLocaleConfiguration = result;
 647                      checkForLocaleChange();  // recursive, but now with a locale configuration
 648                  }
 649              }.execute();
 650              return;
 651          }
 652  
 653          final Configuration configuration = getResources().getConfiguration();
 654  
 655          final String previousLocale = sLocaleConfiguration.locale;
 656          final String locale = configuration.locale.toString();
 657  
 658          final int previousMcc = sLocaleConfiguration.mcc;
 659          final int mcc = configuration.mcc;
 660  
 661          final int previousMnc = sLocaleConfiguration.mnc;
 662          final int mnc = configuration.mnc;
 663  
 664          boolean localeChanged = !locale.equals(previousLocale) || mcc != previousMcc || mnc != previousMnc;
 665  
 666          if (localeChanged) {
 667              sLocaleConfiguration.locale = locale;
 668              sLocaleConfiguration.mcc = mcc;
 669              sLocaleConfiguration.mnc = mnc;
 670  
 671              mIconCache.flush();
 672  
 673              final LocaleConfiguration localeConfiguration = sLocaleConfiguration;
 674              new AsyncTask&lt;Void, Void, Void&gt;() {
 675                  public Void doInBackground(Void ... args) {
 676                      writeConfiguration(Launcher.this, localeConfiguration);
 677                      return null;
 678                  }
 679              }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 680          }
 681      }
 682  
 683      private static class LocaleConfiguration {
 684          public String locale;
 685          public int mcc = -1;
 686          public int mnc = -1;
 687      }
 688  
 689      private static void readConfiguration(Context context, LocaleConfiguration configuration) {
 690          DataInputStream in = null;
 691          try {
 692              in = new DataInputStream(context.openFileInput(PREFERENCES));
 693              configuration.locale = in.readUTF();
 694              configuration.mcc = in.readInt();
 695              configuration.mnc = in.readInt();
 696          } catch (FileNotFoundException e) {
 697              // Ignore
 698          } catch (IOException e) {
 699              // Ignore
 700          } finally {
 701              if (in != null) {
 702                  try {
 703                      in.close();
 704                  } catch (IOException e) {
 705                      // Ignore
 706                  }
 707              }
 708          }
 709      }
 710  
 711      private static void writeConfiguration(Context context, LocaleConfiguration configuration) {
 712          DataOutputStream out = null;
 713          try {
 714              out = new DataOutputStream(context.openFileOutput(PREFERENCES, MODE_PRIVATE));
 715              out.writeUTF(configuration.locale);
 716              out.writeInt(configuration.mcc);
 717              out.writeInt(configuration.mnc);
 718              out.flush();
 719          } catch (FileNotFoundException e) {
 720              // Ignore
 721          } catch (IOException e) {
 722              //noinspection ResultOfMethodCallIgnored
 723              context.getFileStreamPath(PREFERENCES).delete();
 724          } finally {
 725              if (out != null) {
 726                  try {
 727                      out.close();
 728                  } catch (IOException e) {
 729                      // Ignore
 730                  }
 731              }
 732          }
 733      }
 734  
 735      public Stats getStats() {
 736          return mStats;
 737      }
 738  
 739      public LayoutInflater getInflater() {
 740          return mInflater;
 741      }
 742  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 743 -    public DragLayer getDragLayer() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 744 -        return mDragLayer;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 745 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 746 -</span>
 747      boolean isDraggingEnabled() {
 748          // We prevent dragging when we are loading the workspace as it is possible to pick up a view
 749          // that is subsequently removed from the workspace in startBinding().
 750          return !mModel.isLoadingWorkspace();
 751      }
 752  
 753      static int getScreen() {
 754          synchronized (sLock) {
 755              return sScreen;
 756          }
 757      }
 758  
 759      static void setScreen(int screen) {
 760          synchronized (sLock) {
 761              sScreen = screen;
 762          }
 763      }
 764  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 765 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 766 -     * Copied from View -- the View version of the method isn&#x27;t called</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 767 -     * anywhere else in our process and only exists for API level 17+,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 768 -     * so it&#x27;s ok to keep our own version with no API requirement.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 769 -     */</span>
 770      public static int generateViewId() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 771 -        for (;;) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 772 -            final int result = sNextGeneratedId.get();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 773 -            // aapt-generated IDs have the high byte nonzero; clamp to the range under that.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 774 -            int newValue = result + 1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 775 -            if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 776 -            if (sNextGeneratedId.compareAndSet(result, newValue)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 777 -                return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 778 +        if (Build.VERSION.SDK_INT &gt;= 17) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 779 +            return View.generateViewId();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 780 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 781 +            // View.generateViewId() is not available. The following fallback logic is a copy</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 782 +            // of its implementation.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 783 +            for (;;) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 784 +                final int result = sNextGeneratedId.get();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 785 +                // aapt-generated IDs have the high byte nonzero; clamp to the range under that.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 786 +                int newValue = result + 1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 787 +                if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 788 +                if (sNextGeneratedId.compareAndSet(result, newValue)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 789 +                    return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 790 +                }</span>
 791              }
 792          }
 793      }
 794  
 795      public int getViewIdForItem(ItemInfo info) {
 796          // This cast is safe given the &gt; 2B range for int.
 797          int itemId = (int) info.id;
 798          if (mItemIdToViewId.containsKey(itemId)) {
 799              return mItemIdToViewId.get(itemId);
 800          }
 801          int viewId = generateViewId();
 802          mItemIdToViewId.put(itemId, viewId);
 803          return viewId;
 804      }
 805  
 806      /**
 807       * Returns whether we should delay spring loaded mode -- for shortcuts and widgets that have
 808       * a configuration step, this allows the proper animations to run after other transitions.
 809       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 810 -    private boolean completeAdd(PendingAddArguments args) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 811 -        boolean result = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 812 +    private long completeAdd(PendingAddArguments args) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 813 +        long screenId = args.screenId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 814 +        if (args.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 815 +            // When the screen id represents an actual screen (as opposed to a rank) we make sure</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 816 +            // that the drop page actually exists.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 817 +            screenId = ensurePendingDropLayoutExists(args.screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 818 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 819 +</span>
 820          switch (args.requestCode) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 821 -            case REQUEST_PICK_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 822 -                completeAddApplication(args.intent, args.container, args.screenId, args.cellX,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 823 +            case REQUEST_CREATE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 824 +                completeAddShortcut(args.intent, args.container, screenId, args.cellX,</span>
 825                          args.cellY);
 826                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 827 -            case REQUEST_PICK_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 828 -                processShortcut(args.intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 829 +            case REQUEST_CREATE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +                completeAddAppWidget(args.appWidgetId, args.container, screenId, null, null);</span>
 831                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 832 -            case REQUEST_CREATE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 833 -                completeAddShortcut(args.intent, args.container, args.screenId, args.cellX,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 834 -                        args.cellY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 835 -                result = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 836 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 837 -            case REQUEST_CREATE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 838 -                int appWidgetId = args.intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 839 -                completeAddAppWidget(appWidgetId, args.container, args.screenId, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 840 -                result = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 841 +            case REQUEST_RECONFIGURE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 842 +                completeRestoreAppWidget(args.appWidgetId);</span>
 843                  break;
 844          }
 845          // Before adding this resetAddInfo(), after a shortcut was added to a workspace screen,
 846          // if you turned the screen off and then back while in All Apps, Launcher would not
 847          // return to the workspace. Clearing mAddInfo.container here fixes this issue
 848          resetAddInfo();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 849 -        return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 850 +        return screenId;</span>
 851      }
 852  
 853      @Override
 854      protected void onActivityResult(
 855              final int requestCode, final int resultCode, final Intent data) {
 856          // Reset the startActivity waiting flag
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 857 -        mWaitingForResult = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 858 -        int pendingAddWidgetId = mPendingAddWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 859 +        setWaitingForResult(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 860 +        final int pendingAddWidgetId = mPendingAddWidgetId;</span>
 861          mPendingAddWidgetId = -1;
 862  
 863          Runnable exitSpringLoaded = new Runnable() {
 864              @Override
 865              public void run() {
 866                  exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 867                          EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 868              }
 869          };
 870  
 871          if (requestCode == REQUEST_BIND_APPWIDGET) {
 872              final int appWidgetId = data != null ?
 873                      data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1) : -1;
 874              if (resultCode == RESULT_CANCELED) {
 875                  completeTwoStageWidgetDrop(RESULT_CANCELED, appWidgetId);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 876 -                mWorkspace.removeExtraEmptyScreen(true, exitSpringLoaded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 877 +                mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,</span>
 878                          ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 879              } else if (resultCode == RESULT_OK) {
 880                  addAppWidgetImpl(appWidgetId, mPendingAddInfo, null,
 881                          mPendingAddWidgetInfo, ON_ACTIVITY_RESULT_ANIMATION_DELAY);
 882              }
 883              return;
 884          } else if (requestCode == REQUEST_PICK_WALLPAPER) {
 885              if (resultCode == RESULT_OK &amp;&amp; mWorkspace.isInOverviewMode()) {
 886                  mWorkspace.exitOverviewMode(false);
 887              }
 888              return;
 889          }
 890  
 891          boolean isWidgetDrop = (requestCode == REQUEST_PICK_APPWIDGET ||
 892                  requestCode == REQUEST_CREATE_APPWIDGET);
 893  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 894 +        final boolean workspaceLocked = isWorkspaceLocked();</span>
 895          // We have special handling for widgets
 896          if (isWidgetDrop) {
 897              final int appWidgetId;
 898              int widgetId = data != null ? data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
 899                      : -1;
 900              if (widgetId &lt; 0) {
 901                  appWidgetId = pendingAddWidgetId;
 902              } else {
 903                  appWidgetId = widgetId;
 904              }
 905  
 906              final int result;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 907 -            final Runnable onComplete;</span>
 908              if (appWidgetId &lt; 0 || resultCode == RESULT_CANCELED) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 909 -                Log.e(TAG, &quot;Error: appWidgetId (EXTRA_APPWIDGET_ID) was not returned from the \\&quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 910 -                        &quot;widget configuration activity.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +                Log.e(TAG, &quot;Error: appWidgetId (EXTRA_APPWIDGET_ID) was not &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 912 +                        &quot;returned from the widget configuration activity.&quot;);</span>
 913                  result = RESULT_CANCELED;
 914                  completeTwoStageWidgetDrop(result, appWidgetId);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 915 -                onComplete = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +                final Runnable onComplete = new Runnable() {</span>
 917                      @Override
 918                      public void run() {
 919                          exitSpringLoadedDragModeDelayed(false, 0, null);
 920                      }
 921                  };
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 922 +                if (workspaceLocked) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 923 +                    // No need to remove the empty screen if we&#x27;re mid-binding, as the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +                    // the bind will not add the empty screen.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +                    mWorkspace.postDelayed(onComplete, ON_ACTIVITY_RESULT_ANIMATION_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 926 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 927 +                    mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 928 +                            ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +                }</span>
 930              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 931 -                result = resultCode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 932 -                final CellLayout dropLayout =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 933 -                        (CellLayout) mWorkspace.getScreenWithId(mPendingAddInfo.screenId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 934 -                dropLayout.setDropPending(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 935 -                onComplete = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 936 -                    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 937 -                    public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 938 -                        completeTwoStageWidgetDrop(result, appWidgetId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 939 -                        dropLayout.setDropPending(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 940 +                if (!workspaceLocked) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 941 +                    if (mPendingAddInfo.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 942 +                        // When the screen id represents an actual screen (as opposed to a rank)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 943 +                        // we make sure that the drop page actually exists.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +                        mPendingAddInfo.screenId =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 945 +                                ensurePendingDropLayoutExists(mPendingAddInfo.screenId);</span>
 946                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 947 -                };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 948 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 949 -            mWorkspace.removeExtraEmptyScreen(true, onComplete, ON_ACTIVITY_RESULT_ANIMATION_DELAY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 950 -                    false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +                    final CellLayout dropLayout = mWorkspace.getScreenWithId(mPendingAddInfo.screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 952 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 953 +                    dropLayout.setDropPending(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 954 +                    final Runnable onComplete = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 955 +                        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 956 +                        public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 957 +                            completeTwoStageWidgetDrop(resultCode, appWidgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 958 +                            dropLayout.setDropPending(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 959 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 960 +                    };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 961 +                    mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +                            ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 963 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 964 +                    PendingAddArguments args = preparePendingAddArgs(requestCode, data, appWidgetId,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 965 +                            mPendingAddInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 966 +                    sPendingAddItem = args;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 967 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 968 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 969 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 970 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 971 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 972 +        if (requestCode == REQUEST_RECONFIGURE_APPWIDGET) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 973 +            if (resultCode == RESULT_OK) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 974 +                // Update the widget view.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 975 +                PendingAddArguments args = preparePendingAddArgs(requestCode, data,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 976 +                        pendingAddWidgetId, mPendingAddInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 977 +                if (workspaceLocked) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 978 +                    sPendingAddItem = args;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 979 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 980 +                    completeAdd(args);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 981 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 982 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 983 +            // Leave the widget in the pending state if the user canceled the configure.</span>
 984              return;
 985          }
 986  
 987          // The pattern used here is that a user PICKs a specific application,
 988          // which, depending on the target, might need to CREATE the actual target.
 989  
 990          // For example, the user would PICK_SHORTCUT for &quot;Music playlist&quot;, and we
 991          // launch over to the Music app to actually CREATE_SHORTCUT.
 992          if (resultCode == RESULT_OK &amp;&amp; mPendingAddInfo.container != ItemInfo.NO_ID) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 993 -            final PendingAddArguments args = new PendingAddArguments();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 994 -            args.requestCode = requestCode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 995 -            args.intent = data;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 996 -            args.container = mPendingAddInfo.container;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 997 -            args.screenId = mPendingAddInfo.screenId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 998 -            args.cellX = mPendingAddInfo.cellX;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 999 -            args.cellY = mPendingAddInfo.cellY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1000 +            final PendingAddArguments args = preparePendingAddArgs(requestCode, data, -1,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1001 +                    mPendingAddInfo);</span>
1002              if (isWorkspaceLocked()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1003 -                sPendingAddList.add(args);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1004 +                sPendingAddItem = args;</span>
1005              } else {
1006                  completeAdd(args);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1007 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1008 -            mWorkspace.removeExtraEmptyScreen(true, exitSpringLoaded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1009 +                mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1010 +                        ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1011 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1012 +        } else if (resultCode == RESULT_CANCELED) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1013 +            mWorkspace.removeExtraEmptyScreenDelayed(true, exitSpringLoaded,</span>
1014                      ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1015 -        } else if (resultCode == RESULT_CANCELED) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1016 -            mWorkspace.removeExtraEmptyScreen(true, exitSpringLoaded,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1017 -                    ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);</span>
1018          }
1019          mDragLayer.clearAnimatedView();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1020 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1021 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1022 +    private PendingAddArguments preparePendingAddArgs(int requestCode, Intent data, int</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1023 +            appWidgetId, ItemInfo info) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1024 +        PendingAddArguments args = new PendingAddArguments();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1025 +        args.requestCode = requestCode;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1026 +        args.intent = data;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1027 +        args.container = info.container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1028 +        args.screenId = info.screenId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1029 +        args.cellX = info.cellX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1030 +        args.cellY = info.cellY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1031 +        args.appWidgetId = appWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1032 +        return args;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1033 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1034 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1035 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1036 +     * Check to see if a given screen id exists. If not, create it at the end, return the new id.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1037 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1038 +     * @param screenId the screen id to check</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1039 +     * @return the new screen, or screenId if it exists</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1040 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1041 +    private long ensurePendingDropLayoutExists(long screenId) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1042 +        CellLayout dropLayout =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1043 +                (CellLayout) mWorkspace.getScreenWithId(screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1044 +        if (dropLayout == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1045 +            // it&#x27;s possible that the add screen was removed because it was</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1046 +            // empty and a re-bind occurred</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1047 +            mWorkspace.addExtraEmptyScreen();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1048 +            return mWorkspace.commitExtraEmptyScreen();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1049 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1050 +            return screenId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1051 +        }</span>
1052      }
1053  
1054      private void completeTwoStageWidgetDrop(final int resultCode, final int appWidgetId) {
1055          CellLayout cellLayout =
1056                  (CellLayout) mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
1057          Runnable onCompleteRunnable = null;
1058          int animationType = 0;
1059  
1060          AppWidgetHostView boundWidget = null;
1061          if (resultCode == RESULT_OK) {
1062              animationType = Workspace.COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION;
1063              final AppWidgetHostView layout = mAppWidgetHost.createView(this, appWidgetId,
1064                      mPendingAddWidgetInfo);
1065              boundWidget = layout;
1066              onCompleteRunnable = new Runnable() {
1067                  @Override
1068                  public void run() {
1069                      completeAddAppWidget(appWidgetId, mPendingAddInfo.container,
1070                              mPendingAddInfo.screenId, layout, null);
1071                      exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
1072                              EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
1073                  }
1074              };
1075          } else if (resultCode == RESULT_CANCELED) {
1076              mAppWidgetHost.deleteAppWidgetId(appWidgetId);
1077              animationType = Workspace.CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION;
1078          }
1079          if (mDragLayer.getAnimatedView() != null) {
1080              mWorkspace.animateWidgetDrop(mPendingAddInfo, cellLayout,
1081                      (DragView) mDragLayer.getAnimatedView(), onCompleteRunnable,
1082                      animationType, boundWidget, true);
1083          } else if (onCompleteRunnable != null) {
1084              // The animated view may be null in the case of a rotation during widget configuration
1085              onCompleteRunnable.run();
1086          }
1087      }
1088  
1089      @Override
1090      protected void onStop() {
1091          super.onStop();
1092          FirstFrameAnimatorHelper.setIsVisible(false);
1093      }
1094  
1095      @Override
1096      protected void onStart() {
1097          super.onStart();
1098          FirstFrameAnimatorHelper.setIsVisible(true);
1099      }
1100  
1101      @Override
1102      protected void onResume() {
1103          long startTime = 0;
1104          if (DEBUG_RESUME_TIME) {
1105              startTime = System.currentTimeMillis();
1106              Log.v(TAG, &quot;Launcher.onResume()&quot;);
1107          }
1108          super.onResume();
1109  
1110          // Restore the previous launcher state
1111          if (mOnResumeState == State.WORKSPACE) {
1112              showWorkspace(false);
1113          } else if (mOnResumeState == State.APPS_CUSTOMIZE) {
1114              showAllApps(false, mAppsCustomizeContent.getContentType(), false);
1115          }
1116          mOnResumeState = State.NONE;
1117  
1118          // Background was set to gradient in onPause(), restore to black if in all apps.
1119          setWorkspaceBackground(mState == State.WORKSPACE);
1120  
1121          mPaused = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1122 -        sPausedFromUserAction = false;</span>
1123          if (mRestoring || mOnResumeNeedsLoad) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1124 -            mWorkspaceLoading = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1125 +            setWorkspaceLoading(true);</span>
1126              mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
1127              mRestoring = false;
1128              mOnResumeNeedsLoad = false;
1129          }
1130          if (mBindOnResumeCallbacks.size() &gt; 0) {
1131              // We might have postponed some bind calls until onResume (see waitUntilResume) --
1132              // execute them here
1133              long startTimeCallbacks = 0;
1134              if (DEBUG_RESUME_TIME) {
1135                  startTimeCallbacks = System.currentTimeMillis();
1136              }
1137  
1138              if (mAppsCustomizeContent != null) {
1139                  mAppsCustomizeContent.setBulkBind(true);
1140              }
1141              for (int i = 0; i &lt; mBindOnResumeCallbacks.size(); i++) {
1142                  mBindOnResumeCallbacks.get(i).run();
1143              }
1144              if (mAppsCustomizeContent != null) {
1145                  mAppsCustomizeContent.setBulkBind(false);
1146              }
1147              mBindOnResumeCallbacks.clear();
1148              if (DEBUG_RESUME_TIME) {
1149                  Log.d(TAG, &quot;Time spent processing callbacks in onResume: &quot; +
1150                      (System.currentTimeMillis() - startTimeCallbacks));
1151              }
1152          }
1153          if (mOnResumeCallbacks.size() &gt; 0) {
1154              for (int i = 0; i &lt; mOnResumeCallbacks.size(); i++) {
1155                  mOnResumeCallbacks.get(i).run();
1156              }
1157              mOnResumeCallbacks.clear();
1158          }
1159  
1160          // Reset the pressed state of icons that were locked in the press state while activities
1161          // were launching
1162          if (mWaitingForResume != null) {
1163              // Resets the previous workspace icon press state
1164              mWaitingForResume.setStayPressed(false);
1165          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1166 -        if (mAppsCustomizeContent != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1167 -            // Resets the previous all apps icon press state</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1168 -            mAppsCustomizeContent.resetDrawableState();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1169 -        }</span>
1170  
1171          // It is possible that widgets can receive updates while launcher is not in the foreground.
1172          // Consequently, the widgets will be inflated in the orientation of the foreground activity
1173          // (framework issue). On resuming, we ensure that any widgets are inflated for the current
1174          // orientation.
1175          getWorkspace().reinflateWidgetsIfNecessary();
1176  
1177          // Process any items that were added while Launcher was away.
1178          InstallShortcutReceiver.disableAndFlushInstallQueue(this);
1179  
1180          // Update the voice search button proxy
1181          updateVoiceButtonProxyVisible(false);
1182  
1183          // Again, as with the above scenario, it&#x27;s possible that one or more of the global icons
1184          // were updated in the wrong orientation.
1185          updateGlobalIcons();
1186          if (DEBUG_RESUME_TIME) {
1187              Log.d(TAG, &quot;Time spent in onResume: &quot; + (System.currentTimeMillis() - startTime));
1188          }
1189  
1190          if (mWorkspace.getCustomContentCallbacks() != null) {
1191              // If we are resuming and the custom content is the current page, we call onShow().
1192              // It is also poassible that onShow will instead be called slightly after first layout
1193              // if PagedView#setRestorePage was set to the custom content page in onCreate().
1194              if (mWorkspace.isOnOrMovingToCustomContent()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1195 -                mWorkspace.getCustomContentCallbacks().onShow();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1196 +                mWorkspace.getCustomContentCallbacks().onShow(true);</span>
1197              }
1198          }
1199          mWorkspace.updateInteractionForState();
1200          mWorkspace.onResume();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1201 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1202 +        PackageInstallerCompat.getInstance(this).onResume();</span>
1203      }
1204  
1205      @Override
1206      protected void onPause() {
1207          // Ensure that items added to Launcher are queued until Launcher returns
1208          InstallShortcutReceiver.enableInstallQueue();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1209 +        PackageInstallerCompat.getInstance(this).onPause();</span>
1210  
1211          super.onPause();
1212          mPaused = true;
1213          mDragController.cancelDrag();
1214          mDragController.resetLastGestureUpTime();
1215  
1216          // We call onHide() aggressively. The custom content callbacks should be able to
1217          // debounce excess onHide calls.
1218          if (mWorkspace.getCustomContentCallbacks() != null) {
1219              mWorkspace.getCustomContentCallbacks().onHide();
1220          }
1221      }
1222  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1223 -    protected void onFinishBindingItems() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1224 -        if (mWorkspace != null &amp;&amp; hasCustomContentToLeft() &amp;&amp; mWorkspace.hasCustomContent()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1225 -            addCustomContentToLeft();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1226 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1227 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1228 -</span>
1229      QSBScroller mQsbScroller = new QSBScroller() {
1230          int scrollY = 0;
1231  
1232          @Override
1233          public void setScrollY(int scroll) {
1234              scrollY = scroll;
1235  
1236              if (mWorkspace.isOnOrMovingToCustomContent()) {
1237                  mSearchDropTargetBar.setTranslationY(- scrollY);
1238                  getQsbBar().setTranslationY(-scrollY);
1239              }
1240          }
1241      };
1242  
1243      public void resetQSBScroll() {
1244          mSearchDropTargetBar.animate().translationY(0).start();
1245          getQsbBar().animate().translationY(0).start();
1246      }
1247  
1248      public interface CustomContentCallbacks {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1249 -        // Custom content is completely shown</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1250 -        public void onShow();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1251 +        // Custom content is completely shown. {@code fromResume} indicates whether this was caused</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1252 +        // by a onResume or by scrolling otherwise.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1253 +        public void onShow(boolean fromResume);</span>
1254  
1255          // Custom content is completely hidden
1256          public void onHide();
1257  
1258          // Custom content scroll progress changed. From 0 (not showing) to 1 (fully showing).
1259          public void onScrollProgressChanged(float progress);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1260 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1261 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1262 -    protected void startSettings() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1263 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1264 +        // Indicates whether the user is allowed to scroll away from the custom content.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1265 +        boolean isScrollingAllowed();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1266 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1267 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1268 +    protected boolean hasSettings() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1269 +        return false;</span>
1270      }
1271  
1272      public interface QSBScroller {
1273          public void setScrollY(int scrollY);
1274      }
1275  
1276      public QSBScroller addToCustomContentPage(View customContent,
1277              CustomContentCallbacks callbacks, String description) {
1278          mWorkspace.addToCustomContentPage(customContent, callbacks, description);
1279          return mQsbScroller;
1280      }
1281  
1282      // The custom content needs to offset its content to account for the QSB
1283      public int getTopOffsetForCustomContent() {
1284          return mWorkspace.getPaddingTop();
1285      }
1286  
1287      @Override
1288      public Object onRetainNonConfigurationInstance() {
1289          // Flag the loader to stop early before switching
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1290 -        mModel.stopLoader();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1291 +        if (mModel.isCurrentCallbacks(this)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1292 +            mModel.stopLoader();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1293 +        }</span>
1294          if (mAppsCustomizeContent != null) {
1295              mAppsCustomizeContent.surrender();
1296          }
1297          return Boolean.TRUE;
1298      }
1299  
1300      // We can&#x27;t hide the IME if it was forced open.  So don&#x27;t bother
1301      @Override
1302      public void onWindowFocusChanged(boolean hasFocus) {
1303          super.onWindowFocusChanged(hasFocus);
1304          mHasFocus = hasFocus;
1305      }
1306  
1307      private boolean acceptFilter() {
1308          final InputMethodManager inputManager = (InputMethodManager)
1309                  getSystemService(Context.INPUT_METHOD_SERVICE);
1310          return !inputManager.isFullscreenMode();
1311      }
1312  
1313      @Override
1314      public boolean onKeyDown(int keyCode, KeyEvent event) {
1315          final int uniChar = event.getUnicodeChar();
1316          final boolean handled = super.onKeyDown(keyCode, event);
1317          final boolean isKeyNotWhitespace = uniChar &gt; 0 &amp;&amp; !Character.isWhitespace(uniChar);
1318          if (!handled &amp;&amp; acceptFilter() &amp;&amp; isKeyNotWhitespace) {
1319              boolean gotKey = TextKeyListener.getInstance().onKeyDown(mWorkspace, mDefaultKeySsb,
1320                      keyCode, event);
1321              if (gotKey &amp;&amp; mDefaultKeySsb != null &amp;&amp; mDefaultKeySsb.length() &gt; 0) {
1322                  // something usable has been typed - start a search
1323                  // the typed text will be retrieved and cleared by
1324                  // showSearchDialog()
1325                  // If there are multiple keystrokes before the search dialog takes focus,
1326                  // onSearchRequested() will be called for every keystroke,
1327                  // but it is idempotent, so it&#x27;s fine.
1328                  return onSearchRequested();
1329              }
1330          }
1331  
1332          // Eat the long press event so the keyboard doesn&#x27;t come up.
1333          if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.isLongPress()) {
1334              return true;
1335          }
1336  
1337          return handled;
1338      }
1339  
1340      private String getTypedText() {
1341          return mDefaultKeySsb.toString();
1342      }
1343  
1344      private void clearTypedText() {
1345          mDefaultKeySsb.clear();
1346          mDefaultKeySsb.clearSpans();
1347          Selection.setSelection(mDefaultKeySsb, 0);
1348      }
1349  
1350      /**
1351       * Given the integer (ordinal) value of a State enum instance, convert it to a variable of type
1352       * State
1353       */
1354      private static State intToState(int stateOrdinal) {
1355          State state = State.WORKSPACE;
1356          final State[] stateValues = State.values();
1357          for (int i = 0; i &lt; stateValues.length; i++) {
1358              if (stateValues[i].ordinal() == stateOrdinal) {
1359                  state = stateValues[i];
1360                  break;
1361              }
1362          }
1363          return state;
1364      }
1365  
1366      /**
1367       * Restores the previous state, if it exists.
1368       *
1369       * @param savedState The previous state.
1370       */
1371      @SuppressWarnings(&quot;unchecked&quot;)
1372      private void restoreState(Bundle savedState) {
1373          if (savedState == null) {
1374              return;
1375          }
1376  
1377          State state = intToState(savedState.getInt(RUNTIME_STATE, State.WORKSPACE.ordinal()));
1378          if (state == State.APPS_CUSTOMIZE) {
1379              mOnResumeState = State.APPS_CUSTOMIZE;
1380          }
1381  
1382          int currentScreen = savedState.getInt(RUNTIME_STATE_CURRENT_SCREEN,
1383                  PagedView.INVALID_RESTORE_PAGE);
1384          if (currentScreen != PagedView.INVALID_RESTORE_PAGE) {
1385              mWorkspace.setRestorePage(currentScreen);
1386          }
1387  
1388          final long pendingAddContainer = savedState.getLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, -1);
1389          final long pendingAddScreen = savedState.getLong(RUNTIME_STATE_PENDING_ADD_SCREEN, -1);
1390  
1391          if (pendingAddContainer != ItemInfo.NO_ID &amp;&amp; pendingAddScreen &gt; -1) {
1392              mPendingAddInfo.container = pendingAddContainer;
1393              mPendingAddInfo.screenId = pendingAddScreen;
1394              mPendingAddInfo.cellX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_X);
1395              mPendingAddInfo.cellY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_Y);
1396              mPendingAddInfo.spanX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_X);
1397              mPendingAddInfo.spanY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y);
1398              mPendingAddWidgetInfo = savedState.getParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO);
1399              mPendingAddWidgetId = savedState.getInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1400 -            mWaitingForResult = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1401 +            setWaitingForResult(true);</span>
1402              mRestoring = true;
1403          }
1404  
1405          boolean renameFolder = savedState.getBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, false);
1406          if (renameFolder) {
1407              long id = savedState.getLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID);
1408              mFolderInfo = mModel.getFolderById(this, sFolders, id);
1409              mRestoring = true;
1410          }
1411  
1412          // Restore the AppsCustomize tab
1413          if (mAppsCustomizeTabHost != null) {
1414              String curTab = savedState.getString(&quot;apps_customize_currentTab&quot;);
1415              if (curTab != null) {
1416                  mAppsCustomizeTabHost.setContentTypeImmediate(
1417                          mAppsCustomizeTabHost.getContentTypeForTabTag(curTab));
1418                  mAppsCustomizeContent.loadAssociatedPages(
1419                          mAppsCustomizeContent.getCurrentPage());
1420              }
1421  
1422              int currentIndex = savedState.getInt(&quot;apps_customize_currentIndex&quot;);
1423              mAppsCustomizeContent.restorePageForIndex(currentIndex);
1424          }
1425          mItemIdToViewId = (HashMap&lt;Integer, Integer&gt;)
1426                  savedState.getSerializable(RUNTIME_STATE_VIEW_IDS);
1427      }
1428  
1429      /**
1430       * Finds all the views we need and configure them properly.
1431       */
1432      private void setupViews() {
1433          final DragController dragController = mDragController;
1434  
1435          mLauncherView = findViewById(R.id.launcher);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1436 +        mFocusHandler = (FocusIndicatorView) findViewById(R.id.focus_indicator);</span>
1437          mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
1438          mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1439 +        mWorkspace.setPageSwitchListener(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1440 +        mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);</span>
1441  
1442          mLauncherView.setSystemUiVisibility(
1443                  View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
1444          mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
1445  
1446          // Setup the drag layer
1447          mDragLayer.setup(this, dragController);
1448  
1449          // Setup the hotseat
1450          mHotseat = (Hotseat) findViewById(R.id.hotseat);
1451          if (mHotseat != null) {
1452              mHotseat.setup(this);
1453              mHotseat.setOnLongClickListener(this);
1454          }
1455  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1456 -        mOverviewPanel = findViewById(R.id.overview_panel);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1457 +        mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);</span>
1458          View widgetButton = findViewById(R.id.widget_button);
1459          widgetButton.setOnClickListener(new OnClickListener() {
1460              @Override
1461              public void onClick(View arg0) {
1462                  if (!mWorkspace.isSwitchingState()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1463 -                    showAllApps(true, AppsCustomizePagedView.ContentType.Widgets, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1464 +                    onClickAddWidgetButton(arg0);</span>
1465                  }
1466              }
1467          });
1468          widgetButton.setOnTouchListener(getHapticFeedbackTouchListener());
1469  
1470          View wallpaperButton = findViewById(R.id.wallpaper_button);
1471          wallpaperButton.setOnClickListener(new OnClickListener() {
1472              @Override
1473              public void onClick(View arg0) {
1474                  if (!mWorkspace.isSwitchingState()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1475 -                    startWallpaper();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1476 +                    onClickWallpaperPicker(arg0);</span>
1477                  }
1478              }
1479          });
1480          wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
1481  
1482          View settingsButton = findViewById(R.id.settings_button);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1483 -        settingsButton.setOnClickListener(new OnClickListener() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1484 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1485 -            public void onClick(View arg0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1486 -                if (!mWorkspace.isSwitchingState()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1487 -                    startSettings();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1488 +        if (hasSettings()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1489 +            settingsButton.setOnClickListener(new OnClickListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1490 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1491 +                public void onClick(View arg0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1492 +                    if (!mWorkspace.isSwitchingState()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1493 +                        onClickSettingsButton(arg0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1494 +                    }</span>
1495                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1496 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1497 -        });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1498 -        settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1499 +            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1500 +            settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1501 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1502 +            settingsButton.setVisibility(View.GONE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1503 +            FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) widgetButton.getLayoutParams();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1504 +            lp.gravity = Gravity.END | Gravity.TOP;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1505 +            widgetButton.requestLayout();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1506 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1507 +</span>
1508          mOverviewPanel.setAlpha(0f);
1509  
1510          // Setup the workspace
1511          mWorkspace.setHapticFeedbackEnabled(false);
1512          mWorkspace.setOnLongClickListener(this);
1513          mWorkspace.setup(dragController);
1514          dragController.addDragListener(mWorkspace);
1515  
1516          // Get the search/delete bar
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1517 -        mSearchDropTargetBar = (SearchDropTargetBar) mDragLayer.findViewById(R.id.qsb_bar);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1518 +        mSearchDropTargetBar = (SearchDropTargetBar)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1519 +                mDragLayer.findViewById(R.id.search_drop_target_bar);</span>
1520  
1521          // Setup AppsCustomize
1522          mAppsCustomizeTabHost = (AppsCustomizeTabHost) findViewById(R.id.apps_customize_pane);
1523          mAppsCustomizeContent = (AppsCustomizePagedView)
1524                  mAppsCustomizeTabHost.findViewById(R.id.apps_customize_pane_content);
1525          mAppsCustomizeContent.setup(this, dragController);
1526  
1527          // Setup the drag controller (drop targets have to be added in reverse order in priority)
1528          dragController.setDragScoller(mWorkspace);
1529          dragController.setScrollView(mDragLayer);
1530          dragController.setMoveTarget(mWorkspace);
1531          dragController.addDropTarget(mWorkspace);
1532          if (mSearchDropTargetBar != null) {
1533              mSearchDropTargetBar.setup(this, dragController);
1534          }
1535  
1536          if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
1537              Log.v(TAG, &quot;adding WeightWatcher&quot;);
1538              mWeightWatcher = new WeightWatcher(this);
1539              mWeightWatcher.setAlpha(0.5f);
1540              ((FrameLayout) mLauncherView).addView(mWeightWatcher,
1541                      new FrameLayout.LayoutParams(
1542                              FrameLayout.LayoutParams.MATCH_PARENT,
1543                              FrameLayout.LayoutParams.WRAP_CONTENT,
1544                              Gravity.BOTTOM)
1545              );
1546  
1547              boolean show = shouldShowWeightWatcher();
1548              mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
1549          }
1550      }
1551  
1552      /**
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1553 +     * Sets the all apps button. This method is called from {@link Hotseat}.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1554 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1555 +    public void setAllAppsButton(View allAppsButton) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1556 +        mAllAppsButton = allAppsButton;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1557 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1558 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1559 +    public View getAllAppsButton() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1560 +        return mAllAppsButton;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1561 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1562 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1563 +    /**</span>
1564       * Creates a view representing a shortcut.
1565       *
1566       * @param info The data structure describing the shortcut.
1567       *
1568       * @return A View inflated from R.layout.application.
1569       */
1570      View createShortcut(ShortcutInfo info) {
1571          return createShortcut(R.layout.application,
1572                  (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
1573      }
1574  
1575      /**
1576       * Creates a view representing a shortcut inflated from the specified resource.
1577       *
1578       * @param layoutResId The id of the XML layout used to create the shortcut.
1579       * @param parent The group the shortcut belongs to.
1580       * @param info The data structure describing the shortcut.
1581       *
1582       * @return A View inflated from layoutResId.
1583       */
1584      View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) {
1585          BubbleTextView favorite = (BubbleTextView) mInflater.inflate(layoutResId, parent, false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1586 -        favorite.applyFromShortcutInfo(info, mIconCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1587 +        favorite.applyFromShortcutInfo(info, mIconCache, true);</span>
1588          favorite.setOnClickListener(this);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1589 +        favorite.setOnFocusChangeListener(mFocusHandler);</span>
1590          return favorite;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1591 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1592 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1593 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1594 -     * Add an application shortcut to the workspace.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1595 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1596 -     * @param data The intent describing the application.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1597 -     * @param cellInfo The position on screen where to create the shortcut.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1598 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1599 -    void completeAddApplication(Intent data, long container, long screenId, int cellX, int cellY) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1600 -        final int[] cellXY = mTmpAddItemCellCoordinates;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1601 -        final CellLayout layout = getCellLayout(container, screenId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1602 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1603 -        // First we check if we already know the exact location where we want to add this item.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1604 -        if (cellX &gt;= 0 &amp;&amp; cellY &gt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1605 -            cellXY[0] = cellX;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1606 -            cellXY[1] = cellY;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1607 -        } else if (!layout.findCellForSpan(cellXY, 1, 1)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1608 -            showOutOfSpaceMessage(isHotseatLayout(layout));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1609 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1610 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1611 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1612 -        final ShortcutInfo info = mModel.getShortcutInfo(getPackageManager(), data, this);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1613 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1614 -        if (info != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1615 -            info.setActivity(this, data.getComponent(), Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1616 -                    Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1617 -            info.container = ItemInfo.NO_ID;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1618 -            mWorkspace.addApplicationShortcut(info, layout, container, screenId, cellXY[0], cellXY[1],</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1619 -                    isWorkspaceLocked(), cellX, cellY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1620 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1621 -            Log.e(TAG, &quot;Couldn&#x27;t find ActivityInfo for selected application: &quot; + data);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1622 -        }</span>
1623      }
1624  
1625      /**
1626       * Add a shortcut to the workspace.
1627       *
1628       * @param data The intent describing the shortcut.
1629       * @param cellInfo The position on screen where to create the shortcut.
1630       */
1631      private void completeAddShortcut(Intent data, long container, long screenId, int cellX,
1632              int cellY) {
1633          int[] cellXY = mTmpAddItemCellCoordinates;
1634          int[] touchXY = mPendingAddInfo.dropPos;
1635          CellLayout layout = getCellLayout(container, screenId);
1636  
1637          boolean foundCellSpan = false;
1638  
1639          ShortcutInfo info = mModel.infoFromShortcutIntent(this, data, null);
1640          if (info == null) {
1641              return;
1642          }
1643          final View view = createShortcut(info);
1644  
1645          // First we check if we already know the exact location where we want to add this item.
1646          if (cellX &gt;= 0 &amp;&amp; cellY &gt;= 0) {
1647              cellXY[0] = cellX;
1648              cellXY[1] = cellY;
1649              foundCellSpan = true;
1650  
1651              // If appropriate, either create a folder or add to an existing folder
1652              if (mWorkspace.createUserFolderIfNecessary(view, container, layout, cellXY, 0,
1653                      true, null,null)) {
1654                  return;
1655              }
1656              DragObject dragObject = new DragObject();
1657              dragObject.dragInfo = info;
1658              if (mWorkspace.addToExistingFolderIfNecessary(view, layout, cellXY, 0, dragObject,
1659                      true)) {
1660                  return;
1661              }
1662          } else if (touchXY != null) {
1663              // when dragging and dropping, just find the closest free spot
1664              int[] result = layout.findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, cellXY);
1665              foundCellSpan = (result != null);
1666          } else {
1667              foundCellSpan = layout.findCellForSpan(cellXY, 1, 1);
1668          }
1669  
1670          if (!foundCellSpan) {
1671              showOutOfSpaceMessage(isHotseatLayout(layout));
1672              return;
1673          }
1674  
1675          LauncherModel.addItemToDatabase(this, info, container, screenId, cellXY[0], cellXY[1], false);
1676  
1677          if (!mRestoring) {
1678              mWorkspace.addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1,
1679                      isWorkspaceLocked());
1680          }
1681      }
1682  
1683      static int[] getSpanForWidget(Context context, ComponentName component, int minWidth,
1684              int minHeight) {
1685          Rect padding = AppWidgetHostView.getDefaultPaddingForWidget(context, component, null);
1686          // We want to account for the extra amount of padding that we are adding to the widget
1687          // to ensure that it gets the full amount of space that it has requested
1688          int requiredWidth = minWidth + padding.left + padding.right;
1689          int requiredHeight = minHeight + padding.top + padding.bottom;
1690          return CellLayout.rectToCell(requiredWidth, requiredHeight, null);
1691      }
1692  
1693      static int[] getSpanForWidget(Context context, AppWidgetProviderInfo info) {
1694          return getSpanForWidget(context, info.provider, info.minWidth, info.minHeight);
1695      }
1696  
1697      static int[] getMinSpanForWidget(Context context, AppWidgetProviderInfo info) {
1698          return getSpanForWidget(context, info.provider, info.minResizeWidth, info.minResizeHeight);
1699      }
1700  
1701      static int[] getSpanForWidget(Context context, PendingAddWidgetInfo info) {
1702          return getSpanForWidget(context, info.componentName, info.minWidth, info.minHeight);
1703      }
1704  
1705      static int[] getMinSpanForWidget(Context context, PendingAddWidgetInfo info) {
1706          return getSpanForWidget(context, info.componentName, info.minResizeWidth,
1707                  info.minResizeHeight);
1708      }
1709  
1710      /**
1711       * Add a widget to the workspace.
1712       *
1713       * @param appWidgetId The app widget id
1714       * @param cellInfo The position on screen where to create the widget.
1715       */
1716      private void completeAddAppWidget(final int appWidgetId, long container, long screenId,
1717              AppWidgetHostView hostView, AppWidgetProviderInfo appWidgetInfo) {
1718          if (appWidgetInfo == null) {
1719              appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
1720          }
1721  
1722          // Calculate the grid spans needed to fit this widget
1723          CellLayout layout = getCellLayout(container, screenId);
1724  
1725          int[] minSpanXY = getMinSpanForWidget(this, appWidgetInfo);
1726          int[] spanXY = getSpanForWidget(this, appWidgetInfo);
1727  
1728          // Try finding open space on Launcher screen
1729          // We have saved the position to which the widget was dragged-- this really only matters
1730          // if we are placing widgets on a &quot;spring-loaded&quot; screen
1731          int[] cellXY = mTmpAddItemCellCoordinates;
1732          int[] touchXY = mPendingAddInfo.dropPos;
1733          int[] finalSpan = new int[2];
1734          boolean foundCellSpan = false;
1735          if (mPendingAddInfo.cellX &gt;= 0 &amp;&amp; mPendingAddInfo.cellY &gt;= 0) {
1736              cellXY[0] = mPendingAddInfo.cellX;
1737              cellXY[1] = mPendingAddInfo.cellY;
1738              spanXY[0] = mPendingAddInfo.spanX;
1739              spanXY[1] = mPendingAddInfo.spanY;
1740              foundCellSpan = true;
1741          } else if (touchXY != null) {
1742              // when dragging and dropping, just find the closest free spot
1743              int[] result = layout.findNearestVacantArea(
1744                      touchXY[0], touchXY[1], minSpanXY[0], minSpanXY[1], spanXY[0],
1745                      spanXY[1], cellXY, finalSpan);
1746              spanXY[0] = finalSpan[0];
1747              spanXY[1] = finalSpan[1];
1748              foundCellSpan = (result != null);
1749          } else {
1750              foundCellSpan = layout.findCellForSpan(cellXY, minSpanXY[0], minSpanXY[1]);
1751          }
1752  
1753          if (!foundCellSpan) {
1754              if (appWidgetId != -1) {
1755                  // Deleting an app widget ID is a void call but writes to disk before returning
1756                  // to the caller...
1757                  new AsyncTask&lt;Void, Void, Void&gt;() {
1758                      public Void doInBackground(Void ... args) {
1759                          mAppWidgetHost.deleteAppWidgetId(appWidgetId);
1760                          return null;
1761                      }
1762                  }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
1763              }
1764              showOutOfSpaceMessage(isHotseatLayout(layout));
1765              return;
1766          }
1767  
1768          // Build Launcher-specific widget info and save to database
1769          LauncherAppWidgetInfo launcherInfo = new LauncherAppWidgetInfo(appWidgetId,
1770                  appWidgetInfo.provider);
1771          launcherInfo.spanX = spanXY[0];
1772          launcherInfo.spanY = spanXY[1];
1773          launcherInfo.minSpanX = mPendingAddInfo.minSpanX;
1774          launcherInfo.minSpanY = mPendingAddInfo.minSpanY;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1775 +        launcherInfo.user = mAppWidgetManager.getUser(appWidgetInfo);</span>
1776  
1777          LauncherModel.addItemToDatabase(this, launcherInfo,
1778                  container, screenId, cellXY[0], cellXY[1], false);
1779  
1780          if (!mRestoring) {
1781              if (hostView == null) {
1782                  // Perform actual inflation because we&#x27;re live
1783                  launcherInfo.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);
1784                  launcherInfo.hostView.setAppWidget(appWidgetId, appWidgetInfo);
1785              } else {
1786                  // The AppWidgetHostView has already been inflated and instantiated
1787                  launcherInfo.hostView = hostView;
1788              }
1789  
1790              launcherInfo.hostView.setTag(launcherInfo);
1791              launcherInfo.hostView.setVisibility(View.VISIBLE);
1792              launcherInfo.notifyWidgetSizeChanged(this);
1793  
1794              mWorkspace.addInScreen(launcherInfo.hostView, container, screenId, cellXY[0], cellXY[1],
1795                      launcherInfo.spanX, launcherInfo.spanY, isWorkspaceLocked());
1796  
1797              addWidgetToAutoAdvanceIfNeeded(launcherInfo.hostView, appWidgetInfo);
1798          }
1799          resetAddInfo();
1800      }
1801  
1802      private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
1803          @Override
1804          public void onReceive(Context context, Intent intent) {
1805              final String action = intent.getAction();
1806              if (Intent.ACTION_SCREEN_OFF.equals(action)) {
1807                  mUserPresent = false;
1808                  mDragLayer.clearAllResizeFrames();
1809                  updateRunning();
1810  
1811                  // Reset AllApps to its initial state only if we are not in the middle of
1812                  // processing a multi-step drop
1813                  if (mAppsCustomizeTabHost != null &amp;&amp; mPendingAddInfo.container == ItemInfo.NO_ID) {
1814                      showWorkspace(false);
1815                  }
1816              } else if (Intent.ACTION_USER_PRESENT.equals(action)) {
1817                  mUserPresent = true;
1818                  updateRunning();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1819 +            } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.DELETE_DATABASE.equals(action)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1820 +                mModel.resetLoadedState(false, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1821 +                mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1822 +                        LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1823 +            } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.MIGRATE_DATABASE.equals(action)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1824 +                mModel.resetLoadedState(false, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1825 +                mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1826 +                        LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1827 +                                | LauncherModel.LOADER_FLAG_MIGRATE_SHORTCUTS);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1828 +            } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1829 +                    || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1830 +                getModel().forceReload();</span>
1831              }
1832          }
1833      };
1834  
1835      @Override
1836      public void onAttachedToWindow() {
1837          super.onAttachedToWindow();
1838  
1839          // Listen for broadcasts related to user-presence
1840          final IntentFilter filter = new IntentFilter();
1841          filter.addAction(Intent.ACTION_SCREEN_OFF);
1842          filter.addAction(Intent.ACTION_USER_PRESENT);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1843 +        // For handling managed profiles</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1844 +        filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1845 +        filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1846 +        if (ENABLE_DEBUG_INTENTS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1847 +            filter.addAction(DebugIntents.DELETE_DATABASE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1848 +            filter.addAction(DebugIntents.MIGRATE_DATABASE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1849 +        }</span>
1850          registerReceiver(mReceiver, filter);
1851          FirstFrameAnimatorHelper.initializeDrawListener(getWindow().getDecorView());
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1852 +        setupTransparentSystemBarsForLmp();</span>
1853          mAttached = true;
1854          mVisible = true;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1855 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1856 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1857 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1858 +     * Sets up transparent navigation and status bars in LMP.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1859 +     * This method is a no-op for other platform versions.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1860 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1861 +    @TargetApi(19)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1862 +    private void setupTransparentSystemBarsForLmp() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1863 +        // TODO(sansid): use the APIs directly when compiling against L sdk.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1864 +        // Currently we use reflection to access the flags and the API to set the transparency</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1865 +        // on the System bars.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1866 +        if (Utilities.isLmpOrAbove()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1867 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1868 +                getWindow().getAttributes().systemUiVisibility |=</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1869 +                        (View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1870 +                                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1871 +                                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1872 +                getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1873 +                        | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1874 +                Field drawsSysBackgroundsField = WindowManager.LayoutParams.class.getField(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1875 +                        &quot;FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1876 +                getWindow().addFlags(drawsSysBackgroundsField.getInt(null));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1877 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1878 +                Method setStatusBarColorMethod =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1879 +                        Window.class.getDeclaredMethod(&quot;setStatusBarColor&quot;, int.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1880 +                Method setNavigationBarColorMethod =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1881 +                        Window.class.getDeclaredMethod(&quot;setNavigationBarColor&quot;, int.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1882 +                setStatusBarColorMethod.invoke(getWindow(), Color.TRANSPARENT);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1883 +                setNavigationBarColorMethod.invoke(getWindow(), Color.TRANSPARENT);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1884 +            } catch (NoSuchFieldException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1885 +                Log.w(TAG, &quot;NoSuchFieldException while setting up transparent bars&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1886 +            } catch (NoSuchMethodException ex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1887 +                Log.w(TAG, &quot;NoSuchMethodException while setting up transparent bars&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1888 +            } catch (IllegalAccessException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1889 +                Log.w(TAG, &quot;IllegalAccessException while setting up transparent bars&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1890 +            } catch (IllegalArgumentException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1891 +                Log.w(TAG, &quot;IllegalArgumentException while setting up transparent bars&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1892 +            } catch (InvocationTargetException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1893 +                Log.w(TAG, &quot;InvocationTargetException while setting up transparent bars&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1894 +            } finally {}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1895 +        }</span>
1896      }
1897  
1898      @Override
1899      public void onDetachedFromWindow() {
1900          super.onDetachedFromWindow();
1901          mVisible = false;
1902  
1903          if (mAttached) {
1904              unregisterReceiver(mReceiver);
1905              mAttached = false;
1906          }
1907          updateRunning();
1908      }
1909  
1910      public void onWindowVisibilityChanged(int visibility) {
1911          mVisible = visibility == View.VISIBLE;
1912          updateRunning();
1913          // The following code used to be in onResume, but it turns out onResume is called when
1914          // you&#x27;re in All Apps and click home to go to the workspace. onWindowVisibilityChanged
1915          // is a more appropriate event to handle
1916          if (mVisible) {
1917              mAppsCustomizeTabHost.onWindowVisible();
1918              if (!mWorkspaceLoading) {
1919                  final ViewTreeObserver observer = mWorkspace.getViewTreeObserver();
1920                  // We want to let Launcher draw itself at least once before we force it to build
1921                  // layers on all the workspace pages, so that transitioning to Launcher from other
1922                  // apps is nice and speedy.
1923                  observer.addOnDrawListener(new ViewTreeObserver.OnDrawListener() {
1924                      private boolean mStarted = false;
1925                      public void onDraw() {
1926                          if (mStarted) return;
1927                          mStarted = true;
1928                          // We delay the layer building a bit in order to give
1929                          // other message processing a time to run.  In particular
1930                          // this avoids a delay in hiding the IME if it was
1931                          // currently shown, because doing that may involve
1932                          // some communication back with the app.
1933                          mWorkspace.postDelayed(mBuildLayersRunnable, 500);
1934                          final ViewTreeObserver.OnDrawListener listener = this;
1935                          mWorkspace.post(new Runnable() {
1936                                  public void run() {
1937                                      if (mWorkspace != null &amp;&amp;
1938                                              mWorkspace.getViewTreeObserver() != null) {
1939                                          mWorkspace.getViewTreeObserver().
1940                                                  removeOnDrawListener(listener);
1941                                      }
1942                                  }
1943                              });
1944                          return;
1945                      }
1946                  });
1947              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1948 -            // When Launcher comes back to foreground, a different Activity might be responsible for</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1949 -            // the app market intent, so refresh the icon</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1950 -            if (!DISABLE_MARKET_BUTTON) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1951 -                updateAppMarketIcon();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1952 -            }</span>
1953              clearTypedText();
1954          }
1955      }
1956  
1957      private void sendAdvanceMessage(long delay) {
1958          mHandler.removeMessages(ADVANCE_MSG);
1959          Message msg = mHandler.obtainMessage(ADVANCE_MSG);
1960          mHandler.sendMessageDelayed(msg, delay);
1961          mAutoAdvanceSentTime = System.currentTimeMillis();
1962      }
1963  
1964      private void updateRunning() {
1965          boolean autoAdvanceRunning = mVisible &amp;&amp; mUserPresent &amp;&amp; !mWidgetsToAdvance.isEmpty();
1966          if (autoAdvanceRunning != mAutoAdvanceRunning) {
1967              mAutoAdvanceRunning = autoAdvanceRunning;
1968              if (autoAdvanceRunning) {
1969                  long delay = mAutoAdvanceTimeLeft == -1 ? mAdvanceInterval : mAutoAdvanceTimeLeft;
1970                  sendAdvanceMessage(delay);
1971              } else {
1972                  if (!mWidgetsToAdvance.isEmpty()) {
1973                      mAutoAdvanceTimeLeft = Math.max(0, mAdvanceInterval -
1974                              (System.currentTimeMillis() - mAutoAdvanceSentTime));
1975                  }
1976                  mHandler.removeMessages(ADVANCE_MSG);
1977                  mHandler.removeMessages(0); // Remove messages sent using postDelayed()
1978              }
1979          }
1980      }
1981  
1982      private final Handler mHandler = new Handler() {
1983          @Override
1984          public void handleMessage(Message msg) {
1985              if (msg.what == ADVANCE_MSG) {
1986                  int i = 0;
1987                  for (View key: mWidgetsToAdvance.keySet()) {
1988                      final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);
1989                      final int delay = mAdvanceStagger * i;
1990                      if (v instanceof Advanceable) {
1991                         postDelayed(new Runnable() {
1992                             public void run() {
1993                                 ((Advanceable) v).advance();
1994                             }
1995                         }, delay);
1996                      }
1997                      i++;
1998                  }
1999                  sendAdvanceMessage(mAdvanceInterval);
2000              }
2001          }
2002      };
2003  
2004      void addWidgetToAutoAdvanceIfNeeded(View hostView, AppWidgetProviderInfo appWidgetInfo) {
2005          if (appWidgetInfo == null || appWidgetInfo.autoAdvanceViewId == -1) return;
2006          View v = hostView.findViewById(appWidgetInfo.autoAdvanceViewId);
2007          if (v instanceof Advanceable) {
2008              mWidgetsToAdvance.put(hostView, appWidgetInfo);
2009              ((Advanceable) v).fyiWillBeAdvancedByHostKThx();
2010              updateRunning();
2011          }
2012      }
2013  
2014      void removeWidgetToAutoAdvance(View hostView) {
2015          if (mWidgetsToAdvance.containsKey(hostView)) {
2016              mWidgetsToAdvance.remove(hostView);
2017              updateRunning();
2018          }
2019      }
2020  
2021      public void removeAppWidget(LauncherAppWidgetInfo launcherInfo) {
2022          removeWidgetToAutoAdvance(launcherInfo.hostView);
2023          launcherInfo.hostView = null;
2024      }
2025  
2026      void showOutOfSpaceMessage(boolean isHotseatLayout) {
2027          int strId = (isHotseatLayout ? R.string.hotseat_out_of_space : R.string.out_of_space);
2028          Toast.makeText(this, getString(strId), Toast.LENGTH_SHORT).show();
2029      }
2030  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2031 +    public DragLayer getDragLayer() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2032 +        return mDragLayer;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2033 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2034 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2035 +    public Workspace getWorkspace() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2036 +        return mWorkspace;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2037 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2038 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2039 +    public Hotseat getHotseat() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2040 +        return mHotseat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2041 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2042 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2043 +    public ViewGroup getOverviewPanel() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2044 +        return mOverviewPanel;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2045 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2046 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2047 +    public SearchDropTargetBar getSearchBar() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2048 +        return mSearchDropTargetBar;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2049 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2050 +</span>
2051      public LauncherAppWidgetHost getAppWidgetHost() {
2052          return mAppWidgetHost;
2053      }
2054  
2055      public LauncherModel getModel() {
2056          return mModel;








2057      }
2058  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2059 +    protected SharedPreferences getSharedPrefs() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2060 +        return mSharedPrefs;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2061 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2062 +</span>
2063      public void closeSystemDialogs() {
2064          getWindow().closeAllPanels();
2065  
2066          // Whatever we were doing is hereby canceled.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2067 -        mWaitingForResult = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2068 +        setWaitingForResult(false);</span>
2069      }
2070  
2071      @Override
2072      protected void onNewIntent(Intent intent) {
2073          long startTime = 0;
2074          if (DEBUG_RESUME_TIME) {
2075              startTime = System.currentTimeMillis();
2076          }
2077          super.onNewIntent(intent);
2078  
2079          // Close the menu
2080          if (Intent.ACTION_MAIN.equals(intent.getAction())) {
2081              // also will cancel mWaitingForResult.
2082              closeSystemDialogs();
2083  
2084              final boolean alreadyOnHome = mHasFocus &amp;&amp; ((intent.getFlags() &amp;
2085                      Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT)
2086                      != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
2087  
2088              if (mWorkspace == null) {
2089                  // Can be cases where mWorkspace is null, this prevents a NPE
2090                  return;
2091              }
2092              Folder openFolder = mWorkspace.getOpenFolder();
2093              // In all these cases, only animate if we&#x27;re already on home
2094              mWorkspace.exitWidgetResizeMode();
2095              if (alreadyOnHome &amp;&amp; mState == State.WORKSPACE &amp;&amp; !mWorkspace.isTouchActive() &amp;&amp;
2096                      openFolder == null &amp;&amp; shouldMoveToDefaultScreenOnHomeIntent()) {
2097                  mWorkspace.moveToDefaultScreen(true);
2098              }
2099  
2100              closeFolder();
2101              exitSpringLoadedDragMode();
2102  
2103              // If we are already on home, then just animate back to the workspace,
2104              // otherwise, just wait until onResume to set the state back to Workspace
2105              if (alreadyOnHome) {
2106                  showWorkspace(true);
2107              } else {
2108                  mOnResumeState = State.WORKSPACE;
2109              }
2110  
2111              final View v = getWindow().peekDecorView();
2112              if (v != null &amp;&amp; v.getWindowToken() != null) {
2113                  InputMethodManager imm = (InputMethodManager)getSystemService(
2114                          INPUT_METHOD_SERVICE);
2115                  imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
2116              }
2117  
2118              // Reset the apps customize page
2119              if (!alreadyOnHome &amp;&amp; mAppsCustomizeTabHost != null) {
2120                  mAppsCustomizeTabHost.reset();
2121              }
2122  
2123              onHomeIntent();
2124          }
2125  
2126          if (DEBUG_RESUME_TIME) {
2127              Log.d(TAG, &quot;Time spent in onNewIntent: &quot; + (System.currentTimeMillis() - startTime));
2128          }
2129      }
2130  
2131      /**
2132       * Override point for subclasses to prevent movement to the default screen when the home
2133       * button is pressed. Used (for example) in GEL, to prevent movement during a search.
2134       */
2135      protected boolean shouldMoveToDefaultScreenOnHomeIntent() {
2136          return true;
2137      }
2138  
2139      /**
2140       * Override point for subclasses to provide custom behaviour for when a home intent is fired.
2141       */
2142      protected void onHomeIntent() {
2143          // Do nothing
2144      }
2145  
2146      @Override
2147      public void onRestoreInstanceState(Bundle state) {
2148          super.onRestoreInstanceState(state);
2149          for (int page: mSynchronouslyBoundPages) {
2150              mWorkspace.restoreInstanceStateForChild(page);
2151          }
2152      }
2153  
2154      @Override
2155      protected void onSaveInstanceState(Bundle outState) {
2156          if (mWorkspace.getChildCount() &gt; 0) {
2157              outState.putInt(RUNTIME_STATE_CURRENT_SCREEN,
2158                      mWorkspace.getCurrentPageOffsetFromCustomContent());
2159          }
2160          super.onSaveInstanceState(outState);
2161  
2162          outState.putInt(RUNTIME_STATE, mState.ordinal());
2163          // We close any open folder since it will not be re-opened, and we need to make sure
2164          // this state is reflected.
2165          closeFolder();
2166  
2167          if (mPendingAddInfo.container != ItemInfo.NO_ID &amp;&amp; mPendingAddInfo.screenId &gt; -1 &amp;&amp;
2168                  mWaitingForResult) {
2169              outState.putLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, mPendingAddInfo.container);
2170              outState.putLong(RUNTIME_STATE_PENDING_ADD_SCREEN, mPendingAddInfo.screenId);
2171              outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_X, mPendingAddInfo.cellX);
2172              outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_Y, mPendingAddInfo.cellY);
2173              outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_X, mPendingAddInfo.spanX);
2174              outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y, mPendingAddInfo.spanY);
2175              outState.putParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO, mPendingAddWidgetInfo);
2176              outState.putInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID, mPendingAddWidgetId);
2177          }
2178  
2179          if (mFolderInfo != null &amp;&amp; mWaitingForResult) {
2180              outState.putBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, true);
2181              outState.putLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID, mFolderInfo.id);
2182          }
2183  
2184          // Save the current AppsCustomize tab
2185          if (mAppsCustomizeTabHost != null) {
2186              AppsCustomizePagedView.ContentType type = mAppsCustomizeContent.getContentType();
2187              String currentTabTag = mAppsCustomizeTabHost.getTabTagForContentType(type);
2188              if (currentTabTag != null) {
2189                  outState.putString(&quot;apps_customize_currentTab&quot;, currentTabTag);
2190              }
2191              int currentIndex = mAppsCustomizeContent.getSaveInstanceStateIndex();
2192              outState.putInt(&quot;apps_customize_currentIndex&quot;, currentIndex);
2193          }
2194          outState.putSerializable(RUNTIME_STATE_VIEW_IDS, mItemIdToViewId);
2195      }
2196  
2197      @Override
2198      public void onDestroy() {
2199          super.onDestroy();
2200  
2201          // Remove all pending runnables
2202          mHandler.removeMessages(ADVANCE_MSG);
2203          mHandler.removeMessages(0);
2204          mWorkspace.removeCallbacks(mBuildLayersRunnable);
2205  
2206          // Stop callbacks from LauncherModel
2207          LauncherAppState app = (LauncherAppState.getInstance());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2208 -        mModel.stopLoader();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2209 -        app.setLauncher(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2210 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2211 +        // It&#x27;s possible to receive onDestroy after a new Launcher activity has</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2212 +        // been created. In this case, don&#x27;t interfere with the new Launcher.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2213 +        if (mModel.isCurrentCallbacks(this)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2214 +            mModel.stopLoader();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2215 +            app.setLauncher(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2216 +        }</span>
2217  
2218          try {
2219              mAppWidgetHost.stopListening();
2220          } catch (NullPointerException ex) {
2221              Log.w(TAG, &quot;problem while stopping AppWidgetHost during Launcher destruction&quot;, ex);
2222          }
2223          mAppWidgetHost = null;
2224  
2225          mWidgetsToAdvance.clear();
2226  
2227          TextKeyListener.getInstance().release();
2228  
2229          // Disconnect any of the callbacks and drawables associated with ItemInfos on the workspace
2230          // to prevent leaking Launcher activities on orientation change.
2231          if (mModel != null) {
2232              mModel.unbindItemInfosAndClearQueuedBindRunnables();
2233          }
2234  
2235          getContentResolver().unregisterContentObserver(mWidgetObserver);
2236          unregisterReceiver(mCloseSystemDialogsReceiver);
2237  
2238          mDragLayer.clearAllResizeFrames();
2239          ((ViewGroup) mWorkspace.getParent()).removeAllViews();
2240          mWorkspace.removeAllWorkspaceScreens();
2241          mWorkspace = null;
2242          mDragController = null;
2243  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2244 +        PackageInstallerCompat.getInstance(this).onStop();</span>
2245          LauncherAnimUtils.onDestroyActivity();
2246      }
2247  
2248      public DragController getDragController() {
2249          return mDragController;
2250      }
2251  
2252      @Override
2253      public void startActivityForResult(Intent intent, int requestCode) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2254 -        if (requestCode &gt;= 0) mWaitingForResult = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2255 +        if (requestCode &gt;= 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2256 +            setWaitingForResult(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2257 +        }</span>
2258          super.startActivityForResult(intent, requestCode);
2259      }
2260  
2261      /**
2262       * Indicates that we want global search for this activity by setting the globalSearch
2263       * argument for {@link #startSearch} to true.
2264       */
2265      @Override
2266      public void startSearch(String initialQuery, boolean selectInitialQuery,
2267              Bundle appSearchData, boolean globalSearch) {
2268  
2269          showWorkspace(true);
2270  
2271          if (initialQuery == null) {
2272              // Use any text typed in the launcher as the initial query
2273              initialQuery = getTypedText();
2274          }
2275          if (appSearchData == null) {
2276              appSearchData = new Bundle();
2277              appSearchData.putString(&quot;source&quot;, &quot;launcher-search&quot;);
2278          }
2279          Rect sourceBounds = new Rect();
2280          if (mSearchDropTargetBar != null) {
2281              sourceBounds = mSearchDropTargetBar.getSearchBarBounds();
2282          }
2283  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2284 -        startSearch(initialQuery, selectInitialQuery,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2285 +        boolean clearTextImmediately = startSearch(initialQuery, selectInitialQuery,</span>
2286                  appSearchData, sourceBounds);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2287 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2288 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2289 -    public void startSearch(String initialQuery,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2290 +        if (clearTextImmediately) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2291 +            clearTypedText();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2292 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2293 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2294 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2295 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2296 +     * Start a text search.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2297 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2298 +     * @return {@code true} if the search will start immediately, so any further keypresses</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2299 +     * will be handled directly by the search UI. {@code false} if {@link Launcher} should continue</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2300 +     * to buffer keypresses.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2301 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2302 +    public boolean startSearch(String initialQuery,</span>
2303              boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2304          startGlobalSearch(initialQuery, selectInitialQuery,
2305                  appSearchData, sourceBounds);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2306 +        return false;</span>
2307      }
2308  
2309      /**
2310       * Starts the global search activity. This code is a copied from SearchManager
2311       */
2312      private void startGlobalSearch(String initialQuery,
2313              boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2314          final SearchManager searchManager =
2315              (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2316          ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
2317          if (globalSearchActivity == null) {
2318              Log.w(TAG, &quot;No global search activity found.&quot;);
2319              return;
2320          }
2321          Intent intent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
2322          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2323          intent.setComponent(globalSearchActivity);
2324          // Make sure that we have a Bundle to put source in
2325          if (appSearchData == null) {
2326              appSearchData = new Bundle();
2327          } else {
2328              appSearchData = new Bundle(appSearchData);
2329          }
2330          // Set source to package name of app that starts global search, if not set already.
2331          if (!appSearchData.containsKey(&quot;source&quot;)) {
2332              appSearchData.putString(&quot;source&quot;, getPackageName());
2333          }
2334          intent.putExtra(SearchManager.APP_DATA, appSearchData);
2335          if (!TextUtils.isEmpty(initialQuery)) {
2336              intent.putExtra(SearchManager.QUERY, initialQuery);
2337          }
2338          if (selectInitialQuery) {
2339              intent.putExtra(SearchManager.EXTRA_SELECT_QUERY, selectInitialQuery);
2340          }
2341          intent.setSourceBounds(sourceBounds);
2342          try {
2343              startActivity(intent);
2344          } catch (ActivityNotFoundException ex) {
2345              Log.e(TAG, &quot;Global search activity not found: &quot; + globalSearchActivity);
2346          }
2347      }
2348  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2349 +    public boolean isOnCustomContent() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2350 +        return mWorkspace.isOnOrMovingToCustomContent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2351 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2352 +</span>
2353      @Override
2354      public boolean onPrepareOptionsMenu(Menu menu) {
2355          super.onPrepareOptionsMenu(menu);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2356 -        showOverviewMode(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2357 +        if (!isOnCustomContent()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2358 +            // Close any open folders</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2359 +            closeFolder();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2360 +            // Stop resizing any widgets</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2361 +            mWorkspace.exitWidgetResizeMode();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2362 +            if (!mWorkspace.isInOverviewMode()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2363 +                // Show the overview mode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2364 +                showOverviewMode(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2365 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2366 +                showWorkspace(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2367 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2368 +        }</span>
2369          return false;
2370      }
2371  
2372      @Override
2373      public boolean onSearchRequested() {
2374          startSearch(null, false, null, true);
2375          // Use a custom animation for launching search
2376          return true;
2377      }
2378  
2379      public boolean isWorkspaceLocked() {
2380          return mWorkspaceLoading || mWaitingForResult;
2381      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2382 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2383 +    public boolean isWorkspaceLoading() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2384 +        return mWorkspaceLoading;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2385 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2386 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2387 +    private void setWorkspaceLoading(boolean value) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2388 +        boolean isLocked = isWorkspaceLocked();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2389 +        mWorkspaceLoading = value;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2390 +        if (isLocked != isWorkspaceLocked()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2391 +            onWorkspaceLockedChanged();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2392 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2393 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2394 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2395 +    private void setWaitingForResult(boolean value) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2396 +        boolean isLocked = isWorkspaceLocked();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2397 +        mWaitingForResult = value;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2398 +        if (isLocked != isWorkspaceLocked()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2399 +            onWorkspaceLockedChanged();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2400 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2401 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2402 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2403 +    protected void onWorkspaceLockedChanged() { }</span>
2404  
2405      private void resetAddInfo() {
2406          mPendingAddInfo.container = ItemInfo.NO_ID;
2407          mPendingAddInfo.screenId = -1;
2408          mPendingAddInfo.cellX = mPendingAddInfo.cellY = -1;
2409          mPendingAddInfo.spanX = mPendingAddInfo.spanY = -1;
2410          mPendingAddInfo.minSpanX = mPendingAddInfo.minSpanY = -1;
2411          mPendingAddInfo.dropPos = null;
2412      }
2413  
2414      void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2415              final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo) {
2416          addAppWidgetImpl(appWidgetId, info, boundWidget, appWidgetInfo, 0);
2417      }
2418  
2419      void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2420              final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo, int
2421              delay) {
2422          if (appWidgetInfo.configure != null) {
2423              mPendingAddWidgetInfo = appWidgetInfo;
2424              mPendingAddWidgetId = appWidgetId;
2425  
2426              // Launch over to configure widget, if needed
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2427 -            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2428 -            intent.setComponent(appWidgetInfo.configure);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2429 -            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2430 -            Utilities.startActivityForResultSafely(this, intent, REQUEST_CREATE_APPWIDGET);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2431 +            mAppWidgetManager.startConfigActivity(appWidgetInfo, appWidgetId, this,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2432 +                    mAppWidgetHost, REQUEST_CREATE_APPWIDGET);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2433 +</span>
2434          } else {
2435              // Otherwise just add it
2436              Runnable onComplete = new Runnable() {
2437                  @Override
2438                  public void run() {
2439                      // Exit spring loaded mode if necessary after adding the widget
2440                      exitSpringLoadedDragModeDelayed(true, EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
2441                              null);
2442                  }
2443              };
2444              completeAddAppWidget(appWidgetId, info.container, info.screenId, boundWidget,
2445                      appWidgetInfo);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2446 -            mWorkspace.removeExtraEmptyScreen(true, onComplete, delay, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2447 +            mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete, delay, false);</span>
2448          }
2449      }
2450  
2451      protected void moveToCustomContentScreen(boolean animate) {
2452          // Close any folders that may be open.
2453          closeFolder();
2454          mWorkspace.moveToCustomContentScreen(animate);
2455      }
2456      /**
2457       * Process a shortcut drop.
2458       *
2459       * @param componentName The name of the component
2460       * @param screenId The ID of the screen where it should be added
2461       * @param cell The cell it should be added to, optional
2462       * @param position The location on the screen where it was dropped, optional
2463       */
2464      void processShortcutFromDrop(ComponentName componentName, long container, long screenId,
2465              int[] cell, int[] loc) {
2466          resetAddInfo();
2467          mPendingAddInfo.container = container;
2468          mPendingAddInfo.screenId = screenId;
2469          mPendingAddInfo.dropPos = loc;
2470  
2471          if (cell != null) {
2472              mPendingAddInfo.cellX = cell[0];
2473              mPendingAddInfo.cellY = cell[1];
2474          }
2475  
2476          Intent createShortcutIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2477          createShortcutIntent.setComponent(componentName);
2478          processShortcut(createShortcutIntent);
2479      }
2480  
2481      /**
2482       * Process a widget drop.
2483       *
2484       * @param info The PendingAppWidgetInfo of the widget being added.
2485       * @param screenId The ID of the screen where it should be added
2486       * @param cell The cell it should be added to, optional
2487       * @param position The location on the screen where it was dropped, optional
2488       */
2489      void addAppWidgetFromDrop(PendingAddWidgetInfo info, long container, long screenId,
2490              int[] cell, int[] span, int[] loc) {
2491          resetAddInfo();
2492          mPendingAddInfo.container = info.container = container;
2493          mPendingAddInfo.screenId = info.screenId = screenId;
2494          mPendingAddInfo.dropPos = loc;
2495          mPendingAddInfo.minSpanX = info.minSpanX;
2496          mPendingAddInfo.minSpanY = info.minSpanY;
2497  
2498          if (cell != null) {
2499              mPendingAddInfo.cellX = cell[0];
2500              mPendingAddInfo.cellY = cell[1];
2501          }
2502          if (span != null) {
2503              mPendingAddInfo.spanX = span[0];
2504              mPendingAddInfo.spanY = span[1];
2505          }
2506  
2507          AppWidgetHostView hostView = info.boundWidget;
2508          int appWidgetId;
2509          if (hostView != null) {
2510              appWidgetId = hostView.getAppWidgetId();
2511              addAppWidgetImpl(appWidgetId, info, hostView, info.info);
2512          } else {
2513              // In this case, we either need to start an activity to get permission to bind
2514              // the widget, or we need to start an activity to configure the widget, or both.
2515              appWidgetId = getAppWidgetHost().allocateAppWidgetId();
2516              Bundle options = info.bindOptions;
2517  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2518 -            boolean success = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2519 -            if (options != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2520 -                success = mAppWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2521 -                        info.componentName, options);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2522 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2523 -                success = mAppWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2524 -                        info.componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2525 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2526 +            boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2527 +                    appWidgetId, info.info, options);</span>
2528              if (success) {
2529                  addAppWidgetImpl(appWidgetId, info, null, info.info);
2530              } else {
2531                  mPendingAddWidgetInfo = info.info;
2532                  Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);
2533                  intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
2534                  intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2535 +                mAppWidgetManager.getUser(mPendingAddWidgetInfo)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2536 +                    .addToIntent(intent, AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE);</span>
2537                  // TODO: we need to make sure that this accounts for the options bundle.
2538                  // intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);
2539                  startActivityForResult(intent, REQUEST_BIND_APPWIDGET);
2540              }
2541          }
2542      }
2543  
2544      void processShortcut(Intent intent) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2545 -        // Handle case where user selected &quot;Applications&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2546 -        String applicationName = getResources().getString(R.string.group_applications);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2547 -        String shortcutName = intent.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2548 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2549 -        if (applicationName != null &amp;&amp; applicationName.equals(shortcutName)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2550 -            Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2551 -            mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2552 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2553 -            Intent pickIntent = new Intent(Intent.ACTION_PICK_ACTIVITY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2554 -            pickIntent.putExtra(Intent.EXTRA_INTENT, mainIntent);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2555 -            pickIntent.putExtra(Intent.EXTRA_TITLE, getText(R.string.title_select_application));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2556 -            Utilities.startActivityForResultSafely(this, pickIntent, REQUEST_PICK_APPLICATION);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2557 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2558 -            Utilities.startActivityForResultSafely(this, intent, REQUEST_CREATE_SHORTCUT);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2559 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2560 +        Utilities.startActivityForResultSafely(this, intent, REQUEST_CREATE_SHORTCUT);</span>
2561      }
2562  
2563      void processWallpaper(Intent intent) {
2564          startActivityForResult(intent, REQUEST_PICK_WALLPAPER);
2565      }
2566  
2567      FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX,
2568              int cellY) {
2569          final FolderInfo folderInfo = new FolderInfo();
2570          folderInfo.title = getText(R.string.folder_name);
2571  
2572          // Update the model
2573          LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId, cellX, cellY,
2574                  false);
2575          sFolders.put(folderInfo.id, folderInfo);
2576  
2577          // Create the view
2578          FolderIcon newFolder =
2579              FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
2580          mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1,
2581                  isWorkspaceLocked());
2582          // Force measure the new folder icon
2583          CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
2584          parent.getShortcutsAndWidgets().measureChild(newFolder);
2585          return newFolder;
2586      }
2587  
2588      void removeFolder(FolderInfo folder) {
2589          sFolders.remove(folder.id);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2590 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2591 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2592 -    protected void startWallpaper() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2593 -        final Intent pickWallpaper = new Intent(Intent.ACTION_SET_WALLPAPER);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2594 -        pickWallpaper.setComponent(getWallpaperPickerComponent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2595 -        startActivityForResult(pickWallpaper, REQUEST_PICK_WALLPAPER);</span>
2596      }
2597  
2598      protected ComponentName getWallpaperPickerComponent() {
2599          return new ComponentName(getPackageName(), LauncherWallpaperPickerActivity.class.getName());
2600      }
2601  
2602      /**
2603       * Registers various content observers. The current implementation registers
2604       * only a favorites observer to keep track of the favorites applications.
2605       */
2606      private void registerContentObservers() {
2607          ContentResolver resolver = getContentResolver();
2608          resolver.registerContentObserver(LauncherProvider.CONTENT_APPWIDGET_RESET_URI,
2609                  true, mWidgetObserver);
2610      }
2611  
2612      @Override
2613      public boolean dispatchKeyEvent(KeyEvent event) {
2614          if (event.getAction() == KeyEvent.ACTION_DOWN) {
2615              switch (event.getKeyCode()) {
2616                  case KeyEvent.KEYCODE_HOME:
2617                      return true;
2618                  case KeyEvent.KEYCODE_VOLUME_DOWN:
2619                      if (isPropertyEnabled(DUMP_STATE_PROPERTY)) {
2620                          dumpState();
2621                          return true;
2622                      }
2623                      break;
2624              }
2625          } else if (event.getAction() == KeyEvent.ACTION_UP) {
2626              switch (event.getKeyCode()) {
2627                  case KeyEvent.KEYCODE_HOME:
2628                      return true;
2629              }
2630          }
2631  
2632          return super.dispatchKeyEvent(event);
2633      }
2634  
2635      @Override
2636      public void onBackPressed() {
2637          if (isAllAppsVisible()) {
2638              if (mAppsCustomizeContent.getContentType() ==
2639                      AppsCustomizePagedView.ContentType.Applications) {
2640                  showWorkspace(true);
2641              } else {
2642                  showOverviewMode(true);
2643              }
2644          } else if (mWorkspace.isInOverviewMode()) {
2645              mWorkspace.exitOverviewMode(true);
2646          } else if (mWorkspace.getOpenFolder() != null) {
2647              Folder openFolder = mWorkspace.getOpenFolder();
2648              if (openFolder.isEditingName()) {
2649                  openFolder.dismissEditingName();
2650              } else {
2651                  closeFolder();
2652              }
2653          } else {
2654              mWorkspace.exitWidgetResizeMode();
2655  
2656              // Back button is a no-op here, but give at least some feedback for the button press
2657              mWorkspace.showOutlinesTemporarily();
2658          }
2659      }
2660  
2661      /**
2662       * Re-listen when widgets are reset.
2663       */
2664      private void onAppWidgetReset() {
2665          if (mAppWidgetHost != null) {
2666              mAppWidgetHost.startListening();
2667          }
2668      }
2669  
2670      /**
2671       * Launches the intent referred by the clicked shortcut.
2672       *
2673       * @param v The view representing the clicked shortcut.
2674       */
2675      public void onClick(View v) {
2676          // Make sure that rogue clicks don&#x27;t get through while allapps is launching, or after the
2677          // view has detached (it&#x27;s possible for this to happen if the view is removed mid touch).
2678          if (v.getWindowToken() == null) {
2679              return;
2680          }
2681  
2682          if (!mWorkspace.isFinishedSwitchingState()) {
2683              return;
2684          }
2685  
2686          if (v instanceof Workspace) {
2687              if (mWorkspace.isInOverviewMode()) {
2688                  mWorkspace.exitOverviewMode(true);
2689              }
2690              return;
2691          }
2692  
2693          if (v instanceof CellLayout) {
2694              if (mWorkspace.isInOverviewMode()) {
2695                  mWorkspace.exitOverviewMode(mWorkspace.indexOfChild(v), true);
2696              }
2697          }
2698  
2699          Object tag = v.getTag();
2700          if (tag instanceof ShortcutInfo) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2701 -            // Open shortcut</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2702 -            final ShortcutInfo shortcut = (ShortcutInfo) tag;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2703 -            final Intent intent = shortcut.intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2704 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2705 -            // Check for special shortcuts</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2706 -            if (intent.getComponent() != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2707 -                final String shortcutClass = intent.getComponent().getClassName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2708 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2709 -                if (shortcutClass.equals(WidgetAdder.class.getName())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2710 -                    showAllApps(true, AppsCustomizePagedView.ContentType.Widgets, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2711 -                    return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2712 -                } else if (shortcutClass.equals(MemoryDumpActivity.class.getName())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2713 -                    MemoryDumpActivity.startDump(this);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2714 -                    return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2715 -                } else if (shortcutClass.equals(ToggleWeightWatcher.class.getName())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2716 -                    toggleShowWeightWatcher();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2717 -                    return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2718 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2719 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2720 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2721 -            // Start activities</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2722 -            int[] pos = new int[2];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2723 -            v.getLocationOnScreen(pos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2724 -            intent.setSourceBounds(new Rect(pos[0], pos[1],</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2725 -                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2726 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2727 -            boolean success = startActivitySafely(v, intent, tag);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2728 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2729 -            mStats.recordLaunch(intent, shortcut);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2730 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2731 -            if (success &amp;&amp; v instanceof BubbleTextView) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2732 -                mWaitingForResume = (BubbleTextView) v;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2733 -                mWaitingForResume.setStayPressed(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2734 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2735 +            onClickAppShortcut(v);</span>
2736          } else if (tag instanceof FolderInfo) {
2737              if (v instanceof FolderIcon) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2738 -                FolderIcon fi = (FolderIcon) v;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2739 -                handleFolderClick(fi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2740 +                onClickFolderIcon(v);</span>
2741              }
2742          } else if (v == mAllAppsButton) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2743 -            if (isAllAppsVisible()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2744 -                showWorkspace(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2745 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2746 -                onClickAllAppsButton(v);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2747 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2748 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2749 +            onClickAllAppsButton(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2750 +        } else if (tag instanceof AppInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2751 +            startAppShortcutOrInfoActivity(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2752 +        } else if (tag instanceof LauncherAppWidgetInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2753 +            if (v instanceof PendingAppWidgetHostView) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2754 +                onClickPendingWidget((PendingAppWidgetHostView) v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2755 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2756 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2757 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2758 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2759 +    public void onClickPagedViewIcon(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2760 +        startAppShortcutOrInfoActivity(v);</span>
2761      }
2762  
2763      public boolean onTouch(View v, MotionEvent event) {
2764          return false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2765 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2766 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2767 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2768 +     * Event handler for the app widget view which has not fully restored.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2769 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2770 +    public void onClickPendingWidget(final PendingAppWidgetHostView v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2771 +        final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2772 +        if (v.isReadyForClickSetup()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2773 +            int widgetId = info.appWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2774 +            AppWidgetProviderInfo appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(widgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2775 +            if (appWidgetInfo != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2776 +                mPendingAddWidgetInfo = appWidgetInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2777 +                mPendingAddInfo.copyFrom(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2778 +                mPendingAddWidgetId = widgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2779 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2780 +                AppWidgetManagerCompat.getInstance(this).startConfigActivity(appWidgetInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2781 +                        info.appWidgetId, this, mAppWidgetHost, REQUEST_RECONFIGURE_APPWIDGET);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2782 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2783 +        } else if (info.installProgress &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2784 +            // The install has not been queued</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2785 +            final String packageName = info.providerName.getPackageName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2786 +            showBrokenAppInstallDialog(packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2787 +                new DialogInterface.OnClickListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2788 +                    public void onClick(DialogInterface dialog, int id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2789 +                        startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2790 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2791 +                });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2792 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2793 +            // Download has started.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2794 +            final String packageName = info.providerName.getPackageName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2795 +            startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2796 +        }</span>
2797      }
2798  
2799      /**
2800       * Event handler for the search button
2801       *
2802       * @param v The view that was clicked.
2803       */
2804      public void onClickSearchButton(View v) {
2805          v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2806  
2807          onSearchRequested();
2808      }
2809  
2810      /**
2811       * Event handler for the voice button
2812       *
2813       * @param v The view that was clicked.
2814       */
2815      public void onClickVoiceButton(View v) {
2816          v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2817  
2818          startVoice();
2819      }
2820  
2821      public void startVoice() {
2822          try {
2823              final SearchManager searchManager =
2824                      (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2825              ComponentName activityName = searchManager.getGlobalSearchActivity();
2826              Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2827              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2828              if (activityName != null) {
2829                  intent.setPackage(activityName.getPackageName());
2830              }
2831              startActivity(null, intent, &quot;onClickVoiceButton&quot;);
2832          } catch (ActivityNotFoundException e) {
2833              Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2834              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2835              startActivitySafely(null, intent, &quot;onClickVoiceButton&quot;);
2836          }
2837      }
2838  
2839      /**
2840       * Event handler for the &quot;grid&quot; button that appears on the home screen, which
2841       * enters all apps mode.
2842       *
2843       * @param v The view that was clicked.
2844       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2845 -    public void onClickAllAppsButton(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2846 -        showAllApps(true, AppsCustomizePagedView.ContentType.Applications, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2847 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2848 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2849 -    public void onTouchDownAllAppsButton(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2850 -        // Provide the same haptic feedback that the system offers for virtual keys.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2851 -        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2852 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2853 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2854 -    public void performHapticFeedbackOnTouchDown(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2855 -        // Provide the same haptic feedback that the system offers for virtual keys.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2856 -        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2857 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2858 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2859 -    public View.OnTouchListener getHapticFeedbackTouchListener() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2860 -        if (mHapticFeedbackTouchListener == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2861 -            mHapticFeedbackTouchListener = new View.OnTouchListener() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2862 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2863 -                public boolean onTouch(View v, MotionEvent event) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2864 -                    if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2865 -                        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2866 +    protected void onClickAllAppsButton(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2867 +        if (LOGD) Log.d(TAG, &quot;onClickAllAppsButton&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2868 +        if (isAllAppsVisible()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2869 +            showWorkspace(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2870 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2871 +            showAllApps(true, AppsCustomizePagedView.ContentType.Applications, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2872 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2873 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2874 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2875 +    private void showBrokenAppInstallDialog(final String packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2876 +            DialogInterface.OnClickListener onSearchClickListener) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2877 +        new AlertDialog.Builder(new ContextThemeWrapper(this, android.R.style.Theme_DeviceDefault))</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2878 +            .setTitle(R.string.abandoned_promises_title)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2879 +            .setMessage(R.string.abandoned_promise_explanation)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2880 +            .setPositiveButton(R.string.abandoned_search, onSearchClickListener)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2881 +            .setNeutralButton(R.string.abandoned_clean_this,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2882 +                new DialogInterface.OnClickListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2883 +                    public void onClick(DialogInterface dialog, int id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2884 +                        final UserHandleCompat user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2885 +                        mWorkspace.removeAbandonedPromise(packageName, user);</span>
2886                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2887 -                    return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2888 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2889 -            };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2890 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2891 -        return mHapticFeedbackTouchListener;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2892 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2893 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2894 -    public void onClickAppMarketButton(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2895 -        if (!DISABLE_MARKET_BUTTON) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2896 -            if (mAppMarketIntent != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2897 -                startActivitySafely(v, mAppMarketIntent, &quot;app market&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2898 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2899 -                Log.e(TAG, &quot;Invalid app market intent.&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2900 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2901 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2902 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2903 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2904 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2905 -     * Called when the user stops interacting with the launcher.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2906 -     * This implies that the user is now on the homescreen and is not doing housekeeping.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2907 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2908 -    protected void onInteractionEnd() {}</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2909 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2910 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2911 -     * Called when the user starts interacting with the launcher.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2912 -     * The possible interactions are:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2913 -     *  - open all apps</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2914 -     *  - reorder an app shortcut, or a widget</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2915 -     *  - open the overview mode.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2916 -     * This is a good time to stop doing things that only make sense</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2917 -     * when the user is on the homescreen and not doing housekeeping.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2918 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2919 -    protected void onInteractionBegin() {}</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2920 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2921 -    void startApplicationDetailsActivity(ComponentName componentName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2922 -        String packageName = componentName.getPackageName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2923 -        Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2924 -                Uri.fromParts(&quot;package&quot;, packageName, null));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2925 -        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2926 -        startActivitySafely(null, intent, &quot;startApplicationDetailsActivity&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2927 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2928 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2929 -    // returns true if the activity was started</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2930 -    boolean startApplicationUninstallActivity(ComponentName componentName, int flags) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2931 -        if ((flags &amp; AppInfo.DOWNLOADED_FLAG) == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2932 -            // System applications cannot be installed. For now, show a toast explaining that.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2933 -            // We may give them the option of disabling apps this way.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2934 -            int messageId = R.string.uninstall_system_app_text;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2935 -            Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2936 -            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2937 +                })</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2938 +            .create().show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2939 +        return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2940 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2941 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2942 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2943 +     * Event handler for an app shortcut click.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2944 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2945 +     * @param v The view that was clicked. Must be a tagged with a {@link ShortcutInfo}.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2946 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2947 +    protected void onClickAppShortcut(final View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2948 +        if (LOGD) Log.d(TAG, &quot;onClickAppShortcut&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2949 +        Object tag = v.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2950 +        if (!(tag instanceof ShortcutInfo)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2951 +            throw new IllegalArgumentException(&quot;Input must be a Shortcut&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2952 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2953 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2954 +        // Open shortcut</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2955 +        final ShortcutInfo shortcut = (ShortcutInfo) tag;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2956 +        final Intent intent = shortcut.intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2957 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2958 +        // Check for special shortcuts</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2959 +        if (intent.getComponent() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2960 +            final String shortcutClass = intent.getComponent().getClassName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2961 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2962 +            if (shortcutClass.equals(MemoryDumpActivity.class.getName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2963 +                MemoryDumpActivity.startDump(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2964 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2965 +            } else if (shortcutClass.equals(ToggleWeightWatcher.class.getName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2966 +                toggleShowWeightWatcher();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2967 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2968 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2969 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2970 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2971 +        // Check for abandoned promise</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2972 +        if ((v instanceof BubbleTextView)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2973 +                &amp;&amp; shortcut.isPromise()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2974 +                &amp;&amp; !shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2975 +            showBrokenAppInstallDialog(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2976 +                    shortcut.getTargetComponent().getPackageName(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2977 +                    new DialogInterface.OnClickListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2978 +                        public void onClick(DialogInterface dialog, int id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2979 +                            startAppShortcutOrInfoActivity(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2980 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2981 +                    });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2982 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2983 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2984 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2985 +        // Start activities</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2986 +        startAppShortcutOrInfoActivity(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2987 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2988 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2989 +    private void startAppShortcutOrInfoActivity(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2990 +        Object tag = v.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2991 +        final ShortcutInfo shortcut;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2992 +        final Intent intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2993 +        if (tag instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2994 +            shortcut = (ShortcutInfo) tag;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2995 +            intent = shortcut.intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2996 +            int[] pos = new int[2];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2997 +            v.getLocationOnScreen(pos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2998 +            intent.setSourceBounds(new Rect(pos[0], pos[1],</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2999 +                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3000 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3001 +        } else if (tag instanceof AppInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3002 +            shortcut = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3003 +            intent = ((AppInfo) tag).intent;</span>
3004          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3005 -            String packageName = componentName.getPackageName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3006 -            String className = componentName.getClassName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3007 -            Intent intent = new Intent(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3008 -                    Intent.ACTION_DELETE, Uri.fromParts(&quot;package&quot;, packageName, className));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3009 -            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3010 -                    Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3011 -            startActivity(intent);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3012 -            return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3013 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3014 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3015 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3016 -    boolean startActivity(View v, Intent intent, Object tag) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3017 -        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3018 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3019 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3020 -            // Only launch using the new animation if the shortcut has not opted out (this is a</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3021 -            // private contract between launcher and may be ignored in the future).</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3022 -            boolean useLaunchAnimation = (v != null) &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3023 -                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3024 -            if (useLaunchAnimation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3025 -                ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3026 -                        v.getMeasuredWidth(), v.getMeasuredHeight());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3027 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3028 -                startActivity(intent, opts.toBundle());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3029 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3030 -                startActivity(intent);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3031 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3032 -            return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3033 -        } catch (SecurityException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3034 -            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3035 -            Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3036 -                    &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3037 -                    &quot;or use the exported attribute for this activity. &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3038 -                    + &quot;tag=&quot;+ tag + &quot; intent=&quot; + intent, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3039 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3040 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3041 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3042 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3043 -    boolean startActivitySafely(View v, Intent intent, Object tag) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3044 -        boolean success = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3045 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3046 -            success = startActivity(v, intent, tag);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3047 -        } catch (ActivityNotFoundException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3048 -            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3049 -            Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3050 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3051 -        return success;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3052 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3053 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3054 -    private void handleFolderClick(FolderIcon folderIcon) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3055 +            throw new IllegalArgumentException(&quot;Input must be a Shortcut or AppInfo&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3056 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3057 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3058 +        boolean success = startActivitySafely(v, intent, tag);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3059 +        mStats.recordLaunch(intent, shortcut);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3060 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3061 +        if (success &amp;&amp; v instanceof BubbleTextView) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3062 +            mWaitingForResume = (BubbleTextView) v;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3063 +            mWaitingForResume.setStayPressed(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3064 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3065 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3066 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3067 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3068 +     * Event handler for a folder icon click.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3069 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3070 +     * @param v The view that was clicked. Must be an instance of {@link FolderIcon}.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3071 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3072 +    protected void onClickFolderIcon(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3073 +        if (LOGD) Log.d(TAG, &quot;onClickFolder&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3074 +        if (!(v instanceof FolderIcon)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3075 +            throw new IllegalArgumentException(&quot;Input must be a FolderIcon&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3076 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3077 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3078 +        FolderIcon folderIcon = (FolderIcon) v;</span>
3079          final FolderInfo info = folderIcon.getFolderInfo();
3080          Folder openFolder = mWorkspace.getFolderForTag(info);
3081  
3082          // If the folder info reports that the associated folder is open, then verify that
3083          // it is actually opened. There have been a few instances where this gets out of sync.
3084          if (info.opened &amp;&amp; openFolder == null) {
3085              Log.d(TAG, &quot;Folder info marked as open, but associated folder is not open. Screen: &quot;
3086                      + info.screenId + &quot; (&quot; + info.cellX + &quot;, &quot; + info.cellY + &quot;)&quot;);
3087              info.opened = false;
3088          }
3089  
3090          if (!info.opened &amp;&amp; !folderIcon.getFolder().isDestroyed()) {
3091              // Close any open folder
3092              closeFolder();
3093              // Open the requested folder
3094              openFolder(folderIcon);
3095          } else {
3096              // Find the open folder...
3097              int folderScreen;
3098              if (openFolder != null) {
3099                  folderScreen = mWorkspace.getPageForView(openFolder);
3100                  // .. and close it
3101                  closeFolder(openFolder);
3102                  if (folderScreen != mWorkspace.getCurrentPage()) {
3103                      // Close any folder open on the current screen
3104                      closeFolder();
3105                      // Pull the folder onto this screen
3106                      openFolder(folderIcon);
3107                  }
3108              }
3109          }
3110      }
3111  
3112      /**
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3113 +     * Event handler for the (Add) Widgets button that appears after a long press</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3114 +     * on the home screen.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3115 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3116 +    protected void onClickAddWidgetButton(View view) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3117 +        if (LOGD) Log.d(TAG, &quot;onClickAddWidgetButton&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3118 +        showAllApps(true, AppsCustomizePagedView.ContentType.Widgets, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3119 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3120 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3121 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3122 +     * Event handler for the wallpaper picker button that appears after a long press</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3123 +     * on the home screen.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3124 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3125 +    protected void onClickWallpaperPicker(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3126 +        if (LOGD) Log.d(TAG, &quot;onClickWallpaperPicker&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3127 +        final Intent pickWallpaper = new Intent(Intent.ACTION_SET_WALLPAPER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3128 +        pickWallpaper.setComponent(getWallpaperPickerComponent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3129 +        startActivityForResult(pickWallpaper, REQUEST_PICK_WALLPAPER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3130 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3131 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3132 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3133 +     * Event handler for a click on the settings button that appears after a long press</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3134 +     * on the home screen.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3135 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3136 +    protected void onClickSettingsButton(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3137 +        if (LOGD) Log.d(TAG, &quot;onClickSettingsButton&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3138 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3139 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3140 +    public void onTouchDownAllAppsButton(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3141 +        // Provide the same haptic feedback that the system offers for virtual keys.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3142 +        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3143 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3144 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3145 +    public void performHapticFeedbackOnTouchDown(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3146 +        // Provide the same haptic feedback that the system offers for virtual keys.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3147 +        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3148 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3149 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3150 +    public View.OnTouchListener getHapticFeedbackTouchListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3151 +        if (mHapticFeedbackTouchListener == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3152 +            mHapticFeedbackTouchListener = new View.OnTouchListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3153 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3154 +                public boolean onTouch(View v, MotionEvent event) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3155 +                    if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3156 +                        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3157 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3158 +                    return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3159 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3160 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3161 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3162 +        return mHapticFeedbackTouchListener;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3163 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3164 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3165 +    public void onDragStarted(View view) {}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3166 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3167 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3168 +     * Called when the user stops interacting with the launcher.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3169 +     * This implies that the user is now on the homescreen and is not doing housekeeping.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3170 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3171 +    protected void onInteractionEnd() {}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3172 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3173 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3174 +     * Called when the user starts interacting with the launcher.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3175 +     * The possible interactions are:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3176 +     *  - open all apps</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3177 +     *  - reorder an app shortcut, or a widget</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3178 +     *  - open the overview mode.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3179 +     * This is a good time to stop doing things that only make sense</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3180 +     * when the user is on the homescreen and not doing housekeeping.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3181 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3182 +    protected void onInteractionBegin() {}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3183 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3184 +    void startApplicationDetailsActivity(ComponentName componentName, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3185 +        String packageName = componentName.getPackageName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3186 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3187 +            LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3188 +            UserManagerCompat userManager = UserManagerCompat.getInstance(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3189 +            launcherApps.showAppDetailsForProfile(componentName, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3190 +        } catch (SecurityException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3191 +            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3192 +            Log.e(TAG, &quot;Launcher does not have permission to launch settings&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3193 +        } catch (ActivityNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3194 +            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3195 +            Log.e(TAG, &quot;Unable to launch settings&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3196 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3197 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3198 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3199 +    // returns true if the activity was started</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3200 +    boolean startApplicationUninstallActivity(ComponentName componentName, int flags,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3201 +            UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3202 +        if ((flags &amp; AppInfo.DOWNLOADED_FLAG) == 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3203 +            // System applications cannot be installed. For now, show a toast explaining that.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3204 +            // We may give them the option of disabling apps this way.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3205 +            int messageId = R.string.uninstall_system_app_text;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3206 +            Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3207 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3208 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3209 +            String packageName = componentName.getPackageName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3210 +            String className = componentName.getClassName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3211 +            Intent intent = new Intent(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3212 +                    Intent.ACTION_DELETE, Uri.fromParts(&quot;package&quot;, packageName, className));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3213 +            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3214 +                    Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3215 +            if (user != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3216 +                user.addToIntent(intent, Intent.EXTRA_USER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3217 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3218 +            startActivity(intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3219 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3220 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3221 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3222 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3223 +    boolean startActivity(View v, Intent intent, Object tag) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3224 +        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3225 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3226 +            // Only launch using the new animation if the shortcut has not opted out (this is a</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3227 +            // private contract between launcher and may be ignored in the future).</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3228 +            boolean useLaunchAnimation = (v != null) &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3229 +                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3230 +            LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3231 +            UserManagerCompat userManager = UserManagerCompat.getInstance(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3232 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3233 +            UserHandleCompat user = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3234 +            if (intent.hasExtra(AppInfo.EXTRA_PROFILE)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3235 +                long serialNumber = intent.getLongExtra(AppInfo.EXTRA_PROFILE, -1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3236 +                user = userManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3237 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3238 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3239 +            Bundle optsBundle = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3240 +            if (useLaunchAnimation) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3241 +                ActivityOptions opts = Utilities.isLmpOrAbove() ?</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3242 +                        ActivityOptions.makeCustomAnimation(this, R.anim.task_open_enter, R.anim.no_anim) :</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="3243 +                        ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());">3243 +                        ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getMeasuredWidth(), v.getMeasuredHeight())🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3244 +                optsBundle = opts.toBundle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3245 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3246 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3247 +            if (user == null || user.equals(UserHandleCompat.myUserHandle())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3248 +                // Could be launching some bookkeeping activity</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3249 +                startActivity(intent, optsBundle);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3250 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3251 +                // TODO Component can be null when shortcuts are supported for secondary user</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3252 +                launcherApps.startActivityForProfile(intent.getComponent(), user,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3253 +                        intent.getSourceBounds(), optsBundle);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3254 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3255 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3256 +        } catch (SecurityException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3257 +            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3258 +            Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3259 +                    &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3260 +                    &quot;or use the exported attribute for this activity. &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3261 +                    + &quot;tag=&quot;+ tag + &quot; intent=&quot; + intent, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3262 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3263 +        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3264 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3265 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3266 +    boolean startActivitySafely(View v, Intent intent, Object tag) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3267 +        boolean success = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3268 +        if (mIsSafeModeEnabled &amp;&amp; !Utilities.isSystemApp(this, intent)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3269 +            Toast.makeText(this, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3270 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3271 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3272 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3273 +            success = startActivity(v, intent, tag);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3274 +        } catch (ActivityNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3275 +            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3276 +            Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3277 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3278 +        return success;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3279 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3280 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3281 +    /**</span>
3282       * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView
3283       * in the DragLayer in the exact absolute location of the original FolderIcon.
3284       */
3285      private void copyFolderIconToImage(FolderIcon fi) {
3286          final int width = fi.getMeasuredWidth();
3287          final int height = fi.getMeasuredHeight();
3288  
3289          // Lazy load ImageView, Bitmap and Canvas
3290          if (mFolderIconImageView == null) {
3291              mFolderIconImageView = new ImageView(this);
3292          }
3293          if (mFolderIconBitmap == null || mFolderIconBitmap.getWidth() != width ||
3294                  mFolderIconBitmap.getHeight() != height) {
3295              mFolderIconBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
3296              mFolderIconCanvas = new Canvas(mFolderIconBitmap);
3297          }
3298  
3299          DragLayer.LayoutParams lp;
3300          if (mFolderIconImageView.getLayoutParams() instanceof DragLayer.LayoutParams) {
3301              lp = (DragLayer.LayoutParams) mFolderIconImageView.getLayoutParams();
3302          } else {
3303              lp = new DragLayer.LayoutParams(width, height);
3304          }
3305  
3306          // The layout from which the folder is being opened may be scaled, adjust the starting
3307          // view size by this scale factor.
3308          float scale = mDragLayer.getDescendantRectRelativeToSelf(fi, mRectForFolderAnimation);
3309          lp.customPosition = true;
3310          lp.x = mRectForFolderAnimation.left;
3311          lp.y = mRectForFolderAnimation.top;
3312          lp.width = (int) (scale * width);
3313          lp.height = (int) (scale * height);
3314  
3315          mFolderIconCanvas.drawColor(0, PorterDuff.Mode.CLEAR);
3316          fi.draw(mFolderIconCanvas);
3317          mFolderIconImageView.setImageBitmap(mFolderIconBitmap);
3318          if (fi.getFolder() != null) {
3319              mFolderIconImageView.setPivotX(fi.getFolder().getPivotXForIconAnimation());
3320              mFolderIconImageView.setPivotY(fi.getFolder().getPivotYForIconAnimation());
3321          }
3322          // Just in case this image view is still in the drag layer from a previous animation,
3323          // we remove it and re-add it.
3324          if (mDragLayer.indexOfChild(mFolderIconImageView) != -1) {
3325              mDragLayer.removeView(mFolderIconImageView);
3326          }
3327          mDragLayer.addView(mFolderIconImageView, lp);
3328          if (fi.getFolder() != null) {
3329              fi.getFolder().bringToFront();
3330          }
3331      }
3332  
3333      private void growAndFadeOutFolderIcon(FolderIcon fi) {
3334          if (fi == null) return;
3335          PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0);
3336          PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.5f);
3337          PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.5f);
3338  
3339          FolderInfo info = (FolderInfo) fi.getTag();
3340          if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
3341              CellLayout cl = (CellLayout) fi.getParent().getParent();
3342              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) fi.getLayoutParams();
3343              cl.setFolderLeaveBehindCell(lp.cellX, lp.cellY);
3344          }
3345  
3346          // Push an ImageView copy of the FolderIcon into the DragLayer and hide the original
3347          copyFolderIconToImage(fi);
3348          fi.setVisibility(View.INVISIBLE);
3349  
3350          ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
3351                  scaleX, scaleY);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3352 -        oa.setDuration(getResources().getInteger(R.integer.config_folderAnimDuration));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3353 +        if (Utilities.isLmpOrAbove()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3354 +            oa.setInterpolator(new LogDecelerateInterpolator(100, 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3355 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3356 +        oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));</span>
3357          oa.start();
3358      }
3359  
3360      private void shrinkAndFadeInFolderIcon(final FolderIcon fi) {
3361          if (fi == null) return;
3362          PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f);
3363          PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f);
3364          PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.0f);
3365  
3366          final CellLayout cl = (CellLayout) fi.getParent().getParent();
3367  
3368          // We remove and re-draw the FolderIcon in-case it has changed
3369          mDragLayer.removeView(mFolderIconImageView);
3370          copyFolderIconToImage(fi);
3371          ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
3372                  scaleX, scaleY);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3373 -        oa.setDuration(getResources().getInteger(R.integer.config_folderAnimDuration));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3374 +        oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));</span>
3375          oa.addListener(new AnimatorListenerAdapter() {
3376              @Override
3377              public void onAnimationEnd(Animator animation) {
3378                  if (cl != null) {
3379                      cl.clearFolderLeaveBehind();
3380                      // Remove the ImageView copy of the FolderIcon and make the original visible.
3381                      mDragLayer.removeView(mFolderIconImageView);
3382                      fi.setVisibility(View.VISIBLE);
3383                  }
3384              }
3385          });
3386          oa.start();
3387      }
3388  
3389      /**
3390       * Opens the user folder described by the specified tag. The opening of the folder
3391       * is animated relative to the specified View. If the View is null, no animation
3392       * is played.
3393       *
3394       * @param folderInfo The FolderInfo describing the folder to open.
3395       */
3396      public void openFolder(FolderIcon folderIcon) {
3397          Folder folder = folderIcon.getFolder();
3398          FolderInfo info = folder.mInfo;
3399  
3400          info.opened = true;
3401  
3402          // Just verify that the folder hasn&#x27;t already been added to the DragLayer.
3403          // There was a one-off crash where the folder had a parent already.
3404          if (folder.getParent() == null) {
3405              mDragLayer.addView(folder);
3406              mDragController.addDropTarget((DropTarget) folder);
3407          } else {
3408              Log.w(TAG, &quot;Opening folder (&quot; + folder + &quot;) which already has a parent (&quot; +
3409                      folder.getParent() + &quot;).&quot;);
3410          }
3411          folder.animateOpen();
3412          growAndFadeOutFolderIcon(folderIcon);
3413  
3414          // Notify the accessibility manager that this folder &quot;window&quot; has appeared and occluded
3415          // the workspace items
3416          folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3417          getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
3418      }
3419  
3420      public void closeFolder() {
3421          Folder folder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
3422          if (folder != null) {
3423              if (folder.isEditingName()) {
3424                  folder.dismissEditingName();
3425              }
3426              closeFolder(folder);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3427 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3428 -            // Dismiss the folder cling</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3429 -            dismissFolderCling(null);</span>

3430          }
3431      }
3432  
3433      void closeFolder(Folder folder) {
3434          folder.getInfo().opened = false;
3435  
3436          ViewGroup parent = (ViewGroup) folder.getParent().getParent();
3437          if (parent != null) {
3438              FolderIcon fi = (FolderIcon) mWorkspace.getViewForTag(folder.mInfo);
3439              shrinkAndFadeInFolderIcon(fi);
3440          }
3441          folder.animateClosed();
3442  
3443          // Notify the accessibility manager that this folder &quot;window&quot; has disappeard and no
3444          // longer occludeds the workspace items
3445          getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3446      }
3447  
3448      public boolean onLongClick(View v) {
3449          if (!isDraggingEnabled()) return false;
3450          if (isWorkspaceLocked()) return false;
3451          if (mState != State.WORKSPACE) return false;
3452  
3453          if (v instanceof Workspace) {
3454              if (!mWorkspace.isInOverviewMode()) {
3455                  if (mWorkspace.enterOverviewMode()) {
3456                      mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
3457                              HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
3458                      return true;
3459                  } else {
3460                      return false;
3461                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3462 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3463 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3464 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3465 -        if (!(v instanceof CellLayout)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3466 -            v = (View) v.getParent().getParent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3467 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3468 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3469 -        resetAddInfo();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3470 -        CellLayout.CellInfo longClickCellInfo = (CellLayout.CellInfo) v.getTag();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3471 -        // This happens when long clicking an item with the dpad/trackball</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3472 -        if (longClickCellInfo == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3473 -            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3474 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3475 +                return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3476 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3477 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3478 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3479 +        CellLayout.CellInfo longClickCellInfo = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3480 +        View itemUnderLongClick = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3481 +        if (v.getTag() instanceof ItemInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3482 +            ItemInfo info = (ItemInfo) v.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3483 +            longClickCellInfo = new CellLayout.CellInfo(v, info);;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3484 +            itemUnderLongClick = longClickCellInfo.cell;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3485 +            resetAddInfo();</span>
3486          }
3487  
3488          // The hotseat touch handling does not go through Workspace, and we always allow long press
3489          // on hotseat items.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3490 -        final View itemUnderLongClick = longClickCellInfo.cell;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3491 -        boolean allowLongPress = isHotseatLayout(v) || mWorkspace.allowLongPress();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3492 +        final boolean inHotseat = isHotseatLayout(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3493 +        boolean allowLongPress = inHotseat || mWorkspace.allowLongPress();</span>
3494          if (allowLongPress &amp;&amp; !mDragController.isDragging()) {
3495              if (itemUnderLongClick == null) {
3496                  // User long pressed on empty space
3497                  mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
3498                          HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3499 -                // Disabling reordering until we sort out some issues.</span>
3500                  if (mWorkspace.isInOverviewMode()) {
3501                      mWorkspace.startReordering(v);
3502                  } else {
3503                      mWorkspace.enterOverviewMode();
3504                  }
3505              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3506 -                if (!(itemUnderLongClick instanceof Folder)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3507 +                final boolean isAllAppsButton = inHotseat &amp;&amp; isAllAppsButtonRank(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3508 +                        mHotseat.getOrderInHotseat(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3509 +                                longClickCellInfo.cellX,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3510 +                                longClickCellInfo.cellY));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3511 +                if (!(itemUnderLongClick instanceof Folder || isAllAppsButton)) {</span>
3512                      // User long pressed on an item
3513                      mWorkspace.startDrag(longClickCellInfo);
3514                  }
3515              }
3516          }
3517          return true;
3518      }
3519  
3520      boolean isHotseatLayout(View layout) {
3521          return mHotseat != null &amp;&amp; layout != null &amp;&amp;
3522                  (layout instanceof CellLayout) &amp;&amp; (layout == mHotseat.getLayout());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3523 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3524 -    Hotseat getHotseat() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3525 -        return mHotseat;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3526 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3527 -    View getOverviewPanel() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3528 -        return mOverviewPanel;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3529 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3530 -    SearchDropTargetBar getSearchBar() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3531 -        return mSearchDropTargetBar;</span>
3532      }
3533  
3534      /**
3535       * Returns the CellLayout of the specified container at the specified screen.
3536       */
3537      CellLayout getCellLayout(long container, long screenId) {
3538          if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
3539              if (mHotseat != null) {
3540                  return mHotseat.getLayout();
3541              } else {
3542                  return null;
3543              }
3544          } else {
3545              return (CellLayout) mWorkspace.getScreenWithId(screenId);
3546          }
3547      }
3548  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3549 -    Workspace getWorkspace() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3550 -        return mWorkspace;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3551 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3552 -</span>
3553      public boolean isAllAppsVisible() {
3554          return (mState == State.APPS_CUSTOMIZE) || (mOnResumeState == State.APPS_CUSTOMIZE);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3555 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3556 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3557 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3558 -     * Helper method for the cameraZoomIn/cameraZoomOut animations</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3559 -     * @param view The view being animated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3560 -     * @param scaleFactor The scale factor used for the zoom</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3561 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3562 -    private void setPivotsForZoom(View view, float scaleFactor) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3563 -        view.setPivotX(view.getWidth() / 2.0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3564 -        view.setPivotY(view.getHeight() / 2.0f);</span>
3565      }
3566  
3567      private void setWorkspaceBackground(boolean workspace) {
3568          mLauncherView.setBackground(workspace ?
3569                  mWorkspaceBackgroundDrawable : null);
3570      }
3571  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3572 -    void updateWallpaperVisibility(boolean visible) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3573 +    protected void changeWallpaperVisiblity(boolean visible) {</span>
3574          int wpflags = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
3575          int curflags = getWindow().getAttributes().flags
3576                  &amp; WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
3577          if (wpflags != curflags) {
3578              getWindow().setFlags(wpflags, WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
3579          }
3580          setWorkspaceBackground(visible);
3581      }
3582  
3583      private void dispatchOnLauncherTransitionPrepare(View v, boolean animated, boolean toWorkspace) {
3584          if (v instanceof LauncherTransitionable) {
3585              ((LauncherTransitionable) v).onLauncherTransitionPrepare(this, animated, toWorkspace);
3586          }
3587      }
3588  
3589      private void dispatchOnLauncherTransitionStart(View v, boolean animated, boolean toWorkspace) {
3590          if (v instanceof LauncherTransitionable) {
3591              ((LauncherTransitionable) v).onLauncherTransitionStart(this, animated, toWorkspace);
3592          }
3593  
3594          // Update the workspace transition step as well
3595          dispatchOnLauncherTransitionStep(v, 0f);
3596      }
3597  
3598      private void dispatchOnLauncherTransitionStep(View v, float t) {
3599          if (v instanceof LauncherTransitionable) {
3600              ((LauncherTransitionable) v).onLauncherTransitionStep(this, t);
3601          }
3602      }
3603  
3604      private void dispatchOnLauncherTransitionEnd(View v, boolean animated, boolean toWorkspace) {
3605          if (v instanceof LauncherTransitionable) {
3606              ((LauncherTransitionable) v).onLauncherTransitionEnd(this, animated, toWorkspace);
3607          }
3608  
3609          // Update the workspace transition step as well
3610          dispatchOnLauncherTransitionStep(v, 1f);
3611      }
3612  
3613      /**
3614       * Things to test when changing the following seven functions.
3615       *   - Home from workspace
3616       *          - from center screen
3617       *          - from other screens
3618       *   - Home from all apps
3619       *          - from center screen
3620       *          - from other screens
3621       *   - Back from all apps
3622       *          - from center screen
3623       *          - from other screens
3624       *   - Launch app from workspace and quit
3625       *          - with back
3626       *          - with home
3627       *   - Launch app from all apps and quit
3628       *          - with back
3629       *          - with home
3630       *   - Go to a screen that&#x27;s not the default, then all
3631       *     apps, and launch and app, and go back
3632       *          - with back
3633       *          -with home
3634       *   - On workspace, long press power and go back
3635       *          - with back
3636       *          - with home
3637       *   - On all apps, long press power and go back
3638       *          - with back
3639       *          - with home
3640       *   - On workspace, power off
3641       *   - On all apps, power off
3642       *   - Launch an app and turn off the screen while in that app
3643       *          - Go back with home key
3644       *          - Go back with back key  TODO: make this not go to workspace
3645       *          - From all apps
3646       *          - From workspace
3647       *   - Enter and exit car mode (becuase it causes an extra configuration changed)
3648       *          - From all apps
3649       *          - From the center workspace
3650       *          - From another workspace
3651       */
3652  
3653      /**
3654       * Zoom the camera out from the workspace to reveal &#x27;toView&#x27;.
3655       * Assumes that the view to show is anchored at either the very top or very bottom
3656       * of the screen.
3657       */
3658      private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded) {
3659          AppsCustomizePagedView.ContentType contentType = mAppsCustomizeContent.getContentType();
3660          showAppsCustomizeHelper(animated, springLoaded, contentType);
3661      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3662 +</span>
3663      private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded,
3664                                           final AppsCustomizePagedView.ContentType contentType) {
3665          if (mStateAnimation != null) {
3666              mStateAnimation.setDuration(0);
3667              mStateAnimation.cancel();
3668              mStateAnimation = null;
3669          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3670 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3671 +        boolean material = Utilities.isLmpOrAbove();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3672 +</span>
3673          final Resources res = getResources();
3674  
3675          final int duration = res.getInteger(R.integer.config_appsCustomizeZoomInTime);
3676          final int fadeDuration = res.getInteger(R.integer.config_appsCustomizeFadeInTime);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3677 +        final int revealDuration = res.getInteger(R.integer.config_appsCustomizeRevealTime);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3678 +        final int itemsAlphaStagger =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3679 +                res.getInteger(R.integer.config_appsCustomizeItemsAlphaStagger);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3680 +</span>
3681          final float scale = (float) res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3682          final View fromView = mWorkspace;
3683          final AppsCustomizeTabHost toView = mAppsCustomizeTabHost;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3684 -        final int startDelay =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3685 -                res.getInteger(R.integer.config_workspaceAppsCustomizeAnimationStagger);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3686 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3687 -        setPivotsForZoom(toView, scale);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3688 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3689 -        // Shrink workspaces away if going to AppsCustomize from workspace</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3690 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3691 +        final ArrayList&lt;View&gt; layerViews = new ArrayList&lt;View&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3692 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3693 +        Workspace.State workspaceState = contentType == AppsCustomizePagedView.ContentType.Widgets ?</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3694 +                Workspace.State.OVERVIEW_HIDDEN : Workspace.State.NORMAL_HIDDEN;</span>
3695          Animator workspaceAnim =
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3696 -                mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, animated);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3697 -        if (!AppsCustomizePagedView.DISABLE_ALL_APPS</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3698 +                mWorkspace.getChangeStateAnimation(workspaceState, animated, layerViews);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3699 +        if (!LauncherAppState.isDisableAllApps()</span>
3700                  || contentType == AppsCustomizePagedView.ContentType.Widgets) {
3701              // Set the content type for the all apps/widgets space
3702              mAppsCustomizeTabHost.setContentTypeImmediate(contentType);
3703          }
3704  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3705 -        if (animated) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3706 -            toView.setScaleX(scale);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3707 -            toView.setScaleY(scale);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3708 -            final LauncherViewPropertyAnimator scaleAnim = new LauncherViewPropertyAnimator(toView);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3709 -            scaleAnim.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3710 -                scaleX(1f).scaleY(1f).</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3711 -                setDuration(duration).</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3712 -                setInterpolator(new Workspace.ZoomOutInterpolator());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3713 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3714 -            toView.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3715 -            toView.setAlpha(0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3716 -            final ObjectAnimator alphaAnim = LauncherAnimUtils</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3717 -                .ofFloat(toView, &quot;alpha&quot;, 0f, 1f)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3718 -                .setDuration(fadeDuration);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3719 -            alphaAnim.setInterpolator(new DecelerateInterpolator(1.5f));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3720 -            alphaAnim.addUpdateListener(new AnimatorUpdateListener() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3721 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3722 -                public void onAnimationUpdate(ValueAnimator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3723 -                    if (animation == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3724 -                        throw new RuntimeException(&quot;animation is null&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3725 +        // If for some reason our views aren&#x27;t initialized, don&#x27;t animate</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3726 +        boolean initialized = getAllAppsButton() != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3727 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3728 +        if (animated &amp;&amp; initialized) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3729 +            mStateAnimation = LauncherAnimUtils.createAnimatorSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3730 +            final AppsCustomizePagedView content = (AppsCustomizePagedView)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3731 +                    toView.findViewById(R.id.apps_customize_pane_content);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3732 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3733 +            final View page = content.getPageAt(content.getCurrentPage());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3734 +            final View revealView = toView.findViewById(R.id.fake_page);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3735 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3736 +            final float initialPanelAlpha = 1f;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3737 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3738 +            final boolean isWidgetTray = contentType == AppsCustomizePagedView.ContentType.Widgets;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3739 +            if (isWidgetTray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3740 +                revealView.setBackground(res.getDrawable(R.drawable.quantum_panel_dark));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3741 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3742 +                revealView.setBackground(res.getDrawable(R.drawable.quantum_panel));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3743 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3744 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3745 +            // Hide the real page background, and swap in the fake one</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3746 +            content.setPageBackgroundsVisible(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3747 +            revealView.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3748 +            // We need to hide this view as the animation start will be posted.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3749 +            revealView.setAlpha(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3750 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3751 +            int width = revealView.getMeasuredWidth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3752 +            int height = revealView.getMeasuredHeight();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3753 +            float revealRadius = (float) Math.sqrt((width * width) / 4 + (height * height) / 4);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3754 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3755 +            revealView.setTranslationY(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3756 +            revealView.setTranslationX(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3757 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3758 +            // Get the y delta between the center of the page and the center of the all apps button</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3759 +            int[] allAppsToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3760 +                    getAllAppsButton(), null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3761 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3762 +            float alpha = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3763 +            float xDrift = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3764 +            float yDrift = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3765 +            if (material) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3766 +                alpha = isWidgetTray ? 0.3f : 1f;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3767 +                yDrift = isWidgetTray ? height / 2 : allAppsToPanelDelta[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3768 +                xDrift = isWidgetTray ? 0 : allAppsToPanelDelta[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3769 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3770 +                yDrift = 2 * height / 3;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3771 +                xDrift = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3772 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3773 +            final float initAlpha = alpha;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3774 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3775 +            revealView.setLayerType(View.LAYER_TYPE_HARDWARE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3776 +            layerViews.add(revealView);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3777 +            PropertyValuesHolder panelAlpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, initAlpha, 1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3778 +            PropertyValuesHolder panelDriftY =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3779 +                    PropertyValuesHolder.ofFloat(&quot;translationY&quot;, yDrift, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3780 +            PropertyValuesHolder panelDriftX =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3781 +                    PropertyValuesHolder.ofFloat(&quot;translationX&quot;, xDrift, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3782 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3783 +            ObjectAnimator panelAlphaAndDrift = ObjectAnimator.ofPropertyValuesHolder(revealView,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3784 +                    panelAlpha, panelDriftY, panelDriftX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3785 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3786 +            panelAlphaAndDrift.setDuration(revealDuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3787 +            panelAlphaAndDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3788 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3789 +            mStateAnimation.play(panelAlphaAndDrift);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3790 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3791 +            if (page != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3792 +                page.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3793 +                page.setLayerType(View.LAYER_TYPE_HARDWARE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3794 +                layerViews.add(page);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3795 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3796 +                ObjectAnimator pageDrift = ObjectAnimator.ofFloat(page, &quot;translationY&quot;, yDrift, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3797 +                page.setTranslationY(yDrift);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3798 +                pageDrift.setDuration(revealDuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3799 +                pageDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3800 +                pageDrift.setStartDelay(itemsAlphaStagger);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3801 +                mStateAnimation.play(pageDrift);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3802 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3803 +                page.setAlpha(0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3804 +                ObjectAnimator itemsAlpha = ObjectAnimator.ofFloat(page, &quot;alpha&quot;, 0f, 1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3805 +                itemsAlpha.setDuration(revealDuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3806 +                itemsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3807 +                itemsAlpha.setStartDelay(itemsAlphaStagger);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3808 +                mStateAnimation.play(itemsAlpha);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3809 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3810 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3811 +            View pageIndicators = toView.findViewById(R.id.apps_customize_page_indicator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3812 +            pageIndicators.setAlpha(0.01f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3813 +            ObjectAnimator indicatorsAlpha =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3814 +                    ObjectAnimator.ofFloat(pageIndicators, &quot;alpha&quot;, 1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3815 +            indicatorsAlpha.setDuration(revealDuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3816 +            mStateAnimation.play(indicatorsAlpha);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3817 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3818 +            if (material) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3819 +                final View allApps = getAllAppsButton();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3820 +                int allAppsButtonSize = LauncherAppState.getInstance().</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3821 +                        getDynamicGrid().getDeviceProfile().allAppsButtonVisualSize;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3822 +                float startRadius = isWidgetTray ? 0 : allAppsButtonSize / 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3823 +                Animator reveal = ViewAnimationUtils.createCircularReveal(revealView, width / 2,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3824 +                                height / 2, startRadius, revealRadius);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3825 +                reveal.setDuration(revealDuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3826 +                reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3827 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3828 +                reveal.addListener(new AnimatorListenerAdapter() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3829 +                    public void onAnimationStart(Animator animation) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3830 +                        if (!isWidgetTray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3831 +                            allApps.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3832 +                        }</span>
3833                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3834 -                    float t = (Float) animation.getAnimatedValue();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3835 -                    dispatchOnLauncherTransitionStep(fromView, t);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3836 -                    dispatchOnLauncherTransitionStep(toView, t);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3837 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3838 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3839 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3840 -            // toView should appear right at the end of the workspace shrink</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3841 -            // animation</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3842 -            mStateAnimation = LauncherAnimUtils.createAnimatorSet();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3843 -            mStateAnimation.play(scaleAnim).after(startDelay);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3844 -            mStateAnimation.play(alphaAnim).after(startDelay);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3845 +                    public void onAnimationEnd(Animator animation) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3846 +                        if (!isWidgetTray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3847 +                            allApps.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3848 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3849 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3850 +                });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3851 +                mStateAnimation.play(reveal);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3852 +            }</span>
3853  
3854              mStateAnimation.addListener(new AnimatorListenerAdapter() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3855 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3856 -                public void onAnimationStart(Animator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3857 -                    // Prepare the position</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3858 -                    toView.setTranslationX(0.0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3859 -                    toView.setTranslationY(0.0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3860 -                    toView.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3861 -                    toView.bringToFront();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3862 -                }</span>
3863                  @Override
3864                  public void onAnimationEnd(Animator animation) {
3865                      dispatchOnLauncherTransitionEnd(fromView, animated, false);
3866                      dispatchOnLauncherTransitionEnd(toView, animated, false);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3867 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3868 +                    revealView.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3869 +                    revealView.setLayerType(View.LAYER_TYPE_NONE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3870 +                    if (page != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3871 +                        page.setLayerType(View.LAYER_TYPE_NONE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3872 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3873 +                    content.setPageBackgroundsVisible(true);</span>
3874  
3875                      // Hide the search bar
3876                      if (mSearchDropTargetBar != null) {
3877                          mSearchDropTargetBar.hideSearchBar(false);
3878                      }
3879                  }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3880 +</span>
3881              });
3882  
3883              if (workspaceAnim != null) {
3884                  mStateAnimation.play(workspaceAnim);
3885              }
3886  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3887 -            boolean delayAnim = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3888 -</span>
3889              dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3890              dispatchOnLauncherTransitionPrepare(toView, animated, false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3891 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3892 -            // If any of the objects being animated haven&#x27;t been measured/laid out</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3893 -            // yet, delay the animation until we get a layout pass</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3894 -            if ((((LauncherTransitionable) toView).getContent().getMeasuredWidth() == 0) ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3895 -                    (mWorkspace.getMeasuredWidth() == 0) ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3896 -                    (toView.getMeasuredWidth() == 0)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3897 -                delayAnim = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3898 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3899 -</span>
3900              final AnimatorSet stateAnimation = mStateAnimation;
3901              final Runnable startAnimRunnable = new Runnable() {
3902                  public void run() {
3903                      // Check that mStateAnimation hasn&#x27;t changed while
3904                      // we waited for a layout/draw pass
3905                      if (mStateAnimation != stateAnimation)
3906                          return;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3907 -                    setPivotsForZoom(toView, scale);</span>
3908                      dispatchOnLauncherTransitionStart(fromView, animated, false);
3909                      dispatchOnLauncherTransitionStart(toView, animated, false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3910 -                    LauncherAnimUtils.startAnimationAfterNextDraw(mStateAnimation, toView);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3911 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3912 +                    revealView.setAlpha(initAlpha);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3913 +                    if (Utilities.isLmpOrAbove()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3914 +                        for (int i = 0; i &lt; layerViews.size(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3915 +                            View v = layerViews.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3916 +                            if (v != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3917 +                                boolean attached = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3918 +                                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3919 +                                    attached = v.isAttachedToWindow();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3920 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3921 +                                if (attached) v.buildLayer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3922 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3923 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3924 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3925 +                    mStateAnimation.start();</span>
3926                  }
3927              };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3928 -            if (delayAnim) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3929 -                final ViewTreeObserver observer = toView.getViewTreeObserver();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3930 -                observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3931 -                        public void onGlobalLayout() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3932 -                            startAnimRunnable.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3933 -                            toView.getViewTreeObserver().removeOnGlobalLayoutListener(this);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3934 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3935 -                    });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3936 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3937 -                startAnimRunnable.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3938 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3939 +            toView.bringToFront();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3940 +            toView.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3941 +            toView.post(startAnimRunnable);</span>
3942          } else {
3943              toView.setTranslationX(0.0f);
3944              toView.setTranslationY(0.0f);
3945              toView.setScaleX(1.0f);
3946              toView.setScaleY(1.0f);
3947              toView.setVisibility(View.VISIBLE);
3948              toView.bringToFront();
3949  
3950              if (!springLoaded &amp;&amp; !LauncherAppState.getInstance().isScreenLarge()) {
3951                  // Hide the search bar
3952                  if (mSearchDropTargetBar != null) {
3953                      mSearchDropTargetBar.hideSearchBar(false);
3954                  }
3955              }
3956              dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3957              dispatchOnLauncherTransitionStart(fromView, animated, false);
3958              dispatchOnLauncherTransitionEnd(fromView, animated, false);
3959              dispatchOnLauncherTransitionPrepare(toView, animated, false);
3960              dispatchOnLauncherTransitionStart(toView, animated, false);
3961              dispatchOnLauncherTransitionEnd(toView, animated, false);
3962          }
3963      }
3964  
3965      /**
3966       * Zoom the camera back into the workspace, hiding &#x27;fromView&#x27;.
3967       * This is the opposite of showAppsCustomizeHelper.
3968       * @param animated If true, the transition will be animated.
3969       */
3970      private void hideAppsCustomizeHelper(Workspace.State toState, final boolean animated,
3971              final boolean springLoaded, final Runnable onCompleteRunnable) {
3972  
3973          if (mStateAnimation != null) {
3974              mStateAnimation.setDuration(0);
3975              mStateAnimation.cancel();
3976              mStateAnimation = null;
3977          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3978 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3979 +        boolean material = Utilities.isLmpOrAbove();</span>
3980          Resources res = getResources();
3981  
3982          final int duration = res.getInteger(R.integer.config_appsCustomizeZoomOutTime);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3983 -        final int fadeOutDuration =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3984 -                res.getInteger(R.integer.config_appsCustomizeFadeOutTime);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3985 +        final int fadeOutDuration = res.getInteger(R.integer.config_appsCustomizeFadeOutTime);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3986 +        final int revealDuration = res.getInteger(R.integer.config_appsCustomizeConcealTime);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3987 +        final int itemsAlphaStagger =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3988 +                res.getInteger(R.integer.config_appsCustomizeItemsAlphaStagger);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3989 +</span>
3990          final float scaleFactor = (float)
3991                  res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3992          final View fromView = mAppsCustomizeTabHost;
3993          final View toView = mWorkspace;
3994          Animator workspaceAnim = null;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3995 +        final ArrayList&lt;View&gt; layerViews = new ArrayList&lt;View&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3996 +</span>
3997          if (toState == Workspace.State.NORMAL) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3998 -            int stagger = res.getInteger(R.integer.config_appsCustomizeWorkspaceAnimationStagger);</span>
3999              workspaceAnim = mWorkspace.getChangeStateAnimation(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4000 -                    toState, animated, stagger, -1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4001 +                    toState, animated, layerViews);</span>
4002          } else if (toState == Workspace.State.SPRING_LOADED ||
4003                  toState == Workspace.State.OVERVIEW) {
4004              workspaceAnim = mWorkspace.getChangeStateAnimation(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4005 -                    toState, animated);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4006 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4007 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4008 -        setPivotsForZoom(fromView, scaleFactor);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4009 -        showHotseat(animated);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4010 -        if (animated) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4011 -            final LauncherViewPropertyAnimator scaleAnim =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4012 -                    new LauncherViewPropertyAnimator(fromView);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4013 -            scaleAnim.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4014 -                scaleX(scaleFactor).scaleY(scaleFactor).</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4015 -                setDuration(duration).</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4016 -                setInterpolator(new Workspace.ZoomInInterpolator());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4017 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4018 -            final ObjectAnimator alphaAnim = LauncherAnimUtils</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4019 -                .ofFloat(fromView, &quot;alpha&quot;, 1f, 0f)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4020 -                .setDuration(fadeOutDuration);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4021 -            alphaAnim.setInterpolator(new AccelerateDecelerateInterpolator());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4022 -            alphaAnim.addUpdateListener(new AnimatorUpdateListener() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4023 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4024 -                public void onAnimationUpdate(ValueAnimator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4025 -                    float t = 1f - (Float) animation.getAnimatedValue();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4026 -                    dispatchOnLauncherTransitionStep(fromView, t);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4027 -                    dispatchOnLauncherTransitionStep(toView, t);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4028 +                    toState, animated, layerViews);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4029 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4030 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4031 +        // If for some reason our views aren&#x27;t initialized, don&#x27;t animate</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4032 +        boolean initialized = getAllAppsButton() != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4033 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4034 +        if (animated &amp;&amp; initialized) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4035 +            mStateAnimation = LauncherAnimUtils.createAnimatorSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4036 +            if (workspaceAnim != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4037 +                mStateAnimation.play(workspaceAnim);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4038 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4039 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4040 +            final AppsCustomizePagedView content = (AppsCustomizePagedView)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4041 +                    fromView.findViewById(R.id.apps_customize_pane_content);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4042 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4043 +            final View page = content.getPageAt(content.getNextPage());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4044 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4045 +            // We need to hide side pages of the Apps / Widget tray to avoid some ugly edge cases</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4046 +            int count = content.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4047 +            for (int i = 0; i &lt; count; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4048 +                View child = content.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4049 +                if (child != page) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4050 +                    child.setVisibility(View.INVISIBLE);</span>
4051                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4052 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4053 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4054 -            mStateAnimation = LauncherAnimUtils.createAnimatorSet();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4055 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4056 -            dispatchOnLauncherTransitionPrepare(fromView, animated, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4057 -            dispatchOnLauncherTransitionPrepare(toView, animated, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4058 -            mAppsCustomizeContent.stopScrolling();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4059 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4060 +            final View revealView = fromView.findViewById(R.id.fake_page);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4061 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4062 +            // hideAppsCustomizeHelper is called in some cases when it is already hidden</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4063 +            // don&#x27;t perform all these no-op animations. In particularly, this was causing</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4064 +            // the all-apps button to pop in and out.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4065 +            if (fromView.getVisibility() == View.VISIBLE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4066 +                AppsCustomizePagedView.ContentType contentType = content.getContentType();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4067 +                final boolean isWidgetTray =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4068 +                        contentType == AppsCustomizePagedView.ContentType.Widgets;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4069 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4070 +                if (isWidgetTray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4071 +                    revealView.setBackground(res.getDrawable(R.drawable.quantum_panel_dark));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4072 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4073 +                    revealView.setBackground(res.getDrawable(R.drawable.quantum_panel));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4074 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4075 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4076 +                int width = revealView.getMeasuredWidth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4077 +                int height = revealView.getMeasuredHeight();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4078 +                float revealRadius = (float) Math.sqrt((width * width) / 4 + (height * height) / 4);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4079 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4080 +                // Hide the real page background, and swap in the fake one</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4081 +                revealView.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4082 +                content.setPageBackgroundsVisible(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4083 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4084 +                final View allAppsButton = getAllAppsButton();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4085 +                revealView.setTranslationY(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4086 +                int[] allAppsToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4087 +                        allAppsButton, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4088 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4089 +                float xDrift = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4090 +                float yDrift = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4091 +                if (material) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4092 +                    yDrift = isWidgetTray ? height / 2 : allAppsToPanelDelta[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4093 +                    xDrift = isWidgetTray ? 0 : allAppsToPanelDelta[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4094 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4095 +                    yDrift = 5 * height / 4;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4096 +                    xDrift = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4097 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4098 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4099 +                revealView.setLayerType(View.LAYER_TYPE_HARDWARE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4100 +                TimeInterpolator decelerateInterpolator = material ?</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4101 +                        new LogDecelerateInterpolator(100, 0) :</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4102 +                        new LogDecelerateInterpolator(30, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4103 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4104 +                // The vertical motion of the apps panel should be delayed by one frame</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4105 +                // from the conceal animation in order to give the right feel. We correpsondingly</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4106 +                // shorten the duration so that the slide and conceal end at the same time.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4107 +                ObjectAnimator panelDriftY = LauncherAnimUtils.ofFloat(revealView, &quot;translationY&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4108 +                        0, yDrift);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4109 +                panelDriftY.setDuration(revealDuration - SINGLE_FRAME_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4110 +                panelDriftY.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4111 +                panelDriftY.setInterpolator(decelerateInterpolator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4112 +                mStateAnimation.play(panelDriftY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4113 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4114 +                ObjectAnimator panelDriftX = LauncherAnimUtils.ofFloat(revealView, &quot;translationX&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4115 +                        0, xDrift);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4116 +                panelDriftX.setDuration(revealDuration - SINGLE_FRAME_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4117 +                panelDriftX.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4118 +                panelDriftX.setInterpolator(decelerateInterpolator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4119 +                mStateAnimation.play(panelDriftX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4120 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4121 +                if (isWidgetTray || !material) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4122 +                    float finalAlpha = material ? 0.4f : 0f;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4123 +                    revealView.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4124 +                    ObjectAnimator panelAlpha = LauncherAnimUtils.ofFloat(revealView, &quot;alpha&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4125 +                            1f, finalAlpha);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4126 +                    panelAlpha.setDuration(revealDuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4127 +                    panelAlpha.setInterpolator(material ? decelerateInterpolator :</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4128 +                        new AccelerateInterpolator(1.5f));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4129 +                    mStateAnimation.play(panelAlpha);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4130 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4131 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4132 +                if (page != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4133 +                    page.setLayerType(View.LAYER_TYPE_HARDWARE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4134 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4135 +                    ObjectAnimator pageDrift = LauncherAnimUtils.ofFloat(page, &quot;translationY&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4136 +                            0, yDrift);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4137 +                    page.setTranslationY(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4138 +                    pageDrift.setDuration(revealDuration - SINGLE_FRAME_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4139 +                    pageDrift.setInterpolator(decelerateInterpolator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4140 +                    pageDrift.setStartDelay(itemsAlphaStagger + SINGLE_FRAME_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4141 +                    mStateAnimation.play(pageDrift);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4142 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4143 +                    page.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4144 +                    ObjectAnimator itemsAlpha = LauncherAnimUtils.ofFloat(page, &quot;alpha&quot;, 1f, 0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4145 +                    itemsAlpha.setDuration(100);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4146 +                    itemsAlpha.setInterpolator(decelerateInterpolator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4147 +                    mStateAnimation.play(itemsAlpha);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4148 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4149 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4150 +                View pageIndicators = fromView.findViewById(R.id.apps_customize_page_indicator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4151 +                pageIndicators.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4152 +                ObjectAnimator indicatorsAlpha =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4153 +                        LauncherAnimUtils.ofFloat(pageIndicators, &quot;alpha&quot;, 0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4154 +                indicatorsAlpha.setDuration(revealDuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4155 +                indicatorsAlpha.setInterpolator(new DecelerateInterpolator(1.5f));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4156 +                mStateAnimation.play(indicatorsAlpha);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4157 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4158 +                width = revealView.getMeasuredWidth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4159 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4160 +                if (material) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4161 +                    if (!isWidgetTray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4162 +                        allAppsButton.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4163 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4164 +                    int allAppsButtonSize = LauncherAppState.getInstance().</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4165 +                            getDynamicGrid().getDeviceProfile().allAppsButtonVisualSize;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4166 +                    float finalRadius = isWidgetTray ? 0 : allAppsButtonSize / 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4167 +                    Animator reveal =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4168 +                            LauncherAnimUtils.createCircularReveal(revealView, width / 2,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4169 +                                    height / 2, revealRadius, finalRadius);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4170 +                    reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4171 +                    reveal.setDuration(revealDuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4172 +                    reveal.setStartDelay(itemsAlphaStagger);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4173 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4174 +                    reveal.addListener(new AnimatorListenerAdapter() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4175 +                        public void onAnimationEnd(Animator animation) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4176 +                            revealView.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4177 +                            if (!isWidgetTray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4178 +                                allAppsButton.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4179 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4180 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4181 +                    });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4182 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4183 +                    mStateAnimation.play(reveal);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4184 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4185 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4186 +                dispatchOnLauncherTransitionPrepare(fromView, animated, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4187 +                dispatchOnLauncherTransitionPrepare(toView, animated, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4188 +                mAppsCustomizeContent.stopScrolling();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4189 +            }</span>
4190  
4191              mStateAnimation.addListener(new AnimatorListenerAdapter() {
4192                  @Override
4193                  public void onAnimationEnd(Animator animation) {
4194                      fromView.setVisibility(View.GONE);
4195                      dispatchOnLauncherTransitionEnd(fromView, animated, true);
4196                      dispatchOnLauncherTransitionEnd(toView, animated, true);
4197                      if (onCompleteRunnable != null) {
4198                          onCompleteRunnable.run();
4199                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4200 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4201 +                    revealView.setLayerType(View.LAYER_TYPE_NONE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4202 +                    if (page != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4203 +                        page.setLayerType(View.LAYER_TYPE_NONE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4204 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4205 +                    content.setPageBackgroundsVisible(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4206 +                    // Unhide side pages</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4207 +                    int count = content.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4208 +                    for (int i = 0; i &lt; count; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4209 +                        View child = content.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4210 +                        child.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4211 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4212 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4213 +                    // Reset page transforms</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4214 +                    if (page != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4215 +                        page.setTranslationX(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4216 +                        page.setTranslationY(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4217 +                        page.setAlpha(1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4218 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4219 +                    content.setCurrentPage(content.getNextPage());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4220 +</span>
4221                      mAppsCustomizeContent.updateCurrentPageScroll();
4222                  }
4223              });
4224  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4225 -            mStateAnimation.playTogether(scaleAnim, alphaAnim);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4226 -            if (workspaceAnim != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4227 -                mStateAnimation.play(workspaceAnim);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4228 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4229 -            dispatchOnLauncherTransitionStart(fromView, animated, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4230 -            dispatchOnLauncherTransitionStart(toView, animated, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4231 -            LauncherAnimUtils.startAnimationAfterNextDraw(mStateAnimation, toView);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4232 +            final AnimatorSet stateAnimation = mStateAnimation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4233 +            final Runnable startAnimRunnable = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4234 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4235 +                    // Check that mStateAnimation hasn&#x27;t changed while</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4236 +                    // we waited for a layout/draw pass</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4237 +                    if (mStateAnimation != stateAnimation)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4238 +                        return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4239 +                    dispatchOnLauncherTransitionStart(fromView, animated, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4240 +                    dispatchOnLauncherTransitionStart(toView, animated, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4242 +                    if (Utilities.isLmpOrAbove()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4243 +                        for (int i = 0; i &lt; layerViews.size(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4244 +                            View v = layerViews.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4245 +                            if (v != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4246 +                                boolean attached = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4247 +                                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4248 +                                    attached = v.isAttachedToWindow();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4249 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4250 +                                if (attached) v.buildLayer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4251 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4252 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4253 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4254 +                    mStateAnimation.start();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4255 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4256 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4257 +            fromView.post(startAnimRunnable);</span>
4258          } else {
4259              fromView.setVisibility(View.GONE);
4260              dispatchOnLauncherTransitionPrepare(fromView, animated, true);
4261              dispatchOnLauncherTransitionStart(fromView, animated, true);
4262              dispatchOnLauncherTransitionEnd(fromView, animated, true);
4263              dispatchOnLauncherTransitionPrepare(toView, animated, true);
4264              dispatchOnLauncherTransitionStart(toView, animated, true);
4265              dispatchOnLauncherTransitionEnd(toView, animated, true);
4266          }
4267      }
4268  
4269      @Override
4270      public void onTrimMemory(int level) {
4271          super.onTrimMemory(level);
4272          if (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
4273              mAppsCustomizeTabHost.onTrimMemory();
4274          }
4275      }
4276  
4277      protected void showWorkspace(boolean animated) {
4278          showWorkspace(animated, null);
4279      }
4280  
4281      protected void showWorkspace() {
4282          showWorkspace(true);
4283      }
4284  
4285      void showWorkspace(boolean animated, Runnable onCompleteRunnable) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4286 -        if (mWorkspace.isInOverviewMode()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4287 -            mWorkspace.exitOverviewMode(animated);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4288 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4289 -        if (mState != State.WORKSPACE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4290 +        if (mState != State.WORKSPACE || mWorkspace.getState() != Workspace.State.NORMAL) {</span>
4291              boolean wasInSpringLoadedMode = (mState != State.WORKSPACE);
4292              mWorkspace.setVisibility(View.VISIBLE);
4293              hideAppsCustomizeHelper(Workspace.State.NORMAL, animated, false, onCompleteRunnable);
4294  
4295              // Show the search bar (only animate if we were showing the drop target bar in spring
4296              // loaded mode)
4297              if (mSearchDropTargetBar != null) {
4298                  mSearchDropTargetBar.showSearchBar(animated &amp;&amp; wasInSpringLoadedMode);
4299              }
4300  
4301              // Set focus to the AppsCustomize button
4302              if (mAllAppsButton != null) {
4303                  mAllAppsButton.requestFocus();
4304              }
4305          }
4306  
4307          // Change the state *after* we&#x27;ve called all the transition code
4308          mState = State.WORKSPACE;
4309  
4310          // Resume the auto-advance of widgets
4311          mUserPresent = true;
4312          updateRunning();
4313  
4314          // Send an accessibility event to announce the context change
4315          getWindow().getDecorView()
4316                  .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
4317  
4318          onWorkspaceShown(animated);
4319      }
4320  
4321      void showOverviewMode(boolean animated) {
4322          mWorkspace.setVisibility(View.VISIBLE);
4323          hideAppsCustomizeHelper(Workspace.State.OVERVIEW, animated, false, null);
4324          mState = State.WORKSPACE;
4325          onWorkspaceShown(animated);
4326      }
4327  
4328      public void onWorkspaceShown(boolean animated) {
4329      }
4330  
4331      void showAllApps(boolean animated, AppsCustomizePagedView.ContentType contentType,
4332                       boolean resetPageToZero) {
4333          if (mState != State.WORKSPACE) return;
4334  
4335          if (resetPageToZero) {
4336              mAppsCustomizeTabHost.reset();
4337          }
4338          showAppsCustomizeHelper(animated, false, contentType);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4339 -        mAppsCustomizeTabHost.requestFocus();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4340 +        mAppsCustomizeTabHost.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4341 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4342 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4343 +                // We post this in-case the all apps view isn&#x27;t yet constructed.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4344 +                mAppsCustomizeTabHost.requestFocus();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4345 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4346 +        });</span>
4347  
4348          // Change the state *after* we&#x27;ve called all the transition code
4349          mState = State.APPS_CUSTOMIZE;
4350  
4351          // Pause the auto-advance of widgets until we are out of AllApps
4352          mUserPresent = false;
4353          updateRunning();
4354          closeFolder();
4355  
4356          // Send an accessibility event to announce the context change
4357          getWindow().getDecorView()
4358                  .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
4359      }
4360  
4361      void enterSpringLoadedDragMode() {
4362          if (isAllAppsVisible()) {
4363              hideAppsCustomizeHelper(Workspace.State.SPRING_LOADED, true, true, null);
4364              mState = State.APPS_CUSTOMIZE_SPRING_LOADED;
4365          }
4366      }
4367  
4368      void exitSpringLoadedDragModeDelayed(final boolean successfulDrop, int delay,
4369              final Runnable onCompleteRunnable) {
4370          if (mState != State.APPS_CUSTOMIZE_SPRING_LOADED) return;
4371  
4372          mHandler.postDelayed(new Runnable() {
4373              @Override
4374              public void run() {
4375                  if (successfulDrop) {
4376                      // Before we show workspace, hide all apps again because
4377                      // exitSpringLoadedDragMode made it visible. This is a bit hacky; we should
4378                      // clean up our state transition functions
4379                      mAppsCustomizeTabHost.setVisibility(View.GONE);
4380                      showWorkspace(true, onCompleteRunnable);
4381                  } else {
4382                      exitSpringLoadedDragMode();
4383                  }
4384              }
4385          }, delay);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4386 -</span>
4387      }
4388  
4389      void exitSpringLoadedDragMode() {
4390          if (mState == State.APPS_CUSTOMIZE_SPRING_LOADED) {
4391              final boolean animated = true;
4392              final boolean springLoaded = true;
4393              showAppsCustomizeHelper(animated, springLoaded);
4394              mState = State.APPS_CUSTOMIZE;
4395          }
4396          // Otherwise, we are not in spring loaded mode, so don&#x27;t do anything.
4397      }
4398  
4399      void lockAllApps() {
4400          // TODO
4401      }
4402  
4403      void unlockAllApps() {
4404          // TODO
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4405 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4406 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4407 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4408 -     * Shows the hotseat area.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4409 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4410 -    void showHotseat(boolean animated) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4411 -        if (!LauncherAppState.getInstance().isScreenLarge()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4412 -            if (animated) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4413 -                if (mHotseat.getAlpha() != 1f) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4414 -                    int duration = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4415 -                    if (mSearchDropTargetBar != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4416 -                        duration = mSearchDropTargetBar.getTransitionInDuration();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4417 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4418 -                    mHotseat.animate().alpha(1f).setDuration(duration);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4419 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4420 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4421 -                mHotseat.setAlpha(1f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4422 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4423 -        }</span>
4424      }
4425  
4426      /**
4427       * Hides the hotseat area.
4428       */
4429      void hideHotseat(boolean animated) {
4430          if (!LauncherAppState.getInstance().isScreenLarge()) {
4431              if (animated) {
4432                  if (mHotseat.getAlpha() != 0f) {
4433                      int duration = 0;
4434                      if (mSearchDropTargetBar != null) {
4435                          duration = mSearchDropTargetBar.getTransitionOutDuration();
4436                      }
4437                      mHotseat.animate().alpha(0f).setDuration(duration);
4438                  }
4439              } else {
4440                  mHotseat.setAlpha(0f);
4441              }
4442          }
4443      }
4444  
4445      /**
4446       * Add an item from all apps or customize onto the given workspace screen.
4447       * If layout is null, add to the current screen.
4448       */
4449      void addExternalItemToScreen(ItemInfo itemInfo, final CellLayout layout) {
4450          if (!mWorkspace.addExternalItemToScreen(itemInfo, layout)) {
4451              showOutOfSpaceMessage(isHotseatLayout(layout));
4452          }
4453      }
4454  
4455      /** Maps the current orientation to an index for referencing orientation correct global icons */
4456      private int getCurrentOrientationIndexForGlobalIcons() {
4457          // default - 0, landscape - 1
4458          switch (getResources().getConfiguration().orientation) {
4459          case Configuration.ORIENTATION_LANDSCAPE:
4460              return 1;
4461          default:
4462              return 0;
4463          }
4464      }
4465  
4466      private Drawable getExternalPackageToolbarIcon(ComponentName activityName, String resourceName) {
4467          try {
4468              PackageManager packageManager = getPackageManager();
4469              // Look for the toolbar icon specified in the activity meta-data
4470              Bundle metaData = packageManager.getActivityInfo(
4471                      activityName, PackageManager.GET_META_DATA).metaData;
4472              if (metaData != null) {
4473                  int iconResId = metaData.getInt(resourceName);
4474                  if (iconResId != 0) {
4475                      Resources res = packageManager.getResourcesForActivity(activityName);
4476                      return res.getDrawable(iconResId);
4477                  }
4478              }
4479          } catch (NameNotFoundException e) {
4480              // This can happen if the activity defines an invalid drawable
4481              Log.w(TAG, &quot;Failed to load toolbar icon; &quot; + activityName.flattenToShortString() +
4482                      &quot; not found&quot;, e);
4483          } catch (Resources.NotFoundException nfe) {
4484              // This can happen if the activity defines an invalid drawable
4485              Log.w(TAG, &quot;Failed to load toolbar icon from &quot; + activityName.flattenToShortString(),
4486                      nfe);
4487          }
4488          return null;
4489      }
4490  
4491      // if successful in getting icon, return it; otherwise, set button to use default drawable
4492      private Drawable.ConstantState updateTextButtonWithIconFromExternalActivity(
4493              int buttonId, ComponentName activityName, int fallbackDrawableId,
4494              String toolbarResourceName) {
4495          Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
4496          Resources r = getResources();
4497          int w = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_width);
4498          int h = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_height);
4499  
4500          TextView button = (TextView) findViewById(buttonId);
4501          // If we were unable to find the icon via the meta-data, use a generic one
4502          if (toolbarIcon == null) {
4503              toolbarIcon = r.getDrawable(fallbackDrawableId);
4504              toolbarIcon.setBounds(0, 0, w, h);
4505              if (button != null) {
4506                  button.setCompoundDrawables(toolbarIcon, null, null, null);
4507              }
4508              return null;
4509          } else {
4510              toolbarIcon.setBounds(0, 0, w, h);
4511              if (button != null) {
4512                  button.setCompoundDrawables(toolbarIcon, null, null, null);
4513              }
4514              return toolbarIcon.getConstantState();
4515          }
4516      }
4517  
4518      // if successful in getting icon, return it; otherwise, set button to use default drawable
4519      private Drawable.ConstantState updateButtonWithIconFromExternalActivity(
4520              int buttonId, ComponentName activityName, int fallbackDrawableId,
4521              String toolbarResourceName) {
4522          ImageView button = (ImageView) findViewById(buttonId);
4523          Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
4524  
4525          if (button != null) {
4526              // If we were unable to find the icon via the meta-data, use a
4527              // generic one
4528              if (toolbarIcon == null) {
4529                  button.setImageResource(fallbackDrawableId);
4530              } else {
4531                  button.setImageDrawable(toolbarIcon);
4532              }
4533          }
4534  
4535          return toolbarIcon != null ? toolbarIcon.getConstantState() : null;
4536  
4537      }
4538  
4539      private void updateTextButtonWithDrawable(int buttonId, Drawable d) {
4540          TextView button = (TextView) findViewById(buttonId);
4541          button.setCompoundDrawables(d, null, null, null);
4542      }
4543  
4544      private void updateButtonWithDrawable(int buttonId, Drawable.ConstantState d) {
4545          ImageView button = (ImageView) findViewById(buttonId);
4546          button.setImageDrawable(d.newDrawable(getResources()));
4547      }
4548  
4549      private void invalidatePressedFocusedStates(View container, View button) {
4550          if (container instanceof HolographicLinearLayout) {
4551              HolographicLinearLayout layout = (HolographicLinearLayout) container;
4552              layout.invalidatePressedFocusedStates();
4553          } else if (button instanceof HolographicImageView) {
4554              HolographicImageView view = (HolographicImageView) button;
4555              view.invalidatePressedFocusedStates();
4556          }
4557      }
4558  
4559      public View getQsbBar() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4560 -        if (mQsbBar == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4561 -            mQsbBar = mInflater.inflate(R.layout.search_bar, mSearchDropTargetBar, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4562 -            mSearchDropTargetBar.addView(mQsbBar);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4563 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4564 -        return mQsbBar;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4565 +        if (mQsb == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4566 +            mQsb = mInflater.inflate(R.layout.qsb, mSearchDropTargetBar, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4567 +            mSearchDropTargetBar.addView(mQsb);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4568 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4569 +        return mQsb;</span>
4570      }
4571  
4572      protected boolean updateGlobalSearchIcon() {
4573          final View searchButtonContainer = findViewById(R.id.search_button_container);
4574          final ImageView searchButton = (ImageView) findViewById(R.id.search_button);
4575          final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4576          final View voiceButton = findViewById(R.id.voice_button);
4577  
4578          final SearchManager searchManager =
4579                  (SearchManager) getSystemService(Context.SEARCH_SERVICE);
4580          ComponentName activityName = searchManager.getGlobalSearchActivity();
4581          if (activityName != null) {
4582              int coi = getCurrentOrientationIndexForGlobalIcons();
4583              sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4584                      R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
4585                      TOOLBAR_SEARCH_ICON_METADATA_NAME);
4586              if (sGlobalSearchIcon[coi] == null) {
4587                  sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4588                          R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
4589                          TOOLBAR_ICON_METADATA_NAME);
4590              }
4591  
4592              if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.VISIBLE);
4593              searchButton.setVisibility(View.VISIBLE);
4594              invalidatePressedFocusedStates(searchButtonContainer, searchButton);
4595              return true;
4596          } else {
4597              // We disable both search and voice search when there is no global search provider
4598              if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.GONE);
4599              if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
4600              if (searchButton != null) searchButton.setVisibility(View.GONE);
4601              if (voiceButton != null) voiceButton.setVisibility(View.GONE);
4602              updateVoiceButtonProxyVisible(false);
4603              return false;
4604          }
4605      }
4606  
4607      protected void updateGlobalSearchIcon(Drawable.ConstantState d) {
4608          final View searchButtonContainer = findViewById(R.id.search_button_container);
4609          final View searchButton = (ImageView) findViewById(R.id.search_button);
4610          updateButtonWithDrawable(R.id.search_button, d);
4611          invalidatePressedFocusedStates(searchButtonContainer, searchButton);
4612      }
4613  
4614      protected boolean updateVoiceSearchIcon(boolean searchVisible) {
4615          final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4616          final View voiceButton = findViewById(R.id.voice_button);
4617  
4618          // We only show/update the voice search icon if the search icon is enabled as well
4619          final SearchManager searchManager =
4620                  (SearchManager) getSystemService(Context.SEARCH_SERVICE);
4621          ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
4622  
4623          ComponentName activityName = null;
4624          if (globalSearchActivity != null) {
4625              // Check if the global search activity handles voice search
4626              Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
4627              intent.setPackage(globalSearchActivity.getPackageName());
4628              activityName = intent.resolveActivity(getPackageManager());
4629          }
4630  
4631          if (activityName == null) {
4632              // Fallback: check if an activity other than the global search activity
4633              // resolves this
4634              Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
4635              activityName = intent.resolveActivity(getPackageManager());
4636          }
4637          if (searchVisible &amp;&amp; activityName != null) {
4638              int coi = getCurrentOrientationIndexForGlobalIcons();
4639              sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4640                      R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
4641                      TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME);
4642              if (sVoiceSearchIcon[coi] == null) {
4643                  sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
4644                          R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
4645                          TOOLBAR_ICON_METADATA_NAME);
4646              }
4647              if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.VISIBLE);
4648              voiceButton.setVisibility(View.VISIBLE);
4649              updateVoiceButtonProxyVisible(false);
4650              invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
4651              return true;
4652          } else {
4653              if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
4654              if (voiceButton != null) voiceButton.setVisibility(View.GONE);
4655              updateVoiceButtonProxyVisible(false);
4656              return false;
4657          }
4658      }
4659  
4660      protected void updateVoiceSearchIcon(Drawable.ConstantState d) {
4661          final View voiceButtonContainer = findViewById(R.id.voice_button_container);
4662          final View voiceButton = findViewById(R.id.voice_button);
4663          updateButtonWithDrawable(R.id.voice_button, d);
4664          invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
4665      }
4666  
4667      public void updateVoiceButtonProxyVisible(boolean forceDisableVoiceButtonProxy) {
4668          final View voiceButtonProxy = findViewById(R.id.voice_button_proxy);
4669          if (voiceButtonProxy != null) {
4670              boolean visible = !forceDisableVoiceButtonProxy &amp;&amp;
4671                      mWorkspace.shouldVoiceButtonProxyBeVisible();
4672              voiceButtonProxy.setVisibility(visible ? View.VISIBLE : View.GONE);
4673              voiceButtonProxy.bringToFront();
4674          }
4675      }
4676  
4677      /**
4678       * This is an overrid eot disable the voice button proxy.  If disabled is true, then the voice button proxy
4679       * will be hidden regardless of what shouldVoiceButtonProxyBeVisible() returns.
4680       */
4681      public void disableVoiceButtonProxy(boolean disabled) {
4682          updateVoiceButtonProxyVisible(disabled);
4683      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4684 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4685 -     * Sets the app market icon</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4686 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4687 -    private void updateAppMarketIcon() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4688 -        if (!DISABLE_MARKET_BUTTON) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4689 -            final View marketButton = findViewById(R.id.market_button);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4690 -            Intent intent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_APP_MARKET);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4691 -            // Find the app market activity by resolving an intent.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4692 -            // (If multiple app markets are installed, it will return the ResolverActivity.)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4693 -            ComponentName activityName = intent.resolveActivity(getPackageManager());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4694 -            if (activityName != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4695 -                int coi = getCurrentOrientationIndexForGlobalIcons();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4696 -                mAppMarketIntent = intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4697 -                sAppMarketIcon[coi] = updateTextButtonWithIconFromExternalActivity(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4698 -                        R.id.market_button, activityName, R.drawable.ic_launcher_market_holo,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4699 -                        TOOLBAR_ICON_METADATA_NAME);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4700 -                marketButton.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4701 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4702 -                // We should hide and disable the view so that we don&#x27;t try and restore the visibility</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4703 -                // of it when we swap between drag &amp; normal states from IconDropTarget subclasses.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4704 -                marketButton.setVisibility(View.GONE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4705 -                marketButton.setEnabled(false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4706 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4707 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4708 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4709 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4710 -    private void updateAppMarketIcon(Drawable.ConstantState d) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4711 -        if (!DISABLE_MARKET_BUTTON) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4712 -            // Ensure that the new drawable we are creating has the approprate toolbar icon bounds</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4713 -            Resources r = getResources();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4714 -            Drawable marketIconDrawable = d.newDrawable(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4715 -            int w = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_width);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4716 -            int h = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_height);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4717 -            marketIconDrawable.setBounds(0, 0, w, h);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4718 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4719 -            updateTextButtonWithDrawable(R.id.market_button, marketIconDrawable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4720 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4721 -    }</span>
4722  
4723      @Override
4724      public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
4725          final boolean result = super.dispatchPopulateAccessibilityEvent(event);
4726          final List&lt;CharSequence&gt; text = event.getText();
4727          text.clear();
4728          // Populate event with a fake title based on the current state.
4729          if (mState == State.APPS_CUSTOMIZE) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4730 -            text.add(mAppsCustomizeTabHost.getCurrentTabView().getContentDescription());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4731 +            text.add(mAppsCustomizeTabHost.getContentTag());</span>
4732          } else {
4733              text.add(getString(R.string.all_apps_home_button_label));
4734          }
4735          return result;
4736      }
4737  
4738      /**
4739       * Receives notifications when system dialogs are to be closed.
4740       */
4741      private class CloseSystemDialogsIntentReceiver extends BroadcastReceiver {
4742          @Override
4743          public void onReceive(Context context, Intent intent) {
4744              closeSystemDialogs();
4745          }
4746      }
4747  
4748      /**
4749       * Receives notifications whenever the appwidgets are reset.
4750       */
4751      private class AppWidgetResetObserver extends ContentObserver {
4752          public AppWidgetResetObserver() {
4753              super(new Handler());
4754          }
4755  
4756          @Override
4757          public void onChange(boolean selfChange) {
4758              onAppWidgetReset();
4759          }
4760      }
4761  
4762      /**
4763       * If the activity is currently paused, signal that we need to run the passed Runnable
4764       * in onResume.
4765       *
4766       * This needs to be called from incoming places where resources might have been loaded
4767       * while we are paused.  That is becaues the Configuration might be wrong
4768       * when we&#x27;re not running, and if it comes back to what it was when we
4769       * were paused, we are not restarted.
4770       *
4771       * Implementation of the method from LauncherModel.Callbacks.
4772       *
4773       * @return true if we are currently paused.  The caller might be able to
4774       * skip some work in that case since we will come back again.
4775       */
4776      private boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) {
4777          if (mPaused) {
4778              Log.i(TAG, &quot;Deferring update until onResume&quot;);
4779              if (deletePreviousRunnables) {
4780                  while (mBindOnResumeCallbacks.remove(run)) {
4781                  }
4782              }
4783              mBindOnResumeCallbacks.add(run);
4784              return true;
4785          } else {
4786              return false;
4787          }
4788      }
4789  
4790      private boolean waitUntilResume(Runnable run) {
4791          return waitUntilResume(run, false);
4792      }
4793  
4794      public void addOnResumeCallback(Runnable run) {
4795          mOnResumeCallbacks.add(run);
4796      }
4797  
4798      /**
4799       * If the activity is currently paused, signal that we need to re-run the loader
4800       * in onResume.
4801       *
4802       * This needs to be called from incoming places where resources might have been loaded
4803       * while we are paused.  That is becaues the Configuration might be wrong
4804       * when we&#x27;re not running, and if it comes back to what it was when we
4805       * were paused, we are not restarted.
4806       *
4807       * Implementation of the method from LauncherModel.Callbacks.
4808       *
4809       * @return true if we are currently paused.  The caller might be able to
4810       * skip some work in that case since we will come back again.
4811       */
4812      public boolean setLoadOnResume() {
4813          if (mPaused) {
4814              Log.i(TAG, &quot;setLoadOnResume&quot;);
4815              mOnResumeNeedsLoad = true;
4816              return true;
4817          } else {
4818              return false;
4819          }
4820      }
4821  
4822      /**
4823       * Implementation of the method from LauncherModel.Callbacks.
4824       */
4825      public int getCurrentWorkspaceScreen() {
4826          if (mWorkspace != null) {
4827              return mWorkspace.getCurrentPage();
4828          } else {
4829              return SCREEN_COUNT / 2;
4830          }
4831      }
4832  
4833      /**
4834       * Refreshes the shortcuts shown on the workspace.
4835       *
4836       * Implementation of the method from LauncherModel.Callbacks.
4837       */
4838      public void startBinding() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4839 +        setWorkspaceLoading(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4840 +</span>
4841          // If we&#x27;re starting binding all over again, clear any bind calls we&#x27;d postponed in
4842          // the past (see waitUntilResume) -- we don&#x27;t need them since we&#x27;re starting binding
4843          // from scratch again
4844          mBindOnResumeCallbacks.clear();
4845  
4846          // Clear the workspace because it&#x27;s going to be rebound
4847          mWorkspace.clearDropTargets();
4848          mWorkspace.removeAllWorkspaceScreens();
4849  
4850          mWidgetsToAdvance.clear();
4851          if (mHotseat != null) {
4852              mHotseat.resetLayout();
4853          }
4854      }
4855  
4856      @Override
4857      public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
4858          bindAddScreens(orderedScreenIds);
4859  
4860          // If there are no screens, we need to have an empty screen
4861          if (orderedScreenIds.size() == 0) {
4862              mWorkspace.addExtraEmptyScreen();
4863          }
4864  
4865          // Create the custom content page (this call updates mDefaultScreen which calls
4866          // setCurrentPage() so ensure that all pages are added before calling this).
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4867 -        // The actual content of the custom page will be added during onFinishBindingItems().</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4868 -        if (!mWorkspace.hasCustomContent() &amp;&amp; hasCustomContentToLeft()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4869 -            mWorkspace.createCustomContentPage();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4870 +        if (hasCustomContentToLeft()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4871 +            mWorkspace.createCustomContentContainer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4872 +            populateCustomContentContainer();</span>
4873          }
4874      }
4875  
4876      @Override
4877      public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
4878          // Log to disk
4879          Launcher.addDumpLog(TAG, &quot;11683562 - bindAddScreens()&quot;, true);
4880          Launcher.addDumpLog(TAG, &quot;11683562 -   orderedScreenIds: &quot; +
4881                  TextUtils.join(&quot;, &quot;, orderedScreenIds), true);
4882          int count = orderedScreenIds.size();
4883          for (int i = 0; i &lt; count; i++) {
4884              mWorkspace.insertNewWorkspaceScreenBeforeEmptyScreen(orderedScreenIds.get(i));
4885          }
4886      }
4887  
4888      private boolean shouldShowWeightWatcher() {
4889          String spKey = LauncherAppState.getSharedPreferencesKey();
4890          SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
4891          boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, SHOW_WEIGHT_WATCHER_DEFAULT);
4892  
4893          return show;
4894      }
4895  
4896      private void toggleShowWeightWatcher() {
4897          String spKey = LauncherAppState.getSharedPreferencesKey();
4898          SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
4899          boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, true);
4900  
4901          show = !show;
4902  
4903          SharedPreferences.Editor editor = sp.edit();
4904          editor.putBoolean(SHOW_WEIGHT_WATCHER, show);
4905          editor.commit();
4906  
4907          if (mWeightWatcher != null) {
4908              mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
4909          }
4910      }
4911  
4912      public void bindAppsAdded(final ArrayList&lt;Long&gt; newScreens,
4913                                final ArrayList&lt;ItemInfo&gt; addNotAnimated,
4914                                final ArrayList&lt;ItemInfo&gt; addAnimated,
4915                                final ArrayList&lt;AppInfo&gt; addedApps) {
4916          Runnable r = new Runnable() {
4917              public void run() {
4918                  bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
4919              }
4920          };
4921          if (waitUntilResume(r)) {
4922              return;
4923          }
4924  
4925          // Add the new screens
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4926 -        bindAddScreens(newScreens);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4927 +        if (newScreens != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4928 +            bindAddScreens(newScreens);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4929 +        }</span>
4930  
4931          // We add the items without animation on non-visible pages, and with
4932          // animations on the new page (which we will try and snap to).
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4933 -        if (!addNotAnimated.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4934 +        if (addNotAnimated != null &amp;&amp; !addNotAnimated.isEmpty()) {</span>
4935              bindItems(addNotAnimated, 0,
4936                      addNotAnimated.size(), false);
4937          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4938 -        if (!addAnimated.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4939 +        if (addAnimated != null &amp;&amp; !addAnimated.isEmpty()) {</span>
4940              bindItems(addAnimated, 0,
4941                      addAnimated.size(), true);
4942          }
4943  
4944          // Remove the extra empty screen
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4945 -        mWorkspace.removeExtraEmptyScreen(false, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4946 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4947 -        if (!AppsCustomizePagedView.DISABLE_ALL_APPS &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4948 +        mWorkspace.removeExtraEmptyScreen(false, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4949 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4950 +        if (!LauncherAppState.isDisableAllApps() &amp;&amp;</span>
4951                  addedApps != null &amp;&amp; mAppsCustomizeContent != null) {
4952              mAppsCustomizeContent.addApps(addedApps);
4953          }
4954      }
4955  
4956      /**
4957       * Bind the items start-end from the list.
4958       *
4959       * Implementation of the method from LauncherModel.Callbacks.
4960       */
4961      public void bindItems(final ArrayList&lt;ItemInfo&gt; shortcuts, final int start, final int end,
4962                            final boolean forceAnimateIcons) {
4963          Runnable r = new Runnable() {
4964              public void run() {
4965                  bindItems(shortcuts, start, end, forceAnimateIcons);
4966              }
4967          };
4968          if (waitUntilResume(r)) {
4969              return;
4970          }
4971  
4972          // Get the list of added shortcuts and intersect them with the set of shortcuts here
4973          final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
4974          final Collection&lt;Animator&gt; bounceAnims = new ArrayList&lt;Animator&gt;();
4975          final boolean animateIcons = forceAnimateIcons &amp;&amp; canRunNewAppsAnimation();
4976          Workspace workspace = mWorkspace;
4977          long newShortcutsScreenId = -1;
4978          for (int i = start; i &lt; end; i++) {
4979              final ItemInfo item = shortcuts.get(i);
4980  
4981              // Short circuit if we are loading dock items for a configuration which has no dock
4982              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
4983                      mHotseat == null) {
4984                  continue;
4985              }
4986  
4987              switch (item.itemType) {
4988                  case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
4989                  case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
4990                      ShortcutInfo info = (ShortcutInfo) item;
4991                      View shortcut = createShortcut(info);
4992  
4993                      /*
4994                       * TODO: FIX collision case
4995                       */
4996                      if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
4997                          CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
4998                          if (cl != null &amp;&amp; cl.isOccupied(item.cellX, item.cellY)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4999 -                            throw new RuntimeException(&quot;OCCUPIED&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5000 +                            View v = cl.getChildAt(item.cellX, item.cellY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5001 +                            Object tag = v.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5002 +                            String desc = &quot;Collision while binding workspace item: &quot; + item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5003 +                                    + &quot;. Collides with &quot; + tag;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5004 +                            if (LauncherAppState.isDogfoodBuild()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5005 +                                throw (new RuntimeException(desc));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5006 +                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5007 +                                Log.d(TAG, desc);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5008 +                            }</span>
5009                          }
5010                      }
5011  
5012                      workspace.addInScreenFromBind(shortcut, item.container, item.screenId, item.cellX,
5013                              item.cellY, 1, 1);
5014                      if (animateIcons) {
5015                          // Animate all the applications up now
5016                          shortcut.setAlpha(0f);
5017                          shortcut.setScaleX(0f);
5018                          shortcut.setScaleY(0f);
5019                          bounceAnims.add(createNewAppBounceAnimation(shortcut, i));
5020                          newShortcutsScreenId = item.screenId;
5021                      }
5022                      break;
5023                  case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
5024                      FolderIcon newFolder = FolderIcon.fromXml(R.layout.folder_icon, this,
5025                              (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()),
5026                              (FolderInfo) item, mIconCache);
5027                      workspace.addInScreenFromBind(newFolder, item.container, item.screenId, item.cellX,
5028                              item.cellY, 1, 1);
5029                      break;
5030                  default:
5031                      throw new RuntimeException(&quot;Invalid Item Type&quot;);
5032              }
5033          }
5034  
5035          if (animateIcons) {
5036              // Animate to the correct page
5037              if (newShortcutsScreenId &gt; -1) {
5038                  long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
5039                  final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
5040                  final Runnable startBounceAnimRunnable = new Runnable() {
5041                      public void run() {
5042                          anim.playTogether(bounceAnims);
5043                          anim.start();
5044                      }
5045                  };
5046                  if (newShortcutsScreenId != currentScreenId) {
5047                      // We post the animation slightly delayed to prevent slowdowns
5048                      // when we are loading right after we return to launcher.
5049                      mWorkspace.postDelayed(new Runnable() {
5050                          public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5051 -                            mWorkspace.snapToPage(newScreenIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5052 -                            mWorkspace.postDelayed(startBounceAnimRunnable,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5053 -                                    NEW_APPS_ANIMATION_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5054 +                            if (mWorkspace != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5055 +                                mWorkspace.snapToPage(newScreenIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5056 +                                mWorkspace.postDelayed(startBounceAnimRunnable,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5057 +                                        NEW_APPS_ANIMATION_DELAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5058 +                            }</span>
5059                          }
5060                      }, NEW_APPS_PAGE_MOVE_DELAY);
5061                  } else {
5062                      mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
5063                  }
5064              }
5065          }
5066          workspace.requestLayout();
5067      }
5068  
5069      /**
5070       * Implementation of the method from LauncherModel.Callbacks.
5071       */
5072      public void bindFolders(final HashMap&lt;Long, FolderInfo&gt; folders) {
5073          Runnable r = new Runnable() {
5074              public void run() {
5075                  bindFolders(folders);
5076              }
5077          };
5078          if (waitUntilResume(r)) {
5079              return;
5080          }
5081          sFolders.clear();
5082          sFolders.putAll(folders);
5083      }
5084  
5085      /**
5086       * Add the views for a widget to the workspace.
5087       *
5088       * Implementation of the method from LauncherModel.Callbacks.
5089       */
5090      public void bindAppWidget(final LauncherAppWidgetInfo item) {
5091          Runnable r = new Runnable() {
5092              public void run() {
5093                  bindAppWidget(item);
5094              }
5095          };
5096          if (waitUntilResume(r)) {
5097              return;
5098          }
5099  
5100          final long start = DEBUG_WIDGETS ? SystemClock.uptimeMillis() : 0;
5101          if (DEBUG_WIDGETS) {
5102              Log.d(TAG, &quot;bindAppWidget: &quot; + item);
5103          }
5104          final Workspace workspace = mWorkspace;
5105  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5106 -        final int appWidgetId = item.appWidgetId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5107 -        final AppWidgetProviderInfo appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5108 -        if (DEBUG_WIDGETS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="5109 -            Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.provider);">5109 -            Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.provider🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5110 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5111 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5112 -        item.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5113 +        AppWidgetProviderInfo appWidgetInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5114 +        if (((item.restoreStatus &amp; LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0) &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5115 +                ((item.restoreStatus &amp; LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) != 0)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5116 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5117 +            appWidgetInfo = mModel.findAppWidgetProviderInfoWithComponent(this, item.providerName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5118 +            if (appWidgetInfo == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5119 +                if (DEBUG_WIDGETS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5120 +                    Log.d(TAG, &quot;Removing restored widget: id=&quot; + item.appWidgetId</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5121 +                            + &quot; belongs to component &quot; + item.providerName</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5122 +                            + &quot;, as the povider is null&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5123 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5124 +                LauncherModel.deleteItemFromDatabase(this, item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5125 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5126 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5127 +            // Note: This assumes that the id remap broadcast is received before this step.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5128 +            // If that is not the case, the id remap will be ignored and user may see the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5129 +            // click to setup view.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5130 +            PendingAddWidgetInfo pendingInfo = new PendingAddWidgetInfo(appWidgetInfo, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5131 +            pendingInfo.spanX = item.spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5132 +            pendingInfo.spanY = item.spanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5133 +            pendingInfo.minSpanX = item.minSpanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5134 +            pendingInfo.minSpanY = item.minSpanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5135 +            Bundle options =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5136 +                    AppsCustomizePagedView.getDefaultOptionsForWidget(this, pendingInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5137 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5138 +            int newWidgetId = mAppWidgetHost.allocateAppWidgetId();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5139 +            boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5140 +                    newWidgetId, appWidgetInfo, options);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5141 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5142 +            // TODO consider showing a permission dialog when the widget is clicked.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5143 +            if (!success) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5144 +                mAppWidgetHost.deleteAppWidgetId(newWidgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5145 +                if (DEBUG_WIDGETS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5146 +                    Log.d(TAG, &quot;Removing restored widget: id=&quot; + item.appWidgetId</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5147 +                            + &quot; belongs to component &quot; + item.providerName</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5148 +                            + &quot;, as the launcher is unable to bing a new widget id&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5149 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5150 +                LauncherModel.deleteItemFromDatabase(this, item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5151 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5152 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5153 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5154 +            item.appWidgetId = newWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5155 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5156 +            // If the widget has a configure activity, it is still needs to set it up, otherwise</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5157 +            // the widget is ready to go.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5158 +            item.restoreStatus = (appWidgetInfo.configure == null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5159 +                    ? LauncherAppWidgetInfo.RESTORE_COMPLETED</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5160 +                    : LauncherAppWidgetInfo.FLAG_UI_NOT_READY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5161 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5162 +            LauncherModel.updateItemInDatabase(this, item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5163 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5164 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5165 +        if (item.restoreStatus == LauncherAppWidgetInfo.RESTORE_COMPLETED) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5166 +            final int appWidgetId = item.appWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5167 +            appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5168 +            if (DEBUG_WIDGETS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="5169 +                Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.provider);">5169 +                Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.prov🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5170 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5171 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5172 +            item.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5173 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5174 +            appWidgetInfo = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5175 +            PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5176 +            view.updateIcon(mIconCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5177 +            item.hostView = view;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5178 +            item.hostView.updateAppWidget(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5179 +            item.hostView.setOnClickListener(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5180 +        }</span>
5181  
5182          item.hostView.setTag(item);
5183          item.onBindAppWidget(this);
5184  
5185          workspace.addInScreen(item.hostView, item.container, item.screenId, item.cellX,
5186                  item.cellY, item.spanX, item.spanY, false);
5187          addWidgetToAutoAdvanceIfNeeded(item.hostView, appWidgetInfo);
5188  
5189          workspace.requestLayout();
5190  
5191          if (DEBUG_WIDGETS) {
5192              Log.d(TAG, &quot;bound widget id=&quot;+item.appWidgetId+&quot; in &quot;
5193                      + (SystemClock.uptimeMillis()-start) + &quot;ms&quot;);
5194          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5195 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5196 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5197 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5198 +     * Restores a pending widget.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5199 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5200 +     * @param appWidgetId The app widget id</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5201 +     * @param cellInfo The position on screen where to create the widget.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5202 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5203 +    private void completeRestoreAppWidget(final int appWidgetId) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5204 +        LauncherAppWidgetHostView view = mWorkspace.getWidgetForAppWidgetId(appWidgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5205 +        if ((view == null) || !(view instanceof PendingAppWidgetHostView)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5206 +            Log.e(TAG, &quot;Widget update called, when the widget no longer exists.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5207 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5208 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5209 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5210 +        LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) view.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5211 +        info.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5212 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5213 +        mWorkspace.reinflateWidgetsIfNecessary();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5214 +        LauncherModel.updateItemInDatabase(this, info);</span>
5215      }
5216  
5217      public void onPageBoundSynchronously(int page) {
5218          mSynchronouslyBoundPages.add(page);
5219      }
5220  
5221      /**
5222       * Callback saying that there aren&#x27;t any more items to bind.
5223       *
5224       * Implementation of the method from LauncherModel.Callbacks.
5225       */
5226      public void finishBindingItems(final boolean upgradePath) {
5227          Runnable r = new Runnable() {
5228              public void run() {
5229                  finishBindingItems(upgradePath);
5230              }
5231          };
5232          if (waitUntilResume(r)) {
5233              return;
5234          }
5235          if (mSavedState != null) {
5236              if (!mWorkspace.hasFocus()) {
5237                  mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
5238              }
5239              mSavedState = null;
5240          }
5241  
5242          mWorkspace.restoreInstanceStateForRemainingPages();
5243  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5244 +        setWorkspaceLoading(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5245 +        sendLoadingCompleteBroadcastIfNecessary();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5246 +</span>
5247          // If we received the result of any pending adds while the loader was running (e.g. the
5248          // widget configuration forced an orientation change), process them now.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5249 -        for (int i = 0; i &lt; sPendingAddList.size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5250 -            completeAdd(sPendingAddList.get(i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5251 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5252 -        sPendingAddList.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5253 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5254 -        // Update the market app icon as necessary (the other icons will be managed in response to</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5255 -        // package changes in bindSearchablesChanged()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5256 -        if (!DISABLE_MARKET_BUTTON) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5257 -            updateAppMarketIcon();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5258 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5259 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5260 -        mWorkspaceLoading = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5261 +        if (sPendingAddItem != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5262 +            final long screenId = completeAdd(sPendingAddItem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5263 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5264 +            // TODO: this moves the user to the page where the pending item was added. Ideally,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5265 +            // the screen would be guaranteed to exist after bind, and the page would be set through</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5266 +            // the workspace restore process.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5267 +            mWorkspace.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5268 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5269 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5270 +                    mWorkspace.snapToScreenId(screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5271 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5272 +            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5273 +            sPendingAddItem = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5274 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5275 +</span>
5276          if (upgradePath) {
5277              mWorkspace.getUniqueComponents(true, null);
5278              mIntentsOnWorkspaceFromUpgradePath = mWorkspace.getUniqueComponents(true, null);
5279          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5280 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5281 -        mWorkspace.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5282 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5283 -            public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5284 -                onFinishBindingItems();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5285 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5286 -        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5287 +        PackageInstallerCompat.getInstance(this).onFinishBind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5288 +        mModel.recheckRestoredItems(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5289 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5290 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5291 +    private void sendLoadingCompleteBroadcastIfNecessary() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5292 +        if (!mSharedPrefs.getBoolean(FIRST_LOAD_COMPLETE, false)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5293 +            String permission =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5294 +                    getResources().getString(R.string.receive_first_load_broadcast_permission);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5295 +            Intent intent = new Intent(ACTION_FIRST_LOAD_COMPLETE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5296 +            sendBroadcast(intent, permission);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5297 +            SharedPreferences.Editor editor = mSharedPrefs.edit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5298 +            editor.putBoolean(FIRST_LOAD_COMPLETE, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5299 +            editor.apply();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5300 +        }</span>
5301      }
5302  
5303      public boolean isAllAppsButtonRank(int rank) {
5304          if (mHotseat != null) {
5305              return mHotseat.isAllAppsButtonRank(rank);
5306          }
5307          return false;
5308      }
5309  
5310      private boolean canRunNewAppsAnimation() {
5311          long diff = System.currentTimeMillis() - mDragController.getLastGestureUpTime();
5312          return diff &gt; (NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS * 1000);
5313      }
5314  
5315      private ValueAnimator createNewAppBounceAnimation(View v, int i) {
5316          ValueAnimator bounceAnim = LauncherAnimUtils.ofPropertyValuesHolder(v,
5317                  PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1f),
5318                  PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f),
5319                  PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f));
5320          bounceAnim.setDuration(InstallShortcutReceiver.NEW_SHORTCUT_BOUNCE_DURATION);
5321          bounceAnim.setStartDelay(i * InstallShortcutReceiver.NEW_SHORTCUT_STAGGER_DELAY);
5322          bounceAnim.setInterpolator(new SmoothPagedView.OvershootInterpolator());
5323          return bounceAnim;
5324      }
5325  
5326      public boolean useVerticalBarLayout() {
5327          return LauncherAppState.getInstance().getDynamicGrid().
5328                  getDeviceProfile().isVerticalBarLayout();
5329      }
5330  
5331      protected Rect getSearchBarBounds() {
5332          return LauncherAppState.getInstance().getDynamicGrid().
5333                  getDeviceProfile().getSearchBarBounds();
5334      }
5335  
5336      @Override
5337      public void bindSearchablesChanged() {
5338          boolean searchVisible = updateGlobalSearchIcon();
5339          boolean voiceVisible = updateVoiceSearchIcon(searchVisible);
5340          if (mSearchDropTargetBar != null) {
5341              mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
5342          }
5343      }
5344  
5345      /**
5346       * Add the icons for all apps.
5347       *
5348       * Implementation of the method from LauncherModel.Callbacks.
5349       */
5350      public void bindAllApplications(final ArrayList&lt;AppInfo&gt; apps) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5351 -        if (AppsCustomizePagedView.DISABLE_ALL_APPS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5352 +        if (LauncherAppState.isDisableAllApps()) {</span>
5353              if (mIntentsOnWorkspaceFromUpgradePath != null) {
5354                  if (LauncherModel.UPGRADE_USE_MORE_APPS_FOLDER) {
5355                      getHotseat().addAllAppsFolder(mIconCache, apps,
5356                              mIntentsOnWorkspaceFromUpgradePath, Launcher.this, mWorkspace);
5357                  }
5358                  mIntentsOnWorkspaceFromUpgradePath = null;
5359              }
5360              if (mAppsCustomizeContent != null) {
5361                  mAppsCustomizeContent.onPackagesUpdated(
5362                          LauncherModel.getSortedWidgetsAndShortcuts(this));
5363              }
5364          } else {
5365              if (mAppsCustomizeContent != null) {
5366                  mAppsCustomizeContent.setApps(apps);
5367                  mAppsCustomizeContent.onPackagesUpdated(
5368                          LauncherModel.getSortedWidgetsAndShortcuts(this));
5369              }
5370          }
5371      }
5372  
5373      /**
5374       * A package was updated.
5375       *
5376       * Implementation of the method from LauncherModel.Callbacks.
5377       */
5378      public void bindAppsUpdated(final ArrayList&lt;AppInfo&gt; apps) {
5379          Runnable r = new Runnable() {
5380              public void run() {
5381                  bindAppsUpdated(apps);
5382              }
5383          };
5384          if (waitUntilResume(r)) {
5385              return;
5386          }
5387  
5388          if (mWorkspace != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5389 -            mWorkspace.updateShortcuts(apps);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5390 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5391 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5392 -        if (!AppsCustomizePagedView.DISABLE_ALL_APPS &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5393 +            mWorkspace.updateShortcutsAndWidgets(apps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5394 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5395 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5396 +        if (!LauncherAppState.isDisableAllApps() &amp;&amp;</span>
5397                  mAppsCustomizeContent != null) {
5398              mAppsCustomizeContent.updateApps(apps);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5399 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5400 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5401 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5402 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5403 +     * Packages were restored</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5404 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5405 +    public void bindAppsRestored(final ArrayList&lt;AppInfo&gt; apps) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5406 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5407 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5408 +                bindAppsRestored(apps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5409 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5410 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5411 +        if (waitUntilResume(r)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5412 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5413 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5414 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5415 +        if (mWorkspace != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5416 +            mWorkspace.updateShortcutsAndWidgets(apps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5417 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5418 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5419 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5420 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5421 +     * Update the state of a package, typically related to install state.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5422 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5423 +     * Implementation of the method from LauncherModel.Callbacks.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5424 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5425 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5426 +    public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5427 +        if (mWorkspace != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5428 +            mWorkspace.updatePackageState(installInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5429 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5430 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5431 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5432 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5433 +     * Update the label and icon of all the icons in a package</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5434 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5435 +     * Implementation of the method from LauncherModel.Callbacks.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5436 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5437 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5438 +    public void updatePackageBadge(String packageName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5439 +        if (mWorkspace != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5440 +            mWorkspace.updatePackageBadge(packageName, UserHandleCompat.myUserHandle());</span>
5441          }
5442      }
5443  
5444      /**
5445       * A package was uninstalled.  We take both the super set of packageNames
5446       * in addition to specific applications to remove, the reason being that
5447       * this can be called when a package is updated as well.  In that scenario,
5448       * we only remove specific components from the workspace, where as
5449       * package-removal should clear all items by package name.
5450       *
5451       * Implementation of the method from LauncherModel.Callbacks.
5452       */
5453      public void bindComponentsRemoved(final ArrayList&lt;String&gt; packageNames,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5454 -                                      final ArrayList&lt;AppInfo&gt; appInfos) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5455 +            final ArrayList&lt;AppInfo&gt; appInfos, final UserHandleCompat user) {</span>
5456          Runnable r = new Runnable() {
5457              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5458 -                bindComponentsRemoved(packageNames, appInfos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5459 +                bindComponentsRemoved(packageNames, appInfos, user);</span>
5460              }
5461          };
5462          if (waitUntilResume(r)) {
5463              return;
5464          }
5465  
5466          if (!packageNames.isEmpty()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5467 -            mWorkspace.removeItemsByPackageName(packageNames);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5468 +            mWorkspace.removeItemsByPackageName(packageNames, user);</span>
5469          }
5470          if (!appInfos.isEmpty()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5471 -            mWorkspace.removeItemsByApplicationInfo(appInfos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5472 +            mWorkspace.removeItemsByApplicationInfo(appInfos, user);</span>
5473          }
5474  
5475          // Notify the drag controller
5476          mDragController.onAppsRemoved(packageNames, appInfos);
5477  
5478          // Update AllApps
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5479 -        if (!AppsCustomizePagedView.DISABLE_ALL_APPS &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5480 +        if (!LauncherAppState.isDisableAllApps() &amp;&amp;</span>
5481                  mAppsCustomizeContent != null) {
5482              mAppsCustomizeContent.removeApps(appInfos);
5483          }
5484      }
5485  
5486      /**
5487       * A number of packages were updated.
5488       */
5489      private ArrayList&lt;Object&gt; mWidgetsAndShortcuts;
5490      private Runnable mBindPackagesUpdatedRunnable = new Runnable() {
5491              public void run() {
5492                  bindPackagesUpdated(mWidgetsAndShortcuts);
5493                  mWidgetsAndShortcuts = null;
5494              }
5495          };
5496      public void bindPackagesUpdated(final ArrayList&lt;Object&gt; widgetsAndShortcuts) {
5497          if (waitUntilResume(mBindPackagesUpdatedRunnable, true)) {
5498              mWidgetsAndShortcuts = widgetsAndShortcuts;
5499              return;
5500          }
5501  
5502          // Update the widgets pane
5503          if (mAppsCustomizeContent != null) {
5504              mAppsCustomizeContent.onPackagesUpdated(widgetsAndShortcuts);
5505          }
5506      }
5507  
5508      private int mapConfigurationOriActivityInfoOri(int configOri) {
5509          final Display d = getWindowManager().getDefaultDisplay();
5510          int naturalOri = Configuration.ORIENTATION_LANDSCAPE;
5511          switch (d.getRotation()) {
5512          case Surface.ROTATION_0:
5513          case Surface.ROTATION_180:
5514              // We are currently in the same basic orientation as the natural orientation
5515              naturalOri = configOri;
5516              break;
5517          case Surface.ROTATION_90:
5518          case Surface.ROTATION_270:
5519              // We are currently in the other basic orientation to the natural orientation
5520              naturalOri = (configOri == Configuration.ORIENTATION_LANDSCAPE) ?
5521                      Configuration.ORIENTATION_PORTRAIT : Configuration.ORIENTATION_LANDSCAPE;
5522              break;
5523          }
5524  
5525          int[] oriMap = {
5526                  ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
5527                  ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE,
5528                  ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
5529                  ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
5530          };
5531          // Since the map starts at portrait, we need to offset if this device&#x27;s natural orientation
5532          // is landscape.
5533          int indexOffset = 0;
5534          if (naturalOri == Configuration.ORIENTATION_LANDSCAPE) {
5535              indexOffset = 1;
5536          }
5537          return oriMap[(d.getRotation() + indexOffset) % 4];
5538      }
5539  
5540      public boolean isRotationEnabled() {
5541          boolean enableRotation = sForceEnableRotation ||
5542                  getResources().getBoolean(R.bool.allow_rotation);
5543          return enableRotation;
5544      }
5545      public void lockScreenOrientation() {
5546          if (isRotationEnabled()) {
5547              setRequestedOrientation(mapConfigurationOriActivityInfoOri(getResources()
5548                      .getConfiguration().orientation));
5549          }
5550      }
5551      public void unlockScreenOrientation(boolean immediate) {
5552          if (isRotationEnabled()) {
5553              if (immediate) {
5554                  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
5555              } else {
5556                  mHandler.postDelayed(new Runnable() {
5557                      public void run() {
5558                          setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
5559                      }
5560                  }, mRestoreScreenOrientationDelay);
5561              }
5562          }
5563      }
5564  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5565 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5566 +     * Called when the SearchBar hint should be changed.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5567 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5568 +     * @param hint the hint to be displayed in the search bar.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5569 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5570 +    protected void onSearchBarHintChanged(String hint) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5571 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5572 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5573 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5574 +    protected boolean isLauncherPreinstalled() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5575 +        PackageManager pm = getPackageManager();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5576 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5577 +            ApplicationInfo ai = pm.getApplicationInfo(getComponentName().getPackageName(), 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5578 +            if ((ai.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5579 +                return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5580 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5581 +                return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5582 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5583 +        } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5584 +            e.printStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5585 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5586 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5587 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5588 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5589 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5590 +     * This method indicates whether or not we should suggest default wallpaper dimensions</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5591 +     * when our wallpaper cropper was not yet used to set a wallpaper.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5592 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5593 +    protected boolean overrideWallpaperDimensions() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5594 +        return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5595 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5596 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5597 +    protected boolean shouldClingFocusHotseatApp() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5598 +        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5599 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5600 +    protected String getFirstRunClingSearchBarHint() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5601 +        return &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5602 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5603 +    protected String getFirstRunCustomContentHint() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5604 +        return &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5605 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5606 +    protected int getFirstRunFocusedHotseatAppDrawableId() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5607 +        return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5608 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5609 +    protected ComponentName getFirstRunFocusedHotseatAppComponentName() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5610 +        return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5611 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5612 +    protected int getFirstRunFocusedHotseatAppRank() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5613 +        return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5614 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5615 +    protected String getFirstRunFocusedHotseatAppBubbleTitle() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5616 +        return &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5617 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5618 +    protected String getFirstRunFocusedHotseatAppBubbleDescription() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5619 +        return &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5620 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5621 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5622 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5623 +     * To be overridden by subclasses to indicate that there is an activity to launch</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5624 +     * before showing the standard launcher experience.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5625 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5626 +    protected boolean hasFirstRunActivity() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5627 +        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5628 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5629 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5630 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5631 +     * To be overridden by subclasses to launch any first run activity</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5632 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5633 +    protected Intent getFirstRunActivity() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5634 +        return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5635 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5636 +</span>
5637      private boolean shouldRunFirstRunActivity() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5638 -        return !ActivityManager.isRunningInTestHarness();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5639 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5640 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5641 -    /* Cling related */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5642 -    private boolean isClingsEnabled() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5643 -        if (DISABLE_CLINGS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5644 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5645 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5646 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5647 -        // For now, limit only to phones</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5648 -        LauncherAppState app = LauncherAppState.getInstance();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5649 -        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5650 -        if (grid.isTablet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5651 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5652 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5653 -        if (grid.isLandscape) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5654 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5655 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5656 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5657 -        // disable clings when running in a test harness</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5658 -        if(ActivityManager.isRunningInTestHarness()) return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5659 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5660 -        // Disable clings for accessibility when explore by touch is enabled</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5661 -        final AccessibilityManager a11yManager = (AccessibilityManager) getSystemService(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5662 -                ACCESSIBILITY_SERVICE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5663 -        if (a11yManager.isTouchExplorationEnabled()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5664 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5665 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5666 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5667 -        // Restricted secondary users (child mode) will potentially have very few apps</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5668 -        // seeded when they start up for the first time. Clings won&#x27;t work well with that</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5669 -//        boolean supportsLimitedUsers =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5670 -//                android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5671 -//        Account[] accounts = AccountManager.get(this).getAccounts();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5672 -//        if (supportsLimitedUsers &amp;&amp; accounts.length == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5673 -//            UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5674 -//            Bundle restrictions = um.getUserRestrictions();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5675 -//            if (restrictions.getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS, false)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5676 -//               return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5677 -//            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5678 -//        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5679 -        return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5680 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5681 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5682 -    private Cling initCling(int clingId, int scrimId, boolean animate,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5683 -                            boolean dimNavBarVisibilty) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5684 -        Cling cling = (Cling) findViewById(clingId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5685 -        View scrim = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5686 -        if (scrimId &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5687 -            scrim = findViewById(R.id.cling_scrim);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5688 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5689 -        if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5690 -            cling.init(this, scrim);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5691 -            cling.show(animate, SHOW_CLING_DURATION);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5692 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5693 -            if (dimNavBarVisibilty) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5694 -                cling.setSystemUiVisibility(cling.getSystemUiVisibility() |</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5695 -                        View.SYSTEM_UI_FLAG_LOW_PROFILE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5696 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5697 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5698 -        return cling;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5699 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5700 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5701 -    private void dismissCling(final Cling cling, final Runnable postAnimationCb,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5702 -                              final String flag, int duration, boolean restoreNavBarVisibilty) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5703 -        // To catch cases where siblings of top-level views are made invisible, just check whether</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5704 -        // the cling is directly set to GONE before dismissing it.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5705 -        if (cling != null &amp;&amp; cling.getVisibility() != View.GONE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5706 -            final Runnable cleanUpClingCb = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5707 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5708 -                    cling.cleanup();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5709 -                    SharedPreferences.Editor editor = mSharedPrefs.edit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5710 -                    editor.putBoolean(flag, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5711 -                    editor.apply();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5712 -                    if (postAnimationCb != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5713 -                        postAnimationCb.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5714 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5715 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5716 -            };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5717 -            if (duration &lt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5718 -                cleanUpClingCb.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5719 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5720 -                cling.hide(duration, cleanUpClingCb);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5721 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5722 -            mHideFromAccessibilityHelper.restoreImportantForAccessibility(mDragLayer);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5723 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5724 -            if (restoreNavBarVisibilty) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5725 -                cling.setSystemUiVisibility(cling.getSystemUiVisibility() &amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5726 -                        ~View.SYSTEM_UI_FLAG_LOW_PROFILE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5727 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5728 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5729 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5730 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5731 -    private void removeCling(int id) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5732 -        final View cling = findViewById(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5733 -        if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5734 -            final ViewGroup parent = (ViewGroup) cling.getParent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5735 -            parent.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5736 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5737 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5738 -                    parent.removeView(cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5739 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5740 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5741 -            mHideFromAccessibilityHelper.restoreImportantForAccessibility(mDragLayer);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5742 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5743 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5744 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5745 -    private boolean skipCustomClingIfNoAccounts() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5746 -        Cling cling = (Cling) findViewById(R.id.workspace_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5747 -        boolean customCling = cling.getDrawIdentifier().equals(&quot;workspace_custom&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5748 -        if (customCling) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5749 -            AccountManager am = AccountManager.get(this);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5750 -            if (am == null) return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5751 -            Account[] accounts = am.getAccountsByType(&quot;com.google&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5752 -            return accounts.length == 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5753 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5754 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5755 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5756 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5757 -    public void updateCustomContentHintVisibility() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5758 -        Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5759 -        String ccHintStr = getFirstRunCustomContentHint();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5760 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5761 -        if (mWorkspace.hasCustomContent()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5762 -            // Show the custom content hint if ccHintStr is not empty</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5763 -            if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5764 -                setCustomContentHintVisibility(cling, ccHintStr, true, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5765 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5766 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5767 -            // Hide the custom content hint</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5768 -            if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5769 -                setCustomContentHintVisibility(cling, ccHintStr, false, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5770 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5771 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5772 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5773 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5774 -    private void setCustomContentHintVisibility(Cling cling, String ccHintStr, boolean visible,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5775 -                                                boolean animate) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5776 -        final TextView ccHint = (TextView) cling.findViewById(R.id.custom_content_hint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5777 -        if (ccHint != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5778 -            if (visible &amp;&amp; !ccHintStr.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5779 -                ccHint.setText(ccHintStr);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5780 -                ccHint.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5781 -                if (animate) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5782 -                    ccHint.setAlpha(0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5783 -                    ccHint.animate().alpha(1f)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5784 -                                    .setDuration(SHOW_CLING_DURATION)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5785 -                                    .start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5786 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5787 -                    ccHint.setAlpha(1f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5788 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5789 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5790 -                if (animate) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5791 -                    ccHint.animate().alpha(0f)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5792 -                                    .setDuration(SHOW_CLING_DURATION)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5793 -                                    .setListener(new AnimatorListenerAdapter() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5794 -                                        @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5795 -                                        public void onAnimationEnd(Animator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5796 -                                            ccHint.setVisibility(View.GONE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5797 -                                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5798 -                                    })</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5799 -                                    .start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5800 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5801 -                    ccHint.setAlpha(0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5802 -                    ccHint.setVisibility(View.GONE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5803 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5804 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5805 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5806 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5807 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5808 -    public void showFirstRunActivity() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5809 -        if (shouldRunFirstRunActivity() &amp;&amp; hasFirstRunActivity()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5810 -                &amp;&amp; !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5811 +        return !ActivityManager.isRunningInTestHarness() &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5812 +                !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5813 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5814 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5815 +    protected boolean hasRunFirstRunActivity() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5816 +        return mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5817 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5818 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5819 +    public boolean showFirstRunActivity() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5820 +        if (shouldRunFirstRunActivity() &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5821 +                hasFirstRunActivity()) {</span>
5822              Intent firstRunIntent = getFirstRunActivity();
5823              if (firstRunIntent != null) {
5824                  startActivity(firstRunIntent);
5825                  markFirstRunActivityShown();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5826 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5827 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5828 +                return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5829 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5830 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5831 +        return false;</span>
5832      }
5833  
5834      private void markFirstRunActivityShown() {
5835          SharedPreferences.Editor editor = mSharedPrefs.edit();
5836          editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);
5837          editor.apply();
5838      }
5839  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5840 -    public void showFirstRunCling() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5841 -        if (isClingsEnabled() &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5842 -                !mSharedPrefs.getBoolean(Cling.FIRST_RUN_CLING_DISMISSED_KEY, false) &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5843 -                !skipCustomClingIfNoAccounts() ) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5844 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5845 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5846 -            // If we&#x27;re not using the default workspace layout, replace workspace cling</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5847 -            // with a custom workspace cling (usually specified in an overlay)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5848 -            // For now, only do this on tablets</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5849 -            if (!DISABLE_CUSTOM_CLINGS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5850 -                if (mSharedPrefs.getInt(LauncherProvider.DEFAULT_WORKSPACE_RESOURCE_ID, 0) != 0 &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5851 -                        getResources().getBoolean(R.bool.config_useCustomClings)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5852 -                    // Use a custom cling</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5853 -                    View cling = findViewById(R.id.workspace_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5854 -                    ViewGroup clingParent = (ViewGroup) cling.getParent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5855 -                    int clingIndex = clingParent.indexOfChild(cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5856 -                    clingParent.removeViewAt(clingIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5857 -                    View customCling = mInflater.inflate(R.layout.custom_workspace_cling, clingParent, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5858 -                    clingParent.addView(customCling, clingIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5859 -                    customCling.setId(R.id.workspace_cling);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5860 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5861 +     * To be overridden by subclasses to indicate that there is an in-activity full-screen intro</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5862 +     * screen that must be displayed and dismissed.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5863 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5864 +    protected boolean hasDismissableIntroScreen() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5865 +        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5866 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5867 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5868 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5869 +     * Full screen intro screen to be shown and dismissed before the launcher can be used.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5870 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5871 +    protected View getIntroScreen() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5872 +        return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5873 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5874 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5875 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5876 +     * To be overriden by subclasses to indicate whether the in-activity intro screen has been</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5877 +     * dismissed. This method is ignored if #hasDismissableIntroScreen returns false.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5878 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5879 +    private boolean shouldShowIntroScreen() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5880 +        return hasDismissableIntroScreen() &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5881 +                !mSharedPrefs.getBoolean(INTRO_SCREEN_DISMISSED, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5882 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5883 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5884 +    protected void showIntroScreen() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5885 +        View introScreen = getIntroScreen();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5886 +        changeWallpaperVisiblity(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5887 +        if (introScreen != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5888 +            mDragLayer.showOverlayView(introScreen);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5889 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5890 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5891 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5892 +    public void dismissIntroScreen() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5893 +        markIntroScreenDismissed();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5894 +        if (showFirstRunActivity()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5895 +            // We delay hiding the intro view until the first run activity is showing. This</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5896 +            // avoids a blip.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5897 +            mWorkspace.postDelayed(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5898 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5899 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5900 +                    mDragLayer.dismissOverlayView();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5901 +                    showFirstRunClings();</span>
5902                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5903 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5904 -            Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5905 -            if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5906 -                String sbHintStr = getFirstRunClingSearchBarHint();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5907 -                String ccHintStr = getFirstRunCustomContentHint();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5908 -                if (!sbHintStr.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5909 -                    TextView sbHint = (TextView) cling.findViewById(R.id.search_bar_hint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5910 -                    sbHint.setText(sbHintStr);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5911 -                    sbHint.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5912 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5913 -                setCustomContentHintVisibility(cling, ccHintStr, true, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5914 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5915 -            initCling(R.id.first_run_cling, 0, false, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5916 +            }, ACTIVITY_START_DELAY);</span>
5917          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5918 -            removeCling(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5919 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5920 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5921 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5922 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5923 -     * Called when the SearchBar hint should be changed.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5924 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5925 -     * @param hint the hint to be displayed in the search bar.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5926 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5927 -    protected void onSearchBarHintChanged(String hint) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5928 -        Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5929 -        if (cling != null &amp;&amp; cling.getVisibility() == View.VISIBLE &amp;&amp; !hint.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5930 -            TextView sbHint = (TextView) cling.findViewById(R.id.search_bar_hint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5931 -            sbHint.setText(hint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5932 -            sbHint.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5933 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5934 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5935 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5936 -    protected String getFirstRunClingSearchBarHint() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5937 -        return &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5938 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5939 -    protected String getFirstRunCustomContentHint() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5940 -        return &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5941 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5942 -    protected int getFirstRunFocusedHotseatAppDrawableId() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5943 -        return -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5944 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5945 -    protected ComponentName getFirstRunFocusedHotseatAppComponentName() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5946 -        return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5947 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5948 -    protected int getFirstRunFocusedHotseatAppRank() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5949 -        return -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5950 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5951 -    protected String getFirstRunFocusedHotseatAppBubbleTitle() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5952 -        return &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5953 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5954 -    protected String getFirstRunFocusedHotseatAppBubbleDescription() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5955 -        return &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5956 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5957 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5958 -    public void showFirstRunWorkspaceCling() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5959 -        // Enable the clings only if they have not been dismissed before</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5960 -        if (isClingsEnabled() &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5961 -                !mSharedPrefs.getBoolean(Cling.WORKSPACE_CLING_DISMISSED_KEY, false)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5962 -            Cling c = initCling(R.id.workspace_cling, 0, false, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5963 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5964 -            // Set the focused hotseat app if there is one</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5965 -            c.setFocusedHotseatApp(getFirstRunFocusedHotseatAppDrawableId(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5966 -                    getFirstRunFocusedHotseatAppRank(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5967 -                    getFirstRunFocusedHotseatAppComponentName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5968 -                    getFirstRunFocusedHotseatAppBubbleTitle(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5969 -                    getFirstRunFocusedHotseatAppBubbleDescription());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5970 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5971 -            removeCling(R.id.workspace_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5972 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5973 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5974 -    public Cling showFirstRunFoldersCling() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5975 -        // Enable the clings only if they have not been dismissed before</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5976 -        if (isClingsEnabled() &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5977 -                !mSharedPrefs.getBoolean(Cling.FOLDER_CLING_DISMISSED_KEY, false)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5978 -            Cling cling = initCling(R.id.folder_cling, R.id.cling_scrim,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5979 -                    true, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5980 -            return cling;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5981 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">5982 -            removeCling(R.id.folder_cling);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5983 +            mDragLayer.dismissOverlayView();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5984 +            showFirstRunClings();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5985 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5986 +        changeWallpaperVisiblity(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5987 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5988 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5989 +    private void markIntroScreenDismissed() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5990 +        SharedPreferences.Editor editor = mSharedPrefs.edit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5991 +        editor.putBoolean(INTRO_SCREEN_DISMISSED, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5992 +        editor.apply();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5993 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5994 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5995 +    private void showFirstRunClings() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5996 +        // The two first run cling paths are mutually exclusive, if the launcher is preinstalled</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5997 +        // on the device, then we always show the first run cling experience (or if there is no</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5998 +        // launcher2). Otherwise, we prompt the user upon started for migration</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">5999 +        LauncherClings launcherClings = new LauncherClings(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6000 +        if (launcherClings.shouldShowFirstRunOrMigrationClings()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6001 +            if (mModel.canMigrateFromOldLauncherDb(this)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6002 +                launcherClings.showMigrationCling();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6003 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6004 +                launcherClings.showLongPressCling(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6005 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6006 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6007 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6008 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6009 +    void showWorkspaceSearchAndHotseat() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6010 +        if (mWorkspace != null) mWorkspace.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6011 +        if (mHotseat != null) mHotseat.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6012 +        if (mPageIndicators != null) mPageIndicators.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6013 +        if (mSearchDropTargetBar != null) mSearchDropTargetBar.showSearchBar(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6014 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6015 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6016 +    void hideWorkspaceSearchAndHotseat() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6017 +        if (mWorkspace != null) mWorkspace.setAlpha(0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6018 +        if (mHotseat != null) mHotseat.setAlpha(0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6019 +        if (mPageIndicators != null) mPageIndicators.setAlpha(0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6020 +        if (mSearchDropTargetBar != null) mSearchDropTargetBar.hideSearchBar(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6021 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6022 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6023 +    public ItemInfo createAppDragInfo(Intent appLaunchIntent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6024 +        // Called from search suggestion, not supported in other profiles.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6025 +        final UserHandleCompat myUser = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6026 +        LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6027 +        LauncherActivityInfoCompat activityInfo = launcherApps.resolveActivity(appLaunchIntent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6028 +                myUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6029 +        if (activityInfo == null) {</span>
6030              return null;
6031          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6032 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6033 -    protected SharedPreferences getSharedPrefs() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6034 -        return mSharedPrefs;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6035 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6036 -    public boolean isFolderClingVisible() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6037 -        Cling cling = (Cling) findViewById(R.id.folder_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6038 -        if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6039 -            return cling.getVisibility() == View.VISIBLE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6040 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6041 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6042 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6043 -    public void dismissFirstRunCling(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6044 -        Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6045 -        Runnable cb = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6046 -            public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6047 -                // Show the workspace cling next</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6048 -                showFirstRunWorkspaceCling();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6049 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6050 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6051 -        dismissCling(cling, cb, Cling.FIRST_RUN_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6052 -                DISMISS_CLING_DURATION, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6053 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6054 -        // Fade out the search bar for the workspace cling coming up</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6055 -        mSearchDropTargetBar.hideSearchBar(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6056 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6057 -    public void dismissWorkspaceCling(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6058 -        Cling cling = (Cling) findViewById(R.id.workspace_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6059 -        Runnable cb = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6060 -        if (v == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6061 -            cb = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6062 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6063 -                    mWorkspace.enterOverviewMode();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6064 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6065 -            };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6066 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6067 -        dismissCling(cling, cb, Cling.WORKSPACE_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6068 -                DISMISS_CLING_DURATION, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6069 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6070 -        // Fade in the search bar</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6071 -        mSearchDropTargetBar.showSearchBar(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6072 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6073 -    public void dismissFolderCling(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6074 -        Cling cling = (Cling) findViewById(R.id.folder_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6075 -        dismissCling(cling, null, Cling.FOLDER_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6076 -                DISMISS_CLING_DURATION, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6077 -    }</span>














<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6078 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6079 -    public ItemInfo createAppDragInfo(Intent appLaunchIntent) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6080 -        ResolveInfo ri = getPackageManager().resolveActivity(appLaunchIntent, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6081 -        if (ri == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6082 -            return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6083 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6084 -        return new AppInfo(getPackageManager(), ri, mIconCache, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6085 +        return new AppInfo(this, activityInfo, myUser, mIconCache, null);</span>
6086      }
6087  
6088      public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
6089              Bitmap icon) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6090 -        return new ShortcutInfo(shortcutIntent, caption, icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6091 +        // Called from search suggestion, not supported in other profiles.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6092 +        return createShortcutDragInfo(shortcutIntent, caption, icon,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6093 +                UserHandleCompat.myUserHandle());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6094 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6095 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6096 +    public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6097 +            Bitmap icon, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6098 +        UserManagerCompat userManager = UserManagerCompat.getInstance(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6099 +        CharSequence contentDescription = userManager.getBadgedLabelForUser(caption, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6100 +        return new ShortcutInfo(shortcutIntent, caption, contentDescription, icon, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6101 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6102 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6103 +    protected void moveWorkspaceToDefaultScreen() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6104 +        mWorkspace.moveToDefaultScreen(false);</span>
6105      }
6106  
6107      public void startDrag(View dragView, ItemInfo dragInfo, DragSource source) {
6108          dragView.setTag(dragInfo);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6109 -        mWorkspace.onDragStartedWithItem(dragView);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">6110 -        mWorkspace.beginDragShared(dragView, source);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6111 +        mWorkspace.onExternalDragStartedWithItem(dragView);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6112 +        mWorkspace.beginExternalDragShared(dragView, source);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6113 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6114 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6115 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6116 +    public void onPageSwitch(View newPage, int newPageIndex) {</span>
6117      }
6118  
6119      /**
6120       * Prints out out state for debugging.
6121       */
6122      public void dumpState() {
6123          Log.d(TAG, &quot;BEGIN launcher3 dump state for launcher &quot; + this);
6124          Log.d(TAG, &quot;mSavedState=&quot; + mSavedState);
6125          Log.d(TAG, &quot;mWorkspaceLoading=&quot; + mWorkspaceLoading);
6126          Log.d(TAG, &quot;mRestoring=&quot; + mRestoring);
6127          Log.d(TAG, &quot;mWaitingForResult=&quot; + mWaitingForResult);
6128          Log.d(TAG, &quot;mSavedInstanceState=&quot; + mSavedInstanceState);
6129          Log.d(TAG, &quot;sFolders.size=&quot; + sFolders.size());
6130          mModel.dumpState();
6131  
6132          if (mAppsCustomizeContent != null) {
6133              mAppsCustomizeContent.dumpState();
6134          }
6135          Log.d(TAG, &quot;END launcher3 dump state&quot;);
6136      }
6137  
6138      @Override
6139      public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
6140          super.dump(prefix, fd, writer, args);
6141          synchronized (sDumpLogs) {
6142              writer.println(&quot; &quot;);
6143              writer.println(&quot;Debug logs: &quot;);
6144              for (int i = 0; i &lt; sDumpLogs.size(); i++) {
6145                  writer.println(&quot;  &quot; + sDumpLogs.get(i));
6146              }
6147          }
6148      }
6149  
6150      public static void dumpDebugLogsToConsole() {
6151          if (DEBUG_DUMP_LOG) {
6152              synchronized (sDumpLogs) {
6153                  Log.d(TAG, &quot;&quot;);
6154                  Log.d(TAG, &quot;*********************&quot;);
6155                  Log.d(TAG, &quot;Launcher debug logs: &quot;);
6156                  for (int i = 0; i &lt; sDumpLogs.size(); i++) {
6157                      Log.d(TAG, &quot;  &quot; + sDumpLogs.get(i));
6158                  }
6159                  Log.d(TAG, &quot;*********************&quot;);
6160                  Log.d(TAG, &quot;&quot;);
6161              }
6162          }
6163      }
6164  
6165      public static void addDumpLog(String tag, String log, boolean debugLog) {
6166          addDumpLog(tag, log, null, debugLog);
6167      }
6168  
6169      public static void addDumpLog(String tag, String log, Exception e, boolean debugLog) {
6170          if (debugLog) {
6171              if (e != null) {
6172                  Log.d(tag, log, e);
6173              } else {
6174                  Log.d(tag, log);
6175              }
6176          }
6177          if (DEBUG_DUMP_LOG) {
6178              sDateStamp.setTime(System.currentTimeMillis());
6179              synchronized (sDumpLogs) {
6180                  sDumpLogs.add(sDateFormat.format(sDateStamp) + &quot;: &quot; + tag + &quot;, &quot; + log
6181                      + (e == null ? &quot;&quot; : (&quot;, Exception: &quot; + e)));
6182              }
6183          }
6184      }
6185  
6186      public void dumpLogsToLocalData() {
6187          if (DEBUG_DUMP_LOG) {
6188              new AsyncTask&lt;Void, Void, Void&gt;() {
6189                  public Void doInBackground(Void ... args) {
6190                      boolean success = false;
6191                      sDateStamp.setTime(sRunStart);
6192                      String FILENAME = sDateStamp.getMonth() + &quot;-&quot;
6193                              + sDateStamp.getDay() + &quot;_&quot;
6194                              + sDateStamp.getHours() + &quot;-&quot;
6195                              + sDateStamp.getMinutes() + &quot;_&quot;
6196                              + sDateStamp.getSeconds() + &quot;.txt&quot;;
6197  
6198                      FileOutputStream fos = null;
6199                      File outFile = null;
6200                      try {
6201                          outFile = new File(getFilesDir(), FILENAME);
6202                          outFile.createNewFile();
6203                          fos = new FileOutputStream(outFile);
6204                      } catch (Exception e) {
6205                          e.printStackTrace();
6206                      }
6207                      if (fos != null) {
6208                          PrintWriter writer = new PrintWriter(fos);
6209  
6210                          writer.println(&quot; &quot;);
6211                          writer.println(&quot;Debug logs: &quot;);
6212                          synchronized (sDumpLogs) {
6213                              for (int i = 0; i &lt; sDumpLogs.size(); i++) {
6214                                  writer.println(&quot;  &quot; + sDumpLogs.get(i));
6215                              }
6216                          }
6217                          writer.close();
6218                      }
6219                      try {
6220                          if (fos != null) {
6221                              fos.close();
6222                              success = true;
6223                          }
6224                      } catch (IOException e) {
6225                          e.printStackTrace();
6226                      }
6227                      return null;
6228                  }
6229              }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
6230          }
6231      }
6232  }
6233  
6234  interface LauncherTransitionable {
6235      View getContent();
6236      void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace);
6237      void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace);
6238      void onLauncherTransitionStep(Launcher l, float t);
6239      void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace);
6240  }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6242 +interface DebugIntents {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6243 +    static final String DELETE_DATABASE = &quot;com.android.launcher3.action.DELETE_DATABASE&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6244 +    static final String MIGRATE_DATABASE = &quot;com.android.launcher3.action.MIGRATE_DATABASE&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">6245 +}</span></pre></td>
                            <td><pre>   1  
   2  /*
   3   * Copyright (C) 2008 The Android Open Source Project
   4   *
   5   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   6   * you may not use this file except in compliance with the License.
   7   * You may obtain a copy of the License at
   8   *
   9   *      http://www.apache.org/licenses/LICENSE-2.0
  10   *
  11   * Unless required by applicable law or agreed to in writing, software
  12   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  13   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  14   * See the License for the specific language governing permissions and
  15   * limitations under the License.
  16   */
  17  
  18  package com.android.launcher3;
  19  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -import android.accounts.Account;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import android.accounts.AccountManager;</span>
  22  import android.animation.Animator;
  23  import android.animation.AnimatorListenerAdapter;
  24  import android.animation.AnimatorSet;
  25  import android.animation.ObjectAnimator;
  26  import android.animation.PropertyValuesHolder;

  27  import android.animation.ValueAnimator;
  28  import android.animation.ValueAnimator.AnimatorUpdateListener;

  29  import android.app.Activity;
  30  import android.app.ActivityManager;
  31  import android.app.ActivityOptions;

  32  import android.app.SearchManager;
  33  import android.appwidget.AppWidgetHostView;
  34  import android.appwidget.AppWidgetManager;
  35  import android.appwidget.AppWidgetProviderInfo;
  36  import android.content.ActivityNotFoundException;
  37  import android.content.BroadcastReceiver;
  38  import android.content.ComponentCallbacks2;
  39  import android.content.ComponentName;
  40  import android.content.ContentResolver;
  41  import android.content.Context;

  42  import android.content.Intent;
  43  import android.content.IntentFilter;
  44  import android.content.SharedPreferences;
  45  import android.content.pm.ActivityInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +import android.content.pm.ApplicationInfo;</span>
  47  import android.content.pm.PackageManager;
  48  import android.content.pm.PackageManager.NameNotFoundException;
  49  import android.content.pm.ResolveInfo;
  50  import android.content.res.Configuration;
  51  import android.content.res.Resources;
  52  import android.database.ContentObserver;
  53  import android.graphics.Bitmap;
  54  import android.graphics.Canvas;

  55  import android.graphics.Point;
  56  import android.graphics.PorterDuff;
  57  import android.graphics.Rect;
  58  import android.graphics.drawable.Drawable;
  59  import android.net.Uri;
  60  import android.os.AsyncTask;

  61  import android.os.Bundle;
  62  import android.os.Environment;
  63  import android.os.Handler;
  64  import android.os.Message;
  65  import android.os.StrictMode;
  66  import android.os.SystemClock;
  67  import android.provider.Settings;
  68  import android.speech.RecognizerIntent;
  69  import android.text.Selection;
  70  import android.text.SpannableStringBuilder;
  71  import android.text.TextUtils;
  72  import android.text.method.TextKeyListener;
  73  import android.util.DisplayMetrics;
  74  import android.util.Log;

  75  import android.view.Display;
  76  import android.view.Gravity;
  77  import android.view.HapticFeedbackConstants;
  78  import android.view.KeyEvent;
  79  import android.view.LayoutInflater;
  80  import android.view.Menu;
  81  import android.view.MotionEvent;
  82  import android.view.Surface;
  83  import android.view.View;
  84  import android.view.View.OnClickListener;
  85  import android.view.View.OnLongClickListener;

  86  import android.view.ViewGroup;
  87  import android.view.ViewTreeObserver;
  88  import android.view.ViewTreeObserver.OnGlobalLayoutListener;

  89  import android.view.WindowManager;
  90  import android.view.accessibility.AccessibilityEvent;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -import android.view.accessibility.AccessibilityManager;</span>
  92  import android.view.animation.AccelerateDecelerateInterpolator;

  93  import android.view.animation.DecelerateInterpolator;

  94  import android.view.inputmethod.InputMethodManager;
  95  import android.widget.Advanceable;
  96  import android.widget.FrameLayout;
  97  import android.widget.ImageView;
  98  import android.widget.TextView;
  99  import android.widget.Toast;
 100  
 101  import com.android.launcher3.DropTarget.DragObject;








 102  
 103  import java.io.DataInputStream;
 104  import java.io.DataOutputStream;
 105  import java.io.File;
 106  import java.io.FileDescriptor;
 107  import java.io.FileNotFoundException;
 108  import java.io.FileOutputStream;
 109  import java.io.IOException;
 110  import java.io.PrintWriter;



 111  import java.text.DateFormat;
 112  import java.util.ArrayList;
 113  import java.util.Collection;
 114  import java.util.Date;
 115  import java.util.HashMap;
 116  import java.util.List;
 117  import java.util.concurrent.atomic.AtomicInteger;
 118  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +</span>
 120  /**
 121   * Default launcher application.
 122   */
 123  public class Launcher extends Activity
 124          implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,
 125                     View.OnTouchListener {

 126      static final String TAG = &quot;Launcher&quot;;
 127      static final boolean LOGD = false;
 128  
 129      static final boolean PROFILE_STARTUP = false;
 130      static final boolean DEBUG_WIDGETS = false;
 131      static final boolean DEBUG_STRICT_MODE = false;
 132      static final boolean DEBUG_RESUME_TIME = false;
 133      static final boolean DEBUG_DUMP_LOG = false;
 134  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +    static final boolean ENABLE_DEBUG_INTENTS = false; // allow DebugIntents to run</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +</span>
 137      private static final int REQUEST_CREATE_SHORTCUT = 1;
 138      private static final int REQUEST_CREATE_APPWIDGET = 5;
 139      private static final int REQUEST_PICK_APPLICATION = 6;
 140      private static final int REQUEST_PICK_SHORTCUT = 7;
 141      private static final int REQUEST_PICK_APPWIDGET = 9;
 142      private static final int REQUEST_PICK_WALLPAPER = 10;
 143  
 144      private static final int REQUEST_BIND_APPWIDGET = 11;

 145  
 146      /**
 147       * IntentStarter uses request codes starting with this. This must be greater than all activity
 148       * request codes used internally.
 149       */
 150      protected static final int REQUEST_LAST = 100;
 151  
 152      static final String EXTRA_SHORTCUT_DUPLICATE = &quot;duplicate&quot;;
 153  
 154      static final int SCREEN_COUNT = 5;
 155      static final int DEFAULT_SCREEN = 2;
 156  
 157      private static final String PREFERENCES = &quot;launcher.preferences&quot;;
 158      // To turn on these properties, type
 159      // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
 160      static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
 161      static final String DUMP_STATE_PROPERTY = &quot;launcher_dump_state&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +    static final String DISABLE_ALL_APPS_PROPERTY = &quot;launcher_noallapps&quot;;</span>
 163  
 164      // The Intent extra that defines whether to ignore the launch animation
 165      static final String INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION =
 166              &quot;com.android.launcher3.intent.extra.shortcut.INGORE_LAUNCH_ANIMATION&quot;;
 167  
 168      // Type: int
 169      private static final String RUNTIME_STATE_CURRENT_SCREEN = &quot;launcher.current_screen&quot;;
 170      // Type: int
 171      private static final String RUNTIME_STATE = &quot;launcher.state&quot;;
 172      // Type: int
 173      private static final String RUNTIME_STATE_PENDING_ADD_CONTAINER = &quot;launcher.add_container&quot;;
 174      // Type: int
 175      private static final String RUNTIME_STATE_PENDING_ADD_SCREEN = &quot;launcher.add_screen&quot;;
 176      // Type: int
 177      private static final String RUNTIME_STATE_PENDING_ADD_CELL_X = &quot;launcher.add_cell_x&quot;;
 178      // Type: int
 179      private static final String RUNTIME_STATE_PENDING_ADD_CELL_Y = &quot;launcher.add_cell_y&quot;;
 180      // Type: boolean
 181      private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME = &quot;launcher.rename_folder&quot;;
 182      // Type: long
 183      private static final String RUNTIME_STATE_PENDING_FOLDER_RENAME_ID = &quot;launcher.rename_folder_id&quot;;
 184      // Type: int
 185      private static final String RUNTIME_STATE_PENDING_ADD_SPAN_X = &quot;launcher.add_span_x&quot;;
 186      // Type: int
 187      private static final String RUNTIME_STATE_PENDING_ADD_SPAN_Y = &quot;launcher.add_span_y&quot;;
 188      // Type: parcelable
 189      private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_INFO = &quot;launcher.add_widget_info&quot;;
 190      // Type: parcelable
 191      private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_ID = &quot;launcher.add_widget_id&quot;;
 192      // Type: int[]
 193      private static final String RUNTIME_STATE_VIEW_IDS = &quot;launcher.view_ids&quot;;
 194  
 195  

 196      static final String FIRST_RUN_ACTIVITY_DISPLAYED = &quot;launcher.first_run_activity_displayed&quot;;




 197  
 198      private static final String TOOLBAR_ICON_METADATA_NAME = &quot;com.android.launcher.toolbar_icon&quot;;
 199      private static final String TOOLBAR_SEARCH_ICON_METADATA_NAME =
 200              &quot;com.android.launcher.toolbar_search_icon&quot;;
 201      private static final String TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME =
 202              &quot;com.android.launcher.toolbar_voice_search_icon&quot;;
 203  
 204      public static final String SHOW_WEIGHT_WATCHER = &quot;debug.show_mem&quot;;
 205      public static final boolean SHOW_WEIGHT_WATCHER_DEFAULT = false;
 206  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +    public static final String USER_HAS_MIGRATED = &quot;launcher.user_migrated_from_old_data&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +</span>
 209      /** The different states that Launcher can be in. */
 210      private enum State { NONE, WORKSPACE, APPS_CUSTOMIZE, APPS_CUSTOMIZE_SPRING_LOADED };
 211      private State mState = State.WORKSPACE;
 212      private AnimatorSet mStateAnimation;
 213  


 214      static final int APPWIDGET_HOST_ID = 1024;
 215      public static final int EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT = 300;
 216      private static final int ON_ACTIVITY_RESULT_ANIMATION_DELAY = 500;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 217 -    private static final int SHOW_CLING_DURATION = 250;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -    private static final int DISMISS_CLING_DURATION = 200;</span>

 219  
 220      private static final Object sLock = new Object();
 221      private static int sScreen = DEFAULT_SCREEN;
 222  
 223      private HashMap&lt;Integer, Integer&gt; mItemIdToViewId = new HashMap&lt;Integer, Integer&gt;();
 224      private static final AtomicInteger sNextGeneratedId = new AtomicInteger(1);
 225  
 226      // How long to wait before the new-shortcut animation automatically pans the workspace
 227      private static int NEW_APPS_PAGE_MOVE_DELAY = 500;
 228      private static int NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS = 5;
 229      private static int NEW_APPS_ANIMATION_DELAY = 500;

 230  
 231      private final BroadcastReceiver mCloseSystemDialogsReceiver
 232              = new CloseSystemDialogsIntentReceiver();
 233      private final ContentObserver mWidgetObserver = new AppWidgetResetObserver();
 234  
 235      private LayoutInflater mInflater;
 236  
 237      private Workspace mWorkspace;
 238      private View mLauncherView;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +    private View mPageIndicators;</span>
 240      private DragLayer mDragLayer;
 241      private DragController mDragController;
 242      private View mWeightWatcher;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +    private LauncherClings mLauncherClings;</span>
 244  
 245      private AppWidgetManager mAppWidgetManager;

 246      private LauncherAppWidgetHost mAppWidgetHost;
 247  
 248      private ItemInfo mPendingAddInfo = new ItemInfo();
 249      private AppWidgetProviderInfo mPendingAddWidgetInfo;
 250      private int mPendingAddWidgetId = -1;
 251  
 252      private int[] mTmpAddItemCellCoordinates = new int[2];
 253  
 254      private FolderInfo mFolderInfo;
 255  
 256      private Hotseat mHotseat;
 257      private View mOverviewPanel;

 258  
 259      private View mAllAppsButton;
 260  
 261      private SearchDropTargetBar mSearchDropTargetBar;
 262      private AppsCustomizeTabHost mAppsCustomizeTabHost;
 263      private AppsCustomizePagedView mAppsCustomizeContent;
 264      private boolean mAutoAdvanceRunning = false;
 265      private View mQsbBar;

 266  
 267      private Bundle mSavedState;
 268      // We set the state in both onCreate and then onNewIntent in some cases, which causes both
 269      // scroll issues (because the workspace may not have been measured yet) and extra work.
 270      // Instead, just save the state that we need to restore Launcher to, and commit it in onResume.
 271      private State mOnResumeState = State.NONE;
 272  
 273      private SpannableStringBuilder mDefaultKeySsb = null;
 274  
 275      private boolean mWorkspaceLoading = true;
 276  
 277      private boolean mPaused = true;
 278      private boolean mRestoring;
 279      private boolean mWaitingForResult;
 280      private boolean mOnResumeNeedsLoad;
 281  
 282      private ArrayList&lt;Runnable&gt; mBindOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 283      private ArrayList&lt;Runnable&gt; mOnResumeCallbacks = new ArrayList&lt;Runnable&gt;();
 284  
 285      // Keep track of whether the user has left launcher
 286      private static boolean sPausedFromUserAction = false;
 287  
 288      private Bundle mSavedInstanceState;
 289  
 290      private LauncherModel mModel;
 291      private IconCache mIconCache;
 292      private boolean mUserPresent = true;
 293      private boolean mVisible = false;
 294      private boolean mHasFocus = false;
 295      private boolean mAttached = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 296 -    private static final boolean DISABLE_CLINGS = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 297 -    private static final boolean DISABLE_CUSTOM_CLINGS = true;</span>
 298  
 299      private static LocaleConfiguration sLocaleConfiguration = null;
 300  
 301      private static HashMap&lt;Long, FolderInfo&gt; sFolders = new HashMap&lt;Long, FolderInfo&gt;();
 302  
 303      private View.OnTouchListener mHapticFeedbackTouchListener;
 304  
 305      // Related to the auto-advancing of widgets
 306      private final int ADVANCE_MSG = 1;
 307      private final int mAdvanceInterval = 20000;
 308      private final int mAdvanceStagger = 250;
 309      private long mAutoAdvanceSentTime;
 310      private long mAutoAdvanceTimeLeft = -1;
 311      private HashMap&lt;View, AppWidgetProviderInfo&gt; mWidgetsToAdvance =
 312          new HashMap&lt;View, AppWidgetProviderInfo&gt;();
 313  
 314      // Determines how long to wait after a rotation before restoring the screen orientation to
 315      // match the sensor state.
 316      private final int mRestoreScreenOrientationDelay = 500;
 317  
 318      // External icons saved in case of resource changes, orientation, etc.
 319      private static Drawable.ConstantState[] sGlobalSearchIcon = new Drawable.ConstantState[2];
 320      private static Drawable.ConstantState[] sVoiceSearchIcon = new Drawable.ConstantState[2];
 321      private static Drawable.ConstantState[] sAppMarketIcon = new Drawable.ConstantState[2];
 322  
 323      private Intent mAppMarketIntent = null;
 324      private static final boolean DISABLE_MARKET_BUTTON = true;
 325  
 326      private Drawable mWorkspaceBackgroundDrawable;
 327  
 328      private final ArrayList&lt;Integer&gt; mSynchronouslyBoundPages = new ArrayList&lt;Integer&gt;();
 329      private static final boolean DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE = false;
 330  
 331      static final ArrayList&lt;String&gt; sDumpLogs = new ArrayList&lt;String&gt;();
 332      static Date sDateStamp = new Date();
 333      static DateFormat sDateFormat =
 334              DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
 335      static long sRunStart = System.currentTimeMillis();
 336      static final String CORRUPTION_EMAIL_SENT_KEY = &quot;corruptionEmailSent&quot;;
 337  
 338      // We only want to get the SharedPreferences once since it does an FS stat each time we get
 339      // it from the context.
 340      private SharedPreferences mSharedPrefs;
 341  
 342      private static ArrayList&lt;ComponentName&gt; mIntentsOnWorkspaceFromUpgradePath = null;
 343  
 344      // Holds the page that we need to animate to, and the icon views that we need to animate up
 345      // when we scroll to that page on resume.
 346      private ImageView mFolderIconImageView;
 347      private Bitmap mFolderIconBitmap;
 348      private Canvas mFolderIconCanvas;
 349      private Rect mRectForFolderAnimation = new Rect();
 350  
 351      private BubbleTextView mWaitingForResume;
 352  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 353 -    private HideFromAccessibilityHelper mHideFromAccessibilityHelper</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 354 -        = new HideFromAccessibilityHelper();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 355 -</span>
 356      private Runnable mBuildLayersRunnable = new Runnable() {
 357          public void run() {
 358              if (mWorkspace != null) {
 359                  mWorkspace.buildPageHardwareLayers();
 360              }
 361          }
 362      };
 363  
 364      private static ArrayList&lt;PendingAddArguments&gt; sPendingAddList
 365              = new ArrayList&lt;PendingAddArguments&gt;();

 366  
 367      public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
 368  
 369      private static class PendingAddArguments {
 370          int requestCode;
 371          Intent intent;
 372          long container;
 373          long screenId;
 374          int cellX;
 375          int cellY;

 376      }
 377  
 378      private Stats mStats;
 379  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 380 -    private static boolean isPropertyEnabled(String propertyName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 381 +    static boolean isPropertyEnabled(String propertyName) {</span>


 382          return Log.isLoggable(propertyName, Log.VERBOSE);
 383      }
 384  
 385      @Override
 386      protected void onCreate(Bundle savedInstanceState) {
 387          if (DEBUG_STRICT_MODE) {
 388              StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
 389                      .detectDiskReads()
 390                      .detectDiskWrites()
 391                      .detectNetwork()   // or .detectAll() for all detectable problems
 392                      .penaltyLog()
 393                      .build());
 394              StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
 395                      .detectLeakedSqlLiteObjects()
 396                      .detectLeakedClosableObjects()
 397                      .penaltyLog()
 398                      .penaltyDeath()
 399                      .build());
 400          }
 401  
 402          super.onCreate(savedInstanceState);
 403  
 404          LauncherAppState.setApplicationContext(getApplicationContext());
 405          LauncherAppState app = LauncherAppState.getInstance();
 406  

 407          // Determine the dynamic grid properties
 408          Point smallestSize = new Point();
 409          Point largestSize = new Point();
 410          Point realSize = new Point();
 411          Display display = getWindowManager().getDefaultDisplay();
 412          display.getCurrentSizeRange(smallestSize, largestSize);
 413          display.getRealSize(realSize);
 414          DisplayMetrics dm = new DisplayMetrics();
 415          display.getMetrics(dm);
 416  
 417          // Lazy-initialize the dynamic grid
 418          DeviceProfile grid = app.initDynamicGrid(this,
 419                  Math.min(smallestSize.x, smallestSize.y),
 420                  Math.min(largestSize.x, largestSize.y),
 421                  realSize.x, realSize.y,
 422                  dm.widthPixels, dm.heightPixels);
 423  
 424          // the LauncherApplication should call this, but in case of Instrumentation it might not be present yet
 425          mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(),
 426                  Context.MODE_PRIVATE);

 427          mModel = app.setLauncher(this);
 428          mIconCache = app.getIconCache();
 429          mIconCache.flushInvalidIcons(grid);
 430          mDragController = new DragController(this);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 431 +        mLauncherClings = new LauncherClings(this);</span>
 432          mInflater = getLayoutInflater();
 433  
 434          mStats = new Stats(this);
 435  
 436          mAppWidgetManager = AppWidgetManager.getInstance(this);

 437  
 438          mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
 439          mAppWidgetHost.startListening();
 440  
 441          // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
 442          // this also ensures that any synchronous binding below doesn&#x27;t re-trigger another
 443          // LauncherModel load.
 444          mPaused = false;
 445  
 446          if (PROFILE_STARTUP) {
 447              android.os.Debug.startMethodTracing(
 448                      Environment.getExternalStorageDirectory() + &quot;/launcher&quot;);
 449          }
 450  
 451  
 452          checkForLocaleChange();
 453          setContentView(R.layout.launcher);
 454  
 455          setupViews();
 456          grid.layout(this);
 457  
 458          registerContentObservers();
 459  
 460          lockAllApps();
 461  
 462          mSavedState = savedInstanceState;
 463          restoreState(mSavedState);
 464  
 465          if (PROFILE_STARTUP) {
 466              android.os.Debug.stopMethodTracing();
 467          }
 468  
 469          if (!mRestoring) {
 470              if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE || sPausedFromUserAction) {

 471                  // If the user leaves launcher, then we should just load items asynchronously when
 472                  // they return.
 473                  mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
 474              } else {
 475                  // We only load the page synchronously if the user rotates (or triggers a
 476                  // configuration change) while launcher is in the foreground
 477                  mModel.startLoader(true, mWorkspace.getRestorePage());
 478              }
 479          }
 480  
 481          // For handling default keys
 482          mDefaultKeySsb = new SpannableStringBuilder();
 483          Selection.setSelection(mDefaultKeySsb, 0);
 484  
 485          IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
 486          registerReceiver(mCloseSystemDialogsReceiver, filter);
 487  
 488          updateGlobalIcons();
 489  
 490          // On large interfaces, we want the screen to auto-rotate based on the current orientation
 491          unlockScreenOrientation(true);
 492  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 493 +        // The two first run cling paths are mutually exclusive, if the launcher is preinstalled</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 494 +        // on the device, then we always show the first run cling experience (or if there is no</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 495 +        // launcher2). Otherwise, we prompt the user upon started for migration</span>
 496          showFirstRunActivity();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -        showFirstRunCling();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 498 +        if (mLauncherClings.shouldShowFirstRunOrMigrationClings()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 499 +            if (mModel.canMigrateFromOldLauncherDb(this)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 500 +                mLauncherClings.showMigrationCling();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 501 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 502 +                mLauncherClings.showFirstRunCling();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 503 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 504 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 505 +            mLauncherClings.removeFirstRunAndMigrationClings();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 506 +        }</span>
 507      }
 508  
 509      protected void onUserLeaveHint() {
 510          super.onUserLeaveHint();
 511          sPausedFromUserAction = true;
 512      }










 513  
 514      /** To be overriden by subclasses to hint to Launcher that we have custom content */
 515      protected boolean hasCustomContentToLeft() {
 516          return false;
 517      }
 518  
 519      /**
 520       * To be overridden by subclasses to create the custom content and call

 521       * {@link #addToCustomContentPage}. This will only be invoked if
 522       * {@link #hasCustomContentToLeft()} is {@code true}.
 523       */
 524      protected void addCustomContentToLeft() {
 525      }
 526  
 527      /**
 528       * To be overridden by subclasses to indicate that there is an activity to launch
 529       * before showing the standard launcher experience.
 530       */
 531      protected boolean hasFirstRunActivity() {
 532          return false;
 533      }
 534  
 535      /**
 536       * To be overridden by subclasses to launch any first run activity
 537       */
 538      protected Intent getFirstRunActivity() {
 539          return null;

 540      }
 541  
 542      /**
 543       * Invoked by subclasses to signal a change to the {@link #addCustomContentToLeft} value to
 544       * ensure the custom content page is added or removed if necessary.
 545       */
 546      protected void invalidateHasCustomContentToLeft() {
 547          if (mWorkspace == null || mWorkspace.getScreenOrder().isEmpty()) {
 548              // Not bound yet, wait for bindScreens to be called.
 549              return;
 550          }
 551  
 552          if (!mWorkspace.hasCustomContent() &amp;&amp; hasCustomContentToLeft()) {
 553              // Create the custom content page and call the subclass to populate it.
 554              mWorkspace.createCustomContentPage();
 555              addCustomContentToLeft();


 556          } else if (mWorkspace.hasCustomContent() &amp;&amp; !hasCustomContentToLeft()) {
 557              mWorkspace.removeCustomContentPage();
 558          }
 559      }
 560  
 561      private void updateGlobalIcons() {
 562          boolean searchVisible = false;
 563          boolean voiceVisible = false;
 564          // If we have a saved version of these external icons, we load them up immediately
 565          int coi = getCurrentOrientationIndexForGlobalIcons();
 566          if (sGlobalSearchIcon[coi] == null || sVoiceSearchIcon[coi] == null ||
 567                  sAppMarketIcon[coi] == null) {
 568              if (!DISABLE_MARKET_BUTTON) {
 569                  updateAppMarketIcon();
 570              }

 571              searchVisible = updateGlobalSearchIcon();
 572              voiceVisible = updateVoiceSearchIcon(searchVisible);
 573          }
 574          if (sGlobalSearchIcon[coi] != null) {
 575               updateGlobalSearchIcon(sGlobalSearchIcon[coi]);
 576               searchVisible = true;
 577          }
 578          if (sVoiceSearchIcon[coi] != null) {
 579              updateVoiceSearchIcon(sVoiceSearchIcon[coi]);
 580              voiceVisible = true;
 581          }
 582          if (!DISABLE_MARKET_BUTTON &amp;&amp; sAppMarketIcon[coi] != null) {
 583              updateAppMarketIcon(sAppMarketIcon[coi]);
 584          }
 585          if (mSearchDropTargetBar != null) {
 586              mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
 587          }
 588      }
 589  
 590      private void checkForLocaleChange() {
 591          if (sLocaleConfiguration == null) {
 592              new AsyncTask&lt;Void, Void, LocaleConfiguration&gt;() {
 593                  @Override
 594                  protected LocaleConfiguration doInBackground(Void... unused) {
 595                      LocaleConfiguration localeConfiguration = new LocaleConfiguration();
 596                      readConfiguration(Launcher.this, localeConfiguration);
 597                      return localeConfiguration;
 598                  }
 599  
 600                  @Override
 601                  protected void onPostExecute(LocaleConfiguration result) {
 602                      sLocaleConfiguration = result;
 603                      checkForLocaleChange();  // recursive, but now with a locale configuration
 604                  }
 605              }.execute();
 606              return;
 607          }
 608  
 609          final Configuration configuration = getResources().getConfiguration();
 610  
 611          final String previousLocale = sLocaleConfiguration.locale;
 612          final String locale = configuration.locale.toString();
 613  
 614          final int previousMcc = sLocaleConfiguration.mcc;
 615          final int mcc = configuration.mcc;
 616  
 617          final int previousMnc = sLocaleConfiguration.mnc;
 618          final int mnc = configuration.mnc;
 619  
 620          boolean localeChanged = !locale.equals(previousLocale) || mcc != previousMcc || mnc != previousMnc;
 621  
 622          if (localeChanged) {
 623              sLocaleConfiguration.locale = locale;
 624              sLocaleConfiguration.mcc = mcc;
 625              sLocaleConfiguration.mnc = mnc;
 626  
 627              mIconCache.flush();
 628  
 629              final LocaleConfiguration localeConfiguration = sLocaleConfiguration;
 630              new AsyncTask&lt;Void, Void, Void&gt;() {
 631                  public Void doInBackground(Void ... args) {
 632                      writeConfiguration(Launcher.this, localeConfiguration);
 633                      return null;
 634                  }
 635              }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 636          }
 637      }
 638  
 639      private static class LocaleConfiguration {
 640          public String locale;
 641          public int mcc = -1;
 642          public int mnc = -1;
 643      }
 644  
 645      private static void readConfiguration(Context context, LocaleConfiguration configuration) {
 646          DataInputStream in = null;
 647          try {
 648              in = new DataInputStream(context.openFileInput(PREFERENCES));
 649              configuration.locale = in.readUTF();
 650              configuration.mcc = in.readInt();
 651              configuration.mnc = in.readInt();
 652          } catch (FileNotFoundException e) {
 653              // Ignore
 654          } catch (IOException e) {
 655              // Ignore
 656          } finally {
 657              if (in != null) {
 658                  try {
 659                      in.close();
 660                  } catch (IOException e) {
 661                      // Ignore
 662                  }
 663              }
 664          }
 665      }
 666  
 667      private static void writeConfiguration(Context context, LocaleConfiguration configuration) {
 668          DataOutputStream out = null;
 669          try {
 670              out = new DataOutputStream(context.openFileOutput(PREFERENCES, MODE_PRIVATE));
 671              out.writeUTF(configuration.locale);
 672              out.writeInt(configuration.mcc);
 673              out.writeInt(configuration.mnc);
 674              out.flush();
 675          } catch (FileNotFoundException e) {
 676              // Ignore
 677          } catch (IOException e) {
 678              //noinspection ResultOfMethodCallIgnored
 679              context.getFileStreamPath(PREFERENCES).delete();
 680          } finally {
 681              if (out != null) {
 682                  try {
 683                      out.close();
 684                  } catch (IOException e) {
 685                      // Ignore
 686                  }
 687              }
 688          }
 689      }
 690  
 691      public Stats getStats() {
 692          return mStats;
 693      }
 694  
 695      public LayoutInflater getInflater() {
 696          return mInflater;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 697 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 698 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 699 -    public DragLayer getDragLayer() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 700 -        return mDragLayer;</span>
 701      }
 702  
 703      boolean isDraggingEnabled() {
 704          // We prevent dragging when we are loading the workspace as it is possible to pick up a view
 705          // that is subsequently removed from the workspace in startBinding().
 706          return !mModel.isLoadingWorkspace();
 707      }
 708  
 709      static int getScreen() {
 710          synchronized (sLock) {
 711              return sScreen;
 712          }
 713      }
 714  
 715      static void setScreen(int screen) {
 716          synchronized (sLock) {
 717              sScreen = screen;
 718          }
 719      }
 720  
 721      /**
 722       * Copied from View -- the View version of the method isn&#x27;t called
 723       * anywhere else in our process and only exists for API level 17+,
 724       * so it&#x27;s ok to keep our own version with no API requirement.
 725       */
 726      public static int generateViewId() {
 727          for (;;) {
 728              final int result = sNextGeneratedId.get();
 729              // aapt-generated IDs have the high byte nonzero; clamp to the range under that.
 730              int newValue = result + 1;
 731              if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.
 732              if (sNextGeneratedId.compareAndSet(result, newValue)) {
 733                  return result;













 734              }
 735          }
 736      }
 737  
 738      public int getViewIdForItem(ItemInfo info) {
 739          // This cast is safe given the &gt; 2B range for int.
 740          int itemId = (int) info.id;
 741          if (mItemIdToViewId.containsKey(itemId)) {
 742              return mItemIdToViewId.get(itemId);
 743          }
 744          int viewId = generateViewId();
 745          mItemIdToViewId.put(itemId, viewId);
 746          return viewId;
 747      }
 748  
 749      /**
 750       * Returns whether we should delay spring loaded mode -- for shortcuts and widgets that have
 751       * a configuration step, this allows the proper animations to run after other transitions.
 752       */
 753      private boolean completeAdd(PendingAddArguments args) {
 754          boolean result = false;








 755          switch (args.requestCode) {
 756              case REQUEST_PICK_APPLICATION:
 757                  completeAddApplication(args.intent, args.container, args.screenId, args.cellX,


 758                          args.cellY);
 759                  break;
 760              case REQUEST_PICK_SHORTCUT:
 761                  processShortcut(args.intent);


 762                  break;
 763              case REQUEST_CREATE_SHORTCUT:
 764                  completeAddShortcut(args.intent, args.container, args.screenId, args.cellX,
 765                          args.cellY);
 766                  result = true;
 767                  break;
 768              case REQUEST_CREATE_APPWIDGET:
 769                  int appWidgetId = args.intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1);
 770                  completeAddAppWidget(appWidgetId, args.container, args.screenId, null, null);
 771                  result = true;


 772                  break;
 773          }
 774          // Before adding this resetAddInfo(), after a shortcut was added to a workspace screen,
 775          // if you turned the screen off and then back while in All Apps, Launcher would not
 776          // return to the workspace. Clearing mAddInfo.container here fixes this issue
 777          resetAddInfo();
 778          return result;

 779      }
 780  
 781      @Override
 782      protected void onActivityResult(
 783              final int requestCode, final int resultCode, final Intent data) {
 784          // Reset the startActivity waiting flag
 785          mWaitingForResult = false;
 786          int pendingAddWidgetId = mPendingAddWidgetId;


 787          mPendingAddWidgetId = -1;
 788  
 789          Runnable exitSpringLoaded = new Runnable() {
 790              @Override
 791              public void run() {
 792                  exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 793                          EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 794              }
 795          };
 796  
 797          if (requestCode == REQUEST_BIND_APPWIDGET) {
 798              final int appWidgetId = data != null ?
 799                      data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1) : -1;
 800              if (resultCode == RESULT_CANCELED) {
 801                  completeTwoStageWidgetDrop(RESULT_CANCELED, appWidgetId);
 802                  mWorkspace.removeExtraEmptyScreen(true, exitSpringLoaded,

 803                          ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 804              } else if (resultCode == RESULT_OK) {
 805                  addAppWidgetImpl(appWidgetId, mPendingAddInfo, null,
 806                          mPendingAddWidgetInfo, ON_ACTIVITY_RESULT_ANIMATION_DELAY);
 807              }
 808              return;
 809          } else if (requestCode == REQUEST_PICK_WALLPAPER) {
 810              if (resultCode == RESULT_OK &amp;&amp; mWorkspace.isInOverviewMode()) {
 811                  mWorkspace.exitOverviewMode(false);
 812              }
 813              return;
 814          }
 815  
 816          boolean isWidgetDrop = (requestCode == REQUEST_PICK_APPWIDGET ||
 817                  requestCode == REQUEST_CREATE_APPWIDGET);
 818  

 819          // We have special handling for widgets
 820          if (isWidgetDrop) {
 821              final int appWidgetId;
 822              int widgetId = data != null ? data.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
 823                      : -1;
 824              if (widgetId &lt; 0) {
 825                  appWidgetId = pendingAddWidgetId;
 826              } else {
 827                  appWidgetId = widgetId;
 828              }
 829  
 830              final int result;
 831              final Runnable onComplete;
 832              if (appWidgetId &lt; 0 || resultCode == RESULT_CANCELED) {
 833                  Log.e(TAG, &quot;Error: appWidgetId (EXTRA_APPWIDGET_ID) was not returned from the \\&quot; +
 834                          &quot;widget configuration activity.&quot;);


 835                  result = RESULT_CANCELED;
 836                  completeTwoStageWidgetDrop(result, appWidgetId);
 837                  onComplete = new Runnable() {

 838                      @Override
 839                      public void run() {
 840                          exitSpringLoadedDragModeDelayed(false, 0, null);
 841                      }
 842                  };








 843              } else {
 844                  result = resultCode;
 845                  final CellLayout dropLayout =
 846                          (CellLayout) mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
 847                  dropLayout.setDropPending(true);
 848                  onComplete = new Runnable() {
 849                      @Override
 850                      public void run() {
 851                          completeTwoStageWidgetDrop(result, appWidgetId);
 852                          dropLayout.setDropPending(false);






 853                      }
 854                  };
 855              }
 856              mWorkspace.removeExtraEmptyScreen(true, onComplete, ON_ACTIVITY_RESULT_ANIMATION_DELAY,
 857                      false);

































 858              return;
 859          }
 860  
 861          // The pattern used here is that a user PICKs a specific application,
 862          // which, depending on the target, might need to CREATE the actual target.
 863  
 864          // For example, the user would PICK_SHORTCUT for &quot;Music playlist&quot;, and we
 865          // launch over to the Music app to actually CREATE_SHORTCUT.
 866          if (resultCode == RESULT_OK &amp;&amp; mPendingAddInfo.container != ItemInfo.NO_ID) {
 867              final PendingAddArguments args = new PendingAddArguments();
 868              args.requestCode = requestCode;
 869              args.intent = data;
 870              args.container = mPendingAddInfo.container;
 871              args.screenId = mPendingAddInfo.screenId;
 872              args.cellX = mPendingAddInfo.cellX;
 873              args.cellY = mPendingAddInfo.cellY;


 874              if (isWorkspaceLocked()) {
 875                  sPendingAddList.add(args);

 876              } else {
 877                  completeAdd(args);
 878              }
 879              mWorkspace.removeExtraEmptyScreen(true, exitSpringLoaded,





 880                      ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 881          } else if (resultCode == RESULT_CANCELED) {
 882              mWorkspace.removeExtraEmptyScreen(true, exitSpringLoaded,
 883                      ON_ACTIVITY_RESULT_ANIMATION_DELAY, false);
 884          }
 885          mDragLayer.clearAnimatedView();
































 886      }
 887  
 888      private void completeTwoStageWidgetDrop(final int resultCode, final int appWidgetId) {
 889          CellLayout cellLayout =
 890                  (CellLayout) mWorkspace.getScreenWithId(mPendingAddInfo.screenId);
 891          Runnable onCompleteRunnable = null;
 892          int animationType = 0;
 893  
 894          AppWidgetHostView boundWidget = null;
 895          if (resultCode == RESULT_OK) {
 896              animationType = Workspace.COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION;
 897              final AppWidgetHostView layout = mAppWidgetHost.createView(this, appWidgetId,
 898                      mPendingAddWidgetInfo);
 899              boundWidget = layout;
 900              onCompleteRunnable = new Runnable() {
 901                  @Override
 902                  public void run() {
 903                      completeAddAppWidget(appWidgetId, mPendingAddInfo.container,
 904                              mPendingAddInfo.screenId, layout, null);
 905                      exitSpringLoadedDragModeDelayed((resultCode != RESULT_CANCELED),
 906                              EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
 907                  }
 908              };
 909          } else if (resultCode == RESULT_CANCELED) {
 910              mAppWidgetHost.deleteAppWidgetId(appWidgetId);
 911              animationType = Workspace.CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION;
 912          }
 913          if (mDragLayer.getAnimatedView() != null) {
 914              mWorkspace.animateWidgetDrop(mPendingAddInfo, cellLayout,
 915                      (DragView) mDragLayer.getAnimatedView(), onCompleteRunnable,
 916                      animationType, boundWidget, true);
 917          } else if (onCompleteRunnable != null) {
 918              // The animated view may be null in the case of a rotation during widget configuration
 919              onCompleteRunnable.run();
 920          }
 921      }
 922  
 923      @Override
 924      protected void onStop() {
 925          super.onStop();
 926          FirstFrameAnimatorHelper.setIsVisible(false);
 927      }
 928  
 929      @Override
 930      protected void onStart() {
 931          super.onStart();
 932          FirstFrameAnimatorHelper.setIsVisible(true);
 933      }
 934  
 935      @Override
 936      protected void onResume() {
 937          long startTime = 0;
 938          if (DEBUG_RESUME_TIME) {
 939              startTime = System.currentTimeMillis();
 940              Log.v(TAG, &quot;Launcher.onResume()&quot;);
 941          }
 942          super.onResume();
 943  
 944          // Restore the previous launcher state
 945          if (mOnResumeState == State.WORKSPACE) {
 946              showWorkspace(false);
 947          } else if (mOnResumeState == State.APPS_CUSTOMIZE) {
 948              showAllApps(false, mAppsCustomizeContent.getContentType(), false);
 949          }
 950          mOnResumeState = State.NONE;
 951  
 952          // Background was set to gradient in onPause(), restore to black if in all apps.
 953          setWorkspaceBackground(mState == State.WORKSPACE);
 954  
 955          mPaused = false;
 956          sPausedFromUserAction = false;
 957          if (mRestoring || mOnResumeNeedsLoad) {
 958              mWorkspaceLoading = true;

 959              mModel.startLoader(true, PagedView.INVALID_RESTORE_PAGE);
 960              mRestoring = false;
 961              mOnResumeNeedsLoad = false;
 962          }
 963          if (mBindOnResumeCallbacks.size() &gt; 0) {
 964              // We might have postponed some bind calls until onResume (see waitUntilResume) --
 965              // execute them here
 966              long startTimeCallbacks = 0;
 967              if (DEBUG_RESUME_TIME) {
 968                  startTimeCallbacks = System.currentTimeMillis();
 969              }
 970  
 971              if (mAppsCustomizeContent != null) {
 972                  mAppsCustomizeContent.setBulkBind(true);
 973              }
 974              for (int i = 0; i &lt; mBindOnResumeCallbacks.size(); i++) {
 975                  mBindOnResumeCallbacks.get(i).run();
 976              }
 977              if (mAppsCustomizeContent != null) {
 978                  mAppsCustomizeContent.setBulkBind(false);
 979              }
 980              mBindOnResumeCallbacks.clear();
 981              if (DEBUG_RESUME_TIME) {
 982                  Log.d(TAG, &quot;Time spent processing callbacks in onResume: &quot; +
 983                      (System.currentTimeMillis() - startTimeCallbacks));
 984              }
 985          }
 986          if (mOnResumeCallbacks.size() &gt; 0) {
 987              for (int i = 0; i &lt; mOnResumeCallbacks.size(); i++) {
 988                  mOnResumeCallbacks.get(i).run();
 989              }
 990              mOnResumeCallbacks.clear();
 991          }
 992  
 993          // Reset the pressed state of icons that were locked in the press state while activities
 994          // were launching
 995          if (mWaitingForResume != null) {
 996              // Resets the previous workspace icon press state
 997              mWaitingForResume.setStayPressed(false);
 998          }
 999          if (mAppsCustomizeContent != null) {
1000              // Resets the previous all apps icon press state
1001              mAppsCustomizeContent.resetDrawableState();
1002          }
1003  
1004          // It is possible that widgets can receive updates while launcher is not in the foreground.
1005          // Consequently, the widgets will be inflated in the orientation of the foreground activity
1006          // (framework issue). On resuming, we ensure that any widgets are inflated for the current
1007          // orientation.
1008          getWorkspace().reinflateWidgetsIfNecessary();
1009  
1010          // Process any items that were added while Launcher was away.
1011          InstallShortcutReceiver.disableAndFlushInstallQueue(this);
1012  
1013          // Update the voice search button proxy
1014          updateVoiceButtonProxyVisible(false);
1015  
1016          // Again, as with the above scenario, it&#x27;s possible that one or more of the global icons
1017          // were updated in the wrong orientation.
1018          updateGlobalIcons();
1019          if (DEBUG_RESUME_TIME) {
1020              Log.d(TAG, &quot;Time spent in onResume: &quot; + (System.currentTimeMillis() - startTime));
1021          }
1022  
1023          if (mWorkspace.getCustomContentCallbacks() != null) {
1024              // If we are resuming and the custom content is the current page, we call onShow().
1025              // It is also poassible that onShow will instead be called slightly after first layout
1026              // if PagedView#setRestorePage was set to the custom content page in onCreate().
1027              if (mWorkspace.isOnOrMovingToCustomContent()) {
1028                  mWorkspace.getCustomContentCallbacks().onShow();

1029              }
1030          }
1031          mWorkspace.updateInteractionForState();
1032          mWorkspace.onResume();


1033      }
1034  
1035      @Override
1036      protected void onPause() {
1037          // Ensure that items added to Launcher are queued until Launcher returns
1038          InstallShortcutReceiver.enableInstallQueue();

1039  
1040          super.onPause();
1041          mPaused = true;
1042          mDragController.cancelDrag();
1043          mDragController.resetLastGestureUpTime();
1044  
1045          // We call onHide() aggressively. The custom content callbacks should be able to
1046          // debounce excess onHide calls.
1047          if (mWorkspace.getCustomContentCallbacks() != null) {
1048              mWorkspace.getCustomContentCallbacks().onHide();
1049          }
1050      }
1051  
1052      protected void onFinishBindingItems() {
1053          if (mWorkspace != null &amp;&amp; hasCustomContentToLeft() &amp;&amp; mWorkspace.hasCustomContent()) {
1054              addCustomContentToLeft();
1055          }
1056      }
1057  
1058      QSBScroller mQsbScroller = new QSBScroller() {
1059          int scrollY = 0;
1060  
1061          @Override
1062          public void setScrollY(int scroll) {
1063              scrollY = scroll;
1064  
1065              if (mWorkspace.isOnOrMovingToCustomContent()) {
1066                  mSearchDropTargetBar.setTranslationY(- scrollY);
1067                  getQsbBar().setTranslationY(-scrollY);
1068              }
1069          }
1070      };
1071  
1072      public void resetQSBScroll() {
1073          mSearchDropTargetBar.animate().translationY(0).start();
1074          getQsbBar().animate().translationY(0).start();
1075      }
1076  
1077      public interface CustomContentCallbacks {
1078          // Custom content is completely shown
1079          public void onShow();



1080  
1081          // Custom content is completely hidden
1082          public void onHide();
1083  
1084          // Custom content scroll progress changed. From 0 (not showing) to 1 (fully showing).
1085          public void onScrollProgressChanged(float progress);
1086      }
1087  
1088      protected void startSettings() {







1089      }
1090  
1091      public interface QSBScroller {
1092          public void setScrollY(int scrollY);
1093      }
1094  
1095      public QSBScroller addToCustomContentPage(View customContent,
1096              CustomContentCallbacks callbacks, String description) {
1097          mWorkspace.addToCustomContentPage(customContent, callbacks, description);
1098          return mQsbScroller;
1099      }
1100  
1101      // The custom content needs to offset its content to account for the QSB
1102      public int getTopOffsetForCustomContent() {
1103          return mWorkspace.getPaddingTop();
1104      }
1105  
1106      @Override
1107      public Object onRetainNonConfigurationInstance() {
1108          // Flag the loader to stop early before switching
1109          mModel.stopLoader();



1110          if (mAppsCustomizeContent != null) {
1111              mAppsCustomizeContent.surrender();
1112          }
1113          return Boolean.TRUE;
1114      }
1115  
1116      // We can&#x27;t hide the IME if it was forced open.  So don&#x27;t bother
1117      @Override
1118      public void onWindowFocusChanged(boolean hasFocus) {
1119          super.onWindowFocusChanged(hasFocus);
1120          mHasFocus = hasFocus;
1121      }
1122  
1123      private boolean acceptFilter() {
1124          final InputMethodManager inputManager = (InputMethodManager)
1125                  getSystemService(Context.INPUT_METHOD_SERVICE);
1126          return !inputManager.isFullscreenMode();
1127      }
1128  
1129      @Override
1130      public boolean onKeyDown(int keyCode, KeyEvent event) {
1131          final int uniChar = event.getUnicodeChar();
1132          final boolean handled = super.onKeyDown(keyCode, event);
1133          final boolean isKeyNotWhitespace = uniChar &gt; 0 &amp;&amp; !Character.isWhitespace(uniChar);
1134          if (!handled &amp;&amp; acceptFilter() &amp;&amp; isKeyNotWhitespace) {
1135              boolean gotKey = TextKeyListener.getInstance().onKeyDown(mWorkspace, mDefaultKeySsb,
1136                      keyCode, event);
1137              if (gotKey &amp;&amp; mDefaultKeySsb != null &amp;&amp; mDefaultKeySsb.length() &gt; 0) {
1138                  // something usable has been typed - start a search
1139                  // the typed text will be retrieved and cleared by
1140                  // showSearchDialog()
1141                  // If there are multiple keystrokes before the search dialog takes focus,
1142                  // onSearchRequested() will be called for every keystroke,
1143                  // but it is idempotent, so it&#x27;s fine.
1144                  return onSearchRequested();
1145              }
1146          }
1147  
1148          // Eat the long press event so the keyboard doesn&#x27;t come up.
1149          if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.isLongPress()) {
1150              return true;
1151          }
1152  
1153          return handled;
1154      }
1155  
1156      private String getTypedText() {
1157          return mDefaultKeySsb.toString();
1158      }
1159  
1160      private void clearTypedText() {
1161          mDefaultKeySsb.clear();
1162          mDefaultKeySsb.clearSpans();
1163          Selection.setSelection(mDefaultKeySsb, 0);
1164      }
1165  
1166      /**
1167       * Given the integer (ordinal) value of a State enum instance, convert it to a variable of type
1168       * State
1169       */
1170      private static State intToState(int stateOrdinal) {
1171          State state = State.WORKSPACE;
1172          final State[] stateValues = State.values();
1173          for (int i = 0; i &lt; stateValues.length; i++) {
1174              if (stateValues[i].ordinal() == stateOrdinal) {
1175                  state = stateValues[i];
1176                  break;
1177              }
1178          }
1179          return state;
1180      }
1181  
1182      /**
1183       * Restores the previous state, if it exists.
1184       *
1185       * @param savedState The previous state.
1186       */
1187      @SuppressWarnings(&quot;unchecked&quot;)
1188      private void restoreState(Bundle savedState) {
1189          if (savedState == null) {
1190              return;
1191          }
1192  
1193          State state = intToState(savedState.getInt(RUNTIME_STATE, State.WORKSPACE.ordinal()));
1194          if (state == State.APPS_CUSTOMIZE) {
1195              mOnResumeState = State.APPS_CUSTOMIZE;
1196          }
1197  
1198          int currentScreen = savedState.getInt(RUNTIME_STATE_CURRENT_SCREEN,
1199                  PagedView.INVALID_RESTORE_PAGE);
1200          if (currentScreen != PagedView.INVALID_RESTORE_PAGE) {
1201              mWorkspace.setRestorePage(currentScreen);
1202          }
1203  
1204          final long pendingAddContainer = savedState.getLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, -1);
1205          final long pendingAddScreen = savedState.getLong(RUNTIME_STATE_PENDING_ADD_SCREEN, -1);
1206  
1207          if (pendingAddContainer != ItemInfo.NO_ID &amp;&amp; pendingAddScreen &gt; -1) {
1208              mPendingAddInfo.container = pendingAddContainer;
1209              mPendingAddInfo.screenId = pendingAddScreen;
1210              mPendingAddInfo.cellX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_X);
1211              mPendingAddInfo.cellY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_CELL_Y);
1212              mPendingAddInfo.spanX = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_X);
1213              mPendingAddInfo.spanY = savedState.getInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y);
1214              mPendingAddWidgetInfo = savedState.getParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO);
1215              mPendingAddWidgetId = savedState.getInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID);
1216              mWaitingForResult = true;

1217              mRestoring = true;
1218          }
1219  
1220          boolean renameFolder = savedState.getBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, false);
1221          if (renameFolder) {
1222              long id = savedState.getLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID);
1223              mFolderInfo = mModel.getFolderById(this, sFolders, id);
1224              mRestoring = true;
1225          }
1226  
1227          // Restore the AppsCustomize tab
1228          if (mAppsCustomizeTabHost != null) {
1229              String curTab = savedState.getString(&quot;apps_customize_currentTab&quot;);
1230              if (curTab != null) {
1231                  mAppsCustomizeTabHost.setContentTypeImmediate(
1232                          mAppsCustomizeTabHost.getContentTypeForTabTag(curTab));
1233                  mAppsCustomizeContent.loadAssociatedPages(
1234                          mAppsCustomizeContent.getCurrentPage());
1235              }
1236  
1237              int currentIndex = savedState.getInt(&quot;apps_customize_currentIndex&quot;);
1238              mAppsCustomizeContent.restorePageForIndex(currentIndex);
1239          }
1240          mItemIdToViewId = (HashMap&lt;Integer, Integer&gt;)
1241                  savedState.getSerializable(RUNTIME_STATE_VIEW_IDS);
1242      }
1243  
1244      /**
1245       * Finds all the views we need and configure them properly.
1246       */
1247      private void setupViews() {
1248          final DragController dragController = mDragController;
1249  
1250          mLauncherView = findViewById(R.id.launcher);

1251          mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
1252          mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1253 +        mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);</span>

1254  
1255          mLauncherView.setSystemUiVisibility(
1256                  View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
1257          mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
1258  
1259          // Setup the drag layer
1260          mDragLayer.setup(this, dragController);
1261  
1262          // Setup the hotseat
1263          mHotseat = (Hotseat) findViewById(R.id.hotseat);
1264          if (mHotseat != null) {
1265              mHotseat.setup(this);
1266              mHotseat.setOnLongClickListener(this);
1267          }
1268  
1269          mOverviewPanel = findViewById(R.id.overview_panel);

1270          View widgetButton = findViewById(R.id.widget_button);
1271          widgetButton.setOnClickListener(new OnClickListener() {
1272              @Override
1273              public void onClick(View arg0) {
1274                  if (!mWorkspace.isSwitchingState()) {
1275                      showAllApps(true, AppsCustomizePagedView.ContentType.Widgets, true);

1276                  }
1277              }
1278          });
1279          widgetButton.setOnTouchListener(getHapticFeedbackTouchListener());
1280  
1281          View wallpaperButton = findViewById(R.id.wallpaper_button);
1282          wallpaperButton.setOnClickListener(new OnClickListener() {
1283              @Override
1284              public void onClick(View arg0) {
1285                  if (!mWorkspace.isSwitchingState()) {
1286                      startWallpaper();

1287                  }
1288              }
1289          });
1290          wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
1291  
1292          View settingsButton = findViewById(R.id.settings_button);
1293          settingsButton.setOnClickListener(new OnClickListener() {
1294              @Override
1295              public void onClick(View arg0) {
1296                  if (!mWorkspace.isSwitchingState()) {
1297                      startSettings();







1298                  }
1299              }
1300          });
1301          settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());









1302          mOverviewPanel.setAlpha(0f);
1303  
1304          // Setup the workspace
1305          mWorkspace.setHapticFeedbackEnabled(false);
1306          mWorkspace.setOnLongClickListener(this);
1307          mWorkspace.setup(dragController);
1308          dragController.addDragListener(mWorkspace);
1309  
1310          // Get the search/delete bar
1311          mSearchDropTargetBar = (SearchDropTargetBar) mDragLayer.findViewById(R.id.qsb_bar);


1312  
1313          // Setup AppsCustomize
1314          mAppsCustomizeTabHost = (AppsCustomizeTabHost) findViewById(R.id.apps_customize_pane);
1315          mAppsCustomizeContent = (AppsCustomizePagedView)
1316                  mAppsCustomizeTabHost.findViewById(R.id.apps_customize_pane_content);
1317          mAppsCustomizeContent.setup(this, dragController);
1318  
1319          // Setup the drag controller (drop targets have to be added in reverse order in priority)
1320          dragController.setDragScoller(mWorkspace);
1321          dragController.setScrollView(mDragLayer);
1322          dragController.setMoveTarget(mWorkspace);
1323          dragController.addDropTarget(mWorkspace);
1324          if (mSearchDropTargetBar != null) {
1325              mSearchDropTargetBar.setup(this, dragController);
1326          }
1327  
1328          if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
1329              Log.v(TAG, &quot;adding WeightWatcher&quot;);
1330              mWeightWatcher = new WeightWatcher(this);
1331              mWeightWatcher.setAlpha(0.5f);
1332              ((FrameLayout) mLauncherView).addView(mWeightWatcher,
1333                      new FrameLayout.LayoutParams(
1334                              FrameLayout.LayoutParams.MATCH_PARENT,
1335                              FrameLayout.LayoutParams.WRAP_CONTENT,
1336                              Gravity.BOTTOM)
1337              );
1338  
1339              boolean show = shouldShowWeightWatcher();
1340              mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
1341          }
1342      }
1343  
1344      /**











1345       * Creates a view representing a shortcut.
1346       *
1347       * @param info The data structure describing the shortcut.
1348       *
1349       * @return A View inflated from R.layout.application.
1350       */
1351      View createShortcut(ShortcutInfo info) {
1352          return createShortcut(R.layout.application,
1353                  (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
1354      }
1355  
1356      /**
1357       * Creates a view representing a shortcut inflated from the specified resource.
1358       *
1359       * @param layoutResId The id of the XML layout used to create the shortcut.
1360       * @param parent The group the shortcut belongs to.
1361       * @param info The data structure describing the shortcut.
1362       *
1363       * @return A View inflated from layoutResId.
1364       */
1365      View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) {
1366          BubbleTextView favorite = (BubbleTextView) mInflater.inflate(layoutResId, parent, false);
1367          favorite.applyFromShortcutInfo(info, mIconCache);

1368          favorite.setOnClickListener(this);

1369          return favorite;
1370      }
1371  
1372      /**
1373       * Add an application shortcut to the workspace.
1374       *
1375       * @param data The intent describing the application.
1376       * @param cellInfo The position on screen where to create the shortcut.
1377       */
1378      void completeAddApplication(Intent data, long container, long screenId, int cellX, int cellY) {
1379          final int[] cellXY = mTmpAddItemCellCoordinates;
1380          final CellLayout layout = getCellLayout(container, screenId);
1381  
1382          // First we check if we already know the exact location where we want to add this item.
1383          if (cellX &gt;= 0 &amp;&amp; cellY &gt;= 0) {
1384              cellXY[0] = cellX;
1385              cellXY[1] = cellY;
1386          } else if (!layout.findCellForSpan(cellXY, 1, 1)) {
1387              showOutOfSpaceMessage(isHotseatLayout(layout));
1388              return;
1389          }
1390  
1391          final ShortcutInfo info = mModel.getShortcutInfo(getPackageManager(), data, this);
1392  
1393          if (info != null) {
1394              info.setActivity(this, data.getComponent(), Intent.FLAG_ACTIVITY_NEW_TASK |
1395                      Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1396              info.container = ItemInfo.NO_ID;
1397              mWorkspace.addApplicationShortcut(info, layout, container, screenId, cellXY[0], cellXY[1],
1398                      isWorkspaceLocked(), cellX, cellY);
1399          } else {
1400              Log.e(TAG, &quot;Couldn&#x27;t find ActivityInfo for selected application: &quot; + data);
1401          }
1402      }
1403  
1404      /**
1405       * Add a shortcut to the workspace.
1406       *
1407       * @param data The intent describing the shortcut.
1408       * @param cellInfo The position on screen where to create the shortcut.
1409       */
1410      private void completeAddShortcut(Intent data, long container, long screenId, int cellX,
1411              int cellY) {
1412          int[] cellXY = mTmpAddItemCellCoordinates;
1413          int[] touchXY = mPendingAddInfo.dropPos;
1414          CellLayout layout = getCellLayout(container, screenId);
1415  
1416          boolean foundCellSpan = false;
1417  
1418          ShortcutInfo info = mModel.infoFromShortcutIntent(this, data, null);
1419          if (info == null) {
1420              return;
1421          }
1422          final View view = createShortcut(info);
1423  
1424          // First we check if we already know the exact location where we want to add this item.
1425          if (cellX &gt;= 0 &amp;&amp; cellY &gt;= 0) {
1426              cellXY[0] = cellX;
1427              cellXY[1] = cellY;
1428              foundCellSpan = true;
1429  
1430              // If appropriate, either create a folder or add to an existing folder
1431              if (mWorkspace.createUserFolderIfNecessary(view, container, layout, cellXY, 0,
1432                      true, null,null)) {
1433                  return;
1434              }
1435              DragObject dragObject = new DragObject();
1436              dragObject.dragInfo = info;
1437              if (mWorkspace.addToExistingFolderIfNecessary(view, layout, cellXY, 0, dragObject,
1438                      true)) {
1439                  return;
1440              }
1441          } else if (touchXY != null) {
1442              // when dragging and dropping, just find the closest free spot
1443              int[] result = layout.findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, cellXY);
1444              foundCellSpan = (result != null);
1445          } else {
1446              foundCellSpan = layout.findCellForSpan(cellXY, 1, 1);
1447          }
1448  
1449          if (!foundCellSpan) {
1450              showOutOfSpaceMessage(isHotseatLayout(layout));
1451              return;
1452          }
1453  
1454          LauncherModel.addItemToDatabase(this, info, container, screenId, cellXY[0], cellXY[1], false);
1455  
1456          if (!mRestoring) {
1457              mWorkspace.addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1,
1458                      isWorkspaceLocked());
1459          }
1460      }
1461  
1462      static int[] getSpanForWidget(Context context, ComponentName component, int minWidth,
1463              int minHeight) {
1464          Rect padding = AppWidgetHostView.getDefaultPaddingForWidget(context, component, null);
1465          // We want to account for the extra amount of padding that we are adding to the widget
1466          // to ensure that it gets the full amount of space that it has requested
1467          int requiredWidth = minWidth + padding.left + padding.right;
1468          int requiredHeight = minHeight + padding.top + padding.bottom;
1469          return CellLayout.rectToCell(requiredWidth, requiredHeight, null);
1470      }
1471  
1472      static int[] getSpanForWidget(Context context, AppWidgetProviderInfo info) {
1473          return getSpanForWidget(context, info.provider, info.minWidth, info.minHeight);
1474      }
1475  
1476      static int[] getMinSpanForWidget(Context context, AppWidgetProviderInfo info) {
1477          return getSpanForWidget(context, info.provider, info.minResizeWidth, info.minResizeHeight);
1478      }
1479  
1480      static int[] getSpanForWidget(Context context, PendingAddWidgetInfo info) {
1481          return getSpanForWidget(context, info.componentName, info.minWidth, info.minHeight);
1482      }
1483  
1484      static int[] getMinSpanForWidget(Context context, PendingAddWidgetInfo info) {
1485          return getSpanForWidget(context, info.componentName, info.minResizeWidth,
1486                  info.minResizeHeight);
1487      }
1488  
1489      /**
1490       * Add a widget to the workspace.
1491       *
1492       * @param appWidgetId The app widget id
1493       * @param cellInfo The position on screen where to create the widget.
1494       */
1495      private void completeAddAppWidget(final int appWidgetId, long container, long screenId,
1496              AppWidgetHostView hostView, AppWidgetProviderInfo appWidgetInfo) {
1497          if (appWidgetInfo == null) {
1498              appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
1499          }
1500  
1501          // Calculate the grid spans needed to fit this widget
1502          CellLayout layout = getCellLayout(container, screenId);
1503  
1504          int[] minSpanXY = getMinSpanForWidget(this, appWidgetInfo);
1505          int[] spanXY = getSpanForWidget(this, appWidgetInfo);
1506  
1507          // Try finding open space on Launcher screen
1508          // We have saved the position to which the widget was dragged-- this really only matters
1509          // if we are placing widgets on a &quot;spring-loaded&quot; screen
1510          int[] cellXY = mTmpAddItemCellCoordinates;
1511          int[] touchXY = mPendingAddInfo.dropPos;
1512          int[] finalSpan = new int[2];
1513          boolean foundCellSpan = false;
1514          if (mPendingAddInfo.cellX &gt;= 0 &amp;&amp; mPendingAddInfo.cellY &gt;= 0) {
1515              cellXY[0] = mPendingAddInfo.cellX;
1516              cellXY[1] = mPendingAddInfo.cellY;
1517              spanXY[0] = mPendingAddInfo.spanX;
1518              spanXY[1] = mPendingAddInfo.spanY;
1519              foundCellSpan = true;
1520          } else if (touchXY != null) {
1521              // when dragging and dropping, just find the closest free spot
1522              int[] result = layout.findNearestVacantArea(
1523                      touchXY[0], touchXY[1], minSpanXY[0], minSpanXY[1], spanXY[0],
1524                      spanXY[1], cellXY, finalSpan);
1525              spanXY[0] = finalSpan[0];
1526              spanXY[1] = finalSpan[1];
1527              foundCellSpan = (result != null);
1528          } else {
1529              foundCellSpan = layout.findCellForSpan(cellXY, minSpanXY[0], minSpanXY[1]);
1530          }
1531  
1532          if (!foundCellSpan) {
1533              if (appWidgetId != -1) {
1534                  // Deleting an app widget ID is a void call but writes to disk before returning
1535                  // to the caller...
1536                  new AsyncTask&lt;Void, Void, Void&gt;() {
1537                      public Void doInBackground(Void ... args) {
1538                          mAppWidgetHost.deleteAppWidgetId(appWidgetId);
1539                          return null;
1540                      }
1541                  }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
1542              }
1543              showOutOfSpaceMessage(isHotseatLayout(layout));
1544              return;
1545          }
1546  
1547          // Build Launcher-specific widget info and save to database
1548          LauncherAppWidgetInfo launcherInfo = new LauncherAppWidgetInfo(appWidgetId,
1549                  appWidgetInfo.provider);
1550          launcherInfo.spanX = spanXY[0];
1551          launcherInfo.spanY = spanXY[1];
1552          launcherInfo.minSpanX = mPendingAddInfo.minSpanX;
1553          launcherInfo.minSpanY = mPendingAddInfo.minSpanY;

1554  
1555          LauncherModel.addItemToDatabase(this, launcherInfo,
1556                  container, screenId, cellXY[0], cellXY[1], false);
1557  
1558          if (!mRestoring) {
1559              if (hostView == null) {
1560                  // Perform actual inflation because we&#x27;re live
1561                  launcherInfo.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);
1562                  launcherInfo.hostView.setAppWidget(appWidgetId, appWidgetInfo);
1563              } else {
1564                  // The AppWidgetHostView has already been inflated and instantiated
1565                  launcherInfo.hostView = hostView;
1566              }
1567  
1568              launcherInfo.hostView.setTag(launcherInfo);
1569              launcherInfo.hostView.setVisibility(View.VISIBLE);
1570              launcherInfo.notifyWidgetSizeChanged(this);
1571  
1572              mWorkspace.addInScreen(launcherInfo.hostView, container, screenId, cellXY[0], cellXY[1],
1573                      launcherInfo.spanX, launcherInfo.spanY, isWorkspaceLocked());
1574  
1575              addWidgetToAutoAdvanceIfNeeded(launcherInfo.hostView, appWidgetInfo);
1576          }
1577          resetAddInfo();
1578      }
1579  
1580      private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
1581          @Override
1582          public void onReceive(Context context, Intent intent) {
1583              final String action = intent.getAction();
1584              if (Intent.ACTION_SCREEN_OFF.equals(action)) {
1585                  mUserPresent = false;
1586                  mDragLayer.clearAllResizeFrames();
1587                  updateRunning();
1588  
1589                  // Reset AllApps to its initial state only if we are not in the middle of
1590                  // processing a multi-step drop
1591                  if (mAppsCustomizeTabHost != null &amp;&amp; mPendingAddInfo.container == ItemInfo.NO_ID) {
1592                      showWorkspace(false);
1593                  }
1594              } else if (Intent.ACTION_USER_PRESENT.equals(action)) {
1595                  mUserPresent = true;
1596                  updateRunning();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1597 +            } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.DELETE_DATABASE.equals(action)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1598 +                mModel.resetLoadedState(false, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1599 +                mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1600 +                        LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1601 +            } else if (ENABLE_DEBUG_INTENTS &amp;&amp; DebugIntents.MIGRATE_DATABASE.equals(action)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1602 +                mModel.resetLoadedState(false, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1603 +                mModel.startLoader(false, PagedView.INVALID_RESTORE_PAGE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1604 +                        LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1605 +                                | LauncherModel.LOADER_FLAG_MIGRATE_SHORTCUTS);</span>



1606              }
1607          }
1608      };
1609  
1610      @Override
1611      public void onAttachedToWindow() {
1612          super.onAttachedToWindow();
1613  
1614          // Listen for broadcasts related to user-presence
1615          final IntentFilter filter = new IntentFilter();
1616          filter.addAction(Intent.ACTION_SCREEN_OFF);
1617          filter.addAction(Intent.ACTION_USER_PRESENT);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1618 +        if (ENABLE_DEBUG_INTENTS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1619 +            filter.addAction(DebugIntents.DELETE_DATABASE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1620 +            filter.addAction(DebugIntents.MIGRATE_DATABASE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1621 +        }</span>



1622          registerReceiver(mReceiver, filter);
1623          FirstFrameAnimatorHelper.initializeDrawListener(getWindow().getDecorView());

1624          mAttached = true;
1625          mVisible = true;









































1626      }
1627  
1628      @Override
1629      public void onDetachedFromWindow() {
1630          super.onDetachedFromWindow();
1631          mVisible = false;
1632  
1633          if (mAttached) {
1634              unregisterReceiver(mReceiver);
1635              mAttached = false;
1636          }
1637          updateRunning();
1638      }
1639  
1640      public void onWindowVisibilityChanged(int visibility) {
1641          mVisible = visibility == View.VISIBLE;
1642          updateRunning();
1643          // The following code used to be in onResume, but it turns out onResume is called when
1644          // you&#x27;re in All Apps and click home to go to the workspace. onWindowVisibilityChanged
1645          // is a more appropriate event to handle
1646          if (mVisible) {
1647              mAppsCustomizeTabHost.onWindowVisible();
1648              if (!mWorkspaceLoading) {
1649                  final ViewTreeObserver observer = mWorkspace.getViewTreeObserver();
1650                  // We want to let Launcher draw itself at least once before we force it to build
1651                  // layers on all the workspace pages, so that transitioning to Launcher from other
1652                  // apps is nice and speedy.
1653                  observer.addOnDrawListener(new ViewTreeObserver.OnDrawListener() {
1654                      private boolean mStarted = false;
1655                      public void onDraw() {
1656                          if (mStarted) return;
1657                          mStarted = true;
1658                          // We delay the layer building a bit in order to give
1659                          // other message processing a time to run.  In particular
1660                          // this avoids a delay in hiding the IME if it was
1661                          // currently shown, because doing that may involve
1662                          // some communication back with the app.
1663                          mWorkspace.postDelayed(mBuildLayersRunnable, 500);
1664                          final ViewTreeObserver.OnDrawListener listener = this;
1665                          mWorkspace.post(new Runnable() {
1666                                  public void run() {
1667                                      if (mWorkspace != null &amp;&amp;
1668                                              mWorkspace.getViewTreeObserver() != null) {
1669                                          mWorkspace.getViewTreeObserver().
1670                                                  removeOnDrawListener(listener);
1671                                      }
1672                                  }
1673                              });
1674                          return;
1675                      }
1676                  });
1677              }
1678              // When Launcher comes back to foreground, a different Activity might be responsible for
1679              // the app market intent, so refresh the icon
1680              if (!DISABLE_MARKET_BUTTON) {
1681                  updateAppMarketIcon();
1682              }
1683              clearTypedText();
1684          }
1685      }
1686  
1687      private void sendAdvanceMessage(long delay) {
1688          mHandler.removeMessages(ADVANCE_MSG);
1689          Message msg = mHandler.obtainMessage(ADVANCE_MSG);
1690          mHandler.sendMessageDelayed(msg, delay);
1691          mAutoAdvanceSentTime = System.currentTimeMillis();
1692      }
1693  
1694      private void updateRunning() {
1695          boolean autoAdvanceRunning = mVisible &amp;&amp; mUserPresent &amp;&amp; !mWidgetsToAdvance.isEmpty();
1696          if (autoAdvanceRunning != mAutoAdvanceRunning) {
1697              mAutoAdvanceRunning = autoAdvanceRunning;
1698              if (autoAdvanceRunning) {
1699                  long delay = mAutoAdvanceTimeLeft == -1 ? mAdvanceInterval : mAutoAdvanceTimeLeft;
1700                  sendAdvanceMessage(delay);
1701              } else {
1702                  if (!mWidgetsToAdvance.isEmpty()) {
1703                      mAutoAdvanceTimeLeft = Math.max(0, mAdvanceInterval -
1704                              (System.currentTimeMillis() - mAutoAdvanceSentTime));
1705                  }
1706                  mHandler.removeMessages(ADVANCE_MSG);
1707                  mHandler.removeMessages(0); // Remove messages sent using postDelayed()
1708              }
1709          }
1710      }
1711  
1712      private final Handler mHandler = new Handler() {
1713          @Override
1714          public void handleMessage(Message msg) {
1715              if (msg.what == ADVANCE_MSG) {
1716                  int i = 0;
1717                  for (View key: mWidgetsToAdvance.keySet()) {
1718                      final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);
1719                      final int delay = mAdvanceStagger * i;
1720                      if (v instanceof Advanceable) {
1721                         postDelayed(new Runnable() {
1722                             public void run() {
1723                                 ((Advanceable) v).advance();
1724                             }
1725                         }, delay);
1726                      }
1727                      i++;
1728                  }
1729                  sendAdvanceMessage(mAdvanceInterval);
1730              }
1731          }
1732      };
1733  
1734      void addWidgetToAutoAdvanceIfNeeded(View hostView, AppWidgetProviderInfo appWidgetInfo) {
1735          if (appWidgetInfo == null || appWidgetInfo.autoAdvanceViewId == -1) return;
1736          View v = hostView.findViewById(appWidgetInfo.autoAdvanceViewId);
1737          if (v instanceof Advanceable) {
1738              mWidgetsToAdvance.put(hostView, appWidgetInfo);
1739              ((Advanceable) v).fyiWillBeAdvancedByHostKThx();
1740              updateRunning();
1741          }
1742      }
1743  
1744      void removeWidgetToAutoAdvance(View hostView) {
1745          if (mWidgetsToAdvance.containsKey(hostView)) {
1746              mWidgetsToAdvance.remove(hostView);
1747              updateRunning();
1748          }
1749      }
1750  
1751      public void removeAppWidget(LauncherAppWidgetInfo launcherInfo) {
1752          removeWidgetToAutoAdvance(launcherInfo.hostView);
1753          launcherInfo.hostView = null;
1754      }
1755  
1756      void showOutOfSpaceMessage(boolean isHotseatLayout) {
1757          int strId = (isHotseatLayout ? R.string.hotseat_out_of_space : R.string.out_of_space);
1758          Toast.makeText(this, getString(strId), Toast.LENGTH_SHORT).show();
1759      }
1760  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1761 +    public DragLayer getDragLayer() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1762 +        return mDragLayer;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1763 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1764 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1765 +    public Workspace getWorkspace() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1766 +        return mWorkspace;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1767 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1768 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1769 +    public Hotseat getHotseat() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1770 +        return mHotseat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1771 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1772 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1773 +    public View getOverviewPanel() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1774 +        return mOverviewPanel;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1775 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1776 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1777 +    public SearchDropTargetBar getSearchBar() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1778 +        return mSearchDropTargetBar;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1779 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1780 +</span>
1781      public LauncherAppWidgetHost getAppWidgetHost() {
1782          return mAppWidgetHost;
1783      }
1784  
1785      public LauncherModel getModel() {
1786          return mModel;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1787 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1788 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1789 +    public LauncherClings getLauncherClings() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1790 +        return mLauncherClings;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1791 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1792 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1793 +    protected SharedPreferences getSharedPrefs() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1794 +        return mSharedPrefs;</span>
1795      }
1796  




1797      public void closeSystemDialogs() {
1798          getWindow().closeAllPanels();
1799  
1800          // Whatever we were doing is hereby canceled.
1801          mWaitingForResult = false;

1802      }
1803  
1804      @Override
1805      protected void onNewIntent(Intent intent) {
1806          long startTime = 0;
1807          if (DEBUG_RESUME_TIME) {
1808              startTime = System.currentTimeMillis();
1809          }
1810          super.onNewIntent(intent);
1811  
1812          // Close the menu
1813          if (Intent.ACTION_MAIN.equals(intent.getAction())) {
1814              // also will cancel mWaitingForResult.
1815              closeSystemDialogs();
1816  
1817              final boolean alreadyOnHome = mHasFocus &amp;&amp; ((intent.getFlags() &amp;
1818                      Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT)
1819                      != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
1820  
1821              if (mWorkspace == null) {
1822                  // Can be cases where mWorkspace is null, this prevents a NPE
1823                  return;
1824              }
1825              Folder openFolder = mWorkspace.getOpenFolder();
1826              // In all these cases, only animate if we&#x27;re already on home
1827              mWorkspace.exitWidgetResizeMode();
1828              if (alreadyOnHome &amp;&amp; mState == State.WORKSPACE &amp;&amp; !mWorkspace.isTouchActive() &amp;&amp;
1829                      openFolder == null &amp;&amp; shouldMoveToDefaultScreenOnHomeIntent()) {
1830                  mWorkspace.moveToDefaultScreen(true);
1831              }
1832  
1833              closeFolder();
1834              exitSpringLoadedDragMode();
1835  
1836              // If we are already on home, then just animate back to the workspace,
1837              // otherwise, just wait until onResume to set the state back to Workspace
1838              if (alreadyOnHome) {
1839                  showWorkspace(true);
1840              } else {
1841                  mOnResumeState = State.WORKSPACE;
1842              }
1843  
1844              final View v = getWindow().peekDecorView();
1845              if (v != null &amp;&amp; v.getWindowToken() != null) {
1846                  InputMethodManager imm = (InputMethodManager)getSystemService(
1847                          INPUT_METHOD_SERVICE);
1848                  imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
1849              }
1850  
1851              // Reset the apps customize page
1852              if (!alreadyOnHome &amp;&amp; mAppsCustomizeTabHost != null) {
1853                  mAppsCustomizeTabHost.reset();
1854              }
1855  
1856              onHomeIntent();
1857          }
1858  
1859          if (DEBUG_RESUME_TIME) {
1860              Log.d(TAG, &quot;Time spent in onNewIntent: &quot; + (System.currentTimeMillis() - startTime));
1861          }
1862      }
1863  
1864      /**
1865       * Override point for subclasses to prevent movement to the default screen when the home
1866       * button is pressed. Used (for example) in GEL, to prevent movement during a search.
1867       */
1868      protected boolean shouldMoveToDefaultScreenOnHomeIntent() {
1869          return true;
1870      }
1871  
1872      /**
1873       * Override point for subclasses to provide custom behaviour for when a home intent is fired.
1874       */
1875      protected void onHomeIntent() {
1876          // Do nothing
1877      }
1878  
1879      @Override
1880      public void onRestoreInstanceState(Bundle state) {
1881          super.onRestoreInstanceState(state);
1882          for (int page: mSynchronouslyBoundPages) {
1883              mWorkspace.restoreInstanceStateForChild(page);
1884          }
1885      }
1886  
1887      @Override
1888      protected void onSaveInstanceState(Bundle outState) {
1889          if (mWorkspace.getChildCount() &gt; 0) {
1890              outState.putInt(RUNTIME_STATE_CURRENT_SCREEN,
1891                      mWorkspace.getCurrentPageOffsetFromCustomContent());
1892          }
1893          super.onSaveInstanceState(outState);
1894  
1895          outState.putInt(RUNTIME_STATE, mState.ordinal());
1896          // We close any open folder since it will not be re-opened, and we need to make sure
1897          // this state is reflected.
1898          closeFolder();
1899  
1900          if (mPendingAddInfo.container != ItemInfo.NO_ID &amp;&amp; mPendingAddInfo.screenId &gt; -1 &amp;&amp;
1901                  mWaitingForResult) {
1902              outState.putLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, mPendingAddInfo.container);
1903              outState.putLong(RUNTIME_STATE_PENDING_ADD_SCREEN, mPendingAddInfo.screenId);
1904              outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_X, mPendingAddInfo.cellX);
1905              outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_Y, mPendingAddInfo.cellY);
1906              outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_X, mPendingAddInfo.spanX);
1907              outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y, mPendingAddInfo.spanY);
1908              outState.putParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO, mPendingAddWidgetInfo);
1909              outState.putInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID, mPendingAddWidgetId);
1910          }
1911  
1912          if (mFolderInfo != null &amp;&amp; mWaitingForResult) {
1913              outState.putBoolean(RUNTIME_STATE_PENDING_FOLDER_RENAME, true);
1914              outState.putLong(RUNTIME_STATE_PENDING_FOLDER_RENAME_ID, mFolderInfo.id);
1915          }
1916  
1917          // Save the current AppsCustomize tab
1918          if (mAppsCustomizeTabHost != null) {
1919              AppsCustomizePagedView.ContentType type = mAppsCustomizeContent.getContentType();
1920              String currentTabTag = mAppsCustomizeTabHost.getTabTagForContentType(type);
1921              if (currentTabTag != null) {
1922                  outState.putString(&quot;apps_customize_currentTab&quot;, currentTabTag);
1923              }
1924              int currentIndex = mAppsCustomizeContent.getSaveInstanceStateIndex();
1925              outState.putInt(&quot;apps_customize_currentIndex&quot;, currentIndex);
1926          }
1927          outState.putSerializable(RUNTIME_STATE_VIEW_IDS, mItemIdToViewId);
1928      }
1929  
1930      @Override
1931      public void onDestroy() {
1932          super.onDestroy();
1933  
1934          // Remove all pending runnables
1935          mHandler.removeMessages(ADVANCE_MSG);
1936          mHandler.removeMessages(0);
1937          mWorkspace.removeCallbacks(mBuildLayersRunnable);
1938  
1939          // Stop callbacks from LauncherModel
1940          LauncherAppState app = (LauncherAppState.getInstance());
1941          mModel.stopLoader();
1942          app.setLauncher(null);







1943  
1944          try {
1945              mAppWidgetHost.stopListening();
1946          } catch (NullPointerException ex) {
1947              Log.w(TAG, &quot;problem while stopping AppWidgetHost during Launcher destruction&quot;, ex);
1948          }
1949          mAppWidgetHost = null;
1950  
1951          mWidgetsToAdvance.clear();
1952  
1953          TextKeyListener.getInstance().release();
1954  
1955          // Disconnect any of the callbacks and drawables associated with ItemInfos on the workspace
1956          // to prevent leaking Launcher activities on orientation change.
1957          if (mModel != null) {
1958              mModel.unbindItemInfosAndClearQueuedBindRunnables();
1959          }
1960  
1961          getContentResolver().unregisterContentObserver(mWidgetObserver);
1962          unregisterReceiver(mCloseSystemDialogsReceiver);
1963  
1964          mDragLayer.clearAllResizeFrames();
1965          ((ViewGroup) mWorkspace.getParent()).removeAllViews();
1966          mWorkspace.removeAllWorkspaceScreens();
1967          mWorkspace = null;
1968          mDragController = null;
1969  

1970          LauncherAnimUtils.onDestroyActivity();
1971      }
1972  
1973      public DragController getDragController() {
1974          return mDragController;
1975      }
1976  
1977      @Override
1978      public void startActivityForResult(Intent intent, int requestCode) {
1979          if (requestCode &gt;= 0) mWaitingForResult = true;



1980          super.startActivityForResult(intent, requestCode);
1981      }
1982  
1983      /**
1984       * Indicates that we want global search for this activity by setting the globalSearch
1985       * argument for {@link #startSearch} to true.
1986       */
1987      @Override
1988      public void startSearch(String initialQuery, boolean selectInitialQuery,
1989              Bundle appSearchData, boolean globalSearch) {
1990  
1991          showWorkspace(true);
1992  
1993          if (initialQuery == null) {
1994              // Use any text typed in the launcher as the initial query
1995              initialQuery = getTypedText();
1996          }
1997          if (appSearchData == null) {
1998              appSearchData = new Bundle();
1999              appSearchData.putString(&quot;source&quot;, &quot;launcher-search&quot;);
2000          }
2001          Rect sourceBounds = new Rect();
2002          if (mSearchDropTargetBar != null) {
2003              sourceBounds = mSearchDropTargetBar.getSearchBarBounds();
2004          }
2005  
2006          startSearch(initialQuery, selectInitialQuery,

2007                  appSearchData, sourceBounds);
2008      }
2009  
2010      public void startSearch(String initialQuery,













2011              boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2012          startGlobalSearch(initialQuery, selectInitialQuery,
2013                  appSearchData, sourceBounds);

2014      }
2015  
2016      /**
2017       * Starts the global search activity. This code is a copied from SearchManager
2018       */
2019      private void startGlobalSearch(String initialQuery,
2020              boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
2021          final SearchManager searchManager =
2022              (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2023          ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
2024          if (globalSearchActivity == null) {
2025              Log.w(TAG, &quot;No global search activity found.&quot;);
2026              return;
2027          }
2028          Intent intent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
2029          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2030          intent.setComponent(globalSearchActivity);
2031          // Make sure that we have a Bundle to put source in
2032          if (appSearchData == null) {
2033              appSearchData = new Bundle();
2034          } else {
2035              appSearchData = new Bundle(appSearchData);
2036          }
2037          // Set source to package name of app that starts global search, if not set already.
2038          if (!appSearchData.containsKey(&quot;source&quot;)) {
2039              appSearchData.putString(&quot;source&quot;, getPackageName());
2040          }
2041          intent.putExtra(SearchManager.APP_DATA, appSearchData);
2042          if (!TextUtils.isEmpty(initialQuery)) {
2043              intent.putExtra(SearchManager.QUERY, initialQuery);
2044          }
2045          if (selectInitialQuery) {
2046              intent.putExtra(SearchManager.EXTRA_SELECT_QUERY, selectInitialQuery);
2047          }
2048          intent.setSourceBounds(sourceBounds);
2049          try {
2050              startActivity(intent);
2051          } catch (ActivityNotFoundException ex) {
2052              Log.e(TAG, &quot;Global search activity not found: &quot; + globalSearchActivity);
2053          }
2054      }
2055  




2056      @Override
2057      public boolean onPrepareOptionsMenu(Menu menu) {
2058          super.onPrepareOptionsMenu(menu);
2059          showOverviewMode(true);












2060          return false;
2061      }
2062  
2063      @Override
2064      public boolean onSearchRequested() {
2065          startSearch(null, false, null, true);
2066          // Use a custom animation for launching search
2067          return true;
2068      }
2069  
2070      public boolean isWorkspaceLocked() {
2071          return mWorkspaceLoading || mWaitingForResult;
2072      }






















2073  
2074      private void resetAddInfo() {
2075          mPendingAddInfo.container = ItemInfo.NO_ID;
2076          mPendingAddInfo.screenId = -1;
2077          mPendingAddInfo.cellX = mPendingAddInfo.cellY = -1;
2078          mPendingAddInfo.spanX = mPendingAddInfo.spanY = -1;
2079          mPendingAddInfo.minSpanX = mPendingAddInfo.minSpanY = -1;
2080          mPendingAddInfo.dropPos = null;
2081      }
2082  
2083      void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2084              final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo) {
2085          addAppWidgetImpl(appWidgetId, info, boundWidget, appWidgetInfo, 0);
2086      }
2087  
2088      void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
2089              final AppWidgetHostView boundWidget, final AppWidgetProviderInfo appWidgetInfo, int
2090              delay) {
2091          if (appWidgetInfo.configure != null) {
2092              mPendingAddWidgetInfo = appWidgetInfo;
2093              mPendingAddWidgetId = appWidgetId;
2094  
2095              // Launch over to configure widget, if needed
2096              Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);
2097              intent.setComponent(appWidgetInfo.configure);
2098              intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
2099              Utilities.startActivityForResultSafely(this, intent, REQUEST_CREATE_APPWIDGET);



2100          } else {
2101              // Otherwise just add it
2102              Runnable onComplete = new Runnable() {
2103                  @Override
2104                  public void run() {
2105                      // Exit spring loaded mode if necessary after adding the widget
2106                      exitSpringLoadedDragModeDelayed(true, EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
2107                              null);
2108                  }
2109              };
2110              completeAddAppWidget(appWidgetId, info.container, info.screenId, boundWidget,
2111                      appWidgetInfo);
2112              mWorkspace.removeExtraEmptyScreen(true, onComplete, delay, false);

2113          }
2114      }
2115  
2116      protected void moveToCustomContentScreen(boolean animate) {
2117          // Close any folders that may be open.
2118          closeFolder();
2119          mWorkspace.moveToCustomContentScreen(animate);
2120      }
2121      /**
2122       * Process a shortcut drop.
2123       *
2124       * @param componentName The name of the component
2125       * @param screenId The ID of the screen where it should be added
2126       * @param cell The cell it should be added to, optional
2127       * @param position The location on the screen where it was dropped, optional
2128       */
2129      void processShortcutFromDrop(ComponentName componentName, long container, long screenId,
2130              int[] cell, int[] loc) {
2131          resetAddInfo();
2132          mPendingAddInfo.container = container;
2133          mPendingAddInfo.screenId = screenId;
2134          mPendingAddInfo.dropPos = loc;
2135  
2136          if (cell != null) {
2137              mPendingAddInfo.cellX = cell[0];
2138              mPendingAddInfo.cellY = cell[1];
2139          }
2140  
2141          Intent createShortcutIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2142          createShortcutIntent.setComponent(componentName);
2143          processShortcut(createShortcutIntent);
2144      }
2145  
2146      /**
2147       * Process a widget drop.
2148       *
2149       * @param info The PendingAppWidgetInfo of the widget being added.
2150       * @param screenId The ID of the screen where it should be added
2151       * @param cell The cell it should be added to, optional
2152       * @param position The location on the screen where it was dropped, optional
2153       */
2154      void addAppWidgetFromDrop(PendingAddWidgetInfo info, long container, long screenId,
2155              int[] cell, int[] span, int[] loc) {
2156          resetAddInfo();
2157          mPendingAddInfo.container = info.container = container;
2158          mPendingAddInfo.screenId = info.screenId = screenId;
2159          mPendingAddInfo.dropPos = loc;
2160          mPendingAddInfo.minSpanX = info.minSpanX;
2161          mPendingAddInfo.minSpanY = info.minSpanY;
2162  
2163          if (cell != null) {
2164              mPendingAddInfo.cellX = cell[0];
2165              mPendingAddInfo.cellY = cell[1];
2166          }
2167          if (span != null) {
2168              mPendingAddInfo.spanX = span[0];
2169              mPendingAddInfo.spanY = span[1];
2170          }
2171  
2172          AppWidgetHostView hostView = info.boundWidget;
2173          int appWidgetId;
2174          if (hostView != null) {
2175              appWidgetId = hostView.getAppWidgetId();
2176              addAppWidgetImpl(appWidgetId, info, hostView, info.info);
2177          } else {
2178              // In this case, we either need to start an activity to get permission to bind
2179              // the widget, or we need to start an activity to configure the widget, or both.
2180              appWidgetId = getAppWidgetHost().allocateAppWidgetId();
2181              Bundle options = info.bindOptions;
2182  
2183              boolean success = false;
2184              if (options != null) {
2185                  success = mAppWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
2186                          info.componentName, options);
2187              } else {
2188                  success = mAppWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
2189                          info.componentName);
2190              }


2191              if (success) {
2192                  addAppWidgetImpl(appWidgetId, info, null, info.info);
2193              } else {
2194                  mPendingAddWidgetInfo = info.info;
2195                  Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);
2196                  intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
2197                  intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName);


2198                  // TODO: we need to make sure that this accounts for the options bundle.
2199                  // intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);
2200                  startActivityForResult(intent, REQUEST_BIND_APPWIDGET);
2201              }
2202          }
2203      }
2204  
2205      void processShortcut(Intent intent) {
2206          // Handle case where user selected &quot;Applications&quot;
2207          String applicationName = getResources().getString(R.string.group_applications);
2208          String shortcutName = intent.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2209  
2210          if (applicationName != null &amp;&amp; applicationName.equals(shortcutName)) {
2211              Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2212              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2213  
2214              Intent pickIntent = new Intent(Intent.ACTION_PICK_ACTIVITY);
2215              pickIntent.putExtra(Intent.EXTRA_INTENT, mainIntent);
2216              pickIntent.putExtra(Intent.EXTRA_TITLE, getText(R.string.title_select_application));
2217              Utilities.startActivityForResultSafely(this, pickIntent, REQUEST_PICK_APPLICATION);
2218          } else {
2219              Utilities.startActivityForResultSafely(this, intent, REQUEST_CREATE_SHORTCUT);
2220          }

2221      }
2222  
2223      void processWallpaper(Intent intent) {
2224          startActivityForResult(intent, REQUEST_PICK_WALLPAPER);
2225      }
2226  
2227      FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX,
2228              int cellY) {
2229          final FolderInfo folderInfo = new FolderInfo();
2230          folderInfo.title = getText(R.string.folder_name);
2231  
2232          // Update the model
2233          LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId, cellX, cellY,
2234                  false);
2235          sFolders.put(folderInfo.id, folderInfo);
2236  
2237          // Create the view
2238          FolderIcon newFolder =
2239              FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
2240          mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1,
2241                  isWorkspaceLocked());
2242          // Force measure the new folder icon
2243          CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
2244          parent.getShortcutsAndWidgets().measureChild(newFolder);
2245          return newFolder;
2246      }
2247  
2248      void removeFolder(FolderInfo folder) {
2249          sFolders.remove(folder.id);
2250      }
2251  
2252      protected void startWallpaper() {
2253          final Intent pickWallpaper = new Intent(Intent.ACTION_SET_WALLPAPER);
2254          pickWallpaper.setComponent(getWallpaperPickerComponent());
2255          startActivityForResult(pickWallpaper, REQUEST_PICK_WALLPAPER);
2256      }
2257  
2258      protected ComponentName getWallpaperPickerComponent() {
2259          return new ComponentName(getPackageName(), LauncherWallpaperPickerActivity.class.getName());
2260      }
2261  
2262      /**
2263       * Registers various content observers. The current implementation registers
2264       * only a favorites observer to keep track of the favorites applications.
2265       */
2266      private void registerContentObservers() {
2267          ContentResolver resolver = getContentResolver();
2268          resolver.registerContentObserver(LauncherProvider.CONTENT_APPWIDGET_RESET_URI,
2269                  true, mWidgetObserver);
2270      }
2271  
2272      @Override
2273      public boolean dispatchKeyEvent(KeyEvent event) {
2274          if (event.getAction() == KeyEvent.ACTION_DOWN) {
2275              switch (event.getKeyCode()) {
2276                  case KeyEvent.KEYCODE_HOME:
2277                      return true;
2278                  case KeyEvent.KEYCODE_VOLUME_DOWN:
2279                      if (isPropertyEnabled(DUMP_STATE_PROPERTY)) {
2280                          dumpState();
2281                          return true;
2282                      }
2283                      break;
2284              }
2285          } else if (event.getAction() == KeyEvent.ACTION_UP) {
2286              switch (event.getKeyCode()) {
2287                  case KeyEvent.KEYCODE_HOME:
2288                      return true;
2289              }
2290          }
2291  
2292          return super.dispatchKeyEvent(event);
2293      }
2294  
2295      @Override
2296      public void onBackPressed() {
2297          if (isAllAppsVisible()) {
2298              if (mAppsCustomizeContent.getContentType() ==
2299                      AppsCustomizePagedView.ContentType.Applications) {
2300                  showWorkspace(true);
2301              } else {
2302                  showOverviewMode(true);
2303              }
2304          } else if (mWorkspace.isInOverviewMode()) {
2305              mWorkspace.exitOverviewMode(true);
2306          } else if (mWorkspace.getOpenFolder() != null) {
2307              Folder openFolder = mWorkspace.getOpenFolder();
2308              if (openFolder.isEditingName()) {
2309                  openFolder.dismissEditingName();
2310              } else {
2311                  closeFolder();
2312              }
2313          } else {
2314              mWorkspace.exitWidgetResizeMode();
2315  
2316              // Back button is a no-op here, but give at least some feedback for the button press
2317              mWorkspace.showOutlinesTemporarily();
2318          }
2319      }
2320  
2321      /**
2322       * Re-listen when widgets are reset.
2323       */
2324      private void onAppWidgetReset() {
2325          if (mAppWidgetHost != null) {
2326              mAppWidgetHost.startListening();
2327          }
2328      }
2329  
2330      /**
2331       * Launches the intent referred by the clicked shortcut.
2332       *
2333       * @param v The view representing the clicked shortcut.
2334       */
2335      public void onClick(View v) {
2336          // Make sure that rogue clicks don&#x27;t get through while allapps is launching, or after the
2337          // view has detached (it&#x27;s possible for this to happen if the view is removed mid touch).
2338          if (v.getWindowToken() == null) {
2339              return;
2340          }
2341  
2342          if (!mWorkspace.isFinishedSwitchingState()) {
2343              return;
2344          }
2345  
2346          if (v instanceof Workspace) {
2347              if (mWorkspace.isInOverviewMode()) {
2348                  mWorkspace.exitOverviewMode(true);
2349              }
2350              return;
2351          }
2352  
2353          if (v instanceof CellLayout) {
2354              if (mWorkspace.isInOverviewMode()) {
2355                  mWorkspace.exitOverviewMode(mWorkspace.indexOfChild(v), true);
2356              }
2357          }
2358  
2359          Object tag = v.getTag();
2360          if (tag instanceof ShortcutInfo) {
2361              // Open shortcut
2362              final ShortcutInfo shortcut = (ShortcutInfo) tag;
2363              final Intent intent = shortcut.intent;
2364  
2365              // Check for special shortcuts
2366              if (intent.getComponent() != null) {
2367                  final String shortcutClass = intent.getComponent().getClassName();
2368  
2369                  if (shortcutClass.equals(WidgetAdder.class.getName())) {
2370                      showAllApps(true, AppsCustomizePagedView.ContentType.Widgets, true);
2371                      return;
2372                  } else if (shortcutClass.equals(MemoryDumpActivity.class.getName())) {
2373                      MemoryDumpActivity.startDump(this);
2374                      return;
2375                  } else if (shortcutClass.equals(ToggleWeightWatcher.class.getName())) {
2376                      toggleShowWeightWatcher();
2377                      return;
2378                  }
2379              }
2380  
2381              // Start activities
2382              int[] pos = new int[2];
2383              v.getLocationOnScreen(pos);
2384              intent.setSourceBounds(new Rect(pos[0], pos[1],
2385                      pos[0] + v.getWidth(), pos[1] + v.getHeight()));
2386  
2387              boolean success = startActivitySafely(v, intent, tag);
2388  
2389              mStats.recordLaunch(intent, shortcut);
2390  
2391              if (success &amp;&amp; v instanceof BubbleTextView) {
2392                  mWaitingForResume = (BubbleTextView) v;
2393                  mWaitingForResume.setStayPressed(true);
2394              }

2395          } else if (tag instanceof FolderInfo) {
2396              if (v instanceof FolderIcon) {
2397                  FolderIcon fi = (FolderIcon) v;
2398                  handleFolderClick(fi);

2399              }
2400          } else if (v == mAllAppsButton) {
2401              if (isAllAppsVisible()) {
2402                  showWorkspace(true);
2403              } else {
2404                  onClickAllAppsButton(v);
2405              }
2406          }












2407      }
2408  
2409      public boolean onTouch(View v, MotionEvent event) {
2410          return false;
































2411      }
2412  
2413      /**
2414       * Event handler for the search button
2415       *
2416       * @param v The view that was clicked.
2417       */
2418      public void onClickSearchButton(View v) {
2419          v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2420  
2421          onSearchRequested();
2422      }
2423  
2424      /**
2425       * Event handler for the voice button
2426       *
2427       * @param v The view that was clicked.
2428       */
2429      public void onClickVoiceButton(View v) {
2430          v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2431  
2432          startVoice();
2433      }
2434  
2435      public void startVoice() {
2436          try {
2437              final SearchManager searchManager =
2438                      (SearchManager) getSystemService(Context.SEARCH_SERVICE);
2439              ComponentName activityName = searchManager.getGlobalSearchActivity();
2440              Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2441              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2442              if (activityName != null) {
2443                  intent.setPackage(activityName.getPackageName());
2444              }
2445              startActivity(null, intent, &quot;onClickVoiceButton&quot;);
2446          } catch (ActivityNotFoundException e) {
2447              Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
2448              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2449              startActivitySafely(null, intent, &quot;onClickVoiceButton&quot;);
2450          }
2451      }
2452  
2453      /**
2454       * Event handler for the &quot;grid&quot; button that appears on the home screen, which
2455       * enters all apps mode.
2456       *
2457       * @param v The view that was clicked.
2458       */
2459      public void onClickAllAppsButton(View v) {
2460          showAllApps(true, AppsCustomizePagedView.ContentType.Applications, false);
2461      }
2462  
2463      public void onTouchDownAllAppsButton(View v) {
2464          // Provide the same haptic feedback that the system offers for virtual keys.
2465          v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2466      }
2467  
2468      public void performHapticFeedbackOnTouchDown(View v) {
2469          // Provide the same haptic feedback that the system offers for virtual keys.
2470          v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
2471      }
2472  
2473      public View.OnTouchListener getHapticFeedbackTouchListener() {
2474          if (mHapticFeedbackTouchListener == null) {
2475              mHapticFeedbackTouchListener = new View.OnTouchListener() {
2476                  @Override
2477                  public boolean onTouch(View v, MotionEvent event) {
2478                      if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
2479                          v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);




















2480                      }
2481                      return false;
2482                  }
2483              };
2484          }
2485          return mHapticFeedbackTouchListener;
2486      }
2487  
2488      public void onClickAppMarketButton(View v) {
2489          if (!DISABLE_MARKET_BUTTON) {
2490              if (mAppMarketIntent != null) {
2491                  startActivitySafely(v, mAppMarketIntent, &quot;app market&quot;);
2492              } else {
2493                  Log.e(TAG, &quot;Invalid app market intent.&quot;);
2494              }
2495          }
2496      }
2497  
2498      /**
2499       * Called when the user stops interacting with the launcher.
2500       * This implies that the user is now on the homescreen and is not doing housekeeping.
2501       */
2502      protected void onInteractionEnd() {}
2503  
2504      /**
2505       * Called when the user starts interacting with the launcher.
2506       * The possible interactions are:
2507       *  - open all apps
2508       *  - reorder an app shortcut, or a widget
2509       *  - open the overview mode.
2510       * This is a good time to stop doing things that only make sense
2511       * when the user is on the homescreen and not doing housekeeping.
2512       */
2513      protected void onInteractionBegin() {}
2514  
2515      void startApplicationDetailsActivity(ComponentName componentName) {
2516          String packageName = componentName.getPackageName();
2517          Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
2518                  Uri.fromParts(&quot;package&quot;, packageName, null));
2519          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
2520          startActivitySafely(null, intent, &quot;startApplicationDetailsActivity&quot;);
2521      }
2522  
2523      // returns true if the activity was started
2524      boolean startApplicationUninstallActivity(ComponentName componentName, int flags) {
2525          if ((flags &amp; AppInfo.DOWNLOADED_FLAG) == 0) {
2526              // System applications cannot be installed. For now, show a toast explaining that.
2527              // We may give them the option of disabling apps this way.
2528              int messageId = R.string.uninstall_system_app_text;
2529              Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show();
2530              return false;



































































2531          } else {
2532              String packageName = componentName.getPackageName();
2533              String className = componentName.getClassName();
2534              Intent intent = new Intent(
2535                      Intent.ACTION_DELETE, Uri.fromParts(&quot;package&quot;, packageName, className));
2536              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
2537                      Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
2538              startActivity(intent);
2539              return true;
2540          }
2541      }
2542  
2543      boolean startActivity(View v, Intent intent, Object tag) {
2544          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2545  
2546          try {
2547              // Only launch using the new animation if the shortcut has not opted out (this is a
2548              // private contract between launcher and may be ignored in the future).
2549              boolean useLaunchAnimation = (v != null) &amp;&amp;
2550                      !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);
2551              if (useLaunchAnimation) {
2552                  ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0,
2553                          v.getMeasuredWidth(), v.getMeasuredHeight());
2554  
2555                  startActivity(intent, opts.toBundle());
2556              } else {
2557                  startActivity(intent);
2558              }
2559              return true;
2560          } catch (SecurityException e) {
2561              Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2562              Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
2563                      &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
2564                      &quot;or use the exported attribute for this activity. &quot;
2565                      + &quot;tag=&quot;+ tag + &quot; intent=&quot; + intent, e);
2566          }
2567          return false;
2568      }
2569  
2570      boolean startActivitySafely(View v, Intent intent, Object tag) {
2571          boolean success = false;
2572          try {
2573              success = startActivity(v, intent, tag);
2574          } catch (ActivityNotFoundException e) {
2575              Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
2576              Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);
2577          }
2578          return success;
2579      }
2580  
2581      private void handleFolderClick(FolderIcon folderIcon) {
























2582          final FolderInfo info = folderIcon.getFolderInfo();
2583          Folder openFolder = mWorkspace.getFolderForTag(info);
2584  
2585          // If the folder info reports that the associated folder is open, then verify that
2586          // it is actually opened. There have been a few instances where this gets out of sync.
2587          if (info.opened &amp;&amp; openFolder == null) {
2588              Log.d(TAG, &quot;Folder info marked as open, but associated folder is not open. Screen: &quot;
2589                      + info.screenId + &quot; (&quot; + info.cellX + &quot;, &quot; + info.cellY + &quot;)&quot;);
2590              info.opened = false;
2591          }
2592  
2593          if (!info.opened &amp;&amp; !folderIcon.getFolder().isDestroyed()) {
2594              // Close any open folder
2595              closeFolder();
2596              // Open the requested folder
2597              openFolder(folderIcon);
2598          } else {
2599              // Find the open folder...
2600              int folderScreen;
2601              if (openFolder != null) {
2602                  folderScreen = mWorkspace.getPageForView(openFolder);
2603                  // .. and close it
2604                  closeFolder(openFolder);
2605                  if (folderScreen != mWorkspace.getCurrentPage()) {
2606                      // Close any folder open on the current screen
2607                      closeFolder();
2608                      // Pull the folder onto this screen
2609                      openFolder(folderIcon);
2610                  }
2611              }
2612          }
2613      }
2614  
2615      /**









































































































































































2616       * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView
2617       * in the DragLayer in the exact absolute location of the original FolderIcon.
2618       */
2619      private void copyFolderIconToImage(FolderIcon fi) {
2620          final int width = fi.getMeasuredWidth();
2621          final int height = fi.getMeasuredHeight();
2622  
2623          // Lazy load ImageView, Bitmap and Canvas
2624          if (mFolderIconImageView == null) {
2625              mFolderIconImageView = new ImageView(this);
2626          }
2627          if (mFolderIconBitmap == null || mFolderIconBitmap.getWidth() != width ||
2628                  mFolderIconBitmap.getHeight() != height) {
2629              mFolderIconBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
2630              mFolderIconCanvas = new Canvas(mFolderIconBitmap);
2631          }
2632  
2633          DragLayer.LayoutParams lp;
2634          if (mFolderIconImageView.getLayoutParams() instanceof DragLayer.LayoutParams) {
2635              lp = (DragLayer.LayoutParams) mFolderIconImageView.getLayoutParams();
2636          } else {
2637              lp = new DragLayer.LayoutParams(width, height);
2638          }
2639  
2640          // The layout from which the folder is being opened may be scaled, adjust the starting
2641          // view size by this scale factor.
2642          float scale = mDragLayer.getDescendantRectRelativeToSelf(fi, mRectForFolderAnimation);
2643          lp.customPosition = true;
2644          lp.x = mRectForFolderAnimation.left;
2645          lp.y = mRectForFolderAnimation.top;
2646          lp.width = (int) (scale * width);
2647          lp.height = (int) (scale * height);
2648  
2649          mFolderIconCanvas.drawColor(0, PorterDuff.Mode.CLEAR);
2650          fi.draw(mFolderIconCanvas);
2651          mFolderIconImageView.setImageBitmap(mFolderIconBitmap);
2652          if (fi.getFolder() != null) {
2653              mFolderIconImageView.setPivotX(fi.getFolder().getPivotXForIconAnimation());
2654              mFolderIconImageView.setPivotY(fi.getFolder().getPivotYForIconAnimation());
2655          }
2656          // Just in case this image view is still in the drag layer from a previous animation,
2657          // we remove it and re-add it.
2658          if (mDragLayer.indexOfChild(mFolderIconImageView) != -1) {
2659              mDragLayer.removeView(mFolderIconImageView);
2660          }
2661          mDragLayer.addView(mFolderIconImageView, lp);
2662          if (fi.getFolder() != null) {
2663              fi.getFolder().bringToFront();
2664          }
2665      }
2666  
2667      private void growAndFadeOutFolderIcon(FolderIcon fi) {
2668          if (fi == null) return;
2669          PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0);
2670          PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.5f);
2671          PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.5f);
2672  
2673          FolderInfo info = (FolderInfo) fi.getTag();
2674          if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2675              CellLayout cl = (CellLayout) fi.getParent().getParent();
2676              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) fi.getLayoutParams();
2677              cl.setFolderLeaveBehindCell(lp.cellX, lp.cellY);
2678          }
2679  
2680          // Push an ImageView copy of the FolderIcon into the DragLayer and hide the original
2681          copyFolderIconToImage(fi);
2682          fi.setVisibility(View.INVISIBLE);
2683  
2684          ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
2685                  scaleX, scaleY);
2686          oa.setDuration(getResources().getInteger(R.integer.config_folderAnimDuration));




2687          oa.start();
2688      }
2689  
2690      private void shrinkAndFadeInFolderIcon(final FolderIcon fi) {
2691          if (fi == null) return;
2692          PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f);
2693          PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1.0f);
2694          PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1.0f);
2695  
2696          final CellLayout cl = (CellLayout) fi.getParent().getParent();
2697  
2698          // We remove and re-draw the FolderIcon in-case it has changed
2699          mDragLayer.removeView(mFolderIconImageView);
2700          copyFolderIconToImage(fi);
2701          ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
2702                  scaleX, scaleY);
2703          oa.setDuration(getResources().getInteger(R.integer.config_folderAnimDuration));

2704          oa.addListener(new AnimatorListenerAdapter() {
2705              @Override
2706              public void onAnimationEnd(Animator animation) {
2707                  if (cl != null) {
2708                      cl.clearFolderLeaveBehind();
2709                      // Remove the ImageView copy of the FolderIcon and make the original visible.
2710                      mDragLayer.removeView(mFolderIconImageView);
2711                      fi.setVisibility(View.VISIBLE);
2712                  }
2713              }
2714          });
2715          oa.start();
2716      }
2717  
2718      /**
2719       * Opens the user folder described by the specified tag. The opening of the folder
2720       * is animated relative to the specified View. If the View is null, no animation
2721       * is played.
2722       *
2723       * @param folderInfo The FolderInfo describing the folder to open.
2724       */
2725      public void openFolder(FolderIcon folderIcon) {
2726          Folder folder = folderIcon.getFolder();
2727          FolderInfo info = folder.mInfo;
2728  
2729          info.opened = true;
2730  
2731          // Just verify that the folder hasn&#x27;t already been added to the DragLayer.
2732          // There was a one-off crash where the folder had a parent already.
2733          if (folder.getParent() == null) {
2734              mDragLayer.addView(folder);
2735              mDragController.addDropTarget((DropTarget) folder);
2736          } else {
2737              Log.w(TAG, &quot;Opening folder (&quot; + folder + &quot;) which already has a parent (&quot; +
2738                      folder.getParent() + &quot;).&quot;);
2739          }
2740          folder.animateOpen();
2741          growAndFadeOutFolderIcon(folderIcon);
2742  
2743          // Notify the accessibility manager that this folder &quot;window&quot; has appeared and occluded
2744          // the workspace items
2745          folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
2746          getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
2747      }
2748  
2749      public void closeFolder() {
2750          Folder folder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
2751          if (folder != null) {
2752              if (folder.isEditingName()) {
2753                  folder.dismissEditingName();
2754              }
2755              closeFolder(folder);
2756  
2757              // Dismiss the folder cling
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2758 -            dismissFolderCling(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2759 +            mLauncherClings.dismissFolderCling(null);</span>
2760          }
2761      }
2762  
2763      void closeFolder(Folder folder) {
2764          folder.getInfo().opened = false;
2765  
2766          ViewGroup parent = (ViewGroup) folder.getParent().getParent();
2767          if (parent != null) {
2768              FolderIcon fi = (FolderIcon) mWorkspace.getViewForTag(folder.mInfo);
2769              shrinkAndFadeInFolderIcon(fi);
2770          }
2771          folder.animateClosed();
2772  
2773          // Notify the accessibility manager that this folder &quot;window&quot; has disappeard and no
2774          // longer occludeds the workspace items
2775          getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
2776      }
2777  
2778      public boolean onLongClick(View v) {
2779          if (!isDraggingEnabled()) return false;
2780          if (isWorkspaceLocked()) return false;
2781          if (mState != State.WORKSPACE) return false;
2782  
2783          if (v instanceof Workspace) {
2784              if (!mWorkspace.isInOverviewMode()) {
2785                  if (mWorkspace.enterOverviewMode()) {
2786                      mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
2787                              HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
2788                      return true;
2789                  } else {
2790                      return false;
2791                  }
2792              }
2793          }
2794  
2795          if (!(v instanceof CellLayout)) {
2796              v = (View) v.getParent().getParent();
2797          }
2798  
2799          resetAddInfo();
2800          CellLayout.CellInfo longClickCellInfo = (CellLayout.CellInfo) v.getTag();
2801          // This happens when long clicking an item with the dpad/trackball
2802          if (longClickCellInfo == null) {
2803              return true;












2804          }
2805  
2806          // The hotseat touch handling does not go through Workspace, and we always allow long press
2807          // on hotseat items.
2808          final View itemUnderLongClick = longClickCellInfo.cell;
2809          boolean allowLongPress = isHotseatLayout(v) || mWorkspace.allowLongPress();


2810          if (allowLongPress &amp;&amp; !mDragController.isDragging()) {
2811              if (itemUnderLongClick == null) {
2812                  // User long pressed on empty space
2813                  mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
2814                          HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
2815                  // Disabling reordering until we sort out some issues.
2816                  if (mWorkspace.isInOverviewMode()) {
2817                      mWorkspace.startReordering(v);
2818                  } else {
2819                      mWorkspace.enterOverviewMode();
2820                  }
2821              } else {
2822                  if (!(itemUnderLongClick instanceof Folder)) {





2823                      // User long pressed on an item
2824                      mWorkspace.startDrag(longClickCellInfo);
2825                  }
2826              }
2827          }
2828          return true;
2829      }
2830  
2831      boolean isHotseatLayout(View layout) {
2832          return mHotseat != null &amp;&amp; layout != null &amp;&amp;
2833                  (layout instanceof CellLayout) &amp;&amp; (layout == mHotseat.getLayout());
2834      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2835 -    Hotseat getHotseat() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2836 -        return mHotseat;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2837 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2838 -    View getOverviewPanel() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2839 -        return mOverviewPanel;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2840 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2841 -    SearchDropTargetBar getSearchBar() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2842 -        return mSearchDropTargetBar;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2843 -    }</span>
2844  
2845      /**
2846       * Returns the CellLayout of the specified container at the specified screen.
2847       */
2848      CellLayout getCellLayout(long container, long screenId) {
2849          if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2850              if (mHotseat != null) {
2851                  return mHotseat.getLayout();
2852              } else {
2853                  return null;
2854              }
2855          } else {
2856              return (CellLayout) mWorkspace.getScreenWithId(screenId);
2857          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2858 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2859 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2860 -    Workspace getWorkspace() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2861 -        return mWorkspace;</span>
2862      }
2863  
2864      public boolean isAllAppsVisible() {
2865          return (mState == State.APPS_CUSTOMIZE) || (mOnResumeState == State.APPS_CUSTOMIZE);
2866      }
2867  
2868      /**
2869       * Helper method for the cameraZoomIn/cameraZoomOut animations
2870       * @param view The view being animated
2871       * @param scaleFactor The scale factor used for the zoom
2872       */
2873      private void setPivotsForZoom(View view, float scaleFactor) {
2874          view.setPivotX(view.getWidth() / 2.0f);
2875          view.setPivotY(view.getHeight() / 2.0f);
2876      }
2877  
2878      private void setWorkspaceBackground(boolean workspace) {
2879          mLauncherView.setBackground(workspace ?
2880                  mWorkspaceBackgroundDrawable : null);
2881      }
2882  
2883      void updateWallpaperVisibility(boolean visible) {

2884          int wpflags = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
2885          int curflags = getWindow().getAttributes().flags
2886                  &amp; WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
2887          if (wpflags != curflags) {
2888              getWindow().setFlags(wpflags, WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
2889          }
2890          setWorkspaceBackground(visible);
2891      }
2892  
2893      private void dispatchOnLauncherTransitionPrepare(View v, boolean animated, boolean toWorkspace) {
2894          if (v instanceof LauncherTransitionable) {
2895              ((LauncherTransitionable) v).onLauncherTransitionPrepare(this, animated, toWorkspace);
2896          }
2897      }
2898  
2899      private void dispatchOnLauncherTransitionStart(View v, boolean animated, boolean toWorkspace) {
2900          if (v instanceof LauncherTransitionable) {
2901              ((LauncherTransitionable) v).onLauncherTransitionStart(this, animated, toWorkspace);
2902          }
2903  
2904          // Update the workspace transition step as well
2905          dispatchOnLauncherTransitionStep(v, 0f);
2906      }
2907  
2908      private void dispatchOnLauncherTransitionStep(View v, float t) {
2909          if (v instanceof LauncherTransitionable) {
2910              ((LauncherTransitionable) v).onLauncherTransitionStep(this, t);
2911          }
2912      }
2913  
2914      private void dispatchOnLauncherTransitionEnd(View v, boolean animated, boolean toWorkspace) {
2915          if (v instanceof LauncherTransitionable) {
2916              ((LauncherTransitionable) v).onLauncherTransitionEnd(this, animated, toWorkspace);
2917          }
2918  
2919          // Update the workspace transition step as well
2920          dispatchOnLauncherTransitionStep(v, 1f);
2921      }
2922  
2923      /**
2924       * Things to test when changing the following seven functions.
2925       *   - Home from workspace
2926       *          - from center screen
2927       *          - from other screens
2928       *   - Home from all apps
2929       *          - from center screen
2930       *          - from other screens
2931       *   - Back from all apps
2932       *          - from center screen
2933       *          - from other screens
2934       *   - Launch app from workspace and quit
2935       *          - with back
2936       *          - with home
2937       *   - Launch app from all apps and quit
2938       *          - with back
2939       *          - with home
2940       *   - Go to a screen that&#x27;s not the default, then all
2941       *     apps, and launch and app, and go back
2942       *          - with back
2943       *          -with home
2944       *   - On workspace, long press power and go back
2945       *          - with back
2946       *          - with home
2947       *   - On all apps, long press power and go back
2948       *          - with back
2949       *          - with home
2950       *   - On workspace, power off
2951       *   - On all apps, power off
2952       *   - Launch an app and turn off the screen while in that app
2953       *          - Go back with home key
2954       *          - Go back with back key  TODO: make this not go to workspace
2955       *          - From all apps
2956       *          - From workspace
2957       *   - Enter and exit car mode (becuase it causes an extra configuration changed)
2958       *          - From all apps
2959       *          - From the center workspace
2960       *          - From another workspace
2961       */
2962  
2963      /**
2964       * Zoom the camera out from the workspace to reveal &#x27;toView&#x27;.
2965       * Assumes that the view to show is anchored at either the very top or very bottom
2966       * of the screen.
2967       */
2968      private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded) {
2969          AppsCustomizePagedView.ContentType contentType = mAppsCustomizeContent.getContentType();
2970          showAppsCustomizeHelper(animated, springLoaded, contentType);
2971      }

2972      private void showAppsCustomizeHelper(final boolean animated, final boolean springLoaded,
2973                                           final AppsCustomizePagedView.ContentType contentType) {
2974          if (mStateAnimation != null) {
2975              mStateAnimation.setDuration(0);
2976              mStateAnimation.cancel();
2977              mStateAnimation = null;
2978          }



2979          final Resources res = getResources();
2980  
2981          final int duration = res.getInteger(R.integer.config_appsCustomizeZoomInTime);
2982          final int fadeDuration = res.getInteger(R.integer.config_appsCustomizeFadeInTime);




2983          final float scale = (float) res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
2984          final View fromView = mWorkspace;
2985          final AppsCustomizeTabHost toView = mAppsCustomizeTabHost;
2986          final int startDelay =
2987                  res.getInteger(R.integer.config_workspaceAppsCustomizeAnimationStagger);
2988  
2989          setPivotsForZoom(toView, scale);
2990  
2991          // Shrink workspaces away if going to AppsCustomize from workspace





2992          Animator workspaceAnim =
2993                  mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, animated);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2994 -        if (!AppsCustomizePagedView.DISABLE_ALL_APPS</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2995 +        if (!LauncherAppState.isDisableAllApps()</span>

2996                  || contentType == AppsCustomizePagedView.ContentType.Widgets) {
2997              // Set the content type for the all apps/widgets space
2998              mAppsCustomizeTabHost.setContentTypeImmediate(contentType);
2999          }
3000  
3001          if (animated) {
3002              toView.setScaleX(scale);
3003              toView.setScaleY(scale);
3004              final LauncherViewPropertyAnimator scaleAnim = new LauncherViewPropertyAnimator(toView);
3005              scaleAnim.
3006                  scaleX(1f).scaleY(1f).
3007                  setDuration(duration).
3008                  setInterpolator(new Workspace.ZoomOutInterpolator());
3009  
3010              toView.setVisibility(View.VISIBLE);
3011              toView.setAlpha(0f);
3012              final ObjectAnimator alphaAnim = LauncherAnimUtils
3013                  .ofFloat(toView, &quot;alpha&quot;, 0f, 1f)
3014                  .setDuration(fadeDuration);
3015              alphaAnim.setInterpolator(new DecelerateInterpolator(1.5f));
3016              alphaAnim.addUpdateListener(new AnimatorUpdateListener() {
3017                  @Override
3018                  public void onAnimationUpdate(ValueAnimator animation) {
3019                      if (animation == null) {
3020                          throw new RuntimeException(&quot;animation is null&quot;);












































































































3021                      }
3022                      float t = (Float) animation.getAnimatedValue();
3023                      dispatchOnLauncherTransitionStep(fromView, t);
3024                      dispatchOnLauncherTransitionStep(toView, t);
3025                  }
3026              });
3027  
3028              // toView should appear right at the end of the workspace shrink
3029              // animation
3030              mStateAnimation = LauncherAnimUtils.createAnimatorSet();
3031              mStateAnimation.play(scaleAnim).after(startDelay);
3032              mStateAnimation.play(alphaAnim).after(startDelay);








3033  
3034              mStateAnimation.addListener(new AnimatorListenerAdapter() {
3035                  @Override
3036                  public void onAnimationStart(Animator animation) {
3037                      // Prepare the position
3038                      toView.setTranslationX(0.0f);
3039                      toView.setTranslationY(0.0f);
3040                      toView.setVisibility(View.VISIBLE);
3041                      toView.bringToFront();
3042                  }
3043                  @Override
3044                  public void onAnimationEnd(Animator animation) {
3045                      dispatchOnLauncherTransitionEnd(fromView, animated, false);
3046                      dispatchOnLauncherTransitionEnd(toView, animated, false);







3047  
3048                      // Hide the search bar
3049                      if (mSearchDropTargetBar != null) {
3050                          mSearchDropTargetBar.hideSearchBar(false);
3051                      }
3052                  }

3053              });
3054  
3055              if (workspaceAnim != null) {
3056                  mStateAnimation.play(workspaceAnim);
3057              }
3058  
3059              boolean delayAnim = false;
3060  
3061              dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3062              dispatchOnLauncherTransitionPrepare(toView, animated, false);
3063  
3064              // If any of the objects being animated haven&#x27;t been measured/laid out
3065              // yet, delay the animation until we get a layout pass
3066              if ((((LauncherTransitionable) toView).getContent().getMeasuredWidth() == 0) ||
3067                      (mWorkspace.getMeasuredWidth() == 0) ||
3068                      (toView.getMeasuredWidth() == 0)) {
3069                  delayAnim = true;
3070              }
3071  
3072              final AnimatorSet stateAnimation = mStateAnimation;
3073              final Runnable startAnimRunnable = new Runnable() {
3074                  public void run() {
3075                      // Check that mStateAnimation hasn&#x27;t changed while
3076                      // we waited for a layout/draw pass
3077                      if (mStateAnimation != stateAnimation)
3078                          return;
3079                      setPivotsForZoom(toView, scale);
3080                      dispatchOnLauncherTransitionStart(fromView, animated, false);
3081                      dispatchOnLauncherTransitionStart(toView, animated, false);
3082                      LauncherAnimUtils.startAnimationAfterNextDraw(mStateAnimation, toView);















3083                  }
3084              };
3085              if (delayAnim) {
3086                  final ViewTreeObserver observer = toView.getViewTreeObserver();
3087                  observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
3088                          public void onGlobalLayout() {
3089                              startAnimRunnable.run();
3090                              toView.getViewTreeObserver().removeOnGlobalLayoutListener(this);
3091                          }
3092                      });
3093              } else {
3094                  startAnimRunnable.run();
3095              }



3096          } else {
3097              toView.setTranslationX(0.0f);
3098              toView.setTranslationY(0.0f);
3099              toView.setScaleX(1.0f);
3100              toView.setScaleY(1.0f);
3101              toView.setVisibility(View.VISIBLE);
3102              toView.bringToFront();
3103  
3104              if (!springLoaded &amp;&amp; !LauncherAppState.getInstance().isScreenLarge()) {
3105                  // Hide the search bar
3106                  if (mSearchDropTargetBar != null) {
3107                      mSearchDropTargetBar.hideSearchBar(false);
3108                  }
3109              }
3110              dispatchOnLauncherTransitionPrepare(fromView, animated, false);
3111              dispatchOnLauncherTransitionStart(fromView, animated, false);
3112              dispatchOnLauncherTransitionEnd(fromView, animated, false);
3113              dispatchOnLauncherTransitionPrepare(toView, animated, false);
3114              dispatchOnLauncherTransitionStart(toView, animated, false);
3115              dispatchOnLauncherTransitionEnd(toView, animated, false);
3116          }
3117      }
3118  
3119      /**
3120       * Zoom the camera back into the workspace, hiding &#x27;fromView&#x27;.
3121       * This is the opposite of showAppsCustomizeHelper.
3122       * @param animated If true, the transition will be animated.
3123       */
3124      private void hideAppsCustomizeHelper(Workspace.State toState, final boolean animated,
3125              final boolean springLoaded, final Runnable onCompleteRunnable) {
3126  
3127          if (mStateAnimation != null) {
3128              mStateAnimation.setDuration(0);
3129              mStateAnimation.cancel();
3130              mStateAnimation = null;
3131          }


3132          Resources res = getResources();
3133  
3134          final int duration = res.getInteger(R.integer.config_appsCustomizeZoomOutTime);
3135          final int fadeOutDuration =
3136                  res.getInteger(R.integer.config_appsCustomizeFadeOutTime);





3137          final float scaleFactor = (float)
3138                  res.getInteger(R.integer.config_appsCustomizeZoomScaleFactor);
3139          final View fromView = mAppsCustomizeTabHost;
3140          final View toView = mWorkspace;
3141          Animator workspaceAnim = null;


3142          if (toState == Workspace.State.NORMAL) {
3143              int stagger = res.getInteger(R.integer.config_appsCustomizeWorkspaceAnimationStagger);
3144              workspaceAnim = mWorkspace.getChangeStateAnimation(
3145                      toState, animated, stagger, -1);

3146          } else if (toState == Workspace.State.SPRING_LOADED ||
3147                  toState == Workspace.State.OVERVIEW) {
3148              workspaceAnim = mWorkspace.getChangeStateAnimation(
3149                      toState, animated);
3150          }
3151  
3152          setPivotsForZoom(fromView, scaleFactor);
3153          showHotseat(animated);
3154          if (animated) {
3155              final LauncherViewPropertyAnimator scaleAnim =
3156                      new LauncherViewPropertyAnimator(fromView);
3157              scaleAnim.
3158                  scaleX(scaleFactor).scaleY(scaleFactor).
3159                  setDuration(duration).
3160                  setInterpolator(new Workspace.ZoomInInterpolator());
3161  
3162              final ObjectAnimator alphaAnim = LauncherAnimUtils
3163                  .ofFloat(fromView, &quot;alpha&quot;, 1f, 0f)
3164                  .setDuration(fadeOutDuration);
3165              alphaAnim.setInterpolator(new AccelerateDecelerateInterpolator());
3166              alphaAnim.addUpdateListener(new AnimatorUpdateListener() {
3167                  @Override
3168                  public void onAnimationUpdate(ValueAnimator animation) {
3169                      float t = 1f - (Float) animation.getAnimatedValue();
3170                      dispatchOnLauncherTransitionStep(fromView, t);
3171                      dispatchOnLauncherTransitionStep(toView, t);























3172                  }
3173              });
3174  
3175              mStateAnimation = LauncherAnimUtils.createAnimatorSet();
3176  
3177              dispatchOnLauncherTransitionPrepare(fromView, animated, true);
3178              dispatchOnLauncherTransitionPrepare(toView, animated, true);
3179              mAppsCustomizeContent.stopScrolling();



































































































































3180  
3181              mStateAnimation.addListener(new AnimatorListenerAdapter() {
3182                  @Override
3183                  public void onAnimationEnd(Animator animation) {
3184                      fromView.setVisibility(View.GONE);
3185                      dispatchOnLauncherTransitionEnd(fromView, animated, true);
3186                      dispatchOnLauncherTransitionEnd(toView, animated, true);
3187                      if (onCompleteRunnable != null) {
3188                          onCompleteRunnable.run();
3189                      }





















3190                      mAppsCustomizeContent.updateCurrentPageScroll();
3191                  }
3192              });
3193  
3194              mStateAnimation.playTogether(scaleAnim, alphaAnim);
3195              if (workspaceAnim != null) {
3196                  mStateAnimation.play(workspaceAnim);
3197              }
3198              dispatchOnLauncherTransitionStart(fromView, animated, true);
3199              dispatchOnLauncherTransitionStart(toView, animated, true);
3200              LauncherAnimUtils.startAnimationAfterNextDraw(mStateAnimation, toView);


























3201          } else {
3202              fromView.setVisibility(View.GONE);
3203              dispatchOnLauncherTransitionPrepare(fromView, animated, true);
3204              dispatchOnLauncherTransitionStart(fromView, animated, true);
3205              dispatchOnLauncherTransitionEnd(fromView, animated, true);
3206              dispatchOnLauncherTransitionPrepare(toView, animated, true);
3207              dispatchOnLauncherTransitionStart(toView, animated, true);
3208              dispatchOnLauncherTransitionEnd(toView, animated, true);
3209          }
3210      }
3211  
3212      @Override
3213      public void onTrimMemory(int level) {
3214          super.onTrimMemory(level);
3215          if (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
3216              mAppsCustomizeTabHost.onTrimMemory();
3217          }
3218      }
3219  
3220      protected void showWorkspace(boolean animated) {
3221          showWorkspace(animated, null);
3222      }
3223  
3224      protected void showWorkspace() {
3225          showWorkspace(true);
3226      }
3227  
3228      void showWorkspace(boolean animated, Runnable onCompleteRunnable) {
3229          if (mWorkspace.isInOverviewMode()) {
3230              mWorkspace.exitOverviewMode(animated);
3231          }
3232          if (mState != State.WORKSPACE) {

3233              boolean wasInSpringLoadedMode = (mState != State.WORKSPACE);
3234              mWorkspace.setVisibility(View.VISIBLE);
3235              hideAppsCustomizeHelper(Workspace.State.NORMAL, animated, false, onCompleteRunnable);
3236  
3237              // Show the search bar (only animate if we were showing the drop target bar in spring
3238              // loaded mode)
3239              if (mSearchDropTargetBar != null) {
3240                  mSearchDropTargetBar.showSearchBar(animated &amp;&amp; wasInSpringLoadedMode);
3241              }
3242  
3243              // Set focus to the AppsCustomize button
3244              if (mAllAppsButton != null) {
3245                  mAllAppsButton.requestFocus();
3246              }
3247          }
3248  
3249          // Change the state *after* we&#x27;ve called all the transition code
3250          mState = State.WORKSPACE;
3251  
3252          // Resume the auto-advance of widgets
3253          mUserPresent = true;
3254          updateRunning();
3255  
3256          // Send an accessibility event to announce the context change
3257          getWindow().getDecorView()
3258                  .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3259  
3260          onWorkspaceShown(animated);
3261      }
3262  
3263      void showOverviewMode(boolean animated) {
3264          mWorkspace.setVisibility(View.VISIBLE);
3265          hideAppsCustomizeHelper(Workspace.State.OVERVIEW, animated, false, null);
3266          mState = State.WORKSPACE;
3267          onWorkspaceShown(animated);
3268      }
3269  
3270      public void onWorkspaceShown(boolean animated) {
3271      }
3272  
3273      void showAllApps(boolean animated, AppsCustomizePagedView.ContentType contentType,
3274                       boolean resetPageToZero) {
3275          if (mState != State.WORKSPACE) return;
3276  
3277          if (resetPageToZero) {
3278              mAppsCustomizeTabHost.reset();
3279          }
3280          showAppsCustomizeHelper(animated, false, contentType);
3281          mAppsCustomizeTabHost.requestFocus();







3282  
3283          // Change the state *after* we&#x27;ve called all the transition code
3284          mState = State.APPS_CUSTOMIZE;
3285  
3286          // Pause the auto-advance of widgets until we are out of AllApps
3287          mUserPresent = false;
3288          updateRunning();
3289          closeFolder();
3290  
3291          // Send an accessibility event to announce the context change
3292          getWindow().getDecorView()
3293                  .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
3294      }
3295  
3296      void enterSpringLoadedDragMode() {
3297          if (isAllAppsVisible()) {
3298              hideAppsCustomizeHelper(Workspace.State.SPRING_LOADED, true, true, null);
3299              mState = State.APPS_CUSTOMIZE_SPRING_LOADED;
3300          }
3301      }
3302  
3303      void exitSpringLoadedDragModeDelayed(final boolean successfulDrop, int delay,
3304              final Runnable onCompleteRunnable) {
3305          if (mState != State.APPS_CUSTOMIZE_SPRING_LOADED) return;
3306  
3307          mHandler.postDelayed(new Runnable() {
3308              @Override
3309              public void run() {
3310                  if (successfulDrop) {
3311                      // Before we show workspace, hide all apps again because
3312                      // exitSpringLoadedDragMode made it visible. This is a bit hacky; we should
3313                      // clean up our state transition functions
3314                      mAppsCustomizeTabHost.setVisibility(View.GONE);
3315                      showWorkspace(true, onCompleteRunnable);
3316                  } else {
3317                      exitSpringLoadedDragMode();
3318                  }
3319              }
3320          }, delay);
3321  
3322      }
3323  
3324      void exitSpringLoadedDragMode() {
3325          if (mState == State.APPS_CUSTOMIZE_SPRING_LOADED) {
3326              final boolean animated = true;
3327              final boolean springLoaded = true;
3328              showAppsCustomizeHelper(animated, springLoaded);
3329              mState = State.APPS_CUSTOMIZE;
3330          }
3331          // Otherwise, we are not in spring loaded mode, so don&#x27;t do anything.
3332      }
3333  
3334      void lockAllApps() {
3335          // TODO
3336      }
3337  
3338      void unlockAllApps() {
3339          // TODO
3340      }
3341  
3342      /**
3343       * Shows the hotseat area.
3344       */
3345      void showHotseat(boolean animated) {
3346          if (!LauncherAppState.getInstance().isScreenLarge()) {
3347              if (animated) {
3348                  if (mHotseat.getAlpha() != 1f) {
3349                      int duration = 0;
3350                      if (mSearchDropTargetBar != null) {
3351                          duration = mSearchDropTargetBar.getTransitionInDuration();
3352                      }
3353                      mHotseat.animate().alpha(1f).setDuration(duration);
3354                  }
3355              } else {
3356                  mHotseat.setAlpha(1f);
3357              }
3358          }
3359      }
3360  
3361      /**
3362       * Hides the hotseat area.
3363       */
3364      void hideHotseat(boolean animated) {
3365          if (!LauncherAppState.getInstance().isScreenLarge()) {
3366              if (animated) {
3367                  if (mHotseat.getAlpha() != 0f) {
3368                      int duration = 0;
3369                      if (mSearchDropTargetBar != null) {
3370                          duration = mSearchDropTargetBar.getTransitionOutDuration();
3371                      }
3372                      mHotseat.animate().alpha(0f).setDuration(duration);
3373                  }
3374              } else {
3375                  mHotseat.setAlpha(0f);
3376              }
3377          }
3378      }
3379  
3380      /**
3381       * Add an item from all apps or customize onto the given workspace screen.
3382       * If layout is null, add to the current screen.
3383       */
3384      void addExternalItemToScreen(ItemInfo itemInfo, final CellLayout layout) {
3385          if (!mWorkspace.addExternalItemToScreen(itemInfo, layout)) {
3386              showOutOfSpaceMessage(isHotseatLayout(layout));
3387          }
3388      }
3389  
3390      /** Maps the current orientation to an index for referencing orientation correct global icons */
3391      private int getCurrentOrientationIndexForGlobalIcons() {
3392          // default - 0, landscape - 1
3393          switch (getResources().getConfiguration().orientation) {
3394          case Configuration.ORIENTATION_LANDSCAPE:
3395              return 1;
3396          default:
3397              return 0;
3398          }
3399      }
3400  
3401      private Drawable getExternalPackageToolbarIcon(ComponentName activityName, String resourceName) {
3402          try {
3403              PackageManager packageManager = getPackageManager();
3404              // Look for the toolbar icon specified in the activity meta-data
3405              Bundle metaData = packageManager.getActivityInfo(
3406                      activityName, PackageManager.GET_META_DATA).metaData;
3407              if (metaData != null) {
3408                  int iconResId = metaData.getInt(resourceName);
3409                  if (iconResId != 0) {
3410                      Resources res = packageManager.getResourcesForActivity(activityName);
3411                      return res.getDrawable(iconResId);
3412                  }
3413              }
3414          } catch (NameNotFoundException e) {
3415              // This can happen if the activity defines an invalid drawable
3416              Log.w(TAG, &quot;Failed to load toolbar icon; &quot; + activityName.flattenToShortString() +
3417                      &quot; not found&quot;, e);
3418          } catch (Resources.NotFoundException nfe) {
3419              // This can happen if the activity defines an invalid drawable
3420              Log.w(TAG, &quot;Failed to load toolbar icon from &quot; + activityName.flattenToShortString(),
3421                      nfe);
3422          }
3423          return null;
3424      }
3425  
3426      // if successful in getting icon, return it; otherwise, set button to use default drawable
3427      private Drawable.ConstantState updateTextButtonWithIconFromExternalActivity(
3428              int buttonId, ComponentName activityName, int fallbackDrawableId,
3429              String toolbarResourceName) {
3430          Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
3431          Resources r = getResources();
3432          int w = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_width);
3433          int h = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_height);
3434  
3435          TextView button = (TextView) findViewById(buttonId);
3436          // If we were unable to find the icon via the meta-data, use a generic one
3437          if (toolbarIcon == null) {
3438              toolbarIcon = r.getDrawable(fallbackDrawableId);
3439              toolbarIcon.setBounds(0, 0, w, h);
3440              if (button != null) {
3441                  button.setCompoundDrawables(toolbarIcon, null, null, null);
3442              }
3443              return null;
3444          } else {
3445              toolbarIcon.setBounds(0, 0, w, h);
3446              if (button != null) {
3447                  button.setCompoundDrawables(toolbarIcon, null, null, null);
3448              }
3449              return toolbarIcon.getConstantState();
3450          }
3451      }
3452  
3453      // if successful in getting icon, return it; otherwise, set button to use default drawable
3454      private Drawable.ConstantState updateButtonWithIconFromExternalActivity(
3455              int buttonId, ComponentName activityName, int fallbackDrawableId,
3456              String toolbarResourceName) {
3457          ImageView button = (ImageView) findViewById(buttonId);
3458          Drawable toolbarIcon = getExternalPackageToolbarIcon(activityName, toolbarResourceName);
3459  
3460          if (button != null) {
3461              // If we were unable to find the icon via the meta-data, use a
3462              // generic one
3463              if (toolbarIcon == null) {
3464                  button.setImageResource(fallbackDrawableId);
3465              } else {
3466                  button.setImageDrawable(toolbarIcon);
3467              }
3468          }
3469  
3470          return toolbarIcon != null ? toolbarIcon.getConstantState() : null;
3471  
3472      }
3473  
3474      private void updateTextButtonWithDrawable(int buttonId, Drawable d) {
3475          TextView button = (TextView) findViewById(buttonId);
3476          button.setCompoundDrawables(d, null, null, null);
3477      }
3478  
3479      private void updateButtonWithDrawable(int buttonId, Drawable.ConstantState d) {
3480          ImageView button = (ImageView) findViewById(buttonId);
3481          button.setImageDrawable(d.newDrawable(getResources()));
3482      }
3483  
3484      private void invalidatePressedFocusedStates(View container, View button) {
3485          if (container instanceof HolographicLinearLayout) {
3486              HolographicLinearLayout layout = (HolographicLinearLayout) container;
3487              layout.invalidatePressedFocusedStates();
3488          } else if (button instanceof HolographicImageView) {
3489              HolographicImageView view = (HolographicImageView) button;
3490              view.invalidatePressedFocusedStates();
3491          }
3492      }
3493  
3494      public View getQsbBar() {
3495          if (mQsbBar == null) {
3496              mQsbBar = mInflater.inflate(R.layout.search_bar, mSearchDropTargetBar, false);
3497              mSearchDropTargetBar.addView(mQsbBar);
3498          }
3499          return mQsbBar;





3500      }
3501  
3502      protected boolean updateGlobalSearchIcon() {
3503          final View searchButtonContainer = findViewById(R.id.search_button_container);
3504          final ImageView searchButton = (ImageView) findViewById(R.id.search_button);
3505          final View voiceButtonContainer = findViewById(R.id.voice_button_container);
3506          final View voiceButton = findViewById(R.id.voice_button);
3507  
3508          final SearchManager searchManager =
3509                  (SearchManager) getSystemService(Context.SEARCH_SERVICE);
3510          ComponentName activityName = searchManager.getGlobalSearchActivity();
3511          if (activityName != null) {
3512              int coi = getCurrentOrientationIndexForGlobalIcons();
3513              sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
3514                      R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
3515                      TOOLBAR_SEARCH_ICON_METADATA_NAME);
3516              if (sGlobalSearchIcon[coi] == null) {
3517                  sGlobalSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
3518                          R.id.search_button, activityName, R.drawable.ic_home_search_normal_holo,
3519                          TOOLBAR_ICON_METADATA_NAME);
3520              }
3521  
3522              if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.VISIBLE);
3523              searchButton.setVisibility(View.VISIBLE);
3524              invalidatePressedFocusedStates(searchButtonContainer, searchButton);
3525              return true;
3526          } else {
3527              // We disable both search and voice search when there is no global search provider
3528              if (searchButtonContainer != null) searchButtonContainer.setVisibility(View.GONE);
3529              if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
3530              if (searchButton != null) searchButton.setVisibility(View.GONE);
3531              if (voiceButton != null) voiceButton.setVisibility(View.GONE);
3532              updateVoiceButtonProxyVisible(false);
3533              return false;
3534          }
3535      }
3536  
3537      protected void updateGlobalSearchIcon(Drawable.ConstantState d) {
3538          final View searchButtonContainer = findViewById(R.id.search_button_container);
3539          final View searchButton = (ImageView) findViewById(R.id.search_button);
3540          updateButtonWithDrawable(R.id.search_button, d);
3541          invalidatePressedFocusedStates(searchButtonContainer, searchButton);
3542      }
3543  
3544      protected boolean updateVoiceSearchIcon(boolean searchVisible) {
3545          final View voiceButtonContainer = findViewById(R.id.voice_button_container);
3546          final View voiceButton = findViewById(R.id.voice_button);
3547  
3548          // We only show/update the voice search icon if the search icon is enabled as well
3549          final SearchManager searchManager =
3550                  (SearchManager) getSystemService(Context.SEARCH_SERVICE);
3551          ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
3552  
3553          ComponentName activityName = null;
3554          if (globalSearchActivity != null) {
3555              // Check if the global search activity handles voice search
3556              Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
3557              intent.setPackage(globalSearchActivity.getPackageName());
3558              activityName = intent.resolveActivity(getPackageManager());
3559          }
3560  
3561          if (activityName == null) {
3562              // Fallback: check if an activity other than the global search activity
3563              // resolves this
3564              Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
3565              activityName = intent.resolveActivity(getPackageManager());
3566          }
3567          if (searchVisible &amp;&amp; activityName != null) {
3568              int coi = getCurrentOrientationIndexForGlobalIcons();
3569              sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
3570                      R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
3571                      TOOLBAR_VOICE_SEARCH_ICON_METADATA_NAME);
3572              if (sVoiceSearchIcon[coi] == null) {
3573                  sVoiceSearchIcon[coi] = updateButtonWithIconFromExternalActivity(
3574                          R.id.voice_button, activityName, R.drawable.ic_home_voice_search_holo,
3575                          TOOLBAR_ICON_METADATA_NAME);
3576              }
3577              if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.VISIBLE);
3578              voiceButton.setVisibility(View.VISIBLE);
3579              updateVoiceButtonProxyVisible(false);
3580              invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
3581              return true;
3582          } else {
3583              if (voiceButtonContainer != null) voiceButtonContainer.setVisibility(View.GONE);
3584              if (voiceButton != null) voiceButton.setVisibility(View.GONE);
3585              updateVoiceButtonProxyVisible(false);
3586              return false;
3587          }
3588      }
3589  
3590      protected void updateVoiceSearchIcon(Drawable.ConstantState d) {
3591          final View voiceButtonContainer = findViewById(R.id.voice_button_container);
3592          final View voiceButton = findViewById(R.id.voice_button);
3593          updateButtonWithDrawable(R.id.voice_button, d);
3594          invalidatePressedFocusedStates(voiceButtonContainer, voiceButton);
3595      }
3596  
3597      public void updateVoiceButtonProxyVisible(boolean forceDisableVoiceButtonProxy) {
3598          final View voiceButtonProxy = findViewById(R.id.voice_button_proxy);
3599          if (voiceButtonProxy != null) {
3600              boolean visible = !forceDisableVoiceButtonProxy &amp;&amp;
3601                      mWorkspace.shouldVoiceButtonProxyBeVisible();
3602              voiceButtonProxy.setVisibility(visible ? View.VISIBLE : View.GONE);
3603              voiceButtonProxy.bringToFront();
3604          }
3605      }
3606  
3607      /**
3608       * This is an overrid eot disable the voice button proxy.  If disabled is true, then the voice button proxy
3609       * will be hidden regardless of what shouldVoiceButtonProxyBeVisible() returns.
3610       */
3611      public void disableVoiceButtonProxy(boolean disabled) {
3612          updateVoiceButtonProxyVisible(disabled);
3613      }
3614      /**
3615       * Sets the app market icon
3616       */
3617      private void updateAppMarketIcon() {
3618          if (!DISABLE_MARKET_BUTTON) {
3619              final View marketButton = findViewById(R.id.market_button);
3620              Intent intent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_APP_MARKET);
3621              // Find the app market activity by resolving an intent.
3622              // (If multiple app markets are installed, it will return the ResolverActivity.)
3623              ComponentName activityName = intent.resolveActivity(getPackageManager());
3624              if (activityName != null) {
3625                  int coi = getCurrentOrientationIndexForGlobalIcons();
3626                  mAppMarketIntent = intent;
3627                  sAppMarketIcon[coi] = updateTextButtonWithIconFromExternalActivity(
3628                          R.id.market_button, activityName, R.drawable.ic_launcher_market_holo,
3629                          TOOLBAR_ICON_METADATA_NAME);
3630                  marketButton.setVisibility(View.VISIBLE);
3631              } else {
3632                  // We should hide and disable the view so that we don&#x27;t try and restore the visibility
3633                  // of it when we swap between drag &amp; normal states from IconDropTarget subclasses.
3634                  marketButton.setVisibility(View.GONE);
3635                  marketButton.setEnabled(false);
3636              }
3637          }
3638      }
3639  
3640      private void updateAppMarketIcon(Drawable.ConstantState d) {
3641          if (!DISABLE_MARKET_BUTTON) {
3642              // Ensure that the new drawable we are creating has the approprate toolbar icon bounds
3643              Resources r = getResources();
3644              Drawable marketIconDrawable = d.newDrawable(r);
3645              int w = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_width);
3646              int h = r.getDimensionPixelSize(R.dimen.toolbar_external_icon_height);
3647              marketIconDrawable.setBounds(0, 0, w, h);
3648  
3649              updateTextButtonWithDrawable(R.id.market_button, marketIconDrawable);
3650          }
3651      }
3652  
3653      @Override
3654      public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
3655          final boolean result = super.dispatchPopulateAccessibilityEvent(event);
3656          final List&lt;CharSequence&gt; text = event.getText();
3657          text.clear();
3658          // Populate event with a fake title based on the current state.
3659          if (mState == State.APPS_CUSTOMIZE) {
3660              text.add(mAppsCustomizeTabHost.getCurrentTabView().getContentDescription());

3661          } else {
3662              text.add(getString(R.string.all_apps_home_button_label));
3663          }
3664          return result;
3665      }
3666  
3667      /**
3668       * Receives notifications when system dialogs are to be closed.
3669       */
3670      private class CloseSystemDialogsIntentReceiver extends BroadcastReceiver {
3671          @Override
3672          public void onReceive(Context context, Intent intent) {
3673              closeSystemDialogs();
3674          }
3675      }
3676  
3677      /**
3678       * Receives notifications whenever the appwidgets are reset.
3679       */
3680      private class AppWidgetResetObserver extends ContentObserver {
3681          public AppWidgetResetObserver() {
3682              super(new Handler());
3683          }
3684  
3685          @Override
3686          public void onChange(boolean selfChange) {
3687              onAppWidgetReset();
3688          }
3689      }
3690  
3691      /**
3692       * If the activity is currently paused, signal that we need to run the passed Runnable
3693       * in onResume.
3694       *
3695       * This needs to be called from incoming places where resources might have been loaded
3696       * while we are paused.  That is becaues the Configuration might be wrong
3697       * when we&#x27;re not running, and if it comes back to what it was when we
3698       * were paused, we are not restarted.
3699       *
3700       * Implementation of the method from LauncherModel.Callbacks.
3701       *
3702       * @return true if we are currently paused.  The caller might be able to
3703       * skip some work in that case since we will come back again.
3704       */
3705      private boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) {
3706          if (mPaused) {
3707              Log.i(TAG, &quot;Deferring update until onResume&quot;);
3708              if (deletePreviousRunnables) {
3709                  while (mBindOnResumeCallbacks.remove(run)) {
3710                  }
3711              }
3712              mBindOnResumeCallbacks.add(run);
3713              return true;
3714          } else {
3715              return false;
3716          }
3717      }
3718  
3719      private boolean waitUntilResume(Runnable run) {
3720          return waitUntilResume(run, false);
3721      }
3722  
3723      public void addOnResumeCallback(Runnable run) {
3724          mOnResumeCallbacks.add(run);
3725      }
3726  
3727      /**
3728       * If the activity is currently paused, signal that we need to re-run the loader
3729       * in onResume.
3730       *
3731       * This needs to be called from incoming places where resources might have been loaded
3732       * while we are paused.  That is becaues the Configuration might be wrong
3733       * when we&#x27;re not running, and if it comes back to what it was when we
3734       * were paused, we are not restarted.
3735       *
3736       * Implementation of the method from LauncherModel.Callbacks.
3737       *
3738       * @return true if we are currently paused.  The caller might be able to
3739       * skip some work in that case since we will come back again.
3740       */
3741      public boolean setLoadOnResume() {
3742          if (mPaused) {
3743              Log.i(TAG, &quot;setLoadOnResume&quot;);
3744              mOnResumeNeedsLoad = true;
3745              return true;
3746          } else {
3747              return false;
3748          }
3749      }
3750  
3751      /**
3752       * Implementation of the method from LauncherModel.Callbacks.
3753       */
3754      public int getCurrentWorkspaceScreen() {
3755          if (mWorkspace != null) {
3756              return mWorkspace.getCurrentPage();
3757          } else {
3758              return SCREEN_COUNT / 2;
3759          }
3760      }
3761  
3762      /**
3763       * Refreshes the shortcuts shown on the workspace.
3764       *
3765       * Implementation of the method from LauncherModel.Callbacks.
3766       */
3767      public void startBinding() {


3768          // If we&#x27;re starting binding all over again, clear any bind calls we&#x27;d postponed in
3769          // the past (see waitUntilResume) -- we don&#x27;t need them since we&#x27;re starting binding
3770          // from scratch again
3771          mBindOnResumeCallbacks.clear();
3772  
3773          // Clear the workspace because it&#x27;s going to be rebound
3774          mWorkspace.clearDropTargets();
3775          mWorkspace.removeAllWorkspaceScreens();
3776  
3777          mWidgetsToAdvance.clear();
3778          if (mHotseat != null) {
3779              mHotseat.resetLayout();
3780          }
3781      }
3782  
3783      @Override
3784      public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
3785          bindAddScreens(orderedScreenIds);
3786  
3787          // If there are no screens, we need to have an empty screen
3788          if (orderedScreenIds.size() == 0) {
3789              mWorkspace.addExtraEmptyScreen();
3790          }
3791  
3792          // Create the custom content page (this call updates mDefaultScreen which calls
3793          // setCurrentPage() so ensure that all pages are added before calling this).
3794          // The actual content of the custom page will be added during onFinishBindingItems().
3795          if (!mWorkspace.hasCustomContent() &amp;&amp; hasCustomContentToLeft()) {
3796              mWorkspace.createCustomContentPage();



3797          }
3798      }
3799  
3800      @Override
3801      public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds) {
3802          // Log to disk
3803          Launcher.addDumpLog(TAG, &quot;11683562 - bindAddScreens()&quot;, true);
3804          Launcher.addDumpLog(TAG, &quot;11683562 -   orderedScreenIds: &quot; +
3805                  TextUtils.join(&quot;, &quot;, orderedScreenIds), true);
3806          int count = orderedScreenIds.size();
3807          for (int i = 0; i &lt; count; i++) {
3808              mWorkspace.insertNewWorkspaceScreenBeforeEmptyScreen(orderedScreenIds.get(i));
3809          }
3810      }
3811  
3812      private boolean shouldShowWeightWatcher() {
3813          String spKey = LauncherAppState.getSharedPreferencesKey();
3814          SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
3815          boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, SHOW_WEIGHT_WATCHER_DEFAULT);
3816  
3817          return show;
3818      }
3819  
3820      private void toggleShowWeightWatcher() {
3821          String spKey = LauncherAppState.getSharedPreferencesKey();
3822          SharedPreferences sp = getSharedPreferences(spKey, Context.MODE_PRIVATE);
3823          boolean show = sp.getBoolean(SHOW_WEIGHT_WATCHER, true);
3824  
3825          show = !show;
3826  
3827          SharedPreferences.Editor editor = sp.edit();
3828          editor.putBoolean(SHOW_WEIGHT_WATCHER, show);
3829          editor.commit();
3830  
3831          if (mWeightWatcher != null) {
3832              mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
3833          }
3834      }
3835  
3836      public void bindAppsAdded(final ArrayList&lt;Long&gt; newScreens,
3837                                final ArrayList&lt;ItemInfo&gt; addNotAnimated,
3838                                final ArrayList&lt;ItemInfo&gt; addAnimated,
3839                                final ArrayList&lt;AppInfo&gt; addedApps) {
3840          Runnable r = new Runnable() {
3841              public void run() {
3842                  bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
3843              }
3844          };
3845          if (waitUntilResume(r)) {
3846              return;
3847          }
3848  
3849          // Add the new screens
3850          bindAddScreens(newScreens);



3851  
3852          // We add the items without animation on non-visible pages, and with
3853          // animations on the new page (which we will try and snap to).
3854          if (!addNotAnimated.isEmpty()) {

3855              bindItems(addNotAnimated, 0,
3856                      addNotAnimated.size(), false);
3857          }
3858          if (!addAnimated.isEmpty()) {

3859              bindItems(addAnimated, 0,
3860                      addAnimated.size(), true);
3861          }
3862  
3863          // Remove the extra empty screen
3864          mWorkspace.removeExtraEmptyScreen(false, null);
3865  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3866 -        if (!AppsCustomizePagedView.DISABLE_ALL_APPS &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3867 +        if (!LauncherAppState.isDisableAllApps() &amp;&amp;</span>


3868                  addedApps != null &amp;&amp; mAppsCustomizeContent != null) {
3869              mAppsCustomizeContent.addApps(addedApps);
3870          }
3871      }
3872  
3873      /**
3874       * Bind the items start-end from the list.
3875       *
3876       * Implementation of the method from LauncherModel.Callbacks.
3877       */
3878      public void bindItems(final ArrayList&lt;ItemInfo&gt; shortcuts, final int start, final int end,
3879                            final boolean forceAnimateIcons) {
3880          Runnable r = new Runnable() {
3881              public void run() {
3882                  bindItems(shortcuts, start, end, forceAnimateIcons);
3883              }
3884          };
3885          if (waitUntilResume(r)) {
3886              return;
3887          }
3888  
3889          // Get the list of added shortcuts and intersect them with the set of shortcuts here
3890          final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
3891          final Collection&lt;Animator&gt; bounceAnims = new ArrayList&lt;Animator&gt;();
3892          final boolean animateIcons = forceAnimateIcons &amp;&amp; canRunNewAppsAnimation();
3893          Workspace workspace = mWorkspace;
3894          long newShortcutsScreenId = -1;
3895          for (int i = start; i &lt; end; i++) {
3896              final ItemInfo item = shortcuts.get(i);
3897  
3898              // Short circuit if we are loading dock items for a configuration which has no dock
3899              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
3900                      mHotseat == null) {
3901                  continue;
3902              }
3903  
3904              switch (item.itemType) {
3905                  case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3906                  case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3907                      ShortcutInfo info = (ShortcutInfo) item;
3908                      View shortcut = createShortcut(info);
3909  
3910                      /*
3911                       * TODO: FIX collision case
3912                       */
3913                      if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
3914                          CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
3915                          if (cl != null &amp;&amp; cl.isOccupied(item.cellX, item.cellY)) {
3916                              throw new RuntimeException(&quot;OCCUPIED&quot;);









3917                          }
3918                      }
3919  
3920                      workspace.addInScreenFromBind(shortcut, item.container, item.screenId, item.cellX,
3921                              item.cellY, 1, 1);
3922                      if (animateIcons) {
3923                          // Animate all the applications up now
3924                          shortcut.setAlpha(0f);
3925                          shortcut.setScaleX(0f);
3926                          shortcut.setScaleY(0f);
3927                          bounceAnims.add(createNewAppBounceAnimation(shortcut, i));
3928                          newShortcutsScreenId = item.screenId;
3929                      }
3930                      break;
3931                  case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3932                      FolderIcon newFolder = FolderIcon.fromXml(R.layout.folder_icon, this,
3933                              (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()),
3934                              (FolderInfo) item, mIconCache);
3935                      workspace.addInScreenFromBind(newFolder, item.container, item.screenId, item.cellX,
3936                              item.cellY, 1, 1);
3937                      break;
3938                  default:
3939                      throw new RuntimeException(&quot;Invalid Item Type&quot;);
3940              }
3941          }
3942  
3943          if (animateIcons) {
3944              // Animate to the correct page
3945              if (newShortcutsScreenId &gt; -1) {
3946                  long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
3947                  final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
3948                  final Runnable startBounceAnimRunnable = new Runnable() {
3949                      public void run() {
3950                          anim.playTogether(bounceAnims);
3951                          anim.start();
3952                      }
3953                  };
3954                  if (newShortcutsScreenId != currentScreenId) {
3955                      // We post the animation slightly delayed to prevent slowdowns
3956                      // when we are loading right after we return to launcher.
3957                      mWorkspace.postDelayed(new Runnable() {
3958                          public void run() {
3959                              mWorkspace.snapToPage(newScreenIndex);
3960                              mWorkspace.postDelayed(startBounceAnimRunnable,
3961                                      NEW_APPS_ANIMATION_DELAY);





3962                          }
3963                      }, NEW_APPS_PAGE_MOVE_DELAY);
3964                  } else {
3965                      mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
3966                  }
3967              }
3968          }
3969          workspace.requestLayout();
3970      }
3971  
3972      /**
3973       * Implementation of the method from LauncherModel.Callbacks.
3974       */
3975      public void bindFolders(final HashMap&lt;Long, FolderInfo&gt; folders) {
3976          Runnable r = new Runnable() {
3977              public void run() {
3978                  bindFolders(folders);
3979              }
3980          };
3981          if (waitUntilResume(r)) {
3982              return;
3983          }
3984          sFolders.clear();
3985          sFolders.putAll(folders);
3986      }
3987  
3988      /**
3989       * Add the views for a widget to the workspace.
3990       *
3991       * Implementation of the method from LauncherModel.Callbacks.
3992       */
3993      public void bindAppWidget(final LauncherAppWidgetInfo item) {
3994          Runnable r = new Runnable() {
3995              public void run() {
3996                  bindAppWidget(item);
3997              }
3998          };
3999          if (waitUntilResume(r)) {
4000              return;
4001          }
4002  
4003          final long start = DEBUG_WIDGETS ? SystemClock.uptimeMillis() : 0;
4004          if (DEBUG_WIDGETS) {
4005              Log.d(TAG, &quot;bindAppWidget: &quot; + item);
4006          }
4007          final Workspace workspace = mWorkspace;
4008  
4009          final int appWidgetId = item.appWidgetId;
4010          final AppWidgetProviderInfo appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(appWidgetId);
4011          if (DEBUG_WIDGETS) {
<abbr title="4012              Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.provider);">4012              Log.d(TAG, &quot;bindAppWidget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + appWidgetInfo.provider🔵</abbr>
4013          }
4014  
4015          item.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);




































































4016  
4017          item.hostView.setTag(item);
4018          item.onBindAppWidget(this);
4019  
4020          workspace.addInScreen(item.hostView, item.container, item.screenId, item.cellX,
4021                  item.cellY, item.spanX, item.spanY, false);
4022          addWidgetToAutoAdvanceIfNeeded(item.hostView, appWidgetInfo);
4023  
4024          workspace.requestLayout();
4025  
4026          if (DEBUG_WIDGETS) {
4027              Log.d(TAG, &quot;bound widget id=&quot;+item.appWidgetId+&quot; in &quot;
4028                      + (SystemClock.uptimeMillis()-start) + &quot;ms&quot;);
4029          }




















4030      }
4031  
4032      public void onPageBoundSynchronously(int page) {
4033          mSynchronouslyBoundPages.add(page);
4034      }
4035  
4036      /**
4037       * Callback saying that there aren&#x27;t any more items to bind.
4038       *
4039       * Implementation of the method from LauncherModel.Callbacks.
4040       */
4041      public void finishBindingItems(final boolean upgradePath) {
4042          Runnable r = new Runnable() {
4043              public void run() {
4044                  finishBindingItems(upgradePath);
4045              }
4046          };
4047          if (waitUntilResume(r)) {
4048              return;
4049          }
4050          if (mSavedState != null) {
4051              if (!mWorkspace.hasFocus()) {
4052                  mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
4053              }
4054              mSavedState = null;
4055          }
4056  
4057          mWorkspace.restoreInstanceStateForRemainingPages();
4058  



4059          // If we received the result of any pending adds while the loader was running (e.g. the
4060          // widget configuration forced an orientation change), process them now.
4061          for (int i = 0; i &lt; sPendingAddList.size(); i++) {
4062              completeAdd(sPendingAddList.get(i));
4063          }
4064          sPendingAddList.clear();
4065  
4066          // Update the market app icon as necessary (the other icons will be managed in response to
4067          // package changes in bindSearchablesChanged()
4068          if (!DISABLE_MARKET_BUTTON) {
4069              updateAppMarketIcon();
4070          }
4071  
4072          mWorkspaceLoading = false;















4073          if (upgradePath) {
4074              mWorkspace.getUniqueComponents(true, null);
4075              mIntentsOnWorkspaceFromUpgradePath = mWorkspace.getUniqueComponents(true, null);
4076          }
4077  
4078          mWorkspace.post(new Runnable() {
4079              @Override
4080              public void run() {
4081                  onFinishBindingItems();
4082              }
4083          });














4084      }
4085  
4086      public boolean isAllAppsButtonRank(int rank) {
4087          if (mHotseat != null) {
4088              return mHotseat.isAllAppsButtonRank(rank);
4089          }
4090          return false;
4091      }
4092  
4093      private boolean canRunNewAppsAnimation() {
4094          long diff = System.currentTimeMillis() - mDragController.getLastGestureUpTime();
4095          return diff &gt; (NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS * 1000);
4096      }
4097  
4098      private ValueAnimator createNewAppBounceAnimation(View v, int i) {
4099          ValueAnimator bounceAnim = LauncherAnimUtils.ofPropertyValuesHolder(v,
4100                  PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1f),
4101                  PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1f),
4102                  PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f));
4103          bounceAnim.setDuration(InstallShortcutReceiver.NEW_SHORTCUT_BOUNCE_DURATION);
4104          bounceAnim.setStartDelay(i * InstallShortcutReceiver.NEW_SHORTCUT_STAGGER_DELAY);
4105          bounceAnim.setInterpolator(new SmoothPagedView.OvershootInterpolator());
4106          return bounceAnim;
4107      }
4108  
4109      public boolean useVerticalBarLayout() {
4110          return LauncherAppState.getInstance().getDynamicGrid().
4111                  getDeviceProfile().isVerticalBarLayout();
4112      }
4113  
4114      protected Rect getSearchBarBounds() {
4115          return LauncherAppState.getInstance().getDynamicGrid().
4116                  getDeviceProfile().getSearchBarBounds();
4117      }
4118  
4119      @Override
4120      public void bindSearchablesChanged() {
4121          boolean searchVisible = updateGlobalSearchIcon();
4122          boolean voiceVisible = updateVoiceSearchIcon(searchVisible);
4123          if (mSearchDropTargetBar != null) {
4124              mSearchDropTargetBar.onSearchPackagesChanged(searchVisible, voiceVisible);
4125          }
4126      }
4127  
4128      /**
4129       * Add the icons for all apps.
4130       *
4131       * Implementation of the method from LauncherModel.Callbacks.
4132       */
4133      public void bindAllApplications(final ArrayList&lt;AppInfo&gt; apps) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4134 -        if (AppsCustomizePagedView.DISABLE_ALL_APPS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4135 +        if (LauncherAppState.isDisableAllApps()) {</span>
4136              if (mIntentsOnWorkspaceFromUpgradePath != null) {
4137                  if (LauncherModel.UPGRADE_USE_MORE_APPS_FOLDER) {
4138                      getHotseat().addAllAppsFolder(mIconCache, apps,
4139                              mIntentsOnWorkspaceFromUpgradePath, Launcher.this, mWorkspace);
4140                  }
4141                  mIntentsOnWorkspaceFromUpgradePath = null;
4142              }
4143              if (mAppsCustomizeContent != null) {
4144                  mAppsCustomizeContent.onPackagesUpdated(
4145                          LauncherModel.getSortedWidgetsAndShortcuts(this));
4146              }
4147          } else {
4148              if (mAppsCustomizeContent != null) {
4149                  mAppsCustomizeContent.setApps(apps);
4150                  mAppsCustomizeContent.onPackagesUpdated(
4151                          LauncherModel.getSortedWidgetsAndShortcuts(this));
4152              }
4153          }
4154      }
4155  
4156      /**
4157       * A package was updated.
4158       *
4159       * Implementation of the method from LauncherModel.Callbacks.
4160       */
4161      public void bindAppsUpdated(final ArrayList&lt;AppInfo&gt; apps) {
4162          Runnable r = new Runnable() {
4163              public void run() {
4164                  bindAppsUpdated(apps);
4165              }
4166          };
4167          if (waitUntilResume(r)) {
4168              return;
4169          }
4170  
4171          if (mWorkspace != null) {
4172              mWorkspace.updateShortcuts(apps);
4173          }
4174  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4175 -        if (!AppsCustomizePagedView.DISABLE_ALL_APPS &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4176 +        if (!LauncherAppState.isDisableAllApps() &amp;&amp;</span>



4177                  mAppsCustomizeContent != null) {
4178              mAppsCustomizeContent.updateApps(apps);










































4179          }
4180      }
4181  
4182      /**
4183       * A package was uninstalled.  We take both the super set of packageNames
4184       * in addition to specific applications to remove, the reason being that
4185       * this can be called when a package is updated as well.  In that scenario,
4186       * we only remove specific components from the workspace, where as
4187       * package-removal should clear all items by package name.
4188       *
4189       * Implementation of the method from LauncherModel.Callbacks.
4190       */
4191      public void bindComponentsRemoved(final ArrayList&lt;String&gt; packageNames,
4192                                        final ArrayList&lt;AppInfo&gt; appInfos) {

4193          Runnable r = new Runnable() {
4194              public void run() {
4195                  bindComponentsRemoved(packageNames, appInfos);

4196              }
4197          };
4198          if (waitUntilResume(r)) {
4199              return;
4200          }
4201  
4202          if (!packageNames.isEmpty()) {
4203              mWorkspace.removeItemsByPackageName(packageNames);

4204          }
4205          if (!appInfos.isEmpty()) {
4206              mWorkspace.removeItemsByApplicationInfo(appInfos);

4207          }
4208  
4209          // Notify the drag controller
4210          mDragController.onAppsRemoved(packageNames, appInfos);
4211  
4212          // Update AllApps
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4213 -        if (!AppsCustomizePagedView.DISABLE_ALL_APPS &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4214 +        if (!LauncherAppState.isDisableAllApps() &amp;&amp;</span>
4215                  mAppsCustomizeContent != null) {
4216              mAppsCustomizeContent.removeApps(appInfos);
4217          }
4218      }
4219  
4220      /**
4221       * A number of packages were updated.
4222       */
4223      private ArrayList&lt;Object&gt; mWidgetsAndShortcuts;
4224      private Runnable mBindPackagesUpdatedRunnable = new Runnable() {
4225              public void run() {
4226                  bindPackagesUpdated(mWidgetsAndShortcuts);
4227                  mWidgetsAndShortcuts = null;
4228              }
4229          };
4230      public void bindPackagesUpdated(final ArrayList&lt;Object&gt; widgetsAndShortcuts) {
4231          if (waitUntilResume(mBindPackagesUpdatedRunnable, true)) {
4232              mWidgetsAndShortcuts = widgetsAndShortcuts;
4233              return;
4234          }
4235  
4236          // Update the widgets pane
4237          if (mAppsCustomizeContent != null) {
4238              mAppsCustomizeContent.onPackagesUpdated(widgetsAndShortcuts);
4239          }
4240      }
4241  
4242      private int mapConfigurationOriActivityInfoOri(int configOri) {
4243          final Display d = getWindowManager().getDefaultDisplay();
4244          int naturalOri = Configuration.ORIENTATION_LANDSCAPE;
4245          switch (d.getRotation()) {
4246          case Surface.ROTATION_0:
4247          case Surface.ROTATION_180:
4248              // We are currently in the same basic orientation as the natural orientation
4249              naturalOri = configOri;
4250              break;
4251          case Surface.ROTATION_90:
4252          case Surface.ROTATION_270:
4253              // We are currently in the other basic orientation to the natural orientation
4254              naturalOri = (configOri == Configuration.ORIENTATION_LANDSCAPE) ?
4255                      Configuration.ORIENTATION_PORTRAIT : Configuration.ORIENTATION_LANDSCAPE;
4256              break;
4257          }
4258  
4259          int[] oriMap = {
4260                  ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
4261                  ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE,
4262                  ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
4263                  ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
4264          };
4265          // Since the map starts at portrait, we need to offset if this device&#x27;s natural orientation
4266          // is landscape.
4267          int indexOffset = 0;
4268          if (naturalOri == Configuration.ORIENTATION_LANDSCAPE) {
4269              indexOffset = 1;
4270          }
4271          return oriMap[(d.getRotation() + indexOffset) % 4];
4272      }
4273  
4274      public boolean isRotationEnabled() {
4275          boolean enableRotation = sForceEnableRotation ||
4276                  getResources().getBoolean(R.bool.allow_rotation);
4277          return enableRotation;
4278      }
4279      public void lockScreenOrientation() {
4280          if (isRotationEnabled()) {
4281              setRequestedOrientation(mapConfigurationOriActivityInfoOri(getResources()
4282                      .getConfiguration().orientation));
4283          }
4284      }
4285      public void unlockScreenOrientation(boolean immediate) {
4286          if (isRotationEnabled()) {
4287              if (immediate) {
4288                  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
4289              } else {
4290                  mHandler.postDelayed(new Runnable() {
4291                      public void run() {
4292                          setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
4293                      }
4294                  }, mRestoreScreenOrientationDelay);
4295              }
4296          }
4297      }
4298  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4299 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4300 +     * Called when the SearchBar hint should be changed.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4301 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4302 +     * @param hint the hint to be displayed in the search bar.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4303 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4304 +    protected void onSearchBarHintChanged(String hint) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4305 +        mLauncherClings.updateSearchBarHint(hint);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4306 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4307 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4308 +    protected boolean isLauncherPreinstalled() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4309 +        PackageManager pm = getPackageManager();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4310 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4311 +            ApplicationInfo ai = pm.getApplicationInfo(getComponentName().getPackageName(), 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4312 +            if ((ai.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4313 +                return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4314 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4315 +                return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4316 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4317 +        } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4318 +            e.printStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4319 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4320 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4321 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4322 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4323 +    protected String getFirstRunClingSearchBarHint() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4324 +        return &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4325 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4326 +    protected String getFirstRunCustomContentHint() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4327 +        return &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4328 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4329 +    protected int getFirstRunFocusedHotseatAppDrawableId() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4330 +        return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4331 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4332 +    protected ComponentName getFirstRunFocusedHotseatAppComponentName() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4333 +        return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4334 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4335 +    protected int getFirstRunFocusedHotseatAppRank() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4336 +        return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4337 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4338 +    protected String getFirstRunFocusedHotseatAppBubbleTitle() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4339 +        return &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4340 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4341 +    protected String getFirstRunFocusedHotseatAppBubbleDescription() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4342 +        return &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4343 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4344 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4345 +    public void dismissFirstRunCling(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4346 +        mLauncherClings.dismissFirstRunCling(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4347 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4348 +    public void dismissMigrationClingCopyApps(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4349 +        mLauncherClings.dismissMigrationClingCopyApps(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4350 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4351 +    public void dismissMigrationClingUseDefault(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4352 +        mLauncherClings.dismissMigrationClingUseDefault(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4353 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4354 +    public void dismissMigrationWorkspaceCling(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4355 +        mLauncherClings.dismissMigrationWorkspaceCling(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4356 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4357 +    public void dismissWorkspaceCling(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4358 +        mLauncherClings.dismissWorkspaceCling(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4359 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4360 +    public void dismissFolderCling(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4361 +        mLauncherClings.dismissFolderCling(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4362 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4363 +</span>







4364      private boolean shouldRunFirstRunActivity() {
4365          return !ActivityManager.isRunningInTestHarness();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4366 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4367 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4368 -    /* Cling related */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4369 -    private boolean isClingsEnabled() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4370 -        if (DISABLE_CLINGS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4371 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4372 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4373 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4374 -        // For now, limit only to phones</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4375 -        LauncherAppState app = LauncherAppState.getInstance();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4376 -        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4377 -        if (grid.isTablet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4378 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4379 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4380 -        if (grid.isLandscape) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4381 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4382 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4383 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4384 -        // disable clings when running in a test harness</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4385 -        if(ActivityManager.isRunningInTestHarness()) return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4386 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4387 -        // Disable clings for accessibility when explore by touch is enabled</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4388 -        final AccessibilityManager a11yManager = (AccessibilityManager) getSystemService(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4389 -                ACCESSIBILITY_SERVICE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4390 -        if (a11yManager.isTouchExplorationEnabled()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4391 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4392 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4393 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4394 -        // Restricted secondary users (child mode) will potentially have very few apps</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4395 -        // seeded when they start up for the first time. Clings won&#x27;t work well with that</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4396 -//        boolean supportsLimitedUsers =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4397 -//                android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4398 -//        Account[] accounts = AccountManager.get(this).getAccounts();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4399 -//        if (supportsLimitedUsers &amp;&amp; accounts.length == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4400 -//            UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4401 -//            Bundle restrictions = um.getUserRestrictions();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4402 -//            if (restrictions.getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS, false)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4403 -//               return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4404 -//            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4405 -//        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4406 -        return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4407 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4408 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4409 -    private Cling initCling(int clingId, int scrimId, boolean animate,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4410 -                            boolean dimNavBarVisibilty) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4411 -        Cling cling = (Cling) findViewById(clingId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4412 -        View scrim = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4413 -        if (scrimId &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4414 -            scrim = findViewById(R.id.cling_scrim);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4415 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4416 -        if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4417 -            cling.init(this, scrim);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4418 -            cling.show(animate, SHOW_CLING_DURATION);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4419 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4420 -            if (dimNavBarVisibilty) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4421 -                cling.setSystemUiVisibility(cling.getSystemUiVisibility() |</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4422 -                        View.SYSTEM_UI_FLAG_LOW_PROFILE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4423 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4424 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4425 -        return cling;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4426 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4427 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4428 -    private void dismissCling(final Cling cling, final Runnable postAnimationCb,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4429 -                              final String flag, int duration, boolean restoreNavBarVisibilty) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4430 -        // To catch cases where siblings of top-level views are made invisible, just check whether</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4431 -        // the cling is directly set to GONE before dismissing it.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4432 -        if (cling != null &amp;&amp; cling.getVisibility() != View.GONE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4433 -            final Runnable cleanUpClingCb = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4434 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4435 -                    cling.cleanup();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4436 -                    SharedPreferences.Editor editor = mSharedPrefs.edit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4437 -                    editor.putBoolean(flag, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4438 -                    editor.apply();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4439 -                    if (postAnimationCb != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4440 -                        postAnimationCb.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4441 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4442 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4443 -            };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4444 -            if (duration &lt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4445 -                cleanUpClingCb.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4446 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4447 -                cling.hide(duration, cleanUpClingCb);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4448 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4449 -            mHideFromAccessibilityHelper.restoreImportantForAccessibility(mDragLayer);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4450 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4451 -            if (restoreNavBarVisibilty) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4452 -                cling.setSystemUiVisibility(cling.getSystemUiVisibility() &amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4453 -                        ~View.SYSTEM_UI_FLAG_LOW_PROFILE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4454 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4455 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4456 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4457 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4458 -    private void removeCling(int id) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4459 -        final View cling = findViewById(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4460 -        if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4461 -            final ViewGroup parent = (ViewGroup) cling.getParent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4462 -            parent.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4463 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4464 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4465 -                    parent.removeView(cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4466 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4467 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4468 -            mHideFromAccessibilityHelper.restoreImportantForAccessibility(mDragLayer);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4469 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4470 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4471 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4472 -    private boolean skipCustomClingIfNoAccounts() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4473 -        Cling cling = (Cling) findViewById(R.id.workspace_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4474 -        boolean customCling = cling.getDrawIdentifier().equals(&quot;workspace_custom&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4475 -        if (customCling) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4476 -            AccountManager am = AccountManager.get(this);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4477 -            if (am == null) return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4478 -            Account[] accounts = am.getAccountsByType(&quot;com.google&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4479 -            return accounts.length == 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4480 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4481 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4482 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4483 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4484 -    public void updateCustomContentHintVisibility() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4485 -        Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4486 -        String ccHintStr = getFirstRunCustomContentHint();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4487 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4488 -        if (mWorkspace.hasCustomContent()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4489 -            // Show the custom content hint if ccHintStr is not empty</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4490 -            if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4491 -                setCustomContentHintVisibility(cling, ccHintStr, true, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4492 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4493 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4494 -            // Hide the custom content hint</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4495 -            if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4496 -                setCustomContentHintVisibility(cling, ccHintStr, false, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4497 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4498 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4499 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4500 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4501 -    private void setCustomContentHintVisibility(Cling cling, String ccHintStr, boolean visible,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4502 -                                                boolean animate) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4503 -        final TextView ccHint = (TextView) cling.findViewById(R.id.custom_content_hint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4504 -        if (ccHint != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4505 -            if (visible &amp;&amp; !ccHintStr.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4506 -                ccHint.setText(ccHintStr);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4507 -                ccHint.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4508 -                if (animate) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4509 -                    ccHint.setAlpha(0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4510 -                    ccHint.animate().alpha(1f)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4511 -                                    .setDuration(SHOW_CLING_DURATION)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4512 -                                    .start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4513 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4514 -                    ccHint.setAlpha(1f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4515 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4516 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4517 -                if (animate) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4518 -                    ccHint.animate().alpha(0f)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4519 -                                    .setDuration(SHOW_CLING_DURATION)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4520 -                                    .setListener(new AnimatorListenerAdapter() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4521 -                                        @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4522 -                                        public void onAnimationEnd(Animator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4523 -                                            ccHint.setVisibility(View.GONE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4524 -                                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4525 -                                    })</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4526 -                                    .start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4527 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4528 -                    ccHint.setAlpha(0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4529 -                    ccHint.setVisibility(View.GONE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4530 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4531 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4532 -        }</span>
4533      }
4534  
4535      public void showFirstRunActivity() {
4536          if (shouldRunFirstRunActivity() &amp;&amp; hasFirstRunActivity()
4537                  &amp;&amp; !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false)) {











4538              Intent firstRunIntent = getFirstRunActivity();
4539              if (firstRunIntent != null) {
4540                  startActivity(firstRunIntent);
4541                  markFirstRunActivityShown();
4542              }
4543          }




4544      }
4545  
4546      private void markFirstRunActivityShown() {
4547          SharedPreferences.Editor editor = mSharedPrefs.edit();
4548          editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);
4549          editor.apply();
4550      }
4551  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4552 -    public void showFirstRunCling() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4553 -        if (isClingsEnabled() &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4554 -                !mSharedPrefs.getBoolean(Cling.FIRST_RUN_CLING_DISMISSED_KEY, false) &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4555 -                !skipCustomClingIfNoAccounts() ) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4556 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4557 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4558 -            // If we&#x27;re not using the default workspace layout, replace workspace cling</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4559 -            // with a custom workspace cling (usually specified in an overlay)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4560 -            // For now, only do this on tablets</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4561 -            if (!DISABLE_CUSTOM_CLINGS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4562 -                if (mSharedPrefs.getInt(LauncherProvider.DEFAULT_WORKSPACE_RESOURCE_ID, 0) != 0 &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4563 -                        getResources().getBoolean(R.bool.config_useCustomClings)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4564 -                    // Use a custom cling</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4565 -                    View cling = findViewById(R.id.workspace_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4566 -                    ViewGroup clingParent = (ViewGroup) cling.getParent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4567 -                    int clingIndex = clingParent.indexOfChild(cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4568 -                    clingParent.removeViewAt(clingIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4569 -                    View customCling = mInflater.inflate(R.layout.custom_workspace_cling, clingParent, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4570 -                    clingParent.addView(customCling, clingIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4571 -                    customCling.setId(R.id.workspace_cling);</span>










































<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4572 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4573 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4574 -            Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4575 -            if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4576 -                String sbHintStr = getFirstRunClingSearchBarHint();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4577 -                String ccHintStr = getFirstRunCustomContentHint();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4578 -                if (!sbHintStr.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4579 -                    TextView sbHint = (TextView) cling.findViewById(R.id.search_bar_hint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4580 -                    sbHint.setText(sbHintStr);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4581 -                    sbHint.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4582 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4583 -                setCustomContentHintVisibility(cling, ccHintStr, true, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4584 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4585 -            initCling(R.id.first_run_cling, 0, false, true);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4586 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4587 -            removeCling(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4588 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4589 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4590 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4591 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4592 -     * Called when the SearchBar hint should be changed.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4593 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4594 -     * @param hint the hint to be displayed in the search bar.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4595 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4596 -    protected void onSearchBarHintChanged(String hint) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4597 -        Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4598 -        if (cling != null &amp;&amp; cling.getVisibility() == View.VISIBLE &amp;&amp; !hint.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4599 -            TextView sbHint = (TextView) cling.findViewById(R.id.search_bar_hint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4600 -            sbHint.setText(hint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4601 -            sbHint.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4602 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4603 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4604 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4605 -    protected String getFirstRunClingSearchBarHint() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4606 -        return &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4607 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4608 -    protected String getFirstRunCustomContentHint() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4609 -        return &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4610 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4611 -    protected int getFirstRunFocusedHotseatAppDrawableId() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4612 -        return -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4613 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4614 -    protected ComponentName getFirstRunFocusedHotseatAppComponentName() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4615 -        return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4616 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4617 -    protected int getFirstRunFocusedHotseatAppRank() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4618 -        return -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4619 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4620 -    protected String getFirstRunFocusedHotseatAppBubbleTitle() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4621 -        return &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4622 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4623 -    protected String getFirstRunFocusedHotseatAppBubbleDescription() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4624 -        return &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4625 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4626 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4627 -    public void showFirstRunWorkspaceCling() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4628 -        // Enable the clings only if they have not been dismissed before</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4629 -        if (isClingsEnabled() &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4630 -                !mSharedPrefs.getBoolean(Cling.WORKSPACE_CLING_DISMISSED_KEY, false)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4631 -            Cling c = initCling(R.id.workspace_cling, 0, false, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4632 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4633 -            // Set the focused hotseat app if there is one</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4634 -            c.setFocusedHotseatApp(getFirstRunFocusedHotseatAppDrawableId(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4635 -                    getFirstRunFocusedHotseatAppRank(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4636 -                    getFirstRunFocusedHotseatAppComponentName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4637 -                    getFirstRunFocusedHotseatAppBubbleTitle(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4638 -                    getFirstRunFocusedHotseatAppBubbleDescription());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4639 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4640 -            removeCling(R.id.workspace_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4641 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4642 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4643 -    public Cling showFirstRunFoldersCling() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4644 -        // Enable the clings only if they have not been dismissed before</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4645 -        if (isClingsEnabled() &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4646 -                !mSharedPrefs.getBoolean(Cling.FOLDER_CLING_DISMISSED_KEY, false)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4647 -            Cling cling = initCling(R.id.folder_cling, R.id.cling_scrim,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4648 -                    true, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4649 -            return cling;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4650 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4651 -            removeCling(R.id.folder_cling);</span>















































<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4652 -            return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4653 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4654 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4655 -    protected SharedPreferences getSharedPrefs() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4656 -        return mSharedPrefs;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4657 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4658 -    public boolean isFolderClingVisible() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4659 -        Cling cling = (Cling) findViewById(R.id.folder_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4660 -        if (cling != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4661 -            return cling.getVisibility() == View.VISIBLE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4662 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4663 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4664 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4665 -    public void dismissFirstRunCling(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4666 -        Cling cling = (Cling) findViewById(R.id.first_run_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4667 -        Runnable cb = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4668 -            public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4669 -                // Show the workspace cling next</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4670 -                showFirstRunWorkspaceCling();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4671 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4672 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4673 -        dismissCling(cling, cb, Cling.FIRST_RUN_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4674 -                DISMISS_CLING_DURATION, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4675 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4676 -        // Fade out the search bar for the workspace cling coming up</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4677 -        mSearchDropTargetBar.hideSearchBar(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4678 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4679 -    public void dismissWorkspaceCling(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4680 -        Cling cling = (Cling) findViewById(R.id.workspace_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4681 -        Runnable cb = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4682 -        if (v == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4683 -            cb = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4684 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4685 -                    mWorkspace.enterOverviewMode();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4686 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4687 -            };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4688 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4689 -        dismissCling(cling, cb, Cling.WORKSPACE_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4690 -                DISMISS_CLING_DURATION, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4691 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4692 -        // Fade in the search bar</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4693 -        mSearchDropTargetBar.showSearchBar(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4694 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4695 -    public void dismissFolderCling(View v) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4696 -        Cling cling = (Cling) findViewById(R.id.folder_cling);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4697 -        dismissCling(cling, null, Cling.FOLDER_CLING_DISMISSED_KEY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4698 -                DISMISS_CLING_DURATION, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4699 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4700 +    void showWorkspaceSearchAndHotseat() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4701 +        mWorkspace.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4702 +        mHotseat.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4703 +        mPageIndicators.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4704 +        mSearchDropTargetBar.showSearchBar(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4705 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4706 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4707 +    void hideWorkspaceSearchAndHotseat() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4708 +        mWorkspace.setAlpha(0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4709 +        mHotseat.setAlpha(0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4710 +        mPageIndicators.setAlpha(0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4711 +        mSearchDropTargetBar.hideSearchBar(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4712 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4713 +</span>
4714  
4715      public ItemInfo createAppDragInfo(Intent appLaunchIntent) {
4716          ResolveInfo ri = getPackageManager().resolveActivity(appLaunchIntent, 0);
4717          if (ri == null) {
4718              return null;
4719          }
4720          return new AppInfo(getPackageManager(), ri, mIconCache, null);

4721      }
4722  
4723      public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
4724              Bitmap icon) {
4725          return new ShortcutInfo(shortcutIntent, caption, icon);














4726      }
4727  
4728      public void startDrag(View dragView, ItemInfo dragInfo, DragSource source) {
4729          dragView.setTag(dragInfo);
4730          mWorkspace.onDragStartedWithItem(dragView);
4731          mWorkspace.beginDragShared(dragView, source);






4732      }
4733  
4734      /**
4735       * Prints out out state for debugging.
4736       */
4737      public void dumpState() {
4738          Log.d(TAG, &quot;BEGIN launcher3 dump state for launcher &quot; + this);
4739          Log.d(TAG, &quot;mSavedState=&quot; + mSavedState);
4740          Log.d(TAG, &quot;mWorkspaceLoading=&quot; + mWorkspaceLoading);
4741          Log.d(TAG, &quot;mRestoring=&quot; + mRestoring);
4742          Log.d(TAG, &quot;mWaitingForResult=&quot; + mWaitingForResult);
4743          Log.d(TAG, &quot;mSavedInstanceState=&quot; + mSavedInstanceState);
4744          Log.d(TAG, &quot;sFolders.size=&quot; + sFolders.size());
4745          mModel.dumpState();
4746  
4747          if (mAppsCustomizeContent != null) {
4748              mAppsCustomizeContent.dumpState();
4749          }
4750          Log.d(TAG, &quot;END launcher3 dump state&quot;);
4751      }
4752  
4753      @Override
4754      public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
4755          super.dump(prefix, fd, writer, args);
4756          synchronized (sDumpLogs) {
4757              writer.println(&quot; &quot;);
4758              writer.println(&quot;Debug logs: &quot;);
4759              for (int i = 0; i &lt; sDumpLogs.size(); i++) {
4760                  writer.println(&quot;  &quot; + sDumpLogs.get(i));
4761              }
4762          }
4763      }
4764  
4765      public static void dumpDebugLogsToConsole() {
4766          if (DEBUG_DUMP_LOG) {
4767              synchronized (sDumpLogs) {
4768                  Log.d(TAG, &quot;&quot;);
4769                  Log.d(TAG, &quot;*********************&quot;);
4770                  Log.d(TAG, &quot;Launcher debug logs: &quot;);
4771                  for (int i = 0; i &lt; sDumpLogs.size(); i++) {
4772                      Log.d(TAG, &quot;  &quot; + sDumpLogs.get(i));
4773                  }
4774                  Log.d(TAG, &quot;*********************&quot;);
4775                  Log.d(TAG, &quot;&quot;);
4776              }
4777          }
4778      }
4779  
4780      public static void addDumpLog(String tag, String log, boolean debugLog) {
4781          addDumpLog(tag, log, null, debugLog);
4782      }
4783  
4784      public static void addDumpLog(String tag, String log, Exception e, boolean debugLog) {
4785          if (debugLog) {
4786              if (e != null) {
4787                  Log.d(tag, log, e);
4788              } else {
4789                  Log.d(tag, log);
4790              }
4791          }
4792          if (DEBUG_DUMP_LOG) {
4793              sDateStamp.setTime(System.currentTimeMillis());
4794              synchronized (sDumpLogs) {
4795                  sDumpLogs.add(sDateFormat.format(sDateStamp) + &quot;: &quot; + tag + &quot;, &quot; + log
4796                      + (e == null ? &quot;&quot; : (&quot;, Exception: &quot; + e)));
4797              }
4798          }
4799      }
4800  
4801      public void dumpLogsToLocalData() {
4802          if (DEBUG_DUMP_LOG) {
4803              new AsyncTask&lt;Void, Void, Void&gt;() {
4804                  public Void doInBackground(Void ... args) {
4805                      boolean success = false;
4806                      sDateStamp.setTime(sRunStart);
4807                      String FILENAME = sDateStamp.getMonth() + &quot;-&quot;
4808                              + sDateStamp.getDay() + &quot;_&quot;
4809                              + sDateStamp.getHours() + &quot;-&quot;
4810                              + sDateStamp.getMinutes() + &quot;_&quot;
4811                              + sDateStamp.getSeconds() + &quot;.txt&quot;;
4812  
4813                      FileOutputStream fos = null;
4814                      File outFile = null;
4815                      try {
4816                          outFile = new File(getFilesDir(), FILENAME);
4817                          outFile.createNewFile();
4818                          fos = new FileOutputStream(outFile);
4819                      } catch (Exception e) {
4820                          e.printStackTrace();
4821                      }
4822                      if (fos != null) {
4823                          PrintWriter writer = new PrintWriter(fos);
4824  
4825                          writer.println(&quot; &quot;);
4826                          writer.println(&quot;Debug logs: &quot;);
4827                          synchronized (sDumpLogs) {
4828                              for (int i = 0; i &lt; sDumpLogs.size(); i++) {
4829                                  writer.println(&quot;  &quot; + sDumpLogs.get(i));
4830                              }
4831                          }
4832                          writer.close();
4833                      }
4834                      try {
4835                          if (fos != null) {
4836                              fos.close();
4837                              success = true;
4838                          }
4839                      } catch (IOException e) {
4840                          e.printStackTrace();
4841                      }
4842                      return null;
4843                  }
4844              }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
4845          }
4846      }
4847  }
4848  
4849  interface LauncherTransitionable {
4850      View getContent();
4851      void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace);
4852      void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace);
4853      void onLauncherTransitionStep(Launcher l, float t);
4854      void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace);
4855  }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4856 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4857 +interface DebugIntents {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4858 +    static final String DELETE_DATABASE = &quot;com.android.launcher3.action.DELETE_DATABASE&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4859 +    static final String MIGRATE_DATABASE = &quot;com.android.launcher3.action.MIGRATE_DATABASE&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4860 +}</span></pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            