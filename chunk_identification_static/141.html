<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>141</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    141
                    <a href="140.html">prev</a>
                    <a href="142.html">next</a>
                    <a href="141_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_962705190f65e71cd7922fc2e4bbdcc05cc33b63_Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;962705190f65e71cd7922fc2e4bbdcc05cc33b63:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;962705190f65e71cd7922fc2e4bbdcc05cc33b63^1:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;962705190f65e71cd7922fc2e4bbdcc05cc33b63^2:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;c6289aa6d474f6c1cadd75d353442a115070586d:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.ClipData;
   5 import android.content.ClipboardManager;
   6 import android.content.Context;
   7 import android.content.Intent;
   8 import android.database.Cursor;
   9 import android.graphics.drawable.Drawable;
  10 import android.net.Uri;
  11 import android.os.AsyncTask;
  12 import android.os.Bundle;
  13 import android.os.Handler;
  14 import android.text.Editable;
  15 import android.text.Layout;
  16 import android.text.Spanned;
  17 import android.text.TextWatcher;
  18 import android.text.style.RelativeSizeSpan;
  19 import android.text.style.URLSpan;
  20 import android.text.util.Linkify;
  21 import android.util.TypedValue;
  22 import android.view.LayoutInflater;
  23 import android.view.Menu;
  24 import android.view.MenuInflater;
  25 import android.view.MenuItem;
  26 import android.view.View;
  27 import android.view.ViewGroup;
  28 import android.view.ViewTreeObserver;
  29 import android.view.inputmethod.InputMethodManager;
  30 import android.webkit.WebView;
  31 import android.widget.CursorAdapter;
  32 import android.widget.LinearLayout;
  33 import android.widget.ScrollView;
  34 import android.widget.TextView;
  35 import android.widget.Toast;
  36 
  37 import androidx.annotation.NonNull;
  38 import androidx.appcompat.app.AppCompatActivity;
  39 import androidx.appcompat.view.ActionMode;
  40 import androidx.core.widget.NestedScrollView;
  41 import androidx.fragment.app.Fragment;
  42 import androidx.fragment.app.FragmentTransaction;
  43 
  44 import com.automattic.simplenote.analytics.AnalyticsTracker;
  45 import com.automattic.simplenote.models.Note;
  46 import com.automattic.simplenote.models.Tag;
  47 import com.automattic.simplenote.utils.AutoBullet;
  48 import com.automattic.simplenote.utils.ContextUtils;
  49 import com.automattic.simplenote.utils.DisplayUtils;
  50 import com.automattic.simplenote.utils.DrawableUtils;
  51 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  52 import com.automattic.simplenote.utils.NoteUtils;
  53 import com.automattic.simplenote.utils.PrefUtils;
  54 import com.automattic.simplenote.utils.SimplenoteLinkify;
  55 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  56 import com.automattic.simplenote.utils.SnackbarUtils;
  57 import com.automattic.simplenote.utils.SpaceTokenizer;
  58 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  59 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  60 import com.automattic.simplenote.utils.TextHighlighter;
  61 import com.automattic.simplenote.utils.ThemeUtils;
  62 import com.automattic.simplenote.utils.WidgetUtils;
  63 import com.automattic.simplenote.widgets.SimplenoteEditText;
  64 import com.google.android.material.snackbar.Snackbar;
  65 import com.simperium.client.Bucket;
  66 import com.simperium.client.BucketObjectMissingException;
  67 import com.simperium.client.Query;
  68 
  69 import java.lang.ref.WeakReference;
  70 import java.util.Calendar;
  71 
  72 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  73         TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  74         SimplenoteEditText.OnSelectionChangedListener,
  75         ShareBottomSheetDialog.ShareSheetListener,
  76         HistoryBottomSheetDialog.HistorySheetListener,
  77         InfoBottomSheetDialog.InfoSheetListener,
  78         SimplenoteEditText.OnCheckboxToggledListener {
  79 
  80     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  81     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
  82     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
  83     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
  84     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
  85     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
  86     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
  87     private static final int MAX_REVISIONS = 30;
  88     private static final int PUBLISH_TIMEOUT = 20000;
  89     private static final int HISTORY_TIMEOUT = 10000;
  90     private Note mNote;
  91     private final Runnable mAutoSaveRunnable = new Runnable() {
  92         @Override
  93         public void run() {
  94             saveAndSyncNote();
  95         }
  96     };
  97     private Bucket&lt;Note&gt; mNotesBucket;
  98     private View mRootView;
  99     private SimplenoteEditText mContentEditText;
 100     private TagsMultiAutoCompleteTextView mTagView;
 101     private Handler mAutoSaveHandler;
 102     private Handler mPublishTimeoutHandler;
 103     private Handler mHistoryTimeoutHandler;
 104     private LinearLayout mPlaceholderView;
 105     private CursorAdapter mAutocompleteAdapter;
 106     private boolean mIsLoadingNote;
 107     private boolean mIsMarkdownEnabled;
 108     private boolean mIsPreviewEnabled;
 109     private boolean mShouldScrollToSearchMatch;
 110     private ActionMode mActionMode;
 111     private MenuItem mViewLinkMenuItem;
 112     private String mLinkUrl;
 113     private String mLinkText;
 114     private MatchOffsetHighlighter mHighlighter;
 115     private Drawable mEmailIcon, mWebIcon, mMapIcon, mCallIcon;
 116     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 117     private String mMatchOffsets;
 118     private int mCurrentCursorPosition;
 119     private HistoryBottomSheetDialog mHistoryBottomSheet;
 120     // Hides the history bottom sheet if no revisions are loaded
 121     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 122         @Override
 123         public void run() {
 124             if (!isAdded()) {
 125                 return;
 126             }
 127 
 128             requireActivity().runOnUiThread(new Runnable() {
 129                 @Override
 130                 public void run() {
<abbr title=" 131                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 131                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 132                         mHistoryBottomSheet.dismiss();
 133                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 134                     }
 135                 }
 136             });
 137         }
 138     };
 139     private InfoBottomSheetDialog mInfoBottomSheet;
 140     private ShareBottomSheetDialog mShareBottomSheet;
 141     // Contextual action bar for dealing with links
 142     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 143         // Called when the action mode is created; startActionMode() was called
 144         @Override
 145         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 146             // Inflate a menu resource providing context menu items
 147             MenuInflater inflater = mode.getMenuInflater();
 148 
 149             if (inflater != null) {
 150                 inflater.inflate(R.menu.view_link, menu);
 151                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 152                 mode.setTitle(getString(R.string.link));
 153                 mode.setTitleOptionalHint(false);
 154 
 155                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 156             }
 157 
<abbr title=" 158             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 158             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.colðŸ”µ</abbr>
<abbr title=" 159             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 159             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireAcðŸ”µ</abbr>
 160             return true;
 161         }
 162 
 163         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 164         // may be called multiple times if the mode is invalidated.
 165         @Override
 166         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 167             return false; // Return false if nothing is done
 168         }
 169 
 170         // Called when the user selects a contextual menu item
 171         @Override
 172         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 173             switch (item.getItemId()) {
 174                 case R.id.menu_view_link:
 175                     if (mLinkUrl != null) {
 176                         try {
 177                             Uri uri = Uri.parse(mLinkUrl);
 178                             Intent i = new Intent(Intent.ACTION_VIEW);
 179                             i.setData(uri);
 180                             startActivity(i);
 181                         } catch (Exception e) {
 182                             e.printStackTrace();
 183                         }
 184                         mode.finish(); // Action picked, so close the CAB
 185                     }
 186                     return true;
 187                 case R.id.menu_copy:
 188                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 189                         copyToClipboard(mLinkText);
<abbr title=" 190                         Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();"> 190                         Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SðŸ”µ</abbr>
 191                         mode.finish();
 192                     }
 193                     return true;
 194                 case R.id.menu_share:
 195                     if (mLinkText != null) {
 196                         showShareSheet();
 197                         mode.finish();
 198                     }
 199                     return true;
 200                 default:
 201                     return false;
 202             }
 203         }
 204 
 205         // Called when the user exits the action mode
 206         @Override
 207         public void onDestroyActionMode(ActionMode mode) {
 208             mActionMode = null;
 209             new Handler().postDelayed(
 210                 new Runnable() {
 211                     @Override
 212                     public void run() {
<abbr title=" 213                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 213                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 214                     }
 215                 },
 216                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 217             );
 218         }
 219     };
 220     private Snackbar mPublishingSnackbar;
 221     private boolean mIsUndoingPublishing;
 222     // Resets note publish status if Simperium never returned the new publish status
 223     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 224         @Override
 225         public void run() {
 226             if (!isAdded()) return;
 227 
 228             requireActivity().runOnUiThread(new Runnable() {
 229                 @Override
 230                 public void run() {
 231 
 232                     mNote.setPublished(!mNote.isPublished());
 233                     mNote.save();
 234 
 235                     updatePublishedState(false);
 236                 }
 237             });
 238         }
 239     };
 240     private NoteMarkdownFragment mNoteMarkdownFragment;
 241     private String mCss;
 242     private WebView mMarkdown;
 243 
 244     /**
 245      * Mandatory empty constructor for the fragment manager to instantiate the
 246      * fragment (e.g. upon screen orientation changes).
 247      */
 248     public NoteEditorFragment() {
 249     }
 250 
 251     @Override
 252     public void onCreate(Bundle savedInstanceState) {
 253         super.onCreate(savedInstanceState);
 254         mInfoBottomSheet = new InfoBottomSheetDialog(this, this);
 255         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 256         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 257 
 258         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 259         mNotesBucket = currentApp.getNotesBucket();
 260 
<abbr title=" 261         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 261         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 262         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dp, R.attr.actionModeTextColor);"> 262         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dðŸ”µ</abbr>
<abbr title=" 263         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, R.attr.actionModeTextColor);"> 263         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, RðŸ”µ</abbr>
<abbr title=" 264         mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, R.attr.actionModeTextColor);"> 264         mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, RðŸ”µ</abbr>
 265 
 266         mAutoSaveHandler = new Handler();
 267         mPublishTimeoutHandler = new Handler();
 268         mHistoryTimeoutHandler = new Handler();
 269 
 270         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 271                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 271                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 272         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 273             @Override
 274             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 275                 Activity activity = (Activity) context;
 276                 if (activity == null) return null;
 277                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 278             }
 279 
 280             @Override
 281             public void bindView(View view, Context context, Cursor cursor) {
 282                 TextView textView = (TextView) view;
 283                 textView.setText(convertToString(cursor));
 284             }
 285 
 286             @Override
 287             public CharSequence convertToString(Cursor cursor) {
 288                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 289             }
 290 
 291             @Override
 292             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 293                 Activity activity = getActivity();
 294                 if (activity == null) return null;
 295                 Simplenote application = (Simplenote) activity.getApplication();
 296                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 297                 // make the tag name available to the cursor
 298                 query.include(Tag.NAME_PROPERTY);
 299                 // sort the tags by their names
 300                 query.order(Tag.NAME_PROPERTY);
 301                 // if there&#x27;s a filter string find only matching tag names
 302                 if (filter != null)
<abbr title=" 303                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 303                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 304                 return query.execute();
 305             }
 306         };
 307 
 308         WidgetUtils.updateNoteWidgets(getActivity());
 309     }
 310 
 311     @Override
<abbr title=" 312     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 312     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 313         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 314         mContentEditText = mRootView.findViewById(R.id.note_content);
 315         mContentEditText.addOnSelectionChangedListener(this);
 316         mContentEditText.setOnCheckboxToggledListener(this);
 317         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 318         mTagView = mRootView.findViewById(R.id.tag_view);
 319         mTagView.setTokenizer(new SpaceTokenizer());
 320         mTagView.setOnFocusChangeListener(this);
 321         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 322 
 323         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 324         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 325             mPlaceholderView.setVisibility(View.VISIBLE);
 326             requireActivity().invalidateOptionsMenu();
 327             mMarkdown = mRootView.findViewById(R.id.markdown);
 328             mCss = ThemeUtils.isLightTheme(requireContext())
 329                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 330                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 331         }
 332 
 333         mTagView.setAdapter(mAutocompleteAdapter);
 334 
 335         Bundle arguments = getArguments();
 336         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 337             // Load note if we were passed a note Id
 338             String key = arguments.getString(ARG_ITEM_ID);
 339             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 340                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 341             }
 342             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 343         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null ) {
 344             // Restore selected note when in dual pane mode
 345             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 346             if (noteId != null) {
 347                 setNote(noteId);
 348             }
 349         }
 350 
 351         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 352         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 353             @Override
 354             public void onGlobalLayout() {
 355                 // If a note was loaded with search matches, scroll to the first match in the editor
 356                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 357                     if (!isAdded()) {
 358                         return;
 359                     }
 360 
 361                     // Get the character location of the first search match
 362                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 363                             mContentEditText.getText(),
 364                             mMatchOffsets
 365                     );
 366                     if (matchLocation == 0) {
 367                         return;
 368                     }
 369 
 370                     // Calculate how far to scroll to bring the match into view
 371                     Layout layout = mContentEditText.getLayout();
 372                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 373 
 374                     // We use different scroll views in the root of the layout files... yuck.
 375                     // So we have to cast appropriately to do a smooth scroll
 376                     if (mRootView instanceof NestedScrollView) {
 377                         ((NestedScrollView)mRootView).smoothScrollTo(0, lineTop);
 378                     } else {
 379                         ((ScrollView)mRootView).smoothScrollTo(0, lineTop);
 380                     }
 381 
 382                     mShouldScrollToSearchMatch = false;
 383                 }
 384             }
 385         });
 386         setHasOptionsMenu(true);
 387         return mRootView;
 388     }
 389 
 390     @Override
 391     public void onResume() {
 392         super.onResume();
 393         mNotesBucket.start();
 394         mNotesBucket.addListener(this);
 395 
 396         mTagView.setOnTagAddedListener(this);
 397 
 398         if (mContentEditText != null) {
<abbr title=" 399             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));"> 399             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity())ðŸ”µ</abbr>
 400 
 401             if (mContentEditText.hasFocus()) {
 402                 showSoftKeyboard();
 403             }
 404         }
 405     }
 406 
 407     private void showSoftKeyboard() {
 408         new Handler().postDelayed(new Runnable() {
 409             @Override
 410             public void run() {
 411                 if (getActivity() == null) {
 412                     return;
 413                 }
 414 
<abbr title=" 415                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 415                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 416                 if (inputMethodManager != null) {
 417                     inputMethodManager.showSoftInput(mContentEditText, 0);
 418                 }
 419             }
 420         }, 100);
 421     }
 422 
 423     @Override
 424     public void onPause() {
 425         super.onPause();  // Always call the superclass method first
 426 
 427         mNotesBucket.removeListener(this);
 428         mNotesBucket.stop();
 429 
 430         // Hide soft keyboard if it is showing...
 431         DisplayUtils.hideKeyboard(mContentEditText);
 432 
 433         mTagView.setOnTagAddedListener(null);
 434 
 435         if (mAutoSaveHandler != null) {
 436             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 437         }
 438 
 439         if (mPublishTimeoutHandler != null) {
 440             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 441         }
 442 
 443         if (mHistoryTimeoutHandler != null) {
 444             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 445         }
 446 
 447         mHighlighter.stop();
 448         saveNote();
 449     }
 450 
 451     @Override
 452     public void onSaveInstanceState(@NonNull Bundle outState) {
 453         super.onSaveInstanceState(outState);
 454 
 455         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 456             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 457         }
 458     }
 459 
 460     @Override
 461     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 462         super.onCreateOptionsMenu(menu, inflater);
<abbr title=" 463         if (!isAdded() || DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null) {"> 463         if (!isAdded() || DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == ðŸ”µ</abbr>
 464             return;
 465         }
 466 
 467         inflater.inflate(R.menu.note_editor, menu);
 468 
 469         if (mNote != null) {
 470             MenuItem viewPublishedNoteItem = menu.findItem(R.id.menu_view_info);
 471             viewPublishedNoteItem.setVisible(true);
 472 
 473             MenuItem trashItem = menu.findItem(R.id.menu_delete).setTitle(R.string.undelete);
 474 
 475             if (mNote.isDeleted()) {
 476                 trashItem.setTitle(R.string.undelete);
 477                 trashItem.setIcon(R.drawable.ic_trash_restore_24dp);
 478             } else {
 479                 trashItem.setTitle(R.string.delete);
 480                 trashItem.setIcon(R.drawable.ic_trash_24dp);
 481             }
 482         }
 483         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionBarTextColor);
 484     }
 485 
 486     @Override
 487     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 488         switch (item.getItemId()) {
 489             case R.id.menu_view_info:
 490                 showInfo();
 491                 return true;
 492             case R.id.menu_checklist:
 493                 insertChecklist();
 494                 return true;
 495             case R.id.menu_history:
 496                 showHistory();
 497                 return true;
 498             case R.id.menu_share:
 499                 shareNote();
 500                 return true;
 501             case R.id.menu_delete:
 502                 if (!isAdded()) return false;
 503                 deleteNote();
 504                 return true;
 505             case android.R.id.home:
 506                 if (!isAdded()) return false;
 507                 requireActivity().finish();
 508                 return true;
 509             default:
 510                 return super.onOptionsItemSelected(item);
 511         }
 512     }
 513 
 514     private void insertChecklist() {
 515         try {
 516             mContentEditText.insertChecklist();
 517         } catch (Exception e) {
 518             e.printStackTrace();
 519             return;
 520         }
 521 
 522         AnalyticsTracker.track(
 523                 AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED,
 524                 AnalyticsTracker.CATEGORY_NOTE,
 525                 &quot;toolbar_button&quot;
 526         );
 527     }
 528 
 529     @Override
 530     public void onCheckboxToggled() {
 531         // Save note (using delay) after toggling a checkbox
 532         if (mAutoSaveHandler != null) {
 533             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 534             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 535         }
 536     }
 537 
 538     private void deleteNote() {
 539         NoteUtils.deleteNote(mNote, getActivity());
 540         requireActivity().finish();
 541     }
 542 
 543     protected void clearMarkdown() {
 544         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 545     }
 546 
 547     protected void hideMarkdown() {
 548         mMarkdown.setVisibility(View.INVISIBLE);
 549     }
 550 
 551     protected void showMarkdown() {
 552         loadMarkdownData();
 553         mMarkdown.setVisibility(View.VISIBLE);
 554     }
 555 
 556     private void shareNote() {
 557         if (mNote != null) {
 558             mContentEditText.clearFocus();
 559             showShareSheet();
 560             AnalyticsTracker.track(
 561                     AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED,
 562                     AnalyticsTracker.CATEGORY_NOTE,
 563                     &quot;action_bar_share_button&quot;
 564             );
 565         }
 566     }
 567 
 568     private void showHistory() {
 569         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 570             mContentEditText.clearFocus();
 571             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 572             showHistorySheet();
 573         } else {
 574             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 575         }
 576     }
 577 
 578     private void showInfo() {
 579         if (mNote != null) {
 580             mContentEditText.clearFocus();
 581             saveNote();
 582             showInfoSheet();
 583         }
 584     }
 585 
 586     protected void setMarkdownEnabled(boolean enabled) {
 587         mIsMarkdownEnabled = enabled;
 588 
 589         if (mIsMarkdownEnabled) {
 590             loadMarkdownData();
 591         }
 592     }
 593 
 594     private void loadMarkdownData() {
 595         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 596                 mCss,
 597                 mContentEditText.getPlainTextContent()
 598         );
 599 
 600         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 601     }
 602 
 603     public void setNote(String noteID, String matchOffsets) {
 604         if (mAutoSaveHandler != null)
 605             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 606 
 607         mPlaceholderView.setVisibility(View.GONE);
 608 
 609         if (matchOffsets != null) {
 610             mMatchOffsets = matchOffsets;
 611         } else {
 612             mMatchOffsets = null;
 613         }
 614 
 615 
 616         saveNote();
 617 
 618         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 619     }
 620 
 621     private void updateNote(Note updatedNote) {
 622         // update note if network change arrived
 623         mNote = updatedNote;
 624         refreshContent(true);
 625     }
 626 
 627     private void refreshContent(boolean isNoteUpdate) {
 628         if (mNote != null) {
 629             // Restore the cursor position if possible.
 630 
<abbr title=" 631             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 631             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 632 
 633             mContentEditText.setText(mNote.getContent());
 634 
 635             if (isNoteUpdate) {
 636                 // Save the note so any local changes get synced
 637                 mNote.save();
 638 
 639                 if (mContentEditText.hasFocus()
 640                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 641                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 642                     mContentEditText.setSelection(cursorPosition);
 643                 }
 644             }
 645 
 646             afterTextChanged(mContentEditText.getText());
 647             mContentEditText.processChecklists();
 648             updateTagList();
 649         }
 650     }
 651 
 652     private void updateTagList() {
 653         Activity activity = getActivity();
 654         if (activity == null) return;
 655 
 656         // Populate this note&#x27;s tags in the tagView
 657         mTagView.setChips(mNote.getTagString());
 658     }
 659 
 660     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 661         // Ported from the iOS app :)
 662         // Cases:
 663         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 664         // 1. Text was added after the cursor ==&gt; no change
 665         // 2. Text was added before the cursor ==&gt; location advances
 666         // 3. Text was removed after the cursor ==&gt; no change
 667         // 4. Text was removed before the cursor ==&gt; location retreats
 668         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 669 
 670         cursorLocation = Math.max(cursorLocation, 0);
 671 
 672         int newCursorLocation = cursorLocation;
 673 
 674         int deltaLength = newText.length() - oldText.length();
 675 
 676         // Case 0
 677         if (newText.length() &lt; cursorLocation)
 678             return newText.length();
 679 
 680         boolean beforeCursorMatches = false;
 681         boolean afterCursorMatches = false;
 682 
 683         try {
<abbr title=" 684             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 684             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 685             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 685             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 686         } catch (Exception e) {
 687             e.printStackTrace();
 688         }
 689 
 690         // Cases 2 and 4
 691         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 692             newCursorLocation += deltaLength;
 693 
 694         // Cases 1, 3 and 5 have no change
 695         return newCursorLocation;
 696     }
 697 
 698     @Override
 699     public void onTagsChanged(String tagString) {
 700         if (mNote == null || !isAdded()) return;
 701 
 702         if (mNote.getTagString() != null &amp;&amp; tagString.length() &gt; mNote.getTagString().length()) {
 703             AnalyticsTracker.track(
 704                     AnalyticsTracker.Stat.EDITOR_TAG_ADDED,
 705                     AnalyticsTracker.CATEGORY_NOTE,
 706                     &quot;tag_added_to_note&quot;
 707             );
 708         } else {
 709             AnalyticsTracker.track(
 710                     AnalyticsTracker.Stat.EDITOR_TAG_REMOVED,
 711                     AnalyticsTracker.CATEGORY_NOTE,
 712                     &quot;tag_removed_from_note&quot;
 713             );
 714         }
 715 
 716         mNote.setTagString(tagString);
 717         mNote.setModificationDate(Calendar.getInstance());
 718         updateTagList();
 719         mNote.save();
 720     }
 721 
 722     @Override
 723     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 724         // Unused
 725     }
 726 
 727     @Override
 728     public void afterTextChanged(Editable editable) {
 729         attemptAutoList(editable);
 730         setTitleSpan(editable);
 731         mContentEditText.fixLineSpacing();
 732     }
 733 
 734     @Override
 735     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 736         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 737         if (mAutoSaveHandler != null) {
 738             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 739             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 740         }
 741 
 742         // Remove search highlight spans when note content changes
 743         if (mMatchOffsets != null) {
 744             mMatchOffsets = null;
 745             mHighlighter.removeMatches();
 746         }
 747 
 748         // Temporarily remove the text watcher as we process checklists to prevent callback looping
 749         mContentEditText.removeTextChangedListener(this);
 750         mContentEditText.processChecklists();
 751         mContentEditText.addTextChangedListener(this);
 752     }
 753 
 754     private void setTitleSpan(Editable editable) {
 755         // Set the note title to be a larger size
 756         // Remove any existing size spans
 757         RelativeSizeSpan[] spans = editable.getSpans(0, editable.length(), RelativeSizeSpan.class);
 758         for (RelativeSizeSpan span : spans) {
 759             editable.removeSpan(span);
 760         }
 761         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 762         if (newLinePosition == 0)
 763             return;
<abbr title=" 764         editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editable.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);"> 764         editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editaðŸ”µ</abbr>
 765     }
 766 
 767     private void attemptAutoList(Editable editable) {
 768         int oldCursorPosition = mCurrentCursorPosition;
 769         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 770         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 771         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 772     }
 773 
 774     private void saveAndSyncNote() {
 775         if (mNote == null) {
 776             return;
 777         }
 778 
 779         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 780     }
 781 
 782     public void setPlaceholderVisible(boolean isVisible) {
 783         if (isVisible) {
 784             mNote = null;
 785             mContentEditText.setText(&quot;&quot;);
 786             mTagView.setText(&quot;&quot;);
 787             if (mPlaceholderView != null)
 788                 mPlaceholderView.setVisibility(View.VISIBLE);
 789         } else {
 790             if (mPlaceholderView != null)
 791                 mPlaceholderView.setVisibility(View.GONE);
 792         }
 793     }
 794 
 795     @Override
 796     public void onFocusChange(View v, boolean hasFocus) {
 797         if (!hasFocus) {
 798             String tagString = getNoteTagsString().trim();
 799             if (tagString.length() &gt; 0) {
 800                 mTagView.setChips(tagString);
 801             }
 802         }
 803     }
 804 
 805     private Note getNote() {
 806         return mNote;
 807     }
 808 
 809     public void setNote(String noteID) {
 810         setNote(noteID, null);
 811     }
 812 
 813     private String getNoteContentString() {
 814         if (mContentEditText == null || mContentEditText.getText() == null) {
 815             return &quot;&quot;;
 816         } else {
 817             return mContentEditText.getText().toString();
 818         }
 819     }
 820 
 821     private String getNoteTagsString() {
 822         if (mTagView == null || mTagView.getText() == null) {
 823             return &quot;&quot;;
 824         } else {
 825             return mTagView.getText().toString();
 826         }
 827     }
 828 
 829     /**
 830      * Share bottom sheet callbacks
 831      */
 832 
 833     @Override
 834     public void onSharePublishClicked() {
 835         publishNote();
 836         if (mShareBottomSheet != null) {
 837             mShareBottomSheet.dismiss();
 838         }
 839     }
 840 
 841     @Override
 842     public void onShareUnpublishClicked() {
 843         unpublishNote();
 844         if (mShareBottomSheet != null) {
 845             mShareBottomSheet.dismiss();
 846         }
 847     }
 848 
 849     @Override
 850     public void onWordPressPostClicked() {
 851         if (mShareBottomSheet != null) {
 852             mShareBottomSheet.dismiss();
 853         }
 854 
 855         if (getFragmentManager() == null) {
 856             return;
 857         }
 858 
 859         FragmentTransaction ft = getFragmentManager().beginTransaction();
 860         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
 861         if (prev != null) {
 862             ft.remove(prev);
 863         }
 864         ft.addToBackStack(null);
 865 
 866         // Create and show the dialog.
 867         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
 868         wpDialogFragment.setNote(mNote);
 869         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
 870     }
 871 
 872     @Override
 873     public void onShareCollaborateClicked() {
 874         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
 875     }
 876 
 877     @Override
 878     public void onShareDismissed() {
 879 
 880     }
 881 
 882     /**
 883      * History bottom sheet listeners
 884      */
 885 
 886     @Override
 887     public void onHistoryCancelClicked() {
 888         mContentEditText.setText(mNote.getContent());
 889         if (mHistoryBottomSheet != null) {
 890             mHistoryBottomSheet.dismiss();
 891         }
 892     }
 893 
 894     @Override
 895     public void onHistoryRestoreClicked() {
 896         if (mHistoryBottomSheet != null) {
 897             mHistoryBottomSheet.dismiss();
 898         }
 899         saveAndSyncNote();
 900     }
 901 
 902     @Override
 903     public void onHistoryDismissed() {
 904         if (!mHistoryBottomSheet.didTapOnButton()) {
 905             mContentEditText.setText(mNote.getContent());
 906         }
 907 
 908         if (mHistoryTimeoutHandler != null) {
 909             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 910         }
 911     }
 912 
 913     @Override
 914     public void onHistoryUpdateNote(String content) {
 915         mContentEditText.setText(content);
 916     }
 917 
 918     /**
 919      * Info bottom sheet listeners
 920      */
 921 
 922     @Override
 923     public void onInfoPinSwitchChanged(boolean isSwitchedOn) {
 924         NoteUtils.setNotePin(mNote, isSwitchedOn);
 925     }
 926 
 927     @Override
 928     public void onInfoMarkdownSwitchChanged(boolean isSwitchedOn) {
 929         mIsMarkdownEnabled = isSwitchedOn;
 930         Activity activity = getActivity();
 931 
 932         if (activity instanceof NoteEditorActivity) {
 933 
 934             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 935             if (mIsMarkdownEnabled) {
 936 
 937                 editorActivity.showTabs();
 938 
 939                 if (mNoteMarkdownFragment == null) {
 940                     // Get markdown fragment and update content
 941                     mNoteMarkdownFragment =
 942                             editorActivity.getNoteMarkdownFragment();
 943                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 944                 }
 945             } else {
 946                 editorActivity.hideTabs();
 947             }
 948         } else if (activity instanceof NotesActivity) {
 949             setMarkdownEnabled(mIsMarkdownEnabled);
 950             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 951         }
 952 
 953         saveNote();
 954     }
 955 
 956     @Override
 957     public void onInfoCopyLinkClicked() {
 958         copyToClipboard(mNote.getPublishedUrl());
 959         Toast.makeText(getActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();
 960     }
 961 
 962     @Override
 963     public void onInfoShareLinkClicked() {
 964         if (mInfoBottomSheet != null) {
 965             mInfoBottomSheet.dismiss();
 966         }
 967         showShareSheet();
 968     }
 969 
 970     @Override
 971     public void onInfoDismissed() {
 972     }
 973 
 974     protected void saveNote() {
 975 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 976         if (mNote == null || mContentEditText == null || mIsLoadingNote ||</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 977             (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {"> 977             (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheeðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 978             return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 979         }</span>
 980 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 981     protected void saveNote() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 982         if (mNote == null ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 983                 mContentEditText == null ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 984                 mIsLoadingNote ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 985                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.isShowing())) {</span>
 986 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 987         try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 988             Simplenote application = (Simplenote) requireActivity().getApplication();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 989             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 990             mNote = notesBucket.get(mNote.getSimperiumKey());</span>
 991 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 992 
 993             if (mNote == null || mContentEditText == null || mIsLoadingNote ||
 994                     (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.isShowing())) {
 995                 return;
 996             } else {
 997                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 998             }
 999 
1000             String content = mContentEditText.getPlainTextContent();
1001             String tagString = getNoteTagsString();
1002 
<abbr title="1003             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1003             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1004                 mNote.setContent(content);
1005                 mNote.setTagString(tagString);
1006                 mNote.setModificationDate(Calendar.getInstance());
1007                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1008                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1009                 mNote.save();
1010 
1011                 AnalyticsTracker.track(
1012                         AnalyticsTracker.Stat.EDITOR_NOTE_EDITED,
1013                         AnalyticsTracker.CATEGORY_NOTE,
1014                         &quot;editor_save&quot;
1015                 );
1016             }
1017         } catch (BucketObjectMissingException exception) {
1018             exception.printStackTrace();
1019         }
1020     }
1021 
1022     // Checks if cursor is at a URL when the selection changes
1023     // If it is a URL, show the contextual action bar
1024     @Override
1025     public void onSelectionChanged(int selStart, int selEnd) {
1026         mCurrentCursorPosition = selEnd;
1027         if (selStart == selEnd) {
1028             Editable noteContent = mContentEditText.getText();
1029             if (noteContent == null)
1030                 return;
1031 
1032             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1033             if (urlSpans.length &gt; 0) {
1034                 URLSpan urlSpan = urlSpans[0];
1035                 mLinkUrl = urlSpan.getURL();
<abbr title="1036                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1036                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1037                 if (mActionMode != null) {
1038                     mActionMode.setSubtitle(mLinkText);
1039                     setLinkMenuItem();
1040                     return;
1041                 }
1042 
1043                 // Show the Contextual Action Bar
1044                 if (getActivity() != null) {
<abbr title="1045                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1045                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1046                     if (mActionMode != null) {
1047                         mActionMode.setSubtitle(mLinkText);
1048                     }
1049 
1050                     setLinkMenuItem();
1051                 }
1052             } else if (mActionMode != null) {
1053                 mActionMode.finish();
1054                 mActionMode = null;
1055             }
1056         } else if (mActionMode != null) {
1057             mActionMode.finish();
1058             mActionMode = null;
1059         }
1060     }
1061 
1062     private void setLinkMenuItem() {
1063         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1064             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1065                 mViewLinkMenuItem.setIcon(mCallIcon);
1066                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1067             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1068                 mViewLinkMenuItem.setIcon(mEmailIcon);
1069                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1070             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1071                 mViewLinkMenuItem.setIcon(mMapIcon);
1072                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1073             } else {
1074                 mViewLinkMenuItem.setIcon(mWebIcon);
1075                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1076             }
1077         }
1078     }
1079 
1080     private void setPublishedNote(boolean isPublished) {
1081         if (mNote != null) {
1082             mNote.setPublished(isPublished);
1083             mNote.save();
1084 
1085             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1086             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1087 
1088             AnalyticsTracker.track(
1089                     (isPublished) ? AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED :
1090                             AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED,
1091                     AnalyticsTracker.CATEGORY_NOTE,
1092                     &quot;publish_note_button&quot;
1093             );
1094         }
1095     }
1096 
1097     private void updatePublishedState(boolean isSuccess) {
1098 
1099         if (mPublishingSnackbar == null) {
1100             return;
1101         }
1102 
1103         mPublishingSnackbar.dismiss();
1104         mPublishingSnackbar = null;
1105 
1106         if (isSuccess &amp;&amp; isAdded()) {
1107             if (mNote.isPublished()) {
1108 
1109                 if (mIsUndoingPublishing) {
1110                     SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1111                             R.color.status_positive,
1112                             Snackbar.LENGTH_LONG);
1113                 } else {
1114                     SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1115                             R.color.status_positive,
1116                             Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1117                                 @Override
1118                                 public void onClick(View v) {
1119                                     mIsUndoingPublishing = true;
1120                                     unpublishNote();
1121                                 }
1122                             });
1123                 }
1124                 copyToClipboard(mNote.getPublishedUrl());
1125             } else {
1126                 if (mIsUndoingPublishing) {
1127                     SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1128                             R.color.status_negative,
1129                             Snackbar.LENGTH_LONG);
1130                 } else {
1131                     SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1132                             R.color.status_negative,
1133                             Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1134                                 @Override
1135                                 public void onClick(View v) {
1136                                     mIsUndoingPublishing = true;
1137                                     publishNote();
1138                                 }
1139                             });
1140                 }
1141             }
1142         } else {
1143             if (mNote.isPublished()) {
1144                 SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_error,
1145                         R.color.status_negative, Snackbar.LENGTH_LONG);
1146             } else {
1147                 SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_error,
1148                         R.color.status_negative, Snackbar.LENGTH_LONG);
1149             }
1150         }
1151 
1152         mIsUndoingPublishing = false;
1153     }
1154 
1155     private void publishNote() {
1156 
1157         if (isAdded()) {
1158             mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.publishing,
1159                     R.color.blue, Snackbar.LENGTH_INDEFINITE);
1160         }
1161         setPublishedNote(true);
1162     }
1163 
1164     private void unpublishNote() {
1165 
1166         if (isAdded()) {
1167             mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublishing,
1168                     R.color.blue, Snackbar.LENGTH_INDEFINITE);
1169         }
1170         setPublishedNote(false);
1171     }
1172 
1173     private void copyToClipboard(String text) {
1174         ClipboardManager clipboard = (ClipboardManager) requireActivity()
1175                 .getSystemService(Context.CLIPBOARD_SERVICE);
1176         ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);
1177         if (clipboard != null) {
1178             clipboard.setPrimaryClip(clip);
1179         }
1180     }
1181 
1182     private void showShareSheet() {
1183         if (isAdded()) {
1184             mShareBottomSheet.show(requireFragmentManager(), mNote);
1185         }
1186     }
1187 
1188     private void showInfoSheet() {
1189         if (isAdded()) {
1190             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1191         }
1192     }
1193 
1194     private void showHistorySheet() {
1195         if (isAdded()) {
1196             // Request revisions for the current note
<abbr title="1197             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1197             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1198             saveNote();
1199 
1200             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1201         }
1202     }
1203 
1204     /**
1205      * Simperium listeners
1206      */
1207 
1208     @Override
1209     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1210 
1211     }
1212 
1213     @Override
<abbr title="1214     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1214     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1215         if (changeType == Bucket.ChangeType.MODIFY) {
1216             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1217                 try {
1218                     final Note updatedNote = mNotesBucket.get(key);
1219                     if (getActivity() != null) {
1220                         getActivity().runOnUiThread(new Runnable() {
1221                             @Override
1222                             public void run() {
1223                                 if (mPublishTimeoutHandler != null) {
1224                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1225                                 }
1226 
1227                                 updateNote(updatedNote);
1228                                 updatePublishedState(true);
1229                             }
1230                         });
1231                     }
1232                 } catch (BucketObjectMissingException e) {
1233                     e.printStackTrace();
1234                 }
1235             }
1236         }
1237     }
1238 
1239     @Override
1240     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1241         // noop
1242     }
1243 
1244     @Override
1245     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1246         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1247         if (mIsLoadingNote)
1248             return;
1249 
1250         Note openNote = getNote();
1251         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1252             return;
1253 
1254         note.setContent(mContentEditText.getPlainTextContent());
1255     }
1256 
1257     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1258         WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1259 
1260         LoadNoteTask(NoteEditorFragment fragment) {
1261             weakFragment = new WeakReference&lt;&gt;(fragment);
1262         }
1263 
1264         @Override
1265         protected void onPreExecute() {
1266             NoteEditorFragment fragment = weakFragment.get();
1267             if (fragment != null) {
1268                 fragment.mContentEditText.removeTextChangedListener(fragment);
1269                 fragment.mIsLoadingNote = true;
1270             }
1271         }
1272 
1273         @Override
1274         protected Void doInBackground(String... args) {
1275             NoteEditorFragment fragment = weakFragment.get();
1276             if (fragment == null || fragment.getActivity() == null) {
1277                 return null;
1278             }
1279 
1280             String noteID = args[0];
1281             Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1282             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1283 
1284             try {
1285                 fragment.mNote = notesBucket.get(noteID);
1286                 // Set the current note in NotesActivity when on a tablet
1287                 if (fragment.getActivity() instanceof NotesActivity) {
1288                     ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1289                 }
1290 
1291                 // Set markdown and preview flags for current note
1292                 if (fragment.mNote != null) {
1293                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1294                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1295                 }
1296             } catch (BucketObjectMissingException e) {
1297                 // See if the note is in the object store
1298                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1299                 while (notesCursor.moveToNext()) {
1300                     Note currentNote = notesCursor.getObject();
1301                     if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1302                         fragment.mNote = currentNote;
1303                         return null;
1304                     }
1305                 }
1306             }
1307 
1308             return null;
1309         }
1310 
1311         @Override
1312         protected void onPostExecute(Void nada) {
1313             final NoteEditorFragment fragment = weakFragment.get();
1314             if (fragment == null
1315                     || fragment.getActivity() == null
1316                     || fragment.getActivity().isFinishing()) {
1317                 return;
1318             }
1319 
1320             fragment.refreshContent(false);
1321             if (fragment.mMatchOffsets != null) {
<abbr title="1322                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1322                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1323                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1324 
1325                 fragment.mShouldScrollToSearchMatch = true;
1326             }
1327 
1328             fragment.mContentEditText.addTextChangedListener(fragment);
1329 
1330             if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1331                 // Show soft keyboard
1332                 fragment.mContentEditText.requestFocus();
1333 
1334                 new Handler().postDelayed(new Runnable() {
1335                     @Override
1336                     public void run() {
1337                         if (fragment.getActivity() == null) {
1338                             return;
1339                         }
1340 
<abbr title="1341                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1341                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivityðŸ”µ</abbr>
1342                         if (inputMethodManager != null) {
1343                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1344                         }
1345                     }
1346                 }, 100);
1347 
1348             } else if (fragment.mNote != null) {
1349                 // If we have a valid note, hide the placeholder
1350                 fragment.setPlaceholderVisible(false);
1351             }
1352 
1353             fragment.updateMarkdownView();
1354 
1355             fragment.requireActivity().invalidateOptionsMenu();
1356 
1357             fragment.linkifyEditorContent();
1358             fragment.mIsLoadingNote = false;
1359         }
1360     }
1361 
1362     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1363         WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1364 
1365         SaveNoteTask(NoteEditorFragment fragment) {
1366             weakFragment = new WeakReference&lt;&gt;(fragment);
1367         }
1368 
1369         @Override
1370         protected Void doInBackground(Void... args) {
1371             NoteEditorFragment fragment = weakFragment.get();
1372             if (fragment != null) {
1373                 fragment.saveNote();
1374             }
1375             return null;
1376         }
1377 
1378         @Override
1379         protected void onPostExecute(Void nada) {
1380             NoteEditorFragment fragment = weakFragment.get();
<abbr title="1381             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {">1381             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishingðŸ”µ</abbr>
1382                 // Update links
1383                 fragment.linkifyEditorContent();
1384                 fragment.updateMarkdownView();
1385             }
1386         }
1387     }
1388 
1389     private void linkifyEditorContent() {
1390         if (getActivity() == null || getActivity().isFinishing()) {
1391             return;
1392         }
1393 
1394         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1395             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1396         }
1397     }
1398 
1399     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1400     private void updateMarkdownView() {
1401         if (!mIsMarkdownEnabled) {
1402             return;
1403         }
1404 
1405         Activity activity = getActivity();
1406         if (activity instanceof NotesActivity) {
1407             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1408             loadMarkdownData();
1409         } else {
1410             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1411             if (mNoteMarkdownFragment == null) {
1412                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1413                         .getNoteMarkdownFragment();
1414                 ((NoteEditorActivity) requireActivity()).showTabs();
1415             }
1416             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1417             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1418         }
1419     }
1420 }
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.ClipData;
   5 import android.content.ClipboardManager;
   6 import android.content.Context;
   7 import android.content.Intent;
   8 import android.database.Cursor;
   9 import android.graphics.drawable.Drawable;
  10 import android.net.Uri;
  11 import android.os.AsyncTask;
  12 import android.os.Bundle;
  13 import android.os.Handler;
  14 import android.text.Editable;
  15 import android.text.Layout;
  16 import android.text.Spanned;
  17 import android.text.TextWatcher;
  18 import android.text.style.RelativeSizeSpan;
  19 import android.text.style.URLSpan;
  20 import android.text.util.Linkify;
  21 import android.util.TypedValue;
  22 import android.view.LayoutInflater;
  23 import android.view.Menu;
  24 import android.view.MenuInflater;
  25 import android.view.MenuItem;
  26 import android.view.View;
  27 import android.view.ViewGroup;
  28 import android.view.ViewTreeObserver;
  29 import android.view.inputmethod.InputMethodManager;
  30 import android.webkit.WebView;
  31 import android.widget.CursorAdapter;
  32 import android.widget.LinearLayout;
  33 import android.widget.ScrollView;
  34 import android.widget.TextView;
  35 import android.widget.Toast;
  36 
  37 import androidx.annotation.NonNull;
  38 import androidx.appcompat.app.AppCompatActivity;
  39 import androidx.appcompat.view.ActionMode;
  40 import androidx.core.widget.NestedScrollView;
  41 import androidx.fragment.app.Fragment;
  42 import androidx.fragment.app.FragmentTransaction;
  43 
  44 import com.automattic.simplenote.analytics.AnalyticsTracker;
  45 import com.automattic.simplenote.models.Note;
  46 import com.automattic.simplenote.models.Tag;
  47 import com.automattic.simplenote.utils.AutoBullet;
  48 import com.automattic.simplenote.utils.ContextUtils;
  49 import com.automattic.simplenote.utils.DisplayUtils;
  50 import com.automattic.simplenote.utils.DrawableUtils;
  51 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  52 import com.automattic.simplenote.utils.NoteUtils;
  53 import com.automattic.simplenote.utils.PrefUtils;
  54 import com.automattic.simplenote.utils.SimplenoteLinkify;
  55 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  56 import com.automattic.simplenote.utils.SnackbarUtils;
  57 import com.automattic.simplenote.utils.SpaceTokenizer;
  58 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  59 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  60 import com.automattic.simplenote.utils.TextHighlighter;
  61 import com.automattic.simplenote.utils.ThemeUtils;
  62 import com.automattic.simplenote.utils.WidgetUtils;
  63 import com.automattic.simplenote.widgets.SimplenoteEditText;
  64 import com.google.android.material.snackbar.Snackbar;
  65 import com.simperium.client.Bucket;
  66 import com.simperium.client.BucketObjectMissingException;
  67 import com.simperium.client.Query;
  68 
  69 import java.lang.ref.WeakReference;
  70 import java.util.Calendar;
  71 
  72 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  73         TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  74         SimplenoteEditText.OnSelectionChangedListener,
  75         ShareBottomSheetDialog.ShareSheetListener,
  76         HistoryBottomSheetDialog.HistorySheetListener,
  77         InfoBottomSheetDialog.InfoSheetListener,
  78         SimplenoteEditText.OnCheckboxToggledListener {
  79 
  80     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  81     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
  82     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
  83     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
  84     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
  85     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
  86     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
  87     private static final int MAX_REVISIONS = 30;
  88     private static final int PUBLISH_TIMEOUT = 20000;
  89     private static final int HISTORY_TIMEOUT = 10000;
  90     private Note mNote;
  91     private final Runnable mAutoSaveRunnable = new Runnable() {
  92         @Override
  93         public void run() {
  94             saveAndSyncNote();
  95         }
  96     };
  97     private Bucket&lt;Note&gt; mNotesBucket;
  98     private View mRootView;
  99     private SimplenoteEditText mContentEditText;
 100     private TagsMultiAutoCompleteTextView mTagView;
 101     private Handler mAutoSaveHandler;
 102     private Handler mPublishTimeoutHandler;
 103     private Handler mHistoryTimeoutHandler;
 104     private LinearLayout mPlaceholderView;
 105     private CursorAdapter mAutocompleteAdapter;
 106     private boolean mIsLoadingNote;
 107     private boolean mIsMarkdownEnabled;
 108     private boolean mIsPreviewEnabled;
 109     private boolean mShouldScrollToSearchMatch;
 110     private ActionMode mActionMode;
 111     private MenuItem mViewLinkMenuItem;
 112     private String mLinkUrl;
 113     private String mLinkText;
 114     private MatchOffsetHighlighter mHighlighter;
 115     private Drawable mEmailIcon, mWebIcon, mMapIcon, mCallIcon;
 116     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 117     private String mMatchOffsets;
 118     private int mCurrentCursorPosition;
 119     private HistoryBottomSheetDialog mHistoryBottomSheet;
 120     // Hides the history bottom sheet if no revisions are loaded
 121     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 122         @Override
 123         public void run() {
 124             if (!isAdded()) {
 125                 return;
 126             }
 127 
 128             requireActivity().runOnUiThread(new Runnable() {
 129                 @Override
 130                 public void run() {
<abbr title=" 131                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 131                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 132                         mHistoryBottomSheet.dismiss();
 133                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 134                     }
 135                 }
 136             });
 137         }
 138     };
 139     private InfoBottomSheetDialog mInfoBottomSheet;
 140     private ShareBottomSheetDialog mShareBottomSheet;
 141     // Contextual action bar for dealing with links
 142     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 143         // Called when the action mode is created; startActionMode() was called
 144         @Override
 145         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 146             // Inflate a menu resource providing context menu items
 147             MenuInflater inflater = mode.getMenuInflater();
 148 
 149             if (inflater != null) {
 150                 inflater.inflate(R.menu.view_link, menu);
 151                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 152                 mode.setTitle(getString(R.string.link));
 153                 mode.setTitleOptionalHint(false);
 154 
 155                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 156             }
 157 
<abbr title=" 158             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 158             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.colðŸ”µ</abbr>
<abbr title=" 159             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 159             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireAcðŸ”µ</abbr>
 160             return true;
 161         }
 162 
 163         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 164         // may be called multiple times if the mode is invalidated.
 165         @Override
 166         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 167             return false; // Return false if nothing is done
 168         }
 169 
 170         // Called when the user selects a contextual menu item
 171         @Override
 172         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 173             switch (item.getItemId()) {
 174                 case R.id.menu_view_link:
 175                     if (mLinkUrl != null) {
 176                         try {
 177                             Uri uri = Uri.parse(mLinkUrl);
 178                             Intent i = new Intent(Intent.ACTION_VIEW);
 179                             i.setData(uri);
 180                             startActivity(i);
 181                         } catch (Exception e) {
 182                             e.printStackTrace();
 183                         }
 184                         mode.finish(); // Action picked, so close the CAB
 185                     }
 186                     return true;
 187                 case R.id.menu_copy:
 188                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 189                         copyToClipboard(mLinkText);
<abbr title=" 190                         Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();"> 190                         Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SðŸ”µ</abbr>
 191                         mode.finish();
 192                     }
 193                     return true;
 194                 case R.id.menu_share:
 195                     if (mLinkText != null) {
 196                         showShareSheet();
 197                         mode.finish();
 198                     }
 199                     return true;
 200                 default:
 201                     return false;
 202             }
 203         }
 204 
 205         // Called when the user exits the action mode
 206         @Override
 207         public void onDestroyActionMode(ActionMode mode) {
 208             mActionMode = null;
 209             new Handler().postDelayed(
 210                 new Runnable() {
 211                     @Override
 212                     public void run() {
<abbr title=" 213                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 213                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 214                     }
 215                 },
 216                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 217             );
 218         }
 219     };
 220     private Snackbar mPublishingSnackbar;
 221     private boolean mIsUndoingPublishing;
 222     // Resets note publish status if Simperium never returned the new publish status
 223     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 224         @Override
 225         public void run() {
 226             if (!isAdded()) return;
 227 
 228             requireActivity().runOnUiThread(new Runnable() {
 229                 @Override
 230                 public void run() {
 231 
 232                     mNote.setPublished(!mNote.isPublished());
 233                     mNote.save();
 234 
 235                     updatePublishedState(false);
 236                 }
 237             });
 238         }
 239     };
 240     private NoteMarkdownFragment mNoteMarkdownFragment;
 241     private String mCss;
 242     private WebView mMarkdown;
 243 
 244     /**
 245      * Mandatory empty constructor for the fragment manager to instantiate the
 246      * fragment (e.g. upon screen orientation changes).
 247      */
 248     public NoteEditorFragment() {
 249     }
 250 
 251     @Override
 252     public void onCreate(Bundle savedInstanceState) {
 253         super.onCreate(savedInstanceState);
 254         mInfoBottomSheet = new InfoBottomSheetDialog(this, this);
 255         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 256         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 257 
 258         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 259         mNotesBucket = currentApp.getNotesBucket();
 260 
<abbr title=" 261         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 261         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 262         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dp, R.attr.actionModeTextColor);"> 262         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dðŸ”µ</abbr>
<abbr title=" 263         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, R.attr.actionModeTextColor);"> 263         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, RðŸ”µ</abbr>
<abbr title=" 264         mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, R.attr.actionModeTextColor);"> 264         mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, RðŸ”µ</abbr>
 265 
 266         mAutoSaveHandler = new Handler();
 267         mPublishTimeoutHandler = new Handler();
 268         mHistoryTimeoutHandler = new Handler();
 269 
 270         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 271                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 271                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 272         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 273             @Override
 274             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 275                 Activity activity = (Activity) context;
 276                 if (activity == null) return null;
 277                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 278             }
 279 
 280             @Override
 281             public void bindView(View view, Context context, Cursor cursor) {
 282                 TextView textView = (TextView) view;
 283                 textView.setText(convertToString(cursor));
 284             }
 285 
 286             @Override
 287             public CharSequence convertToString(Cursor cursor) {
 288                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 289             }
 290 
 291             @Override
 292             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 293                 Activity activity = getActivity();
 294                 if (activity == null) return null;
 295                 Simplenote application = (Simplenote) activity.getApplication();
 296                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 297                 // make the tag name available to the cursor
 298                 query.include(Tag.NAME_PROPERTY);
 299                 // sort the tags by their names
 300                 query.order(Tag.NAME_PROPERTY);
 301                 // if there&#x27;s a filter string find only matching tag names
 302                 if (filter != null)
<abbr title=" 303                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 303                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 304                 return query.execute();
 305             }
 306         };
 307 
 308         WidgetUtils.updateNoteWidgets(getActivity());
 309     }
 310 
 311     @Override
<abbr title=" 312     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 312     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 313         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 314         mContentEditText = mRootView.findViewById(R.id.note_content);
 315         mContentEditText.addOnSelectionChangedListener(this);
 316         mContentEditText.setOnCheckboxToggledListener(this);
 317         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 318         mTagView = mRootView.findViewById(R.id.tag_view);
 319         mTagView.setTokenizer(new SpaceTokenizer());
 320         mTagView.setOnFocusChangeListener(this);
 321         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 322 
 323         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 324         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 325             mPlaceholderView.setVisibility(View.VISIBLE);
 326             requireActivity().invalidateOptionsMenu();
 327             mMarkdown = mRootView.findViewById(R.id.markdown);
 328             mCss = ThemeUtils.isLightTheme(requireContext())
 329                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 330                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 331         }
 332 
 333         mTagView.setAdapter(mAutocompleteAdapter);
 334 
 335         Bundle arguments = getArguments();
 336         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 337             // Load note if we were passed a note Id
 338             String key = arguments.getString(ARG_ITEM_ID);
 339             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 340                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 341             }
 342             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 343         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null ) {
 344             // Restore selected note when in dual pane mode
 345             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 346             if (noteId != null) {
 347                 setNote(noteId);
 348             }
 349         }
 350 
 351         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 352         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 353             @Override
 354             public void onGlobalLayout() {
 355                 // If a note was loaded with search matches, scroll to the first match in the editor
 356                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 357                     if (!isAdded()) {
 358                         return;
 359                     }
 360 
 361                     // Get the character location of the first search match
 362                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 363                             mContentEditText.getText(),
 364                             mMatchOffsets
 365                     );
 366                     if (matchLocation == 0) {
 367                         return;
 368                     }
 369 
 370                     // Calculate how far to scroll to bring the match into view
 371                     Layout layout = mContentEditText.getLayout();
 372                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 373 
 374                     // We use different scroll views in the root of the layout files... yuck.
 375                     // So we have to cast appropriately to do a smooth scroll
 376                     if (mRootView instanceof NestedScrollView) {
 377                         ((NestedScrollView)mRootView).smoothScrollTo(0, lineTop);
 378                     } else {
 379                         ((ScrollView)mRootView).smoothScrollTo(0, lineTop);
 380                     }
 381 
 382                     mShouldScrollToSearchMatch = false;
 383                 }
 384             }
 385         });
 386         setHasOptionsMenu(true);
 387         return mRootView;
 388     }
 389 
 390     @Override
 391     public void onResume() {
 392         super.onResume();
 393         mNotesBucket.start();
 394         mNotesBucket.addListener(this);
 395 
 396         mTagView.setOnTagAddedListener(this);
 397 
 398         if (mContentEditText != null) {
<abbr title=" 399             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));"> 399             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity())ðŸ”µ</abbr>
 400 
 401             if (mContentEditText.hasFocus()) {
 402                 showSoftKeyboard();
 403             }
 404         }
 405     }
 406 
 407     private void showSoftKeyboard() {
 408         new Handler().postDelayed(new Runnable() {
 409             @Override
 410             public void run() {
 411                 if (getActivity() == null) {
 412                     return;
 413                 }
 414 
<abbr title=" 415                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 415                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 416                 if (inputMethodManager != null) {
 417                     inputMethodManager.showSoftInput(mContentEditText, 0);
 418                 }
 419             }
 420         }, 100);
 421     }
 422 
 423     @Override
 424     public void onPause() {
 425         super.onPause();  // Always call the superclass method first
 426 
 427         mNotesBucket.removeListener(this);
 428         mNotesBucket.stop();
 429 
 430         // Hide soft keyboard if it is showing...
 431         DisplayUtils.hideKeyboard(mContentEditText);
 432 
 433         mTagView.setOnTagAddedListener(null);
 434 
 435         if (mAutoSaveHandler != null) {
 436             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 437         }
 438 
 439         if (mPublishTimeoutHandler != null) {
 440             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 441         }
 442 
 443         if (mHistoryTimeoutHandler != null) {
 444             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 445         }
 446 
 447         mHighlighter.stop();
 448         saveNote();
 449     }
 450 
 451     @Override
 452     public void onSaveInstanceState(@NonNull Bundle outState) {
 453         super.onSaveInstanceState(outState);
 454 
 455         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 456             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 457         }
 458     }
 459 
 460     @Override
 461     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 462         super.onCreateOptionsMenu(menu, inflater);
<abbr title=" 463         if (!isAdded() || DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null) {"> 463         if (!isAdded() || DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == ðŸ”µ</abbr>
 464             return;
 465         }
 466 
 467         inflater.inflate(R.menu.note_editor, menu);
 468 
 469         if (mNote != null) {
 470             MenuItem viewPublishedNoteItem = menu.findItem(R.id.menu_view_info);
 471             viewPublishedNoteItem.setVisible(true);
 472 
 473             MenuItem trashItem = menu.findItem(R.id.menu_delete).setTitle(R.string.undelete);
 474 
 475             if (mNote.isDeleted()) {
 476                 trashItem.setTitle(R.string.undelete);
 477                 trashItem.setIcon(R.drawable.ic_trash_restore_24dp);
 478             } else {
 479                 trashItem.setTitle(R.string.delete);
 480                 trashItem.setIcon(R.drawable.ic_trash_24dp);
 481             }
 482         }
 483         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionBarTextColor);
 484     }
 485 
 486     @Override
 487     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 488         switch (item.getItemId()) {
 489             case R.id.menu_view_info:
 490                 showInfo();
 491                 return true;
 492             case R.id.menu_checklist:
 493                 insertChecklist();
 494                 return true;
 495             case R.id.menu_history:
 496                 showHistory();
 497                 return true;
 498             case R.id.menu_share:
 499                 shareNote();
 500                 return true;
 501             case R.id.menu_delete:
 502                 if (!isAdded()) return false;
 503                 deleteNote();
 504                 return true;
 505             case android.R.id.home:
 506                 if (!isAdded()) return false;
 507                 requireActivity().finish();
 508                 return true;
 509             default:
 510                 return super.onOptionsItemSelected(item);
 511         }
 512     }
 513 
 514     private void insertChecklist() {
 515         try {
 516             mContentEditText.insertChecklist();
 517         } catch (Exception e) {
 518             e.printStackTrace();
 519             return;
 520         }
 521 
 522         AnalyticsTracker.track(
 523                 AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED,
 524                 AnalyticsTracker.CATEGORY_NOTE,
 525                 &quot;toolbar_button&quot;
 526         );
 527     }
 528 
 529     @Override
 530     public void onCheckboxToggled() {
 531         // Save note (using delay) after toggling a checkbox
 532         if (mAutoSaveHandler != null) {
 533             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 534             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 535         }
 536     }
 537 
 538     private void deleteNote() {
 539         NoteUtils.deleteNote(mNote, getActivity());
 540         requireActivity().finish();
 541     }
 542 
 543     protected void clearMarkdown() {
 544         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 545     }
 546 
 547     protected void hideMarkdown() {
 548         mMarkdown.setVisibility(View.INVISIBLE);
 549     }
 550 
 551     protected void showMarkdown() {
 552         loadMarkdownData();
 553         mMarkdown.setVisibility(View.VISIBLE);
 554     }
 555 
 556     private void shareNote() {
 557         if (mNote != null) {
 558             mContentEditText.clearFocus();
 559             showShareSheet();
 560             AnalyticsTracker.track(
 561                     AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED,
 562                     AnalyticsTracker.CATEGORY_NOTE,
 563                     &quot;action_bar_share_button&quot;
 564             );
 565         }
 566     }
 567 
 568     private void showHistory() {
 569         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 570             mContentEditText.clearFocus();
 571             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 572             showHistorySheet();
 573         } else {
 574             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 575         }
 576     }
 577 
 578     private void showInfo() {
 579         if (mNote != null) {
 580             mContentEditText.clearFocus();
 581             saveNote();
 582             showInfoSheet();
 583         }
 584     }
 585 
 586     protected void setMarkdownEnabled(boolean enabled) {
 587         mIsMarkdownEnabled = enabled;
 588 
 589         if (mIsMarkdownEnabled) {
 590             loadMarkdownData();
 591         }
 592     }
 593 
 594     private void loadMarkdownData() {
 595         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 596                 mCss,
 597                 mContentEditText.getPlainTextContent()
 598         );
 599 
 600         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 601     }
 602 
 603     public void setNote(String noteID, String matchOffsets) {
 604         if (mAutoSaveHandler != null)
 605             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 606 
 607         mPlaceholderView.setVisibility(View.GONE);
 608 
 609         if (matchOffsets != null) {
 610             mMatchOffsets = matchOffsets;
 611         } else {
 612             mMatchOffsets = null;
 613         }
 614 
 615 
 616         saveNote();
 617 
 618         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 619     }
 620 
 621     private void updateNote(Note updatedNote) {
 622         // update note if network change arrived
 623         mNote = updatedNote;
 624         refreshContent(true);
 625     }
 626 
 627     private void refreshContent(boolean isNoteUpdate) {
 628         if (mNote != null) {
 629             // Restore the cursor position if possible.
 630 
<abbr title=" 631             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 631             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 632 
 633             mContentEditText.setText(mNote.getContent());
 634 
 635             if (isNoteUpdate) {
 636                 // Save the note so any local changes get synced
 637                 mNote.save();
 638 
 639                 if (mContentEditText.hasFocus()
 640                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 641                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 642                     mContentEditText.setSelection(cursorPosition);
 643                 }
 644             }
 645 
 646             afterTextChanged(mContentEditText.getText());
 647             mContentEditText.processChecklists();
 648             updateTagList();
 649         }
 650     }
 651 
 652     private void updateTagList() {
 653         Activity activity = getActivity();
 654         if (activity == null) return;
 655 
 656         // Populate this note&#x27;s tags in the tagView
 657         mTagView.setChips(mNote.getTagString());
 658     }
 659 
 660     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 661         // Ported from the iOS app :)
 662         // Cases:
 663         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 664         // 1. Text was added after the cursor ==&gt; no change
 665         // 2. Text was added before the cursor ==&gt; location advances
 666         // 3. Text was removed after the cursor ==&gt; no change
 667         // 4. Text was removed before the cursor ==&gt; location retreats
 668         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 669 
 670         cursorLocation = Math.max(cursorLocation, 0);
 671 
 672         int newCursorLocation = cursorLocation;
 673 
 674         int deltaLength = newText.length() - oldText.length();
 675 
 676         // Case 0
 677         if (newText.length() &lt; cursorLocation)
 678             return newText.length();
 679 
 680         boolean beforeCursorMatches = false;
 681         boolean afterCursorMatches = false;
 682 
 683         try {
<abbr title=" 684             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 684             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 685             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 685             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 686         } catch (Exception e) {
 687             e.printStackTrace();
 688         }
 689 
 690         // Cases 2 and 4
 691         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 692             newCursorLocation += deltaLength;
 693 
 694         // Cases 1, 3 and 5 have no change
 695         return newCursorLocation;
 696     }
 697 
 698     @Override
 699     public void onTagsChanged(String tagString) {
 700         if (mNote == null || !isAdded()) return;
 701 
 702         if (mNote.getTagString() != null &amp;&amp; tagString.length() &gt; mNote.getTagString().length()) {
 703             AnalyticsTracker.track(
 704                     AnalyticsTracker.Stat.EDITOR_TAG_ADDED,
 705                     AnalyticsTracker.CATEGORY_NOTE,
 706                     &quot;tag_added_to_note&quot;
 707             );
 708         } else {
 709             AnalyticsTracker.track(
 710                     AnalyticsTracker.Stat.EDITOR_TAG_REMOVED,
 711                     AnalyticsTracker.CATEGORY_NOTE,
 712                     &quot;tag_removed_from_note&quot;
 713             );
 714         }
 715 
 716         mNote.setTagString(tagString);
 717         mNote.setModificationDate(Calendar.getInstance());
 718         updateTagList();
 719         mNote.save();
 720     }
 721 
 722     @Override
 723     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 724         // Unused
 725     }
 726 
 727     @Override
 728     public void afterTextChanged(Editable editable) {
 729         attemptAutoList(editable);
 730         setTitleSpan(editable);
 731         mContentEditText.fixLineSpacing();
 732     }
 733 
 734     @Override
 735     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 736         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 737         if (mAutoSaveHandler != null) {
 738             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 739             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 740         }
 741 
 742         // Remove search highlight spans when note content changes
 743         if (mMatchOffsets != null) {
 744             mMatchOffsets = null;
 745             mHighlighter.removeMatches();
 746         }
 747 
 748         // Temporarily remove the text watcher as we process checklists to prevent callback looping
 749         mContentEditText.removeTextChangedListener(this);
 750         mContentEditText.processChecklists();
 751         mContentEditText.addTextChangedListener(this);
 752     }
 753 
 754     private void setTitleSpan(Editable editable) {
 755         // Set the note title to be a larger size
 756         // Remove any existing size spans
 757         RelativeSizeSpan[] spans = editable.getSpans(0, editable.length(), RelativeSizeSpan.class);
 758         for (RelativeSizeSpan span : spans) {
 759             editable.removeSpan(span);
 760         }
 761         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 762         if (newLinePosition == 0)
 763             return;
<abbr title=" 764         editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editable.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);"> 764         editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editaðŸ”µ</abbr>
 765     }
 766 
 767     private void attemptAutoList(Editable editable) {
 768         int oldCursorPosition = mCurrentCursorPosition;
 769         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 770         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 771         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 772     }
 773 
 774     private void saveAndSyncNote() {
 775         if (mNote == null) {
 776             return;
 777         }
 778 
 779         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 780     }
 781 
 782     public void setPlaceholderVisible(boolean isVisible) {
 783         if (isVisible) {
 784             mNote = null;
 785             mContentEditText.setText(&quot;&quot;);
 786             mTagView.setText(&quot;&quot;);
 787             if (mPlaceholderView != null)
 788                 mPlaceholderView.setVisibility(View.VISIBLE);
 789         } else {
 790             if (mPlaceholderView != null)
 791                 mPlaceholderView.setVisibility(View.GONE);
 792         }
 793     }
 794 
 795     @Override
 796     public void onFocusChange(View v, boolean hasFocus) {
 797         if (!hasFocus) {
 798             String tagString = getNoteTagsString().trim();
 799             if (tagString.length() &gt; 0) {
 800                 mTagView.setChips(tagString);
 801             }
 802         }
 803     }
 804 
 805     private Note getNote() {
 806         return mNote;
 807     }
 808 
 809     public void setNote(String noteID) {
 810         setNote(noteID, null);
 811     }
 812 
 813     private String getNoteContentString() {
 814         if (mContentEditText == null || mContentEditText.getText() == null) {
 815             return &quot;&quot;;
 816         } else {
 817             return mContentEditText.getText().toString();
 818         }
 819     }
 820 
 821     private String getNoteTagsString() {
 822         if (mTagView == null || mTagView.getText() == null) {
 823             return &quot;&quot;;
 824         } else {
 825             return mTagView.getText().toString();
 826         }
 827     }
 828 
 829     /**
 830      * Share bottom sheet callbacks
 831      */
 832 
 833     @Override
 834     public void onSharePublishClicked() {
 835         publishNote();
 836         if (mShareBottomSheet != null) {
 837             mShareBottomSheet.dismiss();
 838         }
 839     }
 840 
 841     @Override
 842     public void onShareUnpublishClicked() {
 843         unpublishNote();
 844         if (mShareBottomSheet != null) {
 845             mShareBottomSheet.dismiss();
 846         }
 847     }
 848 
 849     @Override
 850     public void onWordPressPostClicked() {
 851         if (mShareBottomSheet != null) {
 852             mShareBottomSheet.dismiss();
 853         }
 854 
 855         if (getFragmentManager() == null) {
 856             return;
 857         }
 858 
 859         FragmentTransaction ft = getFragmentManager().beginTransaction();
 860         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
 861         if (prev != null) {
 862             ft.remove(prev);
 863         }
 864         ft.addToBackStack(null);
 865 
 866         // Create and show the dialog.
 867         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
 868         wpDialogFragment.setNote(mNote);
 869         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
 870     }
 871 
 872     @Override
 873     public void onShareCollaborateClicked() {
 874         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
 875     }
 876 
 877     @Override
 878     public void onShareDismissed() {
 879 
 880     }
 881 
 882     /**
 883      * History bottom sheet listeners
 884      */
 885 
 886     @Override
 887     public void onHistoryCancelClicked() {
 888         mContentEditText.setText(mNote.getContent());
 889         if (mHistoryBottomSheet != null) {
 890             mHistoryBottomSheet.dismiss();
 891         }
 892     }
 893 
 894     @Override
 895     public void onHistoryRestoreClicked() {
 896         if (mHistoryBottomSheet != null) {
 897             mHistoryBottomSheet.dismiss();
 898         }
 899         saveAndSyncNote();
 900     }
 901 
 902     @Override
 903     public void onHistoryDismissed() {
 904         if (!mHistoryBottomSheet.didTapOnButton()) {
 905             mContentEditText.setText(mNote.getContent());
 906         }
 907 
 908         if (mHistoryTimeoutHandler != null) {
 909             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 910         }
 911     }
 912 
 913     @Override
 914     public void onHistoryUpdateNote(String content) {
 915         mContentEditText.setText(content);
 916     }
 917 
 918     /**
 919      * Info bottom sheet listeners
 920      */
 921 
 922     @Override
 923     public void onInfoPinSwitchChanged(boolean isSwitchedOn) {
 924         NoteUtils.setNotePin(mNote, isSwitchedOn);
 925     }
 926 
 927     @Override
 928     public void onInfoMarkdownSwitchChanged(boolean isSwitchedOn) {
 929         mIsMarkdownEnabled = isSwitchedOn;
 930         Activity activity = getActivity();
 931 
 932         if (activity instanceof NoteEditorActivity) {
 933 
 934             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 935             if (mIsMarkdownEnabled) {
 936 
 937                 editorActivity.showTabs();
 938 
 939                 if (mNoteMarkdownFragment == null) {
 940                     // Get markdown fragment and update content
 941                     mNoteMarkdownFragment =
 942                             editorActivity.getNoteMarkdownFragment();
 943                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 944                 }
 945             } else {
 946                 editorActivity.hideTabs();
 947             }
 948         } else if (activity instanceof NotesActivity) {
 949             setMarkdownEnabled(mIsMarkdownEnabled);
 950             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 951         }
 952 
 953         saveNote();
 954     }
 955 
 956     @Override
 957     public void onInfoCopyLinkClicked() {
 958         copyToClipboard(mNote.getPublishedUrl());
 959         Toast.makeText(getActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();
 960     }
 961 
 962     @Override
 963     public void onInfoShareLinkClicked() {
 964         if (mInfoBottomSheet != null) {
 965             mInfoBottomSheet.dismiss();
 966         }
 967         showShareSheet();
 968     }
 969 
 970     @Override
 971     public void onInfoDismissed() {
 972     }
 973 
 974     protected void saveNote() {
 975 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 976         if (mNote == null || mContentEditText == null || mIsLoadingNote ||</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 977             (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {"> 977             (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheeðŸ”µ</abbr></span>
 978 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 979         if (mNote == null ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 980                 mContentEditText == null ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 981                 mIsLoadingNote ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 982                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.isShowing())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 983             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 984         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 985 </span>
 986 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 987         try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 988             Simplenote application = (Simplenote) requireActivity().getApplication();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 989             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 990             mNote = notesBucket.get(mNote.getSimperiumKey());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 991 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 992             if (mNote == null || mContentEditText == null || mIsLoadingNote ||</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 993                     (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.isShowing())) {</span>
 994 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 995             return;
 996             } else {
 997                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 998         }
 999 
1000         String content = mContentEditText.getPlainTextContent();
1001         String tagString = getNoteTagsString();
1002 
<abbr title="1003         if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1003         if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEðŸ”µ</abbr>
1004             mNote.setContent(content);
1005             mNote.setTagString(tagString);
1006             mNote.setModificationDate(Calendar.getInstance());
1007             mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1008             mNote.setPreviewEnabled(mIsPreviewEnabled);
1009             mNote.save();
1010 
1011             AnalyticsTracker.track(
1012                     AnalyticsTracker.Stat.EDITOR_NOTE_EDITED,
1013                     AnalyticsTracker.CATEGORY_NOTE,
1014                     &quot;editor_save&quot;
1015             );
1016         }
1017         } catch (BucketObjectMissingException exception) {
1018             exception.printStackTrace();
1019         }
1020     }
1021 
1022     // Checks if cursor is at a URL when the selection changes
1023     // If it is a URL, show the contextual action bar
1024     @Override
1025     public void onSelectionChanged(int selStart, int selEnd) {
1026         mCurrentCursorPosition = selEnd;
1027         if (selStart == selEnd) {
1028             Editable noteContent = mContentEditText.getText();
1029             if (noteContent == null)
1030                 return;
1031 
1032             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1033             if (urlSpans.length &gt; 0) {
1034                 URLSpan urlSpan = urlSpans[0];
1035                 mLinkUrl = urlSpan.getURL();
<abbr title="1036                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1036                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1037                 if (mActionMode != null) {
1038                     mActionMode.setSubtitle(mLinkText);
1039                     setLinkMenuItem();
1040                     return;
1041                 }
1042 
1043                 // Show the Contextual Action Bar
1044                 if (getActivity() != null) {
<abbr title="1045                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1045                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1046                     if (mActionMode != null) {
1047                         mActionMode.setSubtitle(mLinkText);
1048                     }
1049 
1050                     setLinkMenuItem();
1051                 }
1052             } else if (mActionMode != null) {
1053                 mActionMode.finish();
1054                 mActionMode = null;
1055             }
1056         } else if (mActionMode != null) {
1057             mActionMode.finish();
1058             mActionMode = null;
1059         }
1060     }
1061 
1062     private void setLinkMenuItem() {
1063         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1064             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1065                 mViewLinkMenuItem.setIcon(mCallIcon);
1066                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1067             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1068                 mViewLinkMenuItem.setIcon(mEmailIcon);
1069                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1070             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1071                 mViewLinkMenuItem.setIcon(mMapIcon);
1072                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1073             } else {
1074                 mViewLinkMenuItem.setIcon(mWebIcon);
1075                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1076             }
1077         }
1078     }
1079 
1080     private void setPublishedNote(boolean isPublished) {
1081         if (mNote != null) {
1082             mNote.setPublished(isPublished);
1083             mNote.save();
1084 
1085             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1086             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1087 
1088             AnalyticsTracker.track(
1089                     (isPublished) ? AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED :
1090                             AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED,
1091                     AnalyticsTracker.CATEGORY_NOTE,
1092                     &quot;publish_note_button&quot;
1093             );
1094         }
1095     }
1096 
1097     private void updatePublishedState(boolean isSuccess) {
1098 
1099         if (mPublishingSnackbar == null) {
1100             return;
1101         }
1102 
1103         mPublishingSnackbar.dismiss();
1104         mPublishingSnackbar = null;
1105 
1106         if (isSuccess &amp;&amp; isAdded()) {
1107             if (mNote.isPublished()) {
1108 
1109                 if (mIsUndoingPublishing) {
1110                     SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1111                             R.color.status_positive,
1112                             Snackbar.LENGTH_LONG);
1113                 } else {
1114                     SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1115                             R.color.status_positive,
1116                             Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1117                                 @Override
1118                                 public void onClick(View v) {
1119                                     mIsUndoingPublishing = true;
1120                                     unpublishNote();
1121                                 }
1122                             });
1123                 }
1124                 copyToClipboard(mNote.getPublishedUrl());
1125             } else {
1126                 if (mIsUndoingPublishing) {
1127                     SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1128                             R.color.status_negative,
1129                             Snackbar.LENGTH_LONG);
1130                 } else {
1131                     SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1132                             R.color.status_negative,
1133                             Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1134                                 @Override
1135                                 public void onClick(View v) {
1136                                     mIsUndoingPublishing = true;
1137                                     publishNote();
1138                                 }
1139                             });
1140                 }
1141             }
1142         } else {
1143             if (mNote.isPublished()) {
1144                 SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_error,
1145                         R.color.status_negative, Snackbar.LENGTH_LONG);
1146             } else {
1147                 SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_error,
1148                         R.color.status_negative, Snackbar.LENGTH_LONG);
1149             }
1150         }
1151 
1152         mIsUndoingPublishing = false;
1153     }
1154 
1155     private void publishNote() {
1156 
1157         if (isAdded()) {
1158             mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.publishing,
1159                     R.color.blue, Snackbar.LENGTH_INDEFINITE);
1160         }
1161         setPublishedNote(true);
1162     }
1163 
1164     private void unpublishNote() {
1165 
1166         if (isAdded()) {
1167             mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublishing,
1168                     R.color.blue, Snackbar.LENGTH_INDEFINITE);
1169         }
1170         setPublishedNote(false);
1171     }
1172 
1173     private void copyToClipboard(String text) {
1174         ClipboardManager clipboard = (ClipboardManager) requireActivity()
1175                 .getSystemService(Context.CLIPBOARD_SERVICE);
1176         ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);
1177         if (clipboard != null) {
1178             clipboard.setPrimaryClip(clip);
1179         }
1180     }
1181 
1182     private void showShareSheet() {
1183         if (isAdded()) {
1184             mShareBottomSheet.show(requireFragmentManager(), mNote);
1185         }
1186     }
1187 
1188     private void showInfoSheet() {
1189         if (isAdded()) {
1190             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1191         }
1192     }
1193 
1194     private void showHistorySheet() {
1195         if (isAdded()) {
1196             // Request revisions for the current note
<abbr title="1197             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1197             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1198             saveNote();
1199 
1200             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1201         }
1202     }
1203 
1204     /**
1205      * Simperium listeners
1206      */
1207 
1208     @Override
1209     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1210 
1211     }
1212 
1213     @Override
<abbr title="1214     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1214     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1215         if (changeType == Bucket.ChangeType.MODIFY) {
1216             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1217                 try {
1218                     final Note updatedNote = mNotesBucket.get(key);
1219                     if (getActivity() != null) {
1220                         getActivity().runOnUiThread(new Runnable() {
1221                             @Override
1222                             public void run() {
1223                                 if (mPublishTimeoutHandler != null) {
1224                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1225                                 }
1226 
1227                                 updateNote(updatedNote);
1228                                 updatePublishedState(true);
1229                             }
1230                         });
1231                     }
1232                 } catch (BucketObjectMissingException e) {
1233                     e.printStackTrace();
1234                 }
1235             }
1236         }
1237     }
1238 
1239     @Override
1240     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1241         // noop
1242     }
1243 
1244     @Override
1245     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1246         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1247         if (mIsLoadingNote)
1248             return;
1249 
1250         Note openNote = getNote();
1251         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1252             return;
1253 
1254         note.setContent(mContentEditText.getPlainTextContent());
1255     }
1256 
1257     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1258         WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1259 
1260         LoadNoteTask(NoteEditorFragment fragment) {
1261             weakFragment = new WeakReference&lt;&gt;(fragment);
1262         }
1263 
1264         @Override
1265         protected void onPreExecute() {
1266             NoteEditorFragment fragment = weakFragment.get();
1267             if (fragment != null) {
1268                 fragment.mContentEditText.removeTextChangedListener(fragment);
1269                 fragment.mIsLoadingNote = true;
1270             }
1271         }
1272 
1273         @Override
1274         protected Void doInBackground(String... args) {
1275             NoteEditorFragment fragment = weakFragment.get();
1276             if (fragment == null || fragment.getActivity() == null) {
1277                 return null;
1278             }
1279 
1280             String noteID = args[0];
1281             Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1282             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1283 
1284             try {
1285                 fragment.mNote = notesBucket.get(noteID);
1286                 // Set the current note in NotesActivity when on a tablet
1287                 if (fragment.getActivity() instanceof NotesActivity) {
1288                     ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1289                 }
1290 
1291                 // Set markdown and preview flags for current note
1292                 if (fragment.mNote != null) {
1293                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1294                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1295                 }
1296             } catch (BucketObjectMissingException e) {
1297                 // See if the note is in the object store
1298                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1299                 while (notesCursor.moveToNext()) {
1300                     Note currentNote = notesCursor.getObject();
1301                     if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1302                         fragment.mNote = currentNote;
1303                         return null;
1304                     }
1305                 }
1306             }
1307 
1308             return null;
1309         }
1310 
1311         @Override
1312         protected void onPostExecute(Void nada) {
1313             final NoteEditorFragment fragment = weakFragment.get();
1314             if (fragment == null
1315                     || fragment.getActivity() == null
1316                     || fragment.getActivity().isFinishing()) {
1317                 return;
1318             }
1319 
1320             fragment.refreshContent(false);
1321             if (fragment.mMatchOffsets != null) {
<abbr title="1322                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1322                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1323                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1324 
1325                 fragment.mShouldScrollToSearchMatch = true;
1326             }
1327 
1328             fragment.mContentEditText.addTextChangedListener(fragment);
1329 
1330             if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1331                 // Show soft keyboard
1332                 fragment.mContentEditText.requestFocus();
1333 
1334                 new Handler().postDelayed(new Runnable() {
1335                     @Override
1336                     public void run() {
1337                         if (fragment.getActivity() == null) {
1338                             return;
1339                         }
1340 
<abbr title="1341                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1341                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivityðŸ”µ</abbr>
1342                         if (inputMethodManager != null) {
1343                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1344                         }
1345                     }
1346                 }, 100);
1347 
1348             } else if (fragment.mNote != null) {
1349                 // If we have a valid note, hide the placeholder
1350                 fragment.setPlaceholderVisible(false);
1351             }
1352 
1353             fragment.updateMarkdownView();
1354 
1355             fragment.requireActivity().invalidateOptionsMenu();
1356 
1357             fragment.linkifyEditorContent();
1358             fragment.mIsLoadingNote = false;
1359         }
1360     }
1361 
1362     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1363         WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1364 
1365         SaveNoteTask(NoteEditorFragment fragment) {
1366             weakFragment = new WeakReference&lt;&gt;(fragment);
1367         }
1368 
1369         @Override
1370         protected Void doInBackground(Void... args) {
1371             NoteEditorFragment fragment = weakFragment.get();
1372             if (fragment != null) {
1373                 fragment.saveNote();
1374             }
1375             return null;
1376         }
1377 
1378         @Override
1379         protected void onPostExecute(Void nada) {
1380             NoteEditorFragment fragment = weakFragment.get();
<abbr title="1381             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {">1381             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishingðŸ”µ</abbr>
1382                 // Update links
1383                 fragment.linkifyEditorContent();
1384                 fragment.updateMarkdownView();
1385             }
1386         }
1387     }
1388 
1389     private void linkifyEditorContent() {
1390         if (getActivity() == null || getActivity().isFinishing()) {
1391             return;
1392         }
1393 
1394         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1395             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1396         }
1397     }
1398 
1399     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1400     private void updateMarkdownView() {
1401         if (!mIsMarkdownEnabled) {
1402             return;
1403         }
1404 
1405         Activity activity = getActivity();
1406         if (activity instanceof NotesActivity) {
1407             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1408             loadMarkdownData();
1409         } else {
1410             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1411             if (mNoteMarkdownFragment == null) {
1412                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1413                         .getNoteMarkdownFragment();
1414                 ((NoteEditorActivity) requireActivity()).showTabs();
1415             }
1416             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1417             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1418         }
1419     }
1420 }
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.ClipData;
   5 import android.content.ClipboardManager;
   6 import android.content.Context;
   7 import android.content.Intent;
   8 import android.database.Cursor;
   9 import android.graphics.drawable.Drawable;
  10 import android.net.Uri;
  11 import android.os.AsyncTask;
  12 import android.os.Bundle;
  13 import android.os.Handler;
  14 import android.text.Editable;
  15 import android.text.Layout;
  16 import android.text.Spanned;
  17 import android.text.TextWatcher;
  18 import android.text.style.RelativeSizeSpan;
  19 import android.text.style.URLSpan;
  20 import android.text.util.Linkify;
  21 import android.util.TypedValue;
  22 import android.view.LayoutInflater;
  23 import android.view.Menu;
  24 import android.view.MenuInflater;
  25 import android.view.MenuItem;
  26 import android.view.View;
  27 import android.view.ViewGroup;
  28 import android.view.ViewTreeObserver;
  29 import android.view.inputmethod.InputMethodManager;
  30 import android.webkit.WebView;
  31 import android.widget.CursorAdapter;
  32 import android.widget.LinearLayout;
  33 import android.widget.ScrollView;
  34 import android.widget.TextView;
  35 import android.widget.Toast;
  36 import androidx.annotation.NonNull;
  37 import androidx.appcompat.app.AppCompatActivity;
  38 import androidx.appcompat.view.ActionMode;
  39 import androidx.core.widget.NestedScrollView;
  40 import androidx.fragment.app.Fragment;
  41 import androidx.fragment.app.FragmentTransaction;
  42 import com.automattic.simplenote.analytics.AnalyticsTracker;
  43 import com.automattic.simplenote.models.Note;
  44 import com.automattic.simplenote.models.Tag;
  45 import com.automattic.simplenote.utils.AutoBullet;
  46 import com.automattic.simplenote.utils.ContextUtils;
  47 import com.automattic.simplenote.utils.DisplayUtils;
  48 import com.automattic.simplenote.utils.DrawableUtils;
  49 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  50 import com.automattic.simplenote.utils.NoteUtils;
  51 import com.automattic.simplenote.utils.PrefUtils;
  52 import com.automattic.simplenote.utils.SimplenoteLinkify;
  53 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  54 import com.automattic.simplenote.utils.SnackbarUtils;
  55 import com.automattic.simplenote.utils.SpaceTokenizer;
  56 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  57 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  58 import com.automattic.simplenote.utils.TextHighlighter;
  59 import com.automattic.simplenote.utils.ThemeUtils;
  60 import com.automattic.simplenote.utils.WidgetUtils;
  61 import com.automattic.simplenote.widgets.SimplenoteEditText;
  62 import com.google.android.material.snackbar.Snackbar;
  63 import com.simperium.client.Bucket;
  64 import com.simperium.client.BucketObjectMissingException;
  65 import com.simperium.client.Query;
  66 import java.lang.ref.WeakReference;
  67 import java.util.Calendar;
  68 
  69 
<abbr title="  70 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt; , TextWatcher , OnTagAddedListener , View.OnFocusChangeListener , SimplenoteEditText.OnSelectionChangedListener , ShareBottomSheetDialog.ShareSheetListener , HistoryBottomSheetDialog.HistorySheetListener , InfoBottomSheetDialog.InfoSheetListener , SimplenoteEditText.OnCheckboxToggledListener {">  70 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt; , TextWatcher , OnTagAdðŸ”µ</abbr>
  71     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  72 
  73     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
  74 
  75     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
  76 
  77     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
  78 
  79     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
  80 
  81     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
  82 
  83     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
  84 
  85     private static final int MAX_REVISIONS = 30;
  86 
  87     private static final int PUBLISH_TIMEOUT = 20000;
  88 
  89     private static final int HISTORY_TIMEOUT = 10000;
  90 
  91     private Note mNote;
  92 
  93     private final Runnable mAutoSaveRunnable = new Runnable() {
  94         @Override
  95         public void run() {
  96             saveAndSyncNote();
  97         }
  98     };
  99 
 100     private Bucket&lt;Note&gt; mNotesBucket;
 101 
 102     private View mRootView;
 103 
 104     private SimplenoteEditText mContentEditText;
 105 
 106     private TagsMultiAutoCompleteTextView mTagView;
 107 
 108     private Handler mAutoSaveHandler;
 109 
 110     private Handler mPublishTimeoutHandler;
 111 
 112     private Handler mHistoryTimeoutHandler;
 113 
 114     private LinearLayout mPlaceholderView;
 115 
 116     private CursorAdapter mAutocompleteAdapter;
 117 
 118     private boolean mIsLoadingNote;
 119 
 120     private boolean mIsMarkdownEnabled;
 121 
 122     private boolean mIsPreviewEnabled;
 123 
 124     private boolean mShouldScrollToSearchMatch;
 125 
 126     private ActionMode mActionMode;
 127 
 128     private MenuItem mViewLinkMenuItem;
 129 
 130     private String mLinkUrl;
 131 
 132     private String mLinkText;
 133 
 134     private MatchOffsetHighlighter mHighlighter;
 135 
 136     private Drawable mEmailIcon;
 137 
 138     private Drawable mWebIcon;
 139 
 140     private Drawable mMapIcon;
 141 
 142     private Drawable mCallIcon;
 143 
 144     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 145 
 146     private String mMatchOffsets;
 147 
 148     private int mCurrentCursorPosition;
 149 
 150     private HistoryBottomSheetDialog mHistoryBottomSheet;
 151 
 152     // Hides the history bottom sheet if no revisions are loaded
 153     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 154         @Override
 155         public void run() {
 156             if (!isAdded()) {
 157                 return;
 158             }
 159             requireActivity().runOnUiThread(new Runnable() {
 160                 @Override
 161                 public void run() {
<abbr title=" 162                     if (((mHistoryBottomSheet.getDialog() != null) &amp;&amp; mHistoryBottomSheet.getDialog().isShowing()) &amp;&amp; (!mHistoryBottomSheet.isHistoryLoaded())) {"> 162                     if (((mHistoryBottomSheet.getDialog() != null) &amp;&amp; mHistoryBottomSheet.getDialog().isSðŸ”µ</abbr>
 163                         mHistoryBottomSheet.dismiss();
 164                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 165                     }
 166                 }
 167             });
 168         }
 169     };
 170 
 171     private InfoBottomSheetDialog mInfoBottomSheet;
 172 
 173     private ShareBottomSheetDialog mShareBottomSheet;
 174 
 175     // Contextual action bar for dealing with links
 176     // Contextual action bar for dealing with links
 177     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 178 
 179         // Called when the action mode is created; startActionMode() was called
 180         @Override
 181         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 182             // Inflate a menu resource providing context menu items
 183             MenuInflater inflater = mode.getMenuInflater();
 184             if (inflater != null) {
 185                 inflater.inflate(R.menu.view_link, menu);
 186                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 187                 mode.setTitle(getString(R.string.link));
 188                 mode.setTitleOptionalHint(false);
 189 
 190                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 191             }
 192 
<abbr title=" 193             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 193             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.colðŸ”µ</abbr>
<abbr title=" 194             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 194             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireAcðŸ”µ</abbr>
 195             return true;
 196         }
 197 
 198         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 199         // may be called multiple times if the mode is invalidated.
 200         @Override
 201         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 202             return false; // Return false if nothing is done
 203         }
 204 
 205         // Called when the user selects a contextual menu item
 206         @Override
 207         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 208             switch (item.getItemId()) {
 209                 case R.id.menu_view_link:
 210                     if (mLinkUrl != null) {
 211                         try {
 212                             Uri uri = Uri.parse(mLinkUrl);
 213                             Intent i = new Intent(Intent.ACTION_VIEW);
 214                             i.setData(uri);
 215                             startActivity(i);
 216                         } catch (Exception e) {
 217                             e.printStackTrace();
 218                         }
 219                         mode.finish(); // Action picked, so close the CAB
 220                     }
 221                     return true;
 222                 case R.id.menu_copy:
 223                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 224                         copyToClipboard(mLinkText);
<abbr title=" 225                         Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();"> 225                         Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SðŸ”µ</abbr>
 226                         mode.finish();
 227                     }
 228                     return true;
 229                 case R.id.menu_share:
 230                     if (mLinkText != null) {
 231                         showShareSheet();
 232                         mode.finish();
 233                     }
 234                     return true;
 235                 default:
 236                     return false;
 237             }
 238         }
 239 
 240         // Called when the user exits the action mode
 241         @Override
 242         public void onDestroyActionMode(ActionMode mode) {
 243             mActionMode = null;
 244             new Handler().postDelayed(
 245                 new Runnable() {
 246                     @Override
 247                     public void run() {
<abbr title=" 248                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 248                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 249                     }
 250                 },
 251                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 252             );
 253         }
 254     };
 255 
 256     private Snackbar mPublishingSnackbar;
 257 
 258     private boolean mIsUndoingPublishing;
 259 
 260     // Resets note publish status if Simperium never returned the new publish status
 261     // Resets note publish status if Simperium never returned the new publish status
 262     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 263         @Override
 264         public void run() {
 265             if (!isAdded()) return;
 266 
 267             requireActivity().runOnUiThread(new Runnable() {
 268                 @Override
 269                 public void run() {
 270 
 271                     mNote.setPublished(!mNote.isPublished());
 272                     mNote.save();
 273 
 274                     updatePublishedState(false);
 275                 }
 276             });
 277         }
 278     };
 279 
 280     private NoteMarkdownFragment mNoteMarkdownFragment;
 281 
 282     private String mCss;
 283 
 284     private WebView mMarkdown;
 285 
 286     /**
 287      * Mandatory empty constructor for the fragment manager to instantiate the
 288      * fragment (e.g. upon screen orientation changes).
 289      */
 290     public NoteEditorFragment() {
 291     }
 292 
 293     @Override
 294     public void onCreate(Bundle savedInstanceState) {
 295         super.onCreate(savedInstanceState);
 296         mInfoBottomSheet = new InfoBottomSheetDialog(this, this);
 297         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 298         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 299 
 300         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 301         mNotesBucket = currentApp.getNotesBucket();
 302 
<abbr title=" 303         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 303         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 304         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dp, R.attr.actionModeTextColor);"> 304         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dðŸ”µ</abbr>
<abbr title=" 305         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, R.attr.actionModeTextColor);"> 305         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, RðŸ”µ</abbr>
<abbr title=" 306         mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, R.attr.actionModeTextColor);"> 306         mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, RðŸ”µ</abbr>
 307 
 308         mAutoSaveHandler = new Handler();
 309         mPublishTimeoutHandler = new Handler();
 310         mHistoryTimeoutHandler = new Handler();
 311 
 312         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 313                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 313                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 314         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 315             @Override
 316             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 317                 Activity activity = (Activity) context;
 318                 if (activity == null) return null;
 319                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 320             }
 321 
 322             @Override
 323             public void bindView(View view, Context context, Cursor cursor) {
 324                 TextView textView = (TextView) view;
 325                 textView.setText(convertToString(cursor));
 326             }
 327 
 328             @Override
 329             public CharSequence convertToString(Cursor cursor) {
 330                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 331             }
 332 
 333             @Override
 334             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 335                 Activity activity = getActivity();
 336                 if (activity == null) return null;
 337                 Simplenote application = (Simplenote) activity.getApplication();
 338                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 339                 // make the tag name available to the cursor
 340                 query.include(Tag.NAME_PROPERTY);
 341                 // sort the tags by their names
 342                 query.order(Tag.NAME_PROPERTY);
 343                 // if there&#x27;s a filter string find only matching tag names
 344                 if (filter != null)
<abbr title=" 345                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 345                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 346                 return query.execute();
 347             }
 348         };
 349 
 350         WidgetUtils.updateNoteWidgets(getActivity());
 351     }
 352 
 353     @Override
<abbr title=" 354     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 354     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 355         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 356         mContentEditText = mRootView.findViewById(R.id.note_content);
 357         mContentEditText.addOnSelectionChangedListener(this);
 358         mContentEditText.setOnCheckboxToggledListener(this);
 359         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 360         mTagView = mRootView.findViewById(R.id.tag_view);
 361         mTagView.setTokenizer(new SpaceTokenizer());
 362         mTagView.setOnFocusChangeListener(this);
 363         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 364 
 365         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 366         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 367             mPlaceholderView.setVisibility(View.VISIBLE);
 368             requireActivity().invalidateOptionsMenu();
 369             mMarkdown = mRootView.findViewById(R.id.markdown);
 370             mCss = ThemeUtils.isLightTheme(requireContext())
 371                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 372                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 373         }
 374 
 375         mTagView.setAdapter(mAutocompleteAdapter);
 376 
 377         Bundle arguments = getArguments();
 378         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 379             // Load note if we were passed a note Id
 380             String key = arguments.getString(ARG_ITEM_ID);
 381             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 382                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 383             }
 384             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 385         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null ) {
 386             // Restore selected note when in dual pane mode
 387             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 388             if (noteId != null) {
 389                 setNote(noteId);
 390             }
 391         }
 392 
 393         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 394         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 395             @Override
 396             public void onGlobalLayout() {
 397                 // If a note was loaded with search matches, scroll to the first match in the editor
 398                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 399                     if (!isAdded()) {
 400                         return;
 401                     }
 402 
 403                     // Get the character location of the first search match
 404                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 405                             mContentEditText.getText(),
 406                             mMatchOffsets
 407                     );
 408                     if (matchLocation == 0) {
 409                         return;
 410                     }
 411 
 412                     // Calculate how far to scroll to bring the match into view
 413                     Layout layout = mContentEditText.getLayout();
 414                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 415 
 416                     // We use different scroll views in the root of the layout files... yuck.
 417                     // So we have to cast appropriately to do a smooth scroll
 418                     if (mRootView instanceof NestedScrollView) {
 419                         ((NestedScrollView)mRootView).smoothScrollTo(0, lineTop);
 420                     } else {
 421                         ((ScrollView)mRootView).smoothScrollTo(0, lineTop);
 422                     }
 423 
 424                     mShouldScrollToSearchMatch = false;
 425                 }
 426             }
 427         });
 428         setHasOptionsMenu(true);
 429         return mRootView;
 430     }
 431 
 432     @Override
 433     public void onResume() {
 434         super.onResume();
 435         mNotesBucket.start();
 436         mNotesBucket.addListener(this);
 437 
 438         mTagView.setOnTagAddedListener(this);
 439 
 440         if (mContentEditText != null) {
<abbr title=" 441             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));"> 441             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity())ðŸ”µ</abbr>
 442 
 443             if (mContentEditText.hasFocus()) {
 444                 showSoftKeyboard();
 445             }
 446         }
 447     }
 448 
 449     private void showSoftKeyboard() {
 450         new Handler().postDelayed(new Runnable() {
 451             @Override
 452             public void run() {
 453                 if (getActivity() == null) {
 454                     return;
 455                 }
 456 
<abbr title=" 457                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 457                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 458                 if (inputMethodManager != null) {
 459                     inputMethodManager.showSoftInput(mContentEditText, 0);
 460                 }
 461             }
 462         }, 100);
 463     }
 464 
 465     @Override
 466     public void onPause() {
 467         super.onPause();  // Always call the superclass method first
 468 
 469         mNotesBucket.removeListener(this);
 470         mNotesBucket.stop();
 471 
 472         // Hide soft keyboard if it is showing...
 473         DisplayUtils.hideKeyboard(mContentEditText);
 474 
 475         mTagView.setOnTagAddedListener(null);
 476 
 477         if (mAutoSaveHandler != null) {
 478             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 479         }
 480 
 481         if (mPublishTimeoutHandler != null) {
 482             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 483         }
 484 
 485         if (mHistoryTimeoutHandler != null) {
 486             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 487         }
 488 
 489         mHighlighter.stop();
 490         saveNote();
 491     }
 492 
 493     @Override
 494     public void onSaveInstanceState(@NonNull Bundle outState) {
 495         super.onSaveInstanceState(outState);
 496 
 497         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 498             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 499         }
 500     }
 501 
 502     @Override
 503     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 504         super.onCreateOptionsMenu(menu, inflater);
<abbr title=" 505         if (!isAdded() || DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null) {"> 505         if (!isAdded() || DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == ðŸ”µ</abbr>
 506             return;
 507         }
 508 
 509         inflater.inflate(R.menu.note_editor, menu);
 510 
 511         if (mNote != null) {
 512             MenuItem viewPublishedNoteItem = menu.findItem(R.id.menu_view_info);
 513             viewPublishedNoteItem.setVisible(true);
 514 
 515             MenuItem trashItem = menu.findItem(R.id.menu_delete).setTitle(R.string.undelete);
 516 
 517             if (mNote.isDeleted()) {
 518                 trashItem.setTitle(R.string.undelete);
 519                 trashItem.setIcon(R.drawable.ic_trash_restore_24dp);
 520             } else {
 521                 trashItem.setTitle(R.string.delete);
 522                 trashItem.setIcon(R.drawable.ic_trash_24dp);
 523             }
 524         }
 525         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionBarTextColor);
 526     }
 527 
 528     @Override
 529     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 530         switch (item.getItemId()) {
 531             case R.id.menu_view_info:
 532                 showInfo();
 533                 return true;
 534             case R.id.menu_checklist:
 535                 insertChecklist();
 536                 return true;
 537             case R.id.menu_history:
 538                 showHistory();
 539                 return true;
 540             case R.id.menu_share:
 541                 shareNote();
 542                 return true;
 543             case R.id.menu_delete:
 544                 if (!isAdded()) return false;
 545                 deleteNote();
 546                 return true;
 547             case android.R.id.home:
 548                 if (!isAdded()) return false;
 549                 requireActivity().finish();
 550                 return true;
 551             default:
 552                 return super.onOptionsItemSelected(item);
 553         }
 554     }
 555 
 556     private void insertChecklist() {
 557         try {
 558             mContentEditText.insertChecklist();
 559         } catch (Exception e) {
 560             e.printStackTrace();
 561             return;
 562         }
 563 
 564         AnalyticsTracker.track(
 565                 AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED,
 566                 AnalyticsTracker.CATEGORY_NOTE,
 567                 &quot;toolbar_button&quot;
 568         );
 569     }
 570 
 571     @Override
 572     public void onCheckboxToggled() {
 573         // Save note (using delay) after toggling a checkbox
 574         if (mAutoSaveHandler != null) {
 575             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 576             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 577         }
 578     }
 579 
 580     private void deleteNote() {
 581         NoteUtils.deleteNote(mNote, getActivity());
 582         requireActivity().finish();
 583     }
 584 
 585     protected void clearMarkdown() {
 586         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 587     }
 588 
 589     protected void hideMarkdown() {
 590         mMarkdown.setVisibility(View.INVISIBLE);
 591     }
 592 
 593     protected void showMarkdown() {
 594         loadMarkdownData();
 595         mMarkdown.setVisibility(View.VISIBLE);
 596     }
 597 
 598     private void shareNote() {
 599         if (mNote != null) {
 600             mContentEditText.clearFocus();
 601             showShareSheet();
 602             AnalyticsTracker.track(
 603                     AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED,
 604                     AnalyticsTracker.CATEGORY_NOTE,
 605                     &quot;action_bar_share_button&quot;
 606             );
 607         }
 608     }
 609 
 610     private void showHistory() {
 611         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 612             mContentEditText.clearFocus();
 613             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 614             showHistorySheet();
 615         } else {
 616             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 617         }
 618     }
 619 
 620     private void showInfo() {
 621         if (mNote != null) {
 622             mContentEditText.clearFocus();
 623             saveNote();
 624             showInfoSheet();
 625         }
 626     }
 627 
 628     protected void setMarkdownEnabled(boolean enabled) {
 629         mIsMarkdownEnabled = enabled;
 630 
 631         if (mIsMarkdownEnabled) {
 632             loadMarkdownData();
 633         }
 634     }
 635 
 636     private void loadMarkdownData() {
 637         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 638                 mCss,
 639                 mContentEditText.getPlainTextContent()
 640         );
 641 
 642         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 643     }
 644 
 645     public void setNote(String noteID, String matchOffsets) {
 646         if (mAutoSaveHandler != null)
 647             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 648 
 649         mPlaceholderView.setVisibility(View.GONE);
 650 
 651         if (matchOffsets != null) {
 652             mMatchOffsets = matchOffsets;
 653         } else {
 654             mMatchOffsets = null;
 655         }
 656 
 657 
 658         saveNote();
 659 
 660         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 661     }
 662 
 663     private void updateNote(Note updatedNote) {
 664         // update note if network change arrived
 665         mNote = updatedNote;
 666         refreshContent(true);
 667     }
 668 
 669     private void refreshContent(boolean isNoteUpdate) {
 670         if (mNote != null) {
 671             // Restore the cursor position if possible.
 672 
<abbr title=" 673             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 673             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 674 
 675             mContentEditText.setText(mNote.getContent());
 676 
 677             if (isNoteUpdate) {
 678                 // Save the note so any local changes get synced
 679                 mNote.save();
 680 
 681                 if (mContentEditText.hasFocus()
 682                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 683                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 684                     mContentEditText.setSelection(cursorPosition);
 685                 }
 686             }
 687 
 688             afterTextChanged(mContentEditText.getText());
 689             mContentEditText.processChecklists();
 690             updateTagList();
 691         }
 692     }
 693 
 694     private void updateTagList() {
 695         Activity activity = getActivity();
 696         if (activity == null) return;
 697 
 698         // Populate this note&#x27;s tags in the tagView
 699         mTagView.setChips(mNote.getTagString());
 700     }
 701 
 702     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 703         // Ported from the iOS app :)
 704         // Cases:
 705         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 706         // 1. Text was added after the cursor ==&gt; no change
 707         // 2. Text was added before the cursor ==&gt; location advances
 708         // 3. Text was removed after the cursor ==&gt; no change
 709         // 4. Text was removed before the cursor ==&gt; location retreats
 710         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 711 
 712         cursorLocation = Math.max(cursorLocation, 0);
 713 
 714         int newCursorLocation = cursorLocation;
 715 
 716         int deltaLength = newText.length() - oldText.length();
 717 
 718         // Case 0
 719         if (newText.length() &lt; cursorLocation)
 720             return newText.length();
 721 
 722         boolean beforeCursorMatches = false;
 723         boolean afterCursorMatches = false;
 724 
 725         try {
<abbr title=" 726             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 726             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 727             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 727             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 728         } catch (Exception e) {
 729             e.printStackTrace();
 730         }
 731 
 732         // Cases 2 and 4
 733         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 734             newCursorLocation += deltaLength;
 735 
 736         // Cases 1, 3 and 5 have no change
 737         return newCursorLocation;
 738     }
 739 
 740     @Override
 741     public void onTagsChanged(String tagString) {
 742         if (mNote == null || !isAdded()) return;
 743 
 744         if (mNote.getTagString() != null &amp;&amp; tagString.length() &gt; mNote.getTagString().length()) {
 745             AnalyticsTracker.track(
 746                     AnalyticsTracker.Stat.EDITOR_TAG_ADDED,
 747                     AnalyticsTracker.CATEGORY_NOTE,
 748                     &quot;tag_added_to_note&quot;
 749             );
 750         } else {
 751             AnalyticsTracker.track(
 752                     AnalyticsTracker.Stat.EDITOR_TAG_REMOVED,
 753                     AnalyticsTracker.CATEGORY_NOTE,
 754                     &quot;tag_removed_from_note&quot;
 755             );
 756         }
 757 
 758         mNote.setTagString(tagString);
 759         mNote.setModificationDate(Calendar.getInstance());
 760         updateTagList();
 761         mNote.save();
 762     }
 763 
 764     @Override
 765     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 766         // Unused
 767     }
 768 
 769     @Override
 770     public void afterTextChanged(Editable editable) {
 771         attemptAutoList(editable);
 772         setTitleSpan(editable);
 773         mContentEditText.fixLineSpacing();
 774     }
 775 
 776     @Override
 777     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 778         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 779         if (mAutoSaveHandler != null) {
 780             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 781             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 782         }
 783 
 784         // Remove search highlight spans when note content changes
 785         if (mMatchOffsets != null) {
 786             mMatchOffsets = null;
 787             mHighlighter.removeMatches();
 788         }
 789 
 790         // Temporarily remove the text watcher as we process checklists to prevent callback looping
 791         mContentEditText.removeTextChangedListener(this);
 792         mContentEditText.processChecklists();
 793         mContentEditText.addTextChangedListener(this);
 794     }
 795 
 796     private void setTitleSpan(Editable editable) {
 797         // Set the note title to be a larger size
 798         // Remove any existing size spans
 799         RelativeSizeSpan[] spans = editable.getSpans(0, editable.length(), RelativeSizeSpan.class);
 800         for (RelativeSizeSpan span : spans) {
 801             editable.removeSpan(span);
 802         }
 803         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 804         if (newLinePosition == 0)
 805             return;
<abbr title=" 806         editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editable.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);"> 806         editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editaðŸ”µ</abbr>
 807     }
 808 
 809     private void attemptAutoList(Editable editable) {
 810         int oldCursorPosition = mCurrentCursorPosition;
 811         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 812         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 813         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 814     }
 815 
 816     private void saveAndSyncNote() {
 817         if (mNote == null) {
 818             return;
 819         }
 820 
 821         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 822     }
 823 
 824     public void setPlaceholderVisible(boolean isVisible) {
 825         if (isVisible) {
 826             mNote = null;
 827             mContentEditText.setText(&quot;&quot;);
 828             mTagView.setText(&quot;&quot;);
 829             if (mPlaceholderView != null)
 830                 mPlaceholderView.setVisibility(View.VISIBLE);
 831         } else {
 832             if (mPlaceholderView != null)
 833                 mPlaceholderView.setVisibility(View.GONE);
 834         }
 835     }
 836 
 837     @Override
 838     public void onFocusChange(View v, boolean hasFocus) {
 839         if (!hasFocus) {
 840             String tagString = getNoteTagsString().trim();
 841             if (tagString.length() &gt; 0) {
 842                 mTagView.setChips(tagString);
 843             }
 844         }
 845     }
 846 
 847     private Note getNote() {
 848         return mNote;
 849     }
 850 
 851     public void setNote(String noteID) {
 852         setNote(noteID, null);
 853     }
 854 
 855     private String getNoteContentString() {
 856         if (mContentEditText == null || mContentEditText.getText() == null) {
 857             return &quot;&quot;;
 858         } else {
 859             return mContentEditText.getText().toString();
 860         }
 861     }
 862 
 863     private String getNoteTagsString() {
 864         if (mTagView == null || mTagView.getText() == null) {
 865             return &quot;&quot;;
 866         } else {
 867             return mTagView.getText().toString();
 868         }
 869     }
 870 
 871     /**
 872      * Share bottom sheet callbacks
 873      */
 874 
 875     @Override
 876     public void onSharePublishClicked() {
 877         publishNote();
 878         if (mShareBottomSheet != null) {
 879             mShareBottomSheet.dismiss();
 880         }
 881     }
 882 
 883     @Override
 884     public void onShareUnpublishClicked() {
 885         unpublishNote();
 886         if (mShareBottomSheet != null) {
 887             mShareBottomSheet.dismiss();
 888         }
 889     }
 890 
 891     @Override
 892     public void onWordPressPostClicked() {
 893         if (mShareBottomSheet != null) {
 894             mShareBottomSheet.dismiss();
 895         }
 896 
 897         if (getFragmentManager() == null) {
 898             return;
 899         }
 900 
 901         FragmentTransaction ft = getFragmentManager().beginTransaction();
 902         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
 903         if (prev != null) {
 904             ft.remove(prev);
 905         }
 906         ft.addToBackStack(null);
 907 
 908         // Create and show the dialog.
 909         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
 910         wpDialogFragment.setNote(mNote);
 911         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
 912     }
 913 
 914     @Override
 915     public void onShareCollaborateClicked() {
 916         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
 917     }
 918 
 919     @Override
 920     public void onShareDismissed() {
 921 
 922     }
 923 
 924     /**
 925      * History bottom sheet listeners
 926      */
 927 
 928     @Override
 929     public void onHistoryCancelClicked() {
 930         mContentEditText.setText(mNote.getContent());
 931         if (mHistoryBottomSheet != null) {
 932             mHistoryBottomSheet.dismiss();
 933         }
 934     }
 935 
 936     @Override
 937     public void onHistoryRestoreClicked() {
 938         if (mHistoryBottomSheet != null) {
 939             mHistoryBottomSheet.dismiss();
 940         }
 941         saveAndSyncNote();
 942     }
 943 
 944     @Override
 945     public void onHistoryDismissed() {
 946         if (!mHistoryBottomSheet.didTapOnButton()) {
 947             mContentEditText.setText(mNote.getContent());
 948         }
 949 
 950         if (mHistoryTimeoutHandler != null) {
 951             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 952         }
 953     }
 954 
 955     @Override
 956     public void onHistoryUpdateNote(String content) {
 957         mContentEditText.setText(content);
 958     }
 959 
 960     /**
 961      * Info bottom sheet listeners
 962      */
 963 
 964     @Override
 965     public void onInfoPinSwitchChanged(boolean isSwitchedOn) {
 966         NoteUtils.setNotePin(mNote, isSwitchedOn);
 967     }
 968 
 969     @Override
 970     public void onInfoMarkdownSwitchChanged(boolean isSwitchedOn) {
 971         mIsMarkdownEnabled = isSwitchedOn;
 972         Activity activity = getActivity();
 973 
 974         if (activity instanceof NoteEditorActivity) {
 975 
 976             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 977             if (mIsMarkdownEnabled) {
 978 
 979                 editorActivity.showTabs();
 980 
 981                 if (mNoteMarkdownFragment == null) {
 982                     // Get markdown fragment and update content
 983                     mNoteMarkdownFragment =
 984                             editorActivity.getNoteMarkdownFragment();
 985                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 986                 }
 987             } else {
 988                 editorActivity.hideTabs();
 989             }
 990         } else if (activity instanceof NotesActivity) {
 991             setMarkdownEnabled(mIsMarkdownEnabled);
 992             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 993         }
 994 
 995         saveNote();
 996     }
 997 
 998     @Override
 999     public void onInfoCopyLinkClicked() {
1000         copyToClipboard(mNote.getPublishedUrl());
1001         Toast.makeText(getActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();
1002     }
1003 
1004     @Override
1005     public void onInfoShareLinkClicked() {
1006         if (mInfoBottomSheet != null) {
1007             mInfoBottomSheet.dismiss();
1008         }
1009         showShareSheet();
1010     }
1011 
1012     @Override
1013     public void onInfoDismissed() {
1014 
1015     }
1016 
1017     protected void saveNote() {
1018         try {
1019             Simplenote application = ((Simplenote) (requireActivity().getApplication()));
1020             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1021             mNote = notesBucket.get(mNote.getSimperiumKey());
<abbr title="1022             if ((((mNote == null) || (mContentEditText == null)) || mIsLoadingNote) || (((mHistoryBottomSheet != null) &amp;&amp; (mHistoryBottomSheet.getDialog() != null)) &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1022             if ((((mNote == null) || (mContentEditText == null)) || mIsLoadingNote) || (((mHistoryBottomSðŸ”µ</abbr>
1023                 return;
1024             } else {
1025                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1026             }
1027             String content = mContentEditText.getPlainTextContent();
1028             String tagString = getNoteTagsString();
<abbr title="1029             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1029             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1030                 mNote.setContent(content);
1031                 mNote.setTagString(tagString);
1032                 mNote.setModificationDate(Calendar.getInstance());
1033                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1034                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1035                 mNote.save();
<abbr title="1036                 AnalyticsTracker.track(AnalyticsTracker.Stat.EDITOR_NOTE_EDITED, AnalyticsTracker.CATEGORY_NOTE, &quot;editor_save&quot;);">1036                 AnalyticsTracker.track(AnalyticsTracker.Stat.EDITOR_NOTE_EDITED, AnalyticsTracker.CATEGORðŸ”µ</abbr>
1037             }
1038         } catch (BucketObjectMissingException exception) {
1039             exception.printStackTrace();
1040         }
1041     }
1042 
1043     // Checks if cursor is at a URL when the selection changes
1044     // If it is a URL, show the contextual action bar
1045     @Override
1046     public void onSelectionChanged(int selStart, int selEnd) {
1047         mCurrentCursorPosition = selEnd;
1048         if (selStart == selEnd) {
1049             Editable noteContent = mContentEditText.getText();
1050             if (noteContent == null)
1051                 return;
1052 
1053             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1054             if (urlSpans.length &gt; 0) {
1055                 URLSpan urlSpan = urlSpans[0];
1056                 mLinkUrl = urlSpan.getURL();
<abbr title="1057                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1057                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1058                 if (mActionMode != null) {
1059                     mActionMode.setSubtitle(mLinkText);
1060                     setLinkMenuItem();
1061                     return;
1062                 }
1063 
1064                 // Show the Contextual Action Bar
1065                 if (getActivity() != null) {
<abbr title="1066                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1066                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1067                     if (mActionMode != null) {
1068                         mActionMode.setSubtitle(mLinkText);
1069                     }
1070 
1071                     setLinkMenuItem();
1072                 }
1073             } else if (mActionMode != null) {
1074                 mActionMode.finish();
1075                 mActionMode = null;
1076             }
1077         } else if (mActionMode != null) {
1078             mActionMode.finish();
1079             mActionMode = null;
1080         }
1081     }
1082 
1083     private void setLinkMenuItem() {
1084         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1085             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1086                 mViewLinkMenuItem.setIcon(mCallIcon);
1087                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1088             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1089                 mViewLinkMenuItem.setIcon(mEmailIcon);
1090                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1091             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1092                 mViewLinkMenuItem.setIcon(mMapIcon);
1093                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1094             } else {
1095                 mViewLinkMenuItem.setIcon(mWebIcon);
1096                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1097             }
1098         }
1099     }
1100 
1101     private void setPublishedNote(boolean isPublished) {
1102         if (mNote != null) {
1103             mNote.setPublished(isPublished);
1104             mNote.save();
1105 
1106             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1107             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1108 
1109             AnalyticsTracker.track(
1110                     (isPublished) ? AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED :
1111                             AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED,
1112                     AnalyticsTracker.CATEGORY_NOTE,
1113                     &quot;publish_note_button&quot;
1114             );
1115         }
1116     }
1117 
1118     private void updatePublishedState(boolean isSuccess) {
1119 
1120         if (mPublishingSnackbar == null) {
1121             return;
1122         }
1123 
1124         mPublishingSnackbar.dismiss();
1125         mPublishingSnackbar = null;
1126 
1127         if (isSuccess &amp;&amp; isAdded()) {
1128             if (mNote.isPublished()) {
1129 
1130                 if (mIsUndoingPublishing) {
1131                     SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1132                             R.color.status_positive,
1133                             Snackbar.LENGTH_LONG);
1134                 } else {
1135                     SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1136                             R.color.status_positive,
1137                             Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1138                                 @Override
1139                                 public void onClick(View v) {
1140                                     mIsUndoingPublishing = true;
1141                                     unpublishNote();
1142                                 }
1143                             });
1144                 }
1145                 copyToClipboard(mNote.getPublishedUrl());
1146             } else {
1147                 if (mIsUndoingPublishing) {
1148                     SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1149                             R.color.status_negative,
1150                             Snackbar.LENGTH_LONG);
1151                 } else {
1152                     SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1153                             R.color.status_negative,
1154                             Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1155                                 @Override
1156                                 public void onClick(View v) {
1157                                     mIsUndoingPublishing = true;
1158                                     publishNote();
1159                                 }
1160                             });
1161                 }
1162             }
1163         } else {
1164             if (mNote.isPublished()) {
1165                 SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_error,
1166                         R.color.status_negative, Snackbar.LENGTH_LONG);
1167             } else {
1168                 SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_error,
1169                         R.color.status_negative, Snackbar.LENGTH_LONG);
1170             }
1171         }
1172 
1173         mIsUndoingPublishing = false;
1174     }
1175 
1176     private void publishNote() {
1177 
1178         if (isAdded()) {
1179             mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.publishing,
1180                     R.color.blue, Snackbar.LENGTH_INDEFINITE);
1181         }
1182         setPublishedNote(true);
1183     }
1184 
1185     private void unpublishNote() {
1186 
1187         if (isAdded()) {
1188             mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublishing,
1189                     R.color.blue, Snackbar.LENGTH_INDEFINITE);
1190         }
1191         setPublishedNote(false);
1192     }
1193 
1194     private void copyToClipboard(String text) {
1195         ClipboardManager clipboard = (ClipboardManager) requireActivity()
1196                 .getSystemService(Context.CLIPBOARD_SERVICE);
1197         ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);
1198         if (clipboard != null) {
1199             clipboard.setPrimaryClip(clip);
1200         }
1201     }
1202 
1203     private void showShareSheet() {
1204         if (isAdded()) {
1205             mShareBottomSheet.show(requireFragmentManager(), mNote);
1206         }
1207     }
1208 
1209     private void showInfoSheet() {
1210         if (isAdded()) {
1211             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1212         }
1213     }
1214 
1215     private void showHistorySheet() {
1216         if (isAdded()) {
1217             // Request revisions for the current note
<abbr title="1218             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1218             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1219             saveNote();
1220             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1221         }
1222     }
1223 
1224     /**
1225      * Simperium listeners
1226      */
1227 
1228     @Override
1229     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1230 
1231     }
1232 
1233     @Override
<abbr title="1234     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1234     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1235         if (changeType == Bucket.ChangeType.MODIFY) {
1236             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1237                 try {
1238                     final Note updatedNote = mNotesBucket.get(key);
1239                     if (getActivity() != null) {
1240                         getActivity().runOnUiThread(new Runnable() {
1241                             @Override
1242                             public void run() {
1243                                 if (mPublishTimeoutHandler != null) {
1244                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1245                                 }
1246 
1247                                 updateNote(updatedNote);
1248                                 updatePublishedState(true);
1249                             }
1250                         });
1251                     }
1252                 } catch (BucketObjectMissingException e) {
1253                     e.printStackTrace();
1254                 }
1255             }
1256         }
1257     }
1258 
1259     @Override
1260     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1261         // noop
1262     }
1263 
1264     @Override
1265     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1266         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1267         if (mIsLoadingNote)
1268             return;
1269 
1270         Note openNote = getNote();
1271         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1272             return;
1273 
1274         note.setContent(mContentEditText.getPlainTextContent());
1275     }
1276 
1277     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1278         WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1279 
1280         LoadNoteTask(NoteEditorFragment fragment) {
1281             weakFragment = new WeakReference&lt;&gt;(fragment);
1282         }
1283 
1284         @Override
1285         protected void onPreExecute() {
1286             NoteEditorFragment fragment = weakFragment.get();
1287             if (fragment != null) {
1288                 fragment.mContentEditText.removeTextChangedListener(fragment);
1289                 fragment.mIsLoadingNote = true;
1290             }
1291         }
1292 
1293         @Override
1294         protected Void doInBackground(String... args) {
1295             NoteEditorFragment fragment = weakFragment.get();
1296             if ((fragment == null) || (fragment.getActivity() == null)) {
1297                 return null;
1298             }
1299             String noteID = args[0];
1300             Simplenote application = ((Simplenote) (fragment.getActivity().getApplication()));
1301             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1302             try {
1303                 fragment.mNote = notesBucket.get(noteID);
1304                 // Set the current note in NotesActivity when on a tablet
1305                 if (fragment.getActivity() instanceof NotesActivity) {
1306                     ((NotesActivity) (fragment.getActivity())).setCurrentNote(fragment.mNote);
1307                 }
1308                 // Set markdown and preview flags for current note
1309                 if (fragment.mNote != null) {
1310                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1311                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1312                 }
1313             } catch (BucketObjectMissingException e) {
1314                 // See if the note is in the object store
1315                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1316                 while (notesCursor.moveToNext()) {
1317                     Note currentNote = notesCursor.getObject();
1318                     if ((currentNote != null) &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1319                         fragment.mNote = currentNote;
1320                         return null;
1321                     }
1322                 }
1323             }
1324             return null;
1325         }
1326 
1327         @Override
1328         protected void onPostExecute(Void nada) {
1329             final NoteEditorFragment fragment = weakFragment.get();
<abbr title="1330             if (((fragment == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFinishing()) {">1330             if (((fragment == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFiniðŸ”µ</abbr>
1331                 return;
1332             }
1333             fragment.refreshContent(false);
1334             if (fragment.mMatchOffsets != null) {
<abbr title="1335                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1335                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1336                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1337                 fragment.mShouldScrollToSearchMatch = true;
1338             }
1339             fragment.mContentEditText.addTextChangedListener(fragment);
1340             if ((fragment.mNote != null) &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1341                 // Show soft keyboard
1342                 fragment.mContentEditText.requestFocus();
1343                 new Handler().postDelayed(new Runnable() {
1344                     @Override
1345                     public void run() {
1346                         if (fragment.getActivity() == null) {
1347                             return;
1348                         }
<abbr title="1349                         InputMethodManager inputMethodManager = ((InputMethodManager) (fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE)));">1349                         InputMethodManager inputMethodManager = ((InputMethodManager) (fragment.getActiviðŸ”µ</abbr>
1350                         if (inputMethodManager != null) {
1351                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1352                         }
1353                     }
1354                 }, 100);
1355             } else if (fragment.mNote != null) {
1356                 // If we have a valid note, hide the placeholder
1357                 fragment.setPlaceholderVisible(false);
1358             }
1359             fragment.updateMarkdownView();
1360             fragment.requireActivity().invalidateOptionsMenu();
1361             fragment.linkifyEditorContent();
1362             fragment.mIsLoadingNote = false;
1363         }
1364     }
1365 
1366     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1367         WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1368 
1369         SaveNoteTask(NoteEditorFragment fragment) {
1370             weakFragment = new WeakReference&lt;&gt;(fragment);
1371         }
1372 
1373         @Override
1374         protected Void doInBackground(Void... args) {
1375             NoteEditorFragment fragment = weakFragment.get();
1376             if (fragment != null) {
1377                 fragment.saveNote();
1378             }
1379             return null;
1380         }
1381 
1382         @Override
1383         protected void onPostExecute(Void nada) {
1384             NoteEditorFragment fragment = weakFragment.get();
<abbr title="1385             if (((fragment != null) &amp;&amp; (fragment.getActivity() != null)) &amp;&amp; (!fragment.getActivity().isFinishing())) {">1385             if (((fragment != null) &amp;&amp; (fragment.getActivity() != null)) &amp;&amp; (!fragment.getActivity().isFiðŸ”µ</abbr>
1386                 // Update links
1387                 fragment.linkifyEditorContent();
1388                 fragment.updateMarkdownView();
1389             }
1390         }
1391     }
1392 
1393     private void linkifyEditorContent() {
1394         if (getActivity() == null || getActivity().isFinishing()) {
1395             return;
1396         }
1397 
1398         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1399             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1400         }
1401     }
1402 
1403     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1404     private void updateMarkdownView() {
1405         if (!mIsMarkdownEnabled) {
1406             return;
1407         }
1408 
1409         Activity activity = getActivity();
1410         if (activity instanceof NotesActivity) {
1411             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1412             loadMarkdownData();
1413         } else {
1414             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1415             if (mNoteMarkdownFragment == null) {
1416                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1417                         .getNoteMarkdownFragment();
1418                 ((NoteEditorActivity) requireActivity()).showTabs();
1419             }
1420             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1421             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1422         }
1423     }
1424 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.app.Activity;
   4  import android.content.ClipData;
   5  import android.content.ClipboardManager;
   6  import android.content.Context;
   7  import android.content.Intent;
   8  import android.database.Cursor;
   9  import android.graphics.drawable.Drawable;
  10  import android.net.Uri;
  11  import android.os.AsyncTask;
  12  import android.os.Bundle;
  13  import android.os.Handler;
  14  import android.text.Editable;
  15  import android.text.Layout;
  16  import android.text.Spanned;
  17  import android.text.TextWatcher;
  18  import android.text.style.RelativeSizeSpan;
  19  import android.text.style.URLSpan;
  20  import android.text.util.Linkify;
  21  import android.util.TypedValue;
  22  import android.view.LayoutInflater;
  23  import android.view.Menu;
  24  import android.view.MenuInflater;
  25  import android.view.MenuItem;
  26  import android.view.View;
  27  import android.view.ViewGroup;
  28  import android.view.ViewTreeObserver;
  29  import android.view.inputmethod.InputMethodManager;
  30  import android.webkit.WebView;
  31  import android.widget.CursorAdapter;
  32  import android.widget.LinearLayout;
  33  import android.widget.ScrollView;
  34  import android.widget.TextView;
  35  import android.widget.Toast;
  36  
  37  import androidx.annotation.NonNull;
  38  import androidx.appcompat.app.AppCompatActivity;
  39  import androidx.appcompat.view.ActionMode;
  40  import androidx.core.widget.NestedScrollView;
  41  import androidx.fragment.app.Fragment;
  42  import androidx.fragment.app.FragmentTransaction;
  43  
  44  import com.automattic.simplenote.analytics.AnalyticsTracker;
  45  import com.automattic.simplenote.models.Note;
  46  import com.automattic.simplenote.models.Tag;
  47  import com.automattic.simplenote.utils.AutoBullet;
  48  import com.automattic.simplenote.utils.ContextUtils;
  49  import com.automattic.simplenote.utils.DisplayUtils;
  50  import com.automattic.simplenote.utils.DrawableUtils;
  51  import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  52  import com.automattic.simplenote.utils.NoteUtils;
  53  import com.automattic.simplenote.utils.PrefUtils;
  54  import com.automattic.simplenote.utils.SimplenoteLinkify;
  55  import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  56  import com.automattic.simplenote.utils.SnackbarUtils;
  57  import com.automattic.simplenote.utils.SpaceTokenizer;
  58  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  59  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  60  import com.automattic.simplenote.utils.TextHighlighter;
  61  import com.automattic.simplenote.utils.ThemeUtils;
  62  import com.automattic.simplenote.utils.WidgetUtils;
  63  import com.automattic.simplenote.widgets.SimplenoteEditText;
  64  import com.google.android.material.snackbar.Snackbar;
  65  import com.simperium.client.Bucket;
  66  import com.simperium.client.BucketObjectMissingException;
  67  import com.simperium.client.Query;
  68  
  69  import java.lang.ref.WeakReference;
  70  import java.util.Calendar;
  71  
  72  public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  73          TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  74          SimplenoteEditText.OnSelectionChangedListener,
  75          ShareBottomSheetDialog.ShareSheetListener,
  76          HistoryBottomSheetDialog.HistorySheetListener,
  77          InfoBottomSheetDialog.InfoSheetListener,
  78          SimplenoteEditText.OnCheckboxToggledListener {
  79  
  80      public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  81      public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
  82      public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
  83      public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
  84      public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
  85      private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
  86      private static final int AUTOSAVE_DELAY_MILLIS = 2000;
  87      private static final int MAX_REVISIONS = 30;
  88      private static final int PUBLISH_TIMEOUT = 20000;
  89      private static final int HISTORY_TIMEOUT = 10000;
  90      private Note mNote;
  91      private final Runnable mAutoSaveRunnable = new Runnable() {
  92          @Override
  93          public void run() {
  94              saveAndSyncNote();
  95          }
  96      };
  97      private Bucket&lt;Note&gt; mNotesBucket;
  98      private View mRootView;
  99      private SimplenoteEditText mContentEditText;
 100      private TagsMultiAutoCompleteTextView mTagView;
 101      private Handler mAutoSaveHandler;
 102      private Handler mPublishTimeoutHandler;
 103      private Handler mHistoryTimeoutHandler;
 104      private LinearLayout mPlaceholderView;
 105      private CursorAdapter mAutocompleteAdapter;
 106      private boolean mIsLoadingNote;
 107      private boolean mIsMarkdownEnabled;
 108      private boolean mIsPreviewEnabled;
 109      private boolean mShouldScrollToSearchMatch;
 110      private ActionMode mActionMode;
 111      private MenuItem mViewLinkMenuItem;
 112      private String mLinkUrl;
 113      private String mLinkText;
 114      private MatchOffsetHighlighter mHighlighter;
 115      private Drawable mEmailIcon, mWebIcon, mMapIcon, mCallIcon;
 116      private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 117      private String mMatchOffsets;
 118      private int mCurrentCursorPosition;
 119      private HistoryBottomSheetDialog mHistoryBottomSheet;
 120      // Hides the history bottom sheet if no revisions are loaded
 121      private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 122          @Override
 123          public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -            if (!isAdded()) return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +            if (!isAdded()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +            }</span>
 128  
 129              requireActivity().runOnUiThread(new Runnable() {
 130                  @Override
 131                  public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -                    if (mHistoryBottomSheet.isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 134 +                    if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 134 +                    if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; ðŸ”µ</abbr></span>
 135                          mHistoryBottomSheet.dismiss();
 136                          Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 137                      }
 138                  }
 139              });
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -</span>
 141          }
 142      };
 143      private InfoBottomSheetDialog mInfoBottomSheet;
 144      private ShareBottomSheetDialog mShareBottomSheet;
 145      // Contextual action bar for dealing with links
 146      private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -</span>
 148          // Called when the action mode is created; startActionMode() was called
 149          @Override
 150          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 151              // Inflate a menu resource providing context menu items
 152              MenuInflater inflater = mode.getMenuInflater();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +</span>
 154              if (inflater != null) {
 155                  inflater.inflate(R.menu.view_link, menu);
 156                  mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 157                  mode.setTitle(getString(R.string.link));
 158                  mode.setTitleOptionalHint(false);
 159  
 160                  DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 161              }
 162  
<abbr title=" 163              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 163              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgrðŸ”µ</abbr>
<abbr title=" 164              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 164              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().ðŸ”µ</abbr>
 165              return true;
 166          }
 167  
 168          // Called each time the action mode is shown. Always called after onCreateActionMode, but
 169          // may be called multiple times if the mode is invalidated.
 170          @Override
 171          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 172              return false; // Return false if nothing is done
 173          }
 174  
 175          // Called when the user selects a contextual menu item
 176          @Override
 177          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 178              switch (item.getItemId()) {
 179                  case R.id.menu_view_link:
 180                      if (mLinkUrl != null) {
 181                          try {
 182                              Uri uri = Uri.parse(mLinkUrl);
 183                              Intent i = new Intent(Intent.ACTION_VIEW);
 184                              i.setData(uri);
 185                              startActivity(i);
 186                          } catch (Exception e) {
 187                              e.printStackTrace();
 188                          }
 189                          mode.finish(); // Action picked, so close the CAB
 190                      }
 191                      return true;
 192                  case R.id.menu_copy:
 193                      if (mLinkText != null &amp;&amp; getActivity() != null) {
 194                          copyToClipboard(mLinkText);
<abbr title=" 195                          Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();"> 195                          Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).shoðŸ”µ</abbr>
 196                          mode.finish();
 197                      }
 198                      return true;
 199                  case R.id.menu_share:
 200                      if (mLinkText != null) {
 201                          showShareSheet();
 202                          mode.finish();
 203                      }
 204                      return true;
 205                  default:
 206                      return false;
 207              }
 208          }
 209  
 210          // Called when the user exits the action mode
 211          @Override
 212          public void onDestroyActionMode(ActionMode mode) {
 213              mActionMode = null;
 214              new Handler().postDelayed(
 215                  new Runnable() {
 216                      @Override
 217                      public void run() {
<abbr title=" 218                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 218                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.trðŸ”µ</abbr>
 219                      }
 220                  },
 221                  requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 222              );
 223          }
 224      };
 225      private Snackbar mPublishingSnackbar;
 226      private boolean mIsUndoingPublishing;
 227      // Resets note publish status if Simperium never returned the new publish status
 228      private final Runnable mPublishTimeoutRunnable = new Runnable() {
 229          @Override
 230          public void run() {
 231              if (!isAdded()) return;
 232  
 233              requireActivity().runOnUiThread(new Runnable() {
 234                  @Override
 235                  public void run() {
 236  
 237                      mNote.setPublished(!mNote.isPublished());
 238                      mNote.save();
 239  
 240                      updatePublishedState(false);
 241                  }
 242              });
 243          }
 244      };
 245      private NoteMarkdownFragment mNoteMarkdownFragment;
 246      private String mCss;
 247      private WebView mMarkdown;
 248  
 249      /**
 250       * Mandatory empty constructor for the fragment manager to instantiate the
 251       * fragment (e.g. upon screen orientation changes).
 252       */
 253      public NoteEditorFragment() {
 254      }
 255  
 256      @Override
 257      public void onCreate(Bundle savedInstanceState) {
 258          super.onCreate(savedInstanceState);
 259          mInfoBottomSheet = new InfoBottomSheetDialog(this, this);
 260          mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 261          mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 262  
 263          Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 264          mNotesBucket = currentApp.getNotesBucket();
 265  
<abbr title=" 266          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 266          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 267          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dp, R.attr.actionModeTextColor);"> 267          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dp, R.attrðŸ”µ</abbr>
<abbr title=" 268          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, R.attr.actionModeTextColor);"> 268          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, R.attr.actðŸ”µ</abbr>
<abbr title=" 269          mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, R.attr.actionModeTextColor);"> 269          mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, R.attr.actðŸ”µ</abbr>
 270  
 271          mAutoSaveHandler = new Handler();
 272          mPublishTimeoutHandler = new Handler();
 273          mHistoryTimeoutHandler = new Handler();
 274  
 275          mMatchHighlighter = new TextHighlighter(requireActivity(),
 276                  R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);
 277          mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 278              @Override
 279              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 280                  Activity activity = (Activity) context;
 281                  if (activity == null) return null;
 282                  return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 283              }
 284  
 285              @Override
 286              public void bindView(View view, Context context, Cursor cursor) {
 287                  TextView textView = (TextView) view;
 288                  textView.setText(convertToString(cursor));
 289              }
 290  
 291              @Override
 292              public CharSequence convertToString(Cursor cursor) {
 293                  return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 294              }
 295  
 296              @Override
 297              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 298                  Activity activity = getActivity();
 299                  if (activity == null) return null;
 300                  Simplenote application = (Simplenote) activity.getApplication();
 301                  Query&lt;Tag&gt; query = application.getTagsBucket().query();
 302                  // make the tag name available to the cursor
 303                  query.include(Tag.NAME_PROPERTY);
 304                  // sort the tags by their names
 305                  query.order(Tag.NAME_PROPERTY);
 306                  // if there&#x27;s a filter string find only matching tag names
 307                  if (filter != null)
 308                      query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));
 309                  return query.execute();
 310              }
 311          };
 312  
 313          WidgetUtils.updateNoteWidgets(getActivity());
 314      }
 315  
 316      @Override
 317      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 318          mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 319          mContentEditText = mRootView.findViewById(R.id.note_content);
 320          mContentEditText.addOnSelectionChangedListener(this);
 321          mContentEditText.setOnCheckboxToggledListener(this);
 322          mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 323          mTagView = mRootView.findViewById(R.id.tag_view);
 324          mTagView.setTokenizer(new SpaceTokenizer());
 325          mTagView.setOnFocusChangeListener(this);
 326          mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 327  
 328          mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 329          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 330              mPlaceholderView.setVisibility(View.VISIBLE);
 331              requireActivity().invalidateOptionsMenu();
 332              mMarkdown = mRootView.findViewById(R.id.markdown);
 333              mCss = ThemeUtils.isLightTheme(requireContext())
 334                      ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 335                      : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 336          }
 337  
 338          mTagView.setAdapter(mAutocompleteAdapter);
 339  
 340          Bundle arguments = getArguments();
 341          if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 342              // Load note if we were passed a note Id
 343              String key = arguments.getString(ARG_ITEM_ID);
 344              if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 345                  mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 346              }
 347              new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 348          } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null ) {
 349              // Restore selected note when in dual pane mode
 350              String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 351              if (noteId != null) {
 352                  setNote(noteId);
 353              }
 354          }
 355  
 356          ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 357          viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 358              @Override
 359              public void onGlobalLayout() {
 360                  // If a note was loaded with search matches, scroll to the first match in the editor
 361                  if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 362                      if (!isAdded()) {
 363                          return;
 364                      }
 365  
 366                      // Get the character location of the first search match
 367                      int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 368                              mContentEditText.getText(),
 369                              mMatchOffsets
 370                      );
 371                      if (matchLocation == 0) {
 372                          return;
 373                      }
 374  
 375                      // Calculate how far to scroll to bring the match into view
 376                      Layout layout = mContentEditText.getLayout();
 377                      int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 378  
 379                      // We use different scroll views in the root of the layout files... yuck.
 380                      // So we have to cast appropriately to do a smooth scroll
 381                      if (mRootView instanceof NestedScrollView) {
 382                          ((NestedScrollView)mRootView).smoothScrollTo(0, lineTop);
 383                      } else {
 384                          ((ScrollView)mRootView).smoothScrollTo(0, lineTop);
 385                      }
 386  
 387                      mShouldScrollToSearchMatch = false;
 388                  }
 389              }
 390          });
 391          setHasOptionsMenu(true);
 392          return mRootView;
 393      }
 394  
 395      @Override
 396      public void onResume() {
 397          super.onResume();
 398          mNotesBucket.start();
 399          mNotesBucket.addListener(this);
 400  
 401          mTagView.setOnTagAddedListener(this);
 402  
 403          if (mContentEditText != null) {
 404              mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));
 405  
 406              if (mContentEditText.hasFocus()) {
 407                  showSoftKeyboard();
 408              }
 409          }
 410      }
 411  
 412      private void showSoftKeyboard() {
 413          new Handler().postDelayed(new Runnable() {
 414              @Override
 415              public void run() {
 416                  if (getActivity() == null) {
 417                      return;
 418                  }
 419  
<abbr title=" 420                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 420                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(ContexðŸ”µ</abbr>
 421                  if (inputMethodManager != null) {
 422                      inputMethodManager.showSoftInput(mContentEditText, 0);
 423                  }
 424              }
 425          }, 100);
 426      }
 427  
 428      @Override
 429      public void onPause() {
 430          super.onPause();  // Always call the superclass method first
 431  
 432          mNotesBucket.removeListener(this);
 433          mNotesBucket.stop();
 434  
 435          // Hide soft keyboard if it is showing...
 436          DisplayUtils.hideKeyboard(mContentEditText);
 437  
 438          mTagView.setOnTagAddedListener(null);
 439  
 440          if (mAutoSaveHandler != null) {
 441              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 442          }
 443  
 444          if (mPublishTimeoutHandler != null) {
 445              mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 446          }
 447  
 448          if (mHistoryTimeoutHandler != null) {
 449              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 450          }
 451  
 452          mHighlighter.stop();
 453          saveNote();
 454      }
 455  
 456      @Override
 457      public void onSaveInstanceState(@NonNull Bundle outState) {
 458          super.onSaveInstanceState(outState);
 459  
 460          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 461              outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 462          }
 463      }
 464  
 465      @Override
 466      public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 467          super.onCreateOptionsMenu(menu, inflater);
 468          if (!isAdded() || DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null) {
 469              return;
 470          }
 471  
 472          inflater.inflate(R.menu.note_editor, menu);
 473  
 474          if (mNote != null) {
 475              MenuItem viewPublishedNoteItem = menu.findItem(R.id.menu_view_info);
 476              viewPublishedNoteItem.setVisible(true);
 477  
 478              MenuItem trashItem = menu.findItem(R.id.menu_delete).setTitle(R.string.undelete);
 479  
 480              if (mNote.isDeleted()) {
 481                  trashItem.setTitle(R.string.undelete);
 482                  trashItem.setIcon(R.drawable.ic_trash_restore_24dp);
 483              } else {
 484                  trashItem.setTitle(R.string.delete);
 485                  trashItem.setIcon(R.drawable.ic_trash_24dp);
 486              }
 487          }
 488          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionBarTextColor);
 489      }
 490  
 491      @Override
 492      public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 493          switch (item.getItemId()) {
 494              case R.id.menu_view_info:
 495                  showInfo();
 496                  return true;
 497              case R.id.menu_checklist:
 498                  insertChecklist();
 499                  return true;
 500              case R.id.menu_history:
 501                  showHistory();
 502                  return true;
 503              case R.id.menu_share:
 504                  shareNote();
 505                  return true;
 506              case R.id.menu_delete:
 507                  if (!isAdded()) return false;
 508                  deleteNote();
 509                  return true;
 510              case android.R.id.home:
 511                  if (!isAdded()) return false;
 512                  requireActivity().finish();
 513                  return true;
 514              default:
 515                  return super.onOptionsItemSelected(item);
 516          }
 517      }
 518  
 519      private void insertChecklist() {
 520          try {
 521              mContentEditText.insertChecklist();
 522          } catch (Exception e) {
 523              e.printStackTrace();
 524              return;
 525          }
 526  
 527          AnalyticsTracker.track(
 528                  AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED,
 529                  AnalyticsTracker.CATEGORY_NOTE,
 530                  &quot;toolbar_button&quot;
 531          );
 532      }
 533  
 534      @Override
 535      public void onCheckboxToggled() {
 536          // Save note (using delay) after toggling a checkbox
 537          if (mAutoSaveHandler != null) {
 538              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 539              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 540          }
 541      }
 542  
 543      private void deleteNote() {
 544          NoteUtils.deleteNote(mNote, getActivity());
 545          requireActivity().finish();
 546      }
 547  
 548      protected void clearMarkdown() {
 549          mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 550      }
 551  
 552      protected void hideMarkdown() {
 553          mMarkdown.setVisibility(View.INVISIBLE);
 554      }
 555  
 556      protected void showMarkdown() {
 557          loadMarkdownData();
 558          mMarkdown.setVisibility(View.VISIBLE);
 559      }
 560  
 561      private void shareNote() {
 562          if (mNote != null) {
 563              mContentEditText.clearFocus();
 564              showShareSheet();
 565              AnalyticsTracker.track(
 566                      AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED,
 567                      AnalyticsTracker.CATEGORY_NOTE,
 568                      &quot;action_bar_share_button&quot;
 569              );
 570          }
 571      }
 572  
 573      private void showHistory() {
 574          if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 575              mContentEditText.clearFocus();
 576              mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 577              showHistorySheet();
 578          } else {
 579              Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 580          }
 581      }
 582  
 583      private void showInfo() {
 584          if (mNote != null) {
 585              mContentEditText.clearFocus();
 586              saveNote();
 587              showInfoSheet();
 588          }
 589      }
 590  
 591      protected void setMarkdownEnabled(boolean enabled) {
 592          mIsMarkdownEnabled = enabled;
 593  
 594          if (mIsMarkdownEnabled) {
 595              loadMarkdownData();
 596          }
 597      }
 598  
 599      private void loadMarkdownData() {
 600          String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 601                  mCss,
 602                  mContentEditText.getPlainTextContent()
 603          );
 604  
 605          mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 606      }
 607  
 608      public void setNote(String noteID, String matchOffsets) {
 609          if (mAutoSaveHandler != null)
 610              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 611  
 612          mPlaceholderView.setVisibility(View.GONE);
 613  
 614          if (matchOffsets != null) {
 615              mMatchOffsets = matchOffsets;
 616          } else {
 617              mMatchOffsets = null;
 618          }
 619  
 620  
 621          saveNote();
 622  
 623          new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 624      }
 625  
 626      private void updateNote(Note updatedNote) {
 627          // update note if network change arrived
 628          mNote = updatedNote;
 629          refreshContent(true);
 630      }
 631  
 632      private void refreshContent(boolean isNoteUpdate) {
 633          if (mNote != null) {
 634              // Restore the cursor position if possible.
 635  
<abbr title=" 636              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 636              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.geðŸ”µ</abbr>
 637  
 638              mContentEditText.setText(mNote.getContent());
 639  
 640              if (isNoteUpdate) {
 641                  // Save the note so any local changes get synced
 642                  mNote.save();
 643  
 644                  if (mContentEditText.hasFocus()
 645                          &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 646                          &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 647                      mContentEditText.setSelection(cursorPosition);
 648                  }
 649              }
 650  
 651              afterTextChanged(mContentEditText.getText());
 652              mContentEditText.processChecklists();
 653              updateTagList();
 654          }
 655      }
 656  
 657      private void updateTagList() {
 658          Activity activity = getActivity();
 659          if (activity == null) return;
 660  
 661          // Populate this note&#x27;s tags in the tagView
 662          mTagView.setChips(mNote.getTagString());
 663      }
 664  
 665      private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 666          // Ported from the iOS app :)
 667          // Cases:
 668          // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 669          // 1. Text was added after the cursor ==&gt; no change
 670          // 2. Text was added before the cursor ==&gt; location advances
 671          // 3. Text was removed after the cursor ==&gt; no change
 672          // 4. Text was removed before the cursor ==&gt; location retreats
 673          // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 674  
 675          cursorLocation = Math.max(cursorLocation, 0);
 676  
 677          int newCursorLocation = cursorLocation;
 678  
 679          int deltaLength = newText.length() - oldText.length();
 680  
 681          // Case 0
 682          if (newText.length() &lt; cursorLocation)
 683              return newText.length();
 684  
 685          boolean beforeCursorMatches = false;
 686          boolean afterCursorMatches = false;
 687  
 688          try {
<abbr title=" 689              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 689              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation)ðŸ”µ</abbr>
<abbr title=" 690              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 690              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaðŸ”µ</abbr>
 691          } catch (Exception e) {
 692              e.printStackTrace();
 693          }
 694  
 695          // Cases 2 and 4
 696          if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 697              newCursorLocation += deltaLength;
 698  
 699          // Cases 1, 3 and 5 have no change
 700          return newCursorLocation;
 701      }
 702  
 703      @Override
 704      public void onTagsChanged(String tagString) {
 705          if (mNote == null || !isAdded()) return;
 706  
 707          if (mNote.getTagString() != null &amp;&amp; tagString.length() &gt; mNote.getTagString().length()) {
 708              AnalyticsTracker.track(
 709                      AnalyticsTracker.Stat.EDITOR_TAG_ADDED,
 710                      AnalyticsTracker.CATEGORY_NOTE,
 711                      &quot;tag_added_to_note&quot;
 712              );
 713          } else {
 714              AnalyticsTracker.track(
 715                      AnalyticsTracker.Stat.EDITOR_TAG_REMOVED,
 716                      AnalyticsTracker.CATEGORY_NOTE,
 717                      &quot;tag_removed_from_note&quot;
 718              );
 719          }
 720  
 721          mNote.setTagString(tagString);
 722          mNote.setModificationDate(Calendar.getInstance());
 723          updateTagList();
 724          mNote.save();
 725      }
 726  
 727      @Override
 728      public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 729          // Unused
 730      }
 731  
 732      @Override
 733      public void afterTextChanged(Editable editable) {
 734          attemptAutoList(editable);
 735          setTitleSpan(editable);
 736          mContentEditText.fixLineSpacing();
 737      }
 738  
 739      @Override
 740      public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 741          // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 742          if (mAutoSaveHandler != null) {
 743              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 744              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 745          }
 746  
 747          // Remove search highlight spans when note content changes
 748          if (mMatchOffsets != null) {
 749              mMatchOffsets = null;
 750              mHighlighter.removeMatches();
 751          }
 752  
 753          // Temporarily remove the text watcher as we process checklists to prevent callback looping
 754          mContentEditText.removeTextChangedListener(this);
 755          mContentEditText.processChecklists();
 756          mContentEditText.addTextChangedListener(this);
 757      }
 758  
 759      private void setTitleSpan(Editable editable) {
 760          // Set the note title to be a larger size
 761          // Remove any existing size spans
 762          RelativeSizeSpan[] spans = editable.getSpans(0, editable.length(), RelativeSizeSpan.class);
 763          for (RelativeSizeSpan span : spans) {
 764              editable.removeSpan(span);
 765          }
 766          int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 767          if (newLinePosition == 0)
 768              return;
<abbr title=" 769          editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editable.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);"> 769          editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editable.lengtðŸ”µ</abbr>
 770      }
 771  
 772      private void attemptAutoList(Editable editable) {
 773          int oldCursorPosition = mCurrentCursorPosition;
 774          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 775          AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 776          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 777      }
 778  
 779      private void saveAndSyncNote() {
 780          if (mNote == null) {
 781              return;
 782          }
 783  
 784          new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 785      }
 786  
 787      public void setPlaceholderVisible(boolean isVisible) {
 788          if (isVisible) {
 789              mNote = null;
 790              mContentEditText.setText(&quot;&quot;);
 791              mTagView.setText(&quot;&quot;);
 792              if (mPlaceholderView != null)
 793                  mPlaceholderView.setVisibility(View.VISIBLE);
 794          } else {
 795              if (mPlaceholderView != null)
 796                  mPlaceholderView.setVisibility(View.GONE);
 797          }
 798      }
 799  
 800      @Override
 801      public void onFocusChange(View v, boolean hasFocus) {
 802          if (!hasFocus) {
 803              String tagString = getNoteTagsString().trim();
 804              if (tagString.length() &gt; 0) {
 805                  mTagView.setChips(tagString);
 806              }
 807          }
 808      }
 809  
 810      private Note getNote() {
 811          return mNote;
 812      }
 813  
 814      public void setNote(String noteID) {
 815          setNote(noteID, null);
 816      }
 817  
 818      private String getNoteContentString() {
 819          if (mContentEditText == null || mContentEditText.getText() == null) {
 820              return &quot;&quot;;
 821          } else {
 822              return mContentEditText.getText().toString();
 823          }
 824      }
 825  
 826      private String getNoteTagsString() {
 827          if (mTagView == null || mTagView.getText() == null) {
 828              return &quot;&quot;;
 829          } else {
 830              return mTagView.getText().toString();
 831          }
 832      }
 833  
 834      /**
 835       * Share bottom sheet callbacks
 836       */
 837  
 838      @Override
 839      public void onSharePublishClicked() {
 840          publishNote();
 841          if (mShareBottomSheet != null) {
 842              mShareBottomSheet.dismiss();
 843          }
 844      }
 845  
 846      @Override
 847      public void onShareUnpublishClicked() {
 848          unpublishNote();
 849          if (mShareBottomSheet != null) {
 850              mShareBottomSheet.dismiss();
 851          }
 852      }
 853  
 854      @Override
 855      public void onWordPressPostClicked() {
 856          if (mShareBottomSheet != null) {
 857              mShareBottomSheet.dismiss();
 858          }
 859  
 860          if (getFragmentManager() == null) {
 861              return;
 862          }
 863  
 864          FragmentTransaction ft = getFragmentManager().beginTransaction();
 865          Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
 866          if (prev != null) {
 867              ft.remove(prev);
 868          }
 869          ft.addToBackStack(null);
 870  
 871          // Create and show the dialog.
 872          WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
 873          wpDialogFragment.setNote(mNote);
 874          wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
 875      }
 876  
 877      @Override
 878      public void onShareCollaborateClicked() {
 879          Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
 880      }
 881  
 882      @Override
 883      public void onShareDismissed() {
 884  
 885      }
 886  
 887      /**
 888       * History bottom sheet listeners
 889       */
 890  
 891      @Override
 892      public void onHistoryCancelClicked() {
 893          mContentEditText.setText(mNote.getContent());
 894          if (mHistoryBottomSheet != null) {
 895              mHistoryBottomSheet.dismiss();
 896          }
 897      }
 898  
 899      @Override
 900      public void onHistoryRestoreClicked() {
 901          if (mHistoryBottomSheet != null) {
 902              mHistoryBottomSheet.dismiss();
 903          }
 904          saveAndSyncNote();
 905      }
 906  
 907      @Override
 908      public void onHistoryDismissed() {
 909          if (!mHistoryBottomSheet.didTapOnButton()) {
 910              mContentEditText.setText(mNote.getContent());
 911          }
 912  
 913          if (mHistoryTimeoutHandler != null) {
 914              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 915          }
 916      }
 917  
 918      @Override
 919      public void onHistoryUpdateNote(String content) {
 920          mContentEditText.setText(content);
 921      }
 922  
 923      /**
 924       * Info bottom sheet listeners
 925       */
 926  
 927      @Override
 928      public void onInfoPinSwitchChanged(boolean isSwitchedOn) {
 929          NoteUtils.setNotePin(mNote, isSwitchedOn);
 930      }
 931  
 932      @Override
 933      public void onInfoMarkdownSwitchChanged(boolean isSwitchedOn) {
 934          mIsMarkdownEnabled = isSwitchedOn;
 935          Activity activity = getActivity();
 936  
 937          if (activity instanceof NoteEditorActivity) {
 938  
 939              NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 940              if (mIsMarkdownEnabled) {
 941  
 942                  editorActivity.showTabs();
 943  
 944                  if (mNoteMarkdownFragment == null) {
 945                      // Get markdown fragment and update content
 946                      mNoteMarkdownFragment =
 947                              editorActivity.getNoteMarkdownFragment();
 948                      mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 949                  }
 950              } else {
 951                  editorActivity.hideTabs();
 952              }
 953          } else if (activity instanceof NotesActivity) {
 954              setMarkdownEnabled(mIsMarkdownEnabled);
 955              ((NotesActivity) getActivity()).setMarkdownShowing(false);
 956          }
 957  
 958          saveNote();
 959      }
 960  
 961      @Override
 962      public void onInfoCopyLinkClicked() {
 963          copyToClipboard(mNote.getPublishedUrl());
 964          Toast.makeText(getActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();
 965      }
 966  
 967      @Override
 968      public void onInfoShareLinkClicked() {
 969          if (mInfoBottomSheet != null) {
 970              mInfoBottomSheet.dismiss();
 971          }
 972          showShareSheet();
 973      }
 974  
 975      @Override
 976      public void onInfoDismissed() {
 977  
 978      }
 979  
 980      protected void saveNote() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 981 -        if (mNote == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 982 -                mContentEditText == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 983 -                mIsLoadingNote ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 984 -                (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.isShowing())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 985 +        if (mNote == null || mContentEditText == null || mIsLoadingNote ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 986 +            (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {"> 986 +            (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialðŸ”µ</abbr></span>
 987              return;
 988          }
 989  
 990          String content = mContentEditText.getPlainTextContent();
 991          String tagString = getNoteTagsString();
 992  
<abbr title=" 993          if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {"> 993          if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) ðŸ”µ</abbr>
 994              mNote.setContent(content);
 995              mNote.setTagString(tagString);
 996              mNote.setModificationDate(Calendar.getInstance());
 997              mNote.setMarkdownEnabled(mIsMarkdownEnabled);
 998              mNote.setPreviewEnabled(mIsPreviewEnabled);
 999              mNote.save();
1000  
1001              AnalyticsTracker.track(
1002                      AnalyticsTracker.Stat.EDITOR_NOTE_EDITED,
1003                      AnalyticsTracker.CATEGORY_NOTE,
1004                      &quot;editor_save&quot;
1005              );































1006          }
1007      }
1008  
1009      // Checks if cursor is at a URL when the selection changes
1010      // If it is a URL, show the contextual action bar
1011      @Override
1012      public void onSelectionChanged(int selStart, int selEnd) {
1013          mCurrentCursorPosition = selEnd;
1014          if (selStart == selEnd) {
1015              Editable noteContent = mContentEditText.getText();
1016              if (noteContent == null)
1017                  return;
1018  
1019              URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1020              if (urlSpans.length &gt; 0) {
1021                  URLSpan urlSpan = urlSpans[0];
1022                  mLinkUrl = urlSpan.getURL();
<abbr title="1023                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1023                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSðŸ”µ</abbr>
1024                  if (mActionMode != null) {
1025                      mActionMode.setSubtitle(mLinkText);
1026                      setLinkMenuItem();
1027                      return;
1028                  }
1029  
1030                  // Show the Contextual Action Bar
1031                  if (getActivity() != null) {
1032                      mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);
1033                      if (mActionMode != null) {
1034                          mActionMode.setSubtitle(mLinkText);
1035                      }
1036  
1037                      setLinkMenuItem();
1038                  }
1039              } else if (mActionMode != null) {
1040                  mActionMode.finish();
1041                  mActionMode = null;
1042              }
1043          } else if (mActionMode != null) {
1044              mActionMode.finish();
1045              mActionMode = null;
1046          }
1047      }
1048  
1049      private void setLinkMenuItem() {
1050          if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1051              if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1052                  mViewLinkMenuItem.setIcon(mCallIcon);
1053                  mViewLinkMenuItem.setTitle(getString(R.string.call));
1054              } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1055                  mViewLinkMenuItem.setIcon(mEmailIcon);
1056                  mViewLinkMenuItem.setTitle(getString(R.string.email));
1057              } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1058                  mViewLinkMenuItem.setIcon(mMapIcon);
1059                  mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1060              } else {
1061                  mViewLinkMenuItem.setIcon(mWebIcon);
1062                  mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1063              }
1064          }
1065      }
1066  
1067      private void setPublishedNote(boolean isPublished) {
1068          if (mNote != null) {
1069              mNote.setPublished(isPublished);
1070              mNote.save();
1071  
1072              // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1073              mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1074  
1075              AnalyticsTracker.track(
1076                      (isPublished) ? AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED :
1077                              AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED,
1078                      AnalyticsTracker.CATEGORY_NOTE,
1079                      &quot;publish_note_button&quot;
1080              );
1081          }
1082      }
1083  
1084      private void updatePublishedState(boolean isSuccess) {
1085  
1086          if (mPublishingSnackbar == null) {
1087              return;
1088          }
1089  
1090          mPublishingSnackbar.dismiss();
1091          mPublishingSnackbar = null;
1092  
1093          if (isSuccess &amp;&amp; isAdded()) {
1094              if (mNote.isPublished()) {
1095  
1096                  if (mIsUndoingPublishing) {
1097                      SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1098                              R.color.status_positive,
1099                              Snackbar.LENGTH_LONG);
1100                  } else {
1101                      SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1102                              R.color.status_positive,
1103                              Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1104                                  @Override
1105                                  public void onClick(View v) {
1106                                      mIsUndoingPublishing = true;
1107                                      unpublishNote();
1108                                  }
1109                              });
1110                  }
1111                  copyToClipboard(mNote.getPublishedUrl());
1112              } else {
1113                  if (mIsUndoingPublishing) {
1114                      SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1115                              R.color.status_negative,
1116                              Snackbar.LENGTH_LONG);
1117                  } else {
1118                      SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1119                              R.color.status_negative,
1120                              Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1121                                  @Override
1122                                  public void onClick(View v) {
1123                                      mIsUndoingPublishing = true;
1124                                      publishNote();
1125                                  }
1126                              });
1127                  }
1128              }
1129          } else {
1130              if (mNote.isPublished()) {
1131                  SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_error,
1132                          R.color.status_negative, Snackbar.LENGTH_LONG);
1133              } else {
1134                  SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_error,
1135                          R.color.status_negative, Snackbar.LENGTH_LONG);
1136              }
1137          }
1138  
1139          mIsUndoingPublishing = false;
1140      }
1141  
1142      private void publishNote() {
1143  
1144          if (isAdded()) {
1145              mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.publishing,
1146                      R.color.blue, Snackbar.LENGTH_INDEFINITE);
1147          }
1148          setPublishedNote(true);
1149      }
1150  
1151      private void unpublishNote() {
1152  
1153          if (isAdded()) {
1154              mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublishing,
1155                      R.color.blue, Snackbar.LENGTH_INDEFINITE);
1156          }
1157          setPublishedNote(false);
1158      }
1159  
1160      private void copyToClipboard(String text) {
1161          ClipboardManager clipboard = (ClipboardManager) requireActivity()
1162                  .getSystemService(Context.CLIPBOARD_SERVICE);
1163          ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);
1164          if (clipboard != null) {
1165              clipboard.setPrimaryClip(clip);
1166          }
1167      }
1168  
1169      private void showShareSheet() {
1170          if (isAdded()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1171 -            mShareBottomSheet.show(mNote);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1172 +            mShareBottomSheet.show(requireFragmentManager(), mNote);</span>
1173          }
1174      }
1175  
1176      private void showInfoSheet() {
1177          if (isAdded()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1178 -            mInfoBottomSheet.show(mNote);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1179 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1180 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1181 +            mInfoBottomSheet.show(requireFragmentManager(), mNote);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1182 +        }</span>
1183      }
1184  
1185      private void showHistorySheet() {
1186          if (isAdded()) {
1187              // Request revisions for the current note
1188              mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());
1189              saveNote();
1190  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1191 -            mHistoryBottomSheet.show(mNote);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1192 +            mHistoryBottomSheet.show(requireFragmentManager(), mNote);</span>
1193          }
1194      }
1195  
1196      /**
1197       * Simperium listeners
1198       */
1199  
1200      @Override
1201      public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1202  
1203      }
1204  
1205      @Override
1206      public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {
1207          if (changeType == Bucket.ChangeType.MODIFY) {
1208              if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1209                  try {
1210                      final Note updatedNote = mNotesBucket.get(key);
1211                      if (getActivity() != null) {
1212                          getActivity().runOnUiThread(new Runnable() {
1213                              @Override
1214                              public void run() {
1215                                  if (mPublishTimeoutHandler != null) {
1216                                      mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1217                                  }
1218  
1219                                  updateNote(updatedNote);
1220                                  updatePublishedState(true);
1221                              }
1222                          });
1223                      }
1224                  } catch (BucketObjectMissingException e) {
1225                      e.printStackTrace();
1226                  }
1227              }
1228          }
1229      }
1230  
1231      @Override
1232      public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1233          // noop
1234      }
1235  
1236      @Override
1237      public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1238          // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1239          if (mIsLoadingNote)
1240              return;
1241  
1242          Note openNote = getNote();
1243          if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1244              return;
1245  
1246          note.setContent(mContentEditText.getPlainTextContent());
1247      }
1248  
1249      private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1250          WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1251  
1252          LoadNoteTask(NoteEditorFragment fragment) {
1253              weakFragment = new WeakReference&lt;&gt;(fragment);
1254          }
1255  
1256          @Override
1257          protected void onPreExecute() {
1258              NoteEditorFragment fragment = weakFragment.get();
1259              if (fragment != null) {
1260                  fragment.mContentEditText.removeTextChangedListener(fragment);
1261                  fragment.mIsLoadingNote = true;
1262              }
1263          }
1264  
1265          @Override
1266          protected Void doInBackground(String... args) {
1267              NoteEditorFragment fragment = weakFragment.get();
1268              if (fragment == null || fragment.getActivity() == null) {
1269                  return null;
1270              }
1271  
1272              String noteID = args[0];
1273              Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1274              Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1275  
1276              try {
1277                  fragment.mNote = notesBucket.get(noteID);
1278                  // Set the current note in NotesActivity when on a tablet
1279                  if (fragment.getActivity() instanceof NotesActivity) {
1280                      ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1281                  }
1282  
1283                  // Set markdown and preview flags for current note
1284                  if (fragment.mNote != null) {
1285                      fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1286                      fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1287                  }
1288              } catch (BucketObjectMissingException e) {
1289                  // See if the note is in the object store
1290                  Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1291                  while (notesCursor.moveToNext()) {
1292                      Note currentNote = notesCursor.getObject();
1293                      if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1294                          fragment.mNote = currentNote;
1295                          return null;
1296                      }
1297                  }
1298              }
1299  
1300              return null;
1301          }
1302  
1303          @Override
1304          protected void onPostExecute(Void nada) {
1305              final NoteEditorFragment fragment = weakFragment.get();
1306              if (fragment == null
1307                      || fragment.getActivity() == null
1308                      || fragment.getActivity().isFinishing()) {
1309                  return;
1310              }
1311  
1312              fragment.refreshContent(false);
1313              if (fragment.mMatchOffsets != null) {
<abbr title="1314                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1314                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.COðŸ”µ</abbr>
1315                  fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1316  
1317                  fragment.mShouldScrollToSearchMatch = true;
1318              }
1319  
1320              fragment.mContentEditText.addTextChangedListener(fragment);
1321  
1322              if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1323                  // Show soft keyboard
1324                  fragment.mContentEditText.requestFocus();
1325  
1326                  new Handler().postDelayed(new Runnable() {
1327                      @Override
1328                      public void run() {
1329                          if (fragment.getActivity() == null) {
1330                              return;
1331                          }
1332  
<abbr title="1333                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1333                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSysðŸ”µ</abbr>
1334                          if (inputMethodManager != null) {
1335                              inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1336                          }
1337                      }
1338                  }, 100);
1339  
1340              } else if (fragment.mNote != null) {
1341                  // If we have a valid note, hide the placeholder
1342                  fragment.setPlaceholderVisible(false);
1343              }
1344  
1345              fragment.updateMarkdownView();
1346  
1347              fragment.requireActivity().invalidateOptionsMenu();
1348  
1349              fragment.linkifyEditorContent();
1350              fragment.mIsLoadingNote = false;
1351          }
1352      }
1353  
1354      private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1355          WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1356  
1357          SaveNoteTask(NoteEditorFragment fragment) {
1358              weakFragment = new WeakReference&lt;&gt;(fragment);
1359          }
1360  
1361          @Override
1362          protected Void doInBackground(Void... args) {
1363              NoteEditorFragment fragment = weakFragment.get();
1364              if (fragment != null) {
1365                  fragment.saveNote();
1366              }
1367              return null;
1368          }
1369  
1370          @Override
1371          protected void onPostExecute(Void nada) {
1372              NoteEditorFragment fragment = weakFragment.get();
1373              if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {
1374                  // Update links
1375                  fragment.linkifyEditorContent();
1376                  fragment.updateMarkdownView();
1377              }
1378          }
1379      }
1380  
1381      private void linkifyEditorContent() {
1382          if (getActivity() == null || getActivity().isFinishing()) {
1383              return;
1384          }
1385  
1386          if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1387              SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1388          }
1389      }
1390  
1391      // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1392      private void updateMarkdownView() {
1393          if (!mIsMarkdownEnabled) {
1394              return;
1395          }
1396  
1397          Activity activity = getActivity();
1398          if (activity instanceof NotesActivity) {
1399              // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1400              loadMarkdownData();
1401          } else {
1402              // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1403              if (mNoteMarkdownFragment == null) {
1404                  mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1405                          .getNoteMarkdownFragment();
1406                  ((NoteEditorActivity) requireActivity()).showTabs();
1407              }
1408              // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1409              mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1410          }
1411      }
1412  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.app.Activity;
   4  import android.content.ClipData;
   5  import android.content.ClipboardManager;
   6  import android.content.Context;
   7  import android.content.Intent;
   8  import android.database.Cursor;
   9  import android.graphics.drawable.Drawable;
  10  import android.net.Uri;
  11  import android.os.AsyncTask;
  12  import android.os.Bundle;
  13  import android.os.Handler;
  14  import android.text.Editable;
  15  import android.text.Layout;
  16  import android.text.Spanned;
  17  import android.text.TextWatcher;
  18  import android.text.style.RelativeSizeSpan;
  19  import android.text.style.URLSpan;
  20  import android.text.util.Linkify;
  21  import android.util.TypedValue;
  22  import android.view.LayoutInflater;
  23  import android.view.Menu;
  24  import android.view.MenuInflater;
  25  import android.view.MenuItem;
  26  import android.view.View;
  27  import android.view.ViewGroup;
  28  import android.view.ViewTreeObserver;
  29  import android.view.inputmethod.InputMethodManager;
  30  import android.webkit.WebView;
  31  import android.widget.CursorAdapter;
  32  import android.widget.LinearLayout;
  33  import android.widget.ScrollView;
  34  import android.widget.TextView;
  35  import android.widget.Toast;
  36  
  37  import androidx.annotation.NonNull;
  38  import androidx.appcompat.app.AppCompatActivity;
  39  import androidx.appcompat.view.ActionMode;
  40  import androidx.core.widget.NestedScrollView;
  41  import androidx.fragment.app.Fragment;
  42  import androidx.fragment.app.FragmentTransaction;
  43  
  44  import com.automattic.simplenote.analytics.AnalyticsTracker;
  45  import com.automattic.simplenote.models.Note;
  46  import com.automattic.simplenote.models.Tag;
  47  import com.automattic.simplenote.utils.AutoBullet;
  48  import com.automattic.simplenote.utils.ContextUtils;
  49  import com.automattic.simplenote.utils.DisplayUtils;
  50  import com.automattic.simplenote.utils.DrawableUtils;
  51  import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  52  import com.automattic.simplenote.utils.NoteUtils;
  53  import com.automattic.simplenote.utils.PrefUtils;
  54  import com.automattic.simplenote.utils.SimplenoteLinkify;
  55  import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  56  import com.automattic.simplenote.utils.SnackbarUtils;
  57  import com.automattic.simplenote.utils.SpaceTokenizer;
  58  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  59  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  60  import com.automattic.simplenote.utils.TextHighlighter;
  61  import com.automattic.simplenote.utils.ThemeUtils;
  62  import com.automattic.simplenote.utils.WidgetUtils;
  63  import com.automattic.simplenote.widgets.SimplenoteEditText;
  64  import com.google.android.material.snackbar.Snackbar;
  65  import com.simperium.client.Bucket;
  66  import com.simperium.client.BucketObjectMissingException;
  67  import com.simperium.client.Query;
  68  
  69  import java.lang.ref.WeakReference;
  70  import java.util.Calendar;
  71  
  72  public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  73          TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  74          SimplenoteEditText.OnSelectionChangedListener,
  75          ShareBottomSheetDialog.ShareSheetListener,
  76          HistoryBottomSheetDialog.HistorySheetListener,
  77          InfoBottomSheetDialog.InfoSheetListener,
  78          SimplenoteEditText.OnCheckboxToggledListener {
  79  
  80      public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  81      public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
  82      public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
  83      public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
  84      public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
  85      private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
  86      private static final int AUTOSAVE_DELAY_MILLIS = 2000;
  87      private static final int MAX_REVISIONS = 30;
  88      private static final int PUBLISH_TIMEOUT = 20000;
  89      private static final int HISTORY_TIMEOUT = 10000;
  90      private Note mNote;
  91      private final Runnable mAutoSaveRunnable = new Runnable() {
  92          @Override
  93          public void run() {
  94              saveAndSyncNote();
  95          }
  96      };
  97      private Bucket&lt;Note&gt; mNotesBucket;
  98      private View mRootView;
  99      private SimplenoteEditText mContentEditText;
 100      private TagsMultiAutoCompleteTextView mTagView;
 101      private Handler mAutoSaveHandler;
 102      private Handler mPublishTimeoutHandler;
 103      private Handler mHistoryTimeoutHandler;
 104      private LinearLayout mPlaceholderView;
 105      private CursorAdapter mAutocompleteAdapter;
 106      private boolean mIsLoadingNote;
 107      private boolean mIsMarkdownEnabled;
 108      private boolean mIsPreviewEnabled;
 109      private boolean mShouldScrollToSearchMatch;
 110      private ActionMode mActionMode;
 111      private MenuItem mViewLinkMenuItem;
 112      private String mLinkUrl;
 113      private String mLinkText;
 114      private MatchOffsetHighlighter mHighlighter;
 115      private Drawable mEmailIcon, mWebIcon, mMapIcon, mCallIcon;
 116      private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 117      private String mMatchOffsets;
 118      private int mCurrentCursorPosition;
 119      private HistoryBottomSheetDialog mHistoryBottomSheet;
 120      // Hides the history bottom sheet if no revisions are loaded
 121      private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 122          @Override
 123          public void run() {
 124              if (!isAdded()) return;



 125  
 126              requireActivity().runOnUiThread(new Runnable() {
 127                  @Override
 128                  public void run() {
 129  
 130                      if (mHistoryBottomSheet.isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {

 131                          mHistoryBottomSheet.dismiss();
 132                          Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 133                      }
 134                  }
 135              });
 136  
 137          }
 138      };
 139      private InfoBottomSheetDialog mInfoBottomSheet;
 140      private ShareBottomSheetDialog mShareBottomSheet;
 141      // Contextual action bar for dealing with links
 142      private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 143  
 144          // Called when the action mode is created; startActionMode() was called
 145          @Override
 146          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 147              // Inflate a menu resource providing context menu items
 148              MenuInflater inflater = mode.getMenuInflater();

 149              if (inflater != null) {
 150                  inflater.inflate(R.menu.view_link, menu);
 151                  mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 152                  mode.setTitle(getString(R.string.link));
 153                  mode.setTitleOptionalHint(false);
 154  
 155                  DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 156              }
 157  
<abbr title=" 158              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 158              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgrðŸ”µ</abbr>
<abbr title=" 159              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 159              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().ðŸ”µ</abbr>
 160              return true;
 161          }
 162  
 163          // Called each time the action mode is shown. Always called after onCreateActionMode, but
 164          // may be called multiple times if the mode is invalidated.
 165          @Override
 166          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 167              return false; // Return false if nothing is done
 168          }
 169  
 170          // Called when the user selects a contextual menu item
 171          @Override
 172          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 173              switch (item.getItemId()) {
 174                  case R.id.menu_view_link:
 175                      if (mLinkUrl != null) {
 176                          try {
 177                              Uri uri = Uri.parse(mLinkUrl);
 178                              Intent i = new Intent(Intent.ACTION_VIEW);
 179                              i.setData(uri);
 180                              startActivity(i);
 181                          } catch (Exception e) {
 182                              e.printStackTrace();
 183                          }
 184                          mode.finish(); // Action picked, so close the CAB
 185                      }
 186                      return true;
 187                  case R.id.menu_copy:
 188                      if (mLinkText != null &amp;&amp; getActivity() != null) {
 189                          copyToClipboard(mLinkText);
<abbr title=" 190                          Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();"> 190                          Toast.makeText(requireActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).shoðŸ”µ</abbr>
 191                          mode.finish();
 192                      }
 193                      return true;
 194                  case R.id.menu_share:
 195                      if (mLinkText != null) {
 196                          showShareSheet();
 197                          mode.finish();
 198                      }
 199                      return true;
 200                  default:
 201                      return false;
 202              }
 203          }
 204  
 205          // Called when the user exits the action mode
 206          @Override
 207          public void onDestroyActionMode(ActionMode mode) {
 208              mActionMode = null;
 209              new Handler().postDelayed(
 210                  new Runnable() {
 211                      @Override
 212                      public void run() {
<abbr title=" 213                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 213                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.trðŸ”µ</abbr>
 214                      }
 215                  },
 216                  requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 217              );
 218          }
 219      };
 220      private Snackbar mPublishingSnackbar;
 221      private boolean mIsUndoingPublishing;
 222      // Resets note publish status if Simperium never returned the new publish status
 223      private final Runnable mPublishTimeoutRunnable = new Runnable() {
 224          @Override
 225          public void run() {
 226              if (!isAdded()) return;
 227  
 228              requireActivity().runOnUiThread(new Runnable() {
 229                  @Override
 230                  public void run() {
 231  
 232                      mNote.setPublished(!mNote.isPublished());
 233                      mNote.save();
 234  
 235                      updatePublishedState(false);
 236                  }
 237              });
 238          }
 239      };
 240      private NoteMarkdownFragment mNoteMarkdownFragment;
 241      private String mCss;
 242      private WebView mMarkdown;
 243  
 244      /**
 245       * Mandatory empty constructor for the fragment manager to instantiate the
 246       * fragment (e.g. upon screen orientation changes).
 247       */
 248      public NoteEditorFragment() {
 249      }
 250  
 251      @Override
 252      public void onCreate(Bundle savedInstanceState) {
 253          super.onCreate(savedInstanceState);
 254          mInfoBottomSheet = new InfoBottomSheetDialog(this, this);
 255          mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 256          mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 257  
 258          Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 259          mNotesBucket = currentApp.getNotesBucket();
 260  
<abbr title=" 261          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 261          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 262          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dp, R.attr.actionModeTextColor);"> 262          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_white_24dp, R.attrðŸ”µ</abbr>
<abbr title=" 263          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, R.attr.actionModeTextColor);"> 263          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_white_24dp, R.attr.actðŸ”µ</abbr>
<abbr title=" 264          mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, R.attr.actionModeTextColor);"> 264          mWebIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_web_white_24dp, R.attr.actðŸ”µ</abbr>
 265  
 266          mAutoSaveHandler = new Handler();
 267          mPublishTimeoutHandler = new Handler();
 268          mHistoryTimeoutHandler = new Handler();
 269  
 270          mMatchHighlighter = new TextHighlighter(requireActivity(),
 271                  R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);
 272          mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 273              @Override
 274              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 275                  Activity activity = (Activity) context;
 276                  if (activity == null) return null;
 277                  return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 278              }
 279  
 280              @Override
 281              public void bindView(View view, Context context, Cursor cursor) {
 282                  TextView textView = (TextView) view;
 283                  textView.setText(convertToString(cursor));
 284              }
 285  
 286              @Override
 287              public CharSequence convertToString(Cursor cursor) {
 288                  return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 289              }
 290  
 291              @Override
 292              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 293                  Activity activity = getActivity();
 294                  if (activity == null) return null;
 295                  Simplenote application = (Simplenote) activity.getApplication();
 296                  Query&lt;Tag&gt; query = application.getTagsBucket().query();
 297                  // make the tag name available to the cursor
 298                  query.include(Tag.NAME_PROPERTY);
 299                  // sort the tags by their names
 300                  query.order(Tag.NAME_PROPERTY);
 301                  // if there&#x27;s a filter string find only matching tag names
 302                  if (filter != null)
 303                      query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));
 304                  return query.execute();
 305              }
 306          };
 307  
 308          WidgetUtils.updateNoteWidgets(getActivity());
 309      }
 310  
 311      @Override
 312      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 313          mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 314          mContentEditText = mRootView.findViewById(R.id.note_content);
 315          mContentEditText.addOnSelectionChangedListener(this);
 316          mContentEditText.setOnCheckboxToggledListener(this);
 317          mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 318          mTagView = mRootView.findViewById(R.id.tag_view);
 319          mTagView.setTokenizer(new SpaceTokenizer());
 320          mTagView.setOnFocusChangeListener(this);
 321          mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 322  
 323          mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 324          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 325              mPlaceholderView.setVisibility(View.VISIBLE);
 326              requireActivity().invalidateOptionsMenu();
 327              mMarkdown = mRootView.findViewById(R.id.markdown);
 328              mCss = ThemeUtils.isLightTheme(requireContext())
 329                      ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 330                      : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 331          }
 332  
 333          mTagView.setAdapter(mAutocompleteAdapter);
 334  
 335          Bundle arguments = getArguments();
 336          if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 337              // Load note if we were passed a note Id
 338              String key = arguments.getString(ARG_ITEM_ID);
 339              if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 340                  mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 341              }
 342              new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 343          } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null ) {
 344              // Restore selected note when in dual pane mode
 345              String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 346              if (noteId != null) {
 347                  setNote(noteId);
 348              }
 349          }
 350  
 351          ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 352          viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 353              @Override
 354              public void onGlobalLayout() {
 355                  // If a note was loaded with search matches, scroll to the first match in the editor
 356                  if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 357                      if (!isAdded()) {
 358                          return;
 359                      }
 360  
 361                      // Get the character location of the first search match
 362                      int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 363                              mContentEditText.getText(),
 364                              mMatchOffsets
 365                      );
 366                      if (matchLocation == 0) {
 367                          return;
 368                      }
 369  
 370                      // Calculate how far to scroll to bring the match into view
 371                      Layout layout = mContentEditText.getLayout();
 372                      int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 373  
 374                      // We use different scroll views in the root of the layout files... yuck.
 375                      // So we have to cast appropriately to do a smooth scroll
 376                      if (mRootView instanceof NestedScrollView) {
 377                          ((NestedScrollView)mRootView).smoothScrollTo(0, lineTop);
 378                      } else {
 379                          ((ScrollView)mRootView).smoothScrollTo(0, lineTop);
 380                      }
 381  
 382                      mShouldScrollToSearchMatch = false;
 383                  }
 384              }
 385          });
 386          setHasOptionsMenu(true);
 387          return mRootView;
 388      }
 389  
 390      @Override
 391      public void onResume() {
 392          super.onResume();
 393          mNotesBucket.start();
 394          mNotesBucket.addListener(this);
 395  
 396          mTagView.setOnTagAddedListener(this);
 397  
 398          if (mContentEditText != null) {
 399              mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));
 400  
 401              if (mContentEditText.hasFocus()) {
 402                  showSoftKeyboard();
 403              }
 404          }
 405      }
 406  
 407      private void showSoftKeyboard() {
 408          new Handler().postDelayed(new Runnable() {
 409              @Override
 410              public void run() {
 411                  if (getActivity() == null) {
 412                      return;
 413                  }
 414  
<abbr title=" 415                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 415                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(ContexðŸ”µ</abbr>
 416                  if (inputMethodManager != null) {
 417                      inputMethodManager.showSoftInput(mContentEditText, 0);
 418                  }
 419              }
 420          }, 100);
 421      }
 422  
 423      @Override
 424      public void onPause() {
 425          super.onPause();  // Always call the superclass method first
 426  
 427          mNotesBucket.removeListener(this);
 428          mNotesBucket.stop();
 429  
 430          // Hide soft keyboard if it is showing...
 431          DisplayUtils.hideKeyboard(mContentEditText);
 432  
 433          mTagView.setOnTagAddedListener(null);
 434  
 435          if (mAutoSaveHandler != null) {
 436              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 437          }
 438  
 439          if (mPublishTimeoutHandler != null) {
 440              mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 441          }
 442  
 443          if (mHistoryTimeoutHandler != null) {
 444              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 445          }
 446  
 447          mHighlighter.stop();
 448          saveNote();
 449      }
 450  
 451      @Override
 452      public void onSaveInstanceState(@NonNull Bundle outState) {
 453          super.onSaveInstanceState(outState);
 454  
 455          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 456              outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 457          }
 458      }
 459  
 460      @Override
 461      public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 462          super.onCreateOptionsMenu(menu, inflater);
 463          if (!isAdded() || DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null) {
 464              return;
 465          }
 466  
 467          inflater.inflate(R.menu.note_editor, menu);
 468  
 469          if (mNote != null) {
 470              MenuItem viewPublishedNoteItem = menu.findItem(R.id.menu_view_info);
 471              viewPublishedNoteItem.setVisible(true);
 472  
 473              MenuItem trashItem = menu.findItem(R.id.menu_delete).setTitle(R.string.undelete);
 474  
 475              if (mNote.isDeleted()) {
 476                  trashItem.setTitle(R.string.undelete);
 477                  trashItem.setIcon(R.drawable.ic_trash_restore_24dp);
 478              } else {
 479                  trashItem.setTitle(R.string.delete);
 480                  trashItem.setIcon(R.drawable.ic_trash_24dp);
 481              }
 482          }
 483          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionBarTextColor);
 484      }
 485  
 486      @Override
 487      public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 488          switch (item.getItemId()) {
 489              case R.id.menu_view_info:
 490                  showInfo();
 491                  return true;
 492              case R.id.menu_checklist:
 493                  insertChecklist();
 494                  return true;
 495              case R.id.menu_history:
 496                  showHistory();
 497                  return true;
 498              case R.id.menu_share:
 499                  shareNote();
 500                  return true;
 501              case R.id.menu_delete:
 502                  if (!isAdded()) return false;
 503                  deleteNote();
 504                  return true;
 505              case android.R.id.home:
 506                  if (!isAdded()) return false;
 507                  requireActivity().finish();
 508                  return true;
 509              default:
 510                  return super.onOptionsItemSelected(item);
 511          }
 512      }
 513  
 514      private void insertChecklist() {
 515          try {
 516              mContentEditText.insertChecklist();
 517          } catch (Exception e) {
 518              e.printStackTrace();
 519              return;
 520          }
 521  
 522          AnalyticsTracker.track(
 523                  AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED,
 524                  AnalyticsTracker.CATEGORY_NOTE,
 525                  &quot;toolbar_button&quot;
 526          );
 527      }
 528  
 529      @Override
 530      public void onCheckboxToggled() {
 531          // Save note (using delay) after toggling a checkbox
 532          if (mAutoSaveHandler != null) {
 533              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 534              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 535          }
 536      }
 537  
 538      private void deleteNote() {
 539          NoteUtils.deleteNote(mNote, getActivity());
 540          requireActivity().finish();
 541      }
 542  
 543      protected void clearMarkdown() {
 544          mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 545      }
 546  
 547      protected void hideMarkdown() {
 548          mMarkdown.setVisibility(View.INVISIBLE);
 549      }
 550  
 551      protected void showMarkdown() {
 552          loadMarkdownData();
 553          mMarkdown.setVisibility(View.VISIBLE);
 554      }
 555  
 556      private void shareNote() {
 557          if (mNote != null) {
 558              mContentEditText.clearFocus();
 559              showShareSheet();
 560              AnalyticsTracker.track(
 561                      AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED,
 562                      AnalyticsTracker.CATEGORY_NOTE,
 563                      &quot;action_bar_share_button&quot;
 564              );
 565          }
 566      }
 567  
 568      private void showHistory() {
 569          if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 570              mContentEditText.clearFocus();
 571              mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 572              showHistorySheet();
 573          } else {
 574              Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 575          }
 576      }
 577  
 578      private void showInfo() {
 579          if (mNote != null) {
 580              mContentEditText.clearFocus();
 581              saveNote();
 582              showInfoSheet();
 583          }
 584      }
 585  
 586      protected void setMarkdownEnabled(boolean enabled) {
 587          mIsMarkdownEnabled = enabled;
 588  
 589          if (mIsMarkdownEnabled) {
 590              loadMarkdownData();
 591          }
 592      }
 593  
 594      private void loadMarkdownData() {
 595          String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 596                  mCss,
 597                  mContentEditText.getPlainTextContent()
 598          );
 599  
 600          mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 601      }
 602  
 603      public void setNote(String noteID, String matchOffsets) {
 604          if (mAutoSaveHandler != null)
 605              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 606  
 607          mPlaceholderView.setVisibility(View.GONE);
 608  
 609          if (matchOffsets != null) {
 610              mMatchOffsets = matchOffsets;
 611          } else {
 612              mMatchOffsets = null;
 613          }
 614  
 615  
 616          saveNote();
 617  
 618          new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 619      }
 620  
 621      private void updateNote(Note updatedNote) {
 622          // update note if network change arrived
 623          mNote = updatedNote;
 624          refreshContent(true);
 625      }
 626  
 627      private void refreshContent(boolean isNoteUpdate) {
 628          if (mNote != null) {
 629              // Restore the cursor position if possible.
 630  
<abbr title=" 631              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 631              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.geðŸ”µ</abbr>
 632  
 633              mContentEditText.setText(mNote.getContent());
 634  
 635              if (isNoteUpdate) {
 636                  // Save the note so any local changes get synced
 637                  mNote.save();
 638  
 639                  if (mContentEditText.hasFocus()
 640                          &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 641                          &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 642                      mContentEditText.setSelection(cursorPosition);
 643                  }
 644              }
 645  
 646              afterTextChanged(mContentEditText.getText());
 647              mContentEditText.processChecklists();
 648              updateTagList();
 649          }
 650      }
 651  
 652      private void updateTagList() {
 653          Activity activity = getActivity();
 654          if (activity == null) return;
 655  
 656          // Populate this note&#x27;s tags in the tagView
 657          mTagView.setChips(mNote.getTagString());
 658      }
 659  
 660      private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 661          // Ported from the iOS app :)
 662          // Cases:
 663          // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 664          // 1. Text was added after the cursor ==&gt; no change
 665          // 2. Text was added before the cursor ==&gt; location advances
 666          // 3. Text was removed after the cursor ==&gt; no change
 667          // 4. Text was removed before the cursor ==&gt; location retreats
 668          // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 669  
 670          cursorLocation = Math.max(cursorLocation, 0);
 671  
 672          int newCursorLocation = cursorLocation;
 673  
 674          int deltaLength = newText.length() - oldText.length();
 675  
 676          // Case 0
 677          if (newText.length() &lt; cursorLocation)
 678              return newText.length();
 679  
 680          boolean beforeCursorMatches = false;
 681          boolean afterCursorMatches = false;
 682  
 683          try {
<abbr title=" 684              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 684              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation)ðŸ”µ</abbr>
<abbr title=" 685              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 685              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaðŸ”µ</abbr>
 686          } catch (Exception e) {
 687              e.printStackTrace();
 688          }
 689  
 690          // Cases 2 and 4
 691          if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 692              newCursorLocation += deltaLength;
 693  
 694          // Cases 1, 3 and 5 have no change
 695          return newCursorLocation;
 696      }
 697  
 698      @Override
 699      public void onTagsChanged(String tagString) {
 700          if (mNote == null || !isAdded()) return;
 701  
 702          if (mNote.getTagString() != null &amp;&amp; tagString.length() &gt; mNote.getTagString().length()) {
 703              AnalyticsTracker.track(
 704                      AnalyticsTracker.Stat.EDITOR_TAG_ADDED,
 705                      AnalyticsTracker.CATEGORY_NOTE,
 706                      &quot;tag_added_to_note&quot;
 707              );
 708          } else {
 709              AnalyticsTracker.track(
 710                      AnalyticsTracker.Stat.EDITOR_TAG_REMOVED,
 711                      AnalyticsTracker.CATEGORY_NOTE,
 712                      &quot;tag_removed_from_note&quot;
 713              );
 714          }
 715  
 716          mNote.setTagString(tagString);
 717          mNote.setModificationDate(Calendar.getInstance());
 718          updateTagList();
 719          mNote.save();
 720      }
 721  
 722      @Override
 723      public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 724          // Unused
 725      }
 726  
 727      @Override
 728      public void afterTextChanged(Editable editable) {
 729          attemptAutoList(editable);
 730          setTitleSpan(editable);
 731          mContentEditText.fixLineSpacing();
 732      }
 733  
 734      @Override
 735      public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 736          // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 737          if (mAutoSaveHandler != null) {
 738              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 739              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 740          }
 741  
 742          // Remove search highlight spans when note content changes
 743          if (mMatchOffsets != null) {
 744              mMatchOffsets = null;
 745              mHighlighter.removeMatches();
 746          }
 747  
 748          // Temporarily remove the text watcher as we process checklists to prevent callback looping
 749          mContentEditText.removeTextChangedListener(this);
 750          mContentEditText.processChecklists();
 751          mContentEditText.addTextChangedListener(this);
 752      }
 753  
 754      private void setTitleSpan(Editable editable) {
 755          // Set the note title to be a larger size
 756          // Remove any existing size spans
 757          RelativeSizeSpan[] spans = editable.getSpans(0, editable.length(), RelativeSizeSpan.class);
 758          for (RelativeSizeSpan span : spans) {
 759              editable.removeSpan(span);
 760          }
 761          int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 762          if (newLinePosition == 0)
 763              return;
<abbr title=" 764          editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editable.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);"> 764          editable.setSpan(new RelativeSizeSpan(1.227f), 0, (newLinePosition &gt; 0) ? newLinePosition : editable.lengtðŸ”µ</abbr>
 765      }
 766  
 767      private void attemptAutoList(Editable editable) {
 768          int oldCursorPosition = mCurrentCursorPosition;
 769          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 770          AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 771          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 772      }
 773  
 774      private void saveAndSyncNote() {
 775          if (mNote == null) {
 776              return;
 777          }
 778  
 779          new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 780      }
 781  
 782      public void setPlaceholderVisible(boolean isVisible) {
 783          if (isVisible) {
 784              mNote = null;
 785              mContentEditText.setText(&quot;&quot;);
 786              mTagView.setText(&quot;&quot;);
 787              if (mPlaceholderView != null)
 788                  mPlaceholderView.setVisibility(View.VISIBLE);
 789          } else {
 790              if (mPlaceholderView != null)
 791                  mPlaceholderView.setVisibility(View.GONE);
 792          }
 793      }
 794  
 795      @Override
 796      public void onFocusChange(View v, boolean hasFocus) {
 797          if (!hasFocus) {
 798              String tagString = getNoteTagsString().trim();
 799              if (tagString.length() &gt; 0) {
 800                  mTagView.setChips(tagString);
 801              }
 802          }
 803      }
 804  
 805      private Note getNote() {
 806          return mNote;
 807      }
 808  
 809      public void setNote(String noteID) {
 810          setNote(noteID, null);
 811      }
 812  
 813      private String getNoteContentString() {
 814          if (mContentEditText == null || mContentEditText.getText() == null) {
 815              return &quot;&quot;;
 816          } else {
 817              return mContentEditText.getText().toString();
 818          }
 819      }
 820  
 821      private String getNoteTagsString() {
 822          if (mTagView == null || mTagView.getText() == null) {
 823              return &quot;&quot;;
 824          } else {
 825              return mTagView.getText().toString();
 826          }
 827      }
 828  
 829      /**
 830       * Share bottom sheet callbacks
 831       */
 832  
 833      @Override
 834      public void onSharePublishClicked() {
 835          publishNote();
 836          if (mShareBottomSheet != null) {
 837              mShareBottomSheet.dismiss();
 838          }
 839      }
 840  
 841      @Override
 842      public void onShareUnpublishClicked() {
 843          unpublishNote();
 844          if (mShareBottomSheet != null) {
 845              mShareBottomSheet.dismiss();
 846          }
 847      }
 848  
 849      @Override
 850      public void onWordPressPostClicked() {
 851          if (mShareBottomSheet != null) {
 852              mShareBottomSheet.dismiss();
 853          }
 854  
 855          if (getFragmentManager() == null) {
 856              return;
 857          }
 858  
 859          FragmentTransaction ft = getFragmentManager().beginTransaction();
 860          Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
 861          if (prev != null) {
 862              ft.remove(prev);
 863          }
 864          ft.addToBackStack(null);
 865  
 866          // Create and show the dialog.
 867          WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
 868          wpDialogFragment.setNote(mNote);
 869          wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
 870      }
 871  
 872      @Override
 873      public void onShareCollaborateClicked() {
 874          Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
 875      }
 876  
 877      @Override
 878      public void onShareDismissed() {
 879  
 880      }
 881  
 882      /**
 883       * History bottom sheet listeners
 884       */
 885  
 886      @Override
 887      public void onHistoryCancelClicked() {
 888          mContentEditText.setText(mNote.getContent());
 889          if (mHistoryBottomSheet != null) {
 890              mHistoryBottomSheet.dismiss();
 891          }
 892      }
 893  
 894      @Override
 895      public void onHistoryRestoreClicked() {
 896          if (mHistoryBottomSheet != null) {
 897              mHistoryBottomSheet.dismiss();
 898          }
 899          saveAndSyncNote();
 900      }
 901  
 902      @Override
 903      public void onHistoryDismissed() {
 904          if (!mHistoryBottomSheet.didTapOnButton()) {
 905              mContentEditText.setText(mNote.getContent());
 906          }
 907  
 908          if (mHistoryTimeoutHandler != null) {
 909              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 910          }
 911      }
 912  
 913      @Override
 914      public void onHistoryUpdateNote(String content) {
 915          mContentEditText.setText(content);
 916      }
 917  
 918      /**
 919       * Info bottom sheet listeners
 920       */
 921  
 922      @Override
 923      public void onInfoPinSwitchChanged(boolean isSwitchedOn) {
 924          NoteUtils.setNotePin(mNote, isSwitchedOn);
 925      }
 926  
 927      @Override
 928      public void onInfoMarkdownSwitchChanged(boolean isSwitchedOn) {
 929          mIsMarkdownEnabled = isSwitchedOn;
 930          Activity activity = getActivity();
 931  
 932          if (activity instanceof NoteEditorActivity) {
 933  
 934              NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 935              if (mIsMarkdownEnabled) {
 936  
 937                  editorActivity.showTabs();
 938  
 939                  if (mNoteMarkdownFragment == null) {
 940                      // Get markdown fragment and update content
 941                      mNoteMarkdownFragment =
 942                              editorActivity.getNoteMarkdownFragment();
 943                      mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 944                  }
 945              } else {
 946                  editorActivity.hideTabs();
 947              }
 948          } else if (activity instanceof NotesActivity) {
 949              setMarkdownEnabled(mIsMarkdownEnabled);
 950              ((NotesActivity) getActivity()).setMarkdownShowing(false);
 951          }
 952  
 953          saveNote();
 954      }
 955  
 956      @Override
 957      public void onInfoCopyLinkClicked() {
 958          copyToClipboard(mNote.getPublishedUrl());
 959          Toast.makeText(getActivity(), getString(R.string.link_copied), Toast.LENGTH_SHORT).show();
 960      }
 961  
 962      @Override
 963      public void onInfoShareLinkClicked() {
 964          if (mInfoBottomSheet != null) {
 965              mInfoBottomSheet.dismiss();
 966          }
 967          showShareSheet();
 968      }
 969  
 970      @Override
 971      public void onInfoDismissed() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 972 -</span>
 973      }
 974  
 975      protected void saveNote() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 976 -        if (mNote == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 977 -                mContentEditText == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 978 -                mIsLoadingNote ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 979 -                (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.isShowing())) {</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 980 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 981 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 982 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 983 -        String content = mContentEditText.getPlainTextContent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 984 -        String tagString = getNoteTagsString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 985 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 986 -        if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {"> 986 -        if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 987 -            mNote.setContent(content);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 988 -            mNote.setTagString(tagString);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 989 -            mNote.setModificationDate(Calendar.getInstance());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 990 -            mNote.setMarkdownEnabled(mIsMarkdownEnabled);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 991 -            mNote.setPreviewEnabled(mIsPreviewEnabled);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 992 -            mNote.save();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 993 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 994 -            AnalyticsTracker.track(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 995 -                    AnalyticsTracker.Stat.EDITOR_NOTE_EDITED,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 996 -                    AnalyticsTracker.CATEGORY_NOTE,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 997 -                    &quot;editor_save&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 998 -            );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 999 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1000 +            Simplenote application = (Simplenote) requireActivity().getApplication();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1001 +            Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1002 +            mNote = notesBucket.get(mNote.getSimperiumKey());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1003 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1004 +            if (mNote == null || mContentEditText == null || mIsLoadingNote ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1005 +                    (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.isShowing())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1006 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1007 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1008 +                mIsPreviewEnabled = mNote.isPreviewEnabled();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1009 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1010 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1011 +            String content = mContentEditText.getPlainTextContent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1012 +            String tagString = getNoteTagsString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1013 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1014 +            if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1014 +            if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnableðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1015 +                mNote.setContent(content);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1016 +                mNote.setTagString(tagString);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1017 +                mNote.setModificationDate(Calendar.getInstance());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1018 +                mNote.setMarkdownEnabled(mIsMarkdownEnabled);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1019 +                mNote.setPreviewEnabled(mIsPreviewEnabled);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1020 +                mNote.save();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1021 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1022 +                AnalyticsTracker.track(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1023 +                        AnalyticsTracker.Stat.EDITOR_NOTE_EDITED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1024 +                        AnalyticsTracker.CATEGORY_NOTE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1025 +                        &quot;editor_save&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1026 +                );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1027 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1028 +        } catch (BucketObjectMissingException exception) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1029 +            exception.printStackTrace();</span>
1030          }
1031      }
1032  
1033      // Checks if cursor is at a URL when the selection changes
1034      // If it is a URL, show the contextual action bar
1035      @Override
1036      public void onSelectionChanged(int selStart, int selEnd) {
1037          mCurrentCursorPosition = selEnd;
1038          if (selStart == selEnd) {
1039              Editable noteContent = mContentEditText.getText();
1040              if (noteContent == null)
1041                  return;
1042  
1043              URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1044              if (urlSpans.length &gt; 0) {
1045                  URLSpan urlSpan = urlSpans[0];
1046                  mLinkUrl = urlSpan.getURL();
<abbr title="1047                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1047                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSðŸ”µ</abbr>
1048                  if (mActionMode != null) {
1049                      mActionMode.setSubtitle(mLinkText);
1050                      setLinkMenuItem();
1051                      return;
1052                  }
1053  
1054                  // Show the Contextual Action Bar
1055                  if (getActivity() != null) {
1056                      mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);
1057                      if (mActionMode != null) {
1058                          mActionMode.setSubtitle(mLinkText);
1059                      }
1060  
1061                      setLinkMenuItem();
1062                  }
1063              } else if (mActionMode != null) {
1064                  mActionMode.finish();
1065                  mActionMode = null;
1066              }
1067          } else if (mActionMode != null) {
1068              mActionMode.finish();
1069              mActionMode = null;
1070          }
1071      }
1072  
1073      private void setLinkMenuItem() {
1074          if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1075              if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1076                  mViewLinkMenuItem.setIcon(mCallIcon);
1077                  mViewLinkMenuItem.setTitle(getString(R.string.call));
1078              } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1079                  mViewLinkMenuItem.setIcon(mEmailIcon);
1080                  mViewLinkMenuItem.setTitle(getString(R.string.email));
1081              } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1082                  mViewLinkMenuItem.setIcon(mMapIcon);
1083                  mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1084              } else {
1085                  mViewLinkMenuItem.setIcon(mWebIcon);
1086                  mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1087              }
1088          }
1089      }
1090  
1091      private void setPublishedNote(boolean isPublished) {
1092          if (mNote != null) {
1093              mNote.setPublished(isPublished);
1094              mNote.save();
1095  
1096              // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1097              mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1098  
1099              AnalyticsTracker.track(
1100                      (isPublished) ? AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED :
1101                              AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED,
1102                      AnalyticsTracker.CATEGORY_NOTE,
1103                      &quot;publish_note_button&quot;
1104              );
1105          }
1106      }
1107  
1108      private void updatePublishedState(boolean isSuccess) {
1109  
1110          if (mPublishingSnackbar == null) {
1111              return;
1112          }
1113  
1114          mPublishingSnackbar.dismiss();
1115          mPublishingSnackbar = null;
1116  
1117          if (isSuccess &amp;&amp; isAdded()) {
1118              if (mNote.isPublished()) {
1119  
1120                  if (mIsUndoingPublishing) {
1121                      SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1122                              R.color.status_positive,
1123                              Snackbar.LENGTH_LONG);
1124                  } else {
1125                      SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_successful,
1126                              R.color.status_positive,
1127                              Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1128                                  @Override
1129                                  public void onClick(View v) {
1130                                      mIsUndoingPublishing = true;
1131                                      unpublishNote();
1132                                  }
1133                              });
1134                  }
1135                  copyToClipboard(mNote.getPublishedUrl());
1136              } else {
1137                  if (mIsUndoingPublishing) {
1138                      SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1139                              R.color.status_negative,
1140                              Snackbar.LENGTH_LONG);
1141                  } else {
1142                      SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_successful,
1143                              R.color.status_negative,
1144                              Snackbar.LENGTH_LONG, R.string.undo, new View.OnClickListener() {
1145                                  @Override
1146                                  public void onClick(View v) {
1147                                      mIsUndoingPublishing = true;
1148                                      publishNote();
1149                                  }
1150                              });
1151                  }
1152              }
1153          } else {
1154              if (mNote.isPublished()) {
1155                  SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublish_error,
1156                          R.color.status_negative, Snackbar.LENGTH_LONG);
1157              } else {
1158                  SnackbarUtils.showSnackbar(requireActivity(), R.string.publish_error,
1159                          R.color.status_negative, Snackbar.LENGTH_LONG);
1160              }
1161          }
1162  
1163          mIsUndoingPublishing = false;
1164      }
1165  
1166      private void publishNote() {
1167  
1168          if (isAdded()) {
1169              mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.publishing,
1170                      R.color.blue, Snackbar.LENGTH_INDEFINITE);
1171          }
1172          setPublishedNote(true);
1173      }
1174  
1175      private void unpublishNote() {
1176  
1177          if (isAdded()) {
1178              mPublishingSnackbar = SnackbarUtils.showSnackbar(requireActivity(), R.string.unpublishing,
1179                      R.color.blue, Snackbar.LENGTH_INDEFINITE);
1180          }
1181          setPublishedNote(false);
1182      }
1183  
1184      private void copyToClipboard(String text) {
1185          ClipboardManager clipboard = (ClipboardManager) requireActivity()
1186                  .getSystemService(Context.CLIPBOARD_SERVICE);
1187          ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);
1188          if (clipboard != null) {
1189              clipboard.setPrimaryClip(clip);
1190          }
1191      }
1192  
1193      private void showShareSheet() {
1194          if (isAdded()) {
1195              mShareBottomSheet.show(mNote);

1196          }
1197      }
1198  
1199      private void showInfoSheet() {
1200          if (isAdded()) {
1201              mInfoBottomSheet.show(mNote);
1202          }
1203  


1204      }
1205  
1206      private void showHistorySheet() {
1207          if (isAdded()) {
1208              // Request revisions for the current note
1209              mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());
1210              saveNote();
1211  
1212              mHistoryBottomSheet.show(mNote);

1213          }
1214      }
1215  
1216      /**
1217       * Simperium listeners
1218       */
1219  
1220      @Override
1221      public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1222  
1223      }
1224  
1225      @Override
1226      public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {
1227          if (changeType == Bucket.ChangeType.MODIFY) {
1228              if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1229                  try {
1230                      final Note updatedNote = mNotesBucket.get(key);
1231                      if (getActivity() != null) {
1232                          getActivity().runOnUiThread(new Runnable() {
1233                              @Override
1234                              public void run() {
1235                                  if (mPublishTimeoutHandler != null) {
1236                                      mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1237                                  }
1238  
1239                                  updateNote(updatedNote);
1240                                  updatePublishedState(true);
1241                              }
1242                          });
1243                      }
1244                  } catch (BucketObjectMissingException e) {
1245                      e.printStackTrace();
1246                  }
1247              }
1248          }
1249      }
1250  
1251      @Override
1252      public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1253          // noop
1254      }
1255  
1256      @Override
1257      public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1258          // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1259          if (mIsLoadingNote)
1260              return;
1261  
1262          Note openNote = getNote();
1263          if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1264              return;
1265  
1266          note.setContent(mContentEditText.getPlainTextContent());
1267      }
1268  
1269      private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1270          WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1271  
1272          LoadNoteTask(NoteEditorFragment fragment) {
1273              weakFragment = new WeakReference&lt;&gt;(fragment);
1274          }
1275  
1276          @Override
1277          protected void onPreExecute() {
1278              NoteEditorFragment fragment = weakFragment.get();
1279              if (fragment != null) {
1280                  fragment.mContentEditText.removeTextChangedListener(fragment);
1281                  fragment.mIsLoadingNote = true;
1282              }
1283          }
1284  
1285          @Override
1286          protected Void doInBackground(String... args) {
1287              NoteEditorFragment fragment = weakFragment.get();
1288              if (fragment == null || fragment.getActivity() == null) {
1289                  return null;
1290              }
1291  
1292              String noteID = args[0];
1293              Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1294              Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1295  
1296              try {
1297                  fragment.mNote = notesBucket.get(noteID);
1298                  // Set the current note in NotesActivity when on a tablet
1299                  if (fragment.getActivity() instanceof NotesActivity) {
1300                      ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1301                  }
1302  
1303                  // Set markdown and preview flags for current note
1304                  if (fragment.mNote != null) {
1305                      fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1306                      fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1307                  }
1308              } catch (BucketObjectMissingException e) {
1309                  // See if the note is in the object store
1310                  Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1311                  while (notesCursor.moveToNext()) {
1312                      Note currentNote = notesCursor.getObject();
1313                      if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1314                          fragment.mNote = currentNote;
1315                          return null;
1316                      }
1317                  }
1318              }
1319  
1320              return null;
1321          }
1322  
1323          @Override
1324          protected void onPostExecute(Void nada) {
1325              final NoteEditorFragment fragment = weakFragment.get();
1326              if (fragment == null
1327                      || fragment.getActivity() == null
1328                      || fragment.getActivity().isFinishing()) {
1329                  return;
1330              }
1331  
1332              fragment.refreshContent(false);
1333              if (fragment.mMatchOffsets != null) {
<abbr title="1334                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1334                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.COðŸ”µ</abbr>
1335                  fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1336  
1337                  fragment.mShouldScrollToSearchMatch = true;
1338              }
1339  
1340              fragment.mContentEditText.addTextChangedListener(fragment);
1341  
1342              if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1343                  // Show soft keyboard
1344                  fragment.mContentEditText.requestFocus();
1345  
1346                  new Handler().postDelayed(new Runnable() {
1347                      @Override
1348                      public void run() {
1349                          if (fragment.getActivity() == null) {
1350                              return;
1351                          }
1352  
<abbr title="1353                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1353                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSysðŸ”µ</abbr>
1354                          if (inputMethodManager != null) {
1355                              inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1356                          }
1357                      }
1358                  }, 100);
1359  
1360              } else if (fragment.mNote != null) {
1361                  // If we have a valid note, hide the placeholder
1362                  fragment.setPlaceholderVisible(false);
1363              }
1364  
1365              fragment.updateMarkdownView();
1366  
1367              fragment.requireActivity().invalidateOptionsMenu();
1368  
1369              fragment.linkifyEditorContent();
1370              fragment.mIsLoadingNote = false;
1371          }
1372      }
1373  
1374      private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1375          WeakReference&lt;NoteEditorFragment&gt; weakFragment;
1376  
1377          SaveNoteTask(NoteEditorFragment fragment) {
1378              weakFragment = new WeakReference&lt;&gt;(fragment);
1379          }
1380  
1381          @Override
1382          protected Void doInBackground(Void... args) {
1383              NoteEditorFragment fragment = weakFragment.get();
1384              if (fragment != null) {
1385                  fragment.saveNote();
1386              }
1387              return null;
1388          }
1389  
1390          @Override
1391          protected void onPostExecute(Void nada) {
1392              NoteEditorFragment fragment = weakFragment.get();
1393              if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {
1394                  // Update links
1395                  fragment.linkifyEditorContent();
1396                  fragment.updateMarkdownView();
1397              }
1398          }
1399      }
1400  
1401      private void linkifyEditorContent() {
1402          if (getActivity() == null || getActivity().isFinishing()) {
1403              return;
1404          }
1405  
1406          if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1407              SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1408          }
1409      }
1410  
1411      // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1412      private void updateMarkdownView() {
1413          if (!mIsMarkdownEnabled) {
1414              return;
1415          }
1416  
1417          Activity activity = getActivity();
1418          if (activity instanceof NotesActivity) {
1419              // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1420              loadMarkdownData();
1421          } else {
1422              // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1423              if (mNoteMarkdownFragment == null) {
1424                  mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1425                          .getNoteMarkdownFragment();
1426                  ((NoteEditorActivity) requireActivity()).showTabs();
1427              }
1428              // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1429              mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1430          }
1431      }
1432  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            