<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>231</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    231
                    <a href="230.html">prev</a>
                    <a href="232.html">next</a>
                    <a href="231_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_fd1394d8a0df0583b1f2c7c6fefa993051f65c10_core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/search/service/solr/index/SolrIndexServiceImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;fd1394d8a0df0583b1f2c7c6fefa993051f65c10:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/search/service/solr/index/SolrIndexServiceImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;fd1394d8a0df0583b1f2c7c6fefa993051f65c10^1:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/search/service/solr/index/SolrIndexServiceImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;fd1394d8a0df0583b1f2c7c6fefa993051f65c10^2:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/search/service/solr/index/SolrIndexServiceImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;f40b9b4e9d4d9c82000944599b1a359d6f8adba4:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/search/service/solr/index/SolrIndexServiceImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.search.service.solr.index;
  19 
  20 import org.apache.commons.collections.CollectionUtils;
  21 import org.apache.commons.lang3.ObjectUtils;
  22 import org.apache.commons.lang3.StringUtils;
  23 import org.apache.commons.logging.Log;
  24 import org.apache.commons.logging.LogFactory;
  25 import org.apache.solr.client.solrj.SolrClient;
  26 import org.apache.solr.client.solrj.SolrServerException;
  27 import org.apache.solr.common.SolrInputDocument;
  28 import org.apache.solr.common.SolrInputField;
  29 import org.broadleafcommerce.common.exception.ExceptionHelper;
  30 import org.broadleafcommerce.common.exception.ServiceException;
  31 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  32 import org.broadleafcommerce.common.locale.domain.Locale;
  33 import org.broadleafcommerce.common.locale.service.LocaleService;
  34 import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  35 import org.broadleafcommerce.common.site.domain.Catalog;
  36 import org.broadleafcommerce.common.util.BLCCollectionUtils;
  37 import org.broadleafcommerce.common.util.StopWatch;
  38 import org.broadleafcommerce.common.util.StringUtil;
  39 import org.broadleafcommerce.common.util.TransactionUtils;
  40 import org.broadleafcommerce.common.util.TypedTransformer;
  41 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  42 import org.broadleafcommerce.core.catalog.dao.ProductDao;
  43 import org.broadleafcommerce.core.catalog.domain.Indexable;
  44 import org.broadleafcommerce.core.catalog.service.CatalogService;
  45 import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuActiveDatesService;
  46 import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuPricingService;
  47 import org.broadleafcommerce.core.catalog.service.dynamic.SkuActiveDateConsiderationContext;
  48 import org.broadleafcommerce.core.catalog.service.dynamic.SkuPricingConsiderationContext;
  49 import org.broadleafcommerce.core.search.dao.CatalogStructure;
  50 import org.broadleafcommerce.core.search.dao.FieldDao;
  51 import org.broadleafcommerce.core.search.dao.IndexFieldDao;
  52 import org.broadleafcommerce.core.search.dao.SearchFacetDao;
  53 import org.broadleafcommerce.core.search.dao.SolrIndexDao;
  54 import org.broadleafcommerce.core.search.domain.Field;
  55 import org.broadleafcommerce.core.search.domain.FieldEntity;
  56 import org.broadleafcommerce.core.search.domain.IndexField;
  57 import org.broadleafcommerce.core.search.domain.IndexFieldType;
  58 import org.broadleafcommerce.core.search.domain.solr.FieldType;
  59 import org.broadleafcommerce.core.search.service.solr.SolrConfiguration;
  60 import org.broadleafcommerce.core.search.service.solr.SolrHelperService;
  61 import org.springframework.beans.factory.InitializingBean;
  62 import org.springframework.beans.factory.annotation.Autowired;
  63 import org.springframework.beans.factory.annotation.Qualifier;
  64 import org.springframework.beans.factory.annotation.Value;
  65 import org.springframework.stereotype.Service;
  66 import org.springframework.transaction.PlatformTransactionManager;
  67 import org.springframework.transaction.TransactionDefinition;
  68 import org.springframework.transaction.TransactionStatus;
  69 
  70 import java.io.IOException;
  71 import java.lang.reflect.InvocationTargetException;
  72 import java.math.BigDecimal;
  73 import java.util.ArrayList;
  74 import java.util.Collection;
  75 import java.util.HashMap;
  76 import java.util.HashSet;
  77 import java.util.LinkedHashMap;
  78 import java.util.List;
  79 import java.util.Map;
  80 import java.util.Map.Entry;
  81 import java.util.Set;
  82 
  83 import javax.annotation.Resource;
  84 
  85 
  86 /**
  87  * Responsible for building and rebuilding the Solr index
  88  * 
  89  * @author Andre Azzolini (apazzolini)
  90  * @author Jeff Fischer
  91  */
  92 @Service(&quot;blSolrIndexService&quot;)
  93 public class SolrIndexServiceImpl implements SolrIndexService, InitializingBean {
  94 
  95     private static final Log LOG = LogFactory.getLog(SolrIndexServiceImpl.class);
  96 
  97     @Qualifier(&quot;blCatalogSolrConfiguration&quot;)
  98     @Autowired(required = false)
  99     protected SolrConfiguration solrConfiguration;
 100 
 101     @Value(&quot;${solr.index.errorOnConcurrentReIndex}&quot;)
 102     protected boolean errorOnConcurrentReIndex = false;
 103 
 104     @Value(&quot;${solr.index.product.pageSize}&quot;)
 105     protected int pageSize;
 106 
 107     @Value(&quot;${solr.index.commit}&quot;)
 108     protected boolean commit;
 109 
 110     @Value(&quot;${solr.index.softCommit}&quot;)
 111     protected boolean softCommit;
 112 
 113     @Value(&quot;${solr.index.waitSearcher}&quot;)
 114     protected boolean waitSearcher;
 115 
 116     @Value(&quot;${solr.index.waitFlush}&quot;)
 117     protected boolean waitFlush;
 118     
 119     @Value(value = &quot;${solr.catalog.useLegacySolrIndexer:true}&quot;)
 120     protected boolean useLegacySolrIndexer = true;
 121 
 122     @Resource(name = &quot;blProductDao&quot;)
 123     protected ProductDao productDao;
 124 
 125     @Resource(name = &quot;blCatalogService&quot;)
 126     protected CatalogService catalogService;
 127 
 128     @Resource(name = &quot;blFieldDao&quot;)
 129     protected FieldDao fieldDao;
 130 
 131     @Resource(name = &quot;blLocaleService&quot;)
 132     protected LocaleService localeService;
 133 
 134     @Resource(name = &quot;blSolrHelperService&quot;)
 135     protected SolrHelperService shs;
 136 
 137     @Resource(name = &quot;blSolrIndexServiceExtensionManager&quot;)
 138     protected SolrIndexServiceExtensionManager extensionManager;
 139 
 140     @Resource(name = &quot;blTransactionManager&quot;)
 141     protected PlatformTransactionManager transactionManager;
 142 
 143     @Resource(name = &quot;blSolrIndexDao&quot;)
 144     protected SolrIndexDao solrIndexDao;
 145 
 146     @Resource(name = &quot;blSandBoxHelper&quot;)
 147     protected SandBoxHelper sandBoxHelper;
 148 
 149     @Resource(name = &quot;blSearchFacetDao&quot;)
 150     protected SearchFacetDao searchFacetDao;
 151 
 152     @Resource(name = &quot;blIndexFieldDao&quot;)
 153     protected IndexFieldDao indexFieldDao;
 154     
 155     @Override
 156     public void afterPropertiesSet() throws Exception {
 157         if (!useLegacySolrIndexer) {
 158             if (useSku) {
<abbr title=" 159                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;solr.index.use.sku&#x27; was true, which is not supported.&quot;);"> 159                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was falðŸ”µ</abbr>
 160             }
 161             if (solrConfiguration != null &amp;&amp; solrConfiguration.isSiteCollections()) {
<abbr title=" 162                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;solr.index.site.collections&#x27; was true, which is not supported.&quot;);"> 162                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was falðŸ”µ</abbr>
 163             }
 164         }
 165     }
 166 
 167     @Value(value = &quot;${enable.solr.optimize:false}&quot;)
 168     private boolean optimizeEnabled;
 169 
 170 
 171     @Override
<abbr title=" 172     public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws ServiceException {"> 172     public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws SerðŸ”µ</abbr>
 173         try {
 174             CatalogStructure cache = new CatalogStructure();
 175             SolrIndexCachedOperation.setCache(cache);
 176             cacheOperation.execute();
 177         } finally {
 178             SolrIndexCachedOperation.clearCache();
 179         }
 180     }
 181 
 182     @Override
 183     public void rebuildIndex() throws ServiceException, IOException {
 184         LOG.info(&quot;Rebuilding the entire Solr index...&quot;);
 185         StopWatch s = new StopWatch();
 186 
 187         preBuildIndex();
 188         buildIndex();
 189         postBuildIndex();
 190 
 191         LOG.info(String.format(&quot;Finished building entire Solr index in %s&quot;, s.toLapString()));
 192     }
 193 
 194     @Override
 195     public void preBuildIndex() throws ServiceException {
<abbr title=" 196         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 196         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReðŸ”µ</abbr>
 197     }
 198 
 199     @Override
 200     public void buildIndex() throws IOException, ServiceException {
 201         executeSolrIndexOperation(getReindexOperation());
 202     }
 203 
 204     @Override
 205     public void postBuildIndex() throws IOException, ServiceException {
 206         if(optimizeEnabled) {
 207             // this is required to be at the very very very end after rebuilding the whole index
<abbr title=" 208             optimizeIndex(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 208             optimizeIndex(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServeðŸ”µ</abbr>
 209         }
 210         // Swap the active and the reindex cores
 211         if (!solrConfiguration.isSingleCoreMode()) {
 212             shs.swapActiveCores(solrConfiguration);
 213         }
 214     }
 215 
 216     @Override
 217     public SolrIndexOperation getReindexOperation() {
<abbr title=" 218         return new GlobalSolrFullReIndexOperation(this, solrConfiguration, shs, errorOnConcurrentReIndex) {"> 218         return new GlobalSolrFullReIndexOperation(this, solrConfiguration, shs, errorOnConcurrentReIndex)ðŸ”µ</abbr>
 219 
 220             @Override
 221             public List&lt;? extends Indexable&gt; readIndexables(int pageSize, Long lastId) {
 222                 return readAllActiveIndexables(pageSize, lastId);
 223             }
 224 
 225             @Override
 226             public Long countIndexables() {
 227                 return countIndexableItems();
 228             }
 229 
 230             @Override
 231             public void buildPage(List&lt;? extends Indexable&gt; indexables) throws ServiceException {
<abbr title=" 232                 buildIncrementalIndex(getSolrCollectionForIndexing(), indexables, getSolrServerForIndexing());"> 232                 buildIncrementalIndex(getSolrCollectionForIndexing(), indexables, getSolrServerForIndexinðŸ”µ</abbr>
 233             }
 234         };
 235     }
 236 
 237     @Override
<abbr title=" 238     public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOException {"> 238     public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOðŸ”µ</abbr>
 239         operation.obtainLock();
 240 
 241         try {
 242             LOG.info(&quot;Executing Indexing operation&quot;);
 243             StopWatch s = new StopWatch();
 244 
 245             Object[] pack = saveState();
 246             try {
 247                 final Long numItemsToIndex;
 248                 try {
 249                     operation.beforeCountIndexables();
 250 
 251                     numItemsToIndex = operation.countIndexables();
 252                 } finally {
 253                     operation.afterCountIndexables();
 254                 }
 255 
 256                 if (LOG.isDebugEnabled()) {
 257                     LOG.debug(&quot;There are at most &quot; + numItemsToIndex + &quot; items to index&quot;);
 258                 }
 259                 performCachedOperation(new SolrIndexCachedOperation.CacheOperation() {
 260 
 261                     @Override
 262                     public void execute() throws ServiceException {
 263                         int page = 1;
 264                         Long lastId = null;
 265                         Long remainingNumItemsToIndex = numItemsToIndex;
 266                         Long totalPages = getTotalPageCount(numItemsToIndex);
 267 
 268                         while (remainingNumItemsToIndex &gt; 0) {
 269                             String pageNumberMessage = buildPageNumberMessage(page, totalPages);
 270                             LOG.info(pageNumberMessage);
 271 
 272                             lastId = buildIncrementalIndex(pageSize, lastId, operation);
 273                             remainingNumItemsToIndex -= pageSize;
 274                             page++;
 275                         }
 276                     }
 277                 });
 278 
 279             } finally {
 280                 restoreState(pack);
 281             }
 282 
 283             LOG.info(String.format(&quot;Indexing operation completed in %s&quot;, s.toLapString()));
 284         } finally {
 285             operation.releaseLock();
 286         }
 287     }
 288 
 289     protected long getTotalPageCount(Long numItemsToIndex) {
 290         long numPagesToIndex = numItemsToIndex / pageSize;
 291         boolean hasRemainingItemsToIndex = numItemsToIndex % pageSize != 0;
 292 
 293         return hasRemainingItemsToIndex ? (numPagesToIndex + 1) : numPagesToIndex;
 294     }
 295 
 296     protected String buildPageNumberMessage(int page, Long totalPages) {
 297         String pageNumberMessage = String.format(&quot;Building page number %s of %s&quot;, page, totalPages);
 298 
<abbr title=" 299         Catalog currentCatalog = BroadleafRequestContext.getBroadleafRequestContext().getCurrentCatalog();"> 299         Catalog currentCatalog = BroadleafRequestContext.getBroadleafRequestContext().getCurrentCatalog()ðŸ”µ</abbr>
 300         if (currentCatalog != null) {
 301             pageNumberMessage += String.format(&quot; for catalog: %s&quot;, currentCatalog.getName());
 302         }
 303 
 304         return pageNumberMessage;
 305     }
 306 
 307     /**
 308      * @return
 309      */
 310     protected Long countIndexableItems() {
 311         return productDao.readCountAllActiveProducts();
 312     }
 313 
 314     /**
 315      * &lt;p&gt;
 316      * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 317      * 
 318      * @throws ServiceException if there was a problem removing the documents
 319      * @deprecated use {@link #deleteAllReindexCoreDocuments()} instead
 320      */
 321     @Deprecated
 322     protected void deleteAllDocuments() throws ServiceException {
 323         deleteAllReindexCoreDocuments();
 324     }
 325     
 326     /**
 327      * &lt;p&gt;
 328      * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 329      * 
 330      * @throws ServiceException if there was a problem removing the documents
 331      */
 332     protected void deleteAllReindexCoreDocuments() throws ServiceException {
<abbr title=" 333         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 333         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReðŸ”µ</abbr>
 334     }
 335 
 336     @Override
<abbr title=" 337     public void deleteAllNamespaceDocuments(String collection, SolrClient server) throws ServiceException {"> 337     public void deleteAllNamespaceDocuments(String collection, SolrClient server) throws ServiceExceptionðŸ”µ</abbr>
 338         try {
 339             String deleteQuery = StringUtil.sanitize(shs.getNamespaceFieldName()) + &quot;:(\&quot;&quot; 
 340                     + StringUtil.sanitize(solrConfiguration.getNamespace()) + &quot;\&quot;)&quot;;
 341             LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
 342             server.deleteByQuery(collection, deleteQuery);
 343 
 344             //Explicitly do a hard commit here since we just deleted the entire index
 345             server.commit(collection);
 346         } catch (Exception e) {
 347             if (ServiceException.class.isAssignableFrom(e.getClass())) {
 348                 throw (ServiceException) e;
 349             }
 350             throw new ServiceException(&quot;Could not delete documents&quot;, e);
 351         }
 352     }
 353     
 354     @Override
 355     public void deleteAllDocuments(String collection, SolrClient server) throws ServiceException {
 356         try {
 357             String deleteQuery = &quot;*:*&quot;;
 358             LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
 359             server.deleteByQuery(collection, deleteQuery);
 360             server.commit(collection);
 361         } catch (Exception e) {
 362             throw new ServiceException(&quot;Could not delete documents&quot;, e);
 363         }
 364     }
 365 
<abbr title=" 366     protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ServiceException {"> 366     protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ðŸ”µ</abbr>
 367         TransactionStatus status = TransactionUtils.createTransaction(&quot;readItemsToIndex&quot;,
 368             TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 369         if (SolrIndexCachedOperation.getCache() == null) {
 370             LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 371                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 371                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr ðŸ”µ</abbr>
 372         }
 373         Long response = null;
 374         try {
 375             List&lt;? extends Indexable&gt; indexables;
 376             try {
 377                 operation.beforeReadIndexables();
 378                 indexables = operation.readIndexables(pageSize, lastId);
 379                 if (CollectionUtils.isNotEmpty(indexables)) {
 380                     response = indexables.get(indexables.size()-1).getId();
 381                 }
 382             } finally {
 383                 operation.afterReadIndexables();
 384             }
 385 
 386             try {
 387                 operation.beforeBuildPage();
 388 
 389                 operation.buildPage(indexables);
 390             } finally {
 391                 operation.afterBuildPage();
 392             }
 393 
 394 
 395             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 396         } catch (RuntimeException e) {
 397             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 398             throw e;
 399         }
 400         return response;
 401     }
 402 
 403     @Override
<abbr title=" 404     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(String collection, List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 404     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(String collection, List&lt;? extends IndexablðŸ”µ</abbr>
 405         TransactionStatus status = TransactionUtils.createTransaction(&quot;executeIncrementalIndex&quot;,
 406                 TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 407         if (SolrIndexCachedOperation.getCache() == null) {
 408             LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 409                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 409                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr ðŸ”µ</abbr>
 410         }
 411 
 412         if (LOG.isDebugEnabled()) {
<abbr title=" 413             LOG.debug(String.format(&quot;Building incremental product index - pageSize: [%s]...&quot;, indexables.size()));"> 413             LOG.debug(String.format(&quot;Building incremental product index - pageSize: [%s]...&quot;, indexables.ðŸ”µ</abbr>
 414         }
 415 
 416         StopWatch s = new StopWatch();
 417         try {
 418             sandBoxHelper.ignoreCloneCache(true);
 419             extensionManager.getProxy().startBatchEvent(indexables);
 420             Collection&lt;SolrInputDocument&gt; documents = new ArrayList&lt;&gt;();
 421             List&lt;Locale&gt; locales = getAllLocales();
 422 
<abbr title=" 423             List&lt;Long&gt; productIds = BLCCollectionUtils.collectList(indexables, new TypedTransformer&lt;Long&gt;() {"> 423             List&lt;Long&gt; productIds = BLCCollectionUtils.collectList(indexables, new TypedTransformer&lt;Long&gt;ðŸ”µ</abbr>
 424                 @Override
 425                 public Long transform(Object input) {
 426                     return shs.getCurrentProductId((Indexable) input);
 427                 }
 428             });
 429 
<abbr title=" 430             solrIndexDao.populateProductCatalogStructure(productIds, SolrIndexCachedOperation.getCache());"> 430             solrIndexDao.populateProductCatalogStructure(productIds, SolrIndexCachedOperation.getCache())ðŸ”µ</abbr>
 431 
 432             List&lt;IndexField&gt; fields = null;
 433             FieldEntity currentFieldType = null;
 434             for (Indexable indexable : indexables) {
<abbr title=" 435                 if (fields == null || ObjectUtils.notEqual(currentFieldType, indexable.getFieldEntityType())) {"> 435                 if (fields == null || ObjectUtils.notEqual(currentFieldType, indexable.getFieldEntityTypeðŸ”µ</abbr>
 436                     fields = indexFieldDao.readFieldsByEntityType(indexable.getFieldEntityType());
 437                 }
 438 
 439                 SolrInputDocument doc = buildDocument(indexable, fields, locales);
<abbr title=" 440                 //If someone overrides the buildDocument method and determines that they don&#x27;t want a product "> 440                 //If someone overrides the buildDocument method and determines that they don&#x27;t want a proðŸ”µ</abbr>
 441                 //indexed, then they can return null. If the document is null it does not get added to 
 442                 //to the index.
 443                 if (doc != null) {
 444                     documents.add(doc);
 445                 }
 446             }
 447 
 448             extensionManager.getProxy().modifyBuiltDocuments(documents, indexables, fields, locales);
 449 
 450             logDocuments(documents);
 451 
 452             if (!CollectionUtils.isEmpty(documents) &amp;&amp; solrServer != null) {
 453                 solrServer.add(collection, documents);
 454                 commit(collection, solrServer);
 455             }
 456             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 457 
 458             if (LOG.isDebugEnabled()) {
<abbr title=" 459                 LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexables.size(), s.toLapString()));"> 459                 LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexðŸ”µ</abbr>
 460             }
 461 
 462             return documents;
 463         } catch (SolrServerException e) {
 464             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 465             throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 466         } catch (IOException e) {
 467             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 468             throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 469         } catch (RuntimeException e) {
 470             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 471             throw e;
 472         } finally {
 473             extensionManager.getProxy().endBatchEvent(indexables);
 474             sandBoxHelper.ignoreCloneCache(false);
 475         }
 476     }
 477 
 478     protected List&lt;? extends Indexable&gt; readAllActiveIndexables(int pageSize, Long lastId) {
 479         return productDao.readAllActiveProducts(pageSize, lastId);
 480     }
 481 
 482     @Override
 483     public List&lt;Locale&gt; getAllLocales() {
 484         List&lt;Locale&gt; allLocales = localeService.findAllLocales();
 485         Map&lt;String, Locale&gt; processedLocales = new HashMap&lt;&gt;();
<abbr title=" 486         // Optimize the list of locales we are looking at. If I have an &#x27;en&#x27; and &#x27;en_US&#x27; in the locale set and I&#x27;m"> 486         // Optimize the list of locales we are looking at. If I have an &#x27;en&#x27; and &#x27;en_US&#x27; in the locale seðŸ”µ</abbr>
 487         // not using the country code to index the values, then I only need to index the locale &#x27;en&#x27;
 488         for (Locale locale : allLocales) {
 489             String localeCode = locale.getLocaleCode();
 490             int underscoreLocation = localeCode.indexOf(&quot;_&quot;);
 491             if (underscoreLocation &gt; 0 &amp;&amp; Boolean.FALSE.equals(locale.getUseCountryInSearchIndex())) {
 492                 String localeCodeWithoutCountry = localeCode.substring(0, underscoreLocation);
 493                 if (!processedLocales.containsKey(localeCodeWithoutCountry)) {
 494                     processedLocales.put(localeCodeWithoutCountry, locale);
 495                 }
 496             } else {
 497                 processedLocales.put(locale.getLocaleCode(), locale);
 498             }
 499         }
 500         return new ArrayList&lt;&gt;(processedLocales.values());
 501     }
 502     
 503     @Override
<abbr title=" 504     public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 504     public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;LocalðŸ”µ</abbr>
<abbr title=" 505         final SolrInputDocument document = new SolrInputDocument(new LinkedHashMap&lt;String,SolrInputField&gt;());"> 505         final SolrInputDocument document = new SolrInputDocument(new LinkedHashMap&lt;String,SolrInputField&gt;ðŸ”µ</abbr>
 506 
 507         attachBasicDocumentFields(indexable, document);
 508 
 509         attachIndexableDocumentFields(document, indexable, fields, locales);
 510 
 511         attachAdditionalDocumentFields(indexable, document);
 512 
 513         extensionManager.getProxy().attachChildDocuments(indexable, document, fields, locales);
 514 
 515         return document;
 516     }
 517 
 518     @Override
<abbr title=" 519     public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 519     public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexðŸ”µ</abbr>
 520         for (IndexField indexField : fields) {
 521             try {
 522                 // If we find an IndexField entry for this field, then we need to store it in the index
 523                 if (indexField != null) {
 524                     List&lt;IndexFieldType&gt; searchableFieldTypes = indexField.getFieldTypes();
 525 
<abbr title=" 526                     // For each of its search field types, get the property values, and add a field to the document for each property value"> 526                     // For each of its search field types, get the property values, and add a field to thðŸ”µ</abbr>
 527                     for (IndexFieldType sft : searchableFieldTypes) {
 528                         FieldType fieldType = sft.getFieldType();
<abbr title=" 529                         Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getField(), fieldType, locales);"> 529                         Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getFðŸ”µ</abbr>
 530 
<abbr title=" 531                         ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentForIndexField(document, indexField, fieldType, propertyValues);"> 531                         ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentFoðŸ”µ</abbr>
 532 
 533                         if (ExtensionResultStatusType.NOT_HANDLED.equals(result)) {
 534                             // Build out the field for every prefix
 535                             for (Entry&lt;String, Object&gt; entry : propertyValues.entrySet()) {
 536                                 String prefix = entry.getKey();
 537                                 prefix = StringUtils.isBlank(prefix) ? prefix : prefix + &quot;_&quot;;
 538 
<abbr title=" 539                                 String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fieldType, prefix);"> 539                                 String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fiðŸ”µ</abbr>
 540                                 Object value = entry.getValue();
 541 
 542                                 if (FieldType.isMultiValued(fieldType)) {
 543                                     document.addField(solrPropertyName, value);
 544                                 } else {
 545                                     document.setField(solrPropertyName, value);
 546                                 }
 547                             }
 548                         }
 549                     }
 550                 }
 551 
 552             } catch (Exception e) {
<abbr title=" 553                 LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldName() + &quot;] for product id[&quot;"> 553                 LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldNaðŸ”µ</abbr>
 554                         + indexable.getId() + &quot;]&quot;, e);
 555                 throw ExceptionHelper.refineException(e);
 556             }
 557         }
 558     }
 559 
 560     /**
<abbr title=" 561      * Implementors can extend this and override this method to add additional fields to the Solr document."> 561      * Implementors can extend this and override this method to add additional fields to the Solr documenðŸ”µ</abbr>
 562      * 
 563      * @param sku
 564      * @param document
 565      */
 566     protected void attachAdditionalDocumentFields(Indexable indexable, SolrInputDocument document) {
 567         //Empty implementation. Placeholder for others to extend and add additional fields
 568         extensionManager.getProxy().attachAdditionalDocumentFields(indexable, document);
 569     }
 570 
 571     protected void attachBasicDocumentFields(Indexable indexable, SolrInputDocument document) {
 572         CatalogStructure cache = SolrIndexCachedOperation.getCache();
 573         if (cache == null) {
 574             String msg = &quot;SolrIndexService.performCachedOperation() must be used in conjuction with&quot;
<abbr title=" 575                 + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog documents or should&quot;"> 575                 + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog doðŸ”µ</abbr>
 576                 + &quot; be invoked from buildIncrementalIndex()&quot;;
 577             LOG.error(msg);
 578             throw new IllegalStateException(msg);
 579         }
 580 
 581         // Add the namespace and ID fields for this product
 582         document.addField(shs.getNamespaceFieldName(), solrConfiguration.getNamespace());
 583         document.addField(shs.getIdFieldName(), shs.getSolrDocumentId(document, indexable));
 584         document.addField(shs.getTypeFieldName(), shs.getDocumentType(indexable));
 585         document.addField(shs.getIndexableIdFieldName(), shs.getIndexableId(indexable));
 586 
 587         extensionManager.getProxy().attachAdditionalBasicFields(indexable, document, shs);
 588 
 589         Long cacheKey = this.shs.getCurrentProductId(indexable); // current
 590         if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 591             cacheKey = sandBoxHelper.getOriginalId(cacheKey); // parent
 592             if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 593                 cacheKey = shs.getIndexableId(indexable); // master
 594             }
 595         }
 596 
 597         // TODO: figure this out more generally; this doesn&#x27;t work for CMS content
 598         // The explicit categories are the ones defined by the product itself
 599         if (cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 600             for (Long categoryId : cache.getParentCategoriesByProduct().get(cacheKey)) {
 601                 document.addField(shs.getExplicitCategoryFieldName(), shs.getCategoryId(categoryId));
 602 
 603                 // Make sure that we&#x27;re always referencing the parent for the sort field
<abbr title=" 604                 String categorySortFieldName = shs.getCategorySortFieldName(shs.getCategoryId(categoryId));"> 604                 String categorySortFieldName = shs.getCategorySortFieldName(shs.getCategoryId(categoryId)ðŸ”µ</abbr>
<abbr title=" 605                 // The issue here was the super category id is always what is stored in the cache, while the category"> 605                 // The issue here was the super category id is always what is stored in the cache, while ðŸ”µ</abbr>
<abbr title=" 606                 // by product id is the overridden versions. Need to always look at parent version for cache stuff, which"> 606                 // by product id is the overridden versions. Need to always look at parent version for caðŸ”µ</abbr>
 607                 // is given from shs.getCategoryId
 608                 // First try the current level
 609                 String displayOrderKey = categoryId + &quot;-&quot; + cacheKey;
 610                 Long displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 611                 if (displayOrder == null) {
<abbr title=" 612                     // Didn&#x27;t find the cache at the current level, this might be an override so look upwards"> 612                     // Didn&#x27;t find the cache at the current level, this might be an override so look upwaðŸ”µ</abbr>
 613                     displayOrderKey = shs.getCategoryId(categoryId) + &quot;-&quot; + cacheKey;
 614                     displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 615                 }
 616                 
 617                 if (document.getField(categorySortFieldName) == null &amp;&amp; displayOrder != null) {
 618                     document.addField(categorySortFieldName, displayOrder);
 619                 }
 620 
 621                 // This is the entire tree of every category defined on the product
 622                 buildFullCategoryHierarchy(document, cache, categoryId, new HashSet&lt;Long&gt;());
 623             }
 624         }
 625     }
 626 
 627     /**
 628      * Walk the category hierarchy upwards, adding a field for each level to the solr document
 629      *
 630      * @param document the solr document for the product
 631      * @param cache the catalog structure cache
 632      * @param categoryId the current category id
 633      */
<abbr title=" 634     protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long categoryId, Set&lt;Long&gt; indexedParents) {"> 634     protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long caðŸ”µ</abbr>
 635         Long catIdToAdd = shs.getCategoryId(categoryId); 
 636 
 637         Collection&lt;Object&gt; existingValues = document.getFieldValues(shs.getCategoryFieldName());
 638         if (existingValues == null || !existingValues.contains(catIdToAdd)) {
 639             document.addField(shs.getCategoryFieldName(), catIdToAdd);
 640         }
 641 
 642         Set&lt;Long&gt; parents = cache.getParentCategoriesByCategory().get(categoryId);
 643         for (Long parent : parents) {
 644             if (!indexedParents.contains(parent)) {
 645                 indexedParents.add(parent);
 646                 buildFullCategoryHierarchy(document, cache, parent, indexedParents);
 647             }
 648         }
 649     }
 650 
 651     /**
<abbr title=" 652      * Returns a map of prefix to value for the requested attributes. For example, if the requested field corresponds to"> 652      * Returns a map of prefix to value for the requested attributes. For example, if the requested fieldðŸ”µ</abbr>
<abbr title=" 653      * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting map could be"> 653      * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting ðŸ”µ</abbr>
 654      * 
 655      * { &quot;en_US&quot; : &quot;A description&quot;,
 656      *   &quot;es_ES&quot; : &quot;Una descripcion&quot; }
 657      * 
 658      * @param product
 659      * @param sku
 660      * @param field
 661      * @param fieldType
 662      * @param locales
 663      * @return the value of the property
 664      * @throws IllegalAccessException
 665      * @throws InvocationTargetException
 666      * @throws NoSuchMethodException
 667      */
<abbr title=" 668     protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldType, List&lt;Locale&gt; locales)"> 668     protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldTyðŸ”µ</abbr>
 669             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 670 
 671         String propertyName = field.getPropertyName();
 672         Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
 673 
 674         ExtensionResultStatusType extensionResult = ExtensionResultStatusType.NOT_HANDLED;
 675         if (extensionManager != null) {
<abbr title=" 676             extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldType, values, propertyName, locales);"> 676             extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldTypeðŸ”µ</abbr>
 677         }
 678         
 679         if (ExtensionResultStatusType.NOT_HANDLED.equals(extensionResult)) {
 680             Object propertyValue = shs.getPropertyValue(indexedItem, field);
 681             if (propertyValue != null) {
 682                 values.put(&quot;&quot;, propertyValue);
 683             }
 684         }
 685 
 686         return values;
 687     }
 688 
 689     /**
<abbr title=" 690      * Converts a propertyName to one that is able to reference inside a map. For example, consider the property"> 690      * Converts a propertyName to one that is able to reference inside a map. For example, consider the pðŸ”µ</abbr>
<abbr title=" 691      * in Product that references a List&lt;ProductAttribute&gt;, &quot;productAttributes&quot;. Also consider the utility method"> 691      * in Product that references a List&lt;ProductAttribute&gt;, &quot;productAttributes&quot;. Also consider the utilitðŸ”µ</abbr>
<abbr title=" 692      * in Product called &quot;mappedProductAttributes&quot;, which returns a map of the ProductAttributes keyed by the name"> 692      * in Product called &quot;mappedProductAttributes&quot;, which returns a map of the ProductAttributes keyed byðŸ”µ</abbr>
<abbr title=" 693      * property in the ProductAttribute. Given the parameters &quot;productAttributes.heatRange&quot;, &quot;productAttributes&quot;, "> 693      * property in the ProductAttribute. Given the parameters &quot;productAttributes.heatRange&quot;, &quot;productAttrðŸ”µ</abbr>
<abbr title=" 694      * &quot;mappedProductAttributes&quot; (which would represent a property called &quot;productAttributes.heatRange&quot; that "> 694      * &quot;mappedProductAttributes&quot; (which would represent a property called &quot;productAttributes.heatRange&quot; tðŸ”µ</abbr>
<abbr title=" 695      * references a specific ProductAttribute inside of a product whose &quot;name&quot; property is equal to &quot;heatRange&quot;, "> 695      * references a specific ProductAttribute inside of a product whose &quot;name&quot; property is equal to &quot;heatðŸ”µ</abbr>
<abbr title=" 696      * this method will convert this property to mappedProductAttributes(heatRange).value, which is then usable "> 696      * this method will convert this property to mappedProductAttributes(heatRange).value, which is then ðŸ”µ</abbr>
 697      * by the standard beanutils PropertyUtils class to get the value.
 698      * 
 699      * @param propertyName
 700      * @param listPropertyName
 701      * @param mapPropertyName
 702      * @return the converted property name
 703      * 
 704      * @deprecated see SolrHelperService.getPropertyValue()
 705      */
 706     @Deprecated
<abbr title=" 707     protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropertyName) {"> 707     protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropðŸ”µ</abbr>
 708         String[] splitName = StringUtils.split(propertyName, &quot;\\.&quot;);
 709         StringBuilder convertedProperty = new StringBuilder();
 710         for (int i = 0; i &lt; splitName.length; i++) {
 711             if (convertedProperty.length() &gt; 0) {
 712                 convertedProperty.append(&quot;.&quot;);
 713             }
 714 
 715             if (splitName[i].equals(listPropertyName)) {
 716                 convertedProperty.append(mapPropertyName).append(&quot;(&quot;);
 717                 convertedProperty.append(splitName[i + 1]).append(&quot;).value&quot;);
 718                 i++;
 719             } else {
 720                 convertedProperty.append(splitName[i]);
 721             }
 722         }
 723         return convertedProperty.toString();
 724     }
 725 
 726     @Override
 727     public Object[] saveState() {
 728          return new Object[] {
 729              BroadleafRequestContext.getBroadleafRequestContext(),
 730              SkuPricingConsiderationContext.getSkuPricingConsiderationContext(),
 731              SkuPricingConsiderationContext.getSkuPricingService(),
 732              SkuActiveDateConsiderationContext.getSkuActiveDatesService()
 733          };
 734      }
 735          
 736     @Override
 737     @SuppressWarnings(&quot;rawtypes&quot;)
 738     public void restoreState(Object[] pack) {
 739          BroadleafRequestContext.setBroadleafRequestContext((BroadleafRequestContext) pack[0]);
 740          SkuPricingConsiderationContext.setSkuPricingConsiderationContext((HashMap) pack[1]);
 741          SkuPricingConsiderationContext.setSkuPricingService((DynamicSkuPricingService) pack[2]);
<abbr title=" 742          SkuActiveDateConsiderationContext.setSkuActiveDatesService((DynamicSkuActiveDatesService) pack[3]);"> 742          SkuActiveDateConsiderationContext.setSkuActiveDatesService((DynamicSkuActiveDatesService) pack[3ðŸ”µ</abbr>
 743      }
 744      
 745     @Override
<abbr title=" 746     public void optimizeIndex(String collection, SolrClient server) throws ServiceException, IOException {"> 746     public void optimizeIndex(String collection, SolrClient server) throws ServiceException, IOException ðŸ”µ</abbr>
 747         shs.optimizeIndex(collection, server);
 748     }
 749 
 750     @Override
 751     public void commit(String collection, SolrClient server) throws ServiceException, IOException {
 752         if (this.commit) {
 753             commit(collection, server, this.softCommit, this.waitSearcher, this.waitFlush);
 754         } else if (LOG.isDebugEnabled()) {
<abbr title=" 755             LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoCommit is configured.&quot;);"> 755             LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoComðŸ”µ</abbr>
 756         }
 757     }
 758 
 759     @Override
<abbr title=" 760     public void commit(String collection, SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 760     public void commit(String collection, SolrClient server, boolean softCommit, boolean waitSearcher, boðŸ”µ</abbr>
 761         try {
 762             if (!this.commit) {
<abbr title=" 763                 LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is being forced via the API.&quot;);"> 763                 LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is beingðŸ”µ</abbr>
 764             }
 765 
 766             if (LOG.isDebugEnabled()) {
 767                 LOG.debug(&quot;Committing changes to Solr index: softCommit: &quot; + softCommit
 768                         + &quot;, waitSearcher: &quot; + waitSearcher + &quot;, waitFlush: &quot; + waitFlush);
 769             }
 770 
 771             server.commit(collection, waitFlush, waitSearcher, softCommit);
 772         } catch (SolrServerException e) {
 773             throw new ServiceException(&quot;Could not commit changes to Solr index&quot;, e);
 774         }
 775     }
 776 
 777     @Override
 778     public void logDocuments(Collection&lt;SolrInputDocument&gt; documents) {
 779         if (LOG.isTraceEnabled()) {
 780             for (SolrInputDocument document : documents) {
 781                 LOG.trace(document);
 782             }
 783         }
 784     }
 785 
 786     /**
 787      *  We multiply the BigDecimal by 1,000,000 to maintain any possible decimals in use the
 788      *  displayOrder value.
 789      *
 790      * @param cache
 791      * @param displayOrderKey
 792      * @return
 793      */
 794     protected Long convertDisplayOrderToLong(CatalogStructure cache, String displayOrderKey) {
 795         BigDecimal displayOrder = cache.getDisplayOrdersByCategoryProduct().get(displayOrderKey);
 796 
 797         if (displayOrder == null) {
 798             return null;
 799         }
 800 
 801         return displayOrder.multiply(BigDecimal.valueOf(1000000)).longValue();
 802     }
 803 
 804     @Override
 805     public void deleteByQuery(String deleteQuery) throws SolrServerException, IOException {
 806         String productFilter = shs.getTypeFieldName() + &quot;:&quot; + shs.getPrimaryDocumentType();
 807 
<abbr title=" 808         // transform the deleteQuery to include the productFilter, this is necessary to ensure that we don&#x27;t delete non-product documents accidentally"> 808         // transform the deleteQuery to include the productFilter, this is necessary to ensure that we doðŸ”µ</abbr>
 809         deleteQuery = productFilter + &quot; AND (&quot; + deleteQuery + &quot;)&quot;;
 810 
 811         String childDeleteQuery = &quot;{!child of=&quot; + productFilter + &quot;} &quot; + deleteQuery;
<abbr title=" 812         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), childDeleteQuery);"> 812         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), childDeleðŸ”µ</abbr>
<abbr title=" 813         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), deleteQuery);"> 813         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), deleteQueðŸ”µ</abbr>
 814 
 815         logDeleteQuery(childDeleteQuery);
 816         logDeleteQuery(deleteQuery);
 817     }
 818 
 819     @Override
<abbr title=" 820     public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerException {"> 820     public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerExcepðŸ”µ</abbr>
 821         solrConfiguration.getServer().add(solrConfiguration.getQueryCollectionName(), documents);
 822         logDocuments(documents);
 823     }
 824 
 825     @Override
 826     public void logDeleteQuery(String deleteQuery) {
 827         if (LOG.isDebugEnabled()) {
 828             LOG.debug(&quot;Delete query: &quot; + deleteQuery);
 829         }
 830     }
 831 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 832 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 833     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 834     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 834     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 835         return buildIncrementalIndex(null, indexables, solrServer);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 836     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 837 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 838     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 839     public void optimizeIndex(SolrClient server) throws ServiceException, IOException {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 840         optimizeIndex(null, server);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 841     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 842 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 843     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 844     public void commit(SolrClient server) throws ServiceException, IOException {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 845         commit(null, server);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 846     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 847 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 848     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 849     public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 849     public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) thðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 850         commit(null, server, softCommit, waitSearcher, waitFlush);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 851     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 852 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 853     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 854     public void deleteAllNamespaceDocuments(SolrClient server) throws ServiceException {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 855         deleteAllNamespaceDocuments(null, server);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 856     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 857 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 858     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 859     public void deleteAllDocuments(SolrClient server) throws ServiceException {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 860         deleteAllDocuments(null, server);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 861     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 862 </span>
 863 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 864      * @return</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 865      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 866     protected Long convertDisplayOrderToLong(CatalogStructure cache, String displayOrderKey) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 867         BigDecimal displayOrder = cache.getDisplayOrdersByCategoryProduct().get(displayOrderKey);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 868 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 869         if (displayOrder == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 870             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 871         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 872 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 873         return displayOrder.multiply(BigDecimal.valueOf(1000000)).longValue();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 874     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 875 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 876     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 877     public void deleteByQuery(String deleteQuery) throws SolrServerException, IOException {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 878         String productFilter = shs.getTypeFieldName() + &quot;:&quot; + shs.getPrimaryDocumentType();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 879 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 880         // transform the deleteQuery to include the productFilter, this is necessary to ensure that we don&#x27;t delete non-product documents accidentally"> 880         // transform the deleteQuery to include the productFilter, this is necessary to ensure that we doðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 881         deleteQuery = productFilter + &quot; AND (&quot; + deleteQuery + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 882 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 883         String childDeleteQuery = &quot;{!child of=&quot; + productFilter + &quot;} &quot; + deleteQuery;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 884         solrConfiguration.getServer().deleteByQuery(childDeleteQuery);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 885         solrConfiguration.getServer().deleteByQuery(deleteQuery);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 886 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 887         logDeleteQuery(childDeleteQuery);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 888         logDeleteQuery(deleteQuery);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 889     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 890 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 891     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 892     public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerException {"> 892     public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerExcepðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 893         solrConfiguration.getServer().add(documents);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 894         logDocuments(documents);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 895     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 896 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 897     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 898     public void logDeleteQuery(String deleteQuery) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 899         if (LOG.isDebugEnabled()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 900             LOG.debug(&quot;Delete query: &quot; + deleteQuery);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 901         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 902     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 903 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 904 }</span>
 905 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 906     </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 907     @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 908     public boolean useLegacyIndexer() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 909         return useLegacySolrIndexer;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 910     }</span>
 911 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 912 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.search.service.solr.index;
  19 
  20 import org.apache.commons.collections.CollectionUtils;
  21 import org.apache.commons.lang3.ObjectUtils;
  22 import org.apache.commons.lang3.StringUtils;
  23 import org.apache.commons.logging.Log;
  24 import org.apache.commons.logging.LogFactory;
  25 import org.apache.solr.client.solrj.SolrClient;
  26 import org.apache.solr.client.solrj.SolrServerException;
  27 import org.apache.solr.common.SolrInputDocument;
  28 import org.apache.solr.common.SolrInputField;
  29 import org.broadleafcommerce.common.exception.ExceptionHelper;
  30 import org.broadleafcommerce.common.exception.ServiceException;
  31 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  32 import org.broadleafcommerce.common.locale.domain.Locale;
  33 import org.broadleafcommerce.common.locale.service.LocaleService;
  34 import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  35 import org.broadleafcommerce.common.site.domain.Catalog;
  36 import org.broadleafcommerce.common.util.BLCCollectionUtils;
  37 import org.broadleafcommerce.common.util.StopWatch;
  38 import org.broadleafcommerce.common.util.StringUtil;
  39 import org.broadleafcommerce.common.util.TransactionUtils;
  40 import org.broadleafcommerce.common.util.TypedTransformer;
  41 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  42 import org.broadleafcommerce.core.catalog.dao.ProductDao;
  43 import org.broadleafcommerce.core.catalog.domain.Indexable;
  44 import org.broadleafcommerce.core.catalog.service.CatalogService;
  45 import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuActiveDatesService;
  46 import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuPricingService;
  47 import org.broadleafcommerce.core.catalog.service.dynamic.SkuActiveDateConsiderationContext;
  48 import org.broadleafcommerce.core.catalog.service.dynamic.SkuPricingConsiderationContext;
  49 import org.broadleafcommerce.core.search.dao.CatalogStructure;
  50 import org.broadleafcommerce.core.search.dao.FieldDao;
  51 import org.broadleafcommerce.core.search.dao.IndexFieldDao;
  52 import org.broadleafcommerce.core.search.dao.SearchFacetDao;
  53 import org.broadleafcommerce.core.search.dao.SolrIndexDao;
  54 import org.broadleafcommerce.core.search.domain.Field;
  55 import org.broadleafcommerce.core.search.domain.FieldEntity;
  56 import org.broadleafcommerce.core.search.domain.IndexField;
  57 import org.broadleafcommerce.core.search.domain.IndexFieldType;
  58 import org.broadleafcommerce.core.search.domain.solr.FieldType;
  59 import org.broadleafcommerce.core.search.service.solr.SolrConfiguration;
  60 import org.broadleafcommerce.core.search.service.solr.SolrHelperService;
  61 import org.springframework.beans.factory.InitializingBean;
  62 import org.springframework.beans.factory.annotation.Autowired;
  63 import org.springframework.beans.factory.annotation.Qualifier;
  64 import org.springframework.beans.factory.annotation.Value;
  65 import org.springframework.stereotype.Service;
  66 import org.springframework.transaction.PlatformTransactionManager;
  67 import org.springframework.transaction.TransactionDefinition;
  68 import org.springframework.transaction.TransactionStatus;
  69 
  70 import java.io.IOException;
  71 import java.lang.reflect.InvocationTargetException;
  72 import java.math.BigDecimal;
  73 import java.util.ArrayList;
  74 import java.util.Collection;
  75 import java.util.HashMap;
  76 import java.util.HashSet;
  77 import java.util.LinkedHashMap;
  78 import java.util.List;
  79 import java.util.Map;
  80 import java.util.Map.Entry;
  81 import java.util.Set;
  82 
  83 import javax.annotation.Resource;
  84 
  85 
  86 /**
  87  * Responsible for building and rebuilding the Solr index
  88  *
  89  * @author Andre Azzolini (apazzolini)
  90  * @author Jeff Fischer
  91  */
  92 @Service(&quot;blSolrIndexService&quot;)
  93 public class SolrIndexServiceImpl implements SolrIndexService, InitializingBean {
  94 
  95     private static final Log LOG = LogFactory.getLog(SolrIndexServiceImpl.class);
  96 
  97     @Qualifier(&quot;blCatalogSolrConfiguration&quot;)
  98     @Autowired(required = false)
  99     protected SolrConfiguration solrConfiguration;
 100 
 101     @Value(&quot;${solr.index.errorOnConcurrentReIndex}&quot;)
 102     protected boolean errorOnConcurrentReIndex = false;
 103 
 104     @Value(&quot;${solr.index.product.pageSize}&quot;)
 105     protected int pageSize;
 106 
 107     @Value(&quot;${solr.index.commit}&quot;)
 108     protected boolean commit;
 109 
 110     @Value(&quot;${solr.index.softCommit}&quot;)
 111     protected boolean softCommit;
 112 
 113     @Value(&quot;${solr.index.waitSearcher}&quot;)
 114     protected boolean waitSearcher;
 115 
 116     @Value(&quot;${solr.index.waitFlush}&quot;)
 117     protected boolean waitFlush;
 118 
 119     @Value(value = &quot;${solr.catalog.useLegacySolrIndexer:true}&quot;)
 120     protected boolean useLegacySolrIndexer = true;
 121 
 122     @Resource(name = &quot;blProductDao&quot;)
 123     protected ProductDao productDao;
 124 
 125     @Resource(name = &quot;blCatalogService&quot;)
 126     protected CatalogService catalogService;
 127 
 128     @Resource(name = &quot;blFieldDao&quot;)
 129     protected FieldDao fieldDao;
 130 
 131     @Resource(name = &quot;blLocaleService&quot;)
 132     protected LocaleService localeService;
 133 
 134     @Resource(name = &quot;blSolrHelperService&quot;)
 135     protected SolrHelperService shs;
 136 
 137     @Resource(name = &quot;blSolrIndexServiceExtensionManager&quot;)
 138     protected SolrIndexServiceExtensionManager extensionManager;
 139 
 140     @Resource(name = &quot;blTransactionManager&quot;)
 141     protected PlatformTransactionManager transactionManager;
 142 
 143     @Resource(name = &quot;blSolrIndexDao&quot;)
 144     protected SolrIndexDao solrIndexDao;
 145 
 146     @Resource(name = &quot;blSandBoxHelper&quot;)
 147     protected SandBoxHelper sandBoxHelper;
 148 
 149     @Resource(name = &quot;blSearchFacetDao&quot;)
 150     protected SearchFacetDao searchFacetDao;
 151 
 152     @Resource(name = &quot;blIndexFieldDao&quot;)
 153     protected IndexFieldDao indexFieldDao;
 154 
 155     @Value(value = &quot;${enable.solr.optimize:false}&quot;)
 156     private boolean optimizeEnabled;
 157 
 158     @Override
 159     public void afterPropertiesSet() throws Exception {
 160         if (!useLegacySolrIndexer) {
 161             if (useSku) {
<abbr title=" 162                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;solr.index.use.sku&#x27; was true, which is not supported.&quot;);"> 162                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was falðŸ”µ</abbr>
 163             }
 164             if (solrConfiguration != null &amp;&amp; solrConfiguration.isSiteCollections()) {
<abbr title=" 165                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;solr.index.site.collections&#x27; was true, which is not supported.&quot;);"> 165                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was falðŸ”µ</abbr>
 166             }
 167         }
 168     }
 169 
 170 
 171     @Override
<abbr title=" 172     public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws ServiceException {"> 172     public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws SerðŸ”µ</abbr>
 173         try {
 174             CatalogStructure cache = new CatalogStructure();
 175             SolrIndexCachedOperation.setCache(cache);
 176             cacheOperation.execute();
 177         } finally {
 178             SolrIndexCachedOperation.clearCache();
 179         }
 180     }
 181 
 182     @Override
 183     public void rebuildIndex() throws ServiceException, IOException {
 184         LOG.info(&quot;Rebuilding the entire Solr index...&quot;);
 185         StopWatch s = new StopWatch();
 186 
 187         preBuildIndex();
 188         buildIndex();
 189         postBuildIndex();
 190 
 191         LOG.info(String.format(&quot;Finished building entire Solr index in %s&quot;, s.toLapString()));
 192     }
 193 
 194     @Override
 195     public void preBuildIndex() throws ServiceException {
<abbr title=" 196         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 196         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReðŸ”µ</abbr>
 197     }
 198 
 199     @Override
 200     public void buildIndex() throws IOException, ServiceException {
 201         executeSolrIndexOperation(getReindexOperation());
 202     }
 203 
 204     @Override
 205     public void postBuildIndex() throws IOException, ServiceException {
 206         if(optimizeEnabled) {
 207         // this is required to be at the very very very end after rebuilding the whole index
<abbr title=" 208             optimizeIndex(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 208             optimizeIndex(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServeðŸ”µ</abbr>
 209         }
 210         // Swap the active and the reindex cores
 211         if (!solrConfiguration.isSingleCoreMode()) {
 212             shs.swapActiveCores(solrConfiguration);
 213         }
 214     }
 215 
 216     @Override
 217     public SolrIndexOperation getReindexOperation() {
<abbr title=" 218         return new GlobalSolrFullReIndexOperation(this, solrConfiguration, shs, errorOnConcurrentReIndex) {"> 218         return new GlobalSolrFullReIndexOperation(this, solrConfiguration, shs, errorOnConcurrentReIndex)ðŸ”µ</abbr>
 219 
 220             @Override
 221             public List&lt;? extends Indexable&gt; readIndexables(int pageSize, Long lastId) {
 222                 return readAllActiveIndexables(pageSize, lastId);
 223             }
 224 
 225             @Override
 226             public Long countIndexables() {
 227                 return countIndexableItems();
 228             }
 229 
 230             @Override
 231             public void buildPage(List&lt;? extends Indexable&gt; indexables) throws ServiceException {
<abbr title=" 232                 buildIncrementalIndex(getSolrCollectionForIndexing(), indexables, getSolrServerForIndexing());"> 232                 buildIncrementalIndex(getSolrCollectionForIndexing(), indexables, getSolrServerForIndexinðŸ”µ</abbr>
 233             }
 234         };
 235     }
 236 
 237     @Override
<abbr title=" 238     public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOException {"> 238     public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOðŸ”µ</abbr>
 239         operation.obtainLock();
 240 
 241         try {
 242             LOG.info(&quot;Executing Indexing operation&quot;);
 243             StopWatch s = new StopWatch();
 244 
 245             Object[] pack = saveState();
 246             try {
 247                 final Long numItemsToIndex;
 248                 try {
 249                     operation.beforeCountIndexables();
 250 
 251                     numItemsToIndex = operation.countIndexables();
 252                 } finally {
 253                     operation.afterCountIndexables();
 254                 }
 255 
 256                 if (LOG.isDebugEnabled()) {
 257                     LOG.debug(&quot;There are at most &quot; + numItemsToIndex + &quot; items to index&quot;);
 258                 }
 259                 performCachedOperation(new SolrIndexCachedOperation.CacheOperation() {
 260 
 261                     @Override
 262                     public void execute() throws ServiceException {
 263                         int page = 1;
 264                         Long lastId = null;
 265                         Long remainingNumItemsToIndex = numItemsToIndex;
 266                         Long totalPages = getTotalPageCount(numItemsToIndex);
 267 
 268                         while (remainingNumItemsToIndex &gt; 0) {
 269                             String pageNumberMessage = buildPageNumberMessage(page, totalPages);
 270                             LOG.info(pageNumberMessage);
 271 
 272                             lastId = buildIncrementalIndex(pageSize, lastId, operation);
 273                             remainingNumItemsToIndex -= pageSize;
 274                             page++;
 275                         }
 276                     }
 277                 });
 278 
 279             } finally {
 280                 restoreState(pack);
 281             }
 282 
 283             LOG.info(String.format(&quot;Indexing operation completed in %s&quot;, s.toLapString()));
 284         } finally {
 285             operation.releaseLock();
 286         }
 287     }
 288 
 289     protected long getTotalPageCount(Long numItemsToIndex) {
 290         long numPagesToIndex = numItemsToIndex / pageSize;
 291         boolean hasRemainingItemsToIndex = numItemsToIndex % pageSize != 0;
 292 
 293         return hasRemainingItemsToIndex ? (numPagesToIndex + 1) : numPagesToIndex;
 294     }
 295 
 296     protected String buildPageNumberMessage(int page, Long totalPages) {
 297         String pageNumberMessage = String.format(&quot;Building page number %s of %s&quot;, page, totalPages);
 298 
<abbr title=" 299         Catalog currentCatalog = BroadleafRequestContext.getBroadleafRequestContext().getCurrentCatalog();"> 299         Catalog currentCatalog = BroadleafRequestContext.getBroadleafRequestContext().getCurrentCatalog()ðŸ”µ</abbr>
 300         if (currentCatalog != null) {
 301             pageNumberMessage += String.format(&quot; for catalog: %s&quot;, currentCatalog.getName());
 302         }
 303 
 304         return pageNumberMessage;
 305     }
 306 
 307     /**
 308      * @return
 309      */
 310     protected Long countIndexableItems() {
 311             return productDao.readCountAllActiveProducts();
 312         }
 313 
 314     /**
 315      * &lt;p&gt;
 316      * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 317      *
 318      * @throws ServiceException if there was a problem removing the documents
 319      * @deprecated use {@link #deleteAllReindexCoreDocuments()} instead
 320      */
 321     @Deprecated
 322     protected void deleteAllDocuments() throws ServiceException {
 323         deleteAllReindexCoreDocuments();
 324     }
 325 
 326     /**
 327      * &lt;p&gt;
 328      * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 329      *
 330      * @throws ServiceException if there was a problem removing the documents
 331      */
 332     protected void deleteAllReindexCoreDocuments() throws ServiceException {
<abbr title=" 333         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 333         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReðŸ”µ</abbr>
 334     }
 335 
 336     @Override
<abbr title=" 337     public void deleteAllNamespaceDocuments(String collection, SolrClient server) throws ServiceException {"> 337     public void deleteAllNamespaceDocuments(String collection, SolrClient server) throws ServiceExceptionðŸ”µ</abbr>
 338         try {
 339             String deleteQuery = StringUtil.sanitize(shs.getNamespaceFieldName()) + &quot;:(\&quot;&quot;
 340                     + StringUtil.sanitize(solrConfiguration.getNamespace()) + &quot;\&quot;)&quot;;
 341             LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
 342             server.deleteByQuery(collection, deleteQuery);
 343 
 344             //Explicitly do a hard commit here since we just deleted the entire index
 345             server.commit(collection);
 346         } catch (Exception e) {
 347             if (ServiceException.class.isAssignableFrom(e.getClass())) {
 348                 throw (ServiceException) e;
 349             }
 350             throw new ServiceException(&quot;Could not delete documents&quot;, e);
 351         }
 352     }
 353 
 354     @Override
 355     public void deleteAllDocuments(String collection, SolrClient server) throws ServiceException {
 356         try {
 357             String deleteQuery = &quot;*:*&quot;;
 358             LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
 359             server.deleteByQuery(collection, deleteQuery);
 360             server.commit(collection);
 361         } catch (Exception e) {
 362             throw new ServiceException(&quot;Could not delete documents&quot;, e);
 363         }
 364     }
 365 
 366     @Override
 367     public void deleteAllNamespaceDocuments(SolrClient server) throws ServiceException {
 368         deleteAllNamespaceDocuments(null, server);
 369     }
 370 
 371     @Override
 372     public void deleteAllDocuments(SolrClient server) throws ServiceException {
 373         deleteAllDocuments(null, server);
 374     }
 375 
<abbr title=" 376     protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ServiceException {"> 376     protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ðŸ”µ</abbr>
 377         TransactionStatus status = TransactionUtils.createTransaction(&quot;readItemsToIndex&quot;,
 378             TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 379         if (SolrIndexCachedOperation.getCache() == null) {
 380             LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 381                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 381                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr ðŸ”µ</abbr>
 382         }
 383         Long response = null;
 384         try {
 385             List&lt;? extends Indexable&gt; indexables;
 386             try {
 387                 operation.beforeReadIndexables();
 388                 indexables = operation.readIndexables(pageSize, lastId);
 389                 if (CollectionUtils.isNotEmpty(indexables)) {
 390                     response = indexables.get(indexables.size()-1).getId();
 391                 }
 392             } finally {
 393                 operation.afterReadIndexables();
 394             }
 395 
 396             try {
 397                 operation.beforeBuildPage();
 398 
 399                 operation.buildPage(indexables);
 400             } finally {
 401                 operation.afterBuildPage();
 402             }
 403 
 404 
 405             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 406         } catch (RuntimeException e) {
 407             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 408             throw e;
 409         }
 410         return response;
 411     }
 412 
 413     @Override
<abbr title=" 414     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(String collection, List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 414     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(String collection, List&lt;? extends IndexablðŸ”µ</abbr>
 415         TransactionStatus status = TransactionUtils.createTransaction(&quot;executeIncrementalIndex&quot;,
 416                 TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 417         if (SolrIndexCachedOperation.getCache() == null) {
 418             LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 419                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 419                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr ðŸ”µ</abbr>
 420         }
 421 
 422         if (LOG.isDebugEnabled()) {
<abbr title=" 423             LOG.debug(String.format(&quot;Building incremental product index - pageSize: [%s]...&quot;, indexables.size()));"> 423             LOG.debug(String.format(&quot;Building incremental product index - pageSize: [%s]...&quot;, indexables.ðŸ”µ</abbr>
 424         }
 425 
 426         StopWatch s = new StopWatch();
 427         try {
 428             sandBoxHelper.ignoreCloneCache(true);
 429             extensionManager.getProxy().startBatchEvent(indexables);
 430             Collection&lt;SolrInputDocument&gt; documents = new ArrayList&lt;&gt;();
 431             List&lt;Locale&gt; locales = getAllLocales();
 432 
<abbr title=" 433             List&lt;Long&gt; productIds = BLCCollectionUtils.collectList(indexables, new TypedTransformer&lt;Long&gt;() {"> 433             List&lt;Long&gt; productIds = BLCCollectionUtils.collectList(indexables, new TypedTransformer&lt;Long&gt;ðŸ”µ</abbr>
 434                 @Override
 435                 public Long transform(Object input) {
 436                     return shs.getCurrentProductId((Indexable) input);
 437                 }
 438             });
 439 
<abbr title=" 440             solrIndexDao.populateProductCatalogStructure(productIds, SolrIndexCachedOperation.getCache());"> 440             solrIndexDao.populateProductCatalogStructure(productIds, SolrIndexCachedOperation.getCache())ðŸ”µ</abbr>
 441 
 442             List&lt;IndexField&gt; fields = null;
 443             FieldEntity currentFieldType = null;
 444             for (Indexable indexable : indexables) {
<abbr title=" 445                 if (fields == null || ObjectUtils.notEqual(currentFieldType, indexable.getFieldEntityType())) {"> 445                 if (fields == null || ObjectUtils.notEqual(currentFieldType, indexable.getFieldEntityTypeðŸ”µ</abbr>
 446                     fields = indexFieldDao.readFieldsByEntityType(indexable.getFieldEntityType());
 447                 }
 448 
 449                 SolrInputDocument doc = buildDocument(indexable, fields, locales);
<abbr title=" 450                 //If someone overrides the buildDocument method and determines that they don&#x27;t want a product"> 450                 //If someone overrides the buildDocument method and determines that they don&#x27;t want a proðŸ”µ</abbr>
 451                 //indexed, then they can return null. If the document is null it does not get added to
 452                 //to the index.
 453                 if (doc != null) {
 454                     documents.add(doc);
 455                 }
 456             }
 457 
 458             extensionManager.getProxy().modifyBuiltDocuments(documents, indexables, fields, locales);
 459 
 460             logDocuments(documents);
 461 
 462             if (!CollectionUtils.isEmpty(documents) &amp;&amp; solrServer != null) {
 463                 solrServer.add(collection, documents);
 464                 commit(collection, solrServer);
 465             }
 466             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 467 
 468             if (LOG.isDebugEnabled()) {
<abbr title=" 469                 LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexables.size(), s.toLapString()));"> 469                 LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexðŸ”µ</abbr>
 470             }
 471 
 472             return documents;
 473         } catch (SolrServerException e) {
 474             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 475             throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 476         } catch (IOException e) {
 477             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 478             throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 479         } catch (RuntimeException e) {
 480             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 481             throw e;
 482         } finally {
 483             extensionManager.getProxy().endBatchEvent(indexables);
 484             sandBoxHelper.ignoreCloneCache(false);
 485         }
 486     }
 487 
 488     @Override
<abbr title=" 489     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 489     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrðŸ”µ</abbr>
 490         return buildIncrementalIndex(null, indexables, solrServer);
 491     }
 492 
 493     protected List&lt;? extends Indexable&gt; readAllActiveIndexables(int pageSize, Long lastId) {
 494             return productDao.readAllActiveProducts(pageSize, lastId);
 495         }
 496 
 497     @Override
 498     public List&lt;Locale&gt; getAllLocales() {
 499         List&lt;Locale&gt; allLocales = localeService.findAllLocales();
 500         Map&lt;String, Locale&gt; processedLocales = new HashMap&lt;&gt;();
<abbr title=" 501         // Optimize the list of locales we are looking at. If I have an &#x27;en&#x27; and &#x27;en_US&#x27; in the locale set and I&#x27;m"> 501         // Optimize the list of locales we are looking at. If I have an &#x27;en&#x27; and &#x27;en_US&#x27; in the locale seðŸ”µ</abbr>
 502         // not using the country code to index the values, then I only need to index the locale &#x27;en&#x27;
 503         for (Locale locale : allLocales) {
 504             String localeCode = locale.getLocaleCode();
 505             int underscoreLocation = localeCode.indexOf(&quot;_&quot;);
 506             if (underscoreLocation &gt; 0 &amp;&amp; Boolean.FALSE.equals(locale.getUseCountryInSearchIndex())) {
 507                 String localeCodeWithoutCountry = localeCode.substring(0, underscoreLocation);
 508                 if (!processedLocales.containsKey(localeCodeWithoutCountry)) {
 509                     processedLocales.put(localeCodeWithoutCountry, locale);
 510                 }
 511             } else {
 512                 processedLocales.put(locale.getLocaleCode(), locale);
 513             }
 514         }
 515         return new ArrayList&lt;&gt;(processedLocales.values());
 516     }
 517 
 518     @Override
<abbr title=" 519     public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 519     public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;LocalðŸ”µ</abbr>
<abbr title=" 520         final SolrInputDocument document = new SolrInputDocument(new LinkedHashMap&lt;String,SolrInputField&gt;());"> 520         final SolrInputDocument document = new SolrInputDocument(new LinkedHashMap&lt;String,SolrInputField&gt;ðŸ”µ</abbr>
 521 
 522         attachBasicDocumentFields(indexable, document);
 523 
 524         attachIndexableDocumentFields(document, indexable, fields, locales);
 525 
 526         attachAdditionalDocumentFields(indexable, document);
 527 
 528         extensionManager.getProxy().attachChildDocuments(indexable, document, fields, locales);
 529 
 530         return document;
 531     }
 532 
 533     @Override
<abbr title=" 534     public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 534     public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexðŸ”µ</abbr>
 535         for (IndexField indexField : fields) {
 536             try {
 537                 // If we find an IndexField entry for this field, then we need to store it in the index
 538                 if (indexField != null) {
 539                     List&lt;IndexFieldType&gt; searchableFieldTypes = indexField.getFieldTypes();
 540 
<abbr title=" 541                     // For each of its search field types, get the property values, and add a field to the document for each property value"> 541                     // For each of its search field types, get the property values, and add a field to thðŸ”µ</abbr>
 542                     for (IndexFieldType sft : searchableFieldTypes) {
 543                         FieldType fieldType = sft.getFieldType();
<abbr title=" 544                         Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getField(), fieldType, locales);"> 544                         Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getFðŸ”µ</abbr>
 545 
<abbr title=" 546                         ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentForIndexField(document, indexField, fieldType, propertyValues);"> 546                         ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentFoðŸ”µ</abbr>
 547 
 548                         if (ExtensionResultStatusType.NOT_HANDLED.equals(result)) {
 549                             // Build out the field for every prefix
 550                             for (Entry&lt;String, Object&gt; entry : propertyValues.entrySet()) {
 551                                 String prefix = entry.getKey();
 552                                 prefix = StringUtils.isBlank(prefix) ? prefix : prefix + &quot;_&quot;;
 553 
<abbr title=" 554                                 String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fieldType, prefix);"> 554                                 String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fiðŸ”µ</abbr>
 555                                 Object value = entry.getValue();
 556 
 557                                 if (FieldType.isMultiValued(fieldType)) {
 558                                     document.addField(solrPropertyName, value);
 559                                 } else {
 560                                     document.setField(solrPropertyName, value);
 561                                 }
 562                             }
 563                         }
 564                     }
 565                 }
 566 
 567             } catch (Exception e) {
<abbr title=" 568                 LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldName() + &quot;] for product id[&quot;"> 568                 LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldNaðŸ”µ</abbr>
 569                         + indexable.getId() + &quot;]&quot;, e);
 570                 throw ExceptionHelper.refineException(e);
 571             }
 572         }
 573     }
 574 
 575     /**
<abbr title=" 576      * Implementors can extend this and override this method to add additional fields to the Solr document."> 576      * Implementors can extend this and override this method to add additional fields to the Solr documenðŸ”µ</abbr>
 577      *
 578      * @param sku
 579      * @param document
 580      */
 581     protected void attachAdditionalDocumentFields(Indexable indexable, SolrInputDocument document) {
 582         //Empty implementation. Placeholder for others to extend and add additional fields
 583         extensionManager.getProxy().attachAdditionalDocumentFields(indexable, document);
 584     }
 585 
 586     protected void attachBasicDocumentFields(Indexable indexable, SolrInputDocument document) {
 587         CatalogStructure cache = SolrIndexCachedOperation.getCache();
 588         if (cache == null) {
 589             String msg = &quot;SolrIndexService.performCachedOperation() must be used in conjuction with&quot;
<abbr title=" 590                 + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog documents or should&quot;"> 590                 + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog doðŸ”µ</abbr>
 591                 + &quot; be invoked from buildIncrementalIndex()&quot;;
 592             LOG.error(msg);
 593             throw new IllegalStateException(msg);
 594         }
 595 
 596         // Add the namespace and ID fields for this product
 597         document.addField(shs.getNamespaceFieldName(), solrConfiguration.getNamespace());
 598         document.addField(shs.getIdFieldName(), shs.getSolrDocumentId(document, indexable));
 599         document.addField(shs.getTypeFieldName(), shs.getDocumentType(indexable));
 600         document.addField(shs.getIndexableIdFieldName(), shs.getIndexableId(indexable));
 601 
 602         extensionManager.getProxy().attachAdditionalBasicFields(indexable, document, shs);
 603 
 604         Long cacheKey = this.shs.getCurrentProductId(indexable); // current
 605         if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 606             cacheKey = sandBoxHelper.getOriginalId(cacheKey); // parent
 607             if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 608                 cacheKey = shs.getIndexableId(indexable); // master
 609             }
 610         }
 611 
 612         // TODO: figure this out more generally; this doesn&#x27;t work for CMS content
 613         // The explicit categories are the ones defined by the product itself
 614         if (cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 615             for (Long categoryId : cache.getParentCategoriesByProduct().get(cacheKey)) {
 616                 document.addField(shs.getExplicitCategoryFieldName(), shs.getCategoryId(categoryId));
 617 
 618                 // Make sure that we&#x27;re always referencing the parent for the sort field
<abbr title=" 619                 String categorySortFieldName = shs.getCategorySortFieldName(shs.getCategoryId(categoryId));"> 619                 String categorySortFieldName = shs.getCategorySortFieldName(shs.getCategoryId(categoryId)ðŸ”µ</abbr>
<abbr title=" 620                 // The issue here was the super category id is always what is stored in the cache, while the category"> 620                 // The issue here was the super category id is always what is stored in the cache, while ðŸ”µ</abbr>
<abbr title=" 621                 // by product id is the overridden versions. Need to always look at parent version for cache stuff, which"> 621                 // by product id is the overridden versions. Need to always look at parent version for caðŸ”µ</abbr>
 622                 // is given from shs.getCategoryId
 623                 // First try the current level
 624                 String displayOrderKey = categoryId + &quot;-&quot; + cacheKey;
 625                 Long displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 626                 if (displayOrder == null) {
<abbr title=" 627                     // Didn&#x27;t find the cache at the current level, this might be an override so look upwards"> 627                     // Didn&#x27;t find the cache at the current level, this might be an override so look upwaðŸ”µ</abbr>
 628                     displayOrderKey = shs.getCategoryId(categoryId) + &quot;-&quot; + cacheKey;
 629                     displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 630                 }
 631 
 632                 if (document.getField(categorySortFieldName) == null &amp;&amp; displayOrder != null) {
 633                     document.addField(categorySortFieldName, displayOrder);
 634                 }
 635 
 636                 // This is the entire tree of every category defined on the product
 637                 buildFullCategoryHierarchy(document, cache, categoryId, new HashSet&lt;Long&gt;());
 638             }
 639         }
 640     }
 641 
 642     /**
 643      * Walk the category hierarchy upwards, adding a field for each level to the solr document
 644      *
 645      * @param document the solr document for the product
 646      * @param cache the catalog structure cache
 647      * @param categoryId the current category id
 648      */
<abbr title=" 649     protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long categoryId, Set&lt;Long&gt; indexedParents) {"> 649     protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long caðŸ”µ</abbr>
 650         Long catIdToAdd = shs.getCategoryId(categoryId);
 651 
 652         Collection&lt;Object&gt; existingValues = document.getFieldValues(shs.getCategoryFieldName());
 653         if (existingValues == null || !existingValues.contains(catIdToAdd)) {
 654             document.addField(shs.getCategoryFieldName(), catIdToAdd);
 655         }
 656 
 657         Set&lt;Long&gt; parents = cache.getParentCategoriesByCategory().get(categoryId);
 658         for (Long parent : parents) {
 659             if (!indexedParents.contains(parent)) {
 660                 indexedParents.add(parent);
 661                 buildFullCategoryHierarchy(document, cache, parent, indexedParents);
 662             }
 663         }
 664     }
 665 
 666     /**
<abbr title=" 667      * Returns a map of prefix to value for the requested attributes. For example, if the requested field corresponds to"> 667      * Returns a map of prefix to value for the requested attributes. For example, if the requested fieldðŸ”µ</abbr>
<abbr title=" 668      * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting map could be"> 668      * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting ðŸ”µ</abbr>
 669      *
 670      * { &quot;en_US&quot; : &quot;A description&quot;,
 671      *   &quot;es_ES&quot; : &quot;Una descripcion&quot; }
 672      *
 673      * @param product
 674      * @param sku
 675      * @param field
 676      * @param fieldType
 677      * @param locales
 678      * @return the value of the property
 679      * @throws IllegalAccessException
 680      * @throws InvocationTargetException
 681      * @throws NoSuchMethodException
 682      */
<abbr title=" 683     protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldType, List&lt;Locale&gt; locales)"> 683     protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldTyðŸ”µ</abbr>
 684             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 685 
 686         String propertyName = field.getPropertyName();
 687         Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
 688 
 689         ExtensionResultStatusType extensionResult = ExtensionResultStatusType.NOT_HANDLED;
 690         if (extensionManager != null) {
<abbr title=" 691             extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldType, values, propertyName, locales);"> 691             extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldTypeðŸ”µ</abbr>
 692         }
 693 
 694         if (ExtensionResultStatusType.NOT_HANDLED.equals(extensionResult)) {
 695             Object propertyValue = shs.getPropertyValue(indexedItem, field);
 696             if (propertyValue != null) {
 697                 values.put(&quot;&quot;, propertyValue);
 698             }
 699         }
 700 
 701         return values;
 702     }
 703 
 704     /**
<abbr title=" 705      * Converts a propertyName to one that is able to reference inside a map. For example, consider the property"> 705      * Converts a propertyName to one that is able to reference inside a map. For example, consider the pðŸ”µ</abbr>
<abbr title=" 706      * in Product that references a List&lt;ProductAttribute&gt;, &quot;productAttributes&quot;. Also consider the utility method"> 706      * in Product that references a List&lt;ProductAttribute&gt;, &quot;productAttributes&quot;. Also consider the utilitðŸ”µ</abbr>
<abbr title=" 707      * in Product called &quot;mappedProductAttributes&quot;, which returns a map of the ProductAttributes keyed by the name"> 707      * in Product called &quot;mappedProductAttributes&quot;, which returns a map of the ProductAttributes keyed byðŸ”µ</abbr>
<abbr title=" 708      * property in the ProductAttribute. Given the parameters &quot;productAttributes.heatRange&quot;, &quot;productAttributes&quot;,"> 708      * property in the ProductAttribute. Given the parameters &quot;productAttributes.heatRange&quot;, &quot;productAttrðŸ”µ</abbr>
<abbr title=" 709      * &quot;mappedProductAttributes&quot; (which would represent a property called &quot;productAttributes.heatRange&quot; that"> 709      * &quot;mappedProductAttributes&quot; (which would represent a property called &quot;productAttributes.heatRange&quot; tðŸ”µ</abbr>
<abbr title=" 710      * references a specific ProductAttribute inside of a product whose &quot;name&quot; property is equal to &quot;heatRange&quot;,"> 710      * references a specific ProductAttribute inside of a product whose &quot;name&quot; property is equal to &quot;heatðŸ”µ</abbr>
<abbr title=" 711      * this method will convert this property to mappedProductAttributes(heatRange).value, which is then usable"> 711      * this method will convert this property to mappedProductAttributes(heatRange).value, which is then ðŸ”µ</abbr>
 712      * by the standard beanutils PropertyUtils class to get the value.
 713      *
 714      * @param propertyName
 715      * @param listPropertyName
 716      * @param mapPropertyName
 717      * @return the converted property name
 718      *
 719      * @deprecated see SolrHelperService.getPropertyValue()
 720      */
 721     @Deprecated
<abbr title=" 722     protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropertyName) {"> 722     protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropðŸ”µ</abbr>
 723         String[] splitName = StringUtils.split(propertyName, &quot;\\.&quot;);
 724         StringBuilder convertedProperty = new StringBuilder();
 725         for (int i = 0; i &lt; splitName.length; i++) {
 726             if (convertedProperty.length() &gt; 0) {
 727                 convertedProperty.append(&quot;.&quot;);
 728             }
 729 
 730             if (splitName[i].equals(listPropertyName)) {
 731                 convertedProperty.append(mapPropertyName).append(&quot;(&quot;);
 732                 convertedProperty.append(splitName[i + 1]).append(&quot;).value&quot;);
 733                 i++;
 734             } else {
 735                 convertedProperty.append(splitName[i]);
 736             }
 737         }
 738         return convertedProperty.toString();
 739     }
 740 
 741     @Override
 742     public Object[] saveState() {
 743          return new Object[] {
 744              BroadleafRequestContext.getBroadleafRequestContext(),
 745              SkuPricingConsiderationContext.getSkuPricingConsiderationContext(),
 746              SkuPricingConsiderationContext.getSkuPricingService(),
 747              SkuActiveDateConsiderationContext.getSkuActiveDatesService()
 748          };
 749      }
 750 
 751     @Override
 752     @SuppressWarnings(&quot;rawtypes&quot;)
 753     public void restoreState(Object[] pack) {
 754          BroadleafRequestContext.setBroadleafRequestContext((BroadleafRequestContext) pack[0]);
 755          SkuPricingConsiderationContext.setSkuPricingConsiderationContext((HashMap) pack[1]);
 756          SkuPricingConsiderationContext.setSkuPricingService((DynamicSkuPricingService) pack[2]);
<abbr title=" 757          SkuActiveDateConsiderationContext.setSkuActiveDatesService((DynamicSkuActiveDatesService) pack[3]);"> 757          SkuActiveDateConsiderationContext.setSkuActiveDatesService((DynamicSkuActiveDatesService) pack[3ðŸ”µ</abbr>
 758      }
 759 
 760     @Override
<abbr title=" 761     public void optimizeIndex(String collection, SolrClient server) throws ServiceException, IOException {"> 761     public void optimizeIndex(String collection, SolrClient server) throws ServiceException, IOException ðŸ”µ</abbr>
 762         shs.optimizeIndex(collection, server);
 763     }
 764 
 765     @Override
 766     public void commit(String collection, SolrClient server) throws ServiceException, IOException {
 767         if (this.commit) {
 768             commit(collection, server, this.softCommit, this.waitSearcher, this.waitFlush);
 769         } else if (LOG.isDebugEnabled()) {
<abbr title=" 770             LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoCommit is configured.&quot;);"> 770             LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoComðŸ”µ</abbr>
 771         }
 772     }
 773 
 774     @Override
<abbr title=" 775     public void commit(String collection, SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 775     public void commit(String collection, SolrClient server, boolean softCommit, boolean waitSearcher, boðŸ”µ</abbr>
 776         try {
 777             if (!this.commit) {
<abbr title=" 778                 LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is being forced via the API.&quot;);"> 778                 LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is beingðŸ”µ</abbr>
 779             }
 780 
 781             if (LOG.isDebugEnabled()) {
 782                 LOG.debug(&quot;Committing changes to Solr index: softCommit: &quot; + softCommit
 783                         + &quot;, waitSearcher: &quot; + waitSearcher + &quot;, waitFlush: &quot; + waitFlush);
 784             }
 785 
 786             server.commit(collection, waitFlush, waitSearcher, softCommit);
 787         } catch (SolrServerException e) {
 788             throw new ServiceException(&quot;Could not commit changes to Solr index&quot;, e);
 789         }
 790     }
 791 
 792     @Override
 793     public void optimizeIndex(SolrClient server) throws ServiceException, IOException {
 794         optimizeIndex(null, server);
 795     }
 796 
 797     @Override
 798     public void commit(SolrClient server) throws ServiceException, IOException {
 799         commit(null, server);
 800     }
 801 
 802     @Override
<abbr title=" 803     public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 803     public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) thðŸ”µ</abbr>
 804         commit(null, server, softCommit, waitSearcher, waitFlush);
 805     }
 806 
 807     @Override
 808     public void logDocuments(Collection&lt;SolrInputDocument&gt; documents) {
 809         if (LOG.isTraceEnabled()) {
 810             for (SolrInputDocument document : documents) {
 811                 LOG.trace(document);
 812             }
 813         }
 814     }
 815 
 816     /**
 817      *  We multiply the BigDecimal by 1,000,000 to maintain any possible decimals in use the
 818      *  displayOrder value.
 819      *
 820      * @param cache
 821      * @param displayOrderKey
 822      * @return
 823      */
 824     protected Long convertDisplayOrderToLong(CatalogStructure cache, String displayOrderKey) {
 825         BigDecimal displayOrder = cache.getDisplayOrdersByCategoryProduct().get(displayOrderKey);
 826 
 827         if (displayOrder == null) {
 828             return null;
 829         }
 830 
 831         return displayOrder.multiply(BigDecimal.valueOf(1000000)).longValue();
 832     }
 833 
 834     @Override
 835     public void deleteByQuery(String deleteQuery) throws SolrServerException, IOException {
 836         String productFilter = shs.getTypeFieldName() + &quot;:&quot; + shs.getPrimaryDocumentType();
 837 
<abbr title=" 838         // transform the deleteQuery to include the productFilter, this is necessary to ensure that we don&#x27;t delete non-product documents accidentally"> 838         // transform the deleteQuery to include the productFilter, this is necessary to ensure that we doðŸ”µ</abbr>
 839         deleteQuery = productFilter + &quot; AND (&quot; + deleteQuery + &quot;)&quot;;
 840 
 841         String childDeleteQuery = &quot;{!child of=&quot; + productFilter + &quot;} &quot; + deleteQuery;
<abbr title=" 842         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), childDeleteQuery);"> 842         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), childDeleðŸ”µ</abbr>
<abbr title=" 843         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), deleteQuery);"> 843         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), deleteQueðŸ”µ</abbr>
 844 
 845         logDeleteQuery(childDeleteQuery);
 846         logDeleteQuery(deleteQuery);
 847     }
 848 
 849     @Override
<abbr title=" 850     public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerException {"> 850     public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerExcepðŸ”µ</abbr>
 851         solrConfiguration.getServer().add(solrConfiguration.getQueryCollectionName(), documents);
 852         logDocuments(documents);
 853     }
 854 
 855     @Override
 856     public void logDeleteQuery(String deleteQuery) {
 857         if (LOG.isDebugEnabled()) {
 858             LOG.debug(&quot;Delete query: &quot; + deleteQuery);
 859         }
 860     }
 861 
 862     @Override
 863     public boolean useLegacyIndexer() {
 864         return useLegacySolrIndexer;
 865     }
 866 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.search.service.solr.index;
  19 
  20 import java.io.IOException;
  21 import java.lang.reflect.InvocationTargetException;
  22 import java.math.BigDecimal;
  23 import java.util.ArrayList;
  24 import java.util.Collection;
  25 import java.util.HashMap;
  26 import java.util.HashSet;
  27 import java.util.LinkedHashMap;
  28 import java.util.List;
  29 import java.util.Map.Entry;
  30 import java.util.Map;
  31 import java.util.Set;
  32 import javax.annotation.Resource;
  33 import org.apache.commons.collections.CollectionUtils;
  34 import org.apache.commons.lang3.ObjectUtils;
  35 import org.apache.commons.lang3.StringUtils;
  36 import org.apache.commons.logging.Log;
  37 import org.apache.commons.logging.LogFactory;
  38 import org.apache.solr.client.solrj.SolrClient;
  39 import org.apache.solr.client.solrj.SolrServerException;
  40 import org.apache.solr.common.SolrInputDocument;
  41 import org.apache.solr.common.SolrInputField;
  42 import org.broadleafcommerce.common.exception.ExceptionHelper;
  43 import org.broadleafcommerce.common.exception.ServiceException;
  44 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  45 import org.broadleafcommerce.common.locale.domain.Locale;
  46 import org.broadleafcommerce.common.locale.service.LocaleService;
  47 import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  48 import org.broadleafcommerce.common.site.domain.Catalog;
  49 import org.broadleafcommerce.common.util.BLCCollectionUtils;
  50 import org.broadleafcommerce.common.util.StopWatch;
  51 import org.broadleafcommerce.common.util.StringUtil;
  52 import org.broadleafcommerce.common.util.TransactionUtils;
  53 import org.broadleafcommerce.common.util.TypedTransformer;
  54 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  55 import org.broadleafcommerce.core.catalog.dao.ProductDao;
  56 import org.broadleafcommerce.core.catalog.domain.Indexable;
  57 import org.broadleafcommerce.core.catalog.service.CatalogService;
  58 import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuActiveDatesService;
  59 import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuPricingService;
  60 import org.broadleafcommerce.core.catalog.service.dynamic.SkuActiveDateConsiderationContext;
  61 import org.broadleafcommerce.core.catalog.service.dynamic.SkuPricingConsiderationContext;
  62 import org.broadleafcommerce.core.search.dao.CatalogStructure;
  63 import org.broadleafcommerce.core.search.dao.FieldDao;
  64 import org.broadleafcommerce.core.search.dao.IndexFieldDao;
  65 import org.broadleafcommerce.core.search.dao.SearchFacetDao;
  66 import org.broadleafcommerce.core.search.dao.SolrIndexDao;
  67 import org.broadleafcommerce.core.search.domain.Field;
  68 import org.broadleafcommerce.core.search.domain.FieldEntity;
  69 import org.broadleafcommerce.core.search.domain.IndexField;
  70 import org.broadleafcommerce.core.search.domain.IndexFieldType;
  71 import org.broadleafcommerce.core.search.domain.solr.FieldType;
  72 import org.broadleafcommerce.core.search.service.solr.SolrConfiguration;
  73 import org.broadleafcommerce.core.search.service.solr.SolrHelperService;
  74 import org.springframework.beans.factory.InitializingBean;
  75 import org.springframework.beans.factory.annotation.Autowired;
  76 import org.springframework.beans.factory.annotation.Qualifier;
  77 import org.springframework.beans.factory.annotation.Value;
  78 import org.springframework.stereotype.Service;
  79 import org.springframework.transaction.PlatformTransactionManager;
  80 import org.springframework.transaction.TransactionDefinition;
  81 import org.springframework.transaction.TransactionStatus;
  82 
  83 
  84 /**
  85  * Responsible for building and rebuilding the Solr index
  86  *
  87  * @author Andre Azzolini (apazzolini)
  88  * @author Jeff Fischer
  89  */
  90 @Service(&quot;blSolrIndexService&quot;)
  91 public class SolrIndexServiceImpl implements SolrIndexService , InitializingBean {
  92     private static final Log LOG = LogFactory.getLog(SolrIndexServiceImpl.class);
  93 
  94     @Qualifier(&quot;blCatalogSolrConfiguration&quot;)
  95     @Autowired(required = false)
  96     protected SolrConfiguration solrConfiguration;
  97 
  98     @Value(&quot;${solr.index.errorOnConcurrentReIndex}&quot;)
  99     protected boolean errorOnConcurrentReIndex = false;
 100 
 101     @Value(&quot;${solr.index.product.pageSize}&quot;)
 102     protected int pageSize;
 103 
 104     @Value(&quot;${solr.index.commit}&quot;)
 105     protected boolean commit;
 106 
 107     @Value(&quot;${solr.index.softCommit}&quot;)
 108     protected boolean softCommit;
 109 
 110     @Value(&quot;${solr.index.waitSearcher}&quot;)
 111     protected boolean waitSearcher;
 112 
 113     @Value(&quot;${solr.index.waitFlush}&quot;)
 114     protected boolean waitFlush;
 115 
 116     @Value(value = &quot;${solr.catalog.useLegacySolrIndexer:true}&quot;)
 117     protected boolean useLegacySolrIndexer = true;
 118 
 119     @Resource(name = &quot;blProductDao&quot;)
 120     protected ProductDao productDao;
 121 
 122     @Resource(name = &quot;blCatalogService&quot;)
 123     protected CatalogService catalogService;
 124 
 125     @Resource(name = &quot;blFieldDao&quot;)
 126     protected FieldDao fieldDao;
 127 
 128     @Resource(name = &quot;blLocaleService&quot;)
 129     protected LocaleService localeService;
 130 
 131     @Resource(name = &quot;blSolrHelperService&quot;)
 132     protected SolrHelperService shs;
 133 
 134     @Resource(name = &quot;blSolrIndexServiceExtensionManager&quot;)
 135     protected SolrIndexServiceExtensionManager extensionManager;
 136 
 137     @Resource(name = &quot;blTransactionManager&quot;)
 138     protected PlatformTransactionManager transactionManager;
 139 
 140     @Resource(name = &quot;blSolrIndexDao&quot;)
 141     protected SolrIndexDao solrIndexDao;
 142 
 143     @Resource(name = &quot;blSandBoxHelper&quot;)
 144     protected SandBoxHelper sandBoxHelper;
 145 
 146     @Resource(name = &quot;blSearchFacetDao&quot;)
 147     protected SearchFacetDao searchFacetDao;
 148 
 149     @Resource(name = &quot;blIndexFieldDao&quot;)
 150     protected IndexFieldDao indexFieldDao;
 151 
 152     @Value(&quot;${enable.solr.optimize:false}&quot;)
 153     private boolean optimizeEnabled;
 154 
 155     @Override
 156     public void afterPropertiesSet() throws Exception {
 157         if (!useLegacySolrIndexer) {
 158             if (useSku) {
<abbr title=" 159                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;solr.index.use.sku&#x27; was true, which is not supported.&quot;);"> 159                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was falðŸ”µ</abbr>
 160             }
 161             if (solrConfiguration != null &amp;&amp; solrConfiguration.isSiteCollections()) {
<abbr title=" 162                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;solr.index.site.collections&#x27; was true, which is not supported.&quot;);"> 162                 throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was falðŸ”µ</abbr>
 163             }
 164         }
 165     }
 166 
 167     @Override
<abbr title=" 168     public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws ServiceException {"> 168     public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws SerðŸ”µ</abbr>
 169         try {
 170             CatalogStructure cache = new CatalogStructure();
 171             SolrIndexCachedOperation.setCache(cache);
 172             cacheOperation.execute();
 173         } finally {
 174             SolrIndexCachedOperation.clearCache();
 175         }
 176     }
 177 
 178     @Override
 179     public void rebuildIndex() throws ServiceException, IOException {
 180         LOG.info(&quot;Rebuilding the entire Solr index...&quot;);
 181         StopWatch s = new StopWatch();
 182 
 183         preBuildIndex();
 184         buildIndex();
 185         postBuildIndex();
 186 
 187         LOG.info(String.format(&quot;Finished building entire Solr index in %s&quot;, s.toLapString()));
 188     }
 189 
 190     @Override
 191     public void preBuildIndex() throws ServiceException {
<abbr title=" 192         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 192         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReðŸ”µ</abbr>
 193     }
 194 
 195     @Override
 196     public void buildIndex() throws IOException, ServiceException {
 197         executeSolrIndexOperation(getReindexOperation());
 198     }
 199 
 200     @Override
 201     public void postBuildIndex() throws IOException, ServiceException {
 202         if (optimizeEnabled) {
 203         // this is required to be at the very very very end after rebuilding the whole index
<abbr title=" 204             optimizeIndex(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 204             optimizeIndex(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServeðŸ”µ</abbr>
 205         }
 206         // Swap the active and the reindex cores
 207         if (!solrConfiguration.isSingleCoreMode()) {
 208             shs.swapActiveCores(solrConfiguration);
 209         }
 210     }
 211 
 212     @Override
 213     public SolrIndexOperation getReindexOperation() {
<abbr title=" 214         return new GlobalSolrFullReIndexOperation(this, solrConfiguration, shs, errorOnConcurrentReIndex) {"> 214         return new GlobalSolrFullReIndexOperation(this, solrConfiguration, shs, errorOnConcurrentReIndex)ðŸ”µ</abbr>
 215             @Override
 216             public List&lt;? extends Indexable&gt; readIndexables(int pageSize, Long lastId) {
 217                 return readAllActiveIndexables(pageSize, lastId);
 218             }
 219 
 220             @Override
 221             public Long countIndexables() {
 222                 return countIndexableItems();
 223             }
 224 
 225             @Override
 226             public void buildPage(List&lt;? extends Indexable&gt; indexables) throws ServiceException {
<abbr title=" 227                 buildIncrementalIndex(getSolrCollectionForIndexing(), indexables, getSolrServerForIndexing());"> 227                 buildIncrementalIndex(getSolrCollectionForIndexing(), indexables, getSolrServerForIndexinðŸ”µ</abbr>
 228             }
 229         };
 230     }
 231 
 232     @Override
<abbr title=" 233     public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOException {"> 233     public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOðŸ”µ</abbr>
 234         operation.obtainLock();
 235 
 236         try {
 237             LOG.info(&quot;Executing Indexing operation&quot;);
 238             StopWatch s = new StopWatch();
 239 
 240             Object[] pack = saveState();
 241             try {
 242                 final Long numItemsToIndex;
 243                 try {
 244                     operation.beforeCountIndexables();
 245 
 246                     numItemsToIndex = operation.countIndexables();
 247                 } finally {
 248                     operation.afterCountIndexables();
 249                 }
 250 
 251                 if (LOG.isDebugEnabled()) {
 252                     LOG.debug(&quot;There are at most &quot; + numItemsToIndex + &quot; items to index&quot;);
 253                 }
 254                 performCachedOperation(new SolrIndexCachedOperation.CacheOperation() {
 255 
 256                     @Override
 257                     public void execute() throws ServiceException {
 258                         int page = 1;
 259                         Long lastId = null;
 260                         Long remainingNumItemsToIndex = numItemsToIndex;
 261                         Long totalPages = getTotalPageCount(numItemsToIndex);
 262 
 263                         while (remainingNumItemsToIndex &gt; 0) {
 264                             String pageNumberMessage = buildPageNumberMessage(page, totalPages);
 265                             LOG.info(pageNumberMessage);
 266 
 267                             lastId = buildIncrementalIndex(pageSize, lastId, operation);
 268                             remainingNumItemsToIndex -= pageSize;
 269                             page++;
 270                         }
 271                     }
 272                 });
 273 
 274             } finally {
 275                 restoreState(pack);
 276             }
 277 
 278             LOG.info(String.format(&quot;Indexing operation completed in %s&quot;, s.toLapString()));
 279         } finally {
 280             operation.releaseLock();
 281         }
 282     }
 283 
 284     protected long getTotalPageCount(Long numItemsToIndex) {
 285         long numPagesToIndex = numItemsToIndex / pageSize;
 286         boolean hasRemainingItemsToIndex = numItemsToIndex % pageSize != 0;
 287 
 288         return hasRemainingItemsToIndex ? (numPagesToIndex + 1) : numPagesToIndex;
 289     }
 290 
 291     protected String buildPageNumberMessage(int page, Long totalPages) {
 292         String pageNumberMessage = String.format(&quot;Building page number %s of %s&quot;, page, totalPages);
 293 
<abbr title=" 294         Catalog currentCatalog = BroadleafRequestContext.getBroadleafRequestContext().getCurrentCatalog();"> 294         Catalog currentCatalog = BroadleafRequestContext.getBroadleafRequestContext().getCurrentCatalog()ðŸ”µ</abbr>
 295         if (currentCatalog != null) {
 296             pageNumberMessage += String.format(&quot; for catalog: %s&quot;, currentCatalog.getName());
 297         }
 298 
 299         return pageNumberMessage;
 300     }
 301 
 302     /**
 303      * @return
 304      */
 305     protected Long countIndexableItems() {
 306         return productDao.readCountAllActiveProducts();
 307     }
 308 
 309     /**
 310      * &lt;p&gt;
 311      * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 312      *
 313      * @throws ServiceException if there was a problem removing the documents
 314      * @deprecated use {@link #deleteAllReindexCoreDocuments()} instead
 315      */
 316     @Deprecated
 317     protected void deleteAllDocuments() throws ServiceException {
 318         deleteAllReindexCoreDocuments();
 319     }
 320 
 321     /**
 322      * &lt;p&gt;
 323      * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 324      *
 325      * @throws ServiceException if there was a problem removing the documents
 326      */
 327     protected void deleteAllReindexCoreDocuments() throws ServiceException {
<abbr title=" 328         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 328         deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReðŸ”µ</abbr>
 329     }
 330 
 331     @Override
<abbr title=" 332     public void deleteAllNamespaceDocuments(String collection, SolrClient server) throws ServiceException {"> 332     public void deleteAllNamespaceDocuments(String collection, SolrClient server) throws ServiceExceptionðŸ”µ</abbr>
 333         try {
<abbr title=" 334             String deleteQuery = ((StringUtil.sanitize(shs.getNamespaceFieldName()) + &quot;:(\&quot;&quot;) + StringUtil.sanitize(solrConfiguration.getNamespace())) + &quot;\&quot;)&quot;;"> 334             String deleteQuery = ((StringUtil.sanitize(shs.getNamespaceFieldName()) + &quot;:(\&quot;&quot;) + StringUtiðŸ”µ</abbr>
 335             LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
 336             server.deleteByQuery(collection, deleteQuery);
 337             //Explicitly do a hard commit here since we just deleted the entire index
 338             server.commit(collection);
 339         } catch (java.lang.Exception e) {
 340             if (ServiceException.class.isAssignableFrom(e.getClass())) {
 341                 throw ((ServiceException) (e));
 342             }
 343             throw new ServiceException(&quot;Could not delete documents&quot;, e);
 344         }
 345     }
 346 
 347     @Override
 348     public void deleteAllDocuments(String collection, SolrClient server) throws ServiceException {
 349         try {
 350             String deleteQuery = &quot;*:*&quot;;
 351             LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
 352             server.deleteByQuery(collection, deleteQuery);
 353             server.commit(collection);
 354         } catch (java.lang.Exception e) {
 355             throw new ServiceException(&quot;Could not delete documents&quot;, e);
 356         }
 357     }
 358 
<abbr title=" 359     protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ServiceException {"> 359     protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ðŸ”µ</abbr>
 360         TransactionStatus status = TransactionUtils.createTransaction(&quot;readItemsToIndex&quot;,
 361             TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 362         if (SolrIndexCachedOperation.getCache() == null) {
 363             LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 364                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 364                     &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr ðŸ”µ</abbr>
 365         }
 366         Long response = null;
 367         try {
 368             List&lt;? extends Indexable&gt; indexables;
 369             try {
 370                 operation.beforeReadIndexables();
 371                 indexables = operation.readIndexables(pageSize, lastId);
 372                 if (CollectionUtils.isNotEmpty(indexables)) {
 373                     response = indexables.get(indexables.size()-1).getId();
 374                 }
 375             } finally {
 376                 operation.afterReadIndexables();
 377             }
 378 
 379             try {
 380                 operation.beforeBuildPage();
 381 
 382                 operation.buildPage(indexables);
 383             } finally {
 384                 operation.afterBuildPage();
 385             }
 386 
 387 
 388             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 389         } catch (RuntimeException e) {
 390             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 391             throw e;
 392         }
 393         return response;
 394     }
 395 
 396     @Override
<abbr title=" 397     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(String collection, List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 397     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(String collection, List&lt;? extends IndexablðŸ”µ</abbr>
<abbr title=" 398         TransactionStatus status = TransactionUtils.createTransaction(&quot;executeIncrementalIndex&quot;, TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);"> 398         TransactionStatus status = TransactionUtils.createTransaction(&quot;executeIncrementalIndex&quot;, TransactðŸ”µ</abbr>
 399         if (SolrIndexCachedOperation.getCache() == null) {
<abbr title=" 400             LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; + &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 400             LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; + &quot;SðŸ”µ</abbr>
 401         }
 402         if (LOG.isDebugEnabled()) {
<abbr title=" 403             LOG.debug(String.format(&quot;Building incremental product index - pageSize: [%s]...&quot;, indexables.size()));"> 403             LOG.debug(String.format(&quot;Building incremental product index - pageSize: [%s]...&quot;, indexables.ðŸ”µ</abbr>
 404         }
 405         StopWatch s = new StopWatch();
 406         try {
 407             sandBoxHelper.ignoreCloneCache(true);
 408             extensionManager.getProxy().startBatchEvent(indexables);
 409             Collection&lt;SolrInputDocument&gt; documents = new ArrayList&lt;&gt;();
 410             List&lt;Locale&gt; locales = getAllLocales();
<abbr title=" 411             List&lt;Long&gt; productIds = BLCCollectionUtils.collectList(indexables, new TypedTransformer&lt;Long&gt;() {"> 411             List&lt;Long&gt; productIds = BLCCollectionUtils.collectList(indexables, new TypedTransformer&lt;Long&gt;ðŸ”µ</abbr>
 412                 @Override
 413                 public Long transform(Object input) {
 414                     return shs.getCurrentProductId(((Indexable) (input)));
 415                 }
 416             });
<abbr title=" 417             solrIndexDao.populateProductCatalogStructure(productIds, SolrIndexCachedOperation.getCache());"> 417             solrIndexDao.populateProductCatalogStructure(productIds, SolrIndexCachedOperation.getCache())ðŸ”µ</abbr>
 418             List&lt;IndexField&gt; fields = null;
 419             FieldEntity currentFieldType = null;
 420             for (Indexable indexable : indexables) {
<abbr title=" 421                 if ((fields == null) || ObjectUtils.notEqual(currentFieldType, indexable.getFieldEntityType())) {"> 421                 if ((fields == null) || ObjectUtils.notEqual(currentFieldType, indexable.getFieldEntityTyðŸ”µ</abbr>
 422                     fields = indexFieldDao.readFieldsByEntityType(indexable.getFieldEntityType());
 423                 }
 424                 SolrInputDocument doc = buildDocument(indexable, fields, locales);
<abbr title=" 425                 // If someone overrides the buildDocument method and determines that they don&#x27;t want a product"> 425                 // If someone overrides the buildDocument method and determines that they don&#x27;t want a prðŸ”µ</abbr>
 426                 // indexed, then they can return null. If the document is null it does not get added to
 427                 // to the index.
 428                 if (doc != null) {
 429                     documents.add(doc);
 430                 }
 431             }
 432             extensionManager.getProxy().modifyBuiltDocuments(documents, indexables, fields, locales);
 433             logDocuments(documents);
 434             if ((!CollectionUtils.isEmpty(documents)) &amp;&amp; (solrServer != null)) {
 435                 solrServer.add(collection, documents);
 436                 commit(collection, solrServer);
 437             }
 438             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 439             if (LOG.isDebugEnabled()) {
<abbr title=" 440                 LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexables.size(), s.toLapString()));"> 440                 LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexðŸ”µ</abbr>
 441             }
 442             return documents;
 443         } catch (SolrServerException e) {
 444             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 445             throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 446         } catch (IOException e) {
 447             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 448             throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 449         } catch (java.lang.RuntimeException e) {
 450             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 451             throw e;
 452         } finally {
 453             extensionManager.getProxy().endBatchEvent(indexables);
 454             sandBoxHelper.ignoreCloneCache(false);
 455         }
 456     }
 457 
 458     protected List&lt;? extends Indexable&gt; readAllActiveIndexables(int pageSize, Long lastId) {
 459         return productDao.readAllActiveProducts(pageSize, lastId);
 460     }
 461 
 462     @Override
 463     public List&lt;Locale&gt; getAllLocales() {
 464         List&lt;Locale&gt; allLocales = localeService.findAllLocales();
 465         Map&lt;String, Locale&gt; processedLocales = new HashMap&lt;&gt;();
<abbr title=" 466         // Optimize the list of locales we are looking at. If I have an &#x27;en&#x27; and &#x27;en_US&#x27; in the locale set and I&#x27;m"> 466         // Optimize the list of locales we are looking at. If I have an &#x27;en&#x27; and &#x27;en_US&#x27; in the locale seðŸ”µ</abbr>
 467         // not using the country code to index the values, then I only need to index the locale &#x27;en&#x27;
 468         for (Locale locale : allLocales) {
 469             String localeCode = locale.getLocaleCode();
 470             int underscoreLocation = localeCode.indexOf(&quot;_&quot;);
 471             if (underscoreLocation &gt; 0 &amp;&amp; Boolean.FALSE.equals(locale.getUseCountryInSearchIndex())) {
 472                 String localeCodeWithoutCountry = localeCode.substring(0, underscoreLocation);
 473                 if (!processedLocales.containsKey(localeCodeWithoutCountry)) {
 474                     processedLocales.put(localeCodeWithoutCountry, locale);
 475                 }
 476             } else {
 477                 processedLocales.put(locale.getLocaleCode(), locale);
 478             }
 479         }
 480         return new ArrayList&lt;&gt;(processedLocales.values());
 481     }
 482 
 483     @Override
<abbr title=" 484     public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 484     public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;LocalðŸ”µ</abbr>
<abbr title=" 485         final SolrInputDocument document = new SolrInputDocument(new LinkedHashMap&lt;String, SolrInputField&gt;());"> 485         final SolrInputDocument document = new SolrInputDocument(new LinkedHashMap&lt;String, SolrInputFieldðŸ”µ</abbr>
 486         attachBasicDocumentFields(indexable, document);
 487         attachIndexableDocumentFields(document, indexable, fields, locales);
 488         attachAdditionalDocumentFields(indexable, document);
 489         extensionManager.getProxy().attachChildDocuments(indexable, document, fields, locales);
 490         return document;
 491     }
 492 
 493     @Override
<abbr title=" 494     public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 494     public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexðŸ”µ</abbr>
 495         for (IndexField indexField : fields) {
 496             try {
 497                 // If we find an IndexField entry for this field, then we need to store it in the index
 498                 if (indexField != null) {
 499                     List&lt;IndexFieldType&gt; searchableFieldTypes = indexField.getFieldTypes();
 500 
<abbr title=" 501                     // For each of its search field types, get the property values, and add a field to the document for each property value"> 501                     // For each of its search field types, get the property values, and add a field to thðŸ”µ</abbr>
 502                     for (IndexFieldType sft : searchableFieldTypes) {
 503                         FieldType fieldType = sft.getFieldType();
<abbr title=" 504                         Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getField(), fieldType, locales);"> 504                         Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getFðŸ”µ</abbr>
 505 
<abbr title=" 506                         ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentForIndexField(document, indexField, fieldType, propertyValues);"> 506                         ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentFoðŸ”µ</abbr>
 507 
 508                         if (ExtensionResultStatusType.NOT_HANDLED.equals(result)) {
 509                             // Build out the field for every prefix
 510                             for (Entry&lt;String, Object&gt; entry : propertyValues.entrySet()) {
 511                                 String prefix = entry.getKey();
 512                                 prefix = StringUtils.isBlank(prefix) ? prefix : prefix + &quot;_&quot;;
 513 
<abbr title=" 514                                 String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fieldType, prefix);"> 514                                 String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fiðŸ”µ</abbr>
 515                                 Object value = entry.getValue();
 516 
 517                                 if (FieldType.isMultiValued(fieldType)) {
 518                                     document.addField(solrPropertyName, value);
 519                                 } else {
 520                                     document.setField(solrPropertyName, value);
 521                                 }
 522                             }
 523                         }
 524                     }
 525                 }
 526 
 527             } catch (Exception e) {
<abbr title=" 528                 LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldName() + &quot;] for product id[&quot;"> 528                 LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldNaðŸ”µ</abbr>
 529                         + indexable.getId() + &quot;]&quot;, e);
 530                 throw ExceptionHelper.refineException(e);
 531             }
 532         }
 533     }
 534 
 535     /**
<abbr title=" 536      * Implementors can extend this and override this method to add additional fields to the Solr document."> 536      * Implementors can extend this and override this method to add additional fields to the Solr documenðŸ”µ</abbr>
 537      *
 538      * @param sku
 539      * @param document
 540      */
 541     protected void attachAdditionalDocumentFields(Indexable indexable, SolrInputDocument document) {
 542         //Empty implementation. Placeholder for others to extend and add additional fields
 543         extensionManager.getProxy().attachAdditionalDocumentFields(indexable, document);
 544     }
 545 
 546     protected void attachBasicDocumentFields(Indexable indexable, SolrInputDocument document) {
 547         CatalogStructure cache = SolrIndexCachedOperation.getCache();
 548         if (cache == null) {
 549             String msg = &quot;SolrIndexService.performCachedOperation() must be used in conjuction with&quot;
<abbr title=" 550                 + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog documents or should&quot;"> 550                 + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog doðŸ”µ</abbr>
 551                 + &quot; be invoked from buildIncrementalIndex()&quot;;
 552             LOG.error(msg);
 553             throw new IllegalStateException(msg);
 554         }
 555 
 556         // Add the namespace and ID fields for this product
 557         document.addField(shs.getNamespaceFieldName(), solrConfiguration.getNamespace());
 558         document.addField(shs.getIdFieldName(), shs.getSolrDocumentId(document, indexable));
 559         document.addField(shs.getTypeFieldName(), shs.getDocumentType(indexable));
 560         document.addField(shs.getIndexableIdFieldName(), shs.getIndexableId(indexable));
 561 
 562         extensionManager.getProxy().attachAdditionalBasicFields(indexable, document, shs);
 563 
 564         Long cacheKey = this.shs.getCurrentProductId(indexable); // current
 565         if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 566             cacheKey = sandBoxHelper.getOriginalId(cacheKey); // parent
 567             if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 568                 cacheKey = shs.getIndexableId(indexable); // master
 569             }
 570         }
 571 
 572         // TODO: figure this out more generally; this doesn&#x27;t work for CMS content
 573         // The explicit categories are the ones defined by the product itself
 574         if (cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 575             for (Long categoryId : cache.getParentCategoriesByProduct().get(cacheKey)) {
 576                 document.addField(shs.getExplicitCategoryFieldName(), shs.getCategoryId(categoryId));
 577 
 578                 // Make sure that we&#x27;re always referencing the parent for the sort field
<abbr title=" 579                 String categorySortFieldName = shs.getCategorySortFieldName(shs.getCategoryId(categoryId));"> 579                 String categorySortFieldName = shs.getCategorySortFieldName(shs.getCategoryId(categoryId)ðŸ”µ</abbr>
<abbr title=" 580                 // The issue here was the super category id is always what is stored in the cache, while the category"> 580                 // The issue here was the super category id is always what is stored in the cache, while ðŸ”µ</abbr>
<abbr title=" 581                 // by product id is the overridden versions. Need to always look at parent version for cache stuff, which"> 581                 // by product id is the overridden versions. Need to always look at parent version for caðŸ”µ</abbr>
 582                 // is given from shs.getCategoryId
 583                 // First try the current level
 584                 String displayOrderKey = categoryId + &quot;-&quot; + cacheKey;
 585                 Long displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 586                 if (displayOrder == null) {
<abbr title=" 587                     // Didn&#x27;t find the cache at the current level, this might be an override so look upwards"> 587                     // Didn&#x27;t find the cache at the current level, this might be an override so look upwaðŸ”µ</abbr>
 588                     displayOrderKey = shs.getCategoryId(categoryId) + &quot;-&quot; + cacheKey;
 589                     displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 590                 }
 591 
 592                 if (document.getField(categorySortFieldName) == null &amp;&amp; displayOrder != null) {
 593                     document.addField(categorySortFieldName, displayOrder);
 594                 }
 595 
 596                 // This is the entire tree of every category defined on the product
 597                 buildFullCategoryHierarchy(document, cache, categoryId, new HashSet&lt;Long&gt;());
 598             }
 599         }
 600     }
 601 
 602     /**
 603      * Walk the category hierarchy upwards, adding a field for each level to the solr document
 604      *
 605      * @param document the solr document for the product
 606      * @param cache the catalog structure cache
 607      * @param categoryId the current category id
 608      */
<abbr title=" 609     protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long categoryId, Set&lt;Long&gt; indexedParents) {"> 609     protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long caðŸ”µ</abbr>
 610         Long catIdToAdd = shs.getCategoryId(categoryId);
 611 
 612         Collection&lt;Object&gt; existingValues = document.getFieldValues(shs.getCategoryFieldName());
 613         if (existingValues == null || !existingValues.contains(catIdToAdd)) {
 614             document.addField(shs.getCategoryFieldName(), catIdToAdd);
 615         }
 616 
 617         Set&lt;Long&gt; parents = cache.getParentCategoriesByCategory().get(categoryId);
 618         for (Long parent : parents) {
 619             if (!indexedParents.contains(parent)) {
 620                 indexedParents.add(parent);
 621                 buildFullCategoryHierarchy(document, cache, parent, indexedParents);
 622             }
 623         }
 624     }
 625 
 626     /**
<abbr title=" 627      * Returns a map of prefix to value for the requested attributes. For example, if the requested field corresponds to"> 627      * Returns a map of prefix to value for the requested attributes. For example, if the requested fieldðŸ”µ</abbr>
<abbr title=" 628      * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting map could be"> 628      * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting ðŸ”µ</abbr>
 629      *
 630      * { &quot;en_US&quot; : &quot;A description&quot;,
 631      *   &quot;es_ES&quot; : &quot;Una descripcion&quot; }
 632      *
 633      * @param product
 634      * @param sku
 635      * @param field
 636      * @param fieldType
 637      * @param locales
 638      * @return the value of the property
 639      * @throws IllegalAccessException
 640      * @throws InvocationTargetException
 641      * @throws NoSuchMethodException
 642      */
<abbr title=" 643     protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldType, List&lt;Locale&gt; locales)"> 643     protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldTyðŸ”µ</abbr>
 644             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 645 
 646         String propertyName = field.getPropertyName();
 647         Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
 648 
 649         ExtensionResultStatusType extensionResult = ExtensionResultStatusType.NOT_HANDLED;
 650         if (extensionManager != null) {
<abbr title=" 651             extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldType, values, propertyName, locales);"> 651             extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldTypeðŸ”µ</abbr>
 652         }
 653 
 654         if (ExtensionResultStatusType.NOT_HANDLED.equals(extensionResult)) {
 655             Object propertyValue = shs.getPropertyValue(indexedItem, field);
 656             if (propertyValue != null) {
 657                 values.put(&quot;&quot;, propertyValue);
 658             }
 659         }
 660 
 661         return values;
 662     }
 663 
 664     /**
<abbr title=" 665      * Converts a propertyName to one that is able to reference inside a map. For example, consider the property"> 665      * Converts a propertyName to one that is able to reference inside a map. For example, consider the pðŸ”µ</abbr>
<abbr title=" 666      * in Product that references a List&lt;ProductAttribute&gt;, &quot;productAttributes&quot;. Also consider the utility method"> 666      * in Product that references a List&lt;ProductAttribute&gt;, &quot;productAttributes&quot;. Also consider the utilitðŸ”µ</abbr>
<abbr title=" 667      * in Product called &quot;mappedProductAttributes&quot;, which returns a map of the ProductAttributes keyed by the name"> 667      * in Product called &quot;mappedProductAttributes&quot;, which returns a map of the ProductAttributes keyed byðŸ”µ</abbr>
<abbr title=" 668      * property in the ProductAttribute. Given the parameters &quot;productAttributes.heatRange&quot;, &quot;productAttributes&quot;,"> 668      * property in the ProductAttribute. Given the parameters &quot;productAttributes.heatRange&quot;, &quot;productAttrðŸ”µ</abbr>
<abbr title=" 669      * &quot;mappedProductAttributes&quot; (which would represent a property called &quot;productAttributes.heatRange&quot; that"> 669      * &quot;mappedProductAttributes&quot; (which would represent a property called &quot;productAttributes.heatRange&quot; tðŸ”µ</abbr>
<abbr title=" 670      * references a specific ProductAttribute inside of a product whose &quot;name&quot; property is equal to &quot;heatRange&quot;,"> 670      * references a specific ProductAttribute inside of a product whose &quot;name&quot; property is equal to &quot;heatðŸ”µ</abbr>
<abbr title=" 671      * this method will convert this property to mappedProductAttributes(heatRange).value, which is then usable"> 671      * this method will convert this property to mappedProductAttributes(heatRange).value, which is then ðŸ”µ</abbr>
 672      * by the standard beanutils PropertyUtils class to get the value.
 673      *
 674      * @param propertyName
 675      * @param listPropertyName
 676      * @param mapPropertyName
 677      * @return the converted property name
 678      *
 679      * @deprecated see SolrHelperService.getPropertyValue()
 680      */
 681     @Deprecated
<abbr title=" 682     protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropertyName) {"> 682     protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropðŸ”µ</abbr>
 683         String[] splitName = StringUtils.split(propertyName, &quot;\\.&quot;);
 684         StringBuilder convertedProperty = new StringBuilder();
 685         for (int i = 0; i &lt; splitName.length; i++) {
 686             if (convertedProperty.length() &gt; 0) {
 687                 convertedProperty.append(&quot;.&quot;);
 688             }
 689 
 690             if (splitName[i].equals(listPropertyName)) {
 691                 convertedProperty.append(mapPropertyName).append(&quot;(&quot;);
 692                 convertedProperty.append(splitName[i + 1]).append(&quot;).value&quot;);
 693                 i++;
 694             } else {
 695                 convertedProperty.append(splitName[i]);
 696             }
 697         }
 698         return convertedProperty.toString();
 699     }
 700 
 701     @Override
 702     public Object[] saveState() {
 703          return new Object[] {
 704              BroadleafRequestContext.getBroadleafRequestContext(),
 705              SkuPricingConsiderationContext.getSkuPricingConsiderationContext(),
 706              SkuPricingConsiderationContext.getSkuPricingService(),
 707              SkuActiveDateConsiderationContext.getSkuActiveDatesService()
 708          };
 709      }
 710 
 711     @Override
 712     @SuppressWarnings(&quot;rawtypes&quot;)
 713     public void restoreState(Object[] pack) {
 714          BroadleafRequestContext.setBroadleafRequestContext((BroadleafRequestContext) pack[0]);
 715          SkuPricingConsiderationContext.setSkuPricingConsiderationContext((HashMap) pack[1]);
 716          SkuPricingConsiderationContext.setSkuPricingService((DynamicSkuPricingService) pack[2]);
<abbr title=" 717          SkuActiveDateConsiderationContext.setSkuActiveDatesService((DynamicSkuActiveDatesService) pack[3]);"> 717          SkuActiveDateConsiderationContext.setSkuActiveDatesService((DynamicSkuActiveDatesService) pack[3ðŸ”µ</abbr>
 718      }
 719 
 720     @Override
<abbr title=" 721     public void optimizeIndex(String collection, SolrClient server) throws ServiceException, IOException {"> 721     public void optimizeIndex(String collection, SolrClient server) throws ServiceException, IOException ðŸ”µ</abbr>
 722         shs.optimizeIndex(collection, server);
 723     }
 724 
 725     @Override
 726     public void commit(String collection, SolrClient server) throws ServiceException, IOException {
 727         if (this.commit) {
 728             commit(collection, server, this.softCommit, this.waitSearcher, this.waitFlush);
 729         } else if (LOG.isDebugEnabled()) {
<abbr title=" 730             LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoCommit is configured.&quot;);"> 730             LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoComðŸ”µ</abbr>
 731         }
 732     }
 733 
 734     @Override
<abbr title=" 735     public void commit(String collection, SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 735     public void commit(String collection, SolrClient server, boolean softCommit, boolean waitSearcher, boðŸ”µ</abbr>
 736         try {
 737             if (!this.commit) {
<abbr title=" 738                 LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is being forced via the API.&quot;);"> 738                 LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is beingðŸ”µ</abbr>
 739             }
 740             if (LOG.isDebugEnabled()) {
<abbr title=" 741                 LOG.debug(((((&quot;Committing changes to Solr index: softCommit: &quot; + softCommit) + &quot;, waitSearcher: &quot;) + waitSearcher) + &quot;, waitFlush: &quot;) + waitFlush);"> 741                 LOG.debug(((((&quot;Committing changes to Solr index: softCommit: &quot; + softCommit) + &quot;, waitSeaðŸ”µ</abbr>
 742             }
 743             server.commit(collection, waitFlush, waitSearcher, softCommit);
 744         } catch (SolrServerException e) {
 745             throw new ServiceException(&quot;Could not commit changes to Solr index&quot;, e);
 746         }
 747     }
 748 
 749     @Override
 750     public void logDocuments(Collection&lt;SolrInputDocument&gt; documents) {
 751         if (LOG.isTraceEnabled()) {
 752             for (SolrInputDocument document : documents) {
 753                 LOG.trace(document);
 754             }
 755         }
 756     }
 757 
 758     /**
 759      *  We multiply the BigDecimal by 1,000,000 to maintain any possible decimals in use the
 760      *  displayOrder value.
 761      *
 762      * @param cache
 763      * @param displayOrderKey
 764      * @return
 765      */
 766     protected Long convertDisplayOrderToLong(CatalogStructure cache, String displayOrderKey) {
 767         BigDecimal displayOrder = cache.getDisplayOrdersByCategoryProduct().get(displayOrderKey);
 768 
 769         if (displayOrder == null) {
 770             return null;
 771         }
 772 
 773         return displayOrder.multiply(BigDecimal.valueOf(1000000)).longValue();
 774     }
 775 
 776     @Override
 777     public void deleteByQuery(String deleteQuery) throws SolrServerException, IOException {
 778         String productFilter = (shs.getTypeFieldName() + &quot;:&quot;) + shs.getPrimaryDocumentType();
<abbr title=" 779         // transform the deleteQuery to include the productFilter, this is necessary to ensure that we don&#x27;t delete non-product documents accidentally"> 779         // transform the deleteQuery to include the productFilter, this is necessary to ensure that we doðŸ”µ</abbr>
 780         deleteQuery = ((productFilter + &quot; AND (&quot;) + deleteQuery) + &quot;)&quot;;
 781         String childDeleteQuery = ((&quot;{!child of=&quot; + productFilter) + &quot;} &quot;) + deleteQuery;
<abbr title=" 782         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), childDeleteQuery);"> 782         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), childDeleðŸ”µ</abbr>
<abbr title=" 783         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), deleteQuery);"> 783         solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), deleteQueðŸ”µ</abbr>
 784         logDeleteQuery(childDeleteQuery);
 785         logDeleteQuery(deleteQuery);
 786     }
 787 
 788     @Override
<abbr title=" 789     public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerException {"> 789     public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerExcepðŸ”µ</abbr>
 790         solrConfiguration.getServer().add(solrConfiguration.getQueryCollectionName(), documents);
 791         logDocuments(documents);
 792     }
 793 
 794     @Override
 795     public void logDeleteQuery(String deleteQuery) {
 796         if (LOG.isDebugEnabled()) {
 797             LOG.debug(&quot;Delete query: &quot; + deleteQuery);
 798         }
 799     }
 800 
 801     @Override
<abbr title=" 802     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 802     public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrðŸ”µ</abbr>
 803         return buildIncrementalIndex(null, indexables, solrServer);
 804     }
 805 
 806     @Override
 807     public void optimizeIndex(SolrClient server) throws ServiceException, IOException {
 808         optimizeIndex(null, server);
 809     }
 810 
 811     @Override
 812     public void commit(SolrClient server) throws ServiceException, IOException {
 813         commit(null, server);
 814     }
 815 
 816     @Override
<abbr title=" 817     public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 817     public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) thðŸ”µ</abbr>
 818         commit(null, server, softCommit, waitSearcher, waitFlush);
 819     }
 820 
 821     @Override
 822     public void deleteAllNamespaceDocuments(SolrClient server) throws ServiceException {
 823         deleteAllNamespaceDocuments(null, server);
 824     }
 825 
 826     @Override
 827     public void deleteAllDocuments(SolrClient server) throws ServiceException {
 828         deleteAllDocuments(null, server);
 829     }
 830 
 831     @Override
 832     public boolean useLegacyIndexer() {
 833         return useLegacySolrIndexer;
 834     }
 835 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Framework
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.core.search.service.solr.index;
  19  
  20  import org.apache.commons.collections.CollectionUtils;
  21  import org.apache.commons.lang3.ObjectUtils;
  22  import org.apache.commons.lang3.StringUtils;
  23  import org.apache.commons.logging.Log;
  24  import org.apache.commons.logging.LogFactory;
  25  import org.apache.solr.client.solrj.SolrClient;
  26  import org.apache.solr.client.solrj.SolrServerException;
  27  import org.apache.solr.common.SolrInputDocument;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.solr.common.SolrInputField;</span>
  29  import org.broadleafcommerce.common.exception.ExceptionHelper;
  30  import org.broadleafcommerce.common.exception.ServiceException;
  31  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  32  import org.broadleafcommerce.common.locale.domain.Locale;
  33  import org.broadleafcommerce.common.locale.service.LocaleService;
  34  import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  35  import org.broadleafcommerce.common.site.domain.Catalog;
  36  import org.broadleafcommerce.common.util.BLCCollectionUtils;
  37  import org.broadleafcommerce.common.util.StopWatch;
  38  import org.broadleafcommerce.common.util.StringUtil;
  39  import org.broadleafcommerce.common.util.TransactionUtils;
  40  import org.broadleafcommerce.common.util.TypedTransformer;
  41  import org.broadleafcommerce.common.web.BroadleafRequestContext;
  42  import org.broadleafcommerce.core.catalog.dao.ProductDao;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  43 -import org.broadleafcommerce.core.catalog.dao.SkuDao;</span>
  44  import org.broadleafcommerce.core.catalog.domain.Indexable;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -import org.broadleafcommerce.core.catalog.domain.ProductBundle;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  46 -import org.broadleafcommerce.core.catalog.domain.Sku;</span>
  47  import org.broadleafcommerce.core.catalog.service.CatalogService;
  48  import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuActiveDatesService;
  49  import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuPricingService;
  50  import org.broadleafcommerce.core.catalog.service.dynamic.SkuActiveDateConsiderationContext;
  51  import org.broadleafcommerce.core.catalog.service.dynamic.SkuPricingConsiderationContext;
  52  import org.broadleafcommerce.core.search.dao.CatalogStructure;
  53  import org.broadleafcommerce.core.search.dao.FieldDao;
  54  import org.broadleafcommerce.core.search.dao.IndexFieldDao;
  55  import org.broadleafcommerce.core.search.dao.SearchFacetDao;
  56  import org.broadleafcommerce.core.search.dao.SolrIndexDao;
  57  import org.broadleafcommerce.core.search.domain.Field;
  58  import org.broadleafcommerce.core.search.domain.FieldEntity;
  59  import org.broadleafcommerce.core.search.domain.IndexField;
  60  import org.broadleafcommerce.core.search.domain.IndexFieldType;
  61  import org.broadleafcommerce.core.search.domain.solr.FieldType;
  62  import org.broadleafcommerce.core.search.service.solr.SolrConfiguration;
  63  import org.broadleafcommerce.core.search.service.solr.SolrHelperService;

  64  import org.springframework.beans.factory.annotation.Autowired;
  65  import org.springframework.beans.factory.annotation.Qualifier;
  66  import org.springframework.beans.factory.annotation.Value;
  67  import org.springframework.stereotype.Service;
  68  import org.springframework.transaction.PlatformTransactionManager;
  69  import org.springframework.transaction.TransactionDefinition;
  70  import org.springframework.transaction.TransactionStatus;
  71  
  72  import java.io.IOException;
  73  import java.lang.reflect.InvocationTargetException;
  74  import java.math.BigDecimal;
  75  import java.util.ArrayList;
  76  import java.util.Collection;
  77  import java.util.HashMap;
  78  import java.util.HashSet;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +import java.util.LinkedHashMap;</span>
  80  import java.util.List;
  81  import java.util.Map;
  82  import java.util.Map.Entry;
  83  import java.util.Set;
  84  
  85  import javax.annotation.Resource;
  86  
  87  
  88  /**
  89   * Responsible for building and rebuilding the Solr index
  90   *
  91   * @author Andre Azzolini (apazzolini)
  92   * @author Jeff Fischer
  93   */
  94  @Service(&quot;blSolrIndexService&quot;)
  95  public class SolrIndexServiceImpl implements SolrIndexService {

  96  
  97      private static final Log LOG = LogFactory.getLog(SolrIndexServiceImpl.class);
  98  
  99      @Qualifier(&quot;blCatalogSolrConfiguration&quot;)
 100      @Autowired(required = false)
 101      protected SolrConfiguration solrConfiguration;
 102  
 103      @Value(&quot;${solr.index.errorOnConcurrentReIndex}&quot;)
 104      protected boolean errorOnConcurrentReIndex = false;
 105  
 106      @Value(&quot;${solr.index.product.pageSize}&quot;)
 107      protected int pageSize;
 108  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -    @Value(&quot;${solr.index.use.sku}&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -    protected boolean useSku;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -</span>
 112      @Value(&quot;${solr.index.commit}&quot;)
 113      protected boolean commit;
 114  
 115      @Value(&quot;${solr.index.softCommit}&quot;)
 116      protected boolean softCommit;
 117  
 118      @Value(&quot;${solr.index.waitSearcher}&quot;)
 119      protected boolean waitSearcher;
 120  
 121      @Value(&quot;${solr.index.waitFlush}&quot;)
 122      protected boolean waitFlush;
 123  



 124      @Resource(name = &quot;blProductDao&quot;)
 125      protected ProductDao productDao;
 126  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -    @Resource(name = &quot;blSkuDao&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -    protected SkuDao skuDao;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -</span>
 130      @Resource(name = &quot;blCatalogService&quot;)
 131      protected CatalogService catalogService;
 132  
 133      @Resource(name = &quot;blFieldDao&quot;)
 134      protected FieldDao fieldDao;
 135  
 136      @Resource(name = &quot;blLocaleService&quot;)
 137      protected LocaleService localeService;
 138  
 139      @Resource(name = &quot;blSolrHelperService&quot;)
 140      protected SolrHelperService shs;
 141  
 142      @Resource(name = &quot;blSolrIndexServiceExtensionManager&quot;)
 143      protected SolrIndexServiceExtensionManager extensionManager;
 144  
 145      @Resource(name = &quot;blTransactionManager&quot;)
 146      protected PlatformTransactionManager transactionManager;
 147  
 148      @Resource(name = &quot;blSolrIndexDao&quot;)
 149      protected SolrIndexDao solrIndexDao;
 150  
 151      @Resource(name = &quot;blSandBoxHelper&quot;)
 152      protected SandBoxHelper sandBoxHelper;
 153  
 154      @Resource(name = &quot;blSearchFacetDao&quot;)
 155      protected SearchFacetDao searchFacetDao;
 156  
 157      @Resource(name = &quot;blIndexFieldDao&quot;)
 158      protected IndexFieldDao indexFieldDao;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +    @Value(value = &quot;${enable.solr.optimize:false}&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +    private boolean optimizeEnabled;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +</span>








 163  
 164      @Override
<abbr title=" 165      public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws ServiceException {"> 165      public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws ServiceExcepðŸ”µ</abbr>
 166          try {
 167              CatalogStructure cache = new CatalogStructure();
 168              SolrIndexCachedOperation.setCache(cache);
 169              cacheOperation.execute();
 170          } finally {
 171              SolrIndexCachedOperation.clearCache();
 172          }
 173      }
 174  
 175      @Override
 176      public void rebuildIndex() throws ServiceException, IOException {
 177          LOG.info(&quot;Rebuilding the entire Solr index...&quot;);
 178          StopWatch s = new StopWatch();
 179  
 180          preBuildIndex();
 181          buildIndex();
 182          postBuildIndex();
 183  
 184          LOG.info(String.format(&quot;Finished building entire Solr index in %s&quot;, s.toLapString()));
 185      }
 186  
 187      @Override
 188      public void preBuildIndex() throws ServiceException {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -        deleteAllNamespaceDocuments(solrConfiguration.getReindexServer());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 190 +        deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 190 +        deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServðŸ”µ</abbr></span>
 191      }
 192  
 193      @Override
 194      public void buildIndex() throws IOException, ServiceException {
 195          executeSolrIndexOperation(getReindexOperation());
 196      }
 197  
 198      @Override
 199      public void postBuildIndex() throws IOException, ServiceException {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -        // this is required to be at the very very very end after rebuilding the whole index</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -        optimizeIndex(solrConfiguration.getReindexServer());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +        if(optimizeEnabled) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +            // this is required to be at the very very very end after rebuilding the whole index</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +            optimizeIndex(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +        }</span>
 206          // Swap the active and the reindex cores
 207          if (!solrConfiguration.isSingleCoreMode()) {
 208              shs.swapActiveCores(solrConfiguration);
 209          }
 210      }
 211  
 212      @Override
 213      public SolrIndexOperation getReindexOperation() {
 214          return new GlobalSolrFullReIndexOperation(this, solrConfiguration, shs, errorOnConcurrentReIndex) {
 215  
 216              @Override
 217              public List&lt;? extends Indexable&gt; readIndexables(int pageSize, Long lastId) {
 218                  return readAllActiveIndexables(pageSize, lastId);
 219              }
 220  
 221              @Override
 222              public Long countIndexables() {
 223                  return countIndexableItems();
 224              }
 225  
 226              @Override
 227              public void buildPage(List&lt;? extends Indexable&gt; indexables) throws ServiceException {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 228 -                buildIncrementalIndex(indexables, getSolrServerForIndexing());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +                buildIncrementalIndex(getSolrCollectionForIndexing(), indexables, getSolrServerForIndexing());</span>
 230              }
 231          };
 232      }
 233  
 234      @Override
<abbr title=" 235      public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOException {"> 235      public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOExceptionðŸ”µ</abbr>
 236          operation.obtainLock();
 237  
 238          try {
 239              LOG.info(&quot;Executing Indexing operation&quot;);
 240              StopWatch s = new StopWatch();
 241  
 242              Object[] pack = saveState();
 243              try {
 244                  final Long numItemsToIndex;
 245                  try {
 246                      operation.beforeCountIndexables();
 247  
 248                      numItemsToIndex = operation.countIndexables();
 249                  } finally {
 250                      operation.afterCountIndexables();
 251                  }
 252  
 253                  if (LOG.isDebugEnabled()) {
 254                      LOG.debug(&quot;There are at most &quot; + numItemsToIndex + &quot; items to index&quot;);
 255                  }
 256                  performCachedOperation(new SolrIndexCachedOperation.CacheOperation() {
 257  
 258                      @Override
 259                      public void execute() throws ServiceException {
 260                          int page = 1;
 261                          Long lastId = null;
 262                          Long remainingNumItemsToIndex = numItemsToIndex;
 263                          Long totalPages = getTotalPageCount(numItemsToIndex);
 264  
 265                          while (remainingNumItemsToIndex &gt; 0) {
 266                              String pageNumberMessage = buildPageNumberMessage(page, totalPages);
 267                              LOG.info(pageNumberMessage);
 268  
 269                              lastId = buildIncrementalIndex(pageSize, lastId, operation);
 270                              remainingNumItemsToIndex -= pageSize;
 271                              page++;
 272                          }
 273                      }
 274                  });
 275  
 276              } finally {
 277                  restoreState(pack);
 278              }
 279  
 280              LOG.info(String.format(&quot;Indexing operation completed in %s&quot;, s.toLapString()));
 281          } finally {
 282              operation.releaseLock();
 283          }
 284      }
 285  
 286      protected long getTotalPageCount(Long numItemsToIndex) {
 287          long numPagesToIndex = numItemsToIndex / pageSize;
 288          boolean hasRemainingItemsToIndex = numItemsToIndex % pageSize != 0;
 289  
 290          return hasRemainingItemsToIndex ? (numPagesToIndex + 1) : numPagesToIndex;
 291      }
 292  
 293      protected String buildPageNumberMessage(int page, Long totalPages) {
 294          String pageNumberMessage = String.format(&quot;Building page number %s of %s&quot;, page, totalPages);
 295  
 296          Catalog currentCatalog = BroadleafRequestContext.getBroadleafRequestContext().getCurrentCatalog();
 297          if (currentCatalog != null) {
 298              pageNumberMessage += String.format(&quot; for catalog: %s&quot;, currentCatalog.getName());
 299          }
 300  
 301          return pageNumberMessage;
 302      }
 303  
 304      /**
 305       * @return
 306       */
 307      protected Long countIndexableItems() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -        if (useSku) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 309 -            return skuDao.readCountAllActiveSkus();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 310 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 311 -            return productDao.readCountAllActiveProducts();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 312 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +        return productDao.readCountAllActiveProducts();</span>
 314      }
 315  
 316      /**
 317       * &lt;p&gt;
 318       * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 319       *
 320       * @throws ServiceException if there was a problem removing the documents
 321       * @deprecated use {@link #deleteAllReindexCoreDocuments()} instead
 322       */
 323      @Deprecated
 324      protected void deleteAllDocuments() throws ServiceException {
 325          deleteAllReindexCoreDocuments();
 326      }
 327  
 328      /**
 329       * &lt;p&gt;
 330       * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 331       *
 332       * @throws ServiceException if there was a problem removing the documents
 333       */
 334      protected void deleteAllReindexCoreDocuments() throws ServiceException {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 335 -        deleteAllNamespaceDocuments(solrConfiguration.getReindexServer());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 336 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 337 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 338 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 339 -    public void deleteAllNamespaceDocuments(SolrClient server) throws ServiceException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 340 +        deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServer());"> 340 +        deleteAllNamespaceDocuments(solrConfiguration.getReindexCollectionName(), solrConfiguration.getReindexServðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 344 +    public void deleteAllNamespaceDocuments(String collection, SolrClient server) throws ServiceException {</span>
 345          try {
 346              String deleteQuery = StringUtil.sanitize(shs.getNamespaceFieldName()) + &quot;:(\&quot;&quot;
 347                      + StringUtil.sanitize(solrConfiguration.getNamespace()) + &quot;\&quot;)&quot;;
 348              LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 349 -            server.deleteByQuery(deleteQuery);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +            server.deleteByQuery(collection, deleteQuery);</span>
 351  
 352              //Explicitly do a hard commit here since we just deleted the entire index
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 353 -            server.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +            server.commit(collection);</span>
 355          } catch (Exception e) {
 356              if (ServiceException.class.isAssignableFrom(e.getClass())) {
 357                  throw (ServiceException) e;
 358              }
 359              throw new ServiceException(&quot;Could not delete documents&quot;, e);
 360          }
 361      }
 362  
 363      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -    public void deleteAllDocuments(SolrClient server) throws ServiceException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +    public void deleteAllDocuments(String collection, SolrClient server) throws ServiceException {</span>
 366          try {
 367              String deleteQuery = &quot;*:*&quot;;
 368              LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 369 -            server.deleteByQuery(deleteQuery);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 370 -            server.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 371 +            server.deleteByQuery(collection, deleteQuery);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +            server.commit(collection);</span>
 373          } catch (Exception e) {
 374              throw new ServiceException(&quot;Could not delete documents&quot;, e);
 375          }
 376      }
 377  
<abbr title=" 378      protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ServiceException {"> 378      protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ServiceExðŸ”µ</abbr>
 379          TransactionStatus status = TransactionUtils.createTransaction(&quot;readItemsToIndex&quot;,
 380              TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 381          if (SolrIndexCachedOperation.getCache() == null) {
 382              LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 383                      &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 383                      &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;ðŸ”µ</abbr>
 384          }
 385          Long response = null;
 386          try {
 387              List&lt;? extends Indexable&gt; indexables;
 388              try {
 389                  operation.beforeReadIndexables();
 390                  indexables = operation.readIndexables(pageSize, lastId);
 391                  if (CollectionUtils.isNotEmpty(indexables)) {
 392                      response = indexables.get(indexables.size()-1).getId();
 393                  }
 394              } finally {
 395                  operation.afterReadIndexables();
 396              }
 397  
 398              try {
 399                  operation.beforeBuildPage();
 400  
 401                  operation.buildPage(indexables);
 402              } finally {
 403                  operation.afterBuildPage();
 404              }
 405  
 406  
 407              TransactionUtils.finalizeTransaction(status, transactionManager, false);
 408          } catch (RuntimeException e) {
 409              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 410              throw e;
 411          }
 412          return response;
 413      }
 414  
 415      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 416 -    public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 416 -    public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient soðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 417 +    public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(String collection, List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 417 +    public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(String collection, List&lt;? extends Indexable&gt; indexaðŸ”µ</abbr></span>
 418          TransactionStatus status = TransactionUtils.createTransaction(&quot;executeIncrementalIndex&quot;,
 419                  TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 420          if (SolrIndexCachedOperation.getCache() == null) {
 421              LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 422                      &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 422                      &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;ðŸ”µ</abbr>
 423          }
 424  
 425          if (LOG.isDebugEnabled()) {
 426              LOG.debug(String.format(&quot;Building incremental product index - pageSize: [%s]...&quot;, indexables.size()));
 427          }
 428  
 429          StopWatch s = new StopWatch();
 430          try {
 431              sandBoxHelper.ignoreCloneCache(true);
 432              extensionManager.getProxy().startBatchEvent(indexables);
 433              Collection&lt;SolrInputDocument&gt; documents = new ArrayList&lt;&gt;();
 434              List&lt;Locale&gt; locales = getAllLocales();
 435  
 436              List&lt;Long&gt; productIds = BLCCollectionUtils.collectList(indexables, new TypedTransformer&lt;Long&gt;() {
 437                  @Override
 438                  public Long transform(Object input) {
 439                      return shs.getCurrentProductId((Indexable) input);
 440                  }
 441              });
 442  
 443              solrIndexDao.populateProductCatalogStructure(productIds, SolrIndexCachedOperation.getCache());
 444  
 445              List&lt;IndexField&gt; fields = null;
 446              FieldEntity currentFieldType = null;
 447              for (Indexable indexable : indexables) {
 448                  if (fields == null || ObjectUtils.notEqual(currentFieldType, indexable.getFieldEntityType())) {
 449                      fields = indexFieldDao.readFieldsByEntityType(indexable.getFieldEntityType());
 450                  }
 451  
 452                  SolrInputDocument doc = buildDocument(indexable, fields, locales);
 453                  //If someone overrides the buildDocument method and determines that they don&#x27;t want a product
 454                  //indexed, then they can return null. If the document is null it does not get added to
 455                  //to the index.
 456                  if (doc != null) {
 457                      documents.add(doc);
 458                  }
 459              }
 460  
 461              extensionManager.getProxy().modifyBuiltDocuments(documents, indexables, fields, locales);
 462  
 463              logDocuments(documents);
 464  
 465              if (!CollectionUtils.isEmpty(documents) &amp;&amp; solrServer != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 466 -                solrServer.add(documents);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 467 -                commit(solrServer);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +                solrServer.add(collection, documents);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +                commit(collection, solrServer);</span>
 470              }
 471              TransactionUtils.finalizeTransaction(status, transactionManager, false);
 472  
 473              if (LOG.isDebugEnabled()) {
<abbr title=" 474                  LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexables.size(), s.toLapString()));"> 474                  LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexables.sizðŸ”µ</abbr>
 475              }
 476  
 477              return documents;
 478          } catch (SolrServerException e) {
 479              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 480              throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 481          } catch (IOException e) {
 482              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 483              throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 484          } catch (RuntimeException e) {
 485              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 486              throw e;
 487          } finally {
 488              extensionManager.getProxy().endBatchEvent(indexables);
 489              sandBoxHelper.ignoreCloneCache(false);
 490          }
 491      }
 492  
 493      protected List&lt;? extends Indexable&gt; readAllActiveIndexables(int pageSize, Long lastId) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 494 -        if (useSku) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 495 -            List&lt;Sku&gt; skus = skuDao.readAllActiveSkus(pageSize, lastId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 496 -            return filterIndexableSkus(skus);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 498 -            return productDao.readAllActiveProducts(pageSize, lastId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 499 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 500 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 502 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 503 -    public List&lt;Sku&gt; filterIndexableSkus(List&lt;Sku&gt; skus) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 504 -        ArrayList&lt;Sku&gt; skusToIndex = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 505 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 506 -        if (CollectionUtils.isNotEmpty(skus)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 507 -            for (Sku sku : skus) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 508 -                //If the sku is not active, don&#x27;t index it...</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 509 -                if (!sku.isActive()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 510 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 511 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 512 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 513 -                //If this is the default sku and the product has product options</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 514 -                //and is not allowed to be sold without product options</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 515 -                if (sku.getDefaultProduct() != null</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 516 -                        &amp;&amp; !sku.getProduct().getCanSellWithoutOptions()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 517 -                        &amp;&amp; !sku.getProduct().getAdditionalSkus().isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 518 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 519 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 520 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 521 -                if (sku.getDefaultProduct() instanceof ProductBundle) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 524 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 525 -                skusToIndex.add(sku);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 526 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 527 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 528 -        return skusToIndex;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 529 +        return productDao.readAllActiveProducts(pageSize, lastId);</span>
 530      }
 531  
 532      @Override
 533      public List&lt;Locale&gt; getAllLocales() {
 534          List&lt;Locale&gt; allLocales = localeService.findAllLocales();
 535          Map&lt;String, Locale&gt; processedLocales = new HashMap&lt;&gt;();
 536          // Optimize the list of locales we are looking at. If I have an &#x27;en&#x27; and &#x27;en_US&#x27; in the locale set and I&#x27;m
 537          // not using the country code to index the values, then I only need to index the locale &#x27;en&#x27;
 538          for (Locale locale : allLocales) {
 539              String localeCode = locale.getLocaleCode();
 540              int underscoreLocation = localeCode.indexOf(&quot;_&quot;);
 541              if (underscoreLocation &gt; 0 &amp;&amp; Boolean.FALSE.equals(locale.getUseCountryInSearchIndex())) {
 542                  String localeCodeWithoutCountry = localeCode.substring(0, underscoreLocation);
 543                  if (!processedLocales.containsKey(localeCodeWithoutCountry)) {
 544                      processedLocales.put(localeCodeWithoutCountry, locale);
 545                  }
 546              } else {
 547                  processedLocales.put(locale.getLocaleCode(), locale);
 548              }
 549          }
 550          return new ArrayList&lt;&gt;(processedLocales.values());
 551      }
 552  
 553      @Override
<abbr title=" 554      public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 554      public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; localeðŸ”µ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -        final SolrInputDocument document = new SolrInputDocument();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 556 +        final SolrInputDocument document = new SolrInputDocument(new LinkedHashMap&lt;String,SolrInputField&gt;());</span>
 557  
 558          attachBasicDocumentFields(indexable, document);
 559  
 560          attachIndexableDocumentFields(document, indexable, fields, locales);
 561  
 562          attachAdditionalDocumentFields(indexable, document);
 563  
 564          extensionManager.getProxy().attachChildDocuments(indexable, document, fields, locales);
 565  
 566          return document;
 567      }
 568  
 569      @Override
<abbr title=" 570      public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 570      public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexField&gt; fiðŸ”µ</abbr>
 571          for (IndexField indexField : fields) {
 572              try {
 573                  // If we find an IndexField entry for this field, then we need to store it in the index
 574                  if (indexField != null) {
 575                      List&lt;IndexFieldType&gt; searchableFieldTypes = indexField.getFieldTypes();
 576  
<abbr title=" 577                      // For each of its search field types, get the property values, and add a field to the document for each property value"> 577                      // For each of its search field types, get the property values, and add a field to the documenðŸ”µ</abbr>
 578                      for (IndexFieldType sft : searchableFieldTypes) {
 579                          FieldType fieldType = sft.getFieldType();
<abbr title=" 580                          Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getField(), fieldType, locales);"> 580                          Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getField(), fðŸ”µ</abbr>
 581  
<abbr title=" 582                          ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentForIndexField(document, indexField, fieldType, propertyValues);"> 582                          ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentForIndexFieðŸ”µ</abbr>
 583  
 584                          if (ExtensionResultStatusType.NOT_HANDLED.equals(result)) {
 585                              // Build out the field for every prefix
 586                              for (Entry&lt;String, Object&gt; entry : propertyValues.entrySet()) {
 587                                  String prefix = entry.getKey();
 588                                  prefix = StringUtils.isBlank(prefix) ? prefix : prefix + &quot;_&quot;;
 589  
<abbr title=" 590                                  String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fieldType, prefix);"> 590                                  String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fieldType, ðŸ”µ</abbr>
 591                                  Object value = entry.getValue();
 592  
 593                                  if (FieldType.isMultiValued(fieldType)) {
 594                                      document.addField(solrPropertyName, value);
 595                                  } else {
 596                                      document.setField(solrPropertyName, value);
 597                                  }
 598                              }
 599                          }
 600                      }
 601                  }
 602  
 603              } catch (Exception e) {
<abbr title=" 604                  LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldName() + &quot;] for product id[&quot;"> 604                  LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldName() + &quot;]ðŸ”µ</abbr>
 605                          + indexable.getId() + &quot;]&quot;, e);
 606                  throw ExceptionHelper.refineException(e);
 607              }
 608          }
 609      }
 610  
 611      /**
 612       * Implementors can extend this and override this method to add additional fields to the Solr document.
 613       *
 614       * @param sku
 615       * @param document
 616       */
 617      protected void attachAdditionalDocumentFields(Indexable indexable, SolrInputDocument document) {
 618          //Empty implementation. Placeholder for others to extend and add additional fields
 619          extensionManager.getProxy().attachAdditionalDocumentFields(indexable, document);
 620      }
 621  
 622      protected void attachBasicDocumentFields(Indexable indexable, SolrInputDocument document) {
 623          CatalogStructure cache = SolrIndexCachedOperation.getCache();
 624          if (cache == null) {
 625              String msg = &quot;SolrIndexService.performCachedOperation() must be used in conjuction with&quot;
<abbr title=" 626                  + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog documents or should&quot;"> 626                  + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog documents oðŸ”µ</abbr>
 627                  + &quot; be invoked from buildIncrementalIndex()&quot;;
 628              LOG.error(msg);
 629              throw new IllegalStateException(msg);
 630          }
 631  
 632          // Add the namespace and ID fields for this product
 633          document.addField(shs.getNamespaceFieldName(), solrConfiguration.getNamespace());
 634          document.addField(shs.getIdFieldName(), shs.getSolrDocumentId(document, indexable));
 635          document.addField(shs.getTypeFieldName(), shs.getDocumentType(indexable));
 636          document.addField(shs.getIndexableIdFieldName(), shs.getIndexableId(indexable));
 637  
 638          extensionManager.getProxy().attachAdditionalBasicFields(indexable, document, shs);
 639  
 640          Long cacheKey = this.shs.getCurrentProductId(indexable); // current
 641          if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 642              cacheKey = sandBoxHelper.getOriginalId(cacheKey); // parent
 643              if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 644                  cacheKey = shs.getIndexableId(indexable); // master
 645              }
 646          }
 647  
 648          // TODO: figure this out more generally; this doesn&#x27;t work for CMS content
 649          // The explicit categories are the ones defined by the product itself
 650          if (cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 651              for (Long categoryId : cache.getParentCategoriesByProduct().get(cacheKey)) {
 652                  document.addField(shs.getExplicitCategoryFieldName(), shs.getCategoryId(categoryId));
 653  
 654                  // Make sure that we&#x27;re always referencing the parent for the sort field
 655                  String categorySortFieldName = shs.getCategorySortFieldName(shs.getCategoryId(categoryId));
<abbr title=" 656                  // The issue here was the super category id is always what is stored in the cache, while the category"> 656                  // The issue here was the super category id is always what is stored in the cache, while the categðŸ”µ</abbr>
<abbr title=" 657                  // by product id is the overridden versions. Need to always look at parent version for cache stuff, which"> 657                  // by product id is the overridden versions. Need to always look at parent version for cache stuffðŸ”µ</abbr>
 658                  // is given from shs.getCategoryId
 659                  // First try the current level
 660                  String displayOrderKey = categoryId + &quot;-&quot; + cacheKey;
 661                  Long displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 662                  if (displayOrder == null) {
 663                      // Didn&#x27;t find the cache at the current level, this might be an override so look upwards
 664                      displayOrderKey = shs.getCategoryId(categoryId) + &quot;-&quot; + cacheKey;
 665                      displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 666                  }
 667  
 668                  if (document.getField(categorySortFieldName) == null &amp;&amp; displayOrder != null) {
 669                      document.addField(categorySortFieldName, displayOrder);
 670                  }
 671  
 672                  // This is the entire tree of every category defined on the product
 673                  buildFullCategoryHierarchy(document, cache, categoryId, new HashSet&lt;Long&gt;());
 674              }
 675          }
 676      }
 677  
 678      /**
 679       * Walk the category hierarchy upwards, adding a field for each level to the solr document
 680       *
 681       * @param document the solr document for the product
 682       * @param cache the catalog structure cache
 683       * @param categoryId the current category id
 684       */
<abbr title=" 685      protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long categoryId, Set&lt;Long&gt; indexedParents) {"> 685      protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long categoryId,ðŸ”µ</abbr>
 686          Long catIdToAdd = shs.getCategoryId(categoryId);
 687  
 688          Collection&lt;Object&gt; existingValues = document.getFieldValues(shs.getCategoryFieldName());
 689          if (existingValues == null || !existingValues.contains(catIdToAdd)) {
 690              document.addField(shs.getCategoryFieldName(), catIdToAdd);
 691          }
 692  
 693          Set&lt;Long&gt; parents = cache.getParentCategoriesByCategory().get(categoryId);
 694          for (Long parent : parents) {
 695              if (!indexedParents.contains(parent)) {
 696                  indexedParents.add(parent);
 697                  buildFullCategoryHierarchy(document, cache, parent, indexedParents);
 698              }
 699          }
 700      }
 701  
 702      /**
<abbr title=" 703       * Returns a map of prefix to value for the requested attributes. For example, if the requested field corresponds to"> 703       * Returns a map of prefix to value for the requested attributes. For example, if the requested field correspoðŸ”µ</abbr>
<abbr title=" 704       * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting map could be"> 704       * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting map couldðŸ”µ</abbr>
 705       *
 706       * { &quot;en_US&quot; : &quot;A description&quot;,
 707       *   &quot;es_ES&quot; : &quot;Una descripcion&quot; }
 708       *
 709       * @param product
 710       * @param sku
 711       * @param field
 712       * @param fieldType
 713       * @param locales
 714       * @return the value of the property
 715       * @throws IllegalAccessException
 716       * @throws InvocationTargetException
 717       * @throws NoSuchMethodException
 718       */
<abbr title=" 719      protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldType, List&lt;Locale&gt; locales)"> 719      protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldType, List&lt;ðŸ”µ</abbr>
 720              throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 721  
 722          String propertyName = field.getPropertyName();
 723          Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
 724  
 725          ExtensionResultStatusType extensionResult = ExtensionResultStatusType.NOT_HANDLED;
 726          if (extensionManager != null) {
<abbr title=" 727              extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldType, values, propertyName, locales);"> 727              extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldType, values,ðŸ”µ</abbr>
 728          }
 729  
 730          if (ExtensionResultStatusType.NOT_HANDLED.equals(extensionResult)) {
 731              Object propertyValue = shs.getPropertyValue(indexedItem, field);
 732              if (propertyValue != null) {
 733                  values.put(&quot;&quot;, propertyValue);
 734              }
 735          }
 736  
 737          return values;
 738      }
 739  
 740      /**
 741       * Converts a propertyName to one that is able to reference inside a map. For example, consider the property
 742       * in Product that references a List&lt;ProductAttribute&gt;, &quot;productAttributes&quot;. Also consider the utility method
 743       * in Product called &quot;mappedProductAttributes&quot;, which returns a map of the ProductAttributes keyed by the name
 744       * property in the ProductAttribute. Given the parameters &quot;productAttributes.heatRange&quot;, &quot;productAttributes&quot;,
 745       * &quot;mappedProductAttributes&quot; (which would represent a property called &quot;productAttributes.heatRange&quot; that
 746       * references a specific ProductAttribute inside of a product whose &quot;name&quot; property is equal to &quot;heatRange&quot;,
 747       * this method will convert this property to mappedProductAttributes(heatRange).value, which is then usable
 748       * by the standard beanutils PropertyUtils class to get the value.
 749       *
 750       * @param propertyName
 751       * @param listPropertyName
 752       * @param mapPropertyName
 753       * @return the converted property name
 754       *
 755       * @deprecated see SolrHelperService.getPropertyValue()
 756       */
 757      @Deprecated
<abbr title=" 758      protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropertyName) {"> 758      protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropertyName)ðŸ”µ</abbr>
 759          String[] splitName = StringUtils.split(propertyName, &quot;\\.&quot;);
 760          StringBuilder convertedProperty = new StringBuilder();
 761          for (int i = 0; i &lt; splitName.length; i++) {
 762              if (convertedProperty.length() &gt; 0) {
 763                  convertedProperty.append(&quot;.&quot;);
 764              }
 765  
 766              if (splitName[i].equals(listPropertyName)) {
 767                  convertedProperty.append(mapPropertyName).append(&quot;(&quot;);
 768                  convertedProperty.append(splitName[i + 1]).append(&quot;).value&quot;);
 769                  i++;
 770              } else {
 771                  convertedProperty.append(splitName[i]);
 772              }
 773          }
 774          return convertedProperty.toString();
 775      }
 776  
 777      @Override
 778      public Object[] saveState() {
 779           return new Object[] {
 780               BroadleafRequestContext.getBroadleafRequestContext(),
 781               SkuPricingConsiderationContext.getSkuPricingConsiderationContext(),
 782               SkuPricingConsiderationContext.getSkuPricingService(),
 783               SkuActiveDateConsiderationContext.getSkuActiveDatesService()
 784           };
 785       }
 786  
 787      @Override
 788      @SuppressWarnings(&quot;rawtypes&quot;)
 789      public void restoreState(Object[] pack) {
 790           BroadleafRequestContext.setBroadleafRequestContext((BroadleafRequestContext) pack[0]);
 791           SkuPricingConsiderationContext.setSkuPricingConsiderationContext((HashMap) pack[1]);
 792           SkuPricingConsiderationContext.setSkuPricingService((DynamicSkuPricingService) pack[2]);
 793           SkuActiveDateConsiderationContext.setSkuActiveDatesService((DynamicSkuActiveDatesService) pack[3]);
 794       }
 795  
 796      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 797 -    public void optimizeIndex(SolrClient server) throws ServiceException, IOException {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 798 -        shs.optimizeIndex(server);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 799 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 800 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 801 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 802 -    public void commit(SolrClient server) throws ServiceException, IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 803 +    public void optimizeIndex(String collection, SolrClient server) throws ServiceException, IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 804 +        shs.optimizeIndex(collection, server);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 805 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 806 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 807 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 808 +    public void commit(String collection, SolrClient server) throws ServiceException, IOException {</span>
 809          if (this.commit) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 810 -            commit(server, this.softCommit, this.waitSearcher, this.waitFlush);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 811 +            commit(collection, server, this.softCommit, this.waitSearcher, this.waitFlush);</span>
 812          } else if (LOG.isDebugEnabled()) {
<abbr title=" 813              LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoCommit is configured.&quot;);"> 813              LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoCommit is coðŸ”µ</abbr>
 814          }
 815      }
 816  
 817      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 818 -    public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 818 -    public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 819 +    public void commit(String collection, SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 819 +    public void commit(String collection, SolrClient server, boolean softCommit, boolean waitSearcher, boolean waiðŸ”µ</abbr></span>
 820          try {
 821              if (!this.commit) {
<abbr title=" 822                  LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is being forced via the API.&quot;);"> 822                  LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is being forced vðŸ”µ</abbr>
 823              }
 824  
 825              if (LOG.isDebugEnabled()) {
 826                  LOG.debug(&quot;Committing changes to Solr index: softCommit: &quot; + softCommit
 827                          + &quot;, waitSearcher: &quot; + waitSearcher + &quot;, waitFlush: &quot; + waitFlush);
 828              }
 829  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 830 -            server.commit(waitFlush, waitSearcher, softCommit);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 831 +            server.commit(collection, waitFlush, waitSearcher, softCommit);</span>
 832          } catch (SolrServerException e) {
 833              throw new ServiceException(&quot;Could not commit changes to Solr index&quot;, e);
 834          }
 835      }
 836  
 837      @Override
 838      public void logDocuments(Collection&lt;SolrInputDocument&gt; documents) {
 839          if (LOG.isTraceEnabled()) {
 840              for (SolrInputDocument document : documents) {
 841                  LOG.trace(document);
 842              }
 843          }
 844      }
 845  
 846      /**
 847       *  We multiply the BigDecimal by 1,000,000 to maintain any possible decimals in use the
 848       *  displayOrder value.
 849       *
 850       * @param cache
 851       * @param displayOrderKey
 852       * @return
 853       */
 854      protected Long convertDisplayOrderToLong(CatalogStructure cache, String displayOrderKey) {
 855          BigDecimal displayOrder = cache.getDisplayOrdersByCategoryProduct().get(displayOrderKey);
 856  
 857          if (displayOrder == null) {
 858              return null;
 859          }
 860  
 861          return displayOrder.multiply(BigDecimal.valueOf(1000000)).longValue();
 862      }
 863  
 864      @Override
 865      public void deleteByQuery(String deleteQuery) throws SolrServerException, IOException {
 866          String productFilter = shs.getTypeFieldName() + &quot;:&quot; + shs.getPrimaryDocumentType();
 867  
<abbr title=" 868          // transform the deleteQuery to include the productFilter, this is necessary to ensure that we don&#x27;t delete non-product documents accidentally"> 868          // transform the deleteQuery to include the productFilter, this is necessary to ensure that we don&#x27;t deletðŸ”µ</abbr>
 869          deleteQuery = productFilter + &quot; AND (&quot; + deleteQuery + &quot;)&quot;;
 870  
 871          String childDeleteQuery = &quot;{!child of=&quot; + productFilter + &quot;} &quot; + deleteQuery;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 872 -        solrConfiguration.getServer().deleteByQuery(childDeleteQuery);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 873 -        solrConfiguration.getServer().deleteByQuery(deleteQuery);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 874 +        solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), childDeleteQuery);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 875 +        solrConfiguration.getServer().deleteByQuery(solrConfiguration.getQueryCollectionName(), deleteQuery);</span>
 876  
 877          logDeleteQuery(childDeleteQuery);
 878          logDeleteQuery(deleteQuery);
 879      }
 880  
 881      @Override
 882      public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerException {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 883 -        solrConfiguration.getServer().add(documents);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 884 +        solrConfiguration.getServer().add(solrConfiguration.getQueryCollectionName(), documents);</span>
 885          logDocuments(documents);
 886      }
 887  
 888      @Override
 889      public void logDeleteQuery(String deleteQuery) {
 890          if (LOG.isDebugEnabled()) {
 891              LOG.debug(&quot;Delete query: &quot; + deleteQuery);
 892          }
 893      }
 894  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 895 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 896 +    public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 896 +    public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient soðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 897 +        return buildIncrementalIndex(null, indexables, solrServer);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 898 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 899 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 900 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 901 +    public void optimizeIndex(SolrClient server) throws ServiceException, IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 902 +        optimizeIndex(null, server);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 903 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 904 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 905 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 906 +    public void commit(SolrClient server) throws ServiceException, IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 907 +        commit(null, server);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 908 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 911 +    public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 911 +    public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 912 +        commit(null, server, softCommit, waitSearcher, waitFlush);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 913 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 914 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 915 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +    public void deleteAllNamespaceDocuments(SolrClient server) throws ServiceException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 917 +        deleteAllNamespaceDocuments(null, server);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 918 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 919 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 920 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 921 +    public void deleteAllDocuments(SolrClient server) throws ServiceException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 922 +        deleteAllDocuments(null, server);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 923 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +</span>
 925  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Framework
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.core.search.service.solr.index;
  19  
  20  import org.apache.commons.collections.CollectionUtils;
  21  import org.apache.commons.lang3.ObjectUtils;
  22  import org.apache.commons.lang3.StringUtils;
  23  import org.apache.commons.logging.Log;
  24  import org.apache.commons.logging.LogFactory;
  25  import org.apache.solr.client.solrj.SolrClient;
  26  import org.apache.solr.client.solrj.SolrServerException;
  27  import org.apache.solr.common.SolrInputDocument;

  28  import org.broadleafcommerce.common.exception.ExceptionHelper;
  29  import org.broadleafcommerce.common.exception.ServiceException;
  30  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  31  import org.broadleafcommerce.common.locale.domain.Locale;
  32  import org.broadleafcommerce.common.locale.service.LocaleService;
  33  import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  34  import org.broadleafcommerce.common.site.domain.Catalog;
  35  import org.broadleafcommerce.common.util.BLCCollectionUtils;
  36  import org.broadleafcommerce.common.util.StopWatch;
  37  import org.broadleafcommerce.common.util.StringUtil;
  38  import org.broadleafcommerce.common.util.TransactionUtils;
  39  import org.broadleafcommerce.common.util.TypedTransformer;
  40  import org.broadleafcommerce.common.web.BroadleafRequestContext;
  41  import org.broadleafcommerce.core.catalog.dao.ProductDao;
  42  import org.broadleafcommerce.core.catalog.dao.SkuDao;
  43  import org.broadleafcommerce.core.catalog.domain.Indexable;
  44  import org.broadleafcommerce.core.catalog.domain.ProductBundle;
  45  import org.broadleafcommerce.core.catalog.domain.Sku;
  46  import org.broadleafcommerce.core.catalog.service.CatalogService;
  47  import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuActiveDatesService;
  48  import org.broadleafcommerce.core.catalog.service.dynamic.DynamicSkuPricingService;
  49  import org.broadleafcommerce.core.catalog.service.dynamic.SkuActiveDateConsiderationContext;
  50  import org.broadleafcommerce.core.catalog.service.dynamic.SkuPricingConsiderationContext;
  51  import org.broadleafcommerce.core.search.dao.CatalogStructure;
  52  import org.broadleafcommerce.core.search.dao.FieldDao;
  53  import org.broadleafcommerce.core.search.dao.IndexFieldDao;
  54  import org.broadleafcommerce.core.search.dao.SearchFacetDao;
  55  import org.broadleafcommerce.core.search.dao.SolrIndexDao;
  56  import org.broadleafcommerce.core.search.domain.Field;
  57  import org.broadleafcommerce.core.search.domain.FieldEntity;
  58  import org.broadleafcommerce.core.search.domain.IndexField;
  59  import org.broadleafcommerce.core.search.domain.IndexFieldType;
  60  import org.broadleafcommerce.core.search.domain.solr.FieldType;
  61  import org.broadleafcommerce.core.search.service.solr.SolrConfiguration;
  62  import org.broadleafcommerce.core.search.service.solr.SolrHelperService;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import org.springframework.beans.factory.InitializingBean;</span>
  64  import org.springframework.beans.factory.annotation.Autowired;
  65  import org.springframework.beans.factory.annotation.Qualifier;
  66  import org.springframework.beans.factory.annotation.Value;
  67  import org.springframework.stereotype.Service;
  68  import org.springframework.transaction.PlatformTransactionManager;
  69  import org.springframework.transaction.TransactionDefinition;
  70  import org.springframework.transaction.TransactionStatus;
  71  
  72  import java.io.IOException;
  73  import java.lang.reflect.InvocationTargetException;
  74  import java.math.BigDecimal;
  75  import java.util.ArrayList;
  76  import java.util.Collection;
  77  import java.util.HashMap;
  78  import java.util.HashSet;

  79  import java.util.List;
  80  import java.util.Map;
  81  import java.util.Map.Entry;
  82  import java.util.Set;
  83  
  84  import javax.annotation.Resource;
  85  
  86  
  87  /**
  88   * Responsible for building and rebuilding the Solr index
  89   *
  90   * @author Andre Azzolini (apazzolini)
  91   * @author Jeff Fischer
  92   */
  93  @Service(&quot;blSolrIndexService&quot;)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -public class SolrIndexServiceImpl implements SolrIndexService {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +public class SolrIndexServiceImpl implements SolrIndexService, InitializingBean {</span>
  96  
  97      private static final Log LOG = LogFactory.getLog(SolrIndexServiceImpl.class);
  98  
  99      @Qualifier(&quot;blCatalogSolrConfiguration&quot;)
 100      @Autowired(required = false)
 101      protected SolrConfiguration solrConfiguration;
 102  
 103      @Value(&quot;${solr.index.errorOnConcurrentReIndex}&quot;)
 104      protected boolean errorOnConcurrentReIndex = false;
 105  
 106      @Value(&quot;${solr.index.product.pageSize}&quot;)
 107      protected int pageSize;
 108  
 109      @Value(&quot;${solr.index.use.sku}&quot;)
 110      protected boolean useSku;
 111  
 112      @Value(&quot;${solr.index.commit}&quot;)
 113      protected boolean commit;
 114  
 115      @Value(&quot;${solr.index.softCommit}&quot;)
 116      protected boolean softCommit;
 117  
 118      @Value(&quot;${solr.index.waitSearcher}&quot;)
 119      protected boolean waitSearcher;
 120  
 121      @Value(&quot;${solr.index.waitFlush}&quot;)
 122      protected boolean waitFlush;
 123  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +    @Value(value = &quot;${solr.catalog.useLegacySolrIndexer:true}&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +    protected boolean useLegacySolrIndexer = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +</span>
 127      @Resource(name = &quot;blProductDao&quot;)
 128      protected ProductDao productDao;
 129  
 130      @Resource(name = &quot;blSkuDao&quot;)
 131      protected SkuDao skuDao;
 132  
 133      @Resource(name = &quot;blCatalogService&quot;)
 134      protected CatalogService catalogService;
 135  
 136      @Resource(name = &quot;blFieldDao&quot;)
 137      protected FieldDao fieldDao;
 138  
 139      @Resource(name = &quot;blLocaleService&quot;)
 140      protected LocaleService localeService;
 141  
 142      @Resource(name = &quot;blSolrHelperService&quot;)
 143      protected SolrHelperService shs;
 144  
 145      @Resource(name = &quot;blSolrIndexServiceExtensionManager&quot;)
 146      protected SolrIndexServiceExtensionManager extensionManager;
 147  
 148      @Resource(name = &quot;blTransactionManager&quot;)
 149      protected PlatformTransactionManager transactionManager;
 150  
 151      @Resource(name = &quot;blSolrIndexDao&quot;)
 152      protected SolrIndexDao solrIndexDao;
 153  
 154      @Resource(name = &quot;blSandBoxHelper&quot;)
 155      protected SandBoxHelper sandBoxHelper;
 156  
 157      @Resource(name = &quot;blSearchFacetDao&quot;)
 158      protected SearchFacetDao searchFacetDao;
 159  
 160      @Resource(name = &quot;blIndexFieldDao&quot;)
 161      protected IndexFieldDao indexFieldDao;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +    public void afterPropertiesSet() throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +        if (!useLegacySolrIndexer) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +            if (useSku) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 167 +                throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;solr.index.use.sku&#x27; was true, which is not supported.&quot;);"> 167 +                throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;sðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +            if (solrConfiguration != null &amp;&amp; solrConfiguration.isSiteCollections()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 170 +                throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;solr.index.site.collections&#x27; was true, which is not supported.&quot;);"> 170 +                throw new IllegalStateException(&quot;The property &#x27;solr.catalog.useLegacySolrIndexer&#x27; was false and &#x27;sðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +    }</span>
 174  
 175      @Override
<abbr title=" 176      public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws ServiceException {"> 176      public void performCachedOperation(SolrIndexCachedOperation.CacheOperation cacheOperation) throws ServiceExcepðŸ”µ</abbr>
 177          try {
 178              CatalogStructure cache = new CatalogStructure();
 179              SolrIndexCachedOperation.setCache(cache);
 180              cacheOperation.execute();
 181          } finally {
 182              SolrIndexCachedOperation.clearCache();
 183          }
 184      }
 185  
 186      @Override
 187      public void rebuildIndex() throws ServiceException, IOException {
 188          LOG.info(&quot;Rebuilding the entire Solr index...&quot;);
 189          StopWatch s = new StopWatch();
 190  
 191          preBuildIndex();
 192          buildIndex();
 193          postBuildIndex();
 194  
 195          LOG.info(String.format(&quot;Finished building entire Solr index in %s&quot;, s.toLapString()));
 196      }
 197  
 198      @Override
 199      public void preBuildIndex() throws ServiceException {
 200          deleteAllNamespaceDocuments(solrConfiguration.getReindexServer());

 201      }
 202  
 203      @Override
 204      public void buildIndex() throws IOException, ServiceException {
 205          executeSolrIndexOperation(getReindexOperation());
 206      }
 207  
 208      @Override
 209      public void postBuildIndex() throws IOException, ServiceException {
 210          // this is required to be at the very very very end after rebuilding the whole index
 211          optimizeIndex(solrConfiguration.getReindexServer());




 212          // Swap the active and the reindex cores
 213          if (!solrConfiguration.isSingleCoreMode()) {
 214              shs.swapActiveCores(solrConfiguration);
 215          }
 216      }
 217  
 218      @Override
 219      public SolrIndexOperation getReindexOperation() {
 220          return new GlobalSolrFullReIndexOperation(this, solrConfiguration, shs, errorOnConcurrentReIndex) {
 221  
 222              @Override
 223              public List&lt;? extends Indexable&gt; readIndexables(int pageSize, Long lastId) {
 224                  return readAllActiveIndexables(pageSize, lastId);
 225              }
 226  
 227              @Override
 228              public Long countIndexables() {
 229                  return countIndexableItems();
 230              }
 231  
 232              @Override
 233              public void buildPage(List&lt;? extends Indexable&gt; indexables) throws ServiceException {
 234                  buildIncrementalIndex(indexables, getSolrServerForIndexing());

 235              }
 236          };
 237      }
 238  
 239      @Override
<abbr title=" 240      public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOException {"> 240      public void executeSolrIndexOperation(final SolrIndexOperation operation) throws ServiceException, IOExceptionðŸ”µ</abbr>
 241          operation.obtainLock();
 242  
 243          try {
 244              LOG.info(&quot;Executing Indexing operation&quot;);
 245              StopWatch s = new StopWatch();
 246  
 247              Object[] pack = saveState();
 248              try {
 249                  final Long numItemsToIndex;
 250                  try {
 251                      operation.beforeCountIndexables();
 252  
 253                      numItemsToIndex = operation.countIndexables();
 254                  } finally {
 255                      operation.afterCountIndexables();
 256                  }
 257  
 258                  if (LOG.isDebugEnabled()) {
 259                      LOG.debug(&quot;There are at most &quot; + numItemsToIndex + &quot; items to index&quot;);
 260                  }
 261                  performCachedOperation(new SolrIndexCachedOperation.CacheOperation() {
 262  
 263                      @Override
 264                      public void execute() throws ServiceException {
 265                          int page = 1;
 266                          Long lastId = null;
 267                          Long remainingNumItemsToIndex = numItemsToIndex;
 268                          Long totalPages = getTotalPageCount(numItemsToIndex);
 269  
 270                          while (remainingNumItemsToIndex &gt; 0) {
 271                              String pageNumberMessage = buildPageNumberMessage(page, totalPages);
 272                              LOG.info(pageNumberMessage);
 273  
 274                              lastId = buildIncrementalIndex(pageSize, lastId, operation);
 275                              remainingNumItemsToIndex -= pageSize;
 276                              page++;
 277                          }
 278                      }
 279                  });
 280  
 281              } finally {
 282                  restoreState(pack);
 283              }
 284  
 285              LOG.info(String.format(&quot;Indexing operation completed in %s&quot;, s.toLapString()));
 286          } finally {
 287              operation.releaseLock();
 288          }
 289      }
 290  
 291      protected long getTotalPageCount(Long numItemsToIndex) {
 292          long numPagesToIndex = numItemsToIndex / pageSize;
 293          boolean hasRemainingItemsToIndex = numItemsToIndex % pageSize != 0;
 294  
 295          return hasRemainingItemsToIndex ? (numPagesToIndex + 1) : numPagesToIndex;
 296      }
 297  
 298      protected String buildPageNumberMessage(int page, Long totalPages) {
 299          String pageNumberMessage = String.format(&quot;Building page number %s of %s&quot;, page, totalPages);
 300  
 301          Catalog currentCatalog = BroadleafRequestContext.getBroadleafRequestContext().getCurrentCatalog();
 302          if (currentCatalog != null) {
 303              pageNumberMessage += String.format(&quot; for catalog: %s&quot;, currentCatalog.getName());
 304          }
 305  
 306          return pageNumberMessage;
 307      }
 308  
 309      /**
 310       * @return
 311       */
 312      protected Long countIndexableItems() {
 313          if (useSku) {
 314              return skuDao.readCountAllActiveSkus();
 315          } else {
 316              return productDao.readCountAllActiveProducts();
 317          }

 318      }
 319  
 320      /**
 321       * &lt;p&gt;
 322       * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 323       *
 324       * @throws ServiceException if there was a problem removing the documents
 325       * @deprecated use {@link #deleteAllReindexCoreDocuments()} instead
 326       */
 327      @Deprecated
 328      protected void deleteAllDocuments() throws ServiceException {
 329          deleteAllReindexCoreDocuments();
 330      }
 331  
 332      /**
 333       * &lt;p&gt;
 334       * This method deletes all of the documents from {@link SolrContext#getReindexServer()}
 335       *
 336       * @throws ServiceException if there was a problem removing the documents
 337       */
 338      protected void deleteAllReindexCoreDocuments() throws ServiceException {
 339          deleteAllNamespaceDocuments(solrConfiguration.getReindexServer());
 340      }
 341  
 342      @Override
 343      public void deleteAllNamespaceDocuments(SolrClient server) throws ServiceException {





 344          try {
 345              String deleteQuery = StringUtil.sanitize(shs.getNamespaceFieldName()) + &quot;:(\&quot;&quot;
 346                      + StringUtil.sanitize(solrConfiguration.getNamespace()) + &quot;\&quot;)&quot;;
 347              LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
 348              server.deleteByQuery(deleteQuery);

 349  
 350              //Explicitly do a hard commit here since we just deleted the entire index
 351              server.commit();

 352          } catch (Exception e) {
 353              if (ServiceException.class.isAssignableFrom(e.getClass())) {
 354                  throw (ServiceException) e;
 355              }
 356              throw new ServiceException(&quot;Could not delete documents&quot;, e);
 357          }
 358      }
 359  
 360      @Override
 361      public void deleteAllDocuments(SolrClient server) throws ServiceException {

 362          try {
 363              String deleteQuery = &quot;*:*&quot;;
 364              LOG.debug(&quot;Deleting by query: &quot; + deleteQuery);
 365              server.deleteByQuery(deleteQuery);
 366              server.commit();


 367          } catch (Exception e) {
 368              throw new ServiceException(&quot;Could not delete documents&quot;, e);
 369          }
 370      }
 371  
<abbr title=" 372      protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ServiceException {"> 372      protected Long buildIncrementalIndex(int pageSize, Long lastId, SolrIndexOperation operation) throws ServiceExðŸ”µ</abbr>
 373          TransactionStatus status = TransactionUtils.createTransaction(&quot;readItemsToIndex&quot;,
 374              TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 375          if (SolrIndexCachedOperation.getCache() == null) {
 376              LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 377                      &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 377                      &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;ðŸ”µ</abbr>
 378          }
 379          Long response = null;
 380          try {
 381              List&lt;? extends Indexable&gt; indexables;
 382              try {
 383                  operation.beforeReadIndexables();
 384                  indexables = operation.readIndexables(pageSize, lastId);
 385                  if (CollectionUtils.isNotEmpty(indexables)) {
 386                      response = indexables.get(indexables.size()-1).getId();
 387                  }
 388              } finally {
 389                  operation.afterReadIndexables();
 390              }
 391  
 392              try {
 393                  operation.beforeBuildPage();
 394  
 395                  operation.buildPage(indexables);
 396              } finally {
 397                  operation.afterBuildPage();
 398              }
 399  
 400  
 401              TransactionUtils.finalizeTransaction(status, transactionManager, false);
 402          } catch (RuntimeException e) {
 403              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 404              throw e;
 405          }
 406          return response;
 407      }
 408  
 409      @Override
<abbr title=" 410      public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient solrServer) throws ServiceException {"> 410      public Collection&lt;SolrInputDocument&gt; buildIncrementalIndex(List&lt;? extends Indexable&gt; indexables, SolrClient soðŸ”µ</abbr>

 411          TransactionStatus status = TransactionUtils.createTransaction(&quot;executeIncrementalIndex&quot;,
 412                  TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, true);
 413          if (SolrIndexCachedOperation.getCache() == null) {
 414              LOG.warn(&quot;Consider using SolrIndexService.performCachedOperation() in combination with &quot; +
<abbr title=" 415                      &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;);"> 415                      &quot;SolrIndexService.buildIncrementalIndex() for better caching performance during solr indexing&quot;ðŸ”µ</abbr>
 416          }
 417  
 418          if (LOG.isDebugEnabled()) {
 419              LOG.debug(String.format(&quot;Building incremental product index - pageSize: [%s]...&quot;, indexables.size()));
 420          }
 421  
 422          StopWatch s = new StopWatch();
 423          try {
 424              sandBoxHelper.ignoreCloneCache(true);
 425              extensionManager.getProxy().startBatchEvent(indexables);
 426              Collection&lt;SolrInputDocument&gt; documents = new ArrayList&lt;&gt;();
 427              List&lt;Locale&gt; locales = getAllLocales();
 428  
 429              List&lt;Long&gt; productIds = BLCCollectionUtils.collectList(indexables, new TypedTransformer&lt;Long&gt;() {
 430                  @Override
 431                  public Long transform(Object input) {
 432                      return shs.getCurrentProductId((Indexable) input);
 433                  }
 434              });
 435  
 436              solrIndexDao.populateProductCatalogStructure(productIds, SolrIndexCachedOperation.getCache());
 437  
 438              List&lt;IndexField&gt; fields = null;
 439              FieldEntity currentFieldType = null;
 440              for (Indexable indexable : indexables) {
 441                  if (fields == null || ObjectUtils.notEqual(currentFieldType, indexable.getFieldEntityType())) {
 442                      fields = indexFieldDao.readFieldsByEntityType(indexable.getFieldEntityType());
 443                  }
 444  
 445                  SolrInputDocument doc = buildDocument(indexable, fields, locales);
 446                  //If someone overrides the buildDocument method and determines that they don&#x27;t want a product
 447                  //indexed, then they can return null. If the document is null it does not get added to
 448                  //to the index.
 449                  if (doc != null) {
 450                      documents.add(doc);
 451                  }
 452              }
 453  
 454              extensionManager.getProxy().modifyBuiltDocuments(documents, indexables, fields, locales);
 455  
 456              logDocuments(documents);
 457  
 458              if (!CollectionUtils.isEmpty(documents) &amp;&amp; solrServer != null) {
 459                  solrServer.add(documents);
 460                  commit(solrServer);


 461              }
 462              TransactionUtils.finalizeTransaction(status, transactionManager, false);
 463  
 464              if (LOG.isDebugEnabled()) {
<abbr title=" 465                  LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexables.size(), s.toLapString()));"> 465                  LOG.debug(String.format(&quot;Built incremental product index - pageSize: [%s] in [%s]&quot;, indexables.sizðŸ”µ</abbr>
 466              }
 467  
 468              return documents;
 469          } catch (SolrServerException e) {
 470              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 471              throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 472          } catch (IOException e) {
 473              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 474              throw new ServiceException(&quot;Could not rebuild index&quot;, e);
 475          } catch (RuntimeException e) {
 476              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 477              throw e;
 478          } finally {
 479              extensionManager.getProxy().endBatchEvent(indexables);
 480              sandBoxHelper.ignoreCloneCache(false);
 481          }
 482      }
 483  
 484      protected List&lt;? extends Indexable&gt; readAllActiveIndexables(int pageSize, Long lastId) {
 485          if (useSku) {
 486              List&lt;Sku&gt; skus = skuDao.readAllActiveSkus(pageSize, lastId);
 487              return filterIndexableSkus(skus);
 488          } else {
 489              return productDao.readAllActiveProducts(pageSize, lastId);
 490          }
 491      }
 492  
 493      @Override
 494      public List&lt;Sku&gt; filterIndexableSkus(List&lt;Sku&gt; skus) {
 495          ArrayList&lt;Sku&gt; skusToIndex = new ArrayList&lt;&gt;();
 496  
 497          if (CollectionUtils.isNotEmpty(skus)) {
 498              for (Sku sku : skus) {
 499                  //If the sku is not active, don&#x27;t index it...
 500                  if (!sku.isActive()) {
 501                      continue;
 502                  }
 503  
 504                  //If this is the default sku and the product has product options
 505                  //and is not allowed to be sold without product options
 506                  if (sku.getDefaultProduct() != null
 507                          &amp;&amp; !sku.getProduct().getCanSellWithoutOptions()
 508                          &amp;&amp; !sku.getProduct().getAdditionalSkus().isEmpty()) {
 509                      continue;
 510                  }
 511  
 512                  if (sku.getDefaultProduct() instanceof ProductBundle) {
 513                      continue;
 514                  }
 515  
 516                  skusToIndex.add(sku);
 517              }
 518          }
 519          return skusToIndex;

 520      }
 521  
 522      @Override
 523      public List&lt;Locale&gt; getAllLocales() {
 524          List&lt;Locale&gt; allLocales = localeService.findAllLocales();
 525          Map&lt;String, Locale&gt; processedLocales = new HashMap&lt;&gt;();
 526          // Optimize the list of locales we are looking at. If I have an &#x27;en&#x27; and &#x27;en_US&#x27; in the locale set and I&#x27;m
 527          // not using the country code to index the values, then I only need to index the locale &#x27;en&#x27;
 528          for (Locale locale : allLocales) {
 529              String localeCode = locale.getLocaleCode();
 530              int underscoreLocation = localeCode.indexOf(&quot;_&quot;);
 531              if (underscoreLocation &gt; 0 &amp;&amp; Boolean.FALSE.equals(locale.getUseCountryInSearchIndex())) {
 532                  String localeCodeWithoutCountry = localeCode.substring(0, underscoreLocation);
 533                  if (!processedLocales.containsKey(localeCodeWithoutCountry)) {
 534                      processedLocales.put(localeCodeWithoutCountry, locale);
 535                  }
 536              } else {
 537                  processedLocales.put(locale.getLocaleCode(), locale);
 538              }
 539          }
 540          return new ArrayList&lt;&gt;(processedLocales.values());
 541      }
 542  
 543      @Override
<abbr title=" 544      public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 544      public SolrInputDocument buildDocument(final Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; localeðŸ”µ</abbr>
 545          final SolrInputDocument document = new SolrInputDocument();

 546  
 547          attachBasicDocumentFields(indexable, document);
 548  
 549          attachIndexableDocumentFields(document, indexable, fields, locales);
 550  
 551          attachAdditionalDocumentFields(indexable, document);
 552  
 553          extensionManager.getProxy().attachChildDocuments(indexable, document, fields, locales);
 554  
 555          return document;
 556      }
 557  
 558      @Override
<abbr title=" 559      public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexField&gt; fields, List&lt;Locale&gt; locales) {"> 559      public void attachIndexableDocumentFields(SolrInputDocument document, Indexable indexable, List&lt;IndexField&gt; fiðŸ”µ</abbr>
 560          for (IndexField indexField : fields) {
 561              try {
 562                  // If we find an IndexField entry for this field, then we need to store it in the index
 563                  if (indexField != null) {
 564                      List&lt;IndexFieldType&gt; searchableFieldTypes = indexField.getFieldTypes();
 565  
<abbr title=" 566                      // For each of its search field types, get the property values, and add a field to the document for each property value"> 566                      // For each of its search field types, get the property values, and add a field to the documenðŸ”µ</abbr>
 567                      for (IndexFieldType sft : searchableFieldTypes) {
 568                          FieldType fieldType = sft.getFieldType();
<abbr title=" 569                          Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getField(), fieldType, locales);"> 569                          Map&lt;String, Object&gt; propertyValues = getPropertyValues(indexable, indexField.getField(), fðŸ”µ</abbr>
 570  
<abbr title=" 571                          ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentForIndexField(document, indexField, fieldType, propertyValues);"> 571                          ExtensionResultStatusType result = extensionManager.getProxy().populateDocumentForIndexFieðŸ”µ</abbr>
 572  
 573                          if (ExtensionResultStatusType.NOT_HANDLED.equals(result)) {
 574                              // Build out the field for every prefix
 575                              for (Entry&lt;String, Object&gt; entry : propertyValues.entrySet()) {
 576                                  String prefix = entry.getKey();
 577                                  prefix = StringUtils.isBlank(prefix) ? prefix : prefix + &quot;_&quot;;
 578  
<abbr title=" 579                                  String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fieldType, prefix);"> 579                                  String solrPropertyName = shs.getPropertyNameForIndexField(indexField, fieldType, ðŸ”µ</abbr>
 580                                  Object value = entry.getValue();
 581  
 582                                  if (FieldType.isMultiValued(fieldType)) {
 583                                      document.addField(solrPropertyName, value);
 584                                  } else {
 585                                      document.setField(solrPropertyName, value);
 586                                  }
 587                              }
 588                          }
 589                      }
 590                  }
 591  
 592              } catch (Exception e) {
<abbr title=" 593                  LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldName() + &quot;] for product id[&quot;"> 593                  LOG.error(&quot;Could not get value for property[&quot; + indexField.getField().getQualifiedFieldName() + &quot;]ðŸ”µ</abbr>
 594                          + indexable.getId() + &quot;]&quot;, e);
 595                  throw ExceptionHelper.refineException(e);
 596              }
 597          }
 598      }
 599  
 600      /**
 601       * Implementors can extend this and override this method to add additional fields to the Solr document.
 602       *
 603       * @param sku
 604       * @param document
 605       */
 606      protected void attachAdditionalDocumentFields(Indexable indexable, SolrInputDocument document) {
 607          //Empty implementation. Placeholder for others to extend and add additional fields
 608          extensionManager.getProxy().attachAdditionalDocumentFields(indexable, document);
 609      }
 610  
 611      protected void attachBasicDocumentFields(Indexable indexable, SolrInputDocument document) {
 612          CatalogStructure cache = SolrIndexCachedOperation.getCache();
 613          if (cache == null) {
 614              String msg = &quot;SolrIndexService.performCachedOperation() must be used in conjuction with&quot;
<abbr title=" 615                  + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog documents or should&quot;"> 615                  + &quot; solrIndexDao.populateProductCatalogStructure() in order to correctly build catalog documents oðŸ”µ</abbr>
 616                  + &quot; be invoked from buildIncrementalIndex()&quot;;
 617              LOG.error(msg);
 618              throw new IllegalStateException(msg);
 619          }
 620  
 621          // Add the namespace and ID fields for this product
 622          document.addField(shs.getNamespaceFieldName(), solrConfiguration.getNamespace());
 623          document.addField(shs.getIdFieldName(), shs.getSolrDocumentId(document, indexable));
 624          document.addField(shs.getTypeFieldName(), shs.getDocumentType(indexable));
 625          document.addField(shs.getIndexableIdFieldName(), shs.getIndexableId(indexable));
 626  
 627          extensionManager.getProxy().attachAdditionalBasicFields(indexable, document, shs);
 628  
 629          Long cacheKey = this.shs.getCurrentProductId(indexable); // current
 630          if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 631              cacheKey = sandBoxHelper.getOriginalId(cacheKey); // parent
 632              if (!cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 633                  cacheKey = shs.getIndexableId(indexable); // master
 634              }
 635          }
 636  
 637          // TODO: figure this out more generally; this doesn&#x27;t work for CMS content
 638          // The explicit categories are the ones defined by the product itself
 639          if (cache.getParentCategoriesByProduct().containsKey(cacheKey)) {
 640              for (Long categoryId : cache.getParentCategoriesByProduct().get(cacheKey)) {
 641                  document.addField(shs.getExplicitCategoryFieldName(), shs.getCategoryId(categoryId));
 642  
 643                  // Make sure that we&#x27;re always referencing the parent for the sort field
 644                  String categorySortFieldName = shs.getCategorySortFieldName(shs.getCategoryId(categoryId));
<abbr title=" 645                  // The issue here was the super category id is always what is stored in the cache, while the category"> 645                  // The issue here was the super category id is always what is stored in the cache, while the categðŸ”µ</abbr>
<abbr title=" 646                  // by product id is the overridden versions. Need to always look at parent version for cache stuff, which"> 646                  // by product id is the overridden versions. Need to always look at parent version for cache stuffðŸ”µ</abbr>
 647                  // is given from shs.getCategoryId
 648                  // First try the current level
 649                  String displayOrderKey = categoryId + &quot;-&quot; + cacheKey;
 650                  Long displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 651                  if (displayOrder == null) {
 652                      // Didn&#x27;t find the cache at the current level, this might be an override so look upwards
 653                      displayOrderKey = shs.getCategoryId(categoryId) + &quot;-&quot; + cacheKey;
 654                      displayOrder = convertDisplayOrderToLong(cache, displayOrderKey);
 655                  }
 656  
 657                  if (document.getField(categorySortFieldName) == null &amp;&amp; displayOrder != null) {
 658                      document.addField(categorySortFieldName, displayOrder);
 659                  }
 660  
 661                  // This is the entire tree of every category defined on the product
 662                  buildFullCategoryHierarchy(document, cache, categoryId, new HashSet&lt;Long&gt;());
 663              }
 664          }
 665      }
 666  
 667      /**
 668       * Walk the category hierarchy upwards, adding a field for each level to the solr document
 669       *
 670       * @param document the solr document for the product
 671       * @param cache the catalog structure cache
 672       * @param categoryId the current category id
 673       */
<abbr title=" 674      protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long categoryId, Set&lt;Long&gt; indexedParents) {"> 674      protected void buildFullCategoryHierarchy(SolrInputDocument document, CatalogStructure cache, Long categoryId,ðŸ”µ</abbr>
 675          Long catIdToAdd = shs.getCategoryId(categoryId);
 676  
 677          Collection&lt;Object&gt; existingValues = document.getFieldValues(shs.getCategoryFieldName());
 678          if (existingValues == null || !existingValues.contains(catIdToAdd)) {
 679              document.addField(shs.getCategoryFieldName(), catIdToAdd);
 680          }
 681  
 682          Set&lt;Long&gt; parents = cache.getParentCategoriesByCategory().get(categoryId);
 683          for (Long parent : parents) {
 684              if (!indexedParents.contains(parent)) {
 685                  indexedParents.add(parent);
 686                  buildFullCategoryHierarchy(document, cache, parent, indexedParents);
 687              }
 688          }
 689      }
 690  
 691      /**
<abbr title=" 692       * Returns a map of prefix to value for the requested attributes. For example, if the requested field corresponds to"> 692       * Returns a map of prefix to value for the requested attributes. For example, if the requested field correspoðŸ”µ</abbr>
<abbr title=" 693       * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting map could be"> 693       * a Sku&#x27;s description and the locales list has the en_US locale and the es_ES locale, the resulting map couldðŸ”µ</abbr>
 694       *
 695       * { &quot;en_US&quot; : &quot;A description&quot;,
 696       *   &quot;es_ES&quot; : &quot;Una descripcion&quot; }
 697       *
 698       * @param product
 699       * @param sku
 700       * @param field
 701       * @param fieldType
 702       * @param locales
 703       * @return the value of the property
 704       * @throws IllegalAccessException
 705       * @throws InvocationTargetException
 706       * @throws NoSuchMethodException
 707       */
<abbr title=" 708      protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldType, List&lt;Locale&gt; locales)"> 708      protected Map&lt;String, Object&gt; getPropertyValues(Indexable indexedItem, Field field, FieldType fieldType, List&lt;ðŸ”µ</abbr>
 709              throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 710  
 711          String propertyName = field.getPropertyName();
 712          Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
 713  
 714          ExtensionResultStatusType extensionResult = ExtensionResultStatusType.NOT_HANDLED;
 715          if (extensionManager != null) {
<abbr title=" 716              extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldType, values, propertyName, locales);"> 716              extensionResult = extensionManager.getProxy().addPropertyValues(indexedItem, field, fieldType, values,ðŸ”µ</abbr>
 717          }
 718  
 719          if (ExtensionResultStatusType.NOT_HANDLED.equals(extensionResult)) {
 720              Object propertyValue = shs.getPropertyValue(indexedItem, field);
 721              if (propertyValue != null) {
 722                  values.put(&quot;&quot;, propertyValue);
 723              }
 724          }
 725  
 726          return values;
 727      }
 728  
 729      /**
 730       * Converts a propertyName to one that is able to reference inside a map. For example, consider the property
 731       * in Product that references a List&lt;ProductAttribute&gt;, &quot;productAttributes&quot;. Also consider the utility method
 732       * in Product called &quot;mappedProductAttributes&quot;, which returns a map of the ProductAttributes keyed by the name
 733       * property in the ProductAttribute. Given the parameters &quot;productAttributes.heatRange&quot;, &quot;productAttributes&quot;,
 734       * &quot;mappedProductAttributes&quot; (which would represent a property called &quot;productAttributes.heatRange&quot; that
 735       * references a specific ProductAttribute inside of a product whose &quot;name&quot; property is equal to &quot;heatRange&quot;,
 736       * this method will convert this property to mappedProductAttributes(heatRange).value, which is then usable
 737       * by the standard beanutils PropertyUtils class to get the value.
 738       *
 739       * @param propertyName
 740       * @param listPropertyName
 741       * @param mapPropertyName
 742       * @return the converted property name
 743       *
 744       * @deprecated see SolrHelperService.getPropertyValue()
 745       */
 746      @Deprecated
<abbr title=" 747      protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropertyName) {"> 747      protected String convertToMappedProperty(String propertyName, String listPropertyName, String mapPropertyName)ðŸ”µ</abbr>
 748          String[] splitName = StringUtils.split(propertyName, &quot;\\.&quot;);
 749          StringBuilder convertedProperty = new StringBuilder();
 750          for (int i = 0; i &lt; splitName.length; i++) {
 751              if (convertedProperty.length() &gt; 0) {
 752                  convertedProperty.append(&quot;.&quot;);
 753              }
 754  
 755              if (splitName[i].equals(listPropertyName)) {
 756                  convertedProperty.append(mapPropertyName).append(&quot;(&quot;);
 757                  convertedProperty.append(splitName[i + 1]).append(&quot;).value&quot;);
 758                  i++;
 759              } else {
 760                  convertedProperty.append(splitName[i]);
 761              }
 762          }
 763          return convertedProperty.toString();
 764      }
 765  
 766      @Override
 767      public Object[] saveState() {
 768           return new Object[] {
 769               BroadleafRequestContext.getBroadleafRequestContext(),
 770               SkuPricingConsiderationContext.getSkuPricingConsiderationContext(),
 771               SkuPricingConsiderationContext.getSkuPricingService(),
 772               SkuActiveDateConsiderationContext.getSkuActiveDatesService()
 773           };
 774       }
 775  
 776      @Override
 777      @SuppressWarnings(&quot;rawtypes&quot;)
 778      public void restoreState(Object[] pack) {
 779           BroadleafRequestContext.setBroadleafRequestContext((BroadleafRequestContext) pack[0]);
 780           SkuPricingConsiderationContext.setSkuPricingConsiderationContext((HashMap) pack[1]);
 781           SkuPricingConsiderationContext.setSkuPricingService((DynamicSkuPricingService) pack[2]);
 782           SkuActiveDateConsiderationContext.setSkuActiveDatesService((DynamicSkuActiveDatesService) pack[3]);
 783       }
 784  
 785      @Override
 786      public void optimizeIndex(SolrClient server) throws ServiceException, IOException {
 787          shs.optimizeIndex(server);
 788      }
 789  
 790      @Override
 791      public void commit(SolrClient server) throws ServiceException, IOException {






 792          if (this.commit) {
 793              commit(server, this.softCommit, this.waitSearcher, this.waitFlush);

 794          } else if (LOG.isDebugEnabled()) {
<abbr title=" 795              LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoCommit is configured.&quot;);"> 795              LOG.debug(&quot;The flag / property \&quot;solr.index.commit\&quot; is false. Not committing! Ensure autoCommit is coðŸ”µ</abbr>
 796          }
 797      }
 798  
 799      @Override
<abbr title=" 800      public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServiceException, IOException {"> 800      public void commit(SolrClient server, boolean softCommit, boolean waitSearcher, boolean waitFlush) throws ServðŸ”µ</abbr>

 801          try {
 802              if (!this.commit) {
<abbr title=" 803                  LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is being forced via the API.&quot;);"> 803                  LOG.warn(&quot;The flag / property \&quot;solr.index.commit\&quot; is set to false but a commit is being forced vðŸ”µ</abbr>
 804              }
 805  
 806              if (LOG.isDebugEnabled()) {
 807                  LOG.debug(&quot;Committing changes to Solr index: softCommit: &quot; + softCommit
 808                          + &quot;, waitSearcher: &quot; + waitSearcher + &quot;, waitFlush: &quot; + waitFlush);
 809              }
 810  
 811              server.commit(waitFlush, waitSearcher, softCommit);

 812          } catch (SolrServerException e) {
 813              throw new ServiceException(&quot;Could not commit changes to Solr index&quot;, e);
 814          }
 815      }
 816  
 817      @Override
 818      public void logDocuments(Collection&lt;SolrInputDocument&gt; documents) {
 819          if (LOG.isTraceEnabled()) {
 820              for (SolrInputDocument document : documents) {
 821                  LOG.trace(document);
 822              }
 823          }
 824      }
 825  
 826      /**
 827       *  We multiply the BigDecimal by 1,000,000 to maintain any possible decimals in use the
 828       *  displayOrder value.
 829       *
 830       * @param cache
 831       * @param displayOrderKey
 832       * @return
 833       */
 834      protected Long convertDisplayOrderToLong(CatalogStructure cache, String displayOrderKey) {
 835          BigDecimal displayOrder = cache.getDisplayOrdersByCategoryProduct().get(displayOrderKey);
 836  
 837          if (displayOrder == null) {
 838              return null;
 839          }
 840  
 841          return displayOrder.multiply(BigDecimal.valueOf(1000000)).longValue();
 842      }
 843  
 844      @Override
 845      public void deleteByQuery(String deleteQuery) throws SolrServerException, IOException {
 846          String productFilter = shs.getTypeFieldName() + &quot;:&quot; + shs.getPrimaryDocumentType();
 847  
<abbr title=" 848          // transform the deleteQuery to include the productFilter, this is necessary to ensure that we don&#x27;t delete non-product documents accidentally"> 848          // transform the deleteQuery to include the productFilter, this is necessary to ensure that we don&#x27;t deletðŸ”µ</abbr>
 849          deleteQuery = productFilter + &quot; AND (&quot; + deleteQuery + &quot;)&quot;;
 850  
 851          String childDeleteQuery = &quot;{!child of=&quot; + productFilter + &quot;} &quot; + deleteQuery;
 852          solrConfiguration.getServer().deleteByQuery(childDeleteQuery);
 853          solrConfiguration.getServer().deleteByQuery(deleteQuery);


 854  
 855          logDeleteQuery(childDeleteQuery);
 856          logDeleteQuery(deleteQuery);
 857      }
 858  
 859      @Override
 860      public void addDocuments(Collection&lt;SolrInputDocument&gt; documents) throws IOException, SolrServerException {
 861          solrConfiguration.getServer().add(documents);

 862          logDocuments(documents);
 863      }
 864  
 865      @Override
 866      public void logDeleteQuery(String deleteQuery) {
 867          if (LOG.isDebugEnabled()) {
 868              LOG.debug(&quot;Delete query: &quot; + deleteQuery);
 869          }
 870      }
 871  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 872 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 873 +    public boolean useLegacyIndexer() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 874 +        return useLegacySolrIndexer;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 875 +    }</span>


























 876  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            