<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>537</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    537
                    <a href="536.html">prev</a>
                    <a href="538.html">next</a>
                    <a href="537_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_d9058a5a06800299e7173cfab7297358a578530e_src/com/android/launcher2/LauncherModel.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d9058a5a06800299e7173cfab7297358a578530e:src/com/android/launcher2/LauncherModel.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d9058a5a06800299e7173cfab7297358a578530e^1:src/com/android/launcher2/LauncherModel.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d9058a5a06800299e7173cfab7297358a578530e^2:src/com/android/launcher2/LauncherModel.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;039f9d38edac327b39215582b85ef75dbe6ef006:src/com/android/launcher2/LauncherModel.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bs], [bs], [sbj], [bs], [bs], [bs], [bs], [j], [j], [j], [j], [j]], subset: [[sbj], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.content.Intent.ShortcutIconResource;
  30 import android.content.pm.ActivityInfo;
  31 import android.content.pm.PackageInfo;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.PackageManager.NameNotFoundException;
  34 import android.content.pm.ResolveInfo;
  35 import android.content.res.Configuration;
  36 import android.content.res.Resources;
  37 import android.database.Cursor;
  38 import android.graphics.Bitmap;
  39 import android.graphics.BitmapFactory;
  40 import android.net.Uri;
  41 import android.os.Environment;
  42 import android.os.Handler;
  43 import android.os.HandlerThread;
  44 import android.os.Parcelable;
  45 import android.os.Process;
  46 import android.os.RemoteException;
  47 import android.os.SystemClock;
  48 import android.util.Log;
  49 
  50 import com.android.launcher.R;
  51 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52 
  53 import java.lang.ref.WeakReference;
  54 import java.net.URISyntaxException;
  55 import java.text.Collator;
  56 import java.util.ArrayList;
  57 import java.util.Collections;
  58 import java.util.Comparator;
  59 import java.util.HashMap;
  60 import java.util.HashSet;
  61 import java.util.Iterator;
  62 import java.util.List;
  63 import java.util.Set;
  64 
  65 /**
  66  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67  * LauncherModel object held in a static. Also provide APIs for updating the database state
  68  * for the Launcher.
  69  */
  70 public class LauncherModel extends BroadcastReceiver {
  71     static final boolean DEBUG_LOADERS = false;
  72     static final String TAG = &quot;Launcher.Model&quot;;
  73 
  74     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75     private final boolean mAppsCanBeOnExternalStorage;
  76     private int mBatchSize; // 0 is all apps at once
  77     private int mAllAppsLoadDelay; // milliseconds between batches
  78 
  79     private final LauncherApplication mApp;
  80     private final Object mLock = new Object();
  81     private DeferredHandler mHandler = new DeferredHandler();
  82     private LoaderTask mLoaderTask;
  83     private boolean mIsLoaderTaskRunning;
  84 
  85     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86     static {
  87         sWorkerThread.start();
  88     }
  89     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90 
  91     // We start off with everything not loaded.  After that, we assume that
  92     // our monitoring of the package manager provides all updates and we never
  93     // need to do a requery.  These are only ever touched from the loader thread.
  94     private boolean mWorkspaceLoaded;
  95     private boolean mAllAppsLoaded;
  96 
  97     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
  98     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
  99     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 100     // a normal load, we also clear this set of Runnables.
 101     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 102 
 103     private WeakReference&lt;Callbacks&gt; mCallbacks;
 104 
 105     // &lt; only access in worker thread &gt;
 106     private AllAppsList mBgAllAppsList;
 107 
 108     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 109     // other locks, this one can generally be held long-term because we never expect any of these
 110     // static data structures to be referenced outside of the worker thread except on the first
 111     // load after configuration change.
 112     static final Object sBgLock = new Object();
 113 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 114 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 115     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 116     // LauncherModel to their ids</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 117     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
 118 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 119 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 120     // sDbIconCache is the set of ItemInfos that need to have their icons updated in the database</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121     static final HashMap&lt;Object, byte[]&gt; sDbIconCache = new HashMap&lt;Object, byte[]&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122 </span>
 123 =======
 124 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 125 
 126 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 127     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 128     //       created by LauncherModel that are directly on the home screen (however, no widgets or</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 129     //       shortcuts within folders).</span>
 130 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 131     // sDbIconCache is the set of ItemInfos that need to have their icons updated in the database</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 132     static final HashMap&lt;Object, byte[]&gt; sDbIconCache = new HashMap&lt;Object, byte[]&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 133 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 134     // &lt;/ only access in worker thread &gt;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136     private IconCache mIconCache;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137     private Bitmap mDefaultIcon;</span>
 138 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 139     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 140     // LauncherModel to their ids</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 141     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 142 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 143     // sBgItems is passed to bindItems, which expects a list of all folders and shortcuts created by</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 144     //       LauncherModel that are directly on the home screen (however, no widgets or shortcuts</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 145     //       within folders).</span>
 146 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 147     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 148 
 149     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 150     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 151         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 152 
 153     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 154     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 155 
 156     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 157     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 158 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 159 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);</span>
 161 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 162 </span>
 163 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 164     // &lt;/ only access in worker thread &gt;
 165 
 166     private IconCache mIconCache;
 167     private Bitmap mDefaultIcon;
 168 
 169     private static int mCellCountX;
 170     private static int mCellCountY;
 171 
 172     protected int mPreviousConfigMcc;
 173 
 174     public interface Callbacks {
 175         public boolean setLoadOnResume();
 176         public int getCurrentWorkspaceScreen();
 177         public void startBinding();
 178         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 179         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 180         public void finishBindingItems();
 181         public void bindAppWidget(LauncherAppWidgetInfo info);
 182         public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 183         public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 184         public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
 185         public void bindAppsRemoved(ArrayList&lt;String&gt; packageNames, boolean permanent);
 186         public void bindPackagesUpdated();
 187         public boolean isAllAppsVisible();
 188         public boolean isAllAppsButtonRank(int rank);
 189         public void bindSearchablesChanged();
 190     }
 191 
 192     LauncherModel(LauncherApplication app, IconCache iconCache) {
 193         mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 194         mApp = app;
 195         mBgAllAppsList = new AllAppsList(iconCache);
 196         mIconCache = iconCache;
 197 
 198         mDefaultIcon = Utilities.createIconBitmap(
 199                 mIconCache.getFullResDefaultActivityIcon(), app);
 200 
 201         final Resources res = app.getResources();
 202         mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 203         mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 204         Configuration config = res.getConfiguration();
 205         mPreviousConfigMcc = config.mcc;
 206     }
 207 
 208     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 209      * posted on the main thread handler. */
 210     private void runOnMainThread(Runnable r) {
 211         if (sWorkerThread.getThreadId() == Process.myTid()) {
 212             // If we are on the worker thread, post onto the main handler
 213             mHandler.post(r);
 214         } else {
 215             r.run();
 216         }
 217     }
 218 
 219     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 220      * posted on the worker thread handler. */
 221     private static void runOnWorkerThread(Runnable r) {
 222         if (sWorkerThread.getThreadId() == Process.myTid()) {
 223             r.run();
 224         } else {
 225             // If we are not on the worker thread, then post to the worker handler
 226             sWorker.post(r);
 227         }
 228     }
 229 
 230     public Bitmap getFallbackIcon() {
 231         return Bitmap.createBitmap(mDefaultIcon);
 232     }
 233 
 234     public void unbindWorkspaceItems() {
 235         sWorker.post(new Runnable() {
 236             @Override
 237             public void run() {
 238                 unbindWorkspaceItemsOnMainThread();
 239             }
 240         });
 241     }
 242 
 243     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 244     private void unbindWorkspaceItemsOnMainThread() {
 245         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 246         // by making a copy of workspace items first.
 247         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 248         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 249         synchronized (sBgLock) {
 250             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 251             tmpAppWidgets.addAll(sBgAppWidgets);
 252         }
 253         Runnable r = new Runnable() {
 254                 @Override
 255                 public void run() {
 256                    for (ItemInfo item : tmpWorkspaceItems) {
 257                        item.unbind();
 258                    }
 259                    for (ItemInfo item : tmpAppWidgets) {
 260                        item.unbind();
 261                    }
 262                 }
 263             };
 264         runOnMainThread(r);
 265     }
 266 
 267     /**
 268      * Adds an item to the DB if it was not created previously, or move it to a new
 269      * &lt;container, screen, cellX, cellY&gt;
 270      */
 271     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 272             int screen, int cellX, int cellY) {
 273         if (item.container == ItemInfo.NO_ID) {
 274             // From all apps
 275             addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 276         } else {
 277             // From somewhere else
 278             moveItemInDatabase(context, item, container, screen, cellX, cellY);
 279         }
 280     }
 281 
 282     static void checkItemInfo(final ItemInfo item) {
 283         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 284         final long itemId = item.id;
 285         Runnable r = new Runnable() {
 286                 public void run() {
 287                     synchronized (sBgLock) {
 288                         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 289                         if (modelItem != null &amp;&amp; item != modelItem) {
 290                             // the modelItem needs to match up perfectly with item if our model is
 291                             // to be consistent with the database-- for now, just require
 292                             // modelItem == item
 293                             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 294                                 &quot;modelItem: &quot; +
 295                                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 296                                 &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 297                             RuntimeException e = new RuntimeException(msg);
 298                             e.setStackTrace(stackTrace);
 299                             throw e;
 300                         }
 301                     }
 302                 }
 303             };
 304         runOnWorkerThread(r);
 305     }
 306 
 307     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 308             final ItemInfo item, final String callingFunction) {
 309         final long itemId = item.id;
 310         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 311         final ContentResolver cr = context.getContentResolver();
 312 
 313         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 314         Runnable r = new Runnable() {
 315             public void run() {
 316                 cr.update(uri, values, null, null);
 317 
 318                 // Lock on mBgLock *after* the db operation
 319                 synchronized (sBgLock) {
 320                     ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 321                     if (item != modelItem) {
 322                         // the modelItem needs to match up perfectly with item if our model is to be
 323                         // consistent with the database-- for now, just require modelItem == item
 324                         String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 325                             &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 326                             &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +
 327                             &quot;original&quot;;
 328                         throw new RuntimeException(msg);
 329                     }
 330 
 331 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 332                     if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 333                             item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 334                         // Item is in a folder, make sure this folder exists</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 335                         if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 336                             // An items container is being set to a that of an item which is not in</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 337                             // the list of Folders.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 338                             String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 339                                     item.container + &quot;, not in the list of folders&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 340                             RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 341                             e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 342                             Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 343                             throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 344                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 345                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 346 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 347                     // Items are added/removed from the corresponding FolderInfo elsewhere, such</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 348                     // as in Workspace.onDrop. Here, we just add/remove them from the list of items</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 349                     // that are on the desktop, as appropriate</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 350                     if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 351                             modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 352                         switch (modelItem.itemType) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 353                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 354                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 355                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 356                                 if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 357                                     sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 358                                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 359                                 break;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 360                             default:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 361                                 break;</span>
 362 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 363         values.put(LauncherSettings.Favorites.SCREEN, item.screen);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 364 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 365         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 366     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 367 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 368     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 369      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 370      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 371     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 372             final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 373         item.container = container;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 374         item.cellX = cellX;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 375         item.cellY = cellY;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 376         item.spanX = spanX;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 377         item.spanY = spanY;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 378 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 379         // We store hotseat items in canonical form which is this orientation invariant position</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 380         // in the hotseat</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 381         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 382                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 383             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 384         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 385             item.screen = screen;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 386         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 387 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 388         final ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 389         values.put(LauncherSettings.Favorites.CONTAINER, item.container);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 390         values.put(LauncherSettings.Favorites.CELLX, item.cellX);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 391         values.put(LauncherSettings.Favorites.CELLY, item.cellY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 392         values.put(LauncherSettings.Favorites.SPANX, item.spanX);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 393         values.put(LauncherSettings.Favorites.SPANY, item.spanY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 394         values.put(LauncherSettings.Favorites.SCREEN, item.screen);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 395 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 396         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 397     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 398 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 399     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 400      * Update an item to the database in a specified container.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 401      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 402     static void updateItemInDatabase(Context context, final ItemInfo item) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 403         final ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 404         item.onAddToDatabase(values);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 405         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 406         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 407     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 408 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 409     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 410      * Returns true if the shortcuts already exists in the database.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 411      * we identify a shortcut by its title and intent.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 412      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 413     static boolean shortcutExists(Context context, String title, Intent intent) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 414         final ContentResolver cr = context.getContentResolver();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 415         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 416             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 417             new String[] { title, intent.toUri(0) }, null);</span>
 418 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 419                     // Items are added/removed from the corresponding FolderInfo elsewhere, such</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 420                     // as in Workspace.onDrop. Here, we just add/remove them from the list of items</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 421                     // that are on the desktop, as appropriate</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 422                     if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 423                             modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 424                         if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 425                             sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 426 </span>
 427 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 428                         }
 429                     } else {
 430                         sBgWorkspaceItems.remove(modelItem);
 431                     }
 432                 }
 433             }
 434         };
 435         runOnWorkerThread(r);
 436     }
 437 
 438     /**
 439      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 440      */
 441     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 442             final int screen, final int cellX, final int cellY) {
 443         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id + 
 444                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY + 
 445                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 446         Launcher.sDumpLogs.add(transaction);
 447         Log.d(TAG, transaction);
 448         item.container = container;
 449         item.cellX = cellX;
 450         item.cellY = cellY;
 451 
 452         // We store hotseat items in canonical form which is this orientation invariant position
 453         // in the hotseat
 454         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 455                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 456             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 457         } else {
 458             item.screen = screen;
 459         }
 460 
 461         final ContentValues values = new ContentValues();
 462         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 463         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 464         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 465         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 466 
 467         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 468     }
 469 
 470     /**
 471      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 472      */
 473     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 474             final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
 475         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id + 
 476                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY + 
 477                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 478         Launcher.sDumpLogs.add(transaction);
 479         Log.d(TAG, transaction);
 480         item.cellX = cellX;
 481         item.cellY = cellY;
 482         item.spanX = spanX;
 483         item.spanY = spanY;
 484 
 485         // We store hotseat items in canonical form which is this orientation invariant position
 486         // in the hotseat
 487         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 488                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 489             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 490         } else {
 491             item.screen = screen;
 492         }
 493 
 494         final ContentValues values = new ContentValues();
 495         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 496         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 497         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 498         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 499         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 500         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 501 
 502         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 503     }
 504 
 505     /**
 506      * Update an item to the database in a specified container.
 507      */
 508     static void updateItemInDatabase(Context context, final ItemInfo item) {
 509         final ContentValues values = new ContentValues();
 510         item.onAddToDatabase(values);
 511         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 512         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 513     }
 514 
 515     /**
 516      * Returns true if the shortcuts already exists in the database.
 517      * we identify a shortcut by its title and intent.
 518      */
 519     static boolean shortcutExists(Context context, String title, Intent intent) {
 520         final ContentResolver cr = context.getContentResolver();
 521         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 522             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 523             new String[] { title, intent.toUri(0) }, null);
 524         boolean result = false;
 525         try {
 526             result = c.moveToFirst();
 527         } finally {
 528             c.close();
 529         }
 530         return result;
 531     }
 532 
 533     /**
 534      * Returns an ItemInfo array containing all the items in the LauncherModel.
 535      * The ItemInfo.id is not set through this function.
 536      */
 537     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 538         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 539         final ContentResolver cr = context.getContentResolver();
 540         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 541                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 542                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 542                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 543                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 544 
 545         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 546         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 547         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 548         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 549         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 550         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 551         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 552 
 553         try {
 554             while (c.moveToNext()) {
 555                 ItemInfo item = new ItemInfo();
 556                 item.cellX = c.getInt(cellXIndex);
 557                 item.cellY = c.getInt(cellYIndex);
 558                 item.spanX = c.getInt(spanXIndex);
 559                 item.spanY = c.getInt(spanYIndex);
 560                 item.container = c.getInt(containerIndex);
 561                 item.itemType = c.getInt(itemTypeIndex);
 562                 item.screen = c.getInt(screenIndex);
 563 
 564                 items.add(item);
 565             }
 566         } catch (Exception e) {
 567             items.clear();
 568         } finally {
 569             c.close();
 570         }
 571 
 572         return items;
 573     }
 574 
 575     /**
 576      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 577      */
 578     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 579         final ContentResolver cr = context.getContentResolver();
 580         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 581                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 582                 new String[] { String.valueOf(id),
 583                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 584 
 585         try {
 586             if (c.moveToFirst()) {
 587                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 588                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 589                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 590                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 591                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 592                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 593 
 594                 FolderInfo folderInfo = null;
 595                 switch (c.getInt(itemTypeIndex)) {
 596                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 597                         folderInfo = findOrMakeFolder(folderList, id);
 598                         break;
 599                 }
 600 
 601                 folderInfo.title = c.getString(titleIndex);
 602                 folderInfo.id = id;
 603                 folderInfo.container = c.getInt(containerIndex);
 604                 folderInfo.screen = c.getInt(screenIndex);
 605                 folderInfo.cellX = c.getInt(cellXIndex);
 606                 folderInfo.cellY = c.getInt(cellYIndex);
 607 
 608                 return folderInfo;
 609             }
 610         } finally {
 611             c.close();
 612         }
 613 
 614         return null;
 615     }
 616 
 617     /**
 618      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 619      * cellY fields of the item. Also assigns an ID to the item.
 620      */
 621     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 622             final int screen, final int cellX, final int cellY, final boolean notify) {
 623         item.container = container;
 624         item.cellX = cellX;
 625         item.cellY = cellY;
 626         // We store hotseat items in canonical form which is this orientation invariant position
 627         // in the hotseat
 628         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 629                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 630             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 631         } else {
 632             item.screen = screen;
 633         }
 634 
 635         final ContentValues values = new ContentValues();
 636         final ContentResolver cr = context.getContentResolver();
 637         item.onAddToDatabase(values);
 638 
 639         LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 640         item.id = app.getLauncherProvider().generateNewId();
 641         values.put(LauncherSettings.Favorites._ID, item.id);
 642         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 643 
 644         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 645 
 646         Runnable r = new Runnable() {
 647             public void run() {
 648                 String transaction = &quot;DbDebug    Add item (&quot; + item.title + &quot;) to db, id: &quot;
 649                         + item.id + &quot; (&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot;
 650                         + cellY + &quot;)&quot;;
 651                 Launcher.sDumpLogs.add(transaction);
 652                 Log.d(TAG, transaction);
 653 
 654                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 655                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 656 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 657 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 658                 // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 659                 synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 660                     if (sBgItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 661                         // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 662                         throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 663                             &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 664                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 665                     sBgItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 666                     switch (item.itemType) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 667                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 668                             sBgFolders.put(item.id, (FolderInfo) item);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 669                             // Fall through</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 670                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 671                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 672                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 673                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 674                                 sBgWorkspaceItems.add(item);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 675                             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 676                                 if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 677                                     // Adding an item to a folder that doesn&#x27;t exist.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 678                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 679                                             &quot; doesn&#x27;t exist&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 680                                     RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 681                                     e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 682                                     Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 683                                     throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 684                                 }</span>
 685 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 686 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 687     static int getCellCountX() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 688         return mCellCountX;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 689     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 690 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 691     static int getCellCountY() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 692         return mCellCountY;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 693     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 694 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 695     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 696      * Updates the model orientation helper to take into account the current layout dimensions</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 697      * when performing local/canonical coordinate transformations.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 698      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 699     static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 700         mCellCountX = shortAxisCellCount;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 701         mCellCountY = longAxisCellCount;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 702     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 703 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 704     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 705      * Removes the specified item from the database</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 706      * @param context</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 707      * @param item</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 708      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 709     static void deleteItemFromDatabase(Context context, final ItemInfo item) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 710         final ContentResolver cr = context.getContentResolver();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 711         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 712         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 713             public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 714                 cr.delete(uriToDelete, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 715                 switch (item.itemType) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 716                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 717                         sFolders.remove(item.id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 718                         sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 719                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 720                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 721                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 722                         sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 723                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 724                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 725                         sAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 726                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 727                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 728                 sItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 729                 sDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 730             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 731         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 732         if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 733             r.run();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 734         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 735             sWorker.post(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 736         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 737     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 738 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 739     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 740      * Remove the contents of the specified folder from the database</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 741      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 742     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 743         final ContentResolver cr = context.getContentResolver();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 744 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 745         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 746             public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 747                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 748                 sItemsIdMap.remove(info.id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 749                 sFolders.remove(info.id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 750                 sDbIconCache.remove(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 751                 sWorkspaceItems.remove(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 752 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 753                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 754                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 755                 for (ItemInfo childInfo : info.contents) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 756                     sItemsIdMap.remove(childInfo.id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 757                     sDbIconCache.remove(childInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 758                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 759             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 760         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 761         if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 762             r.run();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 763         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 764             sWorker.post(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 765         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 766     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 767 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 768     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 769      * Set this as the current Launcher activity object for the loader.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 770      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 771     public void initialize(Callbacks callbacks) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 772         synchronized (mLock) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 773             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 774         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 775     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 776 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 777     /**</span>
 778 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 779                 // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 780                 synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 781                     if (sBgItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 782                         // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 783                         throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 784                             &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 785                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 786                     sBgItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 787                     switch (item.itemType) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 788                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 789                             sBgFolders.put(item.id, (FolderInfo) item);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 790                             // Fall through</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 791                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 792                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 793                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 794                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 795                                 sBgWorkspaceItems.add(item);</span>
 796 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 797                             }
 798                             break;
 799                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 800                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 801                             break;
 802                     }
 803                 }
 804             }
 805         };
 806         runOnWorkerThread(r);
 807     }
 808 
 809     /**
 810      * Creates a new unique child id, for a given cell span across all layouts.
 811      */
 812     static int getCellLayoutChildId(
 813             long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 814         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 815                 | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 816     }
 817 
 818     static int getCellCountX() {
 819         return mCellCountX;
 820     }
 821 
 822     static int getCellCountY() {
 823         return mCellCountY;
 824     }
 825 
 826     /**
 827      * Updates the model orientation helper to take into account the current layout dimensions
 828      * when performing local/canonical coordinate transformations.
 829      */
 830     static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 831         mCellCountX = shortAxisCellCount;
 832         mCellCountY = longAxisCellCount;
 833     }
 834 
 835     /**
 836      * Removes the specified item from the database
 837      * @param context
 838      * @param item
 839      */
 840     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 841         final ContentResolver cr = context.getContentResolver();
 842         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
 843         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 844 
 845         Runnable r = new Runnable() {
 846             public void run() {
 847                 String transaction = &quot;DbDebug    Delete item (&quot; + item.title + &quot;) from db, id: &quot;
 848                         + item.id + &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX +
 849                         &quot;, &quot; + item.cellY + &quot;)&quot;;
 850                 Launcher.sDumpLogs.add(transaction);
 851                 Log.d(TAG, transaction);
 852 
 853                 cr.delete(uriToDelete, null, null);
 854 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 855 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 856                 // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 857                 synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 858                     switch (item.itemType) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 859                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 860                             sBgFolders.remove(item.id);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 861                             for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 862                                 if (info.container == item.id) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 863                                     // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 864                                     // think they are contained by that folder.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 865                                     String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 866                                             &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 867                                     RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 868                                     e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 869                                     Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 870                                     throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 871                                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 872                             }</span>
 873 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 874 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 875                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 876                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 877                 for (ItemInfo childInfo : info.contents) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 878                     sItemsIdMap.remove(childInfo.id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 879                     sDbIconCache.remove(childInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 880                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 881             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 882         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 883         if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 884             r.run();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 885         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 886             sWorker.post(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 887         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 888     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 889 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 890     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 891      * Set this as the current Launcher activity object for the loader.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 892      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 893     public void initialize(Callbacks callbacks) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 894         synchronized (mLock) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 895             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 896         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 897     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 898 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 899     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 900      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 901      * ACTION_PACKAGE_CHANGED.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 902      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 903     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 904     public void onReceive(Context context, Intent intent) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 905         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 906 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 907         final String action = intent.getAction();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 908 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 909         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 910                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 911                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 912             final String packageName = intent.getData().getSchemeSpecificPart();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 913             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 914 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 915             int op = PackageUpdatedTask.OP_NONE;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 916 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 917             if (packageName == null || packageName.length() == 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 918                 // they sent us a bad intent</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 919                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 920             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 921 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 922             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 923                 op = PackageUpdatedTask.OP_UPDATE;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 924             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 925                 if (!replacing) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 926                     op = PackageUpdatedTask.OP_REMOVE;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 927                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 928                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 929                 // later, we will update the package at this time</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 930             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 931                 if (!replacing) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 932                     op = PackageUpdatedTask.OP_ADD;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 933                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 934                     op = PackageUpdatedTask.OP_UPDATE;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 935                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 936             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 937 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 938             if (op != PackageUpdatedTask.OP_NONE) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 939                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 940             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 941 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 942         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 943             // First, schedule to add these apps back in.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 944             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 945             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 946             // Then, rebind everything.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 947             startLoaderFromBackground();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 948         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 949             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 950             enqueuePackageUpdated(new PackageUpdatedTask(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 951                         PackageUpdatedTask.OP_UNAVAILABLE, packages));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 952         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 953             // If we have changed locale we need to clear out the labels in all apps/workspace.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 954             forceReload();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 955         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 956              // Check if configuration change was an mcc/mnc change which would affect app resources</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 957              // and we would need to clear out the labels in all apps/workspace. Same handling as</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 958              // above for ACTION_LOCALE_CHANGED</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 959              Configuration currentConfig = context.getResources().getConfiguration();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 960              if (mPreviousConfigMcc != currentConfig.mcc) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 961                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 962                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 963                    forceReload();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 964              }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 965              // Update previousConfig</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 966              mPreviousConfigMcc = currentConfig.mcc;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 967         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 968                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 969             if (mCallbacks != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 970                 Callbacks callbacks = mCallbacks.get();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 971                 if (callbacks != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 972                     callbacks.bindSearchablesChanged();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 973                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 974             }</span>
 975 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 976                 // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 977                 synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 978                     switch (item.itemType) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 979                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 980                             sBgFolders.remove(item.id);</span>
 981 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 982                             sBgWorkspaceItems.remove(item);
 983                             break;
 984                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 985                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 986                             sBgWorkspaceItems.remove(item);
 987                             break;
 988                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 989                             sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
 990                             break;
 991                     }
 992                     sBgItemsIdMap.remove(item.id);
 993                     sBgDbIconCache.remove(item);
 994                 }
 995             }
 996         };
 997         runOnWorkerThread(r);
 998     }
 999 
1000     /**
1001      * Remove the contents of the specified folder from the database
1002      */
1003     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1004         final ContentResolver cr = context.getContentResolver();
1005 
1006         Runnable r = new Runnable() {
1007             public void run() {
1008                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1009                 // Lock on mBgLock *after* the db operation
1010                 synchronized (sBgLock) {
1011                     sBgItemsIdMap.remove(info.id);
1012                     sBgFolders.remove(info.id);
1013                     sBgDbIconCache.remove(info);
1014                     sBgWorkspaceItems.remove(info);
1015                 }
1016 
1017                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1018                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1019                 // Lock on mBgLock *after* the db operation
1020                 synchronized (sBgLock) {
1021                     for (ItemInfo childInfo : info.contents) {
1022                         sBgItemsIdMap.remove(childInfo.id);
1023                         sBgDbIconCache.remove(childInfo);
1024                     }
1025                 }
1026             }
1027         };
1028         runOnWorkerThread(r);
1029     }
1030 
1031     /**
1032      * Set this as the current Launcher activity object for the loader.
1033      */
1034     public void initialize(Callbacks callbacks) {
1035         synchronized (mLock) {
1036             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1037         }
1038     }
1039 
1040     /**
1041      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1042      * ACTION_PACKAGE_CHANGED.
1043      */
1044     @Override
1045     public void onReceive(Context context, Intent intent) {
1046         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1047 
1048         final String action = intent.getAction();
1049 
1050         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
1051                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
1052                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1053             final String packageName = intent.getData().getSchemeSpecificPart();
1054             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1055 
1056             int op = PackageUpdatedTask.OP_NONE;
1057 
1058             if (packageName == null || packageName.length() == 0) {
1059                 // they sent us a bad intent
1060                 return;
1061             }
1062 
1063             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
1064                 op = PackageUpdatedTask.OP_UPDATE;
1065             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
1066                 if (!replacing) {
1067                     op = PackageUpdatedTask.OP_REMOVE;
1068                 }
1069                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
1070                 // later, we will update the package at this time
1071             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1072                 if (!replacing) {
1073                     op = PackageUpdatedTask.OP_ADD;
1074                 } else {
1075                     op = PackageUpdatedTask.OP_UPDATE;
1076                 }
1077             }
1078 
1079             if (op != PackageUpdatedTask.OP_NONE) {
1080                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
1081             }
1082 
1083         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
1084             // First, schedule to add these apps back in.
1085             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1086             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
1087             // Then, rebind everything.
1088             startLoaderFromBackground();
1089         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
1090             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1091             enqueuePackageUpdated(new PackageUpdatedTask(
1092                         PackageUpdatedTask.OP_UNAVAILABLE, packages));
1093         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1094             // If we have changed locale we need to clear out the labels in all apps/workspace.
1095             forceReload();
1096         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1097              // Check if configuration change was an mcc/mnc change which would affect app resources
1098              // and we would need to clear out the labels in all apps/workspace. Same handling as
1099              // above for ACTION_LOCALE_CHANGED
1100              Configuration currentConfig = context.getResources().getConfiguration();
1101              if (mPreviousConfigMcc != currentConfig.mcc) {
1102                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1103                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1104                    forceReload();
1105              }
1106              // Update previousConfig
1107              mPreviousConfigMcc = currentConfig.mcc;
1108         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1109                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1110             if (mCallbacks != null) {
1111                 Callbacks callbacks = mCallbacks.get();
1112                 if (callbacks != null) {
1113                     callbacks.bindSearchablesChanged();
1114                 }
1115             }
1116         }
1117     }
1118 
1119     private void forceReload() {
1120         resetLoadedState(true, true);
1121 
1122         // Do this here because if the launcher activity is running it will be restarted.
1123         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1124         // to reload.
1125         startLoaderFromBackground();
1126     }
1127 
1128     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1129         synchronized (mLock) {
1130             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1131             // mWorkspaceLoaded to true later
1132             stopLoaderLocked();
1133             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1134             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1135         }
1136     }
1137 
1138     /**
1139      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1140      * configuration changes.  So whenever we trigger the loader from the background
1141      * tell the launcher that it needs to re-run the loader when it comes back instead
1142      * of doing it now.
1143      */
1144     public void startLoaderFromBackground() {
1145         boolean runLoader = false;
1146         if (mCallbacks != null) {
1147             Callbacks callbacks = mCallbacks.get();
1148             if (callbacks != null) {
1149                 // Only actually run the loader if they&#x27;re not paused.
1150                 if (!callbacks.setLoadOnResume()) {
1151                     runLoader = true;
1152                 }
1153             }
1154         }
1155         if (runLoader) {
1156             startLoader(false, -1);
1157         }
1158     }
1159 
1160     // If there is already a loader task running, tell it to stop.
1161     // returns true if isLaunching() was true on the old task
1162     private boolean stopLoaderLocked() {
1163         boolean isLaunching = false;
1164         LoaderTask oldTask = mLoaderTask;
1165         if (oldTask != null) {
1166             if (oldTask.isLaunching()) {
1167                 isLaunching = true;
1168             }
1169             oldTask.stopLocked();
1170         }
1171         return isLaunching;
1172     }
1173 
1174     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1175         synchronized (mLock) {
1176             if (DEBUG_LOADERS) {
1177                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1178             }
1179 
1180             // Clear any deferred bind-runnables from the synchronized load process
1181             // We must do this before any loading/binding is scheduled below.
1182             mDeferredBindRunnables.clear();
1183 
1184             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1185             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1186                 // If there is already one running, tell it to stop.
1187                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1188                 isLaunching = isLaunching || stopLoaderLocked();
1189                 mLoaderTask = new LoaderTask(mApp, isLaunching);
1190                 if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1191                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1192                 } else {
1193                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1194                     sWorker.post(mLoaderTask);
1195                 }
1196             }
1197         }
1198     }
1199 
1200     void bindRemainingSynchronousPages() {
1201         // Post the remaining side pages to be loaded
1202         if (!mDeferredBindRunnables.isEmpty()) {
1203             for (final Runnable r : mDeferredBindRunnables) {
1204                 mHandler.post(r);
1205             }
1206             mDeferredBindRunnables.clear();
1207         }
1208     }
1209 
1210     public void stopLoader() {
1211         synchronized (mLock) {
1212             if (mLoaderTask != null) {
1213                 mLoaderTask.stopLocked();
1214             }
1215         }
1216     }
1217 
1218     public boolean isAllAppsLoaded() {
1219         return mAllAppsLoaded;
1220     }
1221 
1222     boolean isLoadingWorkspace() {
1223         synchronized (mLock) {
1224             if (mLoaderTask != null) {
1225                 return mLoaderTask.isLoadingWorkspace();
1226             }
1227         }
1228         return false;
1229     }
1230 
1231     /**
1232      * Runnable for the thread that loads the contents of the launcher:
1233      *   - workspace icons
1234      *   - widgets
1235      *   - all apps icons
1236      */
1237     private class LoaderTask implements Runnable {
1238         private Context mContext;
1239         private boolean mIsLaunching;
1240         private boolean mIsLoadingAndBindingWorkspace;
1241         private boolean mStopped;
1242         private boolean mLoadAndBindStepFinished;
1243 
1244         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1245 
1246         LoaderTask(Context context, boolean isLaunching) {
1247             mContext = context;
1248             mIsLaunching = isLaunching;
1249             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1250         }
1251 
1252         boolean isLaunching() {
1253             return mIsLaunching;
1254         }
1255 
1256         boolean isLoadingWorkspace() {
1257             return mIsLoadingAndBindingWorkspace;
1258         }
1259 
1260         private void loadAndBindWorkspace() {
1261             mIsLoadingAndBindingWorkspace = true;
1262 
1263             // Load the workspace
1264             if (DEBUG_LOADERS) {
1265                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1266             }
1267 
1268             if (!mWorkspaceLoaded) {
1269                 loadWorkspace();
1270                 synchronized (LoaderTask.this) {
1271                     if (mStopped) {
1272                         return;
1273                     }
1274                     mWorkspaceLoaded = true;
1275                 }
1276             }
1277 
1278             // Bind the workspace
1279             bindWorkspace(-1);
1280         }
1281 
1282         private void waitForIdle() {
1283             // Wait until the either we&#x27;re stopped or the other threads are done.
1284             // This way we don&#x27;t start loading all apps until the workspace has settled
1285             // down.
1286             synchronized (LoaderTask.this) {
1287                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1288 
1289                 mHandler.postIdle(new Runnable() {
1290                         public void run() {
1291                             synchronized (LoaderTask.this) {
1292                                 mLoadAndBindStepFinished = true;
1293                                 if (DEBUG_LOADERS) {
1294                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1295                                 }
1296                                 LoaderTask.this.notify();
1297                             }
1298                         }
1299                     });
1300 
1301                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1302                     try {
1303                         this.wait();
1304                     } catch (InterruptedException ex) {
1305                         // Ignore
1306                     }
1307                 }
1308                 if (DEBUG_LOADERS) {
1309                     Log.d(TAG, &quot;waited &quot;
1310                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1311                             + &quot;ms for previous step to finish binding&quot;);
1312                 }
1313             }
1314         }
1315 
1316         void runBindSynchronousPage(int synchronousBindPage) {
1317             if (synchronousBindPage &lt; 0) {
1318                 // Ensure that we have a valid page index to load synchronously
1319                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1320                         &quot;valid page index&quot;);
1321             }
1322             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1323                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1324                 // loaded already (we should load everything asynchronously in that case)
1325                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1326             }
1327             synchronized (mLock) {
1328                 if (mIsLoaderTaskRunning) {
1329                     // Ensure that we are never running the background loading at this point since
1330                     // we also touch the background collections
1331                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1332                 }
1333             }
1334 
1335             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1336             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1337             //      this call is synchronous, we can get away with not locking).
1338 
1339             // Divide the set of loaded items into those that we are binding synchronously, and
1340             // everything else that is to be bound normally (asynchronously).
1341             bindWorkspace(synchronousBindPage);
1342             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1343             //      arise from that.
1344             onlyBindAllApps();
1345         }
1346 
1347         public void run() {
1348             synchronized (mLock) {
1349                 mIsLoaderTaskRunning = true;
1350             }
1351             // Optimize for end-user experience: if the Launcher is up and // running with the
1352             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1353             // workspace first (default).
1354             final Callbacks cbk = mCallbacks.get();
1355             final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1356 
1357             keep_running: {
1358                 // Elevate priority when Home launches for the first time to avoid
1359                 // starving at boot time. Staring at a blank home is not cool.
1360                 synchronized (mLock) {
1361                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1362                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1363                     android.os.Process.setThreadPriority(mIsLaunching
1364                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1365                 }
1366                 if (loadWorkspaceFirst) {
1367                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1368                     loadAndBindWorkspace();
1369                 } else {
1370                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1371                     loadAndBindAllApps();
1372                 }
1373 
1374                 if (mStopped) {
1375                     break keep_running;
1376                 }
1377 
1378                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1379                 // settled down.
1380                 synchronized (mLock) {
1381                     if (mIsLaunching) {
1382                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1383                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1384                     }
1385                 }
1386                 waitForIdle();
1387 
1388                 // second step
1389                 if (loadWorkspaceFirst) {
1390                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1391                     loadAndBindAllApps();
1392                 } else {
1393                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1394                     loadAndBindWorkspace();
1395                 }
1396 
1397                 // Restore the default thread priority after we are done loading items
1398                 synchronized (mLock) {
1399                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1400                 }
1401             }
1402 
1403 
1404             // Update the saved icons if necessary
1405             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1406             synchronized (sBgLock) {
1407                 for (Object key : sBgDbIconCache.keySet()) {
1408                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1409                 }
1410                 sBgDbIconCache.clear();
1411             }
1412 
1413             // Clear out this reference, otherwise we end up holding it until all of the
1414             // callback runnables are done.
1415             mContext = null;
1416 
1417             synchronized (mLock) {
1418                 // If we are still the last one to be scheduled, remove ourselves.
1419                 if (mLoaderTask == this) {
1420                     mLoaderTask = null;
1421                 }
1422                 mIsLoaderTaskRunning = false;
1423             }
1424         }
1425 
1426         public void stopLocked() {
1427             synchronized (LoaderTask.this) {
1428                 mStopped = true;
1429                 this.notify();
1430             }
1431         }
1432 
1433         /**
1434          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1435          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1436          * object that was around when the deferred message was scheduled, and if there&#x27;s
1437          * a new Callbacks object around then also return null.  This will save us from
1438          * calling onto it with data that will be ignored.
1439          */
1440         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1441             synchronized (mLock) {
1442                 if (mStopped) {
1443                     return null;
1444                 }
1445 
1446                 if (mCallbacks == null) {
1447                     return null;
1448                 }
1449 
1450                 final Callbacks callbacks = mCallbacks.get();
1451                 if (callbacks != oldCallbacks) {
1452                     return null;
1453                 }
1454                 if (callbacks == null) {
1455                     Log.w(TAG, &quot;no mCallbacks&quot;);
1456                     return null;
1457                 }
1458 
1459                 return callbacks;
1460             }
1461         }
1462 
1463         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1464         private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1465             int containerIndex = item.screen;
1466             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1467                 // Return early if we detect that an item is under the hotseat button
1468                 if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1469                     return false;
1470                 }
1471 
1472                 // We use the last index to refer to the hotseat and the screen as the rank, so
1473                 // test and update the occupied state accordingly
1474                 if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1475                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1476                         + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1477                         + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1478                     return false;
1479                 } else {
1480                     occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1481                     return true;
1482                 }
1483             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1484                 // Skip further checking if it is not the hotseat or workspace container
1485                 return true;
1486             }
1487 
1488             // Check if any workspace icons overlap with each other
1489             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1490                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1491                     if (occupied[containerIndex][x][y] != null) {
1492                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1493                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1494                             + x + &quot;,&quot; + y
1495                             + &quot;) occupied by &quot;
1496                             + occupied[containerIndex][x][y]);
1497                         return false;
1498                     }
1499                 }
1500             }
1501             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1502                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1503                     occupied[containerIndex][x][y] = item;
1504                 }
1505             }
1506 
1507             return true;
1508         }
1509 
1510         private void loadWorkspace() {
1511             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1512 
1513             final Context context = mContext;
1514             final ContentResolver contentResolver = context.getContentResolver();
1515             final PackageManager manager = context.getPackageManager();
1516             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1517             final boolean isSafeMode = manager.isSafeMode();
1518 
1519             // Make sure the default workspace is loaded, if needed
1520             mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1521 
1522             synchronized (sBgLock) {
1523                 sBgWorkspaceItems.clear();
1524                 sBgAppWidgets.clear();
1525                 sBgFolders.clear();
1526                 sBgItemsIdMap.clear();
1527                 sBgDbIconCache.clear();
1528 
1529                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1530 
1531                 final Cursor c = contentResolver.query(
1532                         LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);
1533 
1534                 // +1 for the hotseat (it can be larger than the workspace)
1535                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1536                 // before any earlier duplicates)
1537                 final ItemInfo occupied[][][] =
1538                         new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];
1539 
1540                 try {
1541                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1542                     final int intentIndex = c.getColumnIndexOrThrow
1543                             (LauncherSettings.Favorites.INTENT);
1544                     final int titleIndex = c.getColumnIndexOrThrow
1545                             (LauncherSettings.Favorites.TITLE);
1546                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1547                             LauncherSettings.Favorites.ICON_TYPE);
1548                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1549                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1550                             LauncherSettings.Favorites.ICON_PACKAGE);
1551                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1552                             LauncherSettings.Favorites.ICON_RESOURCE);
1553                     final int containerIndex = c.getColumnIndexOrThrow(
1554                             LauncherSettings.Favorites.CONTAINER);
1555                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1556                             LauncherSettings.Favorites.ITEM_TYPE);
1557                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1558                             LauncherSettings.Favorites.APPWIDGET_ID);
1559                     final int screenIndex = c.getColumnIndexOrThrow(
1560                             LauncherSettings.Favorites.SCREEN);
1561                     final int cellXIndex = c.getColumnIndexOrThrow
1562                             (LauncherSettings.Favorites.CELLX);
1563                     final int cellYIndex = c.getColumnIndexOrThrow
1564                             (LauncherSettings.Favorites.CELLY);
1565                     final int spanXIndex = c.getColumnIndexOrThrow
1566                             (LauncherSettings.Favorites.SPANX);
1567                     final int spanYIndex = c.getColumnIndexOrThrow(
1568                             LauncherSettings.Favorites.SPANY);
1569                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1570                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1571                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1572 
1573                     ShortcutInfo info;
1574                     String intentDescription;
1575                     LauncherAppWidgetInfo appWidgetInfo;
1576                     int container;
1577                     long id;
1578                     Intent intent;
1579 
1580                     while (!mStopped &amp;&amp; c.moveToNext()) {
1581                         try {
1582                             int itemType = c.getInt(itemTypeIndex);
1583 
1584                             switch (itemType) {
1585                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1586                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1587                                 intentDescription = c.getString(intentIndex);
1588                                 try {
1589                                     intent = Intent.parseUri(intentDescription, 0);
1590                                 } catch (URISyntaxException e) {
1591                                     continue;
1592                                 }
1593 
1594                                 if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1595                                     info = getShortcutInfo(manager, intent, context, c, iconIndex,
1596                                             titleIndex, mLabelCache);
1597                                 } else {
1598                                     info = getShortcutInfo(c, context, iconTypeIndex,
1599                                             iconPackageIndex, iconResourceIndex, iconIndex,
1600                                             titleIndex);
1601 
1602                                     // App shortcuts that used to be automatically added to Launcher
1603                                     // didn&#x27;t always have the correct intent flags set, so do that
1604                                     // here
1605                                     if (intent.getAction() != null &amp;&amp;
1606                                         intent.getCategories() != null &amp;&amp;
1607                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1608                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1609                                         intent.addFlags(
1610                                             Intent.FLAG_ACTIVITY_NEW_TASK |
1611                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1612                                     }
1613                                 }
1614 
1615                                 if (info != null) {
1616                                     info.intent = intent;
1617                                     info.id = c.getLong(idIndex);
1618                                     container = c.getInt(containerIndex);
1619                                     info.container = container;
1620                                     info.screen = c.getInt(screenIndex);
1621                                     info.cellX = c.getInt(cellXIndex);
1622                                     info.cellY = c.getInt(cellYIndex);
1623 
1624                                     // check &amp; update map of what&#x27;s occupied
1625                                     if (!checkItemPlacement(occupied, info)) {
1626                                         break;
1627                                     }
1628 
1629                                     switch (container) {
1630                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1631                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1632                                         sBgWorkspaceItems.add(info);
1633                                         break;
1634                                     default:
1635                                         // Item is in a user folder
1636                                         FolderInfo folderInfo =
1637                                                 findOrMakeFolder(sBgFolders, container);
1638                                         folderInfo.add(info);
1639                                         break;
1640                                     }
1641                                     sBgItemsIdMap.put(info.id, info);
1642 
1643                                     // now that we&#x27;ve loaded everthing re-save it with the
1644                                     // icon in case it disappears somehow.
1645                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1646                                 } else {
1647                                     // Failed to load the shortcut, probably because the
1648                                     // activity manager couldn&#x27;t resolve it (maybe the app
1649                                     // was uninstalled), or the db row was somehow screwed up.
1650                                     // Delete it.
1651                                     id = c.getLong(idIndex);
1652                                     Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);
1653                                     contentResolver.delete(LauncherSettings.Favorites.getContentUri(
1654                                                 id, false), null, null);
1655                                 }
1656                                 break;
1657 
1658                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1659                                 id = c.getLong(idIndex);
1660                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1661 
1662                                 folderInfo.title = c.getString(titleIndex);
1663                                 folderInfo.id = id;
1664                                 container = c.getInt(containerIndex);
1665                                 folderInfo.container = container;
1666                                 folderInfo.screen = c.getInt(screenIndex);
1667                                 folderInfo.cellX = c.getInt(cellXIndex);
1668                                 folderInfo.cellY = c.getInt(cellYIndex);
1669 
1670                                 // check &amp; update map of what&#x27;s occupied
1671                                 if (!checkItemPlacement(occupied, folderInfo)) {
1672                                     break;
1673                                 }
1674                                 switch (container) {
1675                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1676                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1677                                         sBgWorkspaceItems.add(folderInfo);
1678                                         break;
1679                                 }
1680 
1681                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
1682                                 sBgFolders.put(folderInfo.id, folderInfo);
1683                                 break;
1684 
1685                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1686                                 // Read all Launcher-specific widget details
1687                                 int appWidgetId = c.getInt(appWidgetIdIndex);
1688                                 id = c.getLong(idIndex);
1689 
1690                                 final AppWidgetProviderInfo provider =
1691                                         widgets.getAppWidgetInfo(appWidgetId);
1692 
1693                                 if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
1694                                         provider.provider.getPackageName() == null)) {
1695                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
1696                                         + id + &quot; appWidgetId=&quot; + appWidgetId;
1697                                     Log.e(TAG, log);
1698                                     Launcher.sDumpLogs.add(log);
1699                                     itemsToRemove.add(id);
1700                                 } else {
1701                                     appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
1702                                             provider.provider);
1703                                     appWidgetInfo.id = id;
1704                                     appWidgetInfo.screen = c.getInt(screenIndex);
1705                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
1706                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
1707                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
1708                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
1709                                     int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1710                                     appWidgetInfo.minSpanX = minSpan[0];
1711                                     appWidgetInfo.minSpanY = minSpan[1];
1712 
1713                                     container = c.getInt(containerIndex);
1714                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1715                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1716                                         Log.e(TAG, &quot;Widget found where container != &quot; +
1717                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
1718                                         continue;
1719                                     }
1720                                     appWidgetInfo.container = c.getInt(containerIndex);
1721 
1722                                     // check &amp; update map of what&#x27;s occupied
1723                                     if (!checkItemPlacement(occupied, appWidgetInfo)) {
1724                                         break;
1725                                     }
1726                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1727                                     sBgAppWidgets.add(appWidgetInfo);
1728                                 }
1729                                 break;
1730                             }
1731                         } catch (Exception e) {
1732                             Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);
1733                         }
1734                     }
1735                 } finally {
1736                     c.close();
1737                 }
1738 
1739                 if (itemsToRemove.size() &gt; 0) {
1740                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
1741                                     LauncherSettings.Favorites.CONTENT_URI);
1742                     // Remove dead items
1743                     for (long id : itemsToRemove) {
1744                         if (DEBUG_LOADERS) {
1745                             Log.d(TAG, &quot;Removed id = &quot; + id);
1746                         }
1747                         // Don&#x27;t notify content observers
1748                         try {
1749                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
1750                                     null, null);
1751                         } catch (RemoteException e) {
1752                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
1753                         }
1754                     }
1755                 }
1756 
1757                 if (DEBUG_LOADERS) {
1758                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1759                     Log.d(TAG, &quot;workspace layout: &quot;);
1760                     for (int y = 0; y &lt; mCellCountY; y++) {
1761                         String line = &quot;&quot;;
1762                         for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {
1763                             if (s &gt; 0) {
1764                                 line += &quot; | &quot;;
1765                             }
1766                             for (int x = 0; x &lt; mCellCountX; x++) {
1767                                 line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
1768                             }
1769                         }
1770                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
1771                     }
1772                 }
1773             }
1774         }
1775 
1776         /** Filters the set of items who are directly or indirectly (via another container) on the
1777          * specified screen. */
1778         private void filterCurrentWorkspaceItems(int currentScreen,
1779                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
1780                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
1781                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
1782             // Purge any null ItemInfos
1783             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
1784             while (iter.hasNext()) {
1785                 ItemInfo i = iter.next();
1786                 if (i == null) {
1787                     iter.remove();
1788                 }
1789             }
1790 
1791             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1792             // items given.
1793             if (currentScreen &lt; 0) {
1794                 currentScreenItems.addAll(allWorkspaceItems);
1795             }
1796 
1797             // Order the set of items by their containers first, this allows use to walk through the
1798             // list sequentially, build up a list of containers that are in the specified screen,
1799             // as well as all items in those containers.
1800             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
1801             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
1802                 @Override
1803                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1804                     return (int) (lhs.container - rhs.container);
1805                 }
1806             });
1807             for (ItemInfo info : allWorkspaceItems) {
1808                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1809                     if (info.screen == currentScreen) {
1810                         currentScreenItems.add(info);
1811                         itemsOnScreen.add(info.id);
1812                     } else {
1813                         otherScreenItems.add(info);
1814                     }
1815                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1816                     currentScreenItems.add(info);
1817                     itemsOnScreen.add(info.id);
1818                 } else {
1819                     if (itemsOnScreen.contains(info.container)) {
1820                         currentScreenItems.add(info);
1821                         itemsOnScreen.add(info.id);
1822                     } else {
1823                         otherScreenItems.add(info);
1824                     }
1825                 }
1826             }
1827         }
1828 
1829         /** Filters the set of widgets which are on the specified screen. */
1830         private void filterCurrentAppWidgets(int currentScreen,
1831                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1832                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
1833                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
1834             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1835             // widgets given.
1836             if (currentScreen &lt; 0) {
1837                 currentScreenWidgets.addAll(appWidgets);
1838             }
1839 
1840             for (LauncherAppWidgetInfo widget : appWidgets) {
1841                 if (widget == null) continue;
1842                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1843                         widget.screen == currentScreen) {
1844                     currentScreenWidgets.add(widget);
1845                 } else {
1846                     otherScreenWidgets.add(widget);
1847                 }
1848             }
1849         }
1850 
1851         /** Filters the set of folders which are on the specified screen. */
1852         private void filterCurrentFolders(int currentScreen,
1853                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
1854                 HashMap&lt;Long, FolderInfo&gt; folders,
1855                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
1856                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
1857             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1858             // widgets given.
1859             if (currentScreen &lt; 0) {
1860                 currentScreenFolders.putAll(folders);
1861             }
1862 
1863             for (long id : folders.keySet()) {
1864                 ItemInfo info = itemsIdMap.get(id);
1865                 FolderInfo folder = folders.get(id);
1866                 if (info == null || folder == null) continue;
1867                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1868                         info.screen == currentScreen) {
1869                     currentScreenFolders.put(id, folder);
1870                 } else {
1871                     otherScreenFolders.put(id, folder);
1872                 }
1873             }
1874         }
1875 
1876         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
1877          * right) */
1878         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
1879             // XXX: review this
1880             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
1881                 @Override
1882                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1883                     int cellCountX = LauncherModel.getCellCountX();
1884                     int cellCountY = LauncherModel.getCellCountY();
1885                     int screenOffset = cellCountX * cellCountY;
1886                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1887                     long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1888                             lhs.cellY * cellCountX + lhs.cellX);
1889                     long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1890                             rhs.cellY * cellCountX + rhs.cellX);
1891                     return (int) (lr - rr);
1892                 }
1893             });
1894         }
1895 
1896         private void bindWorkspaceItems(final Callbacks oldCallbacks,
1897                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
1898                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1899                 final HashMap&lt;Long, FolderInfo&gt; folders,
1900                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
1901 
1902             final boolean postOnMainThread = (deferredBindRunnables != null);
1903 
1904             // Bind the workspace items
1905             int N = workspaceItems.size();
1906             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
1907                 final int start = i;
1908                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
1909                 final Runnable r = new Runnable() {
1910                     @Override
1911                     public void run() {
1912                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1913                         if (callbacks != null) {
1914                             callbacks.bindItems(workspaceItems, start, start+chunkSize);
1915                         }
1916                     }
1917                 };
1918                 if (postOnMainThread) {
1919                     deferredBindRunnables.add(r);
1920                 } else {
1921                     runOnMainThread(r);
1922                 }
1923             }
1924 
1925             // Bind the folders
1926             if (!folders.isEmpty()) {
1927                 final Runnable r = new Runnable() {
1928                     public void run() {
1929                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1930                         if (callbacks != null) {
1931                             callbacks.bindFolders(folders);
1932                         }
1933                     }
1934                 };
1935                 if (postOnMainThread) {
1936                     deferredBindRunnables.add(r);
1937                 } else {
1938                     runOnMainThread(r);
1939                 }
1940             }
1941 
1942             // Bind the widgets, one at a time
1943             N = appWidgets.size();
1944             for (int i = 0; i &lt; N; i++) {
1945                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
1946                 final Runnable r = new Runnable() {
1947                     public void run() {
1948                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1949                         if (callbacks != null) {
1950                             callbacks.bindAppWidget(widget);
1951                         }
1952                     }
1953                 };
1954                 if (postOnMainThread) {
1955                     deferredBindRunnables.add(r);
1956                 } else {
1957                     runOnMainThread(r);
1958                 }
1959             }
1960         }
1961 
1962         /**
1963          * Binds all loaded data to actual views on the main thread.
1964          */
1965         private void bindWorkspace(int synchronizeBindPage) {
1966             final long t = SystemClock.uptimeMillis();
1967             Runnable r;
1968 
1969             // Don&#x27;t use these two variables in any of the callback runnables.
1970             // Otherwise we hold a reference to them.
1971             final Callbacks oldCallbacks = mCallbacks.get();
1972             if (oldCallbacks == null) {
1973                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1974                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
1975                 return;
1976             }
1977 
1978             final int currentScreen = (synchronizeBindPage &gt; -1) ? synchronizeBindPage :
1979                 oldCallbacks.getCurrentWorkspaceScreen();
1980 
1981             // Load all the items that are on the current page first (and in the process, unbind
1982             // all the existing workspace items before we call startBinding() below.
1983             unbindWorkspaceItemsOnMainThread();
1984             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
1985             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
1986                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1987             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
1988             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
1989             synchronized (sBgLock) {
1990                 workspaceItems.addAll(sBgWorkspaceItems);
1991                 appWidgets.addAll(sBgAppWidgets);
1992                 folders.putAll(sBgFolders);
1993                 itemsIdMap.putAll(sBgItemsIdMap);
1994             }
1995 
1996             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1997             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1998             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
1999                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2000             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2001                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2002             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2003             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2004 
2005             // Separate the items that are on the current screen, and all the other remaining items
2006             filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,
2007                     otherWorkspaceItems);
2008             filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,
2009                     otherAppWidgets);
2010             filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,
2011                     otherFolders);
2012             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2013             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2014 
2015             // Tell the workspace that we&#x27;re about to start binding items
2016             r = new Runnable() {
2017                 public void run() {
2018                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2019                     if (callbacks != null) {
2020                         callbacks.startBinding();
2021                     }
2022                 }
2023             };
2024             runOnMainThread(r);
2025 
2026             // Load items on the current page
2027             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2028                     currentFolders, null);
2029 
2030             // Load all the remaining pages
2031             mDeferredBindRunnables.clear();
2032             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2033                     mDeferredBindRunnables);
2034 
2035             // Tell the workspace that we&#x27;re done binding items
2036             r = new Runnable() {
2037                 public void run() {
2038                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2039                     if (callbacks != null) {
2040                         callbacks.finishBindingItems();
2041                     }
2042 
2043                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2044                     if (DEBUG_LOADERS) {
2045                         Log.d(TAG, &quot;bound workspace in &quot;
2046                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2047                     }
2048 
2049                     mIsLoadingAndBindingWorkspace = false;
2050                 }
2051             };
2052             mDeferredBindRunnables.add(r);
2053         }
2054 
2055         private void loadAndBindAllApps() {
2056             if (DEBUG_LOADERS) {
2057                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2058             }
2059             if (!mAllAppsLoaded) {
2060                 loadAllAppsByBatch();
2061                 synchronized (LoaderTask.this) {
2062                     if (mStopped) {
2063                         return;
2064                     }
2065                     mAllAppsLoaded = true;
2066                 }
2067             } else {
2068                 onlyBindAllApps();
2069             }
2070         }
2071 
2072         private void onlyBindAllApps() {
2073             final Callbacks oldCallbacks = mCallbacks.get();
2074             if (oldCallbacks == null) {
2075                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2076                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2077                 return;
2078             }
2079 
2080             // shallow copy
2081             @SuppressWarnings(&quot;unchecked&quot;)
2082             final ArrayList&lt;ApplicationInfo&gt; list
2083                     = (ArrayList&lt;ApplicationInfo&gt;) mBgAllAppsList.data.clone();
2084             mHandler.post(new Runnable() {
2085                 public void run() {
2086                     final long t = SystemClock.uptimeMillis();
2087                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2088                     if (callbacks != null) {
2089                         callbacks.bindAllApplications(list);
2090                     }
2091                     if (DEBUG_LOADERS) {
2092                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2093                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2094                     }
2095                 }
2096             });
2097         }
2098 
2099         private void loadAllAppsByBatch() {
2100             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2101 
2102             // Don&#x27;t use these two variables in any of the callback runnables.
2103             // Otherwise we hold a reference to them.
2104             final Callbacks oldCallbacks = mCallbacks.get();
2105             if (oldCallbacks == null) {
2106                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2107                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
2108                 return;
2109             }
2110 
2111             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2112             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2113 
2114             final PackageManager packageManager = mContext.getPackageManager();
2115             List&lt;ResolveInfo&gt; apps = null;
2116 
2117             int N = Integer.MAX_VALUE;
2118 
2119             int startIndex;
2120             int i=0;
2121             int batchSize = -1;
2122             while (i &lt; N &amp;&amp; !mStopped) {
2123                 if (i == 0) {
2124                     mBgAllAppsList.clear();
2125                     final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2126                     apps = packageManager.queryIntentActivities(mainIntent, 0);
2127                     if (DEBUG_LOADERS) {
2128                         Log.d(TAG, &quot;queryIntentActivities took &quot;
2129                                 + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
2130                     }
2131                     if (apps == null) {
2132                         return;
2133                     }
2134                     N = apps.size();
2135                     if (DEBUG_LOADERS) {
2136                         Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
2137                     }
2138                     if (N == 0) {
2139                         // There are no apps?!?
2140                         return;
2141                     }
2142                     if (mBatchSize == 0) {
2143                         batchSize = N;
2144                     } else {
2145                         batchSize = mBatchSize;
2146                     }
2147 
2148                     final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2149                     Collections.sort(apps,
2150                             new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
2151                     if (DEBUG_LOADERS) {
2152                         Log.d(TAG, &quot;sort took &quot;
2153                                 + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2154                     }
2155                 }
2156 
2157                 final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2158 
2159                 startIndex = i;
2160                 for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
2161                     // This builds the icon bitmaps.
2162                     mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),
2163                             mIconCache, mLabelCache));
2164                     i++;
2165                 }
2166 
2167                 final boolean first = i &lt;= batchSize;
2168                 final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2169                 final ArrayList&lt;ApplicationInfo&gt; added = mBgAllAppsList.added;
2170                 mBgAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();
2171 
2172                 mHandler.post(new Runnable() {
2173                     public void run() {
2174                         final long t = SystemClock.uptimeMillis();
2175                         if (callbacks != null) {
2176                             if (first) {
2177                                 callbacks.bindAllApplications(added);
2178                             } else {
2179                                 callbacks.bindAppsAdded(added);
2180                             }
2181                             if (DEBUG_LOADERS) {
2182                                 Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2183                                     + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
2184                             }
2185                         } else {
2186                             Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2187                         }
2188                     }
2189                 });
2190 
2191                 if (DEBUG_LOADERS) {
2192                     Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
2193                             + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
2194                 }
2195 
2196                 if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
2197                     try {
2198                         if (DEBUG_LOADERS) {
2199                             Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
2200                         }
2201                         Thread.sleep(mAllAppsLoadDelay);
2202                     } catch (InterruptedException exc) { }
2203                 }
2204             }
2205 
2206             if (DEBUG_LOADERS) {
2207                 Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
2208                         + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
2209                         + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
2210             }
2211         }
2212 
2213         public void dumpState() {
2214             synchronized (sBgLock) {
2215                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2216                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2217                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2218                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2219                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2220             }
2221         }
2222     }
2223 
2224     void enqueuePackageUpdated(PackageUpdatedTask task) {
2225         sWorker.post(task);
2226     }
2227 
2228     private class PackageUpdatedTask implements Runnable {
2229         int mOp;
2230         String[] mPackages;
2231 
2232         public static final int OP_NONE = 0;
2233         public static final int OP_ADD = 1;
2234         public static final int OP_UPDATE = 2;
2235         public static final int OP_REMOVE = 3; // uninstlled
2236         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2237 
2238 
2239         public PackageUpdatedTask(int op, String[] packages) {
2240             mOp = op;
2241             mPackages = packages;
2242         }
2243 
2244         public void run() {
2245             final Context context = mApp;
2246 
2247             final String[] packages = mPackages;
2248             final int N = packages.length;
2249             switch (mOp) {
2250                 case OP_ADD:
2251                     for (int i=0; i&lt;N; i++) {
2252                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2253                         mBgAllAppsList.addPackage(context, packages[i]);
2254                     }
2255                     break;
2256                 case OP_UPDATE:
2257                     for (int i=0; i&lt;N; i++) {
2258                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2259                         mBgAllAppsList.updatePackage(context, packages[i]);
2260                     }
2261                     break;
2262                 case OP_REMOVE:
2263                 case OP_UNAVAILABLE:
2264                     for (int i=0; i&lt;N; i++) {
2265                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2266                         mBgAllAppsList.removePackage(packages[i]);
2267                     }
2268                     break;
2269             }
2270 
2271             ArrayList&lt;ApplicationInfo&gt; added = null;
2272             ArrayList&lt;ApplicationInfo&gt; modified = null;
2273 
2274             if (mBgAllAppsList.added.size() &gt; 0) {
2275                 added = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.added);
2276                 mBgAllAppsList.added.clear();
2277             }
2278             if (mBgAllAppsList.modified.size() &gt; 0) {
2279                 modified = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.modified);
2280                 mBgAllAppsList.modified.clear();
2281             }
2282             // We may be removing packages that have no associated launcher application, so we
2283             // pass through the removed package names directly.
2284             // NOTE: We flush the icon cache aggressively in removePackage() above.
2285             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2286             if (mBgAllAppsList.removed.size() &gt; 0) {
2287                 mBgAllAppsList.removed.clear();
2288 
2289                 for (int i = 0; i &lt; N; ++i) {
2290                     removedPackageNames.add(packages[i]);
2291                 }
2292             }
2293 
2294             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2295             if (callbacks == null) {
2296                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2297                 return;
2298             }
2299 
2300             if (added != null) {
2301                 final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
2302                 mHandler.post(new Runnable() {
2303                     public void run() {
2304                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2305                         if (callbacks == cb &amp;&amp; cb != null) {
2306                             callbacks.bindAppsAdded(addedFinal);
2307                         }
2308                     }
2309                 });
2310             }
2311             if (modified != null) {
2312                 final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
2313                 mHandler.post(new Runnable() {
2314                     public void run() {
2315                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2316                         if (callbacks == cb &amp;&amp; cb != null) {
2317                             callbacks.bindAppsUpdated(modifiedFinal);
2318                         }
2319                     }
2320                 });
2321             }
2322             if (!removedPackageNames.isEmpty()) {
2323                 final boolean permanent = mOp != OP_UNAVAILABLE;
2324                 mHandler.post(new Runnable() {
2325                     public void run() {
2326                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2327                         if (callbacks == cb &amp;&amp; cb != null) {
2328                             callbacks.bindAppsRemoved(removedPackageNames, permanent);
2329                         }
2330                     }
2331                 });
2332             }
2333 
2334             mHandler.post(new Runnable() {
2335                 @Override
2336                 public void run() {
2337                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2338                     if (callbacks == cb &amp;&amp; cb != null) {
2339                         callbacks.bindPackagesUpdated();
2340                     }
2341                 }
2342             });
2343         }
2344     }
2345 
2346     /**
2347 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
2348 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2349     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2350         final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2351         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2352             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2353 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2354         final Intent supportsIntent =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2355             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2356         supportsIntent.setType(mimeType);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2357 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2358         // Create a set of widget configuration components that we can test against</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2359         final List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2360             AppWidgetManager.getInstance(context).getInstalledProviders();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2361         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2362             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2363         for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2364             configurationComponentToWidget.put(info.configure, info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2365         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2366 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2367         // Run through each of the intents that can handle this type of clip data, and cross</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2368         // reference them with the components that are actual configuration components</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2369         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2370                 PackageManager.MATCH_DEFAULT_ONLY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2371         for (ResolveInfo info : activities) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2372             final ActivityInfo activityInfo = info.activityInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2373             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2374                     activityInfo.name);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2375             if (configurationComponentToWidget.containsKey(infoComponent)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2376                 supportedConfigurationActivities.add(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2377                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2378                                 configurationComponentToWidget.get(infoComponent)));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2379             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2380         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2381         return supportedConfigurationActivities;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2382     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2383 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2384     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2385         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2386         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2387         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2388 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2389         if (intent == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2390             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2391             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2392             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2393         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2394 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2395         Bitmap icon = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2396         boolean customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2397         ShortcutIconResource iconResource = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2398 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2399         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2400             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2401             customIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2402         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2403             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2404             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2405                 try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2406                     iconResource = (ShortcutIconResource) extra;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2407                     final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2408                     Resources resources = packageManager.getResourcesForApplication(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2409                             iconResource.packageName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2410                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2411                     icon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2412                             mIconCache.getFullResIcon(resources, id), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2413                 } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2414                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2415                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2416             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2417         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2418 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2419         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2420 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2421         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2422             if (fallbackIcon != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2423                 icon = fallbackIcon;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2424             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2425                 icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2426                 info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2427             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2428         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2429         info.setIcon(icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2430 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2431         info.title = name;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2432         info.intent = intent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2433         info.customIcon = customIcon;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2434         info.iconResource = iconResource;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2435 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2436         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2437     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2438 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2439     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2440             int iconIndex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2441         // If apps can&#x27;t be on SD, don&#x27;t even bother.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2442         if (!mAppsCanBeOnExternalStorage) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2443             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2444         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2445         // If this icon doesn&#x27;t have a custom icon, check to see</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2446         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what</span>
2447 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2448      * Returns all the Workspace ShortcutInfos associated with a particular package.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2449      * @param intent</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2450      * @return</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2451      */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2452     ArrayList&lt;ShortcutInfo&gt; getShortcutInfosForPackage(String packageName) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2453         ArrayList&lt;ShortcutInfo&gt; infos = new ArrayList&lt;ShortcutInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2454         synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2455             for (ItemInfo i : sBgWorkspaceItems) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2456                 if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2457                     ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2458                     if (packageName.equals(info.getPackageName())) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2459                         infos.add(info);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2460                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2461                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2462             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2463         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2464         return infos;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2465     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2466 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2467     /**</span>
2468 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
2469      * This is called from the code that adds shortcuts from the intent receiver.  This
2470      * doesn&#x27;t have a Cursor, but
2471      */
2472     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2473         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2474     }
2475 
2476     /**
2477      * Make an ShortcutInfo object for a shortcut that is an application.
2478      *
2479      * If c is not null, then it will be used to fill in missing data like the title and icon.
2480      */
2481     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2482             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2483         Bitmap icon = null;
2484         final ShortcutInfo info = new ShortcutInfo();
2485 
2486         ComponentName componentName = intent.getComponent();
2487         if (componentName == null) {
2488             return null;
2489         }
2490 
2491         try {
2492             PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2493             if (!pi.applicationInfo.enabled) {
2494                 // If we return null here, the corresponding item will be removed from the launcher
2495                 // db and will not appear in the workspace.
2496                 return null;
2497             }
2498         } catch (NameNotFoundException e) {
2499             Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2500         }
2501 
2502         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2503         // then return null &amp; delete this.
2504 
2505         // the resource -- This may implicitly give us back the fallback icon,
2506         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2507         // to avoid saving lots of copies of that in the database, and most apps
2508         // have icons anyway.
2509 
2510         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2511         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2512         // via resolveActivity().
2513         ResolveInfo resolveInfo = null;
2514         ComponentName oldComponent = intent.getComponent();
2515         Intent newIntent = new Intent(intent.getAction(), null);
2516         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2517         newIntent.setPackage(oldComponent.getPackageName());
2518         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2519         for (ResolveInfo i : infos) {
2520             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2521                     i.activityInfo.name);
2522             if (cn.equals(oldComponent)) {
2523                 resolveInfo = i;
2524             }
2525         }
2526         if (resolveInfo == null) {
2527             resolveInfo = manager.resolveActivity(intent, 0);
2528         }
2529         if (resolveInfo != null) {
2530             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2531         }
2532         // the db
2533         if (icon == null) {
2534             if (c != null) {
2535                 icon = getIconFromCursor(c, iconIndex, context);
2536             }
2537         }
2538         // the fallback icon
2539         if (icon == null) {
2540             icon = getFallbackIcon();
2541             info.usingFallbackIcon = true;
2542         }
2543         info.setIcon(icon);
2544 
2545         // from the resource
2546         if (resolveInfo != null) {
2547             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2548             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2549                 info.title = labelCache.get(key);
2550             } else {
2551                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2552                 if (labelCache != null) {
2553                     labelCache.put(key, info.title);
2554                 }
2555             }
2556         }
2557         // from the db
2558         if (info.title == null) {
2559             if (c != null) {
2560                 info.title =  c.getString(titleIndex);
2561             }
2562         }
2563         // fall back to the class name of the activity
2564         if (info.title == null) {
2565             info.title = componentName.getClassName();
2566         }
2567         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2568         return info;
2569     }
2570 
2571     /**
2572      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2573      */
2574     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2575             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2576             int titleIndex) {
2577 
2578         Bitmap icon = null;
2579         final ShortcutInfo info = new ShortcutInfo();
2580         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2581 
2582         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2583 
2584         info.title = c.getString(titleIndex);
2585 
2586         int iconType = c.getInt(iconTypeIndex);
2587         switch (iconType) {
2588         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2589             String packageName = c.getString(iconPackageIndex);
2590             String resourceName = c.getString(iconResourceIndex);
2591             PackageManager packageManager = context.getPackageManager();
2592             info.customIcon = false;
2593             // the resource
2594             try {
2595                 Resources resources = packageManager.getResourcesForApplication(packageName);
2596                 if (resources != null) {
2597                     final int id = resources.getIdentifier(resourceName, null, null);
2598                     icon = Utilities.createIconBitmap(
2599                             mIconCache.getFullResIcon(resources, id), context);
2600                 }
2601             } catch (Exception e) {
2602                 // drop this.  we have other places to look for icons
2603             }
2604             // the db
2605             if (icon == null) {
2606                 icon = getIconFromCursor(c, iconIndex, context);
2607             }
2608             // the fallback icon
2609             if (icon == null) {
2610                 icon = getFallbackIcon();
2611                 info.usingFallbackIcon = true;
2612             }
2613             break;
2614         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2615             icon = getIconFromCursor(c, iconIndex, context);
2616             if (icon == null) {
2617                 icon = getFallbackIcon();
2618                 info.customIcon = false;
2619                 info.usingFallbackIcon = true;
2620             } else {
2621                 info.customIcon = true;
2622             }
2623             break;
2624         default:
2625             icon = getFallbackIcon();
2626             info.usingFallbackIcon = true;
2627             info.customIcon = false;
2628             break;
2629         }
2630         info.setIcon(icon);
2631         return info;
2632     }
2633 
2634     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2635         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2636         final boolean debug = false;
2637         if (debug) {
2638             Log.d(TAG, &quot;getIconFromCursor app=&quot;
2639                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2640         }
2641         byte[] data = c.getBlob(iconIndex);
2642         try {
2643             return Utilities.createIconBitmap(
2644                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
2645         } catch (Exception e) {
2646             return null;
2647         }
2648     }
2649 
2650     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2651             int cellX, int cellY, boolean notify) {
2652         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2653         if (info == null) {
2654             return null;
2655         }
2656         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2657 
2658         return info;
2659     }
2660 
2661     /**
2662      * Attempts to find an AppWidgetProviderInfo that matches the given component.
2663      */
2664     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2665             ComponentName component) {
2666         List&lt;AppWidgetProviderInfo&gt; widgets =
2667             AppWidgetManager.getInstance(context).getInstalledProviders();
2668         for (AppWidgetProviderInfo info : widgets) {
2669             if (info.provider.equals(component)) {
2670                 return info;
2671             }
2672         }
2673         return null;
2674     }
2675 
2676     /**
2677      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2678      */
2679     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2680         final PackageManager packageManager = context.getPackageManager();
2681         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2682             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2683 
2684         final Intent supportsIntent =
2685             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2686         supportsIntent.setType(mimeType);
2687 
2688         // Create a set of widget configuration components that we can test against
2689         final List&lt;AppWidgetProviderInfo&gt; widgets =
2690             AppWidgetManager.getInstance(context).getInstalledProviders();
2691         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2692             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2693         for (AppWidgetProviderInfo info : widgets) {
2694             configurationComponentToWidget.put(info.configure, info);
2695         }
2696 
2697         // Run through each of the intents that can handle this type of clip data, and cross
2698         // reference them with the components that are actual configuration components
2699         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2700                 PackageManager.MATCH_DEFAULT_ONLY);
2701         for (ResolveInfo info : activities) {
2702             final ActivityInfo activityInfo = info.activityInfo;
2703             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2704                     activityInfo.name);
2705             if (configurationComponentToWidget.containsKey(infoComponent)) {
2706                 supportedConfigurationActivities.add(
2707                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2708                                 configurationComponentToWidget.get(infoComponent)));
2709             }
2710         }
2711         return supportedConfigurationActivities;
2712     }
2713 
2714     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2715         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2716         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2717         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2718 
2719         if (intent == null) {
2720             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2721             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2722             return null;
2723         }
2724 
2725         Bitmap icon = null;
2726         boolean customIcon = false;
2727         ShortcutIconResource iconResource = null;
2728 
2729         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2730             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2731             customIcon = true;
2732         } else {
2733             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2734             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2735                 try {
2736                     iconResource = (ShortcutIconResource) extra;
2737                     final PackageManager packageManager = context.getPackageManager();
2738                     Resources resources = packageManager.getResourcesForApplication(
2739                             iconResource.packageName);
2740                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2741                     icon = Utilities.createIconBitmap(
2742                             mIconCache.getFullResIcon(resources, id), context);
2743                 } catch (Exception e) {
2744                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2745                 }
2746             }
2747         }
2748 
2749         final ShortcutInfo info = new ShortcutInfo();
2750 
2751         if (icon == null) {
2752             if (fallbackIcon != null) {
2753                 icon = fallbackIcon;
2754             } else {
2755                 icon = getFallbackIcon();
2756                 info.usingFallbackIcon = true;
2757             }
2758         }
2759         info.setIcon(icon);
2760 
2761         info.title = name;
2762         info.intent = intent;
2763         info.customIcon = customIcon;
2764         info.iconResource = iconResource;
2765 
2766         return info;
2767     }
2768 
2769     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2770             int iconIndex) {
2771         // If apps can&#x27;t be on SD, don&#x27;t even bother.
2772         if (!mAppsCanBeOnExternalStorage) {
2773             return false;
2774         }
2775         // If this icon doesn&#x27;t have a custom icon, check to see
2776         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2777         // we&#x27;re going to show, store what we are going to show back
2778         // into the DB.  We do this so when we&#x27;re loading, if the
2779         // package manager can&#x27;t find an icon (for example because
2780         // the app is on SD) then we can use that instead.
2781         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2782             cache.put(info, c.getBlob(iconIndex));
2783             return true;
2784         }
2785         return false;
2786     }
2787     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2788         boolean needSave = false;
2789         try {
2790             if (data != null) {
2791                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2792                 Bitmap loaded = info.getIcon(mIconCache);
2793                 needSave = !saved.sameAs(loaded);
2794             } else {
2795                 needSave = true;
2796             }
2797         } catch (Exception e) {
2798             needSave = true;
2799         }
2800         if (needSave) {
2801             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2802             // This is slower than is ideal, but this only happens once
2803             // or when the app is updated with a new icon.
2804             updateItemInDatabase(context, info);
2805         }
2806     }
2807 
2808     /**
2809      * Return an existing FolderInfo object if we have encountered this ID previously,
2810      * or make a new one.
2811      */
2812     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2813         // See if a placeholder was created for us already
2814         FolderInfo folderInfo = folders.get(id);
2815         if (folderInfo == null) {
2816             // No placeholder -- create a new instance
2817             folderInfo = new FolderInfo();
2818             folders.put(id, folderInfo);
2819         }
2820         return folderInfo;
2821     }
2822 
2823     private static final Collator sCollator = Collator.getInstance();
2824     public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2825             = new Comparator&lt;ApplicationInfo&gt;() {
2826         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2827             int result = sCollator.compare(a.title.toString(), b.title.toString());
2828             if (result == 0) {
2829                 result = a.componentName.compareTo(b.componentName);
2830             }
2831             return result;
2832         }
2833     };
2834     public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2835             = new Comparator&lt;ApplicationInfo&gt;() {
2836         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2837             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2838             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2839             return 0;
2840         }
2841     };
2842     public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2843             = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2844         public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2845             return sCollator.compare(a.label.toString(), b.label.toString());
2846         }
2847     };
2848     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2849         if (info.activityInfo != null) {
2850             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2851         } else {
2852             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2853         }
2854     }
2855     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2856         private PackageManager mPackageManager;
2857         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2858         ShortcutNameComparator(PackageManager pm) {
2859             mPackageManager = pm;
2860             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2861         }
2862         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2863             mPackageManager = pm;
2864             mLabelCache = labelCache;
2865         }
2866         public final int compare(ResolveInfo a, ResolveInfo b) {
2867             CharSequence labelA, labelB;
2868             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2869             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2870             if (mLabelCache.containsKey(keyA)) {
2871                 labelA = mLabelCache.get(keyA);
2872             } else {
2873                 labelA = a.loadLabel(mPackageManager).toString();
2874 
2875                 mLabelCache.put(keyA, labelA);
2876             }
2877             if (mLabelCache.containsKey(keyB)) {
2878                 labelB = mLabelCache.get(keyB);
2879             } else {
2880                 labelB = b.loadLabel(mPackageManager).toString();
2881 
2882                 mLabelCache.put(keyB, labelB);
2883             }
2884             return sCollator.compare(labelA, labelB);
2885         }
2886     };
2887     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2888         private PackageManager mPackageManager;
2889         private HashMap&lt;Object, String&gt; mLabelCache;
2890         WidgetAndShortcutNameComparator(PackageManager pm) {
2891             mPackageManager = pm;
2892             mLabelCache = new HashMap&lt;Object, String&gt;();
2893         }
2894         public final int compare(Object a, Object b) {
2895             String labelA, labelB;
2896             if (mLabelCache.containsKey(a)) {
2897                 labelA = mLabelCache.get(a);
2898             } else {
2899                 labelA = (a instanceof AppWidgetProviderInfo) ?
2900                     ((AppWidgetProviderInfo) a).label :
2901                     ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2902                 mLabelCache.put(a, labelA);
2903             }
2904             if (mLabelCache.containsKey(b)) {
2905                 labelB = mLabelCache.get(b);
2906             } else {
2907                 labelB = (b instanceof AppWidgetProviderInfo) ?
2908                     ((AppWidgetProviderInfo) b).label :
2909                     ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2910                 mLabelCache.put(b, labelB);
2911             }
2912             return sCollator.compare(labelA, labelB);
2913         }
2914     };
2915 
2916     public void dumpState() {
2917         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
2918         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
2919         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
2920         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
2921         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
2922         if (mLoaderTask != null) {
2923             mLoaderTask.dumpState();
2924         } else {
2925             Log.d(TAG, &quot;mLoaderTask=null&quot;);
2926         }
2927     }
2928 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.content.Intent.ShortcutIconResource;
  30 import android.content.pm.ActivityInfo;
  31 import android.content.pm.PackageInfo;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.PackageManager.NameNotFoundException;
  34 import android.content.pm.ResolveInfo;
  35 import android.content.res.Configuration;
  36 import android.content.res.Resources;
  37 import android.database.Cursor;
  38 import android.graphics.Bitmap;
  39 import android.graphics.BitmapFactory;
  40 import android.net.Uri;
  41 import android.os.Environment;
  42 import android.os.Handler;
  43 import android.os.HandlerThread;
  44 import android.os.Parcelable;
  45 import android.os.Process;
  46 import android.os.RemoteException;
  47 import android.os.SystemClock;
  48 import android.util.Log;
  49 
  50 import com.android.launcher.R;
  51 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52 
  53 import java.lang.ref.WeakReference;
  54 import java.net.URISyntaxException;
  55 import java.text.Collator;
  56 import java.util.ArrayList;
  57 import java.util.Collections;
  58 import java.util.Comparator;
  59 import java.util.HashMap;
  60 import java.util.HashSet;
  61 import java.util.Iterator;
  62 import java.util.List;
  63 import java.util.Set;
  64 
  65 /**
  66  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67  * LauncherModel object held in a static. Also provide APIs for updating the database state
  68  * for the Launcher.
  69  */
  70 public class LauncherModel extends BroadcastReceiver {
  71     static final boolean DEBUG_LOADERS = false;
  72     static final String TAG = &quot;Launcher.Model&quot;;
  73 
  74     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75     private final boolean mAppsCanBeOnExternalStorage;
  76     private int mBatchSize; // 0 is all apps at once
  77     private int mAllAppsLoadDelay; // milliseconds between batches
  78 
  79     private final LauncherApplication mApp;
  80     private final Object mLock = new Object();
  81     private DeferredHandler mHandler = new DeferredHandler();
  82     private LoaderTask mLoaderTask;
  83     private boolean mIsLoaderTaskRunning;
  84 
  85     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86     static {
  87         sWorkerThread.start();
  88     }
  89     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90 
  91     // We start off with everything not loaded.  After that, we assume that
  92     // our monitoring of the package manager provides all updates and we never
  93     // need to do a requery.  These are only ever touched from the loader thread.
  94     private boolean mWorkspaceLoaded;
  95     private boolean mAllAppsLoaded;
  96 
  97     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
  98     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
  99     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 100     // a normal load, we also clear this set of Runnables.
 101     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 102 
 103     private WeakReference&lt;Callbacks&gt; mCallbacks;
 104 
 105     // &lt; only access in worker thread &gt;
 106     private AllAppsList mBgAllAppsList;
 107 
 108     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 109     // other locks, this one can generally be held long-term because we never expect any of these
 110     // static data structures to be referenced outside of the worker thread except on the first
 111     // load after configuration change.
 112     static final Object sBgLock = new Object();
 113 
 114     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 115     // LauncherModel to their ids
 116     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 117 
 118 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 119     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 120     //       created by LauncherModel that are directly on the home screen (however, no widgets or</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 121     //       shortcuts within folders).</span>
 122 ||||||| BASE
 123 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 124     // sBgItems is passed to bindItems, which expects a list of all folders and shortcuts created by</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 125     //       LauncherModel that are directly on the home screen (however, no widgets or shortcuts</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 126     //       within folders).</span>
 127 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 128     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 129 
 130     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 131     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 132         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 133 
 134     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 135     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 136 
 137     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 138     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 139     // &lt;/ only access in worker thread &gt;
 140 
 141     private IconCache mIconCache;
 142     private Bitmap mDefaultIcon;
 143 
 144     private static int mCellCountX;
 145     private static int mCellCountY;
 146 
 147     protected int mPreviousConfigMcc;
 148 
 149     public interface Callbacks {
 150         public boolean setLoadOnResume();
 151         public int getCurrentWorkspaceScreen();
 152         public void startBinding();
 153         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 154         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 155         public void finishBindingItems();
 156         public void bindAppWidget(LauncherAppWidgetInfo info);
 157         public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 158         public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 159         public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
 160         public void bindAppsRemoved(ArrayList&lt;String&gt; packageNames, boolean permanent);
 161         public void bindPackagesUpdated();
 162         public boolean isAllAppsVisible();
 163         public boolean isAllAppsButtonRank(int rank);
 164         public void bindSearchablesChanged();
 165     }
 166 
 167     LauncherModel(LauncherApplication app, IconCache iconCache) {
 168         mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 169         mApp = app;
 170         mBgAllAppsList = new AllAppsList(iconCache);
 171         mIconCache = iconCache;
 172 
 173         mDefaultIcon = Utilities.createIconBitmap(
 174                 mIconCache.getFullResDefaultActivityIcon(), app);
 175 
 176         final Resources res = app.getResources();
 177         mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 178         mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 179         Configuration config = res.getConfiguration();
 180         mPreviousConfigMcc = config.mcc;
 181     }
 182 
 183     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 184      * posted on the main thread handler. */
 185     private void runOnMainThread(Runnable r) {
 186         if (sWorkerThread.getThreadId() == Process.myTid()) {
 187             // If we are on the worker thread, post onto the main handler
 188             mHandler.post(r);
 189         } else {
 190             r.run();
 191         }
 192     }
 193 
 194     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 195      * posted on the worker thread handler. */
 196     private static void runOnWorkerThread(Runnable r) {
 197         if (sWorkerThread.getThreadId() == Process.myTid()) {
 198             r.run();
 199         } else {
 200             // If we are not on the worker thread, then post to the worker handler
 201             sWorker.post(r);
 202         }
 203     }
 204 
 205     public Bitmap getFallbackIcon() {
 206         return Bitmap.createBitmap(mDefaultIcon);
 207     }
 208 
 209     public void unbindWorkspaceItems() {
 210         sWorker.post(new Runnable() {
 211             @Override
 212             public void run() {
 213                 unbindWorkspaceItemsOnMainThread();
 214             }
 215         });
 216     }
 217 
 218     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 219     private void unbindWorkspaceItemsOnMainThread() {
 220         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 221         // by making a copy of workspace items first.
 222         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 223         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 224         synchronized (sBgLock) {
 225             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 226             tmpAppWidgets.addAll(sBgAppWidgets);
 227         }
 228         Runnable r = new Runnable() {
 229             @Override
 230             public void run() {
 231                    for (ItemInfo item : tmpWorkspaceItems) {
 232                    item.unbind();
 233                }
 234                    for (ItemInfo item : tmpAppWidgets) {
 235                    item.unbind();
 236                }
 237             }
 238             };
 239         runOnMainThread(r);
 240     }
 241 
 242     /**
 243      * Adds an item to the DB if it was not created previously, or move it to a new
 244      * &lt;container, screen, cellX, cellY&gt;
 245      */
 246     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 247             int screen, int cellX, int cellY) {
 248         if (item.container == ItemInfo.NO_ID) {
 249             // From all apps
 250             addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 251         } else {
 252             // From somewhere else
 253             moveItemInDatabase(context, item, container, screen, cellX, cellY);
 254         }
 255     }
 256 
 257     static void checkItemInfo(final ItemInfo item) {
 258         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 259         final long itemId = item.id;
 260         Runnable r = new Runnable() {
 261                 public void run() {
 262                     synchronized (sBgLock) {
 263                         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 264                         if (modelItem != null &amp;&amp; item != modelItem) {
 265                             // the modelItem needs to match up perfectly with item if our model is
 266                             // to be consistent with the database-- for now, just require
 267                             // modelItem == item
 268                             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 269                                 &quot;modelItem: &quot; +
 270                                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 271                                 &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 272                             RuntimeException e = new RuntimeException(msg);
 273                             e.setStackTrace(stackTrace);
 274                             throw e;
 275                         }
 276                     }
 277                 }
 278             };
 279         runOnWorkerThread(r);
 280     }
 281 
 282     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 283             final ItemInfo item, final String callingFunction) {
 284         final long itemId = item.id;
 285         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 286         final ContentResolver cr = context.getContentResolver();
 287 
 288         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 289         Runnable r = new Runnable() {
 290             public void run() {
 291                 cr.update(uri, values, null, null);
 292 
 293                 // Lock on mBgLock *after* the db operation
 294                 synchronized (sBgLock) {
 295                     ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 296                 if (item != modelItem) {
 297                     // the modelItem needs to match up perfectly with item if our model is to be
 298                     // consistent with the database-- for now, just require modelItem == item
 299                     String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 300                         &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 301                             &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +
 302                             &quot;original&quot;;
 303                     throw new RuntimeException(msg);
 304                 }
 305 
 306                     if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 307                             item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 308                         // Item is in a folder, make sure this folder exists
 309                         if (!sBgFolders.containsKey(item.container)) {
 310                             // An items container is being set to a that of an item which is not in
 311                             // the list of Folders.
 312                             String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 313                                     item.container + &quot;, not in the list of folders&quot;;
 314                             RuntimeException e = new RuntimeException(msg);
 315                             e.setStackTrace(stackTrace);
 316                             Launcher.dumpDebugLogsToConsole();
 317                             throw e;
 318                         }
 319                     }
 320 
 321                 // Items are added/removed from the corresponding FolderInfo elsewhere, such
 322                 // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 323                 // that are on the desktop, as appropriate
 324                 if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 325                         modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 326 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 327                         switch (modelItem.itemType) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 328                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 329                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 330                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 331                                 if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 332                                     sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 333                                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 334                                 break;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 335                             default:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 336                                 break;</span>
 337 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 338                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 339                     sWorkspaceItems.remove(modelItem);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 340                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 341             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 342         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 343 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 344         if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 345             r.run();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 346         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 347             sWorker.post(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 348         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 349     }</span>
 350 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 351                         if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 352                             sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 353 </span>
 354 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 355                     }
 356                 } else {
 357                         sBgWorkspaceItems.remove(modelItem);
 358                     }
 359                 }
 360             }
 361         };
 362         runOnWorkerThread(r);
 363     }
 364 
 365     /**
 366      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 367      */
 368     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 369             final int screen, final int cellX, final int cellY) {
 370         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +
 371                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +
 372                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 373         Launcher.sDumpLogs.add(transaction);
 374         Log.d(TAG, transaction);
 375         item.container = container;
 376         item.cellX = cellX;
 377         item.cellY = cellY;
 378 
 379         // We store hotseat items in canonical form which is this orientation invariant position
 380         // in the hotseat
 381         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 382                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 383             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 384         } else {
 385             item.screen = screen;
 386         }
 387 
 388         final ContentValues values = new ContentValues();
 389         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 390         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 391         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 392         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 393 
 394         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 395     }
 396 
 397     /**
 398      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 399      */
 400     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 401             final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
 402         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +
 403                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +
 404                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 405         Launcher.sDumpLogs.add(transaction);
 406         Log.d(TAG, transaction);
 407         item.cellX = cellX;
 408         item.cellY = cellY;
 409         item.spanX = spanX;
 410         item.spanY = spanY;
 411 
 412         // We store hotseat items in canonical form which is this orientation invariant position
 413         // in the hotseat
 414         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 415                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 416             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 417         } else {
 418             item.screen = screen;
 419         }
 420 
 421         final ContentValues values = new ContentValues();
 422         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 423         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 424         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 425         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 426         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 427         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 428 
 429         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 430     }
 431 
 432     /**
 433      * Update an item to the database in a specified container.
 434      */
 435     static void updateItemInDatabase(Context context, final ItemInfo item) {
 436         final ContentValues values = new ContentValues();
 437         item.onAddToDatabase(values);
 438         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 439         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 440     }
 441 
 442     /**
 443      * Returns true if the shortcuts already exists in the database.
 444      * we identify a shortcut by its title and intent.
 445      */
 446     static boolean shortcutExists(Context context, String title, Intent intent) {
 447         final ContentResolver cr = context.getContentResolver();
 448         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 449             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 450             new String[] { title, intent.toUri(0) }, null);
 451         boolean result = false;
 452         try {
 453             result = c.moveToFirst();
 454         } finally {
 455             c.close();
 456         }
 457         return result;
 458     }
 459 
 460     /**
 461      * Returns an ItemInfo array containing all the items in the LauncherModel.
 462      * The ItemInfo.id is not set through this function.
 463      */
 464     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 465         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 466         final ContentResolver cr = context.getContentResolver();
 467         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 468                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 469                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 469                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 470                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 471 
 472         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 473         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 474         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 475         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 476         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 477         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 478         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 479 
 480         try {
 481             while (c.moveToNext()) {
 482                 ItemInfo item = new ItemInfo();
 483                 item.cellX = c.getInt(cellXIndex);
 484                 item.cellY = c.getInt(cellYIndex);
 485                 item.spanX = c.getInt(spanXIndex);
 486                 item.spanY = c.getInt(spanYIndex);
 487                 item.container = c.getInt(containerIndex);
 488                 item.itemType = c.getInt(itemTypeIndex);
 489                 item.screen = c.getInt(screenIndex);
 490 
 491                 items.add(item);
 492             }
 493         } catch (Exception e) {
 494             items.clear();
 495         } finally {
 496             c.close();
 497         }
 498 
 499         return items;
 500     }
 501 
 502     /**
 503      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 504      */
 505     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 506         final ContentResolver cr = context.getContentResolver();
 507         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 508                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 509                 new String[] { String.valueOf(id),
 510                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 511 
 512         try {
 513             if (c.moveToFirst()) {
 514                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 515                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 516                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 517                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 518                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 519                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 520 
 521                 FolderInfo folderInfo = null;
 522                 switch (c.getInt(itemTypeIndex)) {
 523                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 524                         folderInfo = findOrMakeFolder(folderList, id);
 525                         break;
 526                 }
 527 
 528                 folderInfo.title = c.getString(titleIndex);
 529                 folderInfo.id = id;
 530                 folderInfo.container = c.getInt(containerIndex);
 531                 folderInfo.screen = c.getInt(screenIndex);
 532                 folderInfo.cellX = c.getInt(cellXIndex);
 533                 folderInfo.cellY = c.getInt(cellYIndex);
 534 
 535                 return folderInfo;
 536             }
 537         } finally {
 538             c.close();
 539         }
 540 
 541         return null;
 542     }
 543 
 544     /**
 545      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 546      * cellY fields of the item. Also assigns an ID to the item.
 547      */
 548     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 549             final int screen, final int cellX, final int cellY, final boolean notify) {
 550         item.container = container;
 551         item.cellX = cellX;
 552         item.cellY = cellY;
 553         // We store hotseat items in canonical form which is this orientation invariant position
 554         // in the hotseat
 555         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 556                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 557             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 558         } else {
 559             item.screen = screen;
 560         }
 561 
 562         final ContentValues values = new ContentValues();
 563         final ContentResolver cr = context.getContentResolver();
 564         item.onAddToDatabase(values);
 565 
 566         LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 567         item.id = app.getLauncherProvider().generateNewId();
 568         values.put(LauncherSettings.Favorites._ID, item.id);
 569         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 570 
 571         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 572 
 573         Runnable r = new Runnable() {
 574             public void run() {
 575                 String transaction = &quot;DbDebug    Add item (&quot; + item.title + &quot;) to db, id: &quot;
 576                         + item.id + &quot; (&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot;
 577                         + cellY + &quot;)&quot;;
 578                 Launcher.sDumpLogs.add(transaction);
 579                 Log.d(TAG, transaction);
 580 
 581                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 582                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 583 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 584 </span>
 585 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 586 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 587                 if (sItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 588                     // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 589                     throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 590                         &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 591                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 592                 sItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 593                 switch (item.itemType) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 594                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
 595 =======
 596 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 597                 // Lock on mBgLock *after* the db operation
 598                 synchronized (sBgLock) {
 599                     if (sBgItemsIdMap.containsKey(item.id)) {
 600                     // we should not be adding new items in the db with the same id
 601                     throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +
 602                         &quot;addItemToDatabase already exists.&quot; + item.toString());
 603                 }
 604                     sBgItemsIdMap.put(item.id, item);
 605                 switch (item.itemType) {
 606                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 607                             sBgFolders.put(item.id, (FolderInfo) item);
 608                         // Fall through
 609                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 610                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 611                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 612                                 item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 613                                 sBgWorkspaceItems.add(item);
 614 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 615                             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 616                                 if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 617                                     // Adding an item to a folder that doesn&#x27;t exist.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 618                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 619                                             &quot; doesn&#x27;t exist&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 620                                     RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 621                                     e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 622                                     Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 623                                     throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 624                                 }</span>
 625 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 626                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 627                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 628                         sAppWidgets.add((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 629                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 630                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 631             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 632         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 633 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 634         if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 635             r.run();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 636         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 637             sWorker.post(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 638         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 639     }</span>
 640 =======
 641 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 642                         }
 643                         break;
 644                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 645                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 646                         break;
 647                 }
 648             }
 649         }
 650         };
 651         runOnWorkerThread(r);
 652     }
 653 
 654     /**
 655      * Creates a new unique child id, for a given cell span across all layouts.
 656      */
 657     static int getCellLayoutChildId(
 658             long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 659         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 660                 | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 661     }
 662 
 663     static int getCellCountX() {
 664         return mCellCountX;
 665     }
 666 
 667     static int getCellCountY() {
 668         return mCellCountY;
 669     }
 670 
 671     /**
 672      * Updates the model orientation helper to take into account the current layout dimensions
 673      * when performing local/canonical coordinate transformations.
 674      */
 675     static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 676         mCellCountX = shortAxisCellCount;
 677         mCellCountY = longAxisCellCount;
 678     }
 679 
 680     /**
 681      * Removes the specified item from the database
 682      * @param context
 683      * @param item
 684      */
 685     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 686         final ContentResolver cr = context.getContentResolver();
 687         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
 688         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 689 
 690         Runnable r = new Runnable() {
 691             public void run() {
 692                 String transaction = &quot;DbDebug    Delete item (&quot; + item.title + &quot;) from db, id: &quot;
 693                         + item.id + &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX +
 694                         &quot;, &quot; + item.cellY + &quot;)&quot;;
 695                 Launcher.sDumpLogs.add(transaction);
 696                 Log.d(TAG, transaction);
 697 
 698                 cr.delete(uriToDelete, null, null);
 699 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 700 </span>
 701 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 702                 switch (item.itemType) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 703                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 704                         sFolders.remove(item.id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 705                         sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 706                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 707                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 708                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 709                         sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 710                         break;</span>
 711 =======
 712 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 713                 // Lock on mBgLock *after* the db operation
 714                 synchronized (sBgLock) {
 715                 switch (item.itemType) {
 716                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 717                             sBgFolders.remove(item.id);
 718 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 719                             for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 720                                 if (info.container == item.id) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 721                                     // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 722                                     // think they are contained by that folder.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 723                                     String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 724                                             &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 725                                     RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 726                                     e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 727                                     Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 728                                     throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 729                                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 730                             }</span>
 731 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 732                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 733                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 734                         sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 735                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 736                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 737                         sAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 738                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 739                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 740                 sItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 741                 sDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 742             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 743         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 744         if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 745             r.run();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 746         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 747             sWorker.post(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 748         }</span>
 749 =======
 750 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 751                             sBgWorkspaceItems.remove(item);
 752                         break;
 753                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 754                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 755                             sBgWorkspaceItems.remove(item);
 756                         break;
 757                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 758                             sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
 759                         break;
 760                 }
 761                     sBgItemsIdMap.remove(item.id);
 762                     sBgDbIconCache.remove(item);
 763                 }
 764             }
 765         };
 766         runOnWorkerThread(r);
 767     }
 768 
 769     /**
 770      * Remove the contents of the specified folder from the database
 771      */
 772     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 773         final ContentResolver cr = context.getContentResolver();
 774 
 775         Runnable r = new Runnable() {
 776             public void run() {
 777                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
 778                 // Lock on mBgLock *after* the db operation
 779                 synchronized (sBgLock) {
 780                     sBgItemsIdMap.remove(info.id);
 781                     sBgFolders.remove(info.id);
 782                     sBgDbIconCache.remove(info);
 783                     sBgWorkspaceItems.remove(info);
 784                 }
 785 
 786                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 787                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
 788                 // Lock on mBgLock *after* the db operation
 789                 synchronized (sBgLock) {
 790                 for (ItemInfo childInfo : info.contents) {
 791                         sBgItemsIdMap.remove(childInfo.id);
 792                         sBgDbIconCache.remove(childInfo);
 793                     }
 794                 }
 795             }
 796         };
 797         runOnWorkerThread(r);
 798     }
 799 
 800     /**
 801      * Set this as the current Launcher activity object for the loader.
 802      */
 803     public void initialize(Callbacks callbacks) {
 804         synchronized (mLock) {
 805             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 806         }
 807     }
 808 
 809     /**
 810      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 811      * ACTION_PACKAGE_CHANGED.
 812      */
 813     @Override
 814     public void onReceive(Context context, Intent intent) {
 815         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 816 
 817         final String action = intent.getAction();
 818 
 819         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 820                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 821                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 822             final String packageName = intent.getData().getSchemeSpecificPart();
 823             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 824 
 825             int op = PackageUpdatedTask.OP_NONE;
 826 
 827             if (packageName == null || packageName.length() == 0) {
 828                 // they sent us a bad intent
 829                 return;
 830             }
 831 
 832             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 833                 op = PackageUpdatedTask.OP_UPDATE;
 834             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 835                 if (!replacing) {
 836                     op = PackageUpdatedTask.OP_REMOVE;
 837                 }
 838                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 839                 // later, we will update the package at this time
 840             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 841                 if (!replacing) {
 842                     op = PackageUpdatedTask.OP_ADD;
 843                 } else {
 844                     op = PackageUpdatedTask.OP_UPDATE;
 845                 }
 846             }
 847 
 848             if (op != PackageUpdatedTask.OP_NONE) {
 849                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 850             }
 851 
 852         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 853             // First, schedule to add these apps back in.
 854             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 855             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 856             // Then, rebind everything.
 857             startLoaderFromBackground();
 858         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 859             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 860             enqueuePackageUpdated(new PackageUpdatedTask(
 861                         PackageUpdatedTask.OP_UNAVAILABLE, packages));
 862         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 863             // If we have changed locale we need to clear out the labels in all apps/workspace.
 864             forceReload();
 865         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 866              // Check if configuration change was an mcc/mnc change which would affect app resources
 867              // and we would need to clear out the labels in all apps/workspace. Same handling as
 868              // above for ACTION_LOCALE_CHANGED
 869              Configuration currentConfig = context.getResources().getConfiguration();
 870              if (mPreviousConfigMcc != currentConfig.mcc) {
 871                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 872                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 873                    forceReload();
 874              }
 875              // Update previousConfig
 876              mPreviousConfigMcc = currentConfig.mcc;
 877         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 878                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 879             if (mCallbacks != null) {
 880                 Callbacks callbacks = mCallbacks.get();
 881                 if (callbacks != null) {
 882                     callbacks.bindSearchablesChanged();
 883                 }
 884             }
 885         }
 886     }
 887 
 888     private void forceReload() {
 889         resetLoadedState(true, true);
 890 
 891         // Do this here because if the launcher activity is running it will be restarted.
 892         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 893         // to reload.
 894         startLoaderFromBackground();
 895     }
 896 
 897     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 898         synchronized (mLock) {
 899             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 900             // mWorkspaceLoaded to true later
 901             stopLoaderLocked();
 902             if (resetAllAppsLoaded) mAllAppsLoaded = false;
 903             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 904         }
 905     }
 906 
 907     /**
 908      * When the launcher is in the background, it&#x27;s possible for it to miss paired
 909      * configuration changes.  So whenever we trigger the loader from the background
 910      * tell the launcher that it needs to re-run the loader when it comes back instead
 911      * of doing it now.
 912      */
 913     public void startLoaderFromBackground() {
 914         boolean runLoader = false;
 915         if (mCallbacks != null) {
 916             Callbacks callbacks = mCallbacks.get();
 917             if (callbacks != null) {
 918                 // Only actually run the loader if they&#x27;re not paused.
 919                 if (!callbacks.setLoadOnResume()) {
 920                     runLoader = true;
 921                 }
 922             }
 923         }
 924         if (runLoader) {
 925             startLoader(false, -1);
 926         }
 927     }
 928 
 929     // If there is already a loader task running, tell it to stop.
 930     // returns true if isLaunching() was true on the old task
 931     private boolean stopLoaderLocked() {
 932         boolean isLaunching = false;
 933         LoaderTask oldTask = mLoaderTask;
 934         if (oldTask != null) {
 935             if (oldTask.isLaunching()) {
 936                 isLaunching = true;
 937             }
 938             oldTask.stopLocked();
 939         }
 940         return isLaunching;
 941     }
 942 
 943     public void startLoader(boolean isLaunching, int synchronousBindPage) {
 944         synchronized (mLock) {
 945             if (DEBUG_LOADERS) {
 946                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 947             }
 948 
 949             // Clear any deferred bind-runnables from the synchronized load process
 950             // We must do this before any loading/binding is scheduled below.
 951             mDeferredBindRunnables.clear();
 952 
 953             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 954             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 955                 // If there is already one running, tell it to stop.
 956                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 957                 isLaunching = isLaunching || stopLoaderLocked();
 958                 mLoaderTask = new LoaderTask(mApp, isLaunching);
 959                 if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
 960                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
 961                 } else {
 962                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
 963                     sWorker.post(mLoaderTask);
 964                 }
 965             }
 966         }
 967     }
 968 
 969     void bindRemainingSynchronousPages() {
 970         // Post the remaining side pages to be loaded
 971         if (!mDeferredBindRunnables.isEmpty()) {
 972             for (final Runnable r : mDeferredBindRunnables) {
 973                 mHandler.post(r);
 974             }
 975             mDeferredBindRunnables.clear();
 976         }
 977     }
 978 
 979     public void stopLoader() {
 980         synchronized (mLock) {
 981             if (mLoaderTask != null) {
 982                 mLoaderTask.stopLocked();
 983             }
 984         }
 985     }
 986 
 987     public boolean isAllAppsLoaded() {
 988         return mAllAppsLoaded;
 989     }
 990 
 991     boolean isLoadingWorkspace() {
 992         synchronized (mLock) {
 993             if (mLoaderTask != null) {
 994                 return mLoaderTask.isLoadingWorkspace();
 995             }
 996         }
 997         return false;
 998     }
 999 
1000     /**
1001      * Runnable for the thread that loads the contents of the launcher:
1002      *   - workspace icons
1003      *   - widgets
1004      *   - all apps icons
1005      */
1006     private class LoaderTask implements Runnable {
1007         private Context mContext;
1008         private boolean mIsLaunching;
1009         private boolean mIsLoadingAndBindingWorkspace;
1010         private boolean mStopped;
1011         private boolean mLoadAndBindStepFinished;
1012 
1013         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1014 
1015         LoaderTask(Context context, boolean isLaunching) {
1016             mContext = context;
1017             mIsLaunching = isLaunching;
1018             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1019         }
1020 
1021         boolean isLaunching() {
1022             return mIsLaunching;
1023         }
1024 
1025         boolean isLoadingWorkspace() {
1026             return mIsLoadingAndBindingWorkspace;
1027         }
1028 
1029         private void loadAndBindWorkspace() {
1030             mIsLoadingAndBindingWorkspace = true;
1031 
1032             // Load the workspace
1033             if (DEBUG_LOADERS) {
1034                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1035             }
1036 
1037             if (!mWorkspaceLoaded) {
1038                 loadWorkspace();
1039                 synchronized (LoaderTask.this) {
1040                     if (mStopped) {
1041                         return;
1042                     }
1043                     mWorkspaceLoaded = true;
1044                 }
1045             }
1046 
1047             // Bind the workspace
1048             bindWorkspace(-1);
1049         }
1050 
1051         private void waitForIdle() {
1052             // Wait until the either we&#x27;re stopped or the other threads are done.
1053             // This way we don&#x27;t start loading all apps until the workspace has settled
1054             // down.
1055             synchronized (LoaderTask.this) {
1056                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1057 
1058                 mHandler.postIdle(new Runnable() {
1059                         public void run() {
1060                             synchronized (LoaderTask.this) {
1061                                 mLoadAndBindStepFinished = true;
1062                                 if (DEBUG_LOADERS) {
1063                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1064                                 }
1065                                 LoaderTask.this.notify();
1066                             }
1067                         }
1068                     });
1069 
1070                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1071                     try {
1072                         this.wait();
1073                     } catch (InterruptedException ex) {
1074                         // Ignore
1075                     }
1076                 }
1077                 if (DEBUG_LOADERS) {
1078                     Log.d(TAG, &quot;waited &quot;
1079                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1080                             + &quot;ms for previous step to finish binding&quot;);
1081                 }
1082             }
1083         }
1084 
1085         void runBindSynchronousPage(int synchronousBindPage) {
1086             if (synchronousBindPage &lt; 0) {
1087                 // Ensure that we have a valid page index to load synchronously
1088                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1089                         &quot;valid page index&quot;);
1090             }
1091             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1092                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1093                 // loaded already (we should load everything asynchronously in that case)
1094                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1095             }
1096             synchronized (mLock) {
1097                 if (mIsLoaderTaskRunning) {
1098                     // Ensure that we are never running the background loading at this point since
1099                     // we also touch the background collections
1100                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1101                 }
1102             }
1103 
1104             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1105             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1106             //      this call is synchronous, we can get away with not locking).
1107 
1108             // Divide the set of loaded items into those that we are binding synchronously, and
1109             // everything else that is to be bound normally (asynchronously).
1110             bindWorkspace(synchronousBindPage);
1111             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1112             //      arise from that.
1113             onlyBindAllApps();
1114         }
1115 
1116         public void run() {
1117             synchronized (mLock) {
1118                 mIsLoaderTaskRunning = true;
1119             }
1120             // Optimize for end-user experience: if the Launcher is up and // running with the
1121             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1122             // workspace first (default).
1123             final Callbacks cbk = mCallbacks.get();
1124             final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1125 
1126             keep_running: {
1127                 // Elevate priority when Home launches for the first time to avoid
1128                 // starving at boot time. Staring at a blank home is not cool.
1129                 synchronized (mLock) {
1130                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1131                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1132                     android.os.Process.setThreadPriority(mIsLaunching
1133                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1134                 }
1135                 if (loadWorkspaceFirst) {
1136                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1137                     loadAndBindWorkspace();
1138                 } else {
1139                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1140                     loadAndBindAllApps();
1141                 }
1142 
1143                 if (mStopped) {
1144                     break keep_running;
1145                 }
1146 
1147                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1148                 // settled down.
1149                 synchronized (mLock) {
1150                     if (mIsLaunching) {
1151                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1152                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1153                     }
1154                 }
1155                 waitForIdle();
1156 
1157                 // second step
1158                 if (loadWorkspaceFirst) {
1159                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1160                     loadAndBindAllApps();
1161                 } else {
1162                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1163                     loadAndBindWorkspace();
1164                 }
1165 
1166                 // Restore the default thread priority after we are done loading items
1167                 synchronized (mLock) {
1168                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1169                 }
1170             }
1171 
1172 
1173             // Update the saved icons if necessary
1174             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1175             synchronized (sBgLock) {
1176                 for (Object key : sBgDbIconCache.keySet()) {
1177                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1178             }
1179                 sBgDbIconCache.clear();
1180             }
1181 
1182             // Clear out this reference, otherwise we end up holding it until all of the
1183             // callback runnables are done.
1184             mContext = null;
1185 
1186             synchronized (mLock) {
1187                 // If we are still the last one to be scheduled, remove ourselves.
1188                 if (mLoaderTask == this) {
1189                     mLoaderTask = null;
1190                 }
1191                 mIsLoaderTaskRunning = false;
1192             }
1193         }
1194 
1195         public void stopLocked() {
1196             synchronized (LoaderTask.this) {
1197                 mStopped = true;
1198                 this.notify();
1199             }
1200         }
1201 
1202         /**
1203          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1204          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1205          * object that was around when the deferred message was scheduled, and if there&#x27;s
1206          * a new Callbacks object around then also return null.  This will save us from
1207          * calling onto it with data that will be ignored.
1208          */
1209         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1210             synchronized (mLock) {
1211                 if (mStopped) {
1212                     return null;
1213                 }
1214 
1215                 if (mCallbacks == null) {
1216                     return null;
1217                 }
1218 
1219                 final Callbacks callbacks = mCallbacks.get();
1220                 if (callbacks != oldCallbacks) {
1221                     return null;
1222                 }
1223                 if (callbacks == null) {
1224                     Log.w(TAG, &quot;no mCallbacks&quot;);
1225                     return null;
1226                 }
1227 
1228                 return callbacks;
1229             }
1230         }
1231 
1232         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1233         private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1234             int containerIndex = item.screen;
1235             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1236                 // Return early if we detect that an item is under the hotseat button
1237                 if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1238                     return false;
1239                 }
1240 
1241                 // We use the last index to refer to the hotseat and the screen as the rank, so
1242                 // test and update the occupied state accordingly
1243                 if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1244                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1245                         + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1246                         + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1247                     return false;
1248                 } else {
1249                     occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1250                     return true;
1251                 }
1252             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1253                 // Skip further checking if it is not the hotseat or workspace container
1254                 return true;
1255             }
1256 
1257             // Check if any workspace icons overlap with each other
1258             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1259                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1260                     if (occupied[containerIndex][x][y] != null) {
1261                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1262                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1263                             + x + &quot;,&quot; + y
1264                             + &quot;) occupied by &quot;
1265                             + occupied[containerIndex][x][y]);
1266                         return false;
1267                     }
1268                 }
1269             }
1270             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1271                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1272                     occupied[containerIndex][x][y] = item;
1273                 }
1274             }
1275 
1276             return true;
1277         }
1278 
1279         private void loadWorkspace() {
1280             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1281 
1282             final Context context = mContext;
1283             final ContentResolver contentResolver = context.getContentResolver();
1284             final PackageManager manager = context.getPackageManager();
1285             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1286             final boolean isSafeMode = manager.isSafeMode();
1287 
1288             // Make sure the default workspace is loaded, if needed
1289             mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1290 
1291             synchronized (sBgLock) {
1292                 sBgWorkspaceItems.clear();
1293                 sBgAppWidgets.clear();
1294                 sBgFolders.clear();
1295                 sBgItemsIdMap.clear();
1296                 sBgDbIconCache.clear();
1297 
1298             final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1299 
1300             final Cursor c = contentResolver.query(
1301                     LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);
1302 
1303             // +1 for the hotseat (it can be larger than the workspace)
1304             // Load workspace in reverse order to ensure that latest items are loaded first (and
1305             // before any earlier duplicates)
1306             final ItemInfo occupied[][][] =
1307                     new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];
1308 
1309             try {
1310                 final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1311                 final int intentIndex = c.getColumnIndexOrThrow
1312                         (LauncherSettings.Favorites.INTENT);
1313                 final int titleIndex = c.getColumnIndexOrThrow
1314                         (LauncherSettings.Favorites.TITLE);
1315                 final int iconTypeIndex = c.getColumnIndexOrThrow(
1316                         LauncherSettings.Favorites.ICON_TYPE);
1317                 final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1318                 final int iconPackageIndex = c.getColumnIndexOrThrow(
1319                         LauncherSettings.Favorites.ICON_PACKAGE);
1320                 final int iconResourceIndex = c.getColumnIndexOrThrow(
1321                         LauncherSettings.Favorites.ICON_RESOURCE);
1322                 final int containerIndex = c.getColumnIndexOrThrow(
1323                         LauncherSettings.Favorites.CONTAINER);
1324                 final int itemTypeIndex = c.getColumnIndexOrThrow(
1325                         LauncherSettings.Favorites.ITEM_TYPE);
1326                 final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1327                         LauncherSettings.Favorites.APPWIDGET_ID);
1328                 final int screenIndex = c.getColumnIndexOrThrow(
1329                         LauncherSettings.Favorites.SCREEN);
1330                 final int cellXIndex = c.getColumnIndexOrThrow
1331                         (LauncherSettings.Favorites.CELLX);
1332                 final int cellYIndex = c.getColumnIndexOrThrow
1333                         (LauncherSettings.Favorites.CELLY);
1334                 final int spanXIndex = c.getColumnIndexOrThrow
1335                         (LauncherSettings.Favorites.SPANX);
1336                 final int spanYIndex = c.getColumnIndexOrThrow(
1337                         LauncherSettings.Favorites.SPANY);
1338                 //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1339                 //final int displayModeIndex = c.getColumnIndexOrThrow(
1340                 //        LauncherSettings.Favorites.DISPLAY_MODE);
1341 
1342                 ShortcutInfo info;
1343                 String intentDescription;
1344                 LauncherAppWidgetInfo appWidgetInfo;
1345                 int container;
1346                 long id;
1347                 Intent intent;
1348 
1349                 while (!mStopped &amp;&amp; c.moveToNext()) {
1350                     try {
1351                         int itemType = c.getInt(itemTypeIndex);
1352 
1353                         switch (itemType) {
1354                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1355                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1356                             intentDescription = c.getString(intentIndex);
1357                             try {
1358                                 intent = Intent.parseUri(intentDescription, 0);
1359                             } catch (URISyntaxException e) {
1360                                 continue;
1361                             }
1362 
1363                             if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1364                                 info = getShortcutInfo(manager, intent, context, c, iconIndex,
1365                                         titleIndex, mLabelCache);
1366                             } else {
1367                                 info = getShortcutInfo(c, context, iconTypeIndex,
1368                                         iconPackageIndex, iconResourceIndex, iconIndex,
1369                                         titleIndex);
1370 
1371                                 // App shortcuts that used to be automatically added to Launcher
1372                                     // didn&#x27;t always have the correct intent flags set, so do that
1373                                     // here
1374                                 if (intent.getAction() != null &amp;&amp;
1375                                         intent.getCategories() != null &amp;&amp;
1376                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1377                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1378                                     intent.addFlags(
1379                                         Intent.FLAG_ACTIVITY_NEW_TASK |
1380                                         Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1381                                 }
1382                             }
1383 
1384                             if (info != null) {
1385                                 info.intent = intent;
1386                                 info.id = c.getLong(idIndex);
1387                                 container = c.getInt(containerIndex);
1388                                 info.container = container;
1389                                 info.screen = c.getInt(screenIndex);
1390                                 info.cellX = c.getInt(cellXIndex);
1391                                 info.cellY = c.getInt(cellYIndex);
1392 
1393                                 // check &amp; update map of what&#x27;s occupied
1394                                 if (!checkItemPlacement(occupied, info)) {
1395                                     break;
1396                                 }
1397 
1398                                 switch (container) {
1399                                 case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1400                                 case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1401                                         sBgWorkspaceItems.add(info);
1402                                     break;
1403                                 default:
1404                                     // Item is in a user folder
1405                                     FolderInfo folderInfo =
1406                                                 findOrMakeFolder(sBgFolders, container);
1407                                     folderInfo.add(info);
1408                                     break;
1409                                 }
1410                                     sBgItemsIdMap.put(info.id, info);
1411 
1412                                 // now that we&#x27;ve loaded everthing re-save it with the
1413                                 // icon in case it disappears somehow.
1414                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1415                             } else {
1416                                 // Failed to load the shortcut, probably because the
1417                                 // activity manager couldn&#x27;t resolve it (maybe the app
1418                                 // was uninstalled), or the db row was somehow screwed up.
1419                                 // Delete it.
1420                                 id = c.getLong(idIndex);
1421                                 Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);
1422                                 contentResolver.delete(LauncherSettings.Favorites.getContentUri(
1423                                             id, false), null, null);
1424                             }
1425                             break;
1426 
1427                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1428                             id = c.getLong(idIndex);
1429                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1430 
1431                             folderInfo.title = c.getString(titleIndex);
1432                             folderInfo.id = id;
1433                             container = c.getInt(containerIndex);
1434                             folderInfo.container = container;
1435                             folderInfo.screen = c.getInt(screenIndex);
1436                             folderInfo.cellX = c.getInt(cellXIndex);
1437                             folderInfo.cellY = c.getInt(cellYIndex);
1438 
1439                             // check &amp; update map of what&#x27;s occupied
1440                             if (!checkItemPlacement(occupied, folderInfo)) {
1441                                 break;
1442                             }
1443                             switch (container) {
1444                                 case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1445                                 case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1446                                         sBgWorkspaceItems.add(folderInfo);
1447                                     break;
1448                             }
1449 
1450                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
1451                                 sBgFolders.put(folderInfo.id, folderInfo);
1452                             break;
1453 
1454                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1455                             // Read all Launcher-specific widget details
1456                             int appWidgetId = c.getInt(appWidgetIdIndex);
1457                             id = c.getLong(idIndex);
1458 
1459                             final AppWidgetProviderInfo provider =
1460                                     widgets.getAppWidgetInfo(appWidgetId);
1461 
1462                             if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
1463                                     provider.provider.getPackageName() == null)) {
1464                                 String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
1465                                     + id + &quot; appWidgetId=&quot; + appWidgetId;
1466                                 Log.e(TAG, log);
1467                                 Launcher.sDumpLogs.add(log);
1468                                 itemsToRemove.add(id);
1469                             } else {
1470                                 appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
1471                                         provider.provider);
1472                                 appWidgetInfo.id = id;
1473                                 appWidgetInfo.screen = c.getInt(screenIndex);
1474                                 appWidgetInfo.cellX = c.getInt(cellXIndex);
1475                                 appWidgetInfo.cellY = c.getInt(cellYIndex);
1476                                 appWidgetInfo.spanX = c.getInt(spanXIndex);
1477                                 appWidgetInfo.spanY = c.getInt(spanYIndex);
1478                                 int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1479                                 appWidgetInfo.minSpanX = minSpan[0];
1480                                 appWidgetInfo.minSpanY = minSpan[1];
1481 
1482                                 container = c.getInt(containerIndex);
1483                                 if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1484                                     container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1485                                         Log.e(TAG, &quot;Widget found where container != &quot; +
1486                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
1487                                     continue;
1488                                 }
1489                                 appWidgetInfo.container = c.getInt(containerIndex);
1490 
1491                                 // check &amp; update map of what&#x27;s occupied
1492                                 if (!checkItemPlacement(occupied, appWidgetInfo)) {
1493                                     break;
1494                                 }
1495                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1496                                     sBgAppWidgets.add(appWidgetInfo);
1497                             }
1498                             break;
1499                         }
1500                     } catch (Exception e) {
1501                         Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);
1502                     }
1503                 }
1504             } finally {
1505                 c.close();
1506             }
1507 
1508             if (itemsToRemove.size() &gt; 0) {
1509                 ContentProviderClient client = contentResolver.acquireContentProviderClient(
1510                                 LauncherSettings.Favorites.CONTENT_URI);
1511                 // Remove dead items
1512                 for (long id : itemsToRemove) {
1513                     if (DEBUG_LOADERS) {
1514                         Log.d(TAG, &quot;Removed id = &quot; + id);
1515                     }
1516                     // Don&#x27;t notify content observers
1517                     try {
1518                         client.delete(LauncherSettings.Favorites.getContentUri(id, false),
1519                                 null, null);
1520                     } catch (RemoteException e) {
1521                         Log.w(TAG, &quot;Could not remove id = &quot; + id);
1522                     }
1523                 }
1524             }
1525 
1526             if (DEBUG_LOADERS) {
1527                 Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1528                 Log.d(TAG, &quot;workspace layout: &quot;);
1529                 for (int y = 0; y &lt; mCellCountY; y++) {
1530                     String line = &quot;&quot;;
1531                     for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {
1532                         if (s &gt; 0) {
1533                             line += &quot; | &quot;;
1534                         }
1535                         for (int x = 0; x &lt; mCellCountX; x++) {
1536                             line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
1537                         }
1538                     }
1539                     Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
1540                 }
1541             }
1542         }
1543         }
1544 
1545         /** Filters the set of items who are directly or indirectly (via another container) on the
1546          * specified screen. */
1547         private void filterCurrentWorkspaceItems(int currentScreen,
1548                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
1549                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
1550                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
1551             // Purge any null ItemInfos
1552             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
1553             while (iter.hasNext()) {
1554                 ItemInfo i = iter.next();
1555                 if (i == null) {
1556                     iter.remove();
1557                 }
1558             }
1559 
1560             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1561             // items given.
1562             if (currentScreen &lt; 0) {
1563                 currentScreenItems.addAll(allWorkspaceItems);
1564             }
1565 
1566             // Order the set of items by their containers first, this allows use to walk through the
1567             // list sequentially, build up a list of containers that are in the specified screen,
1568             // as well as all items in those containers.
1569             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
1570             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
1571                 @Override
1572                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1573                     return (int) (lhs.container - rhs.container);
1574                 }
1575             });
1576             for (ItemInfo info : allWorkspaceItems) {
1577                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1578                     if (info.screen == currentScreen) {
1579                         currentScreenItems.add(info);
1580                         itemsOnScreen.add(info.id);
1581                     } else {
1582                         otherScreenItems.add(info);
1583                     }
1584                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1585                     currentScreenItems.add(info);
1586                     itemsOnScreen.add(info.id);
1587                 } else {
1588                     if (itemsOnScreen.contains(info.container)) {
1589                         currentScreenItems.add(info);
1590                         itemsOnScreen.add(info.id);
1591                     } else {
1592                         otherScreenItems.add(info);
1593                     }
1594                 }
1595             }
1596         }
1597 
1598         /** Filters the set of widgets which are on the specified screen. */
1599         private void filterCurrentAppWidgets(int currentScreen,
1600                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1601                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
1602                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
1603             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1604             // widgets given.
1605             if (currentScreen &lt; 0) {
1606                 currentScreenWidgets.addAll(appWidgets);
1607             }
1608 
1609             for (LauncherAppWidgetInfo widget : appWidgets) {
1610                 if (widget == null) continue;
1611                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1612                         widget.screen == currentScreen) {
1613                     currentScreenWidgets.add(widget);
1614                 } else {
1615                     otherScreenWidgets.add(widget);
1616                 }
1617             }
1618         }
1619 
1620         /** Filters the set of folders which are on the specified screen. */
1621         private void filterCurrentFolders(int currentScreen,
1622                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
1623                 HashMap&lt;Long, FolderInfo&gt; folders,
1624                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
1625                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
1626             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1627             // widgets given.
1628             if (currentScreen &lt; 0) {
1629                 currentScreenFolders.putAll(folders);
1630             }
1631 
1632             for (long id : folders.keySet()) {
1633                 ItemInfo info = itemsIdMap.get(id);
1634                 FolderInfo folder = folders.get(id);
1635                 if (info == null || folder == null) continue;
1636                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1637                         info.screen == currentScreen) {
1638                     currentScreenFolders.put(id, folder);
1639                 } else {
1640                     otherScreenFolders.put(id, folder);
1641                 }
1642             }
1643         }
1644 
1645         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
1646          * right) */
1647         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
1648             // XXX: review this
1649             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
1650                 @Override
1651                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1652                     int cellCountX = LauncherModel.getCellCountX();
1653                     int cellCountY = LauncherModel.getCellCountY();
1654                     int screenOffset = cellCountX * cellCountY;
1655                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1656                     long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1657                             lhs.cellY * cellCountX + lhs.cellX);
1658                     long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1659                             rhs.cellY * cellCountX + rhs.cellX);
1660                     return (int) (lr - rr);
1661                 }
1662             });
1663         }
1664 
1665         private void bindWorkspaceItems(final Callbacks oldCallbacks,
1666                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
1667                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1668                 final HashMap&lt;Long, FolderInfo&gt; folders,
1669                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
1670 
1671             final boolean postOnMainThread = (deferredBindRunnables != null);
1672 
1673             // Bind the workspace items
1674             int N = workspaceItems.size();
1675             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
1676                 final int start = i;
1677                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
1678                 final Runnable r = new Runnable() {
1679                     @Override
1680                     public void run() {
1681                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1682                         if (callbacks != null) {
1683                             callbacks.bindItems(workspaceItems, start, start+chunkSize);
1684                         }
1685                     }
1686                 };
1687                 if (postOnMainThread) {
1688                     deferredBindRunnables.add(r);
1689                 } else {
1690                     runOnMainThread(r);
1691                 }
1692             }
1693 
1694             // Bind the folders
1695             if (!folders.isEmpty()) {
1696                 final Runnable r = new Runnable() {
1697                     public void run() {
1698                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1699                         if (callbacks != null) {
1700                             callbacks.bindFolders(folders);
1701                         }
1702                     }
1703                 };
1704                 if (postOnMainThread) {
1705                     deferredBindRunnables.add(r);
1706                 } else {
1707                     runOnMainThread(r);
1708                 }
1709             }
1710 
1711             // Bind the widgets, one at a time
1712             N = appWidgets.size();
1713             for (int i = 0; i &lt; N; i++) {
1714                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
1715                 final Runnable r = new Runnable() {
1716                     public void run() {
1717                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1718                         if (callbacks != null) {
1719                             callbacks.bindAppWidget(widget);
1720                         }
1721                     }
1722                 };
1723                 if (postOnMainThread) {
1724                     deferredBindRunnables.add(r);
1725                 } else {
1726                     runOnMainThread(r);
1727                 }
1728             }
1729         }
1730 
1731         /**
1732          * Binds all loaded data to actual views on the main thread.
1733          */
1734         private void bindWorkspace(int synchronizeBindPage) {
1735             final long t = SystemClock.uptimeMillis();
1736             Runnable r;
1737 
1738             // Don&#x27;t use these two variables in any of the callback runnables.
1739             // Otherwise we hold a reference to them.
1740             final Callbacks oldCallbacks = mCallbacks.get();
1741             if (oldCallbacks == null) {
1742                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1743                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
1744                 return;
1745             }
1746 
1747             final int currentScreen = (synchronizeBindPage &gt; -1) ? synchronizeBindPage :
1748                 oldCallbacks.getCurrentWorkspaceScreen();
1749 
1750             // Load all the items that are on the current page first (and in the process, unbind
1751             // all the existing workspace items before we call startBinding() below.
1752             unbindWorkspaceItemsOnMainThread();
1753             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
1754             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
1755                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1756             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
1757             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
1758             synchronized (sBgLock) {
1759                 workspaceItems.addAll(sBgWorkspaceItems);
1760                 appWidgets.addAll(sBgAppWidgets);
1761                 folders.putAll(sBgFolders);
1762                 itemsIdMap.putAll(sBgItemsIdMap);
1763             }
1764 
1765             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1766             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1767             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
1768                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1769             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
1770                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1771             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
1772             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
1773 
1774             // Separate the items that are on the current screen, and all the other remaining items
1775             filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,
1776                     otherWorkspaceItems);
1777             filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,
1778                     otherAppWidgets);
1779             filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,
1780                     otherFolders);
1781             sortWorkspaceItemsSpatially(currentWorkspaceItems);
1782             sortWorkspaceItemsSpatially(otherWorkspaceItems);
1783 
1784             // Tell the workspace that we&#x27;re about to start binding items
1785             r = new Runnable() {
1786                 public void run() {
1787                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1788                     if (callbacks != null) {
1789                         callbacks.startBinding();
1790                     }
1791                 }
1792             };
1793             runOnMainThread(r);
1794 
1795             // Load items on the current page
1796             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
1797                     currentFolders, null);
1798 
1799             // Load all the remaining pages
1800             mDeferredBindRunnables.clear();
1801             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
1802                     mDeferredBindRunnables);
1803 
1804             // Tell the workspace that we&#x27;re done binding items
1805             r = new Runnable() {
1806                 public void run() {
1807                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1808                     if (callbacks != null) {
1809                         callbacks.finishBindingItems();
1810                     }
1811 
1812                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
1813                     if (DEBUG_LOADERS) {
1814                         Log.d(TAG, &quot;bound workspace in &quot;
1815                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1816                     }
1817 
1818                     mIsLoadingAndBindingWorkspace = false;
1819                 }
1820             };
1821             mDeferredBindRunnables.add(r);
1822         }
1823 
1824         private void loadAndBindAllApps() {
1825             if (DEBUG_LOADERS) {
1826                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
1827             }
1828             if (!mAllAppsLoaded) {
1829                 loadAllAppsByBatch();
1830                 synchronized (LoaderTask.this) {
1831                     if (mStopped) {
1832                         return;
1833                     }
1834                     mAllAppsLoaded = true;
1835                 }
1836             } else {
1837                 onlyBindAllApps();
1838             }
1839         }
1840 
1841         private void onlyBindAllApps() {
1842             final Callbacks oldCallbacks = mCallbacks.get();
1843             if (oldCallbacks == null) {
1844                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1845                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
1846                 return;
1847             }
1848 
1849             // shallow copy
1850             @SuppressWarnings(&quot;unchecked&quot;)
1851             final ArrayList&lt;ApplicationInfo&gt; list
1852                     = (ArrayList&lt;ApplicationInfo&gt;) mBgAllAppsList.data.clone();
1853             mHandler.post(new Runnable() {
1854                 public void run() {
1855                     final long t = SystemClock.uptimeMillis();
1856                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1857                     if (callbacks != null) {
1858                         callbacks.bindAllApplications(list);
1859                     }
1860                     if (DEBUG_LOADERS) {
1861                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
1862                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1863                     }
1864                 }
1865             });
1866         }
1867 
1868         private void loadAllAppsByBatch() {
1869             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1870 
1871             // Don&#x27;t use these two variables in any of the callback runnables.
1872             // Otherwise we hold a reference to them.
1873             final Callbacks oldCallbacks = mCallbacks.get();
1874             if (oldCallbacks == null) {
1875                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1876                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
1877                 return;
1878             }
1879 
1880             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
1881             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
1882 
1883             final PackageManager packageManager = mContext.getPackageManager();
1884             List&lt;ResolveInfo&gt; apps = null;
1885 
1886             int N = Integer.MAX_VALUE;
1887 
1888             int startIndex;
1889             int i=0;
1890             int batchSize = -1;
1891             while (i &lt; N &amp;&amp; !mStopped) {
1892                 if (i == 0) {
1893                     mBgAllAppsList.clear();
1894                     final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1895                     apps = packageManager.queryIntentActivities(mainIntent, 0);
1896                     if (DEBUG_LOADERS) {
1897                         Log.d(TAG, &quot;queryIntentActivities took &quot;
1898                                 + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
1899                     }
1900                     if (apps == null) {
1901                         return;
1902                     }
1903                     N = apps.size();
1904                     if (DEBUG_LOADERS) {
1905                         Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
1906                     }
1907                     if (N == 0) {
1908                         // There are no apps?!?
1909                         return;
1910                     }
1911                     if (mBatchSize == 0) {
1912                         batchSize = N;
1913                     } else {
1914                         batchSize = mBatchSize;
1915                     }
1916 
1917                     final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1918                     Collections.sort(apps,
1919                             new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
1920                     if (DEBUG_LOADERS) {
1921                         Log.d(TAG, &quot;sort took &quot;
1922                                 + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
1923                     }
1924                 }
1925 
1926                 final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1927 
1928                 startIndex = i;
1929                 for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
1930                     // This builds the icon bitmaps.
1931                     mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),
1932                             mIconCache, mLabelCache));
1933                     i++;
1934                 }
1935 
1936                 final boolean first = i &lt;= batchSize;
1937                 final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1938                 final ArrayList&lt;ApplicationInfo&gt; added = mBgAllAppsList.added;
1939                 mBgAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();
1940 
1941                 mHandler.post(new Runnable() {
1942                     public void run() {
1943                         final long t = SystemClock.uptimeMillis();
1944                         if (callbacks != null) {
1945                             if (first) {
1946                                 callbacks.bindAllApplications(added);
1947                             } else {
1948                                 callbacks.bindAppsAdded(added);
1949                             }
1950                             if (DEBUG_LOADERS) {
1951                                 Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
1952                                     + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
1953                             }
1954                         } else {
1955                             Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
1956                         }
1957                     }
1958                 });
1959 
1960                 if (DEBUG_LOADERS) {
1961                     Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
1962                             + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
1963                 }
1964 
1965                 if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
1966                     try {
1967                         if (DEBUG_LOADERS) {
1968                             Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
1969                         }
1970                         Thread.sleep(mAllAppsLoadDelay);
1971                     } catch (InterruptedException exc) { }
1972                 }
1973             }
1974 
1975             if (DEBUG_LOADERS) {
1976                 Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
1977                         + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
1978                         + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
1979             }
1980         }
1981 
1982         public void dumpState() {
1983             synchronized (sBgLock) {
1984             Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
1985             Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
1986             Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
1987             Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
1988                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
1989             }
1990         }
1991     }
1992 
1993     void enqueuePackageUpdated(PackageUpdatedTask task) {
1994         sWorker.post(task);
1995     }
1996 
1997     private class PackageUpdatedTask implements Runnable {
1998         int mOp;
1999         String[] mPackages;
2000 
2001         public static final int OP_NONE = 0;
2002         public static final int OP_ADD = 1;
2003         public static final int OP_UPDATE = 2;
2004         public static final int OP_REMOVE = 3; // uninstlled
2005         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2006 
2007 
2008         public PackageUpdatedTask(int op, String[] packages) {
2009             mOp = op;
2010             mPackages = packages;
2011         }
2012 
2013         public void run() {
2014             final Context context = mApp;
2015 
2016             final String[] packages = mPackages;
2017             final int N = packages.length;
2018             switch (mOp) {
2019                 case OP_ADD:
2020                     for (int i=0; i&lt;N; i++) {
2021                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2022                         mBgAllAppsList.addPackage(context, packages[i]);
2023                     }
2024                     break;
2025                 case OP_UPDATE:
2026                     for (int i=0; i&lt;N; i++) {
2027                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2028                         mBgAllAppsList.updatePackage(context, packages[i]);
2029                     }
2030                     break;
2031                 case OP_REMOVE:
2032                 case OP_UNAVAILABLE:
2033                     for (int i=0; i&lt;N; i++) {
2034                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2035                         mBgAllAppsList.removePackage(packages[i]);
2036                     }
2037                     break;
2038             }
2039 
2040             ArrayList&lt;ApplicationInfo&gt; added = null;
2041             ArrayList&lt;ApplicationInfo&gt; modified = null;
2042 
2043             if (mBgAllAppsList.added.size() &gt; 0) {
2044                 added = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.added);
2045                 mBgAllAppsList.added.clear();
2046             }
2047             if (mBgAllAppsList.modified.size() &gt; 0) {
2048                 modified = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.modified);
2049                 mBgAllAppsList.modified.clear();
2050                 }
2051             // We may be removing packages that have no associated launcher application, so we
2052             // pass through the removed package names directly.
2053             // NOTE: We flush the icon cache aggressively in removePackage() above.
2054             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2055             if (mBgAllAppsList.removed.size() &gt; 0) {
2056                 mBgAllAppsList.removed.clear();
2057 
2058                 for (int i = 0; i &lt; N; ++i) {
2059                     removedPackageNames.add(packages[i]);
2060             }
2061             }
2062 
2063             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2064             if (callbacks == null) {
2065                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2066                 return;
2067             }
2068 
2069             if (added != null) {
2070                 final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
2071                 mHandler.post(new Runnable() {
2072                     public void run() {
2073                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2074                         if (callbacks == cb &amp;&amp; cb != null) {
2075                             callbacks.bindAppsAdded(addedFinal);
2076                         }
2077                     }
2078                 });
2079             }
2080             if (modified != null) {
2081                 final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
2082                 mHandler.post(new Runnable() {
2083                     public void run() {
2084                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2085                         if (callbacks == cb &amp;&amp; cb != null) {
2086                             callbacks.bindAppsUpdated(modifiedFinal);
2087                         }
2088                     }
2089                 });
2090             }
2091             if (!removedPackageNames.isEmpty()) {
2092                 final boolean permanent = mOp != OP_UNAVAILABLE;
2093                 mHandler.post(new Runnable() {
2094                     public void run() {
2095                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2096                         if (callbacks == cb &amp;&amp; cb != null) {
2097                             callbacks.bindAppsRemoved(removedPackageNames, permanent);
2098                         }
2099                     }
2100                 });
2101             }
2102 
2103             mHandler.post(new Runnable() {
2104                 @Override
2105                 public void run() {
2106                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2107                     if (callbacks == cb &amp;&amp; cb != null) {
2108                         callbacks.bindPackagesUpdated();
2109                     }
2110                 }
2111             });
2112         }
2113     }
2114 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
2115 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2116 ArrayList&lt;ShortcutInfo&gt; getShortcutInfosForPackage(String packageName) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2117         ArrayList&lt;ShortcutInfo&gt; infos = new ArrayList&lt;ShortcutInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2118         for (ItemInfo i : sWorkspaceItems) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2119             if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2120                 ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2121                 if (packageName.equals(info.getPackageName())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2122                     infos.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2123                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2124             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2125         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2126         return infos;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2127     }</span>
2128 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2129 ArrayList&lt;ShortcutInfo&gt; getShortcutInfosForPackage(String packageName) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2130         ArrayList&lt;ShortcutInfo&gt; infos = new ArrayList&lt;ShortcutInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2131         synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2132             for (ItemInfo i : sBgWorkspaceItems) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2133                 if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2134                     ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2135                     if (packageName.equals(info.getPackageName())) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2136                         infos.add(info);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2137                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2138                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2139             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2140         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2141         return infos;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2142     }</span>
2143 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
2144 
2145 
2146     /**
2147      * This is called from the code that adds shortcuts from the intent receiver.  This
2148      * doesn&#x27;t have a Cursor, but
2149      */
2150     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2151         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2152     }
2153 
2154     /**
2155      * Make an ShortcutInfo object for a shortcut that is an application.
2156      *
2157      * If c is not null, then it will be used to fill in missing data like the title and icon.
2158      */
2159     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2160             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2161         Bitmap icon = null;
2162         final ShortcutInfo info = new ShortcutInfo();
2163 
2164         ComponentName componentName = intent.getComponent();
2165         if (componentName == null) {
2166             return null;
2167         }
2168 
2169         try {
2170             PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2171             if (!pi.applicationInfo.enabled) {
2172                 // If we return null here, the corresponding item will be removed from the launcher
2173                 // db and will not appear in the workspace.
2174                 return null;
2175             }
2176         } catch (NameNotFoundException e) {
2177             Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2178         }
2179 
2180         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2181         // then return null &amp; delete this.
2182 
2183         // the resource -- This may implicitly give us back the fallback icon,
2184         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2185         // to avoid saving lots of copies of that in the database, and most apps
2186         // have icons anyway.
2187 
2188         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2189         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2190         // via resolveActivity().
2191         ResolveInfo resolveInfo = null;
2192         ComponentName oldComponent = intent.getComponent();
2193         Intent newIntent = new Intent(intent.getAction(), null);
2194         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2195         newIntent.setPackage(oldComponent.getPackageName());
2196         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2197         for (ResolveInfo i : infos) {
2198             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2199                     i.activityInfo.name);
2200             if (cn.equals(oldComponent)) {
2201                 resolveInfo = i;
2202             }
2203         }
2204         if (resolveInfo == null) {
2205             resolveInfo = manager.resolveActivity(intent, 0);
2206         }
2207         if (resolveInfo != null) {
2208             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2209         }
2210         // the db
2211         if (icon == null) {
2212             if (c != null) {
2213                 icon = getIconFromCursor(c, iconIndex, context);
2214             }
2215         }
2216         // the fallback icon
2217         if (icon == null) {
2218             icon = getFallbackIcon();
2219             info.usingFallbackIcon = true;
2220         }
2221         info.setIcon(icon);
2222 
2223         // from the resource
2224         if (resolveInfo != null) {
2225             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2226             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2227                 info.title = labelCache.get(key);
2228             } else {
2229                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2230                 if (labelCache != null) {
2231                     labelCache.put(key, info.title);
2232                 }
2233             }
2234         }
2235         // from the db
2236         if (info.title == null) {
2237             if (c != null) {
2238                 info.title =  c.getString(titleIndex);
2239             }
2240         }
2241         // fall back to the class name of the activity
2242         if (info.title == null) {
2243             info.title = componentName.getClassName();
2244         }
2245         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2246         return info;
2247     }
2248 
2249     /**
2250      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2251      */
2252     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2253             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2254             int titleIndex) {
2255 
2256         Bitmap icon = null;
2257         final ShortcutInfo info = new ShortcutInfo();
2258         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2259 
2260         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2261 
2262         info.title = c.getString(titleIndex);
2263 
2264         int iconType = c.getInt(iconTypeIndex);
2265         switch (iconType) {
2266         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2267             String packageName = c.getString(iconPackageIndex);
2268             String resourceName = c.getString(iconResourceIndex);
2269             PackageManager packageManager = context.getPackageManager();
2270             info.customIcon = false;
2271             // the resource
2272             try {
2273                 Resources resources = packageManager.getResourcesForApplication(packageName);
2274                 if (resources != null) {
2275                     final int id = resources.getIdentifier(resourceName, null, null);
2276                     icon = Utilities.createIconBitmap(
2277                             mIconCache.getFullResIcon(resources, id), context);
2278                 }
2279             } catch (Exception e) {
2280                 // drop this.  we have other places to look for icons
2281             }
2282             // the db
2283             if (icon == null) {
2284                 icon = getIconFromCursor(c, iconIndex, context);
2285             }
2286             // the fallback icon
2287             if (icon == null) {
2288                 icon = getFallbackIcon();
2289                 info.usingFallbackIcon = true;
2290             }
2291             break;
2292         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2293             icon = getIconFromCursor(c, iconIndex, context);
2294             if (icon == null) {
2295                 icon = getFallbackIcon();
2296                 info.customIcon = false;
2297                 info.usingFallbackIcon = true;
2298             } else {
2299                 info.customIcon = true;
2300             }
2301             break;
2302         default:
2303             icon = getFallbackIcon();
2304             info.usingFallbackIcon = true;
2305             info.customIcon = false;
2306             break;
2307         }
2308         info.setIcon(icon);
2309         return info;
2310     }
2311 
2312     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2313         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2314         final boolean debug = false;
2315         if (debug) {
2316             Log.d(TAG, &quot;getIconFromCursor app=&quot;
2317                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2318         }
2319         byte[] data = c.getBlob(iconIndex);
2320         try {
2321             return Utilities.createIconBitmap(
2322                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
2323         } catch (Exception e) {
2324             return null;
2325         }
2326     }
2327 
2328     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2329             int cellX, int cellY, boolean notify) {
2330         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2331         if (info == null) {
2332             return null;
2333         }
2334         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2335 
2336         return info;
2337     }
2338 
2339     /**
2340      * Attempts to find an AppWidgetProviderInfo that matches the given component.
2341      */
2342     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2343             ComponentName component) {
2344         List&lt;AppWidgetProviderInfo&gt; widgets =
2345             AppWidgetManager.getInstance(context).getInstalledProviders();
2346         for (AppWidgetProviderInfo info : widgets) {
2347             if (info.provider.equals(component)) {
2348                 return info;
2349             }
2350         }
2351         return null;
2352     }
2353 
2354     /**
2355      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2356      */
2357     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2358         final PackageManager packageManager = context.getPackageManager();
2359         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2360             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2361 
2362         final Intent supportsIntent =
2363             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2364         supportsIntent.setType(mimeType);
2365 
2366         // Create a set of widget configuration components that we can test against
2367         final List&lt;AppWidgetProviderInfo&gt; widgets =
2368             AppWidgetManager.getInstance(context).getInstalledProviders();
2369         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2370             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2371         for (AppWidgetProviderInfo info : widgets) {
2372             configurationComponentToWidget.put(info.configure, info);
2373         }
2374 
2375         // Run through each of the intents that can handle this type of clip data, and cross
2376         // reference them with the components that are actual configuration components
2377         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2378                 PackageManager.MATCH_DEFAULT_ONLY);
2379         for (ResolveInfo info : activities) {
2380             final ActivityInfo activityInfo = info.activityInfo;
2381             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2382                     activityInfo.name);
2383             if (configurationComponentToWidget.containsKey(infoComponent)) {
2384                 supportedConfigurationActivities.add(
2385                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2386                                 configurationComponentToWidget.get(infoComponent)));
2387             }
2388         }
2389         return supportedConfigurationActivities;
2390     }
2391 
2392     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2393         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2394         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2395         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2396 
2397         if (intent == null) {
2398             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2399             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2400             return null;
2401         }
2402 
2403         Bitmap icon = null;
2404         boolean customIcon = false;
2405         ShortcutIconResource iconResource = null;
2406 
2407         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2408             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2409             customIcon = true;
2410         } else {
2411             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2412             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2413                 try {
2414                     iconResource = (ShortcutIconResource) extra;
2415                     final PackageManager packageManager = context.getPackageManager();
2416                     Resources resources = packageManager.getResourcesForApplication(
2417                             iconResource.packageName);
2418                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2419                     icon = Utilities.createIconBitmap(
2420                             mIconCache.getFullResIcon(resources, id), context);
2421                 } catch (Exception e) {
2422                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2423                 }
2424             }
2425         }
2426 
2427         final ShortcutInfo info = new ShortcutInfo();
2428 
2429         if (icon == null) {
2430             if (fallbackIcon != null) {
2431                 icon = fallbackIcon;
2432             } else {
2433                 icon = getFallbackIcon();
2434                 info.usingFallbackIcon = true;
2435             }
2436         }
2437         info.setIcon(icon);
2438 
2439         info.title = name;
2440         info.intent = intent;
2441         info.customIcon = customIcon;
2442         info.iconResource = iconResource;
2443 
2444         return info;
2445     }
2446 
2447     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2448             int iconIndex) {
2449         // If apps can&#x27;t be on SD, don&#x27;t even bother.
2450         if (!mAppsCanBeOnExternalStorage) {
2451             return false;
2452         }
2453         // If this icon doesn&#x27;t have a custom icon, check to see
2454         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2455         // we&#x27;re going to show, store what we are going to show back
2456         // into the DB.  We do this so when we&#x27;re loading, if the
2457         // package manager can&#x27;t find an icon (for example because
2458         // the app is on SD) then we can use that instead.
2459         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2460             cache.put(info, c.getBlob(iconIndex));
2461             return true;
2462         }
2463         return false;
2464     }
2465     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2466         boolean needSave = false;
2467         try {
2468             if (data != null) {
2469                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2470                 Bitmap loaded = info.getIcon(mIconCache);
2471                 needSave = !saved.sameAs(loaded);
2472             } else {
2473                 needSave = true;
2474             }
2475         } catch (Exception e) {
2476             needSave = true;
2477         }
2478         if (needSave) {
2479             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2480             // This is slower than is ideal, but this only happens once
2481             // or when the app is updated with a new icon.
2482             updateItemInDatabase(context, info);
2483         }
2484     }
2485 
2486     /**
2487      * Return an existing FolderInfo object if we have encountered this ID previously,
2488      * or make a new one.
2489      */
2490     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2491         // See if a placeholder was created for us already
2492         FolderInfo folderInfo = folders.get(id);
2493         if (folderInfo == null) {
2494             // No placeholder -- create a new instance
2495             folderInfo = new FolderInfo();
2496             folders.put(id, folderInfo);
2497         }
2498         return folderInfo;
2499     }
2500 
2501     private static final Collator sCollator = Collator.getInstance();
2502     public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2503             = new Comparator&lt;ApplicationInfo&gt;() {
2504         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2505             int result = sCollator.compare(a.title.toString(), b.title.toString());
2506             if (result == 0) {
2507                 result = a.componentName.compareTo(b.componentName);
2508             }
2509             return result;
2510         }
2511     };
2512     public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2513             = new Comparator&lt;ApplicationInfo&gt;() {
2514         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2515             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2516             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2517             return 0;
2518         }
2519     };
2520     public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2521             = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2522         public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2523             return sCollator.compare(a.label.toString(), b.label.toString());
2524         }
2525     };
2526     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2527         if (info.activityInfo != null) {
2528             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2529         } else {
2530             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2531         }
2532     }
2533     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2534         private PackageManager mPackageManager;
2535         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2536         ShortcutNameComparator(PackageManager pm) {
2537             mPackageManager = pm;
2538             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2539         }
2540         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2541             mPackageManager = pm;
2542             mLabelCache = labelCache;
2543         }
2544         public final int compare(ResolveInfo a, ResolveInfo b) {
2545             CharSequence labelA, labelB;
2546             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2547             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2548             if (mLabelCache.containsKey(keyA)) {
2549                 labelA = mLabelCache.get(keyA);
2550             } else {
2551                 labelA = a.loadLabel(mPackageManager).toString();
2552 
2553                 mLabelCache.put(keyA, labelA);
2554             }
2555             if (mLabelCache.containsKey(keyB)) {
2556                 labelB = mLabelCache.get(keyB);
2557             } else {
2558                 labelB = b.loadLabel(mPackageManager).toString();
2559 
2560                 mLabelCache.put(keyB, labelB);
2561             }
2562             return sCollator.compare(labelA, labelB);
2563         }
2564     }
2565     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2566         private PackageManager mPackageManager;
2567         private HashMap&lt;Object, String&gt; mLabelCache;
2568         WidgetAndShortcutNameComparator(PackageManager pm) {
2569             mPackageManager = pm;
2570             mLabelCache = new HashMap&lt;Object, String&gt;();
2571         }
2572         public final int compare(Object a, Object b) {
2573             String labelA, labelB;
2574             if (mLabelCache.containsKey(a)) {
2575                 labelA = mLabelCache.get(a);
2576             } else {
2577                 labelA = (a instanceof AppWidgetProviderInfo) ?
2578                     ((AppWidgetProviderInfo) a).label :
2579                     ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2580                 mLabelCache.put(a, labelA);
2581             }
2582             if (mLabelCache.containsKey(b)) {
2583                 labelB = mLabelCache.get(b);
2584             } else {
2585                 labelB = (b instanceof AppWidgetProviderInfo) ?
2586                     ((AppWidgetProviderInfo) b).label :
2587                     ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2588                 mLabelCache.put(b, labelB);
2589             }
2590             return sCollator.compare(labelA, labelB);
2591         }
2592     }
2593 
2594     public void dumpState() {
2595         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
2596         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
2597         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
2598         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
2599         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
2600         if (mLoaderTask != null) {
2601             mLoaderTask.dumpState();
2602         } else {
2603             Log.d(TAG, &quot;mLoaderTask=null&quot;);
2604         }
2605     }
2606 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.content.Intent.ShortcutIconResource;
  30 import android.content.pm.ActivityInfo;
  31 import android.content.pm.PackageInfo;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.PackageManager.NameNotFoundException;
  34 import android.content.pm.ResolveInfo;
  35 import android.content.res.Configuration;
  36 import android.content.res.Resources;
  37 import android.database.Cursor;
  38 import android.graphics.Bitmap;
  39 import android.graphics.BitmapFactory;
  40 import android.net.Uri;
  41 import android.os.Environment;
  42 import android.os.Handler;
  43 import android.os.HandlerThread;
  44 import android.os.Parcelable;
  45 import android.os.Process;
  46 import android.os.RemoteException;
  47 import android.os.SystemClock;
  48 import android.util.Log;
  49 
  50 import com.android.launcher.R;
  51 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52 
  53 import java.lang.ref.WeakReference;
  54 import java.net.URISyntaxException;
  55 import java.text.Collator;
  56 import java.util.ArrayList;
  57 import java.util.Collections;
  58 import java.util.Comparator;
  59 import java.util.HashMap;
  60 import java.util.HashSet;
  61 import java.util.Iterator;
  62 import java.util.List;
  63 import java.util.Set;
  64 
  65 /**
  66  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67  * LauncherModel object held in a static. Also provide APIs for updating the database state
  68  * for the Launcher.
  69  */
  70 public class LauncherModel extends BroadcastReceiver {
  71     static final boolean DEBUG_LOADERS = false;
  72     static final String TAG = &quot;Launcher.Model&quot;;
  73 
  74     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75     private final boolean mAppsCanBeOnExternalStorage;
  76     private int mBatchSize; // 0 is all apps at once
  77     private int mAllAppsLoadDelay; // milliseconds between batches
  78 
  79     private final LauncherApplication mApp;
  80     private final Object mLock = new Object();
  81     private DeferredHandler mHandler = new DeferredHandler();
  82     private LoaderTask mLoaderTask;
  83     private boolean mIsLoaderTaskRunning;
  84 
  85     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86     static {
  87         sWorkerThread.start();
  88     }
  89     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90 
  91     // We start off with everything not loaded.  After that, we assume that
  92     // our monitoring of the package manager provides all updates and we never
  93     // need to do a requery.  These are only ever touched from the loader thread.
  94     private boolean mWorkspaceLoaded;
  95     private boolean mAllAppsLoaded;
  96 
  97     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
  98     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
  99     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 100     // a normal load, we also clear this set of Runnables.
 101     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 102 
 103     private WeakReference&lt;Callbacks&gt; mCallbacks;
 104 
 105     // &lt; only access in worker thread &gt;
 106     private AllAppsList mBgAllAppsList;
 107 
 108     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 109     // other locks, this one can generally be held long-term because we never expect any of these
 110     // static data structures to be referenced outside of the worker thread except on the first
 111     // load after configuration change.
 112     static final Object sBgLock = new Object();
 113 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 114 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 115     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 116     // LauncherModel to their ids</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 117     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
 118 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 119 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 119 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 120 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 121 </span>
 122 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 123 
 124 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 125     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 126     //       created by LauncherModel that are directly on the home screen (however, no widgets or</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 127     //       shortcuts within folders).</span>
 128 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 129 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 129 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 130 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 131 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 132     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 133     // LauncherModel to their ids</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 134     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 135 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 136     // sBgItems is passed to bindItems, which expects a list of all folders and shortcuts created by</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 137     //       LauncherModel that are directly on the home screen (however, no widgets or shortcuts</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 138     //       within folders).</span>
 139 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 140     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 141 
 142     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 143     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 144         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 145 
 146     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 147     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 148 
 149     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 150     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 151 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
 152 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 153 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 153 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 154 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 155 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 156 </span>
 157 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 158     // &lt;/ only access in worker thread &gt;
 159 
 160     private IconCache mIconCache;
 161     private Bitmap mDefaultIcon;
 162 
 163     private static int mCellCountX;
 164     private static int mCellCountY;
 165 
 166     protected int mPreviousConfigMcc;
 167 
 168     public interface Callbacks {
 169         public boolean setLoadOnResume();
 170         public int getCurrentWorkspaceScreen();
 171         public void startBinding();
 172         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 173         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 174         public void finishBindingItems();
 175         public void bindAppWidget(LauncherAppWidgetInfo info);
 176         public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 177         public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 178         public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
 179         public void bindAppsRemoved(ArrayList&lt;String&gt; packageNames, boolean permanent);
 180         public void bindPackagesUpdated();
 181         public boolean isAllAppsVisible();
 182         public boolean isAllAppsButtonRank(int rank);
 183         public void bindSearchablesChanged();
 184     }
 185 
 186     LauncherModel(LauncherApplication app, IconCache iconCache) {
 187         mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 188         mApp = app;
 189         mBgAllAppsList = new AllAppsList(iconCache);
 190         mIconCache = iconCache;
 191 
 192         mDefaultIcon = Utilities.createIconBitmap(
 193                 mIconCache.getFullResDefaultActivityIcon(), app);
 194 
 195         final Resources res = app.getResources();
 196         mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 197         mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 198         Configuration config = res.getConfiguration();
 199         mPreviousConfigMcc = config.mcc;
 200     }
 201 
 202     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 203      * posted on the main thread handler. */
 204     private void runOnMainThread(Runnable r) {
 205         if (sWorkerThread.getThreadId() == Process.myTid()) {
 206             // If we are on the worker thread, post onto the main handler
 207             mHandler.post(r);
 208         } else {
 209             r.run();
 210         }
 211     }
 212 
 213     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 214      * posted on the worker thread handler. */
 215     private static void runOnWorkerThread(Runnable r) {
 216         if (sWorkerThread.getThreadId() == Process.myTid()) {
 217             r.run();
 218         } else {
 219             // If we are not on the worker thread, then post to the worker handler
 220             sWorker.post(r);
 221         }
 222     }
 223 
 224     public Bitmap getFallbackIcon() {
 225         return Bitmap.createBitmap(mDefaultIcon);
 226     }
 227 
 228     public void unbindWorkspaceItems() {
 229         sWorker.post(new Runnable() {
 230             @Override
 231             public void run() {
 232                 unbindWorkspaceItemsOnMainThread();
 233             }
 234         });
 235     }
 236 
 237     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 238     private void unbindWorkspaceItemsOnMainThread() {
 239         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 240         // by making a copy of workspace items first.
 241         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 242         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 243         synchronized (sBgLock) {
 244             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 245             tmpAppWidgets.addAll(sBgAppWidgets);
 246         }
 247         Runnable r = new Runnable() {
 248                 @Override
 249                 public void run() {
 250                    for (ItemInfo item : tmpWorkspaceItems) {
 251                        item.unbind();
 252                    }
 253                    for (ItemInfo item : tmpAppWidgets) {
 254                        item.unbind();
 255                    }
 256                 }
 257             };
 258         runOnMainThread(r);
 259     }
 260 
 261     /**
 262      * Adds an item to the DB if it was not created previously, or move it to a new
 263      * &lt;container, screen, cellX, cellY&gt;
 264      */
 265     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 266             int screen, int cellX, int cellY) {
 267         if (item.container == ItemInfo.NO_ID) {
 268             // From all apps
 269             addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 270         } else {
 271             // From somewhere else
 272             moveItemInDatabase(context, item, container, screen, cellX, cellY);
 273         }
 274     }
 275 
 276     static void checkItemInfo(final ItemInfo item) {
 277         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 278         final long itemId = item.id;
 279         Runnable r = new Runnable() {
 280                 public void run() {
 281                     synchronized (sBgLock) {
 282                         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 283                         if (modelItem != null &amp;&amp; item != modelItem) {
 284                             // the modelItem needs to match up perfectly with item if our model is
 285                             // to be consistent with the database-- for now, just require
 286                             // modelItem == item
 287                             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 288                                 &quot;modelItem: &quot; +
 289                                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 290                                 &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 291                             RuntimeException e = new RuntimeException(msg);
 292                             e.setStackTrace(stackTrace);
 293                             throw e;
 294                         }
 295                     }
 296                 }
 297             };
 298         runOnWorkerThread(r);
 299     }
 300 
 301     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 302             final ItemInfo item, final String callingFunction) {
 303         final long itemId = item.id;
 304         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 305         final ContentResolver cr = context.getContentResolver();
 306 
 307         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 308         Runnable r = new Runnable() {
 309             public void run() {
 310                 cr.update(uri, values, null, null);
 311 
 312                 // Lock on mBgLock *after* the db operation
 313                 synchronized (sBgLock) {
 314                     ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 315                     if (item != modelItem) {
 316                         // the modelItem needs to match up perfectly with item if our model is to be
 317                         // consistent with the database-- for now, just require modelItem == item
 318                         String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 319                             &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 320                             &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +
 321                             &quot;original&quot;;
 322                         throw new RuntimeException(msg);
 323                     }
 324 
 325 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 326                     if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 327                             item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 328                         // Item is in a folder, make sure this folder exists</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 329                         if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 330                             // An items container is being set to a that of an item which is not in</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 331                             // the list of Folders.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 332                             String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 333                                     item.container + &quot;, not in the list of folders&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 334                             RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 335                             e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 336                             Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 337                             throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 338                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 339                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 340 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 341                     // Items are added/removed from the corresponding FolderInfo elsewhere, such</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 342                     // as in Workspace.onDrop. Here, we just add/remove them from the list of items</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 343                     // that are on the desktop, as appropriate</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 344                     if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 345                             modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 346                         switch (modelItem.itemType) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 347                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 348                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 349                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 350                                 if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 351                                     sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 352                                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 353                                 break;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 354                             default:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 355                                 break;</span>
 356 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 357 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 357 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 358 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 359 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 360                     // Items are added/removed from the corresponding FolderInfo elsewhere, such</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 361                     // as in Workspace.onDrop. Here, we just add/remove them from the list of items</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 362                     // that are on the desktop, as appropriate</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 363                     if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 364                             modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 365                         if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 366                             sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 367 </span>
 368 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 369                         }
 370                     } else {
 371                         sBgWorkspaceItems.remove(modelItem);
 372                     }
 373                 }
 374             }
 375         };
 376         runOnWorkerThread(r);
 377     }
 378 
 379     /**
 380      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 381      */
 382     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 383             final int screen, final int cellX, final int cellY) {
 384         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +
 385                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +
 386                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 387         Launcher.sDumpLogs.add(transaction);
 388         Log.d(TAG, transaction);
 389         item.container = container;
 390         item.cellX = cellX;
 391         item.cellY = cellY;
 392 
 393         // We store hotseat items in canonical form which is this orientation invariant position
 394         // in the hotseat
 395         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 396                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 397             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 398         } else {
 399             item.screen = screen;
 400         }
 401 
 402         final ContentValues values = new ContentValues();
 403         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 404         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 405         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 406         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 407 
 408         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 409     }
 410 
 411     /**
 412      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 413      */
 414     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 415             final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
 416         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +
 417                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +
 418                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 419         Launcher.sDumpLogs.add(transaction);
 420         Log.d(TAG, transaction);
 421         item.cellX = cellX;
 422         item.cellY = cellY;
 423         item.spanX = spanX;
 424         item.spanY = spanY;
 425 
 426         // We store hotseat items in canonical form which is this orientation invariant position
 427         // in the hotseat
 428         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 429                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 430             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 431         } else {
 432             item.screen = screen;
 433         }
 434 
 435         final ContentValues values = new ContentValues();
 436         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 437         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 438         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 439         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 440         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 441         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 442 
 443         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 444     }
 445 
 446     /**
 447      * Update an item to the database in a specified container.
 448      */
 449     static void updateItemInDatabase(Context context, final ItemInfo item) {
 450         final ContentValues values = new ContentValues();
 451         item.onAddToDatabase(values);
 452         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 453         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 454     }
 455 
 456     /**
 457      * Returns true if the shortcuts already exists in the database.
 458      * we identify a shortcut by its title and intent.
 459      */
 460     static boolean shortcutExists(Context context, String title, Intent intent) {
 461         final ContentResolver cr = context.getContentResolver();
 462         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 463             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 464             new String[] { title, intent.toUri(0) }, null);
 465         boolean result = false;
 466         try {
 467             result = c.moveToFirst();
 468         } finally {
 469             c.close();
 470         }
 471         return result;
 472     }
 473 
 474     /**
 475      * Returns an ItemInfo array containing all the items in the LauncherModel.
 476      * The ItemInfo.id is not set through this function.
 477      */
 478     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 479         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 480         final ContentResolver cr = context.getContentResolver();
 481         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 482                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 483                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 483                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 484                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 485 
 486         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 487         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 488         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 489         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 490         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 491         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 492         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 493 
 494         try {
 495             while (c.moveToNext()) {
 496                 ItemInfo item = new ItemInfo();
 497                 item.cellX = c.getInt(cellXIndex);
 498                 item.cellY = c.getInt(cellYIndex);
 499                 item.spanX = c.getInt(spanXIndex);
 500                 item.spanY = c.getInt(spanYIndex);
 501                 item.container = c.getInt(containerIndex);
 502                 item.itemType = c.getInt(itemTypeIndex);
 503                 item.screen = c.getInt(screenIndex);
 504 
 505                 items.add(item);
 506             }
 507         } catch (Exception e) {
 508             items.clear();
 509         } finally {
 510             c.close();
 511         }
 512 
 513         return items;
 514     }
 515 
 516     /**
 517      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 518      */
 519     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 520         final ContentResolver cr = context.getContentResolver();
 521         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 522                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 523                 new String[] { String.valueOf(id),
 524                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 525 
 526         try {
 527             if (c.moveToFirst()) {
 528                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 529                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 530                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 531                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 532                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 533                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 534 
 535                 FolderInfo folderInfo = null;
 536                 switch (c.getInt(itemTypeIndex)) {
 537                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 538                         folderInfo = findOrMakeFolder(folderList, id);
 539                         break;
 540                 }
 541 
 542                 folderInfo.title = c.getString(titleIndex);
 543                 folderInfo.id = id;
 544                 folderInfo.container = c.getInt(containerIndex);
 545                 folderInfo.screen = c.getInt(screenIndex);
 546                 folderInfo.cellX = c.getInt(cellXIndex);
 547                 folderInfo.cellY = c.getInt(cellYIndex);
 548 
 549                 return folderInfo;
 550             }
 551         } finally {
 552             c.close();
 553         }
 554 
 555         return null;
 556     }
 557 
 558     /**
 559      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 560      * cellY fields of the item. Also assigns an ID to the item.
 561      */
 562     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 563             final int screen, final int cellX, final int cellY, final boolean notify) {
 564         item.container = container;
 565         item.cellX = cellX;
 566         item.cellY = cellY;
 567         // We store hotseat items in canonical form which is this orientation invariant position
 568         // in the hotseat
 569         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 570                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 571             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 572         } else {
 573             item.screen = screen;
 574         }
 575 
 576         final ContentValues values = new ContentValues();
 577         final ContentResolver cr = context.getContentResolver();
 578         item.onAddToDatabase(values);
 579 
 580         LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 581         item.id = app.getLauncherProvider().generateNewId();
 582         values.put(LauncherSettings.Favorites._ID, item.id);
 583         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 584 
 585         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 586 
 587         Runnable r = new Runnable() {
 588             public void run() {
 589                 String transaction = &quot;DbDebug    Add item (&quot; + item.title + &quot;) to db, id: &quot;
 590                         + item.id + &quot; (&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot;
 591                         + cellY + &quot;)&quot;;
 592                 Launcher.sDumpLogs.add(transaction);
 593                 Log.d(TAG, transaction);
 594 
 595                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 596                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 597 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 598 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 599                 // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 600                 synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 601                     if (sBgItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 602                         // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 603                         throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 604                             &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 605                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 606                     sBgItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 607                     switch (item.itemType) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 608                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 609                             sBgFolders.put(item.id, (FolderInfo) item);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 610                             // Fall through</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 611                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 612                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 613                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 614                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 615                                 sBgWorkspaceItems.add(item);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 616                             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 617                                 if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 618                                     // Adding an item to a folder that doesn&#x27;t exist.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 619                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 620                                             &quot; doesn&#x27;t exist&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 621                                     RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 622                                     e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 623                                     Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 624                                     throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 625                                 }</span>
 626 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 627 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 627 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 628 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 629 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 630                 // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 631                 synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 632                     if (sBgItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 633                         // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 634                         throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 635                             &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 636                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 637                     sBgItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 638                     switch (item.itemType) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 639                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 640                             sBgFolders.put(item.id, (FolderInfo) item);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 641                             // Fall through</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 642                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 643                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 644                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 645                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 646                                 sBgWorkspaceItems.add(item);</span>
 647 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 648                             }
 649                             break;
 650                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 651                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 652                             break;
 653                     }
 654                 }
 655             }
 656         };
 657         runOnWorkerThread(r);
 658     }
 659 
 660     /**
 661      * Creates a new unique child id, for a given cell span across all layouts.
 662      */
 663     static int getCellLayoutChildId(
 664             long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 665         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 666                 | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 667     }
 668 
 669     static int getCellCountX() {
 670         return mCellCountX;
 671     }
 672 
 673     static int getCellCountY() {
 674         return mCellCountY;
 675     }
 676 
 677     /**
 678      * Updates the model orientation helper to take into account the current layout dimensions
 679      * when performing local/canonical coordinate transformations.
 680      */
 681     static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 682         mCellCountX = shortAxisCellCount;
 683         mCellCountY = longAxisCellCount;
 684     }
 685 
 686     /**
 687      * Removes the specified item from the database
 688      * @param context
 689      * @param item
 690      */
 691     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 692         final ContentResolver cr = context.getContentResolver();
 693         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
 694         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 695 
 696         Runnable r = new Runnable() {
 697             public void run() {
 698                 String transaction = &quot;DbDebug    Delete item (&quot; + item.title + &quot;) from db, id: &quot;
 699                         + item.id + &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX +
 700                         &quot;, &quot; + item.cellY + &quot;)&quot;;
 701                 Launcher.sDumpLogs.add(transaction);
 702                 Log.d(TAG, transaction);
 703 
 704                 cr.delete(uriToDelete, null, null);
 705 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 706 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 707                 // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 708                 synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 709                     switch (item.itemType) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 710                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 711                             sBgFolders.remove(item.id);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 712                             for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 713                                 if (info.container == item.id) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 714                                     // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 715                                     // think they are contained by that folder.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 716                                     String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 717                                             &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 718                                     RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 719                                     e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 720                                     Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 721                                     throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 722                                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 723                             }</span>
 724 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 725 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 725 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 726 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 727 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 728                 // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 729                 synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 730                     switch (item.itemType) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 731                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 732                             sBgFolders.remove(item.id);</span>
 733 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 734                             sBgWorkspaceItems.remove(item);
 735                             break;
 736                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 737                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 738                             sBgWorkspaceItems.remove(item);
 739                             break;
 740                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 741                             sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
 742                             break;
 743                     }
 744                     sBgItemsIdMap.remove(item.id);
 745                     sBgDbIconCache.remove(item);
 746                 }
 747             }
 748         };
 749         runOnWorkerThread(r);
 750     }
 751 
 752     /**
 753      * Remove the contents of the specified folder from the database
 754      */
 755     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 756         final ContentResolver cr = context.getContentResolver();
 757 
 758         Runnable r = new Runnable() {
 759             public void run() {
 760                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
 761                 // Lock on mBgLock *after* the db operation
 762                 synchronized (sBgLock) {
 763                     sBgItemsIdMap.remove(info.id);
 764                     sBgFolders.remove(info.id);
 765                     sBgDbIconCache.remove(info);
 766                     sBgWorkspaceItems.remove(info);
 767                 }
 768 
 769                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 770                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
 771                 // Lock on mBgLock *after* the db operation
 772                 synchronized (sBgLock) {
 773                     for (ItemInfo childInfo : info.contents) {
 774                         sBgItemsIdMap.remove(childInfo.id);
 775                         sBgDbIconCache.remove(childInfo);
 776                     }
 777                 }
 778             }
 779         };
 780         runOnWorkerThread(r);
 781     }
 782 
 783     /**
 784      * Set this as the current Launcher activity object for the loader.
 785      */
 786     public void initialize(Callbacks callbacks) {
 787         synchronized (mLock) {
 788             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 789         }
 790     }
 791 
 792     /**
 793      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 794      * ACTION_PACKAGE_CHANGED.
 795      */
 796     @Override
 797     public void onReceive(Context context, Intent intent) {
 798         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 799 
 800         final String action = intent.getAction();
 801 
 802         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 803                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 804                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 805             final String packageName = intent.getData().getSchemeSpecificPart();
 806             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 807 
 808             int op = PackageUpdatedTask.OP_NONE;
 809 
 810             if (packageName == null || packageName.length() == 0) {
 811                 // they sent us a bad intent
 812                 return;
 813             }
 814 
 815             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 816                 op = PackageUpdatedTask.OP_UPDATE;
 817             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 818                 if (!replacing) {
 819                     op = PackageUpdatedTask.OP_REMOVE;
 820                 }
 821                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 822                 // later, we will update the package at this time
 823             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 824                 if (!replacing) {
 825                     op = PackageUpdatedTask.OP_ADD;
 826                 } else {
 827                     op = PackageUpdatedTask.OP_UPDATE;
 828                 }
 829             }
 830 
 831             if (op != PackageUpdatedTask.OP_NONE) {
 832                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 833             }
 834 
 835         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 836             // First, schedule to add these apps back in.
 837             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 838             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 839             // Then, rebind everything.
 840             startLoaderFromBackground();
 841         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 842             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 843             enqueuePackageUpdated(new PackageUpdatedTask(
 844                         PackageUpdatedTask.OP_UNAVAILABLE, packages));
 845         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 846             // If we have changed locale we need to clear out the labels in all apps/workspace.
 847             forceReload();
 848         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 849              // Check if configuration change was an mcc/mnc change which would affect app resources
 850              // and we would need to clear out the labels in all apps/workspace. Same handling as
 851              // above for ACTION_LOCALE_CHANGED
 852              Configuration currentConfig = context.getResources().getConfiguration();
 853              if (mPreviousConfigMcc != currentConfig.mcc) {
 854                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 855                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 856                    forceReload();
 857              }
 858              // Update previousConfig
 859              mPreviousConfigMcc = currentConfig.mcc;
 860         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 861                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 862             if (mCallbacks != null) {
 863                 Callbacks callbacks = mCallbacks.get();
 864                 if (callbacks != null) {
 865                     callbacks.bindSearchablesChanged();
 866                 }
 867             }
 868         }
 869     }
 870 
 871     private void forceReload() {
 872         resetLoadedState(true, true);
 873 
 874         // Do this here because if the launcher activity is running it will be restarted.
 875         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 876         // to reload.
 877         startLoaderFromBackground();
 878     }
 879 
 880     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 881         synchronized (mLock) {
 882             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 883             // mWorkspaceLoaded to true later
 884             stopLoaderLocked();
 885             if (resetAllAppsLoaded) mAllAppsLoaded = false;
 886             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 887         }
 888     }
 889 
 890     /**
 891      * When the launcher is in the background, it&#x27;s possible for it to miss paired
 892      * configuration changes.  So whenever we trigger the loader from the background
 893      * tell the launcher that it needs to re-run the loader when it comes back instead
 894      * of doing it now.
 895      */
 896     public void startLoaderFromBackground() {
 897         boolean runLoader = false;
 898         if (mCallbacks != null) {
 899             Callbacks callbacks = mCallbacks.get();
 900             if (callbacks != null) {
 901                 // Only actually run the loader if they&#x27;re not paused.
 902                 if (!callbacks.setLoadOnResume()) {
 903                     runLoader = true;
 904                 }
 905             }
 906         }
 907         if (runLoader) {
 908             startLoader(false, -1);
 909         }
 910     }
 911 
 912     // If there is already a loader task running, tell it to stop.
 913     // returns true if isLaunching() was true on the old task
 914     private boolean stopLoaderLocked() {
 915         boolean isLaunching = false;
 916         LoaderTask oldTask = mLoaderTask;
 917         if (oldTask != null) {
 918             if (oldTask.isLaunching()) {
 919                 isLaunching = true;
 920             }
 921             oldTask.stopLocked();
 922         }
 923         return isLaunching;
 924     }
 925 
 926     public void startLoader(boolean isLaunching, int synchronousBindPage) {
 927         synchronized (mLock) {
 928             if (DEBUG_LOADERS) {
 929                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 930             }
 931 
 932             // Clear any deferred bind-runnables from the synchronized load process
 933             // We must do this before any loading/binding is scheduled below.
 934             mDeferredBindRunnables.clear();
 935 
 936             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 937             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 938                 // If there is already one running, tell it to stop.
 939                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 940                 isLaunching = isLaunching || stopLoaderLocked();
 941                 mLoaderTask = new LoaderTask(mApp, isLaunching);
 942                 if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
 943                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
 944                 } else {
 945                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
 946                     sWorker.post(mLoaderTask);
 947                 }
 948             }
 949         }
 950     }
 951 
 952     void bindRemainingSynchronousPages() {
 953         // Post the remaining side pages to be loaded
 954         if (!mDeferredBindRunnables.isEmpty()) {
 955             for (final Runnable r : mDeferredBindRunnables) {
 956                 mHandler.post(r);
 957             }
 958             mDeferredBindRunnables.clear();
 959         }
 960     }
 961 
 962     public void stopLoader() {
 963         synchronized (mLock) {
 964             if (mLoaderTask != null) {
 965                 mLoaderTask.stopLocked();
 966             }
 967         }
 968     }
 969 
 970     public boolean isAllAppsLoaded() {
 971         return mAllAppsLoaded;
 972     }
 973 
 974     boolean isLoadingWorkspace() {
 975         synchronized (mLock) {
 976             if (mLoaderTask != null) {
 977                 return mLoaderTask.isLoadingWorkspace();
 978             }
 979         }
 980         return false;
 981     }
 982 
 983     /**
 984      * Runnable for the thread that loads the contents of the launcher:
 985      *   - workspace icons
 986      *   - widgets
 987      *   - all apps icons
 988      */
 989     private class LoaderTask implements Runnable {
 990         private Context mContext;
 991         private boolean mIsLaunching;
 992         private boolean mIsLoadingAndBindingWorkspace;
 993         private boolean mStopped;
 994         private boolean mLoadAndBindStepFinished;
 995 
 996         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
 997 
 998         LoaderTask(Context context, boolean isLaunching) {
 999             mContext = context;
1000             mIsLaunching = isLaunching;
1001             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1002         }
1003 
1004         boolean isLaunching() {
1005             return mIsLaunching;
1006         }
1007 
1008         boolean isLoadingWorkspace() {
1009             return mIsLoadingAndBindingWorkspace;
1010         }
1011 
1012         private void loadAndBindWorkspace() {
1013             mIsLoadingAndBindingWorkspace = true;
1014 
1015             // Load the workspace
1016             if (DEBUG_LOADERS) {
1017                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1018             }
1019 
1020             if (!mWorkspaceLoaded) {
1021                 loadWorkspace();
1022                 synchronized (LoaderTask.this) {
1023                     if (mStopped) {
1024                         return;
1025                     }
1026                     mWorkspaceLoaded = true;
1027                 }
1028             }
1029 
1030             // Bind the workspace
1031             bindWorkspace(-1);
1032         }
1033 
1034         private void waitForIdle() {
1035             // Wait until the either we&#x27;re stopped or the other threads are done.
1036             // This way we don&#x27;t start loading all apps until the workspace has settled
1037             // down.
1038             synchronized (LoaderTask.this) {
1039                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1040 
1041                 mHandler.postIdle(new Runnable() {
1042                         public void run() {
1043                             synchronized (LoaderTask.this) {
1044                                 mLoadAndBindStepFinished = true;
1045                                 if (DEBUG_LOADERS) {
1046                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1047                                 }
1048                                 LoaderTask.this.notify();
1049                             }
1050                         }
1051                     });
1052 
1053                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1054                     try {
1055                         this.wait();
1056                     } catch (InterruptedException ex) {
1057                         // Ignore
1058                     }
1059                 }
1060                 if (DEBUG_LOADERS) {
1061                     Log.d(TAG, &quot;waited &quot;
1062                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1063                             + &quot;ms for previous step to finish binding&quot;);
1064                 }
1065             }
1066         }
1067 
1068         void runBindSynchronousPage(int synchronousBindPage) {
1069             if (synchronousBindPage &lt; 0) {
1070                 // Ensure that we have a valid page index to load synchronously
1071                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1072                         &quot;valid page index&quot;);
1073             }
1074             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1075                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1076                 // loaded already (we should load everything asynchronously in that case)
1077                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1078             }
1079             synchronized (mLock) {
1080                 if (mIsLoaderTaskRunning) {
1081                     // Ensure that we are never running the background loading at this point since
1082                     // we also touch the background collections
1083                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1084                 }
1085             }
1086 
1087             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1088             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1089             //      this call is synchronous, we can get away with not locking).
1090 
1091             // Divide the set of loaded items into those that we are binding synchronously, and
1092             // everything else that is to be bound normally (asynchronously).
1093             bindWorkspace(synchronousBindPage);
1094             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1095             //      arise from that.
1096             onlyBindAllApps();
1097         }
1098 
1099         public void run() {
1100             synchronized (mLock) {
1101                 mIsLoaderTaskRunning = true;
1102             }
1103             // Optimize for end-user experience: if the Launcher is up and // running with the
1104             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1105             // workspace first (default).
1106             final Callbacks cbk = mCallbacks.get();
1107             final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1108 
1109             keep_running: {
1110                 // Elevate priority when Home launches for the first time to avoid
1111                 // starving at boot time. Staring at a blank home is not cool.
1112                 synchronized (mLock) {
1113                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1114                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1115                     android.os.Process.setThreadPriority(mIsLaunching
1116                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1117                 }
1118                 if (loadWorkspaceFirst) {
1119                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1120                     loadAndBindWorkspace();
1121                 } else {
1122                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1123                     loadAndBindAllApps();
1124                 }
1125 
1126                 if (mStopped) {
1127                     break keep_running;
1128                 }
1129 
1130                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1131                 // settled down.
1132                 synchronized (mLock) {
1133                     if (mIsLaunching) {
1134                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1135                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1136                     }
1137                 }
1138                 waitForIdle();
1139 
1140                 // second step
1141                 if (loadWorkspaceFirst) {
1142                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1143                     loadAndBindAllApps();
1144                 } else {
1145                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1146                     loadAndBindWorkspace();
1147                 }
1148 
1149                 // Restore the default thread priority after we are done loading items
1150                 synchronized (mLock) {
1151                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1152                 }
1153             }
1154 
1155 
1156             // Update the saved icons if necessary
1157             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1158             synchronized (sBgLock) {
1159                 for (Object key : sBgDbIconCache.keySet()) {
1160                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1161                 }
1162                 sBgDbIconCache.clear();
1163             }
1164 
1165             // Clear out this reference, otherwise we end up holding it until all of the
1166             // callback runnables are done.
1167             mContext = null;
1168 
1169             synchronized (mLock) {
1170                 // If we are still the last one to be scheduled, remove ourselves.
1171                 if (mLoaderTask == this) {
1172                     mLoaderTask = null;
1173                 }
1174                 mIsLoaderTaskRunning = false;
1175             }
1176         }
1177 
1178         public void stopLocked() {
1179             synchronized (LoaderTask.this) {
1180                 mStopped = true;
1181                 this.notify();
1182             }
1183         }
1184 
1185         /**
1186          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1187          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1188          * object that was around when the deferred message was scheduled, and if there&#x27;s
1189          * a new Callbacks object around then also return null.  This will save us from
1190          * calling onto it with data that will be ignored.
1191          */
1192         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1193             synchronized (mLock) {
1194                 if (mStopped) {
1195                     return null;
1196                 }
1197 
1198                 if (mCallbacks == null) {
1199                     return null;
1200                 }
1201 
1202                 final Callbacks callbacks = mCallbacks.get();
1203                 if (callbacks != oldCallbacks) {
1204                     return null;
1205                 }
1206                 if (callbacks == null) {
1207                     Log.w(TAG, &quot;no mCallbacks&quot;);
1208                     return null;
1209                 }
1210 
1211                 return callbacks;
1212             }
1213         }
1214 
1215         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1216         private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1217             int containerIndex = item.screen;
1218             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1219                 // Return early if we detect that an item is under the hotseat button
1220                 if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1221                     return false;
1222                 }
1223 
1224                 // We use the last index to refer to the hotseat and the screen as the rank, so
1225                 // test and update the occupied state accordingly
1226                 if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1227                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1228                         + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1229                         + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1230                     return false;
1231                 } else {
1232                     occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1233                     return true;
1234                 }
1235             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1236                 // Skip further checking if it is not the hotseat or workspace container
1237                 return true;
1238             }
1239 
1240             // Check if any workspace icons overlap with each other
1241             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1242                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1243                     if (occupied[containerIndex][x][y] != null) {
1244                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1245                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1246                             + x + &quot;,&quot; + y
1247                             + &quot;) occupied by &quot;
1248                             + occupied[containerIndex][x][y]);
1249                         return false;
1250                     }
1251                 }
1252             }
1253             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1254                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1255                     occupied[containerIndex][x][y] = item;
1256                 }
1257             }
1258 
1259             return true;
1260         }
1261 
1262         private void loadWorkspace() {
1263             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1264 
1265             final Context context = mContext;
1266             final ContentResolver contentResolver = context.getContentResolver();
1267             final PackageManager manager = context.getPackageManager();
1268             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1269             final boolean isSafeMode = manager.isSafeMode();
1270 
1271             // Make sure the default workspace is loaded, if needed
1272             mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1273 
1274             synchronized (sBgLock) {
1275                 sBgWorkspaceItems.clear();
1276                 sBgAppWidgets.clear();
1277                 sBgFolders.clear();
1278                 sBgItemsIdMap.clear();
1279                 sBgDbIconCache.clear();
1280 
1281                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1282 
1283                 final Cursor c = contentResolver.query(
1284                         LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);
1285 
1286                 // +1 for the hotseat (it can be larger than the workspace)
1287                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1288                 // before any earlier duplicates)
1289                 final ItemInfo occupied[][][] =
1290                         new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];
1291 
1292                 try {
1293                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1294                     final int intentIndex = c.getColumnIndexOrThrow
1295                             (LauncherSettings.Favorites.INTENT);
1296                     final int titleIndex = c.getColumnIndexOrThrow
1297                             (LauncherSettings.Favorites.TITLE);
1298                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1299                             LauncherSettings.Favorites.ICON_TYPE);
1300                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1301                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1302                             LauncherSettings.Favorites.ICON_PACKAGE);
1303                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1304                             LauncherSettings.Favorites.ICON_RESOURCE);
1305                     final int containerIndex = c.getColumnIndexOrThrow(
1306                             LauncherSettings.Favorites.CONTAINER);
1307                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1308                             LauncherSettings.Favorites.ITEM_TYPE);
1309                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1310                             LauncherSettings.Favorites.APPWIDGET_ID);
1311                     final int screenIndex = c.getColumnIndexOrThrow(
1312                             LauncherSettings.Favorites.SCREEN);
1313                     final int cellXIndex = c.getColumnIndexOrThrow
1314                             (LauncherSettings.Favorites.CELLX);
1315                     final int cellYIndex = c.getColumnIndexOrThrow
1316                             (LauncherSettings.Favorites.CELLY);
1317                     final int spanXIndex = c.getColumnIndexOrThrow
1318                             (LauncherSettings.Favorites.SPANX);
1319                     final int spanYIndex = c.getColumnIndexOrThrow(
1320                             LauncherSettings.Favorites.SPANY);
1321                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1322                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1323                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1324 
1325                     ShortcutInfo info;
1326                     String intentDescription;
1327                     LauncherAppWidgetInfo appWidgetInfo;
1328                     int container;
1329                     long id;
1330                     Intent intent;
1331 
1332                     while (!mStopped &amp;&amp; c.moveToNext()) {
1333                         try {
1334                             int itemType = c.getInt(itemTypeIndex);
1335 
1336                             switch (itemType) {
1337                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1338                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1339                                 intentDescription = c.getString(intentIndex);
1340                                 try {
1341                                     intent = Intent.parseUri(intentDescription, 0);
1342                                 } catch (URISyntaxException e) {
1343                                     continue;
1344                                 }
1345 
1346                                 if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1347                                     info = getShortcutInfo(manager, intent, context, c, iconIndex,
1348                                             titleIndex, mLabelCache);
1349                                 } else {
1350                                     info = getShortcutInfo(c, context, iconTypeIndex,
1351                                             iconPackageIndex, iconResourceIndex, iconIndex,
1352                                             titleIndex);
1353 
1354                                     // App shortcuts that used to be automatically added to Launcher
1355                                     // didn&#x27;t always have the correct intent flags set, so do that
1356                                     // here
1357                                     if (intent.getAction() != null &amp;&amp;
1358                                         intent.getCategories() != null &amp;&amp;
1359                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1360                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1361                                         intent.addFlags(
1362                                             Intent.FLAG_ACTIVITY_NEW_TASK |
1363                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1364                                     }
1365                                 }
1366 
1367                                 if (info != null) {
1368                                     info.intent = intent;
1369                                     info.id = c.getLong(idIndex);
1370                                     container = c.getInt(containerIndex);
1371                                     info.container = container;
1372                                     info.screen = c.getInt(screenIndex);
1373                                     info.cellX = c.getInt(cellXIndex);
1374                                     info.cellY = c.getInt(cellYIndex);
1375 
1376                                     // check &amp; update map of what&#x27;s occupied
1377                                     if (!checkItemPlacement(occupied, info)) {
1378                                         break;
1379                                     }
1380 
1381                                     switch (container) {
1382                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1383                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1384                                         sBgWorkspaceItems.add(info);
1385                                         break;
1386                                     default:
1387                                         // Item is in a user folder
1388                                         FolderInfo folderInfo =
1389                                                 findOrMakeFolder(sBgFolders, container);
1390                                         folderInfo.add(info);
1391                                         break;
1392                                     }
1393                                     sBgItemsIdMap.put(info.id, info);
1394 
1395                                     // now that we&#x27;ve loaded everthing re-save it with the
1396                                     // icon in case it disappears somehow.
1397                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1398                                 } else {
1399                                     // Failed to load the shortcut, probably because the
1400                                     // activity manager couldn&#x27;t resolve it (maybe the app
1401                                     // was uninstalled), or the db row was somehow screwed up.
1402                                     // Delete it.
1403                                     id = c.getLong(idIndex);
1404                                     Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);
1405                                     contentResolver.delete(LauncherSettings.Favorites.getContentUri(
1406                                                 id, false), null, null);
1407                                 }
1408                                 break;
1409 
1410                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1411                                 id = c.getLong(idIndex);
1412                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1413 
1414                                 folderInfo.title = c.getString(titleIndex);
1415                                 folderInfo.id = id;
1416                                 container = c.getInt(containerIndex);
1417                                 folderInfo.container = container;
1418                                 folderInfo.screen = c.getInt(screenIndex);
1419                                 folderInfo.cellX = c.getInt(cellXIndex);
1420                                 folderInfo.cellY = c.getInt(cellYIndex);
1421 
1422                                 // check &amp; update map of what&#x27;s occupied
1423                                 if (!checkItemPlacement(occupied, folderInfo)) {
1424                                     break;
1425                                 }
1426                                 switch (container) {
1427                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1428                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1429                                         sBgWorkspaceItems.add(folderInfo);
1430                                         break;
1431                                 }
1432 
1433                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
1434                                 sBgFolders.put(folderInfo.id, folderInfo);
1435                                 break;
1436 
1437                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1438                                 // Read all Launcher-specific widget details
1439                                 int appWidgetId = c.getInt(appWidgetIdIndex);
1440                                 id = c.getLong(idIndex);
1441 
1442                                 final AppWidgetProviderInfo provider =
1443                                         widgets.getAppWidgetInfo(appWidgetId);
1444 
1445                                 if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
1446                                         provider.provider.getPackageName() == null)) {
1447                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
1448                                         + id + &quot; appWidgetId=&quot; + appWidgetId;
1449                                     Log.e(TAG, log);
1450                                     Launcher.sDumpLogs.add(log);
1451                                     itemsToRemove.add(id);
1452                                 } else {
1453                                     appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
1454                                             provider.provider);
1455                                     appWidgetInfo.id = id;
1456                                     appWidgetInfo.screen = c.getInt(screenIndex);
1457                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
1458                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
1459                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
1460                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
1461                                     int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1462                                     appWidgetInfo.minSpanX = minSpan[0];
1463                                     appWidgetInfo.minSpanY = minSpan[1];
1464 
1465                                     container = c.getInt(containerIndex);
1466                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1467                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1468                                         Log.e(TAG, &quot;Widget found where container != &quot; +
1469                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
1470                                         continue;
1471                                     }
1472                                     appWidgetInfo.container = c.getInt(containerIndex);
1473 
1474                                     // check &amp; update map of what&#x27;s occupied
1475                                     if (!checkItemPlacement(occupied, appWidgetInfo)) {
1476                                         break;
1477                                     }
1478                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1479                                     sBgAppWidgets.add(appWidgetInfo);
1480                                 }
1481                                 break;
1482                             }
1483                         } catch (Exception e) {
1484                             Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);
1485                         }
1486                     }
1487                 } finally {
1488                     c.close();
1489                 }
1490 
1491                 if (itemsToRemove.size() &gt; 0) {
1492                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
1493                                     LauncherSettings.Favorites.CONTENT_URI);
1494                     // Remove dead items
1495                     for (long id : itemsToRemove) {
1496                         if (DEBUG_LOADERS) {
1497                             Log.d(TAG, &quot;Removed id = &quot; + id);
1498                         }
1499                         // Don&#x27;t notify content observers
1500                         try {
1501                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
1502                                     null, null);
1503                         } catch (RemoteException e) {
1504                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
1505                         }
1506                     }
1507                 }
1508 
1509                 if (DEBUG_LOADERS) {
1510                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1511                     Log.d(TAG, &quot;workspace layout: &quot;);
1512                     for (int y = 0; y &lt; mCellCountY; y++) {
1513                         String line = &quot;&quot;;
1514                         for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {
1515                             if (s &gt; 0) {
1516                                 line += &quot; | &quot;;
1517                             }
1518                             for (int x = 0; x &lt; mCellCountX; x++) {
1519                                 line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
1520                             }
1521                         }
1522                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
1523                     }
1524                 }
1525             }
1526         }
1527 
1528         /** Filters the set of items who are directly or indirectly (via another container) on the
1529          * specified screen. */
1530         private void filterCurrentWorkspaceItems(int currentScreen,
1531                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
1532                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
1533                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
1534             // Purge any null ItemInfos
1535             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
1536             while (iter.hasNext()) {
1537                 ItemInfo i = iter.next();
1538                 if (i == null) {
1539                     iter.remove();
1540                 }
1541             }
1542 
1543             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1544             // items given.
1545             if (currentScreen &lt; 0) {
1546                 currentScreenItems.addAll(allWorkspaceItems);
1547             }
1548 
1549             // Order the set of items by their containers first, this allows use to walk through the
1550             // list sequentially, build up a list of containers that are in the specified screen,
1551             // as well as all items in those containers.
1552             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
1553             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
1554                 @Override
1555                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1556                     return (int) (lhs.container - rhs.container);
1557                 }
1558             });
1559             for (ItemInfo info : allWorkspaceItems) {
1560                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1561                     if (info.screen == currentScreen) {
1562                         currentScreenItems.add(info);
1563                         itemsOnScreen.add(info.id);
1564                     } else {
1565                         otherScreenItems.add(info);
1566                     }
1567                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1568                     currentScreenItems.add(info);
1569                     itemsOnScreen.add(info.id);
1570                 } else {
1571                     if (itemsOnScreen.contains(info.container)) {
1572                         currentScreenItems.add(info);
1573                         itemsOnScreen.add(info.id);
1574                     } else {
1575                         otherScreenItems.add(info);
1576                     }
1577                 }
1578             }
1579         }
1580 
1581         /** Filters the set of widgets which are on the specified screen. */
1582         private void filterCurrentAppWidgets(int currentScreen,
1583                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1584                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
1585                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
1586             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1587             // widgets given.
1588             if (currentScreen &lt; 0) {
1589                 currentScreenWidgets.addAll(appWidgets);
1590             }
1591 
1592             for (LauncherAppWidgetInfo widget : appWidgets) {
1593                 if (widget == null) continue;
1594                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1595                         widget.screen == currentScreen) {
1596                     currentScreenWidgets.add(widget);
1597                 } else {
1598                     otherScreenWidgets.add(widget);
1599                 }
1600             }
1601         }
1602 
1603         /** Filters the set of folders which are on the specified screen. */
1604         private void filterCurrentFolders(int currentScreen,
1605                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
1606                 HashMap&lt;Long, FolderInfo&gt; folders,
1607                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
1608                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
1609             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1610             // widgets given.
1611             if (currentScreen &lt; 0) {
1612                 currentScreenFolders.putAll(folders);
1613             }
1614 
1615             for (long id : folders.keySet()) {
1616                 ItemInfo info = itemsIdMap.get(id);
1617                 FolderInfo folder = folders.get(id);
1618                 if (info == null || folder == null) continue;
1619                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1620                         info.screen == currentScreen) {
1621                     currentScreenFolders.put(id, folder);
1622                 } else {
1623                     otherScreenFolders.put(id, folder);
1624                 }
1625             }
1626         }
1627 
1628         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
1629          * right) */
1630         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
1631             // XXX: review this
1632             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
1633                 @Override
1634                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1635                     int cellCountX = LauncherModel.getCellCountX();
1636                     int cellCountY = LauncherModel.getCellCountY();
1637                     int screenOffset = cellCountX * cellCountY;
1638                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1639                     long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1640                             lhs.cellY * cellCountX + lhs.cellX);
1641                     long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1642                             rhs.cellY * cellCountX + rhs.cellX);
1643                     return (int) (lr - rr);
1644                 }
1645             });
1646         }
1647 
1648         private void bindWorkspaceItems(final Callbacks oldCallbacks,
1649                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
1650                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1651                 final HashMap&lt;Long, FolderInfo&gt; folders,
1652                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
1653 
1654             final boolean postOnMainThread = (deferredBindRunnables != null);
1655 
1656             // Bind the workspace items
1657             int N = workspaceItems.size();
1658             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
1659                 final int start = i;
1660                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
1661                 final Runnable r = new Runnable() {
1662                     @Override
1663                     public void run() {
1664                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1665                         if (callbacks != null) {
1666                             callbacks.bindItems(workspaceItems, start, start+chunkSize);
1667                         }
1668                     }
1669                 };
1670                 if (postOnMainThread) {
1671                     deferredBindRunnables.add(r);
1672                 } else {
1673                     runOnMainThread(r);
1674                 }
1675             }
1676 
1677             // Bind the folders
1678             if (!folders.isEmpty()) {
1679                 final Runnable r = new Runnable() {
1680                     public void run() {
1681                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1682                         if (callbacks != null) {
1683                             callbacks.bindFolders(folders);
1684                         }
1685                     }
1686                 };
1687                 if (postOnMainThread) {
1688                     deferredBindRunnables.add(r);
1689                 } else {
1690                     runOnMainThread(r);
1691                 }
1692             }
1693 
1694             // Bind the widgets, one at a time
1695             N = appWidgets.size();
1696             for (int i = 0; i &lt; N; i++) {
1697                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
1698                 final Runnable r = new Runnable() {
1699                     public void run() {
1700                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1701                         if (callbacks != null) {
1702                             callbacks.bindAppWidget(widget);
1703                         }
1704                     }
1705                 };
1706                 if (postOnMainThread) {
1707                     deferredBindRunnables.add(r);
1708                 } else {
1709                     runOnMainThread(r);
1710                 }
1711             }
1712         }
1713 
1714         /**
1715          * Binds all loaded data to actual views on the main thread.
1716          */
1717         private void bindWorkspace(int synchronizeBindPage) {
1718             final long t = SystemClock.uptimeMillis();
1719             Runnable r;
1720 
1721             // Don&#x27;t use these two variables in any of the callback runnables.
1722             // Otherwise we hold a reference to them.
1723             final Callbacks oldCallbacks = mCallbacks.get();
1724             if (oldCallbacks == null) {
1725                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1726                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
1727                 return;
1728             }
1729 
1730             final int currentScreen = (synchronizeBindPage &gt; -1) ? synchronizeBindPage :
1731                 oldCallbacks.getCurrentWorkspaceScreen();
1732 
1733             // Load all the items that are on the current page first (and in the process, unbind
1734             // all the existing workspace items before we call startBinding() below.
1735             unbindWorkspaceItemsOnMainThread();
1736             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
1737             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
1738                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1739             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
1740             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
1741             synchronized (sBgLock) {
1742                 workspaceItems.addAll(sBgWorkspaceItems);
1743                 appWidgets.addAll(sBgAppWidgets);
1744                 folders.putAll(sBgFolders);
1745                 itemsIdMap.putAll(sBgItemsIdMap);
1746             }
1747 
1748             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1749             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1750             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
1751                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1752             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
1753                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1754             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
1755             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
1756 
1757             // Separate the items that are on the current screen, and all the other remaining items
1758             filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,
1759                     otherWorkspaceItems);
1760             filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,
1761                     otherAppWidgets);
1762             filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,
1763                     otherFolders);
1764             sortWorkspaceItemsSpatially(currentWorkspaceItems);
1765             sortWorkspaceItemsSpatially(otherWorkspaceItems);
1766 
1767             // Tell the workspace that we&#x27;re about to start binding items
1768             r = new Runnable() {
1769                 public void run() {
1770                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1771                     if (callbacks != null) {
1772                         callbacks.startBinding();
1773                     }
1774                 }
1775             };
1776             runOnMainThread(r);
1777 
1778             // Load items on the current page
1779             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
1780                     currentFolders, null);
1781 
1782             // Load all the remaining pages
1783             mDeferredBindRunnables.clear();
1784             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
1785                     mDeferredBindRunnables);
1786 
1787             // Tell the workspace that we&#x27;re done binding items
1788             r = new Runnable() {
1789                 public void run() {
1790                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1791                     if (callbacks != null) {
1792                         callbacks.finishBindingItems();
1793                     }
1794 
1795                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
1796                     if (DEBUG_LOADERS) {
1797                         Log.d(TAG, &quot;bound workspace in &quot;
1798                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1799                     }
1800 
1801                     mIsLoadingAndBindingWorkspace = false;
1802                 }
1803             };
1804             mDeferredBindRunnables.add(r);
1805         }
1806 
1807         private void loadAndBindAllApps() {
1808             if (DEBUG_LOADERS) {
1809                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
1810             }
1811             if (!mAllAppsLoaded) {
1812                 loadAllAppsByBatch();
1813                 synchronized (LoaderTask.this) {
1814                     if (mStopped) {
1815                         return;
1816                     }
1817                     mAllAppsLoaded = true;
1818                 }
1819             } else {
1820                 onlyBindAllApps();
1821             }
1822         }
1823 
1824         private void onlyBindAllApps() {
1825             final Callbacks oldCallbacks = mCallbacks.get();
1826             if (oldCallbacks == null) {
1827                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1828                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
1829                 return;
1830             }
1831 
1832             // shallow copy
1833             @SuppressWarnings(&quot;unchecked&quot;)
1834             final ArrayList&lt;ApplicationInfo&gt; list
1835                     = (ArrayList&lt;ApplicationInfo&gt;) mBgAllAppsList.data.clone();
1836             mHandler.post(new Runnable() {
1837                 public void run() {
1838                     final long t = SystemClock.uptimeMillis();
1839                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1840                     if (callbacks != null) {
1841                         callbacks.bindAllApplications(list);
1842                     }
1843                     if (DEBUG_LOADERS) {
1844                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
1845                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1846                     }
1847                 }
1848             });
1849         }
1850 
1851         private void loadAllAppsByBatch() {
1852             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1853 
1854             // Don&#x27;t use these two variables in any of the callback runnables.
1855             // Otherwise we hold a reference to them.
1856             final Callbacks oldCallbacks = mCallbacks.get();
1857             if (oldCallbacks == null) {
1858                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1859                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
1860                 return;
1861             }
1862 
1863             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
1864             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
1865 
1866             final PackageManager packageManager = mContext.getPackageManager();
1867             List&lt;ResolveInfo&gt; apps = null;
1868 
1869             int N = Integer.MAX_VALUE;
1870 
1871             int startIndex;
1872             int i=0;
1873             int batchSize = -1;
1874             while (i &lt; N &amp;&amp; !mStopped) {
1875                 if (i == 0) {
1876                     mBgAllAppsList.clear();
1877                     final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1878                     apps = packageManager.queryIntentActivities(mainIntent, 0);
1879                     if (DEBUG_LOADERS) {
1880                         Log.d(TAG, &quot;queryIntentActivities took &quot;
1881                                 + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
1882                     }
1883                     if (apps == null) {
1884                         return;
1885                     }
1886                     N = apps.size();
1887                     if (DEBUG_LOADERS) {
1888                         Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
1889                     }
1890                     if (N == 0) {
1891                         // There are no apps?!?
1892                         return;
1893                     }
1894                     if (mBatchSize == 0) {
1895                         batchSize = N;
1896                     } else {
1897                         batchSize = mBatchSize;
1898                     }
1899 
1900                     final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1901                     Collections.sort(apps,
1902                             new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
1903                     if (DEBUG_LOADERS) {
1904                         Log.d(TAG, &quot;sort took &quot;
1905                                 + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
1906                     }
1907                 }
1908 
1909                 final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1910 
1911                 startIndex = i;
1912                 for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
1913                     // This builds the icon bitmaps.
1914                     mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),
1915                             mIconCache, mLabelCache));
1916                     i++;
1917                 }
1918 
1919                 final boolean first = i &lt;= batchSize;
1920                 final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1921                 final ArrayList&lt;ApplicationInfo&gt; added = mBgAllAppsList.added;
1922                 mBgAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();
1923 
1924                 mHandler.post(new Runnable() {
1925                     public void run() {
1926                         final long t = SystemClock.uptimeMillis();
1927                         if (callbacks != null) {
1928                             if (first) {
1929                                 callbacks.bindAllApplications(added);
1930                             } else {
1931                                 callbacks.bindAppsAdded(added);
1932                             }
1933                             if (DEBUG_LOADERS) {
1934                                 Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
1935                                     + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
1936                             }
1937                         } else {
1938                             Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
1939                         }
1940                     }
1941                 });
1942 
1943                 if (DEBUG_LOADERS) {
1944                     Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
1945                             + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
1946                 }
1947 
1948                 if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
1949                     try {
1950                         if (DEBUG_LOADERS) {
1951                             Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
1952                         }
1953                         Thread.sleep(mAllAppsLoadDelay);
1954                     } catch (InterruptedException exc) { }
1955                 }
1956             }
1957 
1958             if (DEBUG_LOADERS) {
1959                 Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
1960                         + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
1961                         + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
1962             }
1963         }
1964 
1965         public void dumpState() {
1966             synchronized (sBgLock) {
1967                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
1968                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
1969                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
1970                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
1971                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
1972             }
1973         }
1974     }
1975 
1976     void enqueuePackageUpdated(PackageUpdatedTask task) {
1977         sWorker.post(task);
1978     }
1979 
1980     private class PackageUpdatedTask implements Runnable {
1981         int mOp;
1982         String[] mPackages;
1983 
1984         public static final int OP_NONE = 0;
1985         public static final int OP_ADD = 1;
1986         public static final int OP_UPDATE = 2;
1987         public static final int OP_REMOVE = 3; // uninstlled
1988         public static final int OP_UNAVAILABLE = 4; // external media unmounted
1989 
1990 
1991         public PackageUpdatedTask(int op, String[] packages) {
1992             mOp = op;
1993             mPackages = packages;
1994         }
1995 
1996         public void run() {
1997             final Context context = mApp;
1998 
1999             final String[] packages = mPackages;
2000             final int N = packages.length;
2001             switch (mOp) {
2002                 case OP_ADD:
2003                     for (int i=0; i&lt;N; i++) {
2004                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2005                         mBgAllAppsList.addPackage(context, packages[i]);
2006                     }
2007                     break;
2008                 case OP_UPDATE:
2009                     for (int i=0; i&lt;N; i++) {
2010                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2011                         mBgAllAppsList.updatePackage(context, packages[i]);
2012                     }
2013                     break;
2014                 case OP_REMOVE:
2015                 case OP_UNAVAILABLE:
2016                     for (int i=0; i&lt;N; i++) {
2017                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2018                         mBgAllAppsList.removePackage(packages[i]);
2019                     }
2020                     break;
2021             }
2022 
2023             ArrayList&lt;ApplicationInfo&gt; added = null;
2024             ArrayList&lt;ApplicationInfo&gt; modified = null;
2025 
2026             if (mBgAllAppsList.added.size() &gt; 0) {
2027                 added = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.added);
2028                 mBgAllAppsList.added.clear();
2029             }
2030             if (mBgAllAppsList.modified.size() &gt; 0) {
2031                 modified = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.modified);
2032                 mBgAllAppsList.modified.clear();
2033             }
2034             // We may be removing packages that have no associated launcher application, so we
2035             // pass through the removed package names directly.
2036             // NOTE: We flush the icon cache aggressively in removePackage() above.
2037             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2038             if (mBgAllAppsList.removed.size() &gt; 0) {
2039                 mBgAllAppsList.removed.clear();
2040 
2041                 for (int i = 0; i &lt; N; ++i) {
2042                     removedPackageNames.add(packages[i]);
2043                 }
2044             }
2045 
2046             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2047             if (callbacks == null) {
2048                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2049                 return;
2050             }
2051 
2052             if (added != null) {
2053                 final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
2054                 mHandler.post(new Runnable() {
2055                     public void run() {
2056                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2057                         if (callbacks == cb &amp;&amp; cb != null) {
2058                             callbacks.bindAppsAdded(addedFinal);
2059                         }
2060                     }
2061                 });
2062             }
2063             if (modified != null) {
2064                 final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
2065                 mHandler.post(new Runnable() {
2066                     public void run() {
2067                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2068                         if (callbacks == cb &amp;&amp; cb != null) {
2069                             callbacks.bindAppsUpdated(modifiedFinal);
2070                         }
2071                     }
2072                 });
2073             }
2074             if (!removedPackageNames.isEmpty()) {
2075                 final boolean permanent = mOp != OP_UNAVAILABLE;
2076                 mHandler.post(new Runnable() {
2077                     public void run() {
2078                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2079                         if (callbacks == cb &amp;&amp; cb != null) {
2080                             callbacks.bindAppsRemoved(removedPackageNames, permanent);
2081                         }
2082                     }
2083                 });
2084             }
2085 
2086             mHandler.post(new Runnable() {
2087                 @Override
2088                 public void run() {
2089                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2090                     if (callbacks == cb &amp;&amp; cb != null) {
2091                         callbacks.bindPackagesUpdated();
2092                     }
2093                 }
2094             });
2095         }
2096     }
2097 
2098     /**
2099 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
2100 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="2101 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">2101 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
2102 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2103 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2104      * Returns all the Workspace ShortcutInfos associated with a particular package.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2105      * @param intent</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2106      * @return</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2107      */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2108     ArrayList&lt;ShortcutInfo&gt; getShortcutInfosForPackage(String packageName) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2109         ArrayList&lt;ShortcutInfo&gt; infos = new ArrayList&lt;ShortcutInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2110         synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2111             for (ItemInfo i : sBgWorkspaceItems) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2112                 if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2113                     ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2114                     if (packageName.equals(info.getPackageName())) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2115                         infos.add(info);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2116                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2117                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2118             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2119         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2120         return infos;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2121     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2122 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2123     /**</span>
2124 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
2125      * This is called from the code that adds shortcuts from the intent receiver.  This
2126      * doesn&#x27;t have a Cursor, but
2127      */
2128     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2129         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2130     }
2131 
2132     /**
2133      * Make an ShortcutInfo object for a shortcut that is an application.
2134      *
2135      * If c is not null, then it will be used to fill in missing data like the title and icon.
2136      */
2137     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2138             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2139         Bitmap icon = null;
2140         final ShortcutInfo info = new ShortcutInfo();
2141 
2142         ComponentName componentName = intent.getComponent();
2143         if (componentName == null) {
2144             return null;
2145         }
2146 
2147         try {
2148             PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2149             if (!pi.applicationInfo.enabled) {
2150                 // If we return null here, the corresponding item will be removed from the launcher
2151                 // db and will not appear in the workspace.
2152                 return null;
2153             }
2154         } catch (NameNotFoundException e) {
2155             Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2156         }
2157 
2158         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2159         // then return null &amp; delete this.
2160 
2161         // the resource -- This may implicitly give us back the fallback icon,
2162         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2163         // to avoid saving lots of copies of that in the database, and most apps
2164         // have icons anyway.
2165 
2166         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2167         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2168         // via resolveActivity().
2169         ResolveInfo resolveInfo = null;
2170         ComponentName oldComponent = intent.getComponent();
2171         Intent newIntent = new Intent(intent.getAction(), null);
2172         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2173         newIntent.setPackage(oldComponent.getPackageName());
2174         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2175         for (ResolveInfo i : infos) {
2176             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2177                     i.activityInfo.name);
2178             if (cn.equals(oldComponent)) {
2179                 resolveInfo = i;
2180             }
2181         }
2182         if (resolveInfo == null) {
2183             resolveInfo = manager.resolveActivity(intent, 0);
2184         }
2185         if (resolveInfo != null) {
2186             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2187         }
2188         // the db
2189         if (icon == null) {
2190             if (c != null) {
2191                 icon = getIconFromCursor(c, iconIndex, context);
2192             }
2193         }
2194         // the fallback icon
2195         if (icon == null) {
2196             icon = getFallbackIcon();
2197             info.usingFallbackIcon = true;
2198         }
2199         info.setIcon(icon);
2200 
2201         // from the resource
2202         if (resolveInfo != null) {
2203             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2204             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2205                 info.title = labelCache.get(key);
2206             } else {
2207                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2208                 if (labelCache != null) {
2209                     labelCache.put(key, info.title);
2210                 }
2211             }
2212         }
2213         // from the db
2214         if (info.title == null) {
2215             if (c != null) {
2216                 info.title =  c.getString(titleIndex);
2217             }
2218         }
2219         // fall back to the class name of the activity
2220         if (info.title == null) {
2221             info.title = componentName.getClassName();
2222         }
2223         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2224         return info;
2225     }
2226 
2227     /**
2228      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2229      */
2230     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2231             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2232             int titleIndex) {
2233 
2234         Bitmap icon = null;
2235         final ShortcutInfo info = new ShortcutInfo();
2236         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2237 
2238         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2239 
2240         info.title = c.getString(titleIndex);
2241 
2242         int iconType = c.getInt(iconTypeIndex);
2243         switch (iconType) {
2244         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2245             String packageName = c.getString(iconPackageIndex);
2246             String resourceName = c.getString(iconResourceIndex);
2247             PackageManager packageManager = context.getPackageManager();
2248             info.customIcon = false;
2249             // the resource
2250             try {
2251                 Resources resources = packageManager.getResourcesForApplication(packageName);
2252                 if (resources != null) {
2253                     final int id = resources.getIdentifier(resourceName, null, null);
2254                     icon = Utilities.createIconBitmap(
2255                             mIconCache.getFullResIcon(resources, id), context);
2256                 }
2257             } catch (Exception e) {
2258                 // drop this.  we have other places to look for icons
2259             }
2260             // the db
2261             if (icon == null) {
2262                 icon = getIconFromCursor(c, iconIndex, context);
2263             }
2264             // the fallback icon
2265             if (icon == null) {
2266                 icon = getFallbackIcon();
2267                 info.usingFallbackIcon = true;
2268             }
2269             break;
2270         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2271             icon = getIconFromCursor(c, iconIndex, context);
2272             if (icon == null) {
2273                 icon = getFallbackIcon();
2274                 info.customIcon = false;
2275                 info.usingFallbackIcon = true;
2276             } else {
2277                 info.customIcon = true;
2278             }
2279             break;
2280         default:
2281             icon = getFallbackIcon();
2282             info.usingFallbackIcon = true;
2283             info.customIcon = false;
2284             break;
2285         }
2286         info.setIcon(icon);
2287         return info;
2288     }
2289 
2290     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2291         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2292         final boolean debug = false;
2293         if (debug) {
2294             Log.d(TAG, &quot;getIconFromCursor app=&quot;
2295                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2296         }
2297         byte[] data = c.getBlob(iconIndex);
2298         try {
2299             return Utilities.createIconBitmap(
2300                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
2301         } catch (Exception e) {
2302             return null;
2303         }
2304     }
2305 
2306     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2307             int cellX, int cellY, boolean notify) {
2308         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2309         if (info == null) {
2310             return null;
2311         }
2312         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2313 
2314         return info;
2315     }
2316 
2317     /**
2318      * Attempts to find an AppWidgetProviderInfo that matches the given component.
2319      */
2320     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2321             ComponentName component) {
2322         List&lt;AppWidgetProviderInfo&gt; widgets =
2323             AppWidgetManager.getInstance(context).getInstalledProviders();
2324         for (AppWidgetProviderInfo info : widgets) {
2325             if (info.provider.equals(component)) {
2326                 return info;
2327             }
2328         }
2329         return null;
2330     }
2331 
2332     /**
2333      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2334      */
2335     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2336         final PackageManager packageManager = context.getPackageManager();
2337         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2338             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2339 
2340         final Intent supportsIntent =
2341             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2342         supportsIntent.setType(mimeType);
2343 
2344         // Create a set of widget configuration components that we can test against
2345         final List&lt;AppWidgetProviderInfo&gt; widgets =
2346             AppWidgetManager.getInstance(context).getInstalledProviders();
2347         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2348             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2349         for (AppWidgetProviderInfo info : widgets) {
2350             configurationComponentToWidget.put(info.configure, info);
2351         }
2352 
2353         // Run through each of the intents that can handle this type of clip data, and cross
2354         // reference them with the components that are actual configuration components
2355         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2356                 PackageManager.MATCH_DEFAULT_ONLY);
2357         for (ResolveInfo info : activities) {
2358             final ActivityInfo activityInfo = info.activityInfo;
2359             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2360                     activityInfo.name);
2361             if (configurationComponentToWidget.containsKey(infoComponent)) {
2362                 supportedConfigurationActivities.add(
2363                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2364                                 configurationComponentToWidget.get(infoComponent)));
2365             }
2366         }
2367         return supportedConfigurationActivities;
2368     }
2369 
2370     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2371         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2372         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2373         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2374 
2375         if (intent == null) {
2376             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2377             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2378             return null;
2379         }
2380 
2381         Bitmap icon = null;
2382         boolean customIcon = false;
2383         ShortcutIconResource iconResource = null;
2384 
2385         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2386             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2387             customIcon = true;
2388         } else {
2389             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2390             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2391                 try {
2392                     iconResource = (ShortcutIconResource) extra;
2393                     final PackageManager packageManager = context.getPackageManager();
2394                     Resources resources = packageManager.getResourcesForApplication(
2395                             iconResource.packageName);
2396                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2397                     icon = Utilities.createIconBitmap(
2398                             mIconCache.getFullResIcon(resources, id), context);
2399                 } catch (Exception e) {
2400                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2401                 }
2402             }
2403         }
2404 
2405         final ShortcutInfo info = new ShortcutInfo();
2406 
2407         if (icon == null) {
2408             if (fallbackIcon != null) {
2409                 icon = fallbackIcon;
2410             } else {
2411                 icon = getFallbackIcon();
2412                 info.usingFallbackIcon = true;
2413             }
2414         }
2415         info.setIcon(icon);
2416 
2417         info.title = name;
2418         info.intent = intent;
2419         info.customIcon = customIcon;
2420         info.iconResource = iconResource;
2421 
2422         return info;
2423     }
2424 
2425     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2426             int iconIndex) {
2427         // If apps can&#x27;t be on SD, don&#x27;t even bother.
2428         if (!mAppsCanBeOnExternalStorage) {
2429             return false;
2430         }
2431         // If this icon doesn&#x27;t have a custom icon, check to see
2432         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2433         // we&#x27;re going to show, store what we are going to show back
2434         // into the DB.  We do this so when we&#x27;re loading, if the
2435         // package manager can&#x27;t find an icon (for example because
2436         // the app is on SD) then we can use that instead.
2437         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2438             cache.put(info, c.getBlob(iconIndex));
2439             return true;
2440         }
2441         return false;
2442     }
2443     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2444         boolean needSave = false;
2445         try {
2446             if (data != null) {
2447                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2448                 Bitmap loaded = info.getIcon(mIconCache);
2449                 needSave = !saved.sameAs(loaded);
2450             } else {
2451                 needSave = true;
2452             }
2453         } catch (Exception e) {
2454             needSave = true;
2455         }
2456         if (needSave) {
2457             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2458             // This is slower than is ideal, but this only happens once
2459             // or when the app is updated with a new icon.
2460             updateItemInDatabase(context, info);
2461         }
2462     }
2463 
2464     /**
2465      * Return an existing FolderInfo object if we have encountered this ID previously,
2466      * or make a new one.
2467      */
2468     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2469         // See if a placeholder was created for us already
2470         FolderInfo folderInfo = folders.get(id);
2471         if (folderInfo == null) {
2472             // No placeholder -- create a new instance
2473             folderInfo = new FolderInfo();
2474             folders.put(id, folderInfo);
2475         }
2476         return folderInfo;
2477     }
2478 
2479     private static final Collator sCollator = Collator.getInstance();
2480     public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2481             = new Comparator&lt;ApplicationInfo&gt;() {
2482         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2483             int result = sCollator.compare(a.title.toString(), b.title.toString());
2484             if (result == 0) {
2485                 result = a.componentName.compareTo(b.componentName);
2486             }
2487             return result;
2488         }
2489     };
2490     public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2491             = new Comparator&lt;ApplicationInfo&gt;() {
2492         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2493             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2494             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2495             return 0;
2496         }
2497     };
2498     public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2499             = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2500         public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2501             return sCollator.compare(a.label.toString(), b.label.toString());
2502         }
2503     };
2504     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2505         if (info.activityInfo != null) {
2506             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2507         } else {
2508             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2509         }
2510     }
2511     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2512         private PackageManager mPackageManager;
2513         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2514         ShortcutNameComparator(PackageManager pm) {
2515             mPackageManager = pm;
2516             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2517         }
2518         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2519             mPackageManager = pm;
2520             mLabelCache = labelCache;
2521         }
2522         public final int compare(ResolveInfo a, ResolveInfo b) {
2523             CharSequence labelA, labelB;
2524             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2525             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2526             if (mLabelCache.containsKey(keyA)) {
2527                 labelA = mLabelCache.get(keyA);
2528             } else {
2529                 labelA = a.loadLabel(mPackageManager).toString();
2530 
2531                 mLabelCache.put(keyA, labelA);
2532             }
2533             if (mLabelCache.containsKey(keyB)) {
2534                 labelB = mLabelCache.get(keyB);
2535             } else {
2536                 labelB = b.loadLabel(mPackageManager).toString();
2537 
2538                 mLabelCache.put(keyB, labelB);
2539             }
2540             return sCollator.compare(labelA, labelB);
2541         }
2542     };
2543     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2544         private PackageManager mPackageManager;
2545         private HashMap&lt;Object, String&gt; mLabelCache;
2546         WidgetAndShortcutNameComparator(PackageManager pm) {
2547             mPackageManager = pm;
2548             mLabelCache = new HashMap&lt;Object, String&gt;();
2549         }
2550         public final int compare(Object a, Object b) {
2551             String labelA, labelB;
2552             if (mLabelCache.containsKey(a)) {
2553                 labelA = mLabelCache.get(a);
2554             } else {
2555                 labelA = (a instanceof AppWidgetProviderInfo) ?
2556                     ((AppWidgetProviderInfo) a).label :
2557                     ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2558                 mLabelCache.put(a, labelA);
2559             }
2560             if (mLabelCache.containsKey(b)) {
2561                 labelB = mLabelCache.get(b);
2562             } else {
2563                 labelB = (b instanceof AppWidgetProviderInfo) ?
2564                     ((AppWidgetProviderInfo) b).label :
2565                     ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2566                 mLabelCache.put(b, labelB);
2567             }
2568             return sCollator.compare(labelA, labelB);
2569         }
2570     };
2571 
2572     public void dumpState() {
2573         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
2574         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
2575         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
2576         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
2577         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
2578         if (mLoaderTask != null) {
2579             mLoaderTask.dumpState();
2580         } else {
2581             Log.d(TAG, &quot;mLoaderTask=null&quot;);
2582         }
2583     }
2584 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
  22  import android.content.BroadcastReceiver;
  23  import android.content.ComponentName;
  24  import android.content.ContentProviderClient;
  25  import android.content.ContentResolver;
  26  import android.content.ContentValues;
  27  import android.content.Context;
  28  import android.content.Intent;
  29  import android.content.Intent.ShortcutIconResource;
  30  import android.content.pm.ActivityInfo;
  31  import android.content.pm.PackageInfo;
  32  import android.content.pm.PackageManager;
  33  import android.content.pm.PackageManager.NameNotFoundException;
  34  import android.content.pm.ResolveInfo;
  35  import android.content.res.Configuration;
  36  import android.content.res.Resources;
  37  import android.database.Cursor;
  38  import android.graphics.Bitmap;
  39  import android.graphics.BitmapFactory;
  40  import android.net.Uri;
  41  import android.os.Environment;
  42  import android.os.Handler;
  43  import android.os.HandlerThread;
  44  import android.os.Parcelable;
  45  import android.os.Process;
  46  import android.os.RemoteException;
  47  import android.os.SystemClock;
  48  import android.util.Log;
  49  
  50  import com.android.launcher.R;
  51  import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52  
  53  import java.lang.ref.WeakReference;
  54  import java.net.URISyntaxException;
  55  import java.text.Collator;
  56  import java.util.ArrayList;
  57  import java.util.Collections;
  58  import java.util.Comparator;
  59  import java.util.HashMap;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +import java.util.HashSet;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import java.util.Iterator;</span>
  62  import java.util.List;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import java.util.Set;</span>
  64  
  65  /**
  66   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67   * LauncherModel object held in a static. Also provide APIs for updating the database state
  68   * for the Launcher.
  69   */
  70  public class LauncherModel extends BroadcastReceiver {
  71      static final boolean DEBUG_LOADERS = false;
  72      static final String TAG = &quot;Launcher.Model&quot;;
  73  
  74      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75      private final boolean mAppsCanBeOnExternalStorage;
  76      private int mBatchSize; // 0 is all apps at once
  77      private int mAllAppsLoadDelay; // milliseconds between batches
  78  
  79      private final LauncherApplication mApp;
  80      private final Object mLock = new Object();
  81      private DeferredHandler mHandler = new DeferredHandler();
  82      private LoaderTask mLoaderTask;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +    private boolean mIsLoaderTaskRunning;</span>
  84  
  85      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86      static {
  87          sWorkerThread.start();
  88      }
  89      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90  
  91      // We start off with everything not loaded.  After that, we assume that
  92      // our monitoring of the package manager provides all updates and we never
  93      // need to do a requery.  These are only ever touched from the loader thread.
  94      private boolean mWorkspaceLoaded;
  95      private boolean mAllAppsLoaded;
  96  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +    // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +    // pages as this delays the rotation process.  Instead, we wait for a callback from the first</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +    // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +    // a normal load, we also clear this set of Runnables.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +    static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +</span>
 103      private WeakReference&lt;Callbacks&gt; mCallbacks;
 104  
 105      // &lt; only access in worker thread &gt;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -    private AllAppsList mAllAppsList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -    // sItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +    private AllAppsList mBgAllAppsList;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +    // The lock that must be acquired before referencing any static bg data structures.  Unlike</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +    // other locks, this one can generally be held long-term because we never expect any of these</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +    // static data structures to be referenced outside of the worker thread except on the first</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +    // load after configuration change.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +    static final Object sBgLock = new Object();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +    // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by</span>
 118      // LauncherModel to their ids
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -    static final HashMap&lt;Long, ItemInfo&gt; sItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 121 -    // sItems is passed to bindItems, which expects a list of all folders and shortcuts created by</span>



<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -    //       LauncherModel that are directly on the home screen (however, no widgets or shortcuts</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 123 -    //       within folders).</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -    static final ArrayList&lt;ItemInfo&gt; sWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -    // sAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -    static final ArrayList&lt;LauncherAppWidgetInfo&gt; sAppWidgets =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +    static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +    // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +    //       created by LauncherModel that are directly on the home screen (however, no widgets or</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +    //       shortcuts within folders).</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +    static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +    // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +    static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =</span>
 137          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 138  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -    // sFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -    static final HashMap&lt;Long, FolderInfo&gt; sFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -    // sDbIconCache is the set of ItemInfos that need to have their icons updated in the database</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -    static final HashMap&lt;Object, byte[]&gt; sDbIconCache = new HashMap&lt;Object, byte[]&gt;();</span>





<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +    // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +    static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +    // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +    static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();</span>
 150      // &lt;/ only access in worker thread &gt;
 151  
 152      private IconCache mIconCache;
 153      private Bitmap mDefaultIcon;
 154  
 155      private static int mCellCountX;
 156      private static int mCellCountY;
 157  
 158      protected int mPreviousConfigMcc;
 159  
 160      public interface Callbacks {
 161          public boolean setLoadOnResume();
 162          public int getCurrentWorkspaceScreen();
 163          public void startBinding();
 164          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 165          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 166          public void finishBindingItems();
 167          public void bindAppWidget(LauncherAppWidgetInfo info);
 168          public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 169          public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 170          public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -        public void bindAppsRemoved(ArrayList&lt;ApplicationInfo&gt; apps, boolean permanent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +        public void bindAppsRemoved(ArrayList&lt;String&gt; packageNames, boolean permanent);</span>
 173          public void bindPackagesUpdated();
 174          public boolean isAllAppsVisible();
 175          public boolean isAllAppsButtonRank(int rank);
 176          public void bindSearchablesChanged();
 177      }
 178  
 179      LauncherModel(LauncherApplication app, IconCache iconCache) {
 180          mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 181          mApp = app;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -        mAllAppsList = new AllAppsList(iconCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +        mBgAllAppsList = new AllAppsList(iconCache);</span>
 184          mIconCache = iconCache;
 185  
 186          mDefaultIcon = Utilities.createIconBitmap(
 187                  mIconCache.getFullResDefaultActivityIcon(), app);
 188  
 189          final Resources res = app.getResources();
 190          mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 191          mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 192          Configuration config = res.getConfiguration();
 193          mPreviousConfigMcc = config.mcc;
 194      }
 195  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +    /** Runs the specified runnable immediately if called from the main thread, otherwise it is</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +     * posted on the main thread handler. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +    private void runOnMainThread(Runnable r) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 199 +        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +            // If we are on the worker thread, post onto the main handler</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +            mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +            r.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +    /** Runs the specified runnable immediately if called from the worker thread, otherwise it is</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +     * posted on the worker thread handler. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +    private static void runOnWorkerThread(Runnable r) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +            r.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +            // If we are not on the worker thread, then post to the worker handler</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +            sWorker.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +</span>
 218      public Bitmap getFallbackIcon() {
 219          return Bitmap.createBitmap(mDefaultIcon);
 220      }
 221  
 222      public void unbindWorkspaceItems() {
 223          sWorker.post(new Runnable() {
 224              @Override
 225              public void run() {
 226                  unbindWorkspaceItemsOnMainThread();
 227              }
 228          });
 229      }
 230  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -    /** Unbinds all the sWorkspaceItems on the main thread, and return a copy of sWorkspaceItems</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -     * that is save to reference from the main thread. */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -    private ArrayList&lt;ItemInfo&gt; unbindWorkspaceItemsOnMainThread() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +    /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +    private void unbindWorkspaceItemsOnMainThread() {</span>
 236          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 237          // by making a copy of workspace items first.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -        final ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;(sWorkspaceItems);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -        final ArrayList&lt;ItemInfo&gt; appWidgets = new ArrayList&lt;ItemInfo&gt;(sAppWidgets);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -        mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 241 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -            public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -               for (ItemInfo item : workspaceItems) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 244 -                   item.unbind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 245 -               }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 246 -               for (ItemInfo item : appWidgets) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -                   item.unbind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 248 -               }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 249 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 250 -        });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -        return workspaceItems;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +        final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +        final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +        synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +            tmpWorkspaceItems.addAll(sBgWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +            tmpAppWidgets.addAll(sBgAppWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +                   for (ItemInfo item : tmpWorkspaceItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +                       item.unbind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +                   }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 265 +                   for (ItemInfo item : tmpAppWidgets) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 266 +                       item.unbind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +                   }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +        runOnMainThread(r);</span>
 271      }
 272  
 273      /**
 274       * Adds an item to the DB if it was not created previously, or move it to a new
 275       * &lt;container, screen, cellX, cellY&gt;
 276       */
 277      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 278              int screen, int cellX, int cellY) {
 279          if (item.container == ItemInfo.NO_ID) {
 280              // From all apps
 281              addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 282          } else {
 283              // From somewhere else
 284              moveItemInDatabase(context, item, container, screen, cellX, cellY);
 285          }
 286      }
 287  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +    static void checkItemInfo(final ItemInfo item) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +        final long itemId = item.id;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +                    synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +                        ItemInfo modelItem = sBgItemsIdMap.get(itemId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 295 +                        if (modelItem != null &amp;&amp; item != modelItem) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 296 +                            // the modelItem needs to match up perfectly with item if our model is</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 297 +                            // to be consistent with the database-- for now, just require</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 298 +                            // modelItem == item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 299 +                            String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 300 +                                &quot;modelItem: &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 301 +                                    ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 302 +                                &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 303 +                            RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +                            e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +                            throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +        runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +</span>
 313      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 314              final ItemInfo item, final String callingFunction) {
 315          final long itemId = item.id;
 316          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 317          final ContentResolver cr = context.getContentResolver();
 318  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
 320          Runnable r = new Runnable() {
 321              public void run() {
 322                  cr.update(uri, values, null, null);
 323  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 324 -                ItemInfo modelItem = sItemsIdMap.get(itemId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 325 -                if (item != modelItem) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 326 -                    // the modelItem needs to match up perfectly with item if our model is to be</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 327 -                    // consistent with the database-- for now, just require modelItem == item</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 328 -                    String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -                        &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 330 -                        &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match original&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 331 -                    throw new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 332 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 333 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 334 -                // Items are added/removed from the corresponding FolderInfo elsewhere, such</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 335 -                // as in Workspace.onDrop. Here, we just add/remove them from the list of items</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 336 -                // that are on the desktop, as appropriate</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 337 -                if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 338 -                        modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 339 -                    if (!sWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 340 -                        sWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 341 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 342 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 343 -                    sWorkspaceItems.remove(modelItem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 344 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 345 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +                    ItemInfo modelItem = sBgItemsIdMap.get(itemId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +                    if (item != modelItem) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +                        // the modelItem needs to match up perfectly with item if our model is to be</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +                        // consistent with the database-- for now, just require modelItem == item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +                        String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 351 +                            &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 352 +                            &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 353 +                            &quot;original&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +                        throw new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 356 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 357 +                    if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 358 +                            item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 359 +                        // Item is in a folder, make sure this folder exists</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +                        if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +                            // An items container is being set to a that of an item which is not in</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 362 +                            // the list of Folders.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 363 +                            String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 364 +                                    item.container + &quot;, not in the list of folders&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +                            RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 366 +                            e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 367 +                            Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 368 +                            throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 369 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 370 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 371 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +                    // Items are added/removed from the corresponding FolderInfo elsewhere, such</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 373 +                    // as in Workspace.onDrop. Here, we just add/remove them from the list of items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 374 +                    // that are on the desktop, as appropriate</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 375 +                    if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +                            modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +                        switch (modelItem.itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +                            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +                            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 381 +                                if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 382 +                                    sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 383 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 385 +                            default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 386 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 387 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 388 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 389 +                        sBgWorkspaceItems.remove(modelItem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 390 +                    }</span>
 391                  }
 392              }
 393          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 395 -        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 396 -            r.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 397 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 398 -            sWorker.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 399 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 400 +        runOnWorkerThread(r);</span>
 401      }
 402  
 403      /**
 404       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 405       */
 406      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 407              final int screen, final int cellX, final int cellY) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 408 +        String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 409 +                &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 410 +                &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 411 +        Launcher.sDumpLogs.add(transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 412 +        Log.d(TAG, transaction);</span>
 413          item.container = container;
 414          item.cellX = cellX;
 415          item.cellY = cellY;
 416  
 417          // We store hotseat items in canonical form which is this orientation invariant position
 418          // in the hotseat
 419          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 420                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 421              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 422          } else {
 423              item.screen = screen;
 424          }
 425  
 426          final ContentValues values = new ContentValues();
 427          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 428          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 429          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 430          values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 431  
 432          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 433      }
 434  
 435      /**
 436       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 437       */
 438      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 439              final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 440 -        item.container = container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 441 +        String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 442 +                &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 443 +                &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 444 +        Launcher.sDumpLogs.add(transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 445 +        Log.d(TAG, transaction);</span>
 446          item.cellX = cellX;
 447          item.cellY = cellY;
 448          item.spanX = spanX;
 449          item.spanY = spanY;
 450  
 451          // We store hotseat items in canonical form which is this orientation invariant position
 452          // in the hotseat
 453          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 454                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 455              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 456          } else {
 457              item.screen = screen;
 458          }
 459  
 460          final ContentValues values = new ContentValues();
 461          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 462          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 463          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 464          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 465          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 466          values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 467  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 468 -        updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +        updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);</span>
 470      }
 471  
 472      /**
 473       * Update an item to the database in a specified container.
 474       */
 475      static void updateItemInDatabase(Context context, final ItemInfo item) {
 476          final ContentValues values = new ContentValues();
 477          item.onAddToDatabase(values);
 478          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 479          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 480      }
 481  
 482      /**
 483       * Returns true if the shortcuts already exists in the database.
 484       * we identify a shortcut by its title and intent.
 485       */
 486      static boolean shortcutExists(Context context, String title, Intent intent) {
 487          final ContentResolver cr = context.getContentResolver();
 488          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 489              new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 490              new String[] { title, intent.toUri(0) }, null);
 491          boolean result = false;
 492          try {
 493              result = c.moveToFirst();
 494          } finally {
 495              c.close();
 496          }
 497          return result;
 498      }
 499  
 500      /**
 501       * Returns an ItemInfo array containing all the items in the LauncherModel.
 502       * The ItemInfo.id is not set through this function.
 503       */
 504      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 505          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 506          final ContentResolver cr = context.getContentResolver();
 507          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 508                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 509                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 509                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CEðŸ”µ</abbr>
 510                  LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 511  
 512          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 513          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 514          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 515          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 516          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 517          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 518          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 519  
 520          try {
 521              while (c.moveToNext()) {
 522                  ItemInfo item = new ItemInfo();
 523                  item.cellX = c.getInt(cellXIndex);
 524                  item.cellY = c.getInt(cellYIndex);
 525                  item.spanX = c.getInt(spanXIndex);
 526                  item.spanY = c.getInt(spanYIndex);
 527                  item.container = c.getInt(containerIndex);
 528                  item.itemType = c.getInt(itemTypeIndex);
 529                  item.screen = c.getInt(screenIndex);
 530  
 531                  items.add(item);
 532              }
 533          } catch (Exception e) {
 534              items.clear();
 535          } finally {
 536              c.close();
 537          }
 538  
 539          return items;
 540      }
 541  
 542      /**
 543       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 544       */
 545      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 546          final ContentResolver cr = context.getContentResolver();
 547          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 548                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 549                  new String[] { String.valueOf(id),
 550                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 551  
 552          try {
 553              if (c.moveToFirst()) {
 554                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 555                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 556                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 557                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 558                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 559                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 560  
 561                  FolderInfo folderInfo = null;
 562                  switch (c.getInt(itemTypeIndex)) {
 563                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 564                          folderInfo = findOrMakeFolder(folderList, id);
 565                          break;
 566                  }
 567  
 568                  folderInfo.title = c.getString(titleIndex);
 569                  folderInfo.id = id;
 570                  folderInfo.container = c.getInt(containerIndex);
 571                  folderInfo.screen = c.getInt(screenIndex);
 572                  folderInfo.cellX = c.getInt(cellXIndex);
 573                  folderInfo.cellY = c.getInt(cellYIndex);
 574  
 575                  return folderInfo;
 576              }
 577          } finally {
 578              c.close();
 579          }
 580  
 581          return null;
 582      }
 583  
 584      /**
 585       * Add an item to the database in a specified container. Sets the container, screen, cellX and
 586       * cellY fields of the item. Also assigns an ID to the item.
 587       */
 588      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 589              final int screen, final int cellX, final int cellY, final boolean notify) {
 590          item.container = container;
 591          item.cellX = cellX;
 592          item.cellY = cellY;
 593          // We store hotseat items in canonical form which is this orientation invariant position
 594          // in the hotseat
 595          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 596                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 597              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 598          } else {
 599              item.screen = screen;
 600          }
 601  
 602          final ContentValues values = new ContentValues();
 603          final ContentResolver cr = context.getContentResolver();
 604          item.onAddToDatabase(values);
 605  
 606          LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 607          item.id = app.getLauncherProvider().generateNewId();
 608          values.put(LauncherSettings.Favorites._ID, item.id);
 609          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 610  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 611 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 612 +</span>
 613          Runnable r = new Runnable() {
 614              public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 615 +                String transaction = &quot;DbDebug    Add item (&quot; + item.title + &quot;) to db, id: &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 616 +                        + item.id + &quot; (&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 617 +                        + cellY + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 618 +                Launcher.sDumpLogs.add(transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 619 +                Log.d(TAG, transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 620 +</span>
 621                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 622                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 623  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -                if (sItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -                    // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -                    throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -                        &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 629 -                sItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 630 -                switch (item.itemType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 631 -                    case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -                        sFolders.put(item.id, (FolderInfo) item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 633 -                        // Fall through</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 634 -                    case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -                    case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 636 -                        if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -                                item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 638 -                            sWorkspaceItems.add(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 639 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 640 -                        break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -                    case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -                        sAppWidgets.add((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 644 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 645 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 646 +                    if (sBgItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 647 +                        // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +                        throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +                            &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 650 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +                    sBgItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +                    switch (item.itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 653 +                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 654 +                            sBgFolders.put(item.id, (FolderInfo) item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 655 +                            // Fall through</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 656 +                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +                            if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 659 +                                    item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +                                sBgWorkspaceItems.add(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +                                if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +                                    // Adding an item to a folder that doesn&#x27;t exist.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +                                    String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +                                            &quot; doesn&#x27;t exist&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +                                    RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +                                    e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +                                    Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +                                    throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 673 +                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 674 +                            sBgAppWidgets.add((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 675 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 676 +                    }</span>
 677                  }
 678              }
 679          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -            r.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -            sWorker.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 685 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 686 +        runOnWorkerThread(r);</span>
 687      }
 688  
 689      /**
 690       * Creates a new unique child id, for a given cell span across all layouts.
 691       */
 692      static int getCellLayoutChildId(
 693              long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 694          return (((int) container &amp; 0xFF) &lt;&lt; 24)
 695                  | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 696      }
 697  
 698      static int getCellCountX() {
 699          return mCellCountX;
 700      }
 701  
 702      static int getCellCountY() {
 703          return mCellCountY;
 704      }
 705  
 706      /**
 707       * Updates the model orientation helper to take into account the current layout dimensions
 708       * when performing local/canonical coordinate transformations.
 709       */
 710      static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 711          mCellCountX = shortAxisCellCount;
 712          mCellCountY = longAxisCellCount;
 713      }
 714  
 715      /**
 716       * Removes the specified item from the database
 717       * @param context
 718       * @param item
 719       */
 720      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 721          final ContentResolver cr = context.getContentResolver();
 722          final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 723 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 724 +</span>
 725          Runnable r = new Runnable() {
 726              public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 727 +                String transaction = &quot;DbDebug    Delete item (&quot; + item.title + &quot;) from db, id: &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 728 +                        + item.id + &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 729 +                        &quot;, &quot; + item.cellY + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 730 +                Launcher.sDumpLogs.add(transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 731 +                Log.d(TAG, transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 732 +</span>
 733                  cr.delete(uriToDelete, null, null);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 734 -                switch (item.itemType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 735 -                    case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 736 -                        sFolders.remove(item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 737 -                        sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 738 -                        break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 739 -                    case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 740 -                    case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 741 -                        sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 742 -                        break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 743 -                    case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 744 -                        sAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 745 -                        break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 746 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 747 -                sItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 748 -                sDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 749 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 750 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 751 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 752 +                    switch (item.itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 753 +                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 754 +                            sBgFolders.remove(item.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 755 +                            for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 756 +                                if (info.container == item.id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 757 +                                    // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 758 +                                    // think they are contained by that folder.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 759 +                                    String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 760 +                                            &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 761 +                                    RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 762 +                                    e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 763 +                                    Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 764 +                                    throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 765 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 766 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 767 +                            sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 768 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 769 +                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 770 +                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 771 +                            sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 772 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 773 +                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 774 +                            sBgAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 775 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 776 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 777 +                    sBgItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 778 +                    sBgDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 779 +                }</span>
 780              }
 781          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 782 -        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 783 -            r.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 784 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 785 -            sWorker.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 786 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 787 +        runOnWorkerThread(r);</span>
 788      }
 789  
 790      /**
 791       * Remove the contents of the specified folder from the database
 792       */
 793      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 794          final ContentResolver cr = context.getContentResolver();
 795  
 796          Runnable r = new Runnable() {
 797              public void run() {
 798                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 799 -                sItemsIdMap.remove(info.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 800 -                sFolders.remove(info.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 801 -                sDbIconCache.remove(info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 802 -                sWorkspaceItems.remove(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 803 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 804 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 805 +                    sBgItemsIdMap.remove(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 806 +                    sBgFolders.remove(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 807 +                    sBgDbIconCache.remove(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 808 +                    sBgWorkspaceItems.remove(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 809 +                }</span>
 810  
 811                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 812                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 813 -                for (ItemInfo childInfo : info.contents) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 814 -                    sItemsIdMap.remove(childInfo.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 815 -                    sDbIconCache.remove(childInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 816 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 817 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 818 +                    for (ItemInfo childInfo : info.contents) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 819 +                        sBgItemsIdMap.remove(childInfo.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 820 +                        sBgDbIconCache.remove(childInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 821 +                    }</span>
 822                  }
 823              }
 824          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 825 -        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 826 -            r.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 827 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 828 -            sWorker.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 829 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +        runOnWorkerThread(r);</span>
 831      }
 832  
 833      /**
 834       * Set this as the current Launcher activity object for the loader.
 835       */
 836      public void initialize(Callbacks callbacks) {
 837          synchronized (mLock) {
 838              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 839          }
 840      }
 841  
 842      /**
 843       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 844       * ACTION_PACKAGE_CHANGED.
 845       */
 846      @Override
 847      public void onReceive(Context context, Intent intent) {
 848          if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 849  
 850          final String action = intent.getAction();
 851  
 852          if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 853                  || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 854                  || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 855              final String packageName = intent.getData().getSchemeSpecificPart();
 856              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 857  
 858              int op = PackageUpdatedTask.OP_NONE;
 859  
 860              if (packageName == null || packageName.length() == 0) {
 861                  // they sent us a bad intent
 862                  return;
 863              }
 864  
 865              if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 866                  op = PackageUpdatedTask.OP_UPDATE;
 867              } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 868                  if (!replacing) {
 869                      op = PackageUpdatedTask.OP_REMOVE;
 870                  }
 871                  // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 872                  // later, we will update the package at this time
 873              } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 874                  if (!replacing) {
 875                      op = PackageUpdatedTask.OP_ADD;
 876                  } else {
 877                      op = PackageUpdatedTask.OP_UPDATE;
 878                  }
 879              }
 880  
 881              if (op != PackageUpdatedTask.OP_NONE) {
 882                  enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 883              }
 884  
 885          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 886              // First, schedule to add these apps back in.
 887              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 888              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 889              // Then, rebind everything.
 890              startLoaderFromBackground();
 891          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 892              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 893              enqueuePackageUpdated(new PackageUpdatedTask(
 894                          PackageUpdatedTask.OP_UNAVAILABLE, packages));
 895          } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 896              // If we have changed locale we need to clear out the labels in all apps/workspace.
 897              forceReload();
 898          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 899               // Check if configuration change was an mcc/mnc change which would affect app resources
 900               // and we would need to clear out the labels in all apps/workspace. Same handling as
 901               // above for ACTION_LOCALE_CHANGED
 902               Configuration currentConfig = context.getResources().getConfiguration();
 903               if (mPreviousConfigMcc != currentConfig.mcc) {
 904                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 905                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 906                     forceReload();
 907               }
 908               // Update previousConfig
 909               mPreviousConfigMcc = currentConfig.mcc;
 910          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 911                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 912              if (mCallbacks != null) {
 913                  Callbacks callbacks = mCallbacks.get();
 914                  if (callbacks != null) {
 915                      callbacks.bindSearchablesChanged();
 916                  }
 917              }
 918          }
 919      }
 920  
 921      private void forceReload() {
 922          resetLoadedState(true, true);
 923  
 924          // Do this here because if the launcher activity is running it will be restarted.
 925          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 926          // to reload.
 927          startLoaderFromBackground();
 928      }
 929  
 930      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 931          synchronized (mLock) {
 932              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 933              // mWorkspaceLoaded to true later
 934              stopLoaderLocked();
 935              if (resetAllAppsLoaded) mAllAppsLoaded = false;
 936              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 937          }
 938      }
 939  
 940      /**
 941       * When the launcher is in the background, it&#x27;s possible for it to miss paired
 942       * configuration changes.  So whenever we trigger the loader from the background
 943       * tell the launcher that it needs to re-run the loader when it comes back instead
 944       * of doing it now.
 945       */
 946      public void startLoaderFromBackground() {
 947          boolean runLoader = false;
 948          if (mCallbacks != null) {
 949              Callbacks callbacks = mCallbacks.get();
 950              if (callbacks != null) {
 951                  // Only actually run the loader if they&#x27;re not paused.
 952                  if (!callbacks.setLoadOnResume()) {
 953                      runLoader = true;
 954                  }
 955              }
 956          }
 957          if (runLoader) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 958 -            startLoader(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 959 +            startLoader(false, -1);</span>
 960          }
 961      }
 962  
 963      // If there is already a loader task running, tell it to stop.
 964      // returns true if isLaunching() was true on the old task
 965      private boolean stopLoaderLocked() {
 966          boolean isLaunching = false;
 967          LoaderTask oldTask = mLoaderTask;
 968          if (oldTask != null) {
 969              if (oldTask.isLaunching()) {
 970                  isLaunching = true;
 971              }
 972              oldTask.stopLocked();
 973          }
 974          return isLaunching;
 975      }
 976  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 977 -    public void startLoader(boolean isLaunching) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 978 +    public void startLoader(boolean isLaunching, int synchronousBindPage) {</span>
 979          synchronized (mLock) {
 980              if (DEBUG_LOADERS) {
 981                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 982              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 983 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 984 +            // Clear any deferred bind-runnables from the synchronized load process</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 985 +            // We must do this before any loading/binding is scheduled below.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 986 +            mDeferredBindRunnables.clear();</span>
 987  
 988              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 989              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 990                  // If there is already one running, tell it to stop.
 991                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 992                  isLaunching = isLaunching || stopLoaderLocked();
 993                  mLoaderTask = new LoaderTask(mApp, isLaunching);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 994 -                sWorkerThread.setPriority(Thread.NORM_PRIORITY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 995 -                sWorker.post(mLoaderTask);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 996 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 997 +                if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 998 +                    mLoaderTask.runBindSynchronousPage(synchronousBindPage);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 999 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1000 +                    sWorkerThread.setPriority(Thread.NORM_PRIORITY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1001 +                    sWorker.post(mLoaderTask);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1002 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1003 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1004 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1005 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1006 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1007 +    void bindRemainingSynchronousPages() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1008 +        // Post the remaining side pages to be loaded</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1009 +        if (!mDeferredBindRunnables.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1010 +            for (final Runnable r : mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1011 +                mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1012 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1013 +            mDeferredBindRunnables.clear();</span>
1014          }
1015      }
1016  
1017      public void stopLoader() {
1018          synchronized (mLock) {
1019              if (mLoaderTask != null) {
1020                  mLoaderTask.stopLocked();
1021              }
1022          }
1023      }
1024  
1025      public boolean isAllAppsLoaded() {
1026          return mAllAppsLoaded;
1027      }
1028  
1029      boolean isLoadingWorkspace() {
1030          synchronized (mLock) {
1031              if (mLoaderTask != null) {
1032                  return mLoaderTask.isLoadingWorkspace();
1033              }
1034          }
1035          return false;
1036      }
1037  
1038      /**
1039       * Runnable for the thread that loads the contents of the launcher:
1040       *   - workspace icons
1041       *   - widgets
1042       *   - all apps icons
1043       */
1044      private class LoaderTask implements Runnable {
1045          private Context mContext;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1046 -        private Thread mWaitThread;</span>
1047          private boolean mIsLaunching;
1048          private boolean mIsLoadingAndBindingWorkspace;
1049          private boolean mStopped;
1050          private boolean mLoadAndBindStepFinished;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1051 +</span>
1052          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1053  
1054          LoaderTask(Context context, boolean isLaunching) {
1055              mContext = context;
1056              mIsLaunching = isLaunching;
1057              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1058          }
1059  
1060          boolean isLaunching() {
1061              return mIsLaunching;
1062          }
1063  
1064          boolean isLoadingWorkspace() {
1065              return mIsLoadingAndBindingWorkspace;
1066          }
1067  
1068          private void loadAndBindWorkspace() {
1069              mIsLoadingAndBindingWorkspace = true;
1070  
1071              // Load the workspace
1072              if (DEBUG_LOADERS) {
1073                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1074              }
1075  
1076              if (!mWorkspaceLoaded) {
1077                  loadWorkspace();
1078                  synchronized (LoaderTask.this) {
1079                      if (mStopped) {
1080                          return;
1081                      }
1082                      mWorkspaceLoaded = true;
1083                  }
1084              }
1085  
1086              // Bind the workspace
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1087 -            bindWorkspace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1088 +            bindWorkspace(-1);</span>
1089          }
1090  
1091          private void waitForIdle() {
1092              // Wait until the either we&#x27;re stopped or the other threads are done.
1093              // This way we don&#x27;t start loading all apps until the workspace has settled
1094              // down.
1095              synchronized (LoaderTask.this) {
1096                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1097  
1098                  mHandler.postIdle(new Runnable() {
1099                          public void run() {
1100                              synchronized (LoaderTask.this) {
1101                                  mLoadAndBindStepFinished = true;
1102                                  if (DEBUG_LOADERS) {
1103                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1104                                  }
1105                                  LoaderTask.this.notify();
1106                              }
1107                          }
1108                      });
1109  
1110                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1111                      try {
1112                          this.wait();
1113                      } catch (InterruptedException ex) {
1114                          // Ignore
1115                      }
1116                  }
1117                  if (DEBUG_LOADERS) {
1118                      Log.d(TAG, &quot;waited &quot;
1119                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1120                              + &quot;ms for previous step to finish binding&quot;);
1121                  }
1122              }
1123          }
1124  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1125 +        void runBindSynchronousPage(int synchronousBindPage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1126 +            if (synchronousBindPage &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1127 +                // Ensure that we have a valid page index to load synchronously</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1128 +                throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1129 +                        &quot;valid page index&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1130 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1131 +            if (!mAllAppsLoaded || !mWorkspaceLoaded) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1132 +                // Ensure that we don&#x27;t try and bind a specified page when the pages have not been</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1133 +                // loaded already (we should load everything asynchronously in that case)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1134 +                throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1135 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1136 +            synchronized (mLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1137 +                if (mIsLoaderTaskRunning) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1138 +                    // Ensure that we are never running the background loading at this point since</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1139 +                    // we also touch the background collections</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1140 +                    throw new RuntimeException(&quot;Error! Background loading is already running&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1141 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1142 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1143 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1144 +            // XXX: Throw an exception if we are already loading (since we touch the worker thread</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1145 +            //      data structures, we can&#x27;t allow any other thread to touch that data, but because</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1146 +            //      this call is synchronous, we can get away with not locking).</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1147 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1148 +            // Divide the set of loaded items into those that we are binding synchronously, and</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1149 +            // everything else that is to be bound normally (asynchronously).</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1150 +            bindWorkspace(synchronousBindPage);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1151 +            // XXX: For now, continue posting the binding of AllApps as there are other issues that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1152 +            //      arise from that.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1153 +            onlyBindAllApps();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1154 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1155 +</span>
1156          public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1157 +            synchronized (mLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1158 +                mIsLoaderTaskRunning = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1159 +            }</span>
1160              // Optimize for end-user experience: if the Launcher is up and // running with the
1161              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1162              // workspace first (default).
1163              final Callbacks cbk = mCallbacks.get();
1164              final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1165  
1166              keep_running: {
1167                  // Elevate priority when Home launches for the first time to avoid
1168                  // starving at boot time. Staring at a blank home is not cool.
1169                  synchronized (mLock) {
1170                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1171                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1172                      android.os.Process.setThreadPriority(mIsLaunching
1173                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1174                  }
1175                  if (loadWorkspaceFirst) {
1176                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1177                      loadAndBindWorkspace();
1178                  } else {
1179                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1180                      loadAndBindAllApps();
1181                  }
1182  
1183                  if (mStopped) {
1184                      break keep_running;
1185                  }
1186  
1187                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1188                  // settled down.
1189                  synchronized (mLock) {
1190                      if (mIsLaunching) {
1191                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1192                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1193                      }
1194                  }
1195                  waitForIdle();
1196  
1197                  // second step
1198                  if (loadWorkspaceFirst) {
1199                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1200                      loadAndBindAllApps();
1201                  } else {
1202                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1203                      loadAndBindWorkspace();
1204                  }
1205  
1206                  // Restore the default thread priority after we are done loading items
1207                  synchronized (mLock) {
1208                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1209                  }
1210              }
1211  
1212  
1213              // Update the saved icons if necessary
1214              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1215 -            for (Object key : sDbIconCache.keySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1216 -                updateSavedIcon(mContext, (ShortcutInfo) key, sDbIconCache.get(key));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1217 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1218 -            sDbIconCache.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1219 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1220 +                for (Object key : sBgDbIconCache.keySet()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1221 +                    updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1222 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1223 +                sBgDbIconCache.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1224 +            }</span>
1225  
1226              // Clear out this reference, otherwise we end up holding it until all of the
1227              // callback runnables are done.
1228              mContext = null;
1229  
1230              synchronized (mLock) {
1231                  // If we are still the last one to be scheduled, remove ourselves.
1232                  if (mLoaderTask == this) {
1233                      mLoaderTask = null;
1234                  }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1235 +                mIsLoaderTaskRunning = false;</span>
1236              }
1237          }
1238  
1239          public void stopLocked() {
1240              synchronized (LoaderTask.this) {
1241                  mStopped = true;
1242                  this.notify();
1243              }
1244          }
1245  
1246          /**
1247           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1248           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1249           * object that was around when the deferred message was scheduled, and if there&#x27;s
1250           * a new Callbacks object around then also return null.  This will save us from
1251           * calling onto it with data that will be ignored.
1252           */
1253          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1254              synchronized (mLock) {
1255                  if (mStopped) {
1256                      return null;
1257                  }
1258  
1259                  if (mCallbacks == null) {
1260                      return null;
1261                  }
1262  
1263                  final Callbacks callbacks = mCallbacks.get();
1264                  if (callbacks != oldCallbacks) {
1265                      return null;
1266                  }
1267                  if (callbacks == null) {
1268                      Log.w(TAG, &quot;no mCallbacks&quot;);
1269                      return null;
1270                  }
1271  
1272                  return callbacks;
1273              }
1274          }
1275  
1276          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1277          private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1278              int containerIndex = item.screen;
1279              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1280                  // Return early if we detect that an item is under the hotseat button
1281                  if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1282                      return false;
1283                  }
1284  
1285                  // We use the last index to refer to the hotseat and the screen as the rank, so
1286                  // test and update the occupied state accordingly
1287                  if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1288                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1289                          + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1290                          + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1291                      return false;
1292                  } else {
1293                      occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1294                      return true;
1295                  }
1296              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1297                  // Skip further checking if it is not the hotseat or workspace container
1298                  return true;
1299              }
1300  
1301              // Check if any workspace icons overlap with each other
1302              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1303                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1304                      if (occupied[containerIndex][x][y] != null) {
1305                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1306                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1307                              + x + &quot;,&quot; + y
1308                              + &quot;) occupied by &quot;
1309                              + occupied[containerIndex][x][y]);
1310                          return false;
1311                      }
1312                  }
1313              }
1314              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1315                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1316                      occupied[containerIndex][x][y] = item;
1317                  }
1318              }
1319  
1320              return true;
1321          }
1322  
1323          private void loadWorkspace() {
1324              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1325  
1326              final Context context = mContext;
1327              final ContentResolver contentResolver = context.getContentResolver();
1328              final PackageManager manager = context.getPackageManager();
1329              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1330              final boolean isSafeMode = manager.isSafeMode();
1331  
1332              // Make sure the default workspace is loaded, if needed
1333              mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1334  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1335 -            sWorkspaceItems.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1336 -            sAppWidgets.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1337 -            sFolders.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1338 -            sItemsIdMap.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1339 -            sDbIconCache.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1340 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1341 -            final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1342 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1343 -            final Cursor c = contentResolver.query(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1344 -                    LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1345 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1346 -            // +1 for the hotseat (it can be larger than the workspace)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1347 -            // Load workspace in reverse order to ensure that latest items are loaded first (and</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1348 -            // before any earlier duplicates)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1349 -            final ItemInfo occupied[][][] =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1350 -                    new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1351 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1352 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1353 -                final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1354 -                final int intentIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1355 -                        (LauncherSettings.Favorites.INTENT);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1356 -                final int titleIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1357 -                        (LauncherSettings.Favorites.TITLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1358 -                final int iconTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1359 -                        LauncherSettings.Favorites.ICON_TYPE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1360 -                final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1361 -                final int iconPackageIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1362 -                        LauncherSettings.Favorites.ICON_PACKAGE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1363 -                final int iconResourceIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1364 -                        LauncherSettings.Favorites.ICON_RESOURCE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1365 -                final int containerIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1366 -                        LauncherSettings.Favorites.CONTAINER);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1367 -                final int itemTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1368 -                        LauncherSettings.Favorites.ITEM_TYPE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1369 -                final int appWidgetIdIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1370 -                        LauncherSettings.Favorites.APPWIDGET_ID);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1371 -                final int screenIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1372 -                        LauncherSettings.Favorites.SCREEN);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1373 -                final int cellXIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1374 -                        (LauncherSettings.Favorites.CELLX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1375 -                final int cellYIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1376 -                        (LauncherSettings.Favorites.CELLY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1377 -                final int spanXIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1378 -                        (LauncherSettings.Favorites.SPANX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1379 -                final int spanYIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1380 -                        LauncherSettings.Favorites.SPANY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1381 -                //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1382 -                //final int displayModeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1383 -                //        LauncherSettings.Favorites.DISPLAY_MODE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1384 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1385 -                ShortcutInfo info;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1386 -                String intentDescription;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1387 -                LauncherAppWidgetInfo appWidgetInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1388 -                int container;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1389 -                long id;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1390 -                Intent intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1391 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1392 -                while (!mStopped &amp;&amp; c.moveToNext()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1393 -                    try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1394 -                        int itemType = c.getInt(itemTypeIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1395 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1396 -                        switch (itemType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1397 -                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1398 -                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1399 -                            intentDescription = c.getString(intentIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1400 -                            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1401 -                                intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1402 -                            } catch (URISyntaxException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1403 -                                continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1404 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1405 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1406 -                            if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1407 -                                info = getShortcutInfo(manager, intent, context, c, iconIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1408 -                                        titleIndex, mLabelCache);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1409 -                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1410 -                                info = getShortcutInfo(c, context, iconTypeIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1411 -                                        iconPackageIndex, iconResourceIndex, iconIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1412 -                                        titleIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1413 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1414 -                                // App shortcuts that used to be automatically added to Launcher</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1415 -                                // didn&#x27;t always have the correct intent flags set, so do that here</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1416 -                                if (intent.getAction() != null &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1417 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1418 +                sBgWorkspaceItems.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1419 +                sBgAppWidgets.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1420 +                sBgFolders.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1421 +                sBgItemsIdMap.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1422 +                sBgDbIconCache.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1423 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1424 +                final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1425 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1426 +                final Cursor c = contentResolver.query(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1427 +                        LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1428 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1429 +                // +1 for the hotseat (it can be larger than the workspace)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1430 +                // Load workspace in reverse order to ensure that latest items are loaded first (and</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1431 +                // before any earlier duplicates)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1432 +                final ItemInfo occupied[][][] =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1433 +                        new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1434 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1435 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1436 +                    final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1437 +                    final int intentIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1438 +                            (LauncherSettings.Favorites.INTENT);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1439 +                    final int titleIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1440 +                            (LauncherSettings.Favorites.TITLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1441 +                    final int iconTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1442 +                            LauncherSettings.Favorites.ICON_TYPE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1443 +                    final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1444 +                    final int iconPackageIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1445 +                            LauncherSettings.Favorites.ICON_PACKAGE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1446 +                    final int iconResourceIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1447 +                            LauncherSettings.Favorites.ICON_RESOURCE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1448 +                    final int containerIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1449 +                            LauncherSettings.Favorites.CONTAINER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1450 +                    final int itemTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1451 +                            LauncherSettings.Favorites.ITEM_TYPE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1452 +                    final int appWidgetIdIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1453 +                            LauncherSettings.Favorites.APPWIDGET_ID);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1454 +                    final int screenIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1455 +                            LauncherSettings.Favorites.SCREEN);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1456 +                    final int cellXIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1457 +                            (LauncherSettings.Favorites.CELLX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1458 +                    final int cellYIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1459 +                            (LauncherSettings.Favorites.CELLY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1460 +                    final int spanXIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1461 +                            (LauncherSettings.Favorites.SPANX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1462 +                    final int spanYIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1463 +                            LauncherSettings.Favorites.SPANY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1464 +                    //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1465 +                    //final int displayModeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1466 +                    //        LauncherSettings.Favorites.DISPLAY_MODE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1467 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1468 +                    ShortcutInfo info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1469 +                    String intentDescription;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1470 +                    LauncherAppWidgetInfo appWidgetInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1471 +                    int container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1472 +                    long id;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1473 +                    Intent intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1474 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1475 +                    while (!mStopped &amp;&amp; c.moveToNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1476 +                        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1477 +                            int itemType = c.getInt(itemTypeIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1478 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1479 +                            switch (itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1480 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1481 +                            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1482 +                                intentDescription = c.getString(intentIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1483 +                                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1484 +                                    intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1485 +                                } catch (URISyntaxException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1486 +                                    continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1487 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1488 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1489 +                                if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1490 +                                    info = getShortcutInfo(manager, intent, context, c, iconIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1491 +                                            titleIndex, mLabelCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1492 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1493 +                                    info = getShortcutInfo(c, context, iconTypeIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1494 +                                            iconPackageIndex, iconResourceIndex, iconIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1495 +                                            titleIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1496 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1497 +                                    // App shortcuts that used to be automatically added to Launcher</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1498 +                                    // didn&#x27;t always have the correct intent flags set, so do that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1499 +                                    // here</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1500 +                                    if (intent.getAction() != null &amp;&amp;</span>
1501                                          intent.getCategories() != null &amp;&amp;
1502                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1503                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1504 -                                    intent.addFlags(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1505 -                                        Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1506 -                                        Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1507 +                                        intent.addFlags(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1508 +                                            Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1509 +                                            Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1510 +                                    }</span>
1511                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1512 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1513 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1514 -                            if (info != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1515 -                                info.intent = intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1516 -                                info.id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1517 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1518 +                                if (info != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1519 +                                    info.intent = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1520 +                                    info.id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1521 +                                    container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1522 +                                    info.container = container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1523 +                                    info.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1524 +                                    info.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1525 +                                    info.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1526 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1527 +                                    // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1528 +                                    if (!checkItemPlacement(occupied, info)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1529 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1530 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1531 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1532 +                                    switch (container) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1533 +                                    case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1534 +                                    case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1535 +                                        sBgWorkspaceItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1536 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1537 +                                    default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1538 +                                        // Item is in a user folder</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1539 +                                        FolderInfo folderInfo =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1540 +                                                findOrMakeFolder(sBgFolders, container);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1541 +                                        folderInfo.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1542 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1543 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1544 +                                    sBgItemsIdMap.put(info.id, info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1545 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1546 +                                    // now that we&#x27;ve loaded everthing re-save it with the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1547 +                                    // icon in case it disappears somehow.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1548 +                                    queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1549 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1550 +                                    // Failed to load the shortcut, probably because the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1551 +                                    // activity manager couldn&#x27;t resolve it (maybe the app</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1552 +                                    // was uninstalled), or the db row was somehow screwed up.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1553 +                                    // Delete it.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1554 +                                    id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1555 +                                    Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1556 +                                    contentResolver.delete(LauncherSettings.Favorites.getContentUri(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1557 +                                                id, false), null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1558 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1559 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1560 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1561 +                            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1562 +                                id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1563 +                                FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1564 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1565 +                                folderInfo.title = c.getString(titleIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1566 +                                folderInfo.id = id;</span>
1567                                  container = c.getInt(containerIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1568 -                                info.container = container;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1569 -                                info.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1570 -                                info.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1571 -                                info.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1572 +                                folderInfo.container = container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1573 +                                folderInfo.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1574 +                                folderInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1575 +                                folderInfo.cellY = c.getInt(cellYIndex);</span>
1576  
1577                                  // check &amp; update map of what&#x27;s occupied
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1578 -                                if (!checkItemPlacement(occupied, info)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1579 +                                if (!checkItemPlacement(occupied, folderInfo)) {</span>
1580                                      break;
1581                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1582 -</span>
1583                                  switch (container) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1584 -                                case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1585 -                                case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1586 -                                    sWorkspaceItems.add(info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1587 -                                    break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1588 -                                default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1589 -                                    // Item is in a user folder</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1590 -                                    FolderInfo folderInfo =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1591 -                                            findOrMakeFolder(sFolders, container);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1592 -                                    folderInfo.add(info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1593 -                                    break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1594 +                                    case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1595 +                                    case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1596 +                                        sBgWorkspaceItems.add(folderInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1597 +                                        break;</span>
1598                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1599 -                                sItemsIdMap.put(info.id, info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1600 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1601 -                                // now that we&#x27;ve loaded everthing re-save it with the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1602 -                                // icon in case it disappears somehow.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1603 -                                queueIconToBeChecked(sDbIconCache, info, c, iconIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1604 -                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1605 -                                // Failed to load the shortcut, probably because the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1606 -                                // activity manager couldn&#x27;t resolve it (maybe the app</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1607 -                                // was uninstalled), or the db row was somehow screwed up.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1608 -                                // Delete it.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1609 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1610 +                                sBgItemsIdMap.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1611 +                                sBgFolders.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1612 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1613 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1614 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1615 +                                // Read all Launcher-specific widget details</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1616 +                                int appWidgetId = c.getInt(appWidgetIdIndex);</span>
1617                                  id = c.getLong(idIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1618 -                                Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1619 -                                contentResolver.delete(LauncherSettings.Favorites.getContentUri(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1620 -                                            id, false), null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1621 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1622 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1623 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1624 -                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1625 -                            id = c.getLong(idIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1626 -                            FolderInfo folderInfo = findOrMakeFolder(sFolders, id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1627 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1628 -                            folderInfo.title = c.getString(titleIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1629 -                            folderInfo.id = id;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1630 -                            container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1631 -                            folderInfo.container = container;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1632 -                            folderInfo.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1633 -                            folderInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1634 -                            folderInfo.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1635 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1636 -                            // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1637 -                            if (!checkItemPlacement(occupied, folderInfo)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1638 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1639 +                                final AppWidgetProviderInfo provider =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1640 +                                        widgets.getAppWidgetInfo(appWidgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1641 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1642 +                                if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1643 +                                        provider.provider.getPackageName() == null)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1644 +                                    String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1645 +                                        + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1646 +                                    Log.e(TAG, log);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1647 +                                    Launcher.sDumpLogs.add(log);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1648 +                                    itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1649 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1650 +                                    appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1651 +                                            provider.provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1652 +                                    appWidgetInfo.id = id;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1653 +                                    appWidgetInfo.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1654 +                                    appWidgetInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1655 +                                    appWidgetInfo.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1656 +                                    appWidgetInfo.spanX = c.getInt(spanXIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1657 +                                    appWidgetInfo.spanY = c.getInt(spanYIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1658 +                                    int[] minSpan = Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1659 +                                    appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1660 +                                    appWidgetInfo.minSpanY = minSpan[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1661 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1662 +                                    container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1663 +                                    if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1664 +                                        container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1665 +                                        Log.e(TAG, &quot;Widget found where container != &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1666 +                                            &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1667 +                                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1668 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1669 +                                    appWidgetInfo.container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1670 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1671 +                                    // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1672 +                                    if (!checkItemPlacement(occupied, appWidgetInfo)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1673 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1674 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1675 +                                    sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1676 +                                    sBgAppWidgets.add(appWidgetInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1677 +                                }</span>
1678                                  break;
1679                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1680 -                            switch (container) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1681 -                                case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1682 -                                case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1683 -                                    sWorkspaceItems.add(folderInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1684 -                                    break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1685 +                        } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1686 +                            Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1687 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1688 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1689 +                } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1690 +                    c.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1691 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1692 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1693 +                if (itemsToRemove.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1694 +                    ContentProviderClient client = contentResolver.acquireContentProviderClient(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1695 +                                    LauncherSettings.Favorites.CONTENT_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1696 +                    // Remove dead items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1697 +                    for (long id : itemsToRemove) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1698 +                        if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1699 +                            Log.d(TAG, &quot;Removed id = &quot; + id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1700 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1701 +                        // Don&#x27;t notify content observers</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1702 +                        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1703 +                            client.delete(LauncherSettings.Favorites.getContentUri(id, false),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1704 +                                    null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1705 +                        } catch (RemoteException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1706 +                            Log.w(TAG, &quot;Could not remove id = &quot; + id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1707 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1708 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1709 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1710 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1711 +                if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1712 +                    Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1713 +                    Log.d(TAG, &quot;workspace layout: &quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1714 +                    for (int y = 0; y &lt; mCellCountY; y++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1715 +                        String line = &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1716 +                        for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1717 +                            if (s &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1718 +                                line += &quot; | &quot;;</span>
1719                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1720 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1721 -                            sItemsIdMap.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1722 -                            sFolders.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1723 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1724 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1725 -                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1726 -                            // Read all Launcher-specific widget details</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1727 -                            int appWidgetId = c.getInt(appWidgetIdIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1728 -                            id = c.getLong(idIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1729 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1730 -                            final AppWidgetProviderInfo provider =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1731 -                                    widgets.getAppWidgetInfo(appWidgetId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1732 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1733 -                            if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1734 -                                    provider.provider.getPackageName() == null)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1735 -                                String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1736 -                                    + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1737 -                                Log.e(TAG, log);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1738 -                                Launcher.sDumpLogs.add(log);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1739 -                                itemsToRemove.add(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1740 -                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1741 -                                appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1742 -                                        provider.provider);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1743 -                                appWidgetInfo.id = id;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1744 -                                appWidgetInfo.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1745 -                                appWidgetInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1746 -                                appWidgetInfo.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1747 -                                appWidgetInfo.spanX = c.getInt(spanXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1748 -                                appWidgetInfo.spanY = c.getInt(spanYIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1749 -                                int[] minSpan = Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1750 -                                appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1751 -                                appWidgetInfo.minSpanY = minSpan[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1752 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1753 -                                container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1754 -                                if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1755 -                                    container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1756 -                                    Log.e(TAG, &quot;Widget found where container &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1757 -                                        + &quot;!= CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1758 -                                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1759 -                                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1760 -                                appWidgetInfo.container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1761 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1762 -                                // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1763 -                                if (!checkItemPlacement(occupied, appWidgetInfo)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1764 -                                    break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1765 -                                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1766 -                                sItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1767 -                                sAppWidgets.add(appWidgetInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1768 +                            for (int x = 0; x &lt; mCellCountX; x++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1769 +                                line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);</span>
1770                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1771 -                            break;</span>
1772                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1773 -                    } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1774 -                        Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1775 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1776 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1777 -            } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1778 -                c.close();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1779 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1780 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1781 -            if (itemsToRemove.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1782 -                ContentProviderClient client = contentResolver.acquireContentProviderClient(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1783 -                                LauncherSettings.Favorites.CONTENT_URI);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1784 -                // Remove dead items</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1785 -                for (long id : itemsToRemove) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1786 -                    if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1787 -                        Log.d(TAG, &quot;Removed id = &quot; + id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1788 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1789 -                    // Don&#x27;t notify content observers</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1790 -                    try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1791 -                        client.delete(LauncherSettings.Favorites.getContentUri(id, false),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1792 -                                null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1793 -                    } catch (RemoteException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1794 -                        Log.w(TAG, &quot;Could not remove id = &quot; + id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1795 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1796 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1797 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1798 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1799 -            if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1800 -                Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1801 -                Log.d(TAG, &quot;workspace layout: &quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1802 -                for (int y = 0; y &lt; mCellCountY; y++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1803 -                    String line = &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1804 -                    for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1805 -                        if (s &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1806 -                            line += &quot; | &quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1807 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1808 -                        for (int x = 0; x &lt; mCellCountX; x++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1809 -                            line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1810 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1811 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1812 -                    Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1813 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1814 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1815 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1816 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1817 -        /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1818 -         * Read everything out of our database.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1819 -         */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1820 -        private void bindWorkspace() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1821 -            final long t = SystemClock.uptimeMillis();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1822 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1823 -            // Don&#x27;t use these two variables in any of the callback runnables.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1824 -            // Otherwise we hold a reference to them.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1825 -            final Callbacks oldCallbacks = mCallbacks.get();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1826 -            if (oldCallbacks == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1827 -                // This launcher has exited and nobody bothered to tell us.  Just bail.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1828 -                Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1829 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1830 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1831 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1832 -            // Get the list of workspace items to load and unbind the existing ShortcutInfos</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1833 -            // before we call startBinding() below.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1834 -            final int currentScreen = oldCallbacks.getCurrentWorkspaceScreen();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1835 -            final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = unbindWorkspaceItemsOnMainThread();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1836 -            // Order the items for loading as follows: current workspace, hotseat, everything else</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1837 -            Collections.sort(tmpWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1838 +                        Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1839 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1840 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1841 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1842 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1843 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1844 +        /** Filters the set of items who are directly or indirectly (via another container) on the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1845 +         * specified screen. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1846 +        private void filterCurrentWorkspaceItems(int currentScreen,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1847 +                ArrayList&lt;ItemInfo&gt; allWorkspaceItems,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1848 +                ArrayList&lt;ItemInfo&gt; currentScreenItems,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1849 +                ArrayList&lt;ItemInfo&gt; otherScreenItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1850 +            // Purge any null ItemInfos</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1851 +            Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1852 +            while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1853 +                ItemInfo i = iter.next();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1854 +                if (i == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1855 +                    iter.remove();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1856 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1857 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1858 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1859 +            // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1860 +            // items given.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1861 +            if (currentScreen &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1862 +                currentScreenItems.addAll(allWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1863 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1864 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1865 +            // Order the set of items by their containers first, this allows use to walk through the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1866 +            // list sequentially, build up a list of containers that are in the specified screen,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1867 +            // as well as all items in those containers.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1868 +            Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1869 +            Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1870 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1871 +                public int compare(ItemInfo lhs, ItemInfo rhs) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1872 +                    return (int) (lhs.container - rhs.container);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1873 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1874 +            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1875 +            for (ItemInfo info : allWorkspaceItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1876 +                if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1877 +                    if (info.screen == currentScreen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1878 +                        currentScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1879 +                        itemsOnScreen.add(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1880 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1881 +                        otherScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1882 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1883 +                } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1884 +                    currentScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1885 +                    itemsOnScreen.add(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1886 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1887 +                    if (itemsOnScreen.contains(info.container)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1888 +                        currentScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1889 +                        itemsOnScreen.add(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1890 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1891 +                        otherScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1892 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1893 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1894 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1895 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1896 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1897 +        /** Filters the set of widgets which are on the specified screen. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1898 +        private void filterCurrentAppWidgets(int currentScreen,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1899 +                ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1900 +                ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1901 +                ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1902 +            // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1903 +            // widgets given.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1904 +            if (currentScreen &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1905 +                currentScreenWidgets.addAll(appWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1906 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1907 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1908 +            for (LauncherAppWidgetInfo widget : appWidgets) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1909 +                if (widget == null) continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1910 +                if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1911 +                        widget.screen == currentScreen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1912 +                    currentScreenWidgets.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1913 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1914 +                    otherScreenWidgets.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1915 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1916 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1917 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1918 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1919 +        /** Filters the set of folders which are on the specified screen. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1920 +        private void filterCurrentFolders(int currentScreen,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1921 +                HashMap&lt;Long, ItemInfo&gt; itemsIdMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1922 +                HashMap&lt;Long, FolderInfo&gt; folders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1923 +                HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1924 +                HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1925 +            // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1926 +            // widgets given.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1927 +            if (currentScreen &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1928 +                currentScreenFolders.putAll(folders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1929 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1930 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1931 +            for (long id : folders.keySet()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1932 +                ItemInfo info = itemsIdMap.get(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1933 +                FolderInfo folder = folders.get(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1934 +                if (info == null || folder == null) continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1935 +                if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1936 +                        info.screen == currentScreen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1937 +                    currentScreenFolders.put(id, folder);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1938 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1939 +                    otherScreenFolders.put(id, folder);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1940 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1941 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1942 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1943 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1944 +        /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1945 +         * right) */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1946 +        private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1947 +            // XXX: review this</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1948 +            Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {</span>
1949                  @Override
1950                  public int compare(ItemInfo lhs, ItemInfo rhs) {
1951                      int cellCountX = LauncherModel.getCellCountX();
1952                      int cellCountY = LauncherModel.getCellCountY();
1953                      int screenOffset = cellCountX * cellCountY;
1954                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1955                      long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1956                              lhs.cellY * cellCountX + lhs.cellX);
1957                      long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1958                              rhs.cellY * cellCountX + rhs.cellX);
1959                      return (int) (lr - rr);
1960                  }
1961              });
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1962 -            // Precondition: the items are ordered by page, screen</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1963 -            final ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1964 -            for (ItemInfo ii : tmpWorkspaceItems) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1965 -                // Prepend the current items, hotseat items, append everything else</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1966 -                if (ii.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1967 -                        ii.screen == currentScreen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1968 -                    workspaceItems.add(0, ii);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1969 -                } else if (ii.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1970 -                    workspaceItems.add(0, ii);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1971 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1972 -                    workspaceItems.add(ii);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1973 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1974 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1975 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1976 -            // Tell the workspace that we&#x27;re about to start firing items at it</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1977 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1978 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1979 -                    Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1980 -                    if (callbacks != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1981 -                        callbacks.startBinding();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1982 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1983 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1984 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1985 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1986 -            // Add the items to the workspace.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1987 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1988 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1989 +        private void bindWorkspaceItems(final Callbacks oldCallbacks,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1990 +                final ArrayList&lt;ItemInfo&gt; workspaceItems,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1991 +                final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1992 +                final HashMap&lt;Long, FolderInfo&gt; folders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1993 +                ArrayList&lt;Runnable&gt; deferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1994 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1995 +            final boolean postOnMainThread = (deferredBindRunnables != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1996 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1997 +            // Bind the workspace items</span>
1998              int N = workspaceItems.size();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1999 -            for (int i=0; i&lt;N; i+=ITEMS_CHUNK) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2000 +            for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {</span>
2001                  final int start = i;
2002                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2003 -                mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2004 +                final Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2005 +                    @Override</span>
2006                      public void run() {
2007                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2008                          if (callbacks != null) {
2009                              callbacks.bindItems(workspaceItems, start, start+chunkSize);
2010                          }
2011                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2012 -                });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2013 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2014 -            // Ensure that we don&#x27;t use the same folders data structure on the main thread</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2015 -            final HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;(sFolders);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2016 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2017 +                };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2018 +                if (postOnMainThread) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2019 +                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2020 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2021 +                    runOnMainThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2022 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2023 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2024 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2025 +            // Bind the folders</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2026 +            if (!folders.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2027 +                final Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2028 +                    public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2029 +                        Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2030 +                        if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2031 +                            callbacks.bindFolders(folders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2032 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2033 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2034 +                };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2035 +                if (postOnMainThread) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2036 +                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2037 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2038 +                    runOnMainThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2039 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2040 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2041 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2042 +            // Bind the widgets, one at a time</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2043 +            N = appWidgets.size();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2044 +            for (int i = 0; i &lt; N; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2045 +                final LauncherAppWidgetInfo widget = appWidgets.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2046 +                final Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2047 +                    public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2048 +                        Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2049 +                        if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2050 +                            callbacks.bindAppWidget(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2051 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2052 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2053 +                };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2054 +                if (postOnMainThread) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2055 +                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2056 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2057 +                    runOnMainThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2058 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2059 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2060 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2061 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2062 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2063 +         * Binds all loaded data to actual views on the main thread.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2064 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2065 +        private void bindWorkspace(int synchronizeBindPage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2066 +            final long t = SystemClock.uptimeMillis();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2067 +            Runnable r;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2068 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2069 +            // Don&#x27;t use these two variables in any of the callback runnables.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2070 +            // Otherwise we hold a reference to them.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2071 +            final Callbacks oldCallbacks = mCallbacks.get();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2072 +            if (oldCallbacks == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2073 +                // This launcher has exited and nobody bothered to tell us.  Just bail.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2074 +                Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2075 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2076 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2077 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2078 +            final int currentScreen = (synchronizeBindPage &gt; -1) ? synchronizeBindPage :</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2079 +                oldCallbacks.getCurrentWorkspaceScreen();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2080 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2081 +            // Load all the items that are on the current page first (and in the process, unbind</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2082 +            // all the existing workspace items before we call startBinding() below.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2083 +            unbindWorkspaceItemsOnMainThread();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2084 +            ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2085 +            ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2086 +                    new ArrayList&lt;LauncherAppWidgetInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2087 +            HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2088 +            HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2089 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2090 +                workspaceItems.addAll(sBgWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2091 +                appWidgets.addAll(sBgAppWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2092 +                folders.putAll(sBgFolders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2093 +                itemsIdMap.putAll(sBgItemsIdMap);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2094 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2095 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2096 +            ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2097 +            ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2098 +            ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2099 +                    new ArrayList&lt;LauncherAppWidgetInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2100 +            ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2101 +                    new ArrayList&lt;LauncherAppWidgetInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2102 +            HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2103 +            HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2104 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2105 +            // Separate the items that are on the current screen, and all the other remaining items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2106 +            filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2107 +                    otherWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2108 +            filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2109 +                    otherAppWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2110 +            filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2111 +                    otherFolders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2112 +            sortWorkspaceItemsSpatially(currentWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2113 +            sortWorkspaceItemsSpatially(otherWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2114 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2115 +            // Tell the workspace that we&#x27;re about to start binding items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2116 +            r = new Runnable() {</span>
2117                  public void run() {
2118                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2119                      if (callbacks != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2120 -                        callbacks.bindFolders(folders);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2121 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2122 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2123 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2124 -            // Wait until the queue goes empty.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2125 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2126 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2127 -                    if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2128 -                        Log.d(TAG, &quot;Going to start binding widgets soon.&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2129 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2130 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2131 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2132 -            // Bind the widgets, one at a time.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2133 -            // WARNING: this is calling into the workspace from the background thread,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2134 -            // but since getCurrentScreen() just returns the int, we should be okay.  This</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2135 -            // is just a hint for the order, and if it&#x27;s wrong, we&#x27;ll be okay.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2136 -            // TODO: instead, we should have that push the current screen into here.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2137 -            N = sAppWidgets.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2138 -            // once for the current screen</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2139 -            for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2140 -                final LauncherAppWidgetInfo widget = sAppWidgets.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2141 -                if (widget.screen == currentScreen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2142 -                    mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2143 -                        public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2144 -                            Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2145 -                            if (callbacks != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2146 -                                callbacks.bindAppWidget(widget);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2147 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2148 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2149 -                    });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2150 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2151 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2152 -            // once for the other screens</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2153 -            for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2154 -                final LauncherAppWidgetInfo widget = sAppWidgets.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2155 -                if (widget.screen != currentScreen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2156 -                    mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2157 -                        public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2158 -                            Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2159 -                            if (callbacks != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2160 -                                callbacks.bindAppWidget(widget);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2161 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2162 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2163 -                    });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2164 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2165 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2166 -            // Tell the workspace that we&#x27;re done.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2167 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2168 +                        callbacks.startBinding();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2169 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2170 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2171 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2172 +            runOnMainThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2173 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2174 +            // Load items on the current page</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2175 +            bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2176 +                    currentFolders, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2177 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2178 +            // Load all the remaining pages</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2179 +            mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2180 +            bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2181 +                    mDeferredBindRunnables);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2182 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2183 +            // Tell the workspace that we&#x27;re done binding items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2184 +            r = new Runnable() {</span>
2185                  public void run() {
2186                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2187                      if (callbacks != null) {
2188                          callbacks.finishBindingItems();
2189                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2190 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2191 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2192 -            // Cleanup</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2193 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2194 -                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2195 +</span>
2196                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2197                      if (DEBUG_LOADERS) {
2198                          Log.d(TAG, &quot;bound workspace in &quot;
2199                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2200                      }
2201  
2202                      mIsLoadingAndBindingWorkspace = false;
2203                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2204 -            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2205 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2206 +            mDeferredBindRunnables.add(r);</span>
2207          }
2208  
2209          private void loadAndBindAllApps() {
2210              if (DEBUG_LOADERS) {
2211                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2212              }
2213              if (!mAllAppsLoaded) {
2214                  loadAllAppsByBatch();
2215                  synchronized (LoaderTask.this) {
2216                      if (mStopped) {
2217                          return;
2218                      }
2219                      mAllAppsLoaded = true;
2220                  }
2221              } else {
2222                  onlyBindAllApps();
2223              }
2224          }
2225  
2226          private void onlyBindAllApps() {
2227              final Callbacks oldCallbacks = mCallbacks.get();
2228              if (oldCallbacks == null) {
2229                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2230                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2231                  return;
2232              }
2233  
2234              // shallow copy
2235              @SuppressWarnings(&quot;unchecked&quot;)
2236              final ArrayList&lt;ApplicationInfo&gt; list
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2237 -                    = (ArrayList&lt;ApplicationInfo&gt;) mAllAppsList.data.clone();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2238 +                    = (ArrayList&lt;ApplicationInfo&gt;) mBgAllAppsList.data.clone();</span>
2239              mHandler.post(new Runnable() {
2240                  public void run() {
2241                      final long t = SystemClock.uptimeMillis();
2242                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2243                      if (callbacks != null) {
2244                          callbacks.bindAllApplications(list);
2245                      }
2246                      if (DEBUG_LOADERS) {
2247                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2248                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2249                      }
2250                  }
2251              });
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2252 -</span>
2253          }
2254  
2255          private void loadAllAppsByBatch() {
2256              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2257  
2258              // Don&#x27;t use these two variables in any of the callback runnables.
2259              // Otherwise we hold a reference to them.
2260              final Callbacks oldCallbacks = mCallbacks.get();
2261              if (oldCallbacks == null) {
2262                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2263                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
2264                  return;
2265              }
2266  
2267              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2268              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2269  
2270              final PackageManager packageManager = mContext.getPackageManager();
2271              List&lt;ResolveInfo&gt; apps = null;
2272  
2273              int N = Integer.MAX_VALUE;
2274  
2275              int startIndex;
2276              int i=0;
2277              int batchSize = -1;
2278              while (i &lt; N &amp;&amp; !mStopped) {
2279                  if (i == 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2280 -                    mAllAppsList.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2281 +                    mBgAllAppsList.clear();</span>
2282                      final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2283                      apps = packageManager.queryIntentActivities(mainIntent, 0);
2284                      if (DEBUG_LOADERS) {
2285                          Log.d(TAG, &quot;queryIntentActivities took &quot;
2286                                  + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
2287                      }
2288                      if (apps == null) {
2289                          return;
2290                      }
2291                      N = apps.size();
2292                      if (DEBUG_LOADERS) {
2293                          Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
2294                      }
2295                      if (N == 0) {
2296                          // There are no apps?!?
2297                          return;
2298                      }
2299                      if (mBatchSize == 0) {
2300                          batchSize = N;
2301                      } else {
2302                          batchSize = mBatchSize;
2303                      }
2304  
2305                      final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2306                      Collections.sort(apps,
2307                              new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
2308                      if (DEBUG_LOADERS) {
2309                          Log.d(TAG, &quot;sort took &quot;
2310                                  + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2311                      }
2312                  }
2313  
2314                  final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2315  
2316                  startIndex = i;
2317                  for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
2318                      // This builds the icon bitmaps.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2319 -                    mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2320 +                    mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</span>
2321                              mIconCache, mLabelCache));
2322                      i++;
2323                  }
2324  
2325                  final boolean first = i &lt;= batchSize;
2326                  final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2327 -                final ArrayList&lt;ApplicationInfo&gt; added = mAllAppsList.added;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2328 -                mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2329 +                final ArrayList&lt;ApplicationInfo&gt; added = mBgAllAppsList.added;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2330 +                mBgAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();</span>
2331  
2332                  mHandler.post(new Runnable() {
2333                      public void run() {
2334                          final long t = SystemClock.uptimeMillis();
2335                          if (callbacks != null) {
2336                              if (first) {
2337                                  callbacks.bindAllApplications(added);
2338                              } else {
2339                                  callbacks.bindAppsAdded(added);
2340                              }
2341                              if (DEBUG_LOADERS) {
2342                                  Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2343                                      + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
2344                              }
2345                          } else {
2346                              Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2347                          }
2348                      }
2349                  });
2350  
2351                  if (DEBUG_LOADERS) {
2352                      Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
2353                              + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
2354                  }
2355  
2356                  if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
2357                      try {
2358                          if (DEBUG_LOADERS) {
2359                              Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
2360                          }
2361                          Thread.sleep(mAllAppsLoadDelay);
2362                      } catch (InterruptedException exc) { }
2363                  }
2364              }
2365  
2366              if (DEBUG_LOADERS) {
2367                  Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
2368                          + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
2369                          + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
2370              }
2371          }
2372  
2373          public void dumpState() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2374 -            Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2375 -            Log.d(TAG, &quot;mLoaderTask.mWaitThread=&quot; + mWaitThread);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2376 -            Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2377 -            Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2378 -            Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2379 -            Log.d(TAG, &quot;mItems size=&quot; + sWorkspaceItems.size());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2380 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2381 +                Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2382 +                Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2383 +                Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2384 +                Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2385 +                Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2386 +            }</span>
2387          }
2388      }
2389  
2390      void enqueuePackageUpdated(PackageUpdatedTask task) {
2391          sWorker.post(task);
2392      }
2393  
2394      private class PackageUpdatedTask implements Runnable {
2395          int mOp;
2396          String[] mPackages;
2397  
2398          public static final int OP_NONE = 0;
2399          public static final int OP_ADD = 1;
2400          public static final int OP_UPDATE = 2;
2401          public static final int OP_REMOVE = 3; // uninstlled
2402          public static final int OP_UNAVAILABLE = 4; // external media unmounted
2403  
2404  
2405          public PackageUpdatedTask(int op, String[] packages) {
2406              mOp = op;
2407              mPackages = packages;
2408          }
2409  
2410          public void run() {
2411              final Context context = mApp;
2412  
2413              final String[] packages = mPackages;
2414              final int N = packages.length;
2415              switch (mOp) {
2416                  case OP_ADD:
2417                      for (int i=0; i&lt;N; i++) {
2418                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2419 -                        mAllAppsList.addPackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2420 +                        mBgAllAppsList.addPackage(context, packages[i]);</span>
2421                      }
2422                      break;
2423                  case OP_UPDATE:
2424                      for (int i=0; i&lt;N; i++) {
2425                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2426 -                        mAllAppsList.updatePackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2427 +                        mBgAllAppsList.updatePackage(context, packages[i]);</span>
2428                      }
2429                      break;
2430                  case OP_REMOVE:
2431                  case OP_UNAVAILABLE:
2432                      for (int i=0; i&lt;N; i++) {
2433                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2434 -                        mAllAppsList.removePackage(packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2435 +                        mBgAllAppsList.removePackage(packages[i]);</span>
2436                      }
2437                      break;
2438              }
2439  
2440              ArrayList&lt;ApplicationInfo&gt; added = null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2441 -            ArrayList&lt;ApplicationInfo&gt; removed = null;</span>
2442              ArrayList&lt;ApplicationInfo&gt; modified = null;
2443  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2444 -            if (mAllAppsList.added.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2445 -                added = mAllAppsList.added;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2446 -                mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2447 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2448 -            if (mAllAppsList.removed.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2449 -                removed = mAllAppsList.removed;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2450 -                mAllAppsList.removed = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2451 -                for (ApplicationInfo info: removed) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2452 -                    mIconCache.remove(info.intent.getComponent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2453 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2454 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2455 -            if (mAllAppsList.modified.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2456 -                modified = mAllAppsList.modified;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2457 -                mAllAppsList.modified = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2458 +            if (mBgAllAppsList.added.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2459 +                added = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2460 +                mBgAllAppsList.added.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2461 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2462 +            if (mBgAllAppsList.modified.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2463 +                modified = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.modified);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2464 +                mBgAllAppsList.modified.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2465 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2466 +            // We may be removing packages that have no associated launcher application, so we</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2467 +            // pass through the removed package names directly.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2468 +            // NOTE: We flush the icon cache aggressively in removePackage() above.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2469 +            final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2470 +            if (mBgAllAppsList.removed.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2471 +                mBgAllAppsList.removed.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2472 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2473 +                for (int i = 0; i &lt; N; ++i) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2474 +                    removedPackageNames.add(packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2475 +                }</span>
2476              }
2477  
2478              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2479              if (callbacks == null) {
2480                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2481                  return;
2482              }
2483  
2484              if (added != null) {
2485                  final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
2486                  mHandler.post(new Runnable() {
2487                      public void run() {
2488                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2489                          if (callbacks == cb &amp;&amp; cb != null) {
2490                              callbacks.bindAppsAdded(addedFinal);
2491                          }
2492                      }
2493                  });
2494              }
2495              if (modified != null) {
2496                  final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
2497                  mHandler.post(new Runnable() {
2498                      public void run() {
2499                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2500                          if (callbacks == cb &amp;&amp; cb != null) {
2501                              callbacks.bindAppsUpdated(modifiedFinal);
2502                          }
2503                      }
2504                  });
2505              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2506 -            if (removed != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2507 +            if (!removedPackageNames.isEmpty()) {</span>
2508                  final boolean permanent = mOp != OP_UNAVAILABLE;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2509 -                final ArrayList&lt;ApplicationInfo&gt; removedFinal = removed;</span>
2510                  mHandler.post(new Runnable() {
2511                      public void run() {
2512                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2513                          if (callbacks == cb &amp;&amp; cb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2514 -                            callbacks.bindAppsRemoved(removedFinal, permanent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2515 +                            callbacks.bindAppsRemoved(removedPackageNames, permanent);</span>
2516                          }
2517                      }
2518                  });
2519              }
2520  
2521              mHandler.post(new Runnable() {
2522                  @Override
2523                  public void run() {
2524                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2525                      if (callbacks == cb &amp;&amp; cb != null) {
2526                          callbacks.bindPackagesUpdated();
2527                      }
2528                  }
2529              });
2530          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2531 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2532 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2533 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2534 -     * Returns all the Workspace ShortcutInfos associated with a particular package.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2535 -     * @param intent</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2536 -     * @return</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2537 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2538 -    ArrayList&lt;ShortcutInfo&gt; getShortcutInfosForPackage(String packageName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2539 -        ArrayList&lt;ShortcutInfo&gt; infos = new ArrayList&lt;ShortcutInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2540 -        for (ItemInfo i : sWorkspaceItems) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2541 -            if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2542 -                ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2543 -                if (packageName.equals(info.getPackageName())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2544 -                    infos.add(info);</span>







<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2545 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2546 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2547 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2548 -        return infos;</span>
2549      }
2550  
2551      /**
2552       * This is called from the code that adds shortcuts from the intent receiver.  This
2553       * doesn&#x27;t have a Cursor, but
2554       */
2555      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2556          return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2557      }
2558  
2559      /**
2560       * Make an ShortcutInfo object for a shortcut that is an application.
2561       *
2562       * If c is not null, then it will be used to fill in missing data like the title and icon.
2563       */
2564      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2565              Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2566          Bitmap icon = null;
2567          final ShortcutInfo info = new ShortcutInfo();
2568  
2569          ComponentName componentName = intent.getComponent();
2570          if (componentName == null) {
2571              return null;
2572          }
2573  
2574          try {
2575              PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2576              if (!pi.applicationInfo.enabled) {
2577                  // If we return null here, the corresponding item will be removed from the launcher
2578                  // db and will not appear in the workspace.
2579                  return null;
2580              }
2581          } catch (NameNotFoundException e) {
2582              Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2583          }
2584  
2585          // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2586          // then return null &amp; delete this.
2587  
2588          // the resource -- This may implicitly give us back the fallback icon,
2589          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2590          // to avoid saving lots of copies of that in the database, and most apps
2591          // have icons anyway.
2592  
2593          // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2594          // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2595          // via resolveActivity().
2596          ResolveInfo resolveInfo = null;
2597          ComponentName oldComponent = intent.getComponent();
2598          Intent newIntent = new Intent(intent.getAction(), null);
2599          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2600          newIntent.setPackage(oldComponent.getPackageName());
2601          List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2602          for (ResolveInfo i : infos) {
2603              ComponentName cn = new ComponentName(i.activityInfo.packageName,
2604                      i.activityInfo.name);
2605              if (cn.equals(oldComponent)) {
2606                  resolveInfo = i;
2607              }
2608          }
2609          if (resolveInfo == null) {
2610              resolveInfo = manager.resolveActivity(intent, 0);
2611          }
2612          if (resolveInfo != null) {
2613              icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2614          }
2615          // the db
2616          if (icon == null) {
2617              if (c != null) {
2618                  icon = getIconFromCursor(c, iconIndex, context);
2619              }
2620          }
2621          // the fallback icon
2622          if (icon == null) {
2623              icon = getFallbackIcon();
2624              info.usingFallbackIcon = true;
2625          }
2626          info.setIcon(icon);
2627  
2628          // from the resource
2629          if (resolveInfo != null) {
2630              ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2631              if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2632                  info.title = labelCache.get(key);
2633              } else {
2634                  info.title = resolveInfo.activityInfo.loadLabel(manager);
2635                  if (labelCache != null) {
2636                      labelCache.put(key, info.title);
2637                  }
2638              }
2639          }
2640          // from the db
2641          if (info.title == null) {
2642              if (c != null) {
2643                  info.title =  c.getString(titleIndex);
2644              }
2645          }
2646          // fall back to the class name of the activity
2647          if (info.title == null) {
2648              info.title = componentName.getClassName();
2649          }
2650          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2651          return info;
2652      }
2653  
2654      /**
2655       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2656       */
2657      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2658              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2659              int titleIndex) {
2660  
2661          Bitmap icon = null;
2662          final ShortcutInfo info = new ShortcutInfo();
2663          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2664  
2665          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2666  
2667          info.title = c.getString(titleIndex);
2668  
2669          int iconType = c.getInt(iconTypeIndex);
2670          switch (iconType) {
2671          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2672              String packageName = c.getString(iconPackageIndex);
2673              String resourceName = c.getString(iconResourceIndex);
2674              PackageManager packageManager = context.getPackageManager();
2675              info.customIcon = false;
2676              // the resource
2677              try {
2678                  Resources resources = packageManager.getResourcesForApplication(packageName);
2679                  if (resources != null) {
2680                      final int id = resources.getIdentifier(resourceName, null, null);
2681                      icon = Utilities.createIconBitmap(
2682                              mIconCache.getFullResIcon(resources, id), context);
2683                  }
2684              } catch (Exception e) {
2685                  // drop this.  we have other places to look for icons
2686              }
2687              // the db
2688              if (icon == null) {
2689                  icon = getIconFromCursor(c, iconIndex, context);
2690              }
2691              // the fallback icon
2692              if (icon == null) {
2693                  icon = getFallbackIcon();
2694                  info.usingFallbackIcon = true;
2695              }
2696              break;
2697          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2698              icon = getIconFromCursor(c, iconIndex, context);
2699              if (icon == null) {
2700                  icon = getFallbackIcon();
2701                  info.customIcon = false;
2702                  info.usingFallbackIcon = true;
2703              } else {
2704                  info.customIcon = true;
2705              }
2706              break;
2707          default:
2708              icon = getFallbackIcon();
2709              info.usingFallbackIcon = true;
2710              info.customIcon = false;
2711              break;
2712          }
2713          info.setIcon(icon);
2714          return info;
2715      }
2716  
2717      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2718          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2719          final boolean debug = false;
2720          if (debug) {
2721              Log.d(TAG, &quot;getIconFromCursor app=&quot;
2722                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2723          }
2724          byte[] data = c.getBlob(iconIndex);
2725          try {
2726              return Utilities.createIconBitmap(
2727                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
2728          } catch (Exception e) {
2729              return null;
2730          }
2731      }
2732  
2733      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2734              int cellX, int cellY, boolean notify) {
2735          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2736          if (info == null) {
2737              return null;
2738          }
2739          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2740  
2741          return info;
2742      }
2743  
2744      /**
2745       * Attempts to find an AppWidgetProviderInfo that matches the given component.
2746       */
2747      AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2748              ComponentName component) {
2749          List&lt;AppWidgetProviderInfo&gt; widgets =
2750              AppWidgetManager.getInstance(context).getInstalledProviders();
2751          for (AppWidgetProviderInfo info : widgets) {
2752              if (info.provider.equals(component)) {
2753                  return info;
2754              }
2755          }
2756          return null;
2757      }
2758  
2759      /**
2760       * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2761       */
2762      List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2763          final PackageManager packageManager = context.getPackageManager();
2764          final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2765              new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2766  
2767          final Intent supportsIntent =
2768              new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2769          supportsIntent.setType(mimeType);
2770  
2771          // Create a set of widget configuration components that we can test against
2772          final List&lt;AppWidgetProviderInfo&gt; widgets =
2773              AppWidgetManager.getInstance(context).getInstalledProviders();
2774          final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2775              new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2776          for (AppWidgetProviderInfo info : widgets) {
2777              configurationComponentToWidget.put(info.configure, info);
2778          }
2779  
2780          // Run through each of the intents that can handle this type of clip data, and cross
2781          // reference them with the components that are actual configuration components
2782          final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2783                  PackageManager.MATCH_DEFAULT_ONLY);
2784          for (ResolveInfo info : activities) {
2785              final ActivityInfo activityInfo = info.activityInfo;
2786              final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2787                      activityInfo.name);
2788              if (configurationComponentToWidget.containsKey(infoComponent)) {
2789                  supportedConfigurationActivities.add(
2790                          new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2791                                  configurationComponentToWidget.get(infoComponent)));
2792              }
2793          }
2794          return supportedConfigurationActivities;
2795      }
2796  
2797      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2798          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2799          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2800          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2801  
2802          if (intent == null) {
2803              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2804              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2805              return null;
2806          }
2807  
2808          Bitmap icon = null;
2809          boolean customIcon = false;
2810          ShortcutIconResource iconResource = null;
2811  
2812          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2813              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2814              customIcon = true;
2815          } else {
2816              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2817              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2818                  try {
2819                      iconResource = (ShortcutIconResource) extra;
2820                      final PackageManager packageManager = context.getPackageManager();
2821                      Resources resources = packageManager.getResourcesForApplication(
2822                              iconResource.packageName);
2823                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2824                      icon = Utilities.createIconBitmap(
2825                              mIconCache.getFullResIcon(resources, id), context);
2826                  } catch (Exception e) {
2827                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2828                  }
2829              }
2830          }
2831  
2832          final ShortcutInfo info = new ShortcutInfo();
2833  
2834          if (icon == null) {
2835              if (fallbackIcon != null) {
2836                  icon = fallbackIcon;
2837              } else {
2838                  icon = getFallbackIcon();
2839                  info.usingFallbackIcon = true;
2840              }
2841          }
2842          info.setIcon(icon);
2843  
2844          info.title = name;
2845          info.intent = intent;
2846          info.customIcon = customIcon;
2847          info.iconResource = iconResource;
2848  
2849          return info;
2850      }
2851  
2852      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2853              int iconIndex) {
2854          // If apps can&#x27;t be on SD, don&#x27;t even bother.
2855          if (!mAppsCanBeOnExternalStorage) {
2856              return false;
2857          }
2858          // If this icon doesn&#x27;t have a custom icon, check to see
2859          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2860          // we&#x27;re going to show, store what we are going to show back
2861          // into the DB.  We do this so when we&#x27;re loading, if the
2862          // package manager can&#x27;t find an icon (for example because
2863          // the app is on SD) then we can use that instead.
2864          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2865              cache.put(info, c.getBlob(iconIndex));
2866              return true;
2867          }
2868          return false;
2869      }
2870      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2871          boolean needSave = false;
2872          try {
2873              if (data != null) {
2874                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2875                  Bitmap loaded = info.getIcon(mIconCache);
2876                  needSave = !saved.sameAs(loaded);
2877              } else {
2878                  needSave = true;
2879              }
2880          } catch (Exception e) {
2881              needSave = true;
2882          }
2883          if (needSave) {
2884              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2885              // This is slower than is ideal, but this only happens once
2886              // or when the app is updated with a new icon.
2887              updateItemInDatabase(context, info);
2888          }
2889      }
2890  
2891      /**
2892       * Return an existing FolderInfo object if we have encountered this ID previously,
2893       * or make a new one.
2894       */
2895      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2896          // See if a placeholder was created for us already
2897          FolderInfo folderInfo = folders.get(id);
2898          if (folderInfo == null) {
2899              // No placeholder -- create a new instance
2900              folderInfo = new FolderInfo();
2901              folders.put(id, folderInfo);
2902          }
2903          return folderInfo;
2904      }
2905  
2906      private static final Collator sCollator = Collator.getInstance();
2907      public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2908              = new Comparator&lt;ApplicationInfo&gt;() {
2909          public final int compare(ApplicationInfo a, ApplicationInfo b) {
2910              int result = sCollator.compare(a.title.toString(), b.title.toString());
2911              if (result == 0) {
2912                  result = a.componentName.compareTo(b.componentName);
2913              }
2914              return result;
2915          }
2916      };
2917      public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2918              = new Comparator&lt;ApplicationInfo&gt;() {
2919          public final int compare(ApplicationInfo a, ApplicationInfo b) {
2920              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2921              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2922              return 0;
2923          }
2924      };
2925      public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2926              = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2927          public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2928              return sCollator.compare(a.label.toString(), b.label.toString());
2929          }
2930      };
2931      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2932          if (info.activityInfo != null) {
2933              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2934          } else {
2935              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2936          }
2937      }
2938      public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2939          private PackageManager mPackageManager;
2940          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2941          ShortcutNameComparator(PackageManager pm) {
2942              mPackageManager = pm;
2943              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2944          }
2945          ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2946              mPackageManager = pm;
2947              mLabelCache = labelCache;
2948          }
2949          public final int compare(ResolveInfo a, ResolveInfo b) {
2950              CharSequence labelA, labelB;
2951              ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2952              ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2953              if (mLabelCache.containsKey(keyA)) {
2954                  labelA = mLabelCache.get(keyA);
2955              } else {
2956                  labelA = a.loadLabel(mPackageManager).toString();
2957  
2958                  mLabelCache.put(keyA, labelA);
2959              }
2960              if (mLabelCache.containsKey(keyB)) {
2961                  labelB = mLabelCache.get(keyB);
2962              } else {
2963                  labelB = b.loadLabel(mPackageManager).toString();
2964  
2965                  mLabelCache.put(keyB, labelB);
2966              }
2967              return sCollator.compare(labelA, labelB);
2968          }
2969      };
2970      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2971          private PackageManager mPackageManager;
2972          private HashMap&lt;Object, String&gt; mLabelCache;
2973          WidgetAndShortcutNameComparator(PackageManager pm) {
2974              mPackageManager = pm;
2975              mLabelCache = new HashMap&lt;Object, String&gt;();
2976          }
2977          public final int compare(Object a, Object b) {
2978              String labelA, labelB;
2979              if (mLabelCache.containsKey(a)) {
2980                  labelA = mLabelCache.get(a);
2981              } else {
2982                  labelA = (a instanceof AppWidgetProviderInfo) ?
2983                      ((AppWidgetProviderInfo) a).label :
2984                      ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2985                  mLabelCache.put(a, labelA);
2986              }
2987              if (mLabelCache.containsKey(b)) {
2988                  labelB = mLabelCache.get(b);
2989              } else {
2990                  labelB = (b instanceof AppWidgetProviderInfo) ?
2991                      ((AppWidgetProviderInfo) b).label :
2992                      ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2993                  mLabelCache.put(b, labelB);
2994              }
2995              return sCollator.compare(labelA, labelB);
2996          }
2997      };
2998  
2999      public void dumpState() {
3000          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3001 -        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mAllAppsList.data);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3002 -        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mAllAppsList.added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3003 -        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mAllAppsList.removed);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3004 -        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mAllAppsList.modified);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3005 +        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3006 +        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3007 +        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3008 +        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);</span>
3009          if (mLoaderTask != null) {
3010              mLoaderTask.dumpState();
3011          } else {
3012              Log.d(TAG, &quot;mLoaderTask=null&quot;);
3013          }
3014      }
3015  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
  22  import android.content.BroadcastReceiver;
  23  import android.content.ComponentName;
  24  import android.content.ContentProviderClient;
  25  import android.content.ContentResolver;
  26  import android.content.ContentValues;
  27  import android.content.Context;
  28  import android.content.Intent;
  29  import android.content.Intent.ShortcutIconResource;
  30  import android.content.pm.ActivityInfo;
  31  import android.content.pm.PackageInfo;
  32  import android.content.pm.PackageManager;
  33  import android.content.pm.PackageManager.NameNotFoundException;
  34  import android.content.pm.ResolveInfo;
  35  import android.content.res.Configuration;
  36  import android.content.res.Resources;
  37  import android.database.Cursor;
  38  import android.graphics.Bitmap;
  39  import android.graphics.BitmapFactory;
  40  import android.net.Uri;
  41  import android.os.Environment;
  42  import android.os.Handler;
  43  import android.os.HandlerThread;
  44  import android.os.Parcelable;
  45  import android.os.Process;
  46  import android.os.RemoteException;
  47  import android.os.SystemClock;
  48  import android.util.Log;
  49  
  50  import com.android.launcher.R;
  51  import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52  
  53  import java.lang.ref.WeakReference;
  54  import java.net.URISyntaxException;
  55  import java.text.Collator;
  56  import java.util.ArrayList;
  57  import java.util.Collections;
  58  import java.util.Comparator;
  59  import java.util.HashMap;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +import java.util.HashSet;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import java.util.Iterator;</span>
  62  import java.util.List;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import java.util.Set;</span>
  64  
  65  /**
  66   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67   * LauncherModel object held in a static. Also provide APIs for updating the database state
  68   * for the Launcher.
  69   */
  70  public class LauncherModel extends BroadcastReceiver {
  71      static final boolean DEBUG_LOADERS = false;
  72      static final String TAG = &quot;Launcher.Model&quot;;
  73  
  74      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75      private final boolean mAppsCanBeOnExternalStorage;
  76      private int mBatchSize; // 0 is all apps at once
  77      private int mAllAppsLoadDelay; // milliseconds between batches
  78  
  79      private final LauncherApplication mApp;
  80      private final Object mLock = new Object();
  81      private DeferredHandler mHandler = new DeferredHandler();
  82      private LoaderTask mLoaderTask;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +    private boolean mIsLoaderTaskRunning;</span>
  84  
  85      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86      static {
  87          sWorkerThread.start();
  88      }
  89      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90  
  91      // We start off with everything not loaded.  After that, we assume that
  92      // our monitoring of the package manager provides all updates and we never
  93      // need to do a requery.  These are only ever touched from the loader thread.
  94      private boolean mWorkspaceLoaded;
  95      private boolean mAllAppsLoaded;
  96  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +    // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +    // pages as this delays the rotation process.  Instead, we wait for a callback from the first</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +    // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +    // a normal load, we also clear this set of Runnables.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +    static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +</span>
 103      private WeakReference&lt;Callbacks&gt; mCallbacks;
 104  
 105      // &lt; only access in worker thread &gt;
 106      private AllAppsList mAllAppsList;
 107  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -    // sItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +    // The lock that must be acquired before referencing any static bg data structures.  Unlike</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +    // other locks, this one can generally be held long-term because we never expect any of these</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +    // static data structures to be referenced outside of the worker thread except on the first</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +    // load after configuration change.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +    static final Object sBgLock = new Object();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +    // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by</span>


 116      // LauncherModel to their ids
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -    static final HashMap&lt;Long, ItemInfo&gt; sItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -    // sItems is passed to bindItems, which expects a list of all folders and shortcuts created by</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +    static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +    // sBgItems is passed to bindItems, which expects a list of all folders and shortcuts created by</span>
 123      //       LauncherModel that are directly on the home screen (however, no widgets or shortcuts
 124      //       within folders).
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -    static final ArrayList&lt;ItemInfo&gt; sWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -    // sAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -    static final ArrayList&lt;LauncherAppWidgetInfo&gt; sAppWidgets =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +    static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +    // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +    static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =</span>





 133          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 134  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -    // sFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -    static final HashMap&lt;Long, FolderInfo&gt; sFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -    // sDbIconCache is the set of ItemInfos that need to have their icons updated in the database</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -    static final HashMap&lt;Object, byte[]&gt; sDbIconCache = new HashMap&lt;Object, byte[]&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +    // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +    static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +    // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +    static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();</span>
 145  





 146      // &lt;/ only access in worker thread &gt;
 147  
 148      private IconCache mIconCache;
 149      private Bitmap mDefaultIcon;
 150  
 151      private static int mCellCountX;
 152      private static int mCellCountY;
 153  
 154      protected int mPreviousConfigMcc;
 155  
 156      public interface Callbacks {
 157          public boolean setLoadOnResume();
 158          public int getCurrentWorkspaceScreen();
 159          public void startBinding();
 160          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 161          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 162          public void finishBindingItems();
 163          public void bindAppWidget(LauncherAppWidgetInfo info);
 164          public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 165          public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 166          public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
 167          public void bindAppsRemoved(ArrayList&lt;ApplicationInfo&gt; apps, boolean permanent);

 168          public void bindPackagesUpdated();
 169          public boolean isAllAppsVisible();
 170          public boolean isAllAppsButtonRank(int rank);
 171          public void bindSearchablesChanged();
 172      }
 173  
 174      LauncherModel(LauncherApplication app, IconCache iconCache) {
 175          mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 176          mApp = app;
 177          mAllAppsList = new AllAppsList(iconCache);

 178          mIconCache = iconCache;
 179  
 180          mDefaultIcon = Utilities.createIconBitmap(
 181                  mIconCache.getFullResDefaultActivityIcon(), app);
 182  
 183          final Resources res = app.getResources();
 184          mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 185          mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 186          Configuration config = res.getConfiguration();
 187          mPreviousConfigMcc = config.mcc;
 188      }
 189  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +    /** Runs the specified runnable immediately if called from the main thread, otherwise it is</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +     * posted on the main thread handler. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +    private void runOnMainThread(Runnable r) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +            // If we are on the worker thread, post onto the main handler</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +            mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +            r.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 199 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +    /** Runs the specified runnable immediately if called from the worker thread, otherwise it is</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +     * posted on the worker thread handler. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +    private static void runOnWorkerThread(Runnable r) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +            r.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +            // If we are not on the worker thread, then post to the worker handler</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +            sWorker.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +</span>
 212      public Bitmap getFallbackIcon() {
 213          return Bitmap.createBitmap(mDefaultIcon);
 214      }
 215  
 216      public void unbindWorkspaceItems() {
 217          sWorker.post(new Runnable() {
 218              @Override
 219              public void run() {
 220                  unbindWorkspaceItemsOnMainThread();
 221              }
 222          });
 223      }
 224  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 225 -    /** Unbinds all the sWorkspaceItems on the main thread, and return a copy of sWorkspaceItems</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 226 -     * that is save to reference from the main thread. */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 227 -    private ArrayList&lt;ItemInfo&gt; unbindWorkspaceItemsOnMainThread() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +    /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +    private void unbindWorkspaceItemsOnMainThread() {</span>
 230          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 231          // by making a copy of workspace items first.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -        final ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;(sWorkspaceItems);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -        final ArrayList&lt;ItemInfo&gt; appWidgets = new ArrayList&lt;ItemInfo&gt;(sAppWidgets);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -        mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -            public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 237 -               for (ItemInfo item : workspaceItems) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -                   item.unbind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -               }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -               for (ItemInfo item : appWidgets) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 241 -                   item.unbind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -               }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 244 -        });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 245 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 246 -        return workspaceItems;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +        final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +        final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +        synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +            tmpWorkspaceItems.addAll(sBgWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +            tmpAppWidgets.addAll(sBgAppWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +                   for (ItemInfo item : tmpWorkspaceItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +                       item.unbind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +                   }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +                   for (ItemInfo item : tmpAppWidgets) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +                       item.unbind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +                   }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +        runOnMainThread(r);</span>
 265      }
 266  
 267      /**
 268       * Adds an item to the DB if it was not created previously, or move it to a new
 269       * &lt;container, screen, cellX, cellY&gt;
 270       */
 271      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 272              int screen, int cellX, int cellY) {
 273          if (item.container == ItemInfo.NO_ID) {
 274              // From all apps
 275              addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 276          } else {
 277              // From somewhere else
 278              moveItemInDatabase(context, item, container, screen, cellX, cellY);
 279          }
 280      }
 281  

























 282      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 283              final ItemInfo item, final String callingFunction) {
 284          final long itemId = item.id;
 285          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 286          final ContentResolver cr = context.getContentResolver();
 287  

 288          Runnable r = new Runnable() {
 289              public void run() {
 290                  cr.update(uri, values, null, null);
 291  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 292 -                ItemInfo modelItem = sItemsIdMap.get(itemId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 293 -                if (item != modelItem) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 294 -                    // the modelItem needs to match up perfectly with item if our model is to be</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 295 -                    // consistent with the database-- for now, just require modelItem == item</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 296 -                    String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 297 -                        &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 298 -                        &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match original&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 299 -                    throw new RuntimeException(msg);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 300 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -                // Items are added/removed from the corresponding FolderInfo elsewhere, such</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -                // as in Workspace.onDrop. Here, we just add/remove them from the list of items</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 304 -                // that are on the desktop, as appropriate</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 305 -                if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 306 -                        modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 307 -                    if (!sWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -                        sWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 309 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 310 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 311 -                    sWorkspaceItems.remove(modelItem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +                    ItemInfo modelItem = sBgItemsIdMap.get(itemId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +                    if (item != modelItem) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +                        // the modelItem needs to match up perfectly with item if our model is to be</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +                        // consistent with the database-- for now, just require modelItem == item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +                        String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +                            &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +                            &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +                            &quot;original&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +                        throw new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 325 +                    // Items are added/removed from the corresponding FolderInfo elsewhere, such</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +                    // as in Workspace.onDrop. Here, we just add/remove them from the list of items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +                    // that are on the desktop, as appropriate</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +                    if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 329 +                            modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +                        if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +                            sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 332 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 333 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 334 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +                        sBgWorkspaceItems.remove(modelItem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 336 +                    }</span>






















 337                  }
 338              }
 339          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 340 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 341 -        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 342 -            r.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 343 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 344 -            sWorker.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 345 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +        runOnWorkerThread(r);</span>
 347      }
 348  
 349      /**
 350       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 351       */
 352      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 353              final int screen, final int cellX, final int cellY) {





 354          item.container = container;
 355          item.cellX = cellX;
 356          item.cellY = cellY;
 357  
 358          // We store hotseat items in canonical form which is this orientation invariant position
 359          // in the hotseat
 360          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 361                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 362              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 363          } else {
 364              item.screen = screen;
 365          }
 366  
 367          final ContentValues values = new ContentValues();
 368          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 369          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 370          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 371          values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 372  
 373          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 374      }
 375  
 376      /**
 377       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 378       */
 379      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 380              final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
 381          item.container = container;





 382          item.cellX = cellX;
 383          item.cellY = cellY;
 384          item.spanX = spanX;
 385          item.spanY = spanY;
 386  
 387          // We store hotseat items in canonical form which is this orientation invariant position
 388          // in the hotseat
 389          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 390                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 391              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 392          } else {
 393              item.screen = screen;
 394          }
 395  
 396          final ContentValues values = new ContentValues();
 397          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 398          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 399          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 400          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 401          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 402          values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 403  
 404          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);

 405      }
 406  
 407      /**
 408       * Update an item to the database in a specified container.
 409       */
 410      static void updateItemInDatabase(Context context, final ItemInfo item) {
 411          final ContentValues values = new ContentValues();
 412          item.onAddToDatabase(values);
 413          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 414          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 415      }
 416  
 417      /**
 418       * Returns true if the shortcuts already exists in the database.
 419       * we identify a shortcut by its title and intent.
 420       */
 421      static boolean shortcutExists(Context context, String title, Intent intent) {
 422          final ContentResolver cr = context.getContentResolver();
 423          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 424              new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 425              new String[] { title, intent.toUri(0) }, null);
 426          boolean result = false;
 427          try {
 428              result = c.moveToFirst();
 429          } finally {
 430              c.close();
 431          }
 432          return result;
 433      }
 434  
 435      /**
 436       * Returns an ItemInfo array containing all the items in the LauncherModel.
 437       * The ItemInfo.id is not set through this function.
 438       */
 439      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 440          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 441          final ContentResolver cr = context.getContentResolver();
 442          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 443                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 444                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 444                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CEðŸ”µ</abbr>
 445                  LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 446  
 447          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 448          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 449          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 450          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 451          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 452          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 453          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 454  
 455          try {
 456              while (c.moveToNext()) {
 457                  ItemInfo item = new ItemInfo();
 458                  item.cellX = c.getInt(cellXIndex);
 459                  item.cellY = c.getInt(cellYIndex);
 460                  item.spanX = c.getInt(spanXIndex);
 461                  item.spanY = c.getInt(spanYIndex);
 462                  item.container = c.getInt(containerIndex);
 463                  item.itemType = c.getInt(itemTypeIndex);
 464                  item.screen = c.getInt(screenIndex);
 465  
 466                  items.add(item);
 467              }
 468          } catch (Exception e) {
 469              items.clear();
 470          } finally {
 471              c.close();
 472          }
 473  
 474          return items;
 475      }
 476  
 477      /**
 478       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 479       */
 480      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 481          final ContentResolver cr = context.getContentResolver();
 482          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 483                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 484                  new String[] { String.valueOf(id),
 485                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 486  
 487          try {
 488              if (c.moveToFirst()) {
 489                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 490                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 491                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 492                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 493                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 494                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 495  
 496                  FolderInfo folderInfo = null;
 497                  switch (c.getInt(itemTypeIndex)) {
 498                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 499                          folderInfo = findOrMakeFolder(folderList, id);
 500                          break;
 501                  }
 502  
 503                  folderInfo.title = c.getString(titleIndex);
 504                  folderInfo.id = id;
 505                  folderInfo.container = c.getInt(containerIndex);
 506                  folderInfo.screen = c.getInt(screenIndex);
 507                  folderInfo.cellX = c.getInt(cellXIndex);
 508                  folderInfo.cellY = c.getInt(cellYIndex);
 509  
 510                  return folderInfo;
 511              }
 512          } finally {
 513              c.close();
 514          }
 515  
 516          return null;
 517      }
 518  
 519      /**
 520       * Add an item to the database in a specified container. Sets the container, screen, cellX and
 521       * cellY fields of the item. Also assigns an ID to the item.
 522       */
 523      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 524              final int screen, final int cellX, final int cellY, final boolean notify) {
 525          item.container = container;
 526          item.cellX = cellX;
 527          item.cellY = cellY;
 528          // We store hotseat items in canonical form which is this orientation invariant position
 529          // in the hotseat
 530          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 531                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 532              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 533          } else {
 534              item.screen = screen;
 535          }
 536  
 537          final ContentValues values = new ContentValues();
 538          final ContentResolver cr = context.getContentResolver();
 539          item.onAddToDatabase(values);
 540  
 541          LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 542          item.id = app.getLauncherProvider().generateNewId();
 543          values.put(LauncherSettings.Favorites._ID, item.id);
 544          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 545  


 546          Runnable r = new Runnable() {
 547              public void run() {






 548                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 549                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 550 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 551 -                if (sItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 552 -                    // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 553 -                    throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 554 -                        &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -                sItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -                switch (item.itemType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -                    case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -                        sFolders.put(item.id, (FolderInfo) item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -                        // Fall through</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -                    case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -                    case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -                        if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -                                item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -                            sWorkspaceItems.add(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -                        break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -                    case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -                        sAppWidgets.add((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 571 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 572 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 573 +                    if (sBgItemsIdMap.containsKey(item.id)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 574 +                        // we should not be adding new items in the db with the same id</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 575 +                        throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 576 +                            &quot;addItemToDatabase already exists.&quot; + item.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 577 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 578 +                    sBgItemsIdMap.put(item.id, item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +                    switch (item.itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +                            sBgFolders.put(item.id, (FolderInfo) item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 582 +                            // Fall through</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 583 +                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 584 +                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 585 +                            if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 586 +                                    item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 587 +                                sBgWorkspaceItems.add(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 588 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 589 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 590 +                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +                            sBgAppWidgets.add((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +                    }</span>










 594                  }
 595              }
 596          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 597 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 598 -        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 599 -            r.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 600 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 601 -            sWorker.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 602 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 603 +        runOnWorkerThread(r);</span>
 604      }
 605  
 606      /**
 607       * Creates a new unique child id, for a given cell span across all layouts.
 608       */
 609      static int getCellLayoutChildId(
 610              long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 611          return (((int) container &amp; 0xFF) &lt;&lt; 24)
 612                  | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 613      }
 614  
 615      static int getCellCountX() {
 616          return mCellCountX;
 617      }
 618  
 619      static int getCellCountY() {
 620          return mCellCountY;
 621      }
 622  
 623      /**
 624       * Updates the model orientation helper to take into account the current layout dimensions
 625       * when performing local/canonical coordinate transformations.
 626       */
 627      static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 628          mCellCountX = shortAxisCellCount;
 629          mCellCountY = longAxisCellCount;
 630      }
 631  
 632      /**
 633       * Removes the specified item from the database
 634       * @param context
 635       * @param item
 636       */
 637      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 638          final ContentResolver cr = context.getContentResolver();
 639          final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);


 640          Runnable r = new Runnable() {
 641              public void run() {






 642                  cr.delete(uriToDelete, null, null);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -                switch (item.itemType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -                    case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 645 -                        sFolders.remove(item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 646 -                        sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 647 -                        break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -                    case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -                    case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -                        sWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -                        break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -                    case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -                        sAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -                        break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -                sItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -                sDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 659 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +                    switch (item.itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +                            sBgFolders.remove(item.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +                            sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +                            sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +                            sBgAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                            break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 673 +                    sBgItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 674 +                    sBgDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 675 +                }</span>













 676              }
 677          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -            r.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -            sWorker.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 683 +        runOnWorkerThread(r);</span>
 684      }
 685  
 686      /**
 687       * Remove the contents of the specified folder from the database
 688       */
 689      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 690          final ContentResolver cr = context.getContentResolver();
 691  
 692          Runnable r = new Runnable() {
 693              public void run() {
 694                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 695 -                sItemsIdMap.remove(info.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 696 -                sFolders.remove(info.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 697 -                sDbIconCache.remove(info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 698 -                sWorkspaceItems.remove(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 699 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 700 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 701 +                    sBgItemsIdMap.remove(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 702 +                    sBgFolders.remove(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 703 +                    sBgDbIconCache.remove(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 704 +                    sBgWorkspaceItems.remove(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 705 +                }</span>
 706  
 707                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 708                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 709 -                for (ItemInfo childInfo : info.contents) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 710 -                    sItemsIdMap.remove(childInfo.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 711 -                    sDbIconCache.remove(childInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 712 +                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 713 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 714 +                    for (ItemInfo childInfo : info.contents) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 715 +                        sBgItemsIdMap.remove(childInfo.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 716 +                        sBgDbIconCache.remove(childInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 717 +                    }</span>
 718                  }
 719              }
 720          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 721 -        if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 722 -            r.run();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 723 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 724 -            sWorker.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 725 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 726 +        runOnWorkerThread(r);</span>
 727      }
 728  
 729      /**
 730       * Set this as the current Launcher activity object for the loader.
 731       */
 732      public void initialize(Callbacks callbacks) {
 733          synchronized (mLock) {
 734              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 735          }
 736      }
 737  
 738      /**
 739       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 740       * ACTION_PACKAGE_CHANGED.
 741       */
 742      @Override
 743      public void onReceive(Context context, Intent intent) {
 744          if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 745  
 746          final String action = intent.getAction();
 747  
 748          if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 749                  || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 750                  || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 751              final String packageName = intent.getData().getSchemeSpecificPart();
 752              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 753  
 754              int op = PackageUpdatedTask.OP_NONE;
 755  
 756              if (packageName == null || packageName.length() == 0) {
 757                  // they sent us a bad intent
 758                  return;
 759              }
 760  
 761              if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 762                  op = PackageUpdatedTask.OP_UPDATE;
 763              } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 764                  if (!replacing) {
 765                      op = PackageUpdatedTask.OP_REMOVE;
 766                  }
 767                  // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 768                  // later, we will update the package at this time
 769              } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 770                  if (!replacing) {
 771                      op = PackageUpdatedTask.OP_ADD;
 772                  } else {
 773                      op = PackageUpdatedTask.OP_UPDATE;
 774                  }
 775              }
 776  
 777              if (op != PackageUpdatedTask.OP_NONE) {
 778                  enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 779              }
 780  
 781          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 782              // First, schedule to add these apps back in.
 783              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 784              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 785              // Then, rebind everything.
 786              startLoaderFromBackground();
 787          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 788              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 789              enqueuePackageUpdated(new PackageUpdatedTask(
 790                          PackageUpdatedTask.OP_UNAVAILABLE, packages));
 791          } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 792              // If we have changed locale we need to clear out the labels in all apps/workspace.
 793              forceReload();
 794          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 795               // Check if configuration change was an mcc/mnc change which would affect app resources
 796               // and we would need to clear out the labels in all apps/workspace. Same handling as
 797               // above for ACTION_LOCALE_CHANGED
 798               Configuration currentConfig = context.getResources().getConfiguration();
 799               if (mPreviousConfigMcc != currentConfig.mcc) {
 800                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 801                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 802                     forceReload();
 803               }
 804               // Update previousConfig
 805               mPreviousConfigMcc = currentConfig.mcc;
 806          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 807                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 808              if (mCallbacks != null) {
 809                  Callbacks callbacks = mCallbacks.get();
 810                  if (callbacks != null) {
 811                      callbacks.bindSearchablesChanged();
 812                  }
 813              }
 814          }
 815      }
 816  
 817      private void forceReload() {
 818          resetLoadedState(true, true);
 819  
 820          // Do this here because if the launcher activity is running it will be restarted.
 821          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 822          // to reload.
 823          startLoaderFromBackground();
 824      }
 825  
 826      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 827          synchronized (mLock) {
 828              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 829              // mWorkspaceLoaded to true later
 830              stopLoaderLocked();
 831              if (resetAllAppsLoaded) mAllAppsLoaded = false;
 832              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 833          }
 834      }
 835  
 836      /**
 837       * When the launcher is in the background, it&#x27;s possible for it to miss paired
 838       * configuration changes.  So whenever we trigger the loader from the background
 839       * tell the launcher that it needs to re-run the loader when it comes back instead
 840       * of doing it now.
 841       */
 842      public void startLoaderFromBackground() {
 843          boolean runLoader = false;
 844          if (mCallbacks != null) {
 845              Callbacks callbacks = mCallbacks.get();
 846              if (callbacks != null) {
 847                  // Only actually run the loader if they&#x27;re not paused.
 848                  if (!callbacks.setLoadOnResume()) {
 849                      runLoader = true;
 850                  }
 851              }
 852          }
 853          if (runLoader) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 854 -            startLoader(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 855 +            startLoader(false, -1);</span>
 856          }
 857      }
 858  
 859      // If there is already a loader task running, tell it to stop.
 860      // returns true if isLaunching() was true on the old task
 861      private boolean stopLoaderLocked() {
 862          boolean isLaunching = false;
 863          LoaderTask oldTask = mLoaderTask;
 864          if (oldTask != null) {
 865              if (oldTask.isLaunching()) {
 866                  isLaunching = true;
 867              }
 868              oldTask.stopLocked();
 869          }
 870          return isLaunching;
 871      }
 872  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 873 -    public void startLoader(boolean isLaunching) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 874 +    public void startLoader(boolean isLaunching, int synchronousBindPage) {</span>
 875          synchronized (mLock) {
 876              if (DEBUG_LOADERS) {
 877                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 878              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 879 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 880 +            // Clear any deferred bind-runnables from the synchronized load process</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 881 +            // We must do this before any loading/binding is scheduled below.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 882 +            mDeferredBindRunnables.clear();</span>
 883  
 884              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 885              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 886                  // If there is already one running, tell it to stop.
 887                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 888                  isLaunching = isLaunching || stopLoaderLocked();
 889                  mLoaderTask = new LoaderTask(mApp, isLaunching);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 890 -                sWorkerThread.setPriority(Thread.NORM_PRIORITY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 891 -                sWorker.post(mLoaderTask);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 892 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 893 +                if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 894 +                    mLoaderTask.runBindSynchronousPage(synchronousBindPage);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 895 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 896 +                    sWorkerThread.setPriority(Thread.NORM_PRIORITY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 897 +                    sWorker.post(mLoaderTask);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 898 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 899 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 900 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 901 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 902 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 903 +    void bindRemainingSynchronousPages() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 904 +        // Post the remaining side pages to be loaded</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 905 +        if (!mDeferredBindRunnables.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 906 +            for (final Runnable r : mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 907 +                mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 908 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +            mDeferredBindRunnables.clear();</span>
 910          }
 911      }
 912  
 913      public void stopLoader() {
 914          synchronized (mLock) {
 915              if (mLoaderTask != null) {
 916                  mLoaderTask.stopLocked();
 917              }
 918          }
 919      }
 920  
 921      public boolean isAllAppsLoaded() {
 922          return mAllAppsLoaded;
 923      }
 924  
 925      boolean isLoadingWorkspace() {
 926          synchronized (mLock) {
 927              if (mLoaderTask != null) {
 928                  return mLoaderTask.isLoadingWorkspace();
 929              }
 930          }
 931          return false;
 932      }
 933  
 934      /**
 935       * Runnable for the thread that loads the contents of the launcher:
 936       *   - workspace icons
 937       *   - widgets
 938       *   - all apps icons
 939       */
 940      private class LoaderTask implements Runnable {
 941          private Context mContext;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 942 -        private Thread mWaitThread;</span>
 943          private boolean mIsLaunching;
 944          private boolean mIsLoadingAndBindingWorkspace;
 945          private boolean mStopped;
 946          private boolean mLoadAndBindStepFinished;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 947 +</span>
 948          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
 949  
 950          LoaderTask(Context context, boolean isLaunching) {
 951              mContext = context;
 952              mIsLaunching = isLaunching;
 953              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
 954          }
 955  
 956          boolean isLaunching() {
 957              return mIsLaunching;
 958          }
 959  
 960          boolean isLoadingWorkspace() {
 961              return mIsLoadingAndBindingWorkspace;
 962          }
 963  
 964          private void loadAndBindWorkspace() {
 965              mIsLoadingAndBindingWorkspace = true;
 966  
 967              // Load the workspace
 968              if (DEBUG_LOADERS) {
 969                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
 970              }
 971  
 972              if (!mWorkspaceLoaded) {
 973                  loadWorkspace();
 974                  synchronized (LoaderTask.this) {
 975                      if (mStopped) {
 976                          return;
 977                      }
 978                      mWorkspaceLoaded = true;
 979                  }
 980              }
 981  
 982              // Bind the workspace
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 983 -            bindWorkspace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 984 +            bindWorkspace(-1);</span>
 985          }
 986  
 987          private void waitForIdle() {
 988              // Wait until the either we&#x27;re stopped or the other threads are done.
 989              // This way we don&#x27;t start loading all apps until the workspace has settled
 990              // down.
 991              synchronized (LoaderTask.this) {
 992                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
 993  
 994                  mHandler.postIdle(new Runnable() {
 995                          public void run() {
 996                              synchronized (LoaderTask.this) {
 997                                  mLoadAndBindStepFinished = true;
 998                                  if (DEBUG_LOADERS) {
 999                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1000                                  }
1001                                  LoaderTask.this.notify();
1002                              }
1003                          }
1004                      });
1005  
1006                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1007                      try {
1008                          this.wait();
1009                      } catch (InterruptedException ex) {
1010                          // Ignore
1011                      }
1012                  }
1013                  if (DEBUG_LOADERS) {
1014                      Log.d(TAG, &quot;waited &quot;
1015                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1016                              + &quot;ms for previous step to finish binding&quot;);
1017                  }
1018              }
1019          }
1020  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1021 +        void runBindSynchronousPage(int synchronousBindPage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1022 +            if (synchronousBindPage &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1023 +                // Ensure that we have a valid page index to load synchronously</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1024 +                throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1025 +                        &quot;valid page index&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1026 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1027 +            if (!mAllAppsLoaded || !mWorkspaceLoaded) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1028 +                // Ensure that we don&#x27;t try and bind a specified page when the pages have not been</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1029 +                // loaded already (we should load everything asynchronously in that case)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1030 +                throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1031 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1032 +            synchronized (mLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1033 +                if (mIsLoaderTaskRunning) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1034 +                    // Ensure that we are never running the background loading at this point since</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1035 +                    // we also touch the background collections</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1036 +                    throw new RuntimeException(&quot;Error! Background loading is already running&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1037 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1038 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1039 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1040 +            // XXX: Throw an exception if we are already loading (since we touch the worker thread</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1041 +            //      data structures, we can&#x27;t allow any other thread to touch that data, but because</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1042 +            //      this call is synchronous, we can get away with not locking).</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1043 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1044 +            // Divide the set of loaded items into those that we are binding synchronously, and</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1045 +            // everything else that is to be bound normally (asynchronously).</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1046 +            bindWorkspace(synchronousBindPage);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1047 +            // XXX: For now, continue posting the binding of AllApps as there are other issues that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1048 +            //      arise from that.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1049 +            onlyBindAllApps();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1050 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1051 +</span>
1052          public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1053 +            synchronized (mLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1054 +                mIsLoaderTaskRunning = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1055 +            }</span>
1056              // Optimize for end-user experience: if the Launcher is up and // running with the
1057              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1058              // workspace first (default).
1059              final Callbacks cbk = mCallbacks.get();
1060              final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1061  
1062              keep_running: {
1063                  // Elevate priority when Home launches for the first time to avoid
1064                  // starving at boot time. Staring at a blank home is not cool.
1065                  synchronized (mLock) {
1066                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1067                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1068                      android.os.Process.setThreadPriority(mIsLaunching
1069                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1070                  }
1071                  if (loadWorkspaceFirst) {
1072                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1073                      loadAndBindWorkspace();
1074                  } else {
1075                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1076                      loadAndBindAllApps();
1077                  }
1078  
1079                  if (mStopped) {
1080                      break keep_running;
1081                  }
1082  
1083                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1084                  // settled down.
1085                  synchronized (mLock) {
1086                      if (mIsLaunching) {
1087                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1088                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1089                      }
1090                  }
1091                  waitForIdle();
1092  
1093                  // second step
1094                  if (loadWorkspaceFirst) {
1095                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1096                      loadAndBindAllApps();
1097                  } else {
1098                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1099                      loadAndBindWorkspace();
1100                  }
1101  
1102                  // Restore the default thread priority after we are done loading items
1103                  synchronized (mLock) {
1104                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1105                  }
1106              }
1107  
1108  
1109              // Update the saved icons if necessary
1110              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1111 -            for (Object key : sDbIconCache.keySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1112 -                updateSavedIcon(mContext, (ShortcutInfo) key, sDbIconCache.get(key));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1113 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1114 -            sDbIconCache.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1115 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1116 +                for (Object key : sBgDbIconCache.keySet()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1117 +                    updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1118 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1119 +                sBgDbIconCache.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1120 +            }</span>
1121  
1122              // Clear out this reference, otherwise we end up holding it until all of the
1123              // callback runnables are done.
1124              mContext = null;
1125  
1126              synchronized (mLock) {
1127                  // If we are still the last one to be scheduled, remove ourselves.
1128                  if (mLoaderTask == this) {
1129                      mLoaderTask = null;
1130                  }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1131 +                mIsLoaderTaskRunning = false;</span>
1132              }
1133          }
1134  
1135          public void stopLocked() {
1136              synchronized (LoaderTask.this) {
1137                  mStopped = true;
1138                  this.notify();
1139              }
1140          }
1141  
1142          /**
1143           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1144           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1145           * object that was around when the deferred message was scheduled, and if there&#x27;s
1146           * a new Callbacks object around then also return null.  This will save us from
1147           * calling onto it with data that will be ignored.
1148           */
1149          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1150              synchronized (mLock) {
1151                  if (mStopped) {
1152                      return null;
1153                  }
1154  
1155                  if (mCallbacks == null) {
1156                      return null;
1157                  }
1158  
1159                  final Callbacks callbacks = mCallbacks.get();
1160                  if (callbacks != oldCallbacks) {
1161                      return null;
1162                  }
1163                  if (callbacks == null) {
1164                      Log.w(TAG, &quot;no mCallbacks&quot;);
1165                      return null;
1166                  }
1167  
1168                  return callbacks;
1169              }
1170          }
1171  
1172          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1173          private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1174              int containerIndex = item.screen;
1175              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1176                  // Return early if we detect that an item is under the hotseat button
1177                  if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1178                      return false;
1179                  }
1180  
1181                  // We use the last index to refer to the hotseat and the screen as the rank, so
1182                  // test and update the occupied state accordingly
1183                  if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1184                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1185                          + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1186                          + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1187                      return false;
1188                  } else {
1189                      occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1190                      return true;
1191                  }
1192              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1193                  // Skip further checking if it is not the hotseat or workspace container
1194                  return true;
1195              }
1196  
1197              // Check if any workspace icons overlap with each other
1198              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1199                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1200                      if (occupied[containerIndex][x][y] != null) {
1201                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1202                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1203                              + x + &quot;,&quot; + y
1204                              + &quot;) occupied by &quot;
1205                              + occupied[containerIndex][x][y]);
1206                          return false;
1207                      }
1208                  }
1209              }
1210              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1211                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1212                      occupied[containerIndex][x][y] = item;
1213                  }
1214              }
1215  
1216              return true;
1217          }
1218  
1219          private void loadWorkspace() {
1220              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1221  
1222              final Context context = mContext;
1223              final ContentResolver contentResolver = context.getContentResolver();
1224              final PackageManager manager = context.getPackageManager();
1225              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1226              final boolean isSafeMode = manager.isSafeMode();
1227  
1228              // Make sure the default workspace is loaded, if needed
1229              mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1230  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1231 -            sWorkspaceItems.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1232 -            sAppWidgets.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1233 -            sFolders.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1234 -            sItemsIdMap.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1235 -            sDbIconCache.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1236 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1237 -            final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1238 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1239 -            final Cursor c = contentResolver.query(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1240 -                    LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1241 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1242 -            // +1 for the hotseat (it can be larger than the workspace)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1243 -            // Load workspace in reverse order to ensure that latest items are loaded first (and</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1244 -            // before any earlier duplicates)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1245 -            final ItemInfo occupied[][][] =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1246 -                    new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1247 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1248 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1249 -                final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1250 -                final int intentIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1251 -                        (LauncherSettings.Favorites.INTENT);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1252 -                final int titleIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1253 -                        (LauncherSettings.Favorites.TITLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1254 -                final int iconTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1255 -                        LauncherSettings.Favorites.ICON_TYPE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1256 -                final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1257 -                final int iconPackageIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1258 -                        LauncherSettings.Favorites.ICON_PACKAGE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1259 -                final int iconResourceIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1260 -                        LauncherSettings.Favorites.ICON_RESOURCE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1261 -                final int containerIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1262 -                        LauncherSettings.Favorites.CONTAINER);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1263 -                final int itemTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1264 -                        LauncherSettings.Favorites.ITEM_TYPE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1265 -                final int appWidgetIdIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1266 -                        LauncherSettings.Favorites.APPWIDGET_ID);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1267 -                final int screenIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1268 -                        LauncherSettings.Favorites.SCREEN);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1269 -                final int cellXIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1270 -                        (LauncherSettings.Favorites.CELLX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1271 -                final int cellYIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1272 -                        (LauncherSettings.Favorites.CELLY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1273 -                final int spanXIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1274 -                        (LauncherSettings.Favorites.SPANX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1275 -                final int spanYIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1276 -                        LauncherSettings.Favorites.SPANY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1277 -                //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1278 -                //final int displayModeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1279 -                //        LauncherSettings.Favorites.DISPLAY_MODE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1280 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1281 -                ShortcutInfo info;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1282 -                String intentDescription;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1283 -                LauncherAppWidgetInfo appWidgetInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1284 -                int container;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1285 -                long id;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1286 -                Intent intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1287 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1288 -                while (!mStopped &amp;&amp; c.moveToNext()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1289 -                    try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1290 -                        int itemType = c.getInt(itemTypeIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1291 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1292 -                        switch (itemType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1293 -                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1294 -                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1295 -                            intentDescription = c.getString(intentIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1296 -                            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1297 -                                intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1298 -                            } catch (URISyntaxException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1299 -                                continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1300 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1301 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1302 -                            if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1303 -                                info = getShortcutInfo(manager, intent, context, c, iconIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1304 -                                        titleIndex, mLabelCache);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1305 -                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1306 -                                info = getShortcutInfo(c, context, iconTypeIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1307 -                                        iconPackageIndex, iconResourceIndex, iconIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1308 -                                        titleIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1309 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1310 -                                // App shortcuts that used to be automatically added to Launcher</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1311 -                                // didn&#x27;t always have the correct intent flags set, so do that here</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1312 -                                if (intent.getAction() != null &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1313 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1314 +                sBgWorkspaceItems.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1315 +                sBgAppWidgets.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1316 +                sBgFolders.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1317 +                sBgItemsIdMap.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1318 +                sBgDbIconCache.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1319 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1320 +                final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1321 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1322 +                final Cursor c = contentResolver.query(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1323 +                        LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1324 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1325 +                // +1 for the hotseat (it can be larger than the workspace)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1326 +                // Load workspace in reverse order to ensure that latest items are loaded first (and</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1327 +                // before any earlier duplicates)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1328 +                final ItemInfo occupied[][][] =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1329 +                        new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1330 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1331 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1332 +                    final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1333 +                    final int intentIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1334 +                            (LauncherSettings.Favorites.INTENT);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1335 +                    final int titleIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1336 +                            (LauncherSettings.Favorites.TITLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1337 +                    final int iconTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1338 +                            LauncherSettings.Favorites.ICON_TYPE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1339 +                    final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1340 +                    final int iconPackageIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1341 +                            LauncherSettings.Favorites.ICON_PACKAGE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1342 +                    final int iconResourceIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1343 +                            LauncherSettings.Favorites.ICON_RESOURCE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1344 +                    final int containerIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1345 +                            LauncherSettings.Favorites.CONTAINER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1346 +                    final int itemTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1347 +                            LauncherSettings.Favorites.ITEM_TYPE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1348 +                    final int appWidgetIdIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1349 +                            LauncherSettings.Favorites.APPWIDGET_ID);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1350 +                    final int screenIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1351 +                            LauncherSettings.Favorites.SCREEN);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1352 +                    final int cellXIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1353 +                            (LauncherSettings.Favorites.CELLX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1354 +                    final int cellYIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1355 +                            (LauncherSettings.Favorites.CELLY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1356 +                    final int spanXIndex = c.getColumnIndexOrThrow</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1357 +                            (LauncherSettings.Favorites.SPANX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1358 +                    final int spanYIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1359 +                            LauncherSettings.Favorites.SPANY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1360 +                    //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1361 +                    //final int displayModeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1362 +                    //        LauncherSettings.Favorites.DISPLAY_MODE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1363 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1364 +                    ShortcutInfo info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1365 +                    String intentDescription;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1366 +                    LauncherAppWidgetInfo appWidgetInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1367 +                    int container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1368 +                    long id;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1369 +                    Intent intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1370 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1371 +                    while (!mStopped &amp;&amp; c.moveToNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1372 +                        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1373 +                            int itemType = c.getInt(itemTypeIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1374 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1375 +                            switch (itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1376 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1377 +                            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1378 +                                intentDescription = c.getString(intentIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1379 +                                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1380 +                                    intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1381 +                                } catch (URISyntaxException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1382 +                                    continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1383 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1384 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1385 +                                if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1386 +                                    info = getShortcutInfo(manager, intent, context, c, iconIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1387 +                                            titleIndex, mLabelCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1388 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1389 +                                    info = getShortcutInfo(c, context, iconTypeIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1390 +                                            iconPackageIndex, iconResourceIndex, iconIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1391 +                                            titleIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1392 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1393 +                                    // App shortcuts that used to be automatically added to Launcher</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1394 +                                    // didn&#x27;t always have the correct intent flags set, so do that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1395 +                                    // here</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1396 +                                    if (intent.getAction() != null &amp;&amp;</span>
1397                                          intent.getCategories() != null &amp;&amp;
1398                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1399                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1400 -                                    intent.addFlags(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1401 -                                        Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1402 -                                        Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1403 +                                        intent.addFlags(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1404 +                                            Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1405 +                                            Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1406 +                                    }</span>
1407                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1408 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1409 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1410 -                            if (info != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1411 -                                info.intent = intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1412 -                                info.id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1413 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1414 +                                if (info != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1415 +                                    info.intent = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1416 +                                    info.id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1417 +                                    container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1418 +                                    info.container = container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1419 +                                    info.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1420 +                                    info.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1421 +                                    info.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1422 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1423 +                                    // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1424 +                                    if (!checkItemPlacement(occupied, info)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1425 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1426 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1427 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1428 +                                    switch (container) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1429 +                                    case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1430 +                                    case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1431 +                                        sBgWorkspaceItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1432 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1433 +                                    default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1434 +                                        // Item is in a user folder</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1435 +                                        FolderInfo folderInfo =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1436 +                                                findOrMakeFolder(sBgFolders, container);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1437 +                                        folderInfo.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1438 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1439 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1440 +                                    sBgItemsIdMap.put(info.id, info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1441 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1442 +                                    // now that we&#x27;ve loaded everthing re-save it with the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1443 +                                    // icon in case it disappears somehow.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1444 +                                    queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1445 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1446 +                                    // Failed to load the shortcut, probably because the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1447 +                                    // activity manager couldn&#x27;t resolve it (maybe the app</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1448 +                                    // was uninstalled), or the db row was somehow screwed up.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1449 +                                    // Delete it.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1450 +                                    id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1451 +                                    Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1452 +                                    contentResolver.delete(LauncherSettings.Favorites.getContentUri(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1453 +                                                id, false), null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1454 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1455 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1456 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1457 +                            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1458 +                                id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1459 +                                FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1460 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1461 +                                folderInfo.title = c.getString(titleIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1462 +                                folderInfo.id = id;</span>
1463                                  container = c.getInt(containerIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1464 -                                info.container = container;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1465 -                                info.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1466 -                                info.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1467 -                                info.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1468 +                                folderInfo.container = container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1469 +                                folderInfo.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1470 +                                folderInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1471 +                                folderInfo.cellY = c.getInt(cellYIndex);</span>
1472  
1473                                  // check &amp; update map of what&#x27;s occupied
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1474 -                                if (!checkItemPlacement(occupied, info)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1475 +                                if (!checkItemPlacement(occupied, folderInfo)) {</span>
1476                                      break;
1477                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1478 -</span>
1479                                  switch (container) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1480 -                                case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1481 -                                case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1482 -                                    sWorkspaceItems.add(info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1483 -                                    break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1484 -                                default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1485 -                                    // Item is in a user folder</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1486 -                                    FolderInfo folderInfo =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1487 -                                            findOrMakeFolder(sFolders, container);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1488 -                                    folderInfo.add(info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1489 -                                    break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1490 +                                    case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1491 +                                    case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1492 +                                        sBgWorkspaceItems.add(folderInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1493 +                                        break;</span>
1494                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1495 -                                sItemsIdMap.put(info.id, info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1496 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1497 -                                // now that we&#x27;ve loaded everthing re-save it with the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1498 -                                // icon in case it disappears somehow.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1499 -                                queueIconToBeChecked(sDbIconCache, info, c, iconIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1500 -                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1501 -                                // Failed to load the shortcut, probably because the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1502 -                                // activity manager couldn&#x27;t resolve it (maybe the app</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1503 -                                // was uninstalled), or the db row was somehow screwed up.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1504 -                                // Delete it.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1505 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1506 +                                sBgItemsIdMap.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1507 +                                sBgFolders.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1508 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1509 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1510 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1511 +                                // Read all Launcher-specific widget details</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1512 +                                int appWidgetId = c.getInt(appWidgetIdIndex);</span>
1513                                  id = c.getLong(idIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1514 -                                Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1515 -                                contentResolver.delete(LauncherSettings.Favorites.getContentUri(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1516 -                                            id, false), null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1517 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1518 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1519 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1520 -                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1521 -                            id = c.getLong(idIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1522 -                            FolderInfo folderInfo = findOrMakeFolder(sFolders, id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1523 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1524 -                            folderInfo.title = c.getString(titleIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1525 -                            folderInfo.id = id;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1526 -                            container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1527 -                            folderInfo.container = container;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1528 -                            folderInfo.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1529 -                            folderInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1530 -                            folderInfo.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1531 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1532 -                            // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1533 -                            if (!checkItemPlacement(occupied, folderInfo)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1534 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1535 +                                final AppWidgetProviderInfo provider =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1536 +                                        widgets.getAppWidgetInfo(appWidgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1537 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1538 +                                if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1539 +                                        provider.provider.getPackageName() == null)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1540 +                                    String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1541 +                                        + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1542 +                                    Log.e(TAG, log);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1543 +                                    Launcher.sDumpLogs.add(log);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1544 +                                    itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1545 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1546 +                                    appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1547 +                                            provider.provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1548 +                                    appWidgetInfo.id = id;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1549 +                                    appWidgetInfo.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1550 +                                    appWidgetInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1551 +                                    appWidgetInfo.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1552 +                                    appWidgetInfo.spanX = c.getInt(spanXIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1553 +                                    appWidgetInfo.spanY = c.getInt(spanYIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1554 +                                    int[] minSpan = Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1555 +                                    appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1556 +                                    appWidgetInfo.minSpanY = minSpan[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1557 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1558 +                                    container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1559 +                                    if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1560 +                                        container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1561 +                                        Log.e(TAG, &quot;Widget found where container != &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1562 +                                            &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1563 +                                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1564 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1565 +                                    appWidgetInfo.container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1566 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1567 +                                    // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1568 +                                    if (!checkItemPlacement(occupied, appWidgetInfo)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1569 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1570 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1571 +                                    sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1572 +                                    sBgAppWidgets.add(appWidgetInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1573 +                                }</span>
1574                                  break;
1575                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1576 -                            switch (container) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1577 -                                case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1578 -                                case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1579 -                                    sWorkspaceItems.add(folderInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1580 -                                    break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1581 +                        } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1582 +                            Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1583 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1584 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1585 +                } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1586 +                    c.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1587 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1588 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1589 +                if (itemsToRemove.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1590 +                    ContentProviderClient client = contentResolver.acquireContentProviderClient(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1591 +                                    LauncherSettings.Favorites.CONTENT_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1592 +                    // Remove dead items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1593 +                    for (long id : itemsToRemove) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1594 +                        if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1595 +                            Log.d(TAG, &quot;Removed id = &quot; + id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1596 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1597 +                        // Don&#x27;t notify content observers</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1598 +                        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1599 +                            client.delete(LauncherSettings.Favorites.getContentUri(id, false),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1600 +                                    null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1601 +                        } catch (RemoteException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1602 +                            Log.w(TAG, &quot;Could not remove id = &quot; + id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1603 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1604 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1605 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1606 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1607 +                if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1608 +                    Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1609 +                    Log.d(TAG, &quot;workspace layout: &quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1610 +                    for (int y = 0; y &lt; mCellCountY; y++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1611 +                        String line = &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1612 +                        for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1613 +                            if (s &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1614 +                                line += &quot; | &quot;;</span>
1615                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1616 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1617 -                            sItemsIdMap.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1618 -                            sFolders.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1619 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1620 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1621 -                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1622 -                            // Read all Launcher-specific widget details</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1623 -                            int appWidgetId = c.getInt(appWidgetIdIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1624 -                            id = c.getLong(idIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1625 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1626 -                            final AppWidgetProviderInfo provider =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1627 -                                    widgets.getAppWidgetInfo(appWidgetId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1628 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1629 -                            if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1630 -                                    provider.provider.getPackageName() == null)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1631 -                                String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1632 -                                    + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1633 -                                Log.e(TAG, log);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1634 -                                Launcher.sDumpLogs.add(log);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1635 -                                itemsToRemove.add(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1636 -                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1637 -                                appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1638 -                                        provider.provider);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1639 -                                appWidgetInfo.id = id;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1640 -                                appWidgetInfo.screen = c.getInt(screenIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1641 -                                appWidgetInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1642 -                                appWidgetInfo.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1643 -                                appWidgetInfo.spanX = c.getInt(spanXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1644 -                                appWidgetInfo.spanY = c.getInt(spanYIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1645 -                                int[] minSpan = Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1646 -                                appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1647 -                                appWidgetInfo.minSpanY = minSpan[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1648 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1649 -                                container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1650 -                                if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1651 -                                    container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1652 -                                    Log.e(TAG, &quot;Widget found where container &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1653 -                                        + &quot;!= CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1654 -                                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1655 -                                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1656 -                                appWidgetInfo.container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1657 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1658 -                                // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1659 -                                if (!checkItemPlacement(occupied, appWidgetInfo)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1660 -                                    break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1661 -                                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1662 -                                sItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1663 -                                sAppWidgets.add(appWidgetInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1664 +                            for (int x = 0; x &lt; mCellCountX; x++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1665 +                                line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);</span>
1666                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1667 -                            break;</span>
1668                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1669 -                    } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1670 -                        Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1671 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1672 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1673 -            } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1674 -                c.close();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1675 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1676 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1677 -            if (itemsToRemove.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1678 -                ContentProviderClient client = contentResolver.acquireContentProviderClient(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1679 -                                LauncherSettings.Favorites.CONTENT_URI);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1680 -                // Remove dead items</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1681 -                for (long id : itemsToRemove) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1682 -                    if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1683 -                        Log.d(TAG, &quot;Removed id = &quot; + id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1684 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1685 -                    // Don&#x27;t notify content observers</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1686 -                    try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1687 -                        client.delete(LauncherSettings.Favorites.getContentUri(id, false),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1688 -                                null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1689 -                    } catch (RemoteException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1690 -                        Log.w(TAG, &quot;Could not remove id = &quot; + id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1691 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1692 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1693 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1694 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1695 -            if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1696 -                Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1697 -                Log.d(TAG, &quot;workspace layout: &quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1698 -                for (int y = 0; y &lt; mCellCountY; y++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1699 -                    String line = &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1700 -                    for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1701 -                        if (s &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1702 -                            line += &quot; | &quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1703 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1704 -                        for (int x = 0; x &lt; mCellCountX; x++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1705 -                            line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1706 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1707 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1708 -                    Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1709 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1710 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1711 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1712 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1713 -        /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1714 -         * Read everything out of our database.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1715 -         */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1716 -        private void bindWorkspace() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1717 -            final long t = SystemClock.uptimeMillis();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1718 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1719 -            // Don&#x27;t use these two variables in any of the callback runnables.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1720 -            // Otherwise we hold a reference to them.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1721 -            final Callbacks oldCallbacks = mCallbacks.get();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1722 -            if (oldCallbacks == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1723 -                // This launcher has exited and nobody bothered to tell us.  Just bail.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1724 -                Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1725 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1726 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1727 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1728 -            // Get the list of workspace items to load and unbind the existing ShortcutInfos</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1729 -            // before we call startBinding() below.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1730 -            final int currentScreen = oldCallbacks.getCurrentWorkspaceScreen();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1731 -            final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = unbindWorkspaceItemsOnMainThread();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1732 -            // Order the items for loading as follows: current workspace, hotseat, everything else</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1733 -            Collections.sort(tmpWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1734 +                        Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1735 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1736 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1737 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1738 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1739 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1740 +        /** Filters the set of items who are directly or indirectly (via another container) on the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1741 +         * specified screen. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1742 +        private void filterCurrentWorkspaceItems(int currentScreen,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1743 +                ArrayList&lt;ItemInfo&gt; allWorkspaceItems,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1744 +                ArrayList&lt;ItemInfo&gt; currentScreenItems,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1745 +                ArrayList&lt;ItemInfo&gt; otherScreenItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1746 +            // Purge any null ItemInfos</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1747 +            Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1748 +            while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1749 +                ItemInfo i = iter.next();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1750 +                if (i == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1751 +                    iter.remove();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1752 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1753 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1754 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1755 +            // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1756 +            // items given.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1757 +            if (currentScreen &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1758 +                currentScreenItems.addAll(allWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1759 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1760 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1761 +            // Order the set of items by their containers first, this allows use to walk through the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1762 +            // list sequentially, build up a list of containers that are in the specified screen,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1763 +            // as well as all items in those containers.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1764 +            Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1765 +            Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1766 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1767 +                public int compare(ItemInfo lhs, ItemInfo rhs) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1768 +                    return (int) (lhs.container - rhs.container);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1769 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1770 +            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1771 +            for (ItemInfo info : allWorkspaceItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1772 +                if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1773 +                    if (info.screen == currentScreen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1774 +                        currentScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1775 +                        itemsOnScreen.add(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1776 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1777 +                        otherScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1778 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1779 +                } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1780 +                    currentScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1781 +                    itemsOnScreen.add(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1782 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1783 +                    if (itemsOnScreen.contains(info.container)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1784 +                        currentScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1785 +                        itemsOnScreen.add(info.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1786 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1787 +                        otherScreenItems.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1788 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1789 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1790 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1791 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1792 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1793 +        /** Filters the set of widgets which are on the specified screen. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1794 +        private void filterCurrentAppWidgets(int currentScreen,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1795 +                ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1796 +                ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1797 +                ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1798 +            // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1799 +            // widgets given.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1800 +            if (currentScreen &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1801 +                currentScreenWidgets.addAll(appWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1802 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1803 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1804 +            for (LauncherAppWidgetInfo widget : appWidgets) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1805 +                if (widget == null) continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1806 +                if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1807 +                        widget.screen == currentScreen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1808 +                    currentScreenWidgets.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1809 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1810 +                    otherScreenWidgets.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1811 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1812 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1813 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1814 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1815 +        /** Filters the set of folders which are on the specified screen. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1816 +        private void filterCurrentFolders(int currentScreen,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1817 +                HashMap&lt;Long, ItemInfo&gt; itemsIdMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1818 +                HashMap&lt;Long, FolderInfo&gt; folders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1819 +                HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1820 +                HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1821 +            // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1822 +            // widgets given.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1823 +            if (currentScreen &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1824 +                currentScreenFolders.putAll(folders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1825 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1826 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1827 +            for (long id : folders.keySet()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1828 +                ItemInfo info = itemsIdMap.get(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1829 +                FolderInfo folder = folders.get(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1830 +                if (info == null || folder == null) continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1831 +                if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1832 +                        info.screen == currentScreen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1833 +                    currentScreenFolders.put(id, folder);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1834 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1835 +                    otherScreenFolders.put(id, folder);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1836 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1837 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1838 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1839 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1840 +        /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1841 +         * right) */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1842 +        private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1843 +            // XXX: review this</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1844 +            Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {</span>
1845                  @Override
1846                  public int compare(ItemInfo lhs, ItemInfo rhs) {
1847                      int cellCountX = LauncherModel.getCellCountX();
1848                      int cellCountY = LauncherModel.getCellCountY();
1849                      int screenOffset = cellCountX * cellCountY;
1850                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1851                      long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1852                              lhs.cellY * cellCountX + lhs.cellX);
1853                      long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1854                              rhs.cellY * cellCountX + rhs.cellX);
1855                      return (int) (lr - rr);
1856                  }
1857              });
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1858 -            // Precondition: the items are ordered by page, screen</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1859 -            final ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1860 -            for (ItemInfo ii : tmpWorkspaceItems) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1861 -                // Prepend the current items, hotseat items, append everything else</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1862 -                if (ii.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1863 -                        ii.screen == currentScreen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1864 -                    workspaceItems.add(0, ii);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1865 -                } else if (ii.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1866 -                    workspaceItems.add(0, ii);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1867 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1868 -                    workspaceItems.add(ii);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1869 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1870 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1871 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1872 -            // Tell the workspace that we&#x27;re about to start firing items at it</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1873 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1874 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1875 -                    Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1876 -                    if (callbacks != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1877 -                        callbacks.startBinding();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1878 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1879 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1880 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1881 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1882 -            // Add the items to the workspace.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1883 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1884 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1885 +        private void bindWorkspaceItems(final Callbacks oldCallbacks,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1886 +                final ArrayList&lt;ItemInfo&gt; workspaceItems,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1887 +                final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1888 +                final HashMap&lt;Long, FolderInfo&gt; folders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1889 +                ArrayList&lt;Runnable&gt; deferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1890 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1891 +            final boolean postOnMainThread = (deferredBindRunnables != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1892 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1893 +            // Bind the workspace items</span>
1894              int N = workspaceItems.size();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1895 -            for (int i=0; i&lt;N; i+=ITEMS_CHUNK) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1896 +            for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {</span>
1897                  final int start = i;
1898                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1899 -                mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1900 +                final Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1901 +                    @Override</span>
1902                      public void run() {
1903                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1904                          if (callbacks != null) {
1905                              callbacks.bindItems(workspaceItems, start, start+chunkSize);
1906                          }
1907                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1908 -                });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1909 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1910 -            // Ensure that we don&#x27;t use the same folders data structure on the main thread</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1911 -            final HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;(sFolders);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1912 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1913 +                };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1914 +                if (postOnMainThread) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1915 +                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1916 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1917 +                    runOnMainThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1918 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1919 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1920 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1921 +            // Bind the folders</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1922 +            if (!folders.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1923 +                final Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1924 +                    public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1925 +                        Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1926 +                        if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1927 +                            callbacks.bindFolders(folders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1928 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1929 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1930 +                };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1931 +                if (postOnMainThread) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1932 +                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1933 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1934 +                    runOnMainThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1935 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1936 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1937 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1938 +            // Bind the widgets, one at a time</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1939 +            N = appWidgets.size();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1940 +            for (int i = 0; i &lt; N; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1941 +                final LauncherAppWidgetInfo widget = appWidgets.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1942 +                final Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1943 +                    public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1944 +                        Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1945 +                        if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1946 +                            callbacks.bindAppWidget(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1947 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1948 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1949 +                };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1950 +                if (postOnMainThread) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1951 +                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1952 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1953 +                    runOnMainThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1954 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1955 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1956 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1957 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1958 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1959 +         * Binds all loaded data to actual views on the main thread.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1960 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1961 +        private void bindWorkspace(int synchronizeBindPage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1962 +            final long t = SystemClock.uptimeMillis();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1963 +            Runnable r;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1964 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1965 +            // Don&#x27;t use these two variables in any of the callback runnables.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1966 +            // Otherwise we hold a reference to them.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1967 +            final Callbacks oldCallbacks = mCallbacks.get();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1968 +            if (oldCallbacks == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1969 +                // This launcher has exited and nobody bothered to tell us.  Just bail.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1970 +                Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1971 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1972 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1973 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1974 +            final int currentScreen = (synchronizeBindPage &gt; -1) ? synchronizeBindPage :</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1975 +                oldCallbacks.getCurrentWorkspaceScreen();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1976 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1977 +            // Load all the items that are on the current page first (and in the process, unbind</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1978 +            // all the existing workspace items before we call startBinding() below.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1979 +            unbindWorkspaceItemsOnMainThread();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1980 +            ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1981 +            ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1982 +                    new ArrayList&lt;LauncherAppWidgetInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1983 +            HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1984 +            HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1985 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1986 +                workspaceItems.addAll(sBgWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1987 +                appWidgets.addAll(sBgAppWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1988 +                folders.putAll(sBgFolders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1989 +                itemsIdMap.putAll(sBgItemsIdMap);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1990 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1991 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1992 +            ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1993 +            ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1994 +            ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1995 +                    new ArrayList&lt;LauncherAppWidgetInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1996 +            ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1997 +                    new ArrayList&lt;LauncherAppWidgetInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1998 +            HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1999 +            HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2000 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2001 +            // Separate the items that are on the current screen, and all the other remaining items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2002 +            filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2003 +                    otherWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2004 +            filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2005 +                    otherAppWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2006 +            filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2007 +                    otherFolders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2008 +            sortWorkspaceItemsSpatially(currentWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2009 +            sortWorkspaceItemsSpatially(otherWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2010 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2011 +            // Tell the workspace that we&#x27;re about to start binding items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2012 +            r = new Runnable() {</span>
2013                  public void run() {
2014                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2015                      if (callbacks != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2016 -                        callbacks.bindFolders(folders);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2017 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2018 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2019 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2020 -            // Wait until the queue goes empty.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2021 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2022 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2023 -                    if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2024 -                        Log.d(TAG, &quot;Going to start binding widgets soon.&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2025 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2026 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2027 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2028 -            // Bind the widgets, one at a time.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2029 -            // WARNING: this is calling into the workspace from the background thread,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2030 -            // but since getCurrentScreen() just returns the int, we should be okay.  This</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2031 -            // is just a hint for the order, and if it&#x27;s wrong, we&#x27;ll be okay.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2032 -            // TODO: instead, we should have that push the current screen into here.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2033 -            N = sAppWidgets.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2034 -            // once for the current screen</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2035 -            for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2036 -                final LauncherAppWidgetInfo widget = sAppWidgets.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2037 -                if (widget.screen == currentScreen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2038 -                    mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2039 -                        public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2040 -                            Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2041 -                            if (callbacks != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2042 -                                callbacks.bindAppWidget(widget);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2043 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2044 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2045 -                    });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2046 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2047 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2048 -            // once for the other screens</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2049 -            for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2050 -                final LauncherAppWidgetInfo widget = sAppWidgets.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2051 -                if (widget.screen != currentScreen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2052 -                    mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2053 -                        public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2054 -                            Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2055 -                            if (callbacks != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2056 -                                callbacks.bindAppWidget(widget);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2057 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2058 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2059 -                    });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2060 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2061 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2062 -            // Tell the workspace that we&#x27;re done.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2063 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2064 +                        callbacks.startBinding();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2065 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2066 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2067 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2068 +            runOnMainThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2069 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2070 +            // Load items on the current page</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2071 +            bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2072 +                    currentFolders, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2073 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2074 +            // Load all the remaining pages</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2075 +            mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2076 +            bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2077 +                    mDeferredBindRunnables);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2078 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2079 +            // Tell the workspace that we&#x27;re done binding items</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2080 +            r = new Runnable() {</span>
2081                  public void run() {
2082                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2083                      if (callbacks != null) {
2084                          callbacks.finishBindingItems();
2085                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2086 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2087 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2088 -            // Cleanup</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2089 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2090 -                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2091 +</span>
2092                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2093                      if (DEBUG_LOADERS) {
2094                          Log.d(TAG, &quot;bound workspace in &quot;
2095                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2096                      }
2097  
2098                      mIsLoadingAndBindingWorkspace = false;
2099                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2100 -            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2101 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2102 +            mDeferredBindRunnables.add(r);</span>
2103          }
2104  
2105          private void loadAndBindAllApps() {
2106              if (DEBUG_LOADERS) {
2107                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2108              }
2109              if (!mAllAppsLoaded) {
2110                  loadAllAppsByBatch();
2111                  synchronized (LoaderTask.this) {
2112                      if (mStopped) {
2113                          return;
2114                      }
2115                      mAllAppsLoaded = true;
2116                  }
2117              } else {
2118                  onlyBindAllApps();
2119              }
2120          }
2121  
2122          private void onlyBindAllApps() {
2123              final Callbacks oldCallbacks = mCallbacks.get();
2124              if (oldCallbacks == null) {
2125                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2126                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2127                  return;
2128              }
2129  
2130              // shallow copy
2131              @SuppressWarnings(&quot;unchecked&quot;)
2132              final ArrayList&lt;ApplicationInfo&gt; list
2133                      = (ArrayList&lt;ApplicationInfo&gt;) mAllAppsList.data.clone();

2134              mHandler.post(new Runnable() {
2135                  public void run() {
2136                      final long t = SystemClock.uptimeMillis();
2137                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2138                      if (callbacks != null) {
2139                          callbacks.bindAllApplications(list);
2140                      }
2141                      if (DEBUG_LOADERS) {
2142                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2143                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2144                      }
2145                  }
2146              });
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2147 -</span>
2148          }
2149  
2150          private void loadAllAppsByBatch() {
2151              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2152  
2153              // Don&#x27;t use these two variables in any of the callback runnables.
2154              // Otherwise we hold a reference to them.
2155              final Callbacks oldCallbacks = mCallbacks.get();
2156              if (oldCallbacks == null) {
2157                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2158                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
2159                  return;
2160              }
2161  
2162              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2163              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2164  
2165              final PackageManager packageManager = mContext.getPackageManager();
2166              List&lt;ResolveInfo&gt; apps = null;
2167  
2168              int N = Integer.MAX_VALUE;
2169  
2170              int startIndex;
2171              int i=0;
2172              int batchSize = -1;
2173              while (i &lt; N &amp;&amp; !mStopped) {
2174                  if (i == 0) {
2175                      mAllAppsList.clear();

2176                      final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2177                      apps = packageManager.queryIntentActivities(mainIntent, 0);
2178                      if (DEBUG_LOADERS) {
2179                          Log.d(TAG, &quot;queryIntentActivities took &quot;
2180                                  + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
2181                      }
2182                      if (apps == null) {
2183                          return;
2184                      }
2185                      N = apps.size();
2186                      if (DEBUG_LOADERS) {
2187                          Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
2188                      }
2189                      if (N == 0) {
2190                          // There are no apps?!?
2191                          return;
2192                      }
2193                      if (mBatchSize == 0) {
2194                          batchSize = N;
2195                      } else {
2196                          batchSize = mBatchSize;
2197                      }
2198  
2199                      final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2200                      Collections.sort(apps,
2201                              new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
2202                      if (DEBUG_LOADERS) {
2203                          Log.d(TAG, &quot;sort took &quot;
2204                                  + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2205                      }
2206                  }
2207  
2208                  final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2209  
2210                  startIndex = i;
2211                  for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
2212                      // This builds the icon bitmaps.
2213                      mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),

2214                              mIconCache, mLabelCache));
2215                      i++;
2216                  }
2217  
2218                  final boolean first = i &lt;= batchSize;
2219                  final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2220                  final ArrayList&lt;ApplicationInfo&gt; added = mAllAppsList.added;
2221                  mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();


2222  
2223                  mHandler.post(new Runnable() {
2224                      public void run() {
2225                          final long t = SystemClock.uptimeMillis();
2226                          if (callbacks != null) {
2227                              if (first) {
2228                                  callbacks.bindAllApplications(added);
2229                              } else {
2230                                  callbacks.bindAppsAdded(added);
2231                              }
2232                              if (DEBUG_LOADERS) {
2233                                  Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2234                                      + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
2235                              }
2236                          } else {
2237                              Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2238                          }
2239                      }
2240                  });
2241  
2242                  if (DEBUG_LOADERS) {
2243                      Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
2244                              + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
2245                  }
2246  
2247                  if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
2248                      try {
2249                          if (DEBUG_LOADERS) {
2250                              Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
2251                          }
2252                          Thread.sleep(mAllAppsLoadDelay);
2253                      } catch (InterruptedException exc) { }
2254                  }
2255              }
2256  
2257              if (DEBUG_LOADERS) {
2258                  Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
2259                          + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
2260                          + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
2261              }
2262          }
2263  
2264          public void dumpState() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2265 -            Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2266 -            Log.d(TAG, &quot;mLoaderTask.mWaitThread=&quot; + mWaitThread);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2267 -            Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2268 -            Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2269 -            Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2270 -            Log.d(TAG, &quot;mItems size=&quot; + sWorkspaceItems.size());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2271 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2272 +                Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2273 +                Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2274 +                Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2275 +                Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2276 +                Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2277 +            }</span>
2278          }
2279      }
2280  
2281      void enqueuePackageUpdated(PackageUpdatedTask task) {
2282          sWorker.post(task);
2283      }
2284  
2285      private class PackageUpdatedTask implements Runnable {
2286          int mOp;
2287          String[] mPackages;
2288  
2289          public static final int OP_NONE = 0;
2290          public static final int OP_ADD = 1;
2291          public static final int OP_UPDATE = 2;
2292          public static final int OP_REMOVE = 3; // uninstlled
2293          public static final int OP_UNAVAILABLE = 4; // external media unmounted
2294  
2295  
2296          public PackageUpdatedTask(int op, String[] packages) {
2297              mOp = op;
2298              mPackages = packages;
2299          }
2300  
2301          public void run() {
2302              final Context context = mApp;
2303  
2304              final String[] packages = mPackages;
2305              final int N = packages.length;
2306              switch (mOp) {
2307                  case OP_ADD:
2308                      for (int i=0; i&lt;N; i++) {
2309                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2310                          mAllAppsList.addPackage(context, packages[i]);

2311                      }
2312                      break;
2313                  case OP_UPDATE:
2314                      for (int i=0; i&lt;N; i++) {
2315                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2316                          mAllAppsList.updatePackage(context, packages[i]);

2317                      }
2318                      break;
2319                  case OP_REMOVE:
2320                  case OP_UNAVAILABLE:
2321                      for (int i=0; i&lt;N; i++) {
2322                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2323                          mAllAppsList.removePackage(packages[i]);

2324                      }
2325                      break;
2326              }
2327  
2328              ArrayList&lt;ApplicationInfo&gt; added = null;
2329              ArrayList&lt;ApplicationInfo&gt; removed = null;
2330              ArrayList&lt;ApplicationInfo&gt; modified = null;
2331  
2332              if (mAllAppsList.added.size() &gt; 0) {
2333                  added = mAllAppsList.added;
2334                  mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();
2335              }
2336              if (mAllAppsList.removed.size() &gt; 0) {
2337                  removed = mAllAppsList.removed;
2338                  mAllAppsList.removed = new ArrayList&lt;ApplicationInfo&gt;();
2339                  for (ApplicationInfo info: removed) {
2340                      mIconCache.remove(info.intent.getComponent());
2341                  }
2342              }
2343              if (mAllAppsList.modified.size() &gt; 0) {
2344                  modified = mAllAppsList.modified;
2345                  mAllAppsList.modified = new ArrayList&lt;ApplicationInfo&gt;();


















2346              }
2347  
2348              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2349              if (callbacks == null) {
2350                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2351                  return;
2352              }
2353  
2354              if (added != null) {
2355                  final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
2356                  mHandler.post(new Runnable() {
2357                      public void run() {
2358                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2359                          if (callbacks == cb &amp;&amp; cb != null) {
2360                              callbacks.bindAppsAdded(addedFinal);
2361                          }
2362                      }
2363                  });
2364              }
2365              if (modified != null) {
2366                  final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
2367                  mHandler.post(new Runnable() {
2368                      public void run() {
2369                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2370                          if (callbacks == cb &amp;&amp; cb != null) {
2371                              callbacks.bindAppsUpdated(modifiedFinal);
2372                          }
2373                      }
2374                  });
2375              }
2376              if (removed != null) {

2377                  final boolean permanent = mOp != OP_UNAVAILABLE;
2378                  final ArrayList&lt;ApplicationInfo&gt; removedFinal = removed;
2379                  mHandler.post(new Runnable() {
2380                      public void run() {
2381                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2382                          if (callbacks == cb &amp;&amp; cb != null) {
2383                              callbacks.bindAppsRemoved(removedFinal, permanent);

2384                          }
2385                      }
2386                  });
2387              }
2388  
2389              mHandler.post(new Runnable() {
2390                  @Override
2391                  public void run() {
2392                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2393                      if (callbacks == cb &amp;&amp; cb != null) {
2394                          callbacks.bindPackagesUpdated();
2395                      }
2396                  }
2397              });
2398          }
2399      }
2400  
2401      /**
2402       * Returns all the Workspace ShortcutInfos associated with a particular package.
2403       * @param intent
2404       * @return
2405       */
2406      ArrayList&lt;ShortcutInfo&gt; getShortcutInfosForPackage(String packageName) {
2407          ArrayList&lt;ShortcutInfo&gt; infos = new ArrayList&lt;ShortcutInfo&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2408 -        for (ItemInfo i : sWorkspaceItems) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2409 -            if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2410 -                ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2411 -                if (packageName.equals(info.getPackageName())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2412 -                    infos.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2413 +        synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2414 +            for (ItemInfo i : sBgWorkspaceItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2415 +                if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2416 +                    ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2417 +                    if (packageName.equals(info.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2418 +                        infos.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2419 +                    }</span>
2420                  }
2421              }
2422          }
2423          return infos;
2424      }
2425  
2426      /**
2427       * This is called from the code that adds shortcuts from the intent receiver.  This
2428       * doesn&#x27;t have a Cursor, but
2429       */
2430      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2431          return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2432      }
2433  
2434      /**
2435       * Make an ShortcutInfo object for a shortcut that is an application.
2436       *
2437       * If c is not null, then it will be used to fill in missing data like the title and icon.
2438       */
2439      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2440              Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2441          Bitmap icon = null;
2442          final ShortcutInfo info = new ShortcutInfo();
2443  
2444          ComponentName componentName = intent.getComponent();
2445          if (componentName == null) {
2446              return null;
2447          }
2448  
2449          try {
2450              PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2451              if (!pi.applicationInfo.enabled) {
2452                  // If we return null here, the corresponding item will be removed from the launcher
2453                  // db and will not appear in the workspace.
2454                  return null;
2455              }
2456          } catch (NameNotFoundException e) {
2457              Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2458          }
2459  
2460          // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2461          // then return null &amp; delete this.
2462  
2463          // the resource -- This may implicitly give us back the fallback icon,
2464          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2465          // to avoid saving lots of copies of that in the database, and most apps
2466          // have icons anyway.
2467  
2468          // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2469          // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2470          // via resolveActivity().
2471          ResolveInfo resolveInfo = null;
2472          ComponentName oldComponent = intent.getComponent();
2473          Intent newIntent = new Intent(intent.getAction(), null);
2474          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2475          newIntent.setPackage(oldComponent.getPackageName());
2476          List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2477          for (ResolveInfo i : infos) {
2478              ComponentName cn = new ComponentName(i.activityInfo.packageName,
2479                      i.activityInfo.name);
2480              if (cn.equals(oldComponent)) {
2481                  resolveInfo = i;
2482              }
2483          }
2484          if (resolveInfo == null) {
2485              resolveInfo = manager.resolveActivity(intent, 0);
2486          }
2487          if (resolveInfo != null) {
2488              icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2489          }
2490          // the db
2491          if (icon == null) {
2492              if (c != null) {
2493                  icon = getIconFromCursor(c, iconIndex, context);
2494              }
2495          }
2496          // the fallback icon
2497          if (icon == null) {
2498              icon = getFallbackIcon();
2499              info.usingFallbackIcon = true;
2500          }
2501          info.setIcon(icon);
2502  
2503          // from the resource
2504          if (resolveInfo != null) {
2505              ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2506              if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2507                  info.title = labelCache.get(key);
2508              } else {
2509                  info.title = resolveInfo.activityInfo.loadLabel(manager);
2510                  if (labelCache != null) {
2511                      labelCache.put(key, info.title);
2512                  }
2513              }
2514          }
2515          // from the db
2516          if (info.title == null) {
2517              if (c != null) {
2518                  info.title =  c.getString(titleIndex);
2519              }
2520          }
2521          // fall back to the class name of the activity
2522          if (info.title == null) {
2523              info.title = componentName.getClassName();
2524          }
2525          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2526          return info;
2527      }
2528  
2529      /**
2530       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2531       */
2532      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2533              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2534              int titleIndex) {
2535  
2536          Bitmap icon = null;
2537          final ShortcutInfo info = new ShortcutInfo();
2538          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2539  
2540          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2541  
2542          info.title = c.getString(titleIndex);
2543  
2544          int iconType = c.getInt(iconTypeIndex);
2545          switch (iconType) {
2546          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2547              String packageName = c.getString(iconPackageIndex);
2548              String resourceName = c.getString(iconResourceIndex);
2549              PackageManager packageManager = context.getPackageManager();
2550              info.customIcon = false;
2551              // the resource
2552              try {
2553                  Resources resources = packageManager.getResourcesForApplication(packageName);
2554                  if (resources != null) {
2555                      final int id = resources.getIdentifier(resourceName, null, null);
2556                      icon = Utilities.createIconBitmap(
2557                              mIconCache.getFullResIcon(resources, id), context);
2558                  }
2559              } catch (Exception e) {
2560                  // drop this.  we have other places to look for icons
2561              }
2562              // the db
2563              if (icon == null) {
2564                  icon = getIconFromCursor(c, iconIndex, context);
2565              }
2566              // the fallback icon
2567              if (icon == null) {
2568                  icon = getFallbackIcon();
2569                  info.usingFallbackIcon = true;
2570              }
2571              break;
2572          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2573              icon = getIconFromCursor(c, iconIndex, context);
2574              if (icon == null) {
2575                  icon = getFallbackIcon();
2576                  info.customIcon = false;
2577                  info.usingFallbackIcon = true;
2578              } else {
2579                  info.customIcon = true;
2580              }
2581              break;
2582          default:
2583              icon = getFallbackIcon();
2584              info.usingFallbackIcon = true;
2585              info.customIcon = false;
2586              break;
2587          }
2588          info.setIcon(icon);
2589          return info;
2590      }
2591  
2592      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2593          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2594          final boolean debug = false;
2595          if (debug) {
2596              Log.d(TAG, &quot;getIconFromCursor app=&quot;
2597                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2598          }
2599          byte[] data = c.getBlob(iconIndex);
2600          try {
2601              return Utilities.createIconBitmap(
2602                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
2603          } catch (Exception e) {
2604              return null;
2605          }
2606      }
2607  
2608      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2609              int cellX, int cellY, boolean notify) {
2610          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2611          if (info == null) {
2612              return null;
2613          }
2614          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2615  
2616          return info;
2617      }
2618  
2619      /**
2620       * Attempts to find an AppWidgetProviderInfo that matches the given component.
2621       */
2622      AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2623              ComponentName component) {
2624          List&lt;AppWidgetProviderInfo&gt; widgets =
2625              AppWidgetManager.getInstance(context).getInstalledProviders();
2626          for (AppWidgetProviderInfo info : widgets) {
2627              if (info.provider.equals(component)) {
2628                  return info;
2629              }
2630          }
2631          return null;
2632      }
2633  
2634      /**
2635       * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2636       */
2637      List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2638          final PackageManager packageManager = context.getPackageManager();
2639          final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2640              new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2641  
2642          final Intent supportsIntent =
2643              new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2644          supportsIntent.setType(mimeType);
2645  
2646          // Create a set of widget configuration components that we can test against
2647          final List&lt;AppWidgetProviderInfo&gt; widgets =
2648              AppWidgetManager.getInstance(context).getInstalledProviders();
2649          final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2650              new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2651          for (AppWidgetProviderInfo info : widgets) {
2652              configurationComponentToWidget.put(info.configure, info);
2653          }
2654  
2655          // Run through each of the intents that can handle this type of clip data, and cross
2656          // reference them with the components that are actual configuration components
2657          final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2658                  PackageManager.MATCH_DEFAULT_ONLY);
2659          for (ResolveInfo info : activities) {
2660              final ActivityInfo activityInfo = info.activityInfo;
2661              final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2662                      activityInfo.name);
2663              if (configurationComponentToWidget.containsKey(infoComponent)) {
2664                  supportedConfigurationActivities.add(
2665                          new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2666                                  configurationComponentToWidget.get(infoComponent)));
2667              }
2668          }
2669          return supportedConfigurationActivities;
2670      }
2671  
2672      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2673          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2674          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2675          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2676  
2677          if (intent == null) {
2678              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2679              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2680              return null;
2681          }
2682  
2683          Bitmap icon = null;
2684          boolean customIcon = false;
2685          ShortcutIconResource iconResource = null;
2686  
2687          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2688              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2689              customIcon = true;
2690          } else {
2691              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2692              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2693                  try {
2694                      iconResource = (ShortcutIconResource) extra;
2695                      final PackageManager packageManager = context.getPackageManager();
2696                      Resources resources = packageManager.getResourcesForApplication(
2697                              iconResource.packageName);
2698                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2699                      icon = Utilities.createIconBitmap(
2700                              mIconCache.getFullResIcon(resources, id), context);
2701                  } catch (Exception e) {
2702                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2703                  }
2704              }
2705          }
2706  
2707          final ShortcutInfo info = new ShortcutInfo();
2708  
2709          if (icon == null) {
2710              if (fallbackIcon != null) {
2711                  icon = fallbackIcon;
2712              } else {
2713                  icon = getFallbackIcon();
2714                  info.usingFallbackIcon = true;
2715              }
2716          }
2717          info.setIcon(icon);
2718  
2719          info.title = name;
2720          info.intent = intent;
2721          info.customIcon = customIcon;
2722          info.iconResource = iconResource;
2723  
2724          return info;
2725      }
2726  
2727      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2728              int iconIndex) {
2729          // If apps can&#x27;t be on SD, don&#x27;t even bother.
2730          if (!mAppsCanBeOnExternalStorage) {
2731              return false;
2732          }
2733          // If this icon doesn&#x27;t have a custom icon, check to see
2734          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2735          // we&#x27;re going to show, store what we are going to show back
2736          // into the DB.  We do this so when we&#x27;re loading, if the
2737          // package manager can&#x27;t find an icon (for example because
2738          // the app is on SD) then we can use that instead.
2739          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2740              cache.put(info, c.getBlob(iconIndex));
2741              return true;
2742          }
2743          return false;
2744      }
2745      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2746          boolean needSave = false;
2747          try {
2748              if (data != null) {
2749                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2750                  Bitmap loaded = info.getIcon(mIconCache);
2751                  needSave = !saved.sameAs(loaded);
2752              } else {
2753                  needSave = true;
2754              }
2755          } catch (Exception e) {
2756              needSave = true;
2757          }
2758          if (needSave) {
2759              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2760              // This is slower than is ideal, but this only happens once
2761              // or when the app is updated with a new icon.
2762              updateItemInDatabase(context, info);
2763          }
2764      }
2765  
2766      /**
2767       * Return an existing FolderInfo object if we have encountered this ID previously,
2768       * or make a new one.
2769       */
2770      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2771          // See if a placeholder was created for us already
2772          FolderInfo folderInfo = folders.get(id);
2773          if (folderInfo == null) {
2774              // No placeholder -- create a new instance
2775              folderInfo = new FolderInfo();
2776              folders.put(id, folderInfo);
2777          }
2778          return folderInfo;
2779      }
2780  
2781      private static final Collator sCollator = Collator.getInstance();
2782      public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2783              = new Comparator&lt;ApplicationInfo&gt;() {
2784          public final int compare(ApplicationInfo a, ApplicationInfo b) {
2785              int result = sCollator.compare(a.title.toString(), b.title.toString());
2786              if (result == 0) {
2787                  result = a.componentName.compareTo(b.componentName);
2788              }
2789              return result;
2790          }
2791      };
2792      public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2793              = new Comparator&lt;ApplicationInfo&gt;() {
2794          public final int compare(ApplicationInfo a, ApplicationInfo b) {
2795              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2796              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2797              return 0;
2798          }
2799      };
2800      public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2801              = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2802          public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2803              return sCollator.compare(a.label.toString(), b.label.toString());
2804          }
2805      };
2806      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2807          if (info.activityInfo != null) {
2808              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2809          } else {
2810              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2811          }
2812      }
2813      public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2814          private PackageManager mPackageManager;
2815          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2816          ShortcutNameComparator(PackageManager pm) {
2817              mPackageManager = pm;
2818              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2819          }
2820          ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2821              mPackageManager = pm;
2822              mLabelCache = labelCache;
2823          }
2824          public final int compare(ResolveInfo a, ResolveInfo b) {
2825              CharSequence labelA, labelB;
2826              ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2827              ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2828              if (mLabelCache.containsKey(keyA)) {
2829                  labelA = mLabelCache.get(keyA);
2830              } else {
2831                  labelA = a.loadLabel(mPackageManager).toString();
2832  
2833                  mLabelCache.put(keyA, labelA);
2834              }
2835              if (mLabelCache.containsKey(keyB)) {
2836                  labelB = mLabelCache.get(keyB);
2837              } else {
2838                  labelB = b.loadLabel(mPackageManager).toString();
2839  
2840                  mLabelCache.put(keyB, labelB);
2841              }
2842              return sCollator.compare(labelA, labelB);
2843          }
2844      };
2845      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2846          private PackageManager mPackageManager;
2847          private HashMap&lt;Object, String&gt; mLabelCache;
2848          WidgetAndShortcutNameComparator(PackageManager pm) {
2849              mPackageManager = pm;
2850              mLabelCache = new HashMap&lt;Object, String&gt;();
2851          }
2852          public final int compare(Object a, Object b) {
2853              String labelA, labelB;
2854              if (mLabelCache.containsKey(a)) {
2855                  labelA = mLabelCache.get(a);
2856              } else {
2857                  labelA = (a instanceof AppWidgetProviderInfo) ?
2858                      ((AppWidgetProviderInfo) a).label :
2859                      ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2860                  mLabelCache.put(a, labelA);
2861              }
2862              if (mLabelCache.containsKey(b)) {
2863                  labelB = mLabelCache.get(b);
2864              } else {
2865                  labelB = (b instanceof AppWidgetProviderInfo) ?
2866                      ((AppWidgetProviderInfo) b).label :
2867                      ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2868                  mLabelCache.put(b, labelB);
2869              }
2870              return sCollator.compare(labelA, labelB);
2871          }
2872      };
2873  
2874      public void dumpState() {
2875          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
2876          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mAllAppsList.data);
2877          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mAllAppsList.added);
2878          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mAllAppsList.removed);
2879          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mAllAppsList.modified);




2880          if (mLoaderTask != null) {
2881              mLoaderTask.dumpState();
2882          } else {
2883              Log.d(TAG, &quot;mLoaderTask=null&quot;);
2884          }
2885      }
2886  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            