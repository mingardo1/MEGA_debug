<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>605 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.StreamQueryConfig;\n&#x27;
                           &#x27;import org.apache.flink.table.api.Table;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.TableEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.java.StreamTableEnvironment;\n&#x27;
                           &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                .setJarUrlList(jarUrlList)\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                .setJarUrlList(jarURList)\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private static void sqlTranslation(String &#x27;
                         &#x27;localSqlPluginPath,\n&#x27;
                         &#x27;                                       &#x27;
                         &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                         &#x27;                                       SqlTree &#x27;
                         &#x27;sqlTree,Map&lt;String, AbstractSideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                                       Map&lt;String, &#x27;
                         &#x27;Table&gt; registerTableCache,\n&#x27;
                         &#x27;                                       &#x27;
                         &#x27;StreamQueryConfig queryConfig) throws Exception {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        SideSqlExec sideSqlExec = new &#x27;
                         &#x27;SideSqlExec();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    \tSideSqlExec sideSqlExec = new &#x27;
                           &#x27;SideSqlExec();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public static void setLogLevel(ParamsInfo &#x27;
                         &#x27;paramsInfo){\n&#x27;
                         &#x27;        String logLevel = &#x27;
                         &#x27;paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        ChangeLogLevelProcess logLevelProcess = new &#x27;
                         &#x27;ChangeLogLevelProcess();\n&#x27;
                         &#x27;        logLevelProcess.process(logLevel);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.classloader.ClassLoaderManager;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.config.CalciteConfig;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.constrant.ConfigConstrant;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ClusterMode;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.EPluginLoadMode;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.environment.StreamEnvConfigManager;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.function.FunctionManager;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.option.OptionParser;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.option.Options;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.parser.CreateFuncParser;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.parser.CreateTmpTableParser;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.parser.InsertSqlParser;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.parser.SqlParser;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.parser.SqlTree;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.SideSqlExec;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.AbstractSideTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.table.AbstractSourceTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.table.AbstractTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.table.AbstractTargetTableInfo;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.PluginUtil;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;\n&#x27;
                         &#x27;import com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                         &#x27;import com.google.common.base.Preconditions;\n&#x27;
                         &#x27;import com.google.common.base.Strings;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import com.google.common.collect.Sets;\n&#x27;
                         &#x27;import org.apache.calcite.sql.SqlInsert;\n&#x27;
                         &#x27;import org.apache.calcite.sql.SqlNode;\n&#x27;
                         &#x27;import org.apache.commons.io.Charsets;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.api.StreamQueryConfig;\n&#x27;
                         &#x27;import org.apache.flink.table.api.Table;\n&#x27;
                         &#x27;import org.apache.flink.table.api.TableEnvironment;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.api.java.StreamTableEnvironment;\n&#x27;
                         &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.lang.reflect.InvocationTargetException;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.net.URLClassLoader;\n&#x27;
                         &#x27;import java.net.URLDecoder;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.Set;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; *  任务执行时的流程方法\n&#x27;
                         &#x27; * Date: 2020/2/17\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class ExecuteProcessHelper {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String CLASS_FILE_NAME_FMT &#x27;
                         &#x27;= &quot;class_path_%d&quot;;\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(ExecuteProcessHelper.class);\n&#x27;
                         &#x27;    private static final ObjectMapper OBJECT_MAPPER &#x27;
                         &#x27;= new ObjectMapper();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static ParamsInfo parseParams(String[] &#x27;
                         &#x27;args) throws Exception {\n&#x27;
                         &#x27;        LOG.info(&quot;------------program &#x27;
                         &#x27;params-------------------------&quot;);\n&#x27;
                         &#x27;        System.out.println(&quot;------------program &#x27;
                         &#x27;params-------------------------&quot;);\n&#x27;
                         &#x27;        Arrays.stream(args).forEach(arg -&gt; &#x27;
                         &#x27;LOG.info(&quot;{}&quot;, arg));\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Arrays.stream(args).forEach(System.out::println);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;LOG.info(&quot;-------------------------------------------&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;System.out.println(&quot;----------------------------------------&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        OptionParser optionParser = new &#x27;
                         &#x27;OptionParser(args);\n&#x27;
                         &#x27;        Options options = &#x27;
                         &#x27;optionParser.getOptions();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String sql = &#x27;
                         &#x27;URLDecoder.decode(options.getSql(), &#x27;
                         &#x27;Charsets.UTF_8.name());\n&#x27;
                         &#x27;        String name = options.getName();\n&#x27;
                         &#x27;        String localSqlPluginPath = &#x27;
                         &#x27;options.getLocalSqlPluginPath();\n&#x27;
                         &#x27;        String remoteSqlPluginPath = &#x27;
                         &#x27;options.getRemoteSqlPluginPath();\n&#x27;
                         &#x27;        String pluginLoadMode = &#x27;
                         &#x27;options.getPluginLoadMode();\n&#x27;
                         &#x27;        String deployMode = options.getMode();\n&#x27;
                         &#x27;        String logLevel = options.getLogLevel();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, &#x27;
                         &#x27;deployMode, pluginLoadMode),\n&#x27;
                         &#x27;                &quot;Non-local mode or shipfile &#x27;
                         &#x27;deployment mode, remoteSqlPluginPath is required&quot;);\n&#x27;
                         &#x27;        String confProp = &#x27;
                         &#x27;URLDecoder.decode(options.getConfProp(), &#x27;
                         &#x27;Charsets.UTF_8.toString());\n&#x27;
                         &#x27;        Properties confProperties = &#x27;
                         &#x27;PluginUtil.jsonStrToObject(confProp, &#x27;
                         &#x27;Properties.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;URL&gt; jarUrlList = &#x27;
                         &#x27;getExternalJarUrls(options.getAddjar());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return ParamsInfo.builder()\n&#x27;
                         &#x27;                .setSql(sql)\n&#x27;
                         &#x27;                .setName(name)\n&#x27;
                         &#x27;                &#x27;
                         &#x27;.setLocalSqlPluginPath(localSqlPluginPath)\n&#x27;
                         &#x27;                &#x27;
                         &#x27;.setRemoteSqlPluginPath(remoteSqlPluginPath)\n&#x27;
                         &#x27;                .setPluginLoadMode(pluginLoadMode)\n&#x27;
                         &#x27;                .setDeployMode(deployMode)\n&#x27;
                         &#x27;                .setConfProp(confProperties)\n&#x27;
                         &#x27;                .setJarUrlList(jarUrlList)\n&#x27;
                         &#x27;                .build();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     *   &#x27;
                         &#x27;非local模式或者shipfile部署模式，remoteSqlPluginPath必填\n&#x27;
                         &#x27;     * @param remoteSqlPluginPath\n&#x27;
                         &#x27;     * @param deployMode\n&#x27;
                         &#x27;     * @param pluginLoadMode\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public static boolean &#x27;
                         &#x27;checkRemoteSqlPluginPath(String remoteSqlPluginPath, &#x27;
                         &#x27;String deployMode, String pluginLoadMode) {\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(StringUtils.isEmpty(remoteSqlPluginPath)) {\n&#x27;
                         &#x27;            return &#x27;
                         &#x27;StringUtils.equalsIgnoreCase(pluginLoadMode, &#x27;
                         &#x27;EPluginLoadMode.SHIPFILE.name())\n&#x27;
                         &#x27;                    || &#x27;
                         &#x27;StringUtils.equalsIgnoreCase(deployMode, &#x27;
                         &#x27;ClusterMode.local.name());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static StreamExecutionEnvironment &#x27;
                         &#x27;getStreamExecution(ParamsInfo paramsInfo) throws &#x27;
                         &#x27;Exception {\n&#x27;
                         &#x27;        StreamExecutionEnvironment env = &#x27;
                         &#x27;ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), &#x27;
                         &#x27;paramsInfo.getDeployMode());\n&#x27;
                         &#x27;        StreamTableEnvironment tableEnv = &#x27;
                         &#x27;StreamTableEnvironment.create(env);\n&#x27;
                         &#x27;        StreamQueryConfig streamQueryConfig = &#x27;
                         &#x27;StreamEnvConfigManager.getStreamQueryConfig(tableEnv, &#x27;
                         &#x27;paramsInfo.getConfProp());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());\n&#x27;
                         &#x27;        SqlTree sqlTree = &#x27;
                         &#x27;SqlParser.parseSql(paramsInfo.getSql());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Map&lt;String, AbstractSideTableInfo&gt; &#x27;
                         &#x27;sideTableMap = Maps.newHashMap();\n&#x27;
                         &#x27;        Map&lt;String, Table&gt; registerTableCache = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //register udf\n&#x27;
                         &#x27;        &#x27;
                         &#x27;ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, &#x27;
                         &#x27;paramsInfo.getJarUrlList(), tableEnv);\n&#x27;
                         &#x27;        //register table schema\n&#x27;
                         &#x27;        Set&lt;URL&gt; classPathSets = &#x27;
                         &#x27;ExecuteProcessHelper.registerTable(sqlTree, env, &#x27;
                         &#x27;tableEnv, paramsInfo.getLocalSqlPluginPath(),\n&#x27;
                         &#x27;                paramsInfo.getRemoteSqlPluginPath(), &#x27;
                         &#x27;paramsInfo.getPluginLoadMode(), sideTableMap, &#x27;
                         &#x27;registerTableCache);\n&#x27;
                         &#x27;        // cache classPathSets\n&#x27;
                         &#x27;        &#x27;
                         &#x27;ExecuteProcessHelper.registerPluginUrlToCachedFile(env, &#x27;
                         &#x27;classPathSets);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), &#x27;
                         &#x27;tableEnv, sqlTree, sideTableMap, registerTableCache, &#x27;
                         &#x27;streamQueryConfig);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (env instanceof MyLocalStreamEnvironment) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            ((MyLocalStreamEnvironment) &#x27;
                         &#x27;env).setClasspaths(ClassLoaderManager.getClassPath());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return env;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static List&lt;URL&gt; &#x27;
                         &#x27;getExternalJarUrls(String addJarListStr) throws &#x27;
                         &#x27;java.io.IOException {\n&#x27;
                         &#x27;        List&lt;URL&gt; jarUrlList = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;        if (Strings.isNullOrEmpty(addJarListStr)) {\n&#x27;
                         &#x27;            return jarUrlList;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; addJarFileList = &#x27;
                         &#x27;OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, &#x27;
                         &#x27;Charsets.UTF_8.name()), List.class);\n&#x27;
                         &#x27;        //Get External jar to load\n&#x27;
                         &#x27;        for (String addJarPath : addJarFileList) {\n&#x27;
                         &#x27;            jarUrlList.add(new &#x27;
                         &#x27;File(addJarPath).toURI().toURL());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return jarUrlList;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static void sqlTranslation(String &#x27;
                         &#x27;localSqlPluginPath,\n&#x27;
                         &#x27;                                       &#x27;
                         &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                         &#x27;                                       SqlTree &#x27;
                         &#x27;sqlTree,Map&lt;String, AbstractSideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                                       Map&lt;String, &#x27;
                         &#x27;Table&gt; registerTableCache,\n&#x27;
                         &#x27;                                       &#x27;
                         &#x27;StreamQueryConfig queryConfig) throws Exception {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        SideSqlExec sideSqlExec = new &#x27;
                         &#x27;SideSqlExec();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);\n&#x27;
                         &#x27;        for (CreateTmpTableParser.SqlParserResult &#x27;
                         &#x27;result : sqlTree.getTmpSqlList()) {\n&#x27;
                         &#x27;            sideSqlExec.exec(result.getExecSql(), &#x27;
                         &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                         &#x27;queryConfig, result);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (InsertSqlParser.SqlParseResult result : &#x27;
                         &#x27;sqlTree.getExecSqlList()) {\n&#x27;
                         &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                         &#x27;                LOG.info(&quot;exe-sql:\\n&quot; + &#x27;
                         &#x27;result.getExecSql());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            boolean isSide = false;\n&#x27;
                         &#x27;            for (String tableName : &#x27;
                         &#x27;result.getTargetTableList()) {\n&#x27;
                         &#x27;                if &#x27;
                         &#x27;(sqlTree.getTmpTableMap().containsKey(tableName)) {\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult tmp = &#x27;
                         &#x27;sqlTree.getTmpTableMap().get(tableName);\n&#x27;
                         &#x27;                    String realSql = &#x27;
                         &#x27;DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &#x27;
                         &#x27;&quot;`&quot;, &quot;&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                    SqlNode sqlNode = &#x27;
                         &#x27;org.apache.calcite.sql.parser.SqlParser.create(realSql, &#x27;
                         &#x27;CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();\n&#x27;
                         &#x27;                    String tmpSql = ((SqlInsert) &#x27;
                         &#x27;sqlNode).getSource().toString();\n&#x27;
                         &#x27;                    tmp.setExecSql(tmpSql);\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;sideSqlExec.exec(tmp.getExecSql(), sideTableMap, &#x27;
                         &#x27;tableEnv, registerTableCache, queryConfig, tmp);\n&#x27;
                         &#x27;                } else {\n&#x27;
                         &#x27;                    for (String sourceTable : &#x27;
                         &#x27;result.getSourceTableList()) {\n&#x27;
                         &#x27;                        if &#x27;
                         &#x27;(sideTableMap.containsKey(sourceTable)) {\n&#x27;
                         &#x27;                            isSide = true;\n&#x27;
                         &#x27;                            break;\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    if (isSide) {\n&#x27;
                         &#x27;                        //sql-dimensional table &#x27;
                         &#x27;contains the dimension table of execution\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;sideSqlExec.exec(result.getExecSql(), sideTableMap, &#x27;
                         &#x27;tableEnv, registerTableCache, queryConfig, null);\n&#x27;
                         &#x27;                    } else {\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;System.out.println(&quot;----------exec sql without &#x27;
                         &#x27;dimension join-----------&quot;);\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;System.out.println(&quot;----------real sql exec &#x27;
                         &#x27;is--------------------------&quot;);\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;System.out.println(result.getExecSql());\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                         &#x27;result.getExecSql(), queryConfig);\n&#x27;
                         &#x27;                        if (LOG.isInfoEnabled()) {\n&#x27;
                         &#x27;                            System.out.println();\n&#x27;
                         &#x27;                            LOG.info(&quot;exec sql: &quot; + &#x27;
                         &#x27;result.getExecSql());\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static void &#x27;
                         &#x27;registerUserDefinedFunction(SqlTree sqlTree, &#x27;
                         &#x27;List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)\n&#x27;
                         &#x27;            throws IllegalAccessException, &#x27;
                         &#x27;InvocationTargetException {\n&#x27;
                         &#x27;        // udf和tableEnv须由同一个类加载器加载\n&#x27;
                         &#x27;        ClassLoader levelClassLoader = &#x27;
                         &#x27;tableEnv.getClass().getClassLoader();\n&#x27;
                         &#x27;        URLClassLoader classLoader = null;\n&#x27;
                         &#x27;        List&lt;CreateFuncParser.SqlParserResult&gt; &#x27;
                         &#x27;funcList = sqlTree.getFunctionList();\n&#x27;
                         &#x27;        for (CreateFuncParser.SqlParserResult &#x27;
                         &#x27;funcInfo : funcList) {\n&#x27;
                         &#x27;            //classloader\n&#x27;
                         &#x27;            if (classLoader == null) {\n&#x27;
                         &#x27;                classLoader = &#x27;
                         &#x27;ClassLoaderManager.loadExtraJar(jarUrlList, &#x27;
                         &#x27;(URLClassLoader) levelClassLoader);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            &#x27;
                         &#x27;FunctionManager.registerUDF(funcInfo.getType(), &#x27;
                         &#x27;funcInfo.getClassName(), funcInfo.getName(), &#x27;
                         &#x27;tableEnv, classLoader);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     *    向Flink注册源表和结果表，返回执行时插件包的全路径\n&#x27;
                         &#x27;     * @param sqlTree\n&#x27;
                         &#x27;     * @param env\n&#x27;
                         &#x27;     * @param tableEnv\n&#x27;
                         &#x27;     * @param localSqlPluginPath\n&#x27;
                         &#x27;     * @param remoteSqlPluginPath\n&#x27;
                         &#x27;     * @param pluginLoadMode   插件加载模式 classpath or &#x27;
                         &#x27;shipfile\n&#x27;
                         &#x27;     * @param sideTableMap\n&#x27;
                         &#x27;     * @param registerTableCache\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     * @throws Exception\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public static Set&lt;URL&gt; registerTable(SqlTree &#x27;
                         &#x27;sqlTree, StreamExecutionEnvironment env, &#x27;
                         &#x27;StreamTableEnvironment tableEnv, String &#x27;
                         &#x27;localSqlPluginPath,\n&#x27;
                         &#x27;                                         String &#x27;
                         &#x27;remoteSqlPluginPath, String pluginLoadMode, &#x27;
                         &#x27;Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, &#x27;
                         &#x27;Map&lt;String, Table&gt; registerTableCache) throws &#x27;
                         &#x27;Exception {\n&#x27;
                         &#x27;        Set&lt;URL&gt; pluginClassPatshSets = &#x27;
                         &#x27;Sets.newHashSet();\n&#x27;
                         &#x27;        WaterMarkerAssigner waterMarkerAssigner = &#x27;
                         &#x27;new WaterMarkerAssigner();\n&#x27;
                         &#x27;        for (AbstractTableInfo tableInfo : &#x27;
                         &#x27;sqlTree.getTableInfoMap().values()) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if (tableInfo instanceof &#x27;
                         &#x27;AbstractSourceTableInfo) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                AbstractSourceTableInfo &#x27;
                         &#x27;sourceTableInfo = (AbstractSourceTableInfo) &#x27;
                         &#x27;tableInfo;\n&#x27;
                         &#x27;                Table table = &#x27;
                         &#x27;StreamSourceFactory.getStreamSource(sourceTableInfo, &#x27;
                         &#x27;env, tableEnv, localSqlPluginPath);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;tableEnv.registerTable(sourceTableInfo.getAdaptName(), &#x27;
                         &#x27;table);\n&#x27;
                         &#x27;                //Note --- parameter conversion &#x27;
                         &#x27;function can not be used inside a function of the &#x27;
                         &#x27;type of polymerization\n&#x27;
                         &#x27;                //Create table in which the function &#x27;
                         &#x27;is arranged only need adaptation sql\n&#x27;
                         &#x27;                String adaptSql = &#x27;
                         &#x27;sourceTableInfo.getAdaptSelectSql();\n&#x27;
                         &#x27;                Table adaptTable = adaptSql == null &#x27;
                         &#x27;? table : tableEnv.sqlQuery(adaptSql);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                RowTypeInfo typeInfo = new &#x27;
                         &#x27;RowTypeInfo(adaptTable.getSchema().getFieldTypes(), &#x27;
                         &#x27;adaptTable.getSchema().getFieldNames());\n&#x27;
                         &#x27;                DataStream adaptStream = &#x27;
                         &#x27;tableEnv.toRetractStream(adaptTable, typeInfo)\n&#x27;
                         &#x27;                        .map((Tuple2&lt;Boolean, Row&gt; &#x27;
                         &#x27;f0) -&gt; {\n&#x27;
                         &#x27;                            return f0.f1;\n&#x27;
                         &#x27;                        })\n&#x27;
                         &#x27;                        .returns(typeInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                String fields = String.join(&quot;,&quot;, &#x27;
                         &#x27;typeInfo.getFieldNames());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                if &#x27;
                         &#x27;(waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                    adaptStream = &#x27;
                         &#x27;waterMarkerAssigner.assignWaterMarker(adaptStream, &#x27;
                         &#x27;typeInfo, sourceTableInfo);\n&#x27;
                         &#x27;                    fields += &quot;,ROWTIME.ROWTIME&quot;;\n&#x27;
                         &#x27;                } else {\n&#x27;
                         &#x27;                    fields += &quot;,PROCTIME.PROCTIME&quot;;\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                Table regTable = &#x27;
                         &#x27;tableEnv.fromDataStream(adaptStream, fields);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;tableEnv.registerTable(tableInfo.getName(), &#x27;
                         &#x27;regTable);\n&#x27;
                         &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                         &#x27;                    LOG.info(&quot;registe table {} &#x27;
                         &#x27;success.&quot;, tableInfo.getName());\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                &#x27;
                         &#x27;registerTableCache.put(tableInfo.getName(), &#x27;
                         &#x27;regTable);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                URL sourceTablePathUrl = &#x27;
                         &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                         &#x27;AbstractSourceTableInfo.SOURCE_SUFFIX, &#x27;
                         &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                         &#x27;pluginLoadMode);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;pluginClassPatshSets.add(sourceTablePathUrl);\n&#x27;
                         &#x27;            } else if (tableInfo instanceof &#x27;
                         &#x27;AbstractTargetTableInfo) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                TableSink tableSink = &#x27;
                         &#x27;StreamSinkFactory.getTableSink((AbstractTargetTableInfo) &#x27;
                         &#x27;tableInfo, localSqlPluginPath);\n&#x27;
                         &#x27;                TypeInformation[] flinkTypes = &#x27;
                         &#x27;FunctionManager.transformTypes(tableInfo.getFieldClasses());\n&#x27;
                         &#x27;                &#x27;
                         &#x27;tableEnv.registerTableSink(tableInfo.getName(), &#x27;
                         &#x27;tableInfo.getFields(), flinkTypes, tableSink);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                URL sinkTablePathUrl = &#x27;
                         &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                         &#x27;AbstractTargetTableInfo.TARGET_SUFFIX, &#x27;
                         &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                         &#x27;pluginLoadMode);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;pluginClassPatshSets.add(sinkTablePathUrl);\n&#x27;
                         &#x27;            } else if (tableInfo instanceof &#x27;
                         &#x27;AbstractSideTableInfo) {\n&#x27;
                         &#x27;                String sideOperator = &#x27;
                         &#x27;ECacheType.ALL.name().equals(((AbstractSideTableInfo) &#x27;
                         &#x27;tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;\n&#x27;
                         &#x27;                &#x27;
                         &#x27;sideTableMap.put(tableInfo.getName(), &#x27;
                         &#x27;(AbstractSideTableInfo) tableInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                URL sideTablePathUrl = &#x27;
                         &#x27;PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), &#x27;
                         &#x27;sideOperator, AbstractSideTableInfo.TARGET_SUFFIX, &#x27;
                         &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                         &#x27;pluginLoadMode);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;pluginClassPatshSets.add(sideTablePathUrl);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                throw new RuntimeException(&quot;not &#x27;
                         &#x27;support table type:&quot; + tableInfo.getType());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return pluginClassPatshSets;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     *   &#x27;
                         &#x27;perjob模式将job依赖的插件包路径存储到cacheFile，在外围将插件包路径传递给jobgraph\n&#x27;
                         &#x27;     * @param env\n&#x27;
                         &#x27;     * @param classPathSet\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public static void &#x27;
                         &#x27;registerPluginUrlToCachedFile(StreamExecutionEnvironment &#x27;
                         &#x27;env, Set&lt;URL&gt; classPathSet) {\n&#x27;
                         &#x27;        int i = 0;\n&#x27;
                         &#x27;        for (URL url : classPathSet) {\n&#x27;
                         &#x27;            String classFileName = &#x27;
                         &#x27;String.format(CLASS_FILE_NAME_FMT, i);\n&#x27;
                         &#x27;            env.registerCachedFile(url.getPath(), &#x27;
                         &#x27;classFileName, true);\n&#x27;
                         &#x27;            i++;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static StreamExecutionEnvironment &#x27;
                         &#x27;getStreamExeEnv(Properties confProperties, String &#x27;
                         &#x27;deployMode) throws Exception {\n&#x27;
                         &#x27;        StreamExecutionEnvironment env = &#x27;
                         &#x27;!ClusterMode.local.name().equals(deployMode) ?\n&#x27;
                         &#x27;                &#x27;
                         &#x27;StreamExecutionEnvironment.getExecutionEnvironment() &#x27;
                         &#x27;:\n&#x27;
                         &#x27;                new MyLocalStreamEnvironment();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, &#x27;
                         &#x27;confProperties);\n&#x27;
                         &#x27;        return env;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static void setLogLevel(ParamsInfo &#x27;
                         &#x27;paramsInfo){\n&#x27;
                         &#x27;        String logLevel = &#x27;
                         &#x27;paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        ChangeLogLevelProcess logLevelProcess = new &#x27;
                         &#x27;ChangeLogLevelProcess();\n&#x27;
                         &#x27;        logLevelProcess.process(logLevel);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.StreamQueryConfig;\n&#x27;
                           &#x27;import org.apache.flink.table.api.Table;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.TableEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.java.StreamTableEnvironment;\n&#x27;
                           &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.classloader.ClassLoaderManager;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.config.CalciteConfig;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ClusterMode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.enums.EPluginLoadMode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.environment.StreamEnvConfigManager;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.function.FunctionManager;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.option.OptionParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.option.Options;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateFuncParser;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTmpTableParser;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.InsertSqlParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.SqlParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.SqlTree;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideSqlExec;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.table.SourceTableInfo;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.table.TableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.PluginUtil;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import com.google.common.base.Preconditions;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import com.google.common.collect.Sets;\n&#x27;
                           &#x27;import org.apache.calcite.sql.SqlInsert;\n&#x27;
                           &#x27;import org.apache.calcite.sql.SqlNode;\n&#x27;
                           &#x27;import org.apache.commons.io.Charsets;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import org.slf4j.Logger;\n&#x27;
                           &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.lang.reflect.InvocationTargetException;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLClassLoader;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *  任务执行时的流程方法\n&#x27;
                           &#x27; * Date: 2020/2/17\n&#x27;
                           &#x27; * Company: www.dtstack.com\n&#x27;
                           &#x27; * @author maqi\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class ExecuteProcessHelper {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final String &#x27;
                           &#x27;CLASS_FILE_NAME_FMT = &quot;class_path_%d&quot;;\n&#x27;
                           &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(ExecuteProcessHelper.class);\n&#x27;
                           &#x27;    private static final ObjectMapper &#x27;
                           &#x27;OBJECT_MAPPER = new ObjectMapper();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static ParamsInfo parseParams(String[] &#x27;
                           &#x27;args) throws Exception {\n&#x27;
                           &#x27;        LOG.info(&quot;------------program &#x27;
                           &#x27;params-------------------------&quot;);\n&#x27;
                           &#x27;        System.out.println(&quot;------------program &#x27;
                           &#x27;params-------------------------&quot;);\n&#x27;
                           &#x27;        Arrays.stream(args).forEach(arg -&gt; &#x27;
                           &#x27;LOG.info(&quot;{}&quot;, arg));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;Arrays.stream(args).forEach(System.out::println);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;LOG.info(&quot;-------------------------------------------&quot;);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;System.out.println(&quot;----------------------------------------&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        OptionParser optionParser = new &#x27;
                           &#x27;OptionParser(args);\n&#x27;
                           &#x27;        Options options = &#x27;
                           &#x27;optionParser.getOptions();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String sql = &#x27;
                           &#x27;URLDecoder.decode(options.getSql(), &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;        String name = options.getName();\n&#x27;
                           &#x27;        String localSqlPluginPath = &#x27;
                           &#x27;options.getLocalSqlPluginPath();\n&#x27;
                           &#x27;        String remoteSqlPluginPath = &#x27;
                           &#x27;options.getRemoteSqlPluginPath();\n&#x27;
                           &#x27;        String pluginLoadMode = &#x27;
                           &#x27;options.getPluginLoadMode();\n&#x27;
                           &#x27;        String deployMode = options.getMode();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, &#x27;
                           &#x27;deployMode, pluginLoadMode),\n&#x27;
                           &#x27;                &quot;Non-local mode or shipfile &#x27;
                           &#x27;deployment mode, remoteSqlPluginPath is &#x27;
                           &#x27;required&quot;);\n&#x27;
                           &#x27;        String confProp = &#x27;
                           &#x27;URLDecoder.decode(options.getConfProp(), &#x27;
                           &#x27;Charsets.UTF_8.toString());\n&#x27;
                           &#x27;        Properties confProperties = &#x27;
                           &#x27;PluginUtil.jsonStrToObject(confProp, &#x27;
                           &#x27;Properties.class);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;URL&gt; jarURList = &#x27;
                           &#x27;getExternalJarUrls(options.getAddjar());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return ParamsInfo.builder()\n&#x27;
                           &#x27;                .setSql(sql)\n&#x27;
                           &#x27;                .setName(name)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;.setLocalSqlPluginPath(localSqlPluginPath)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;.setRemoteSqlPluginPath(remoteSqlPluginPath)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;.setPluginLoadMode(pluginLoadMode)\n&#x27;
                           &#x27;                .setDeployMode(deployMode)\n&#x27;
                           &#x27;                .setConfProp(confProperties)\n&#x27;
                           &#x27;                .setJarUrlList(jarURList)\n&#x27;
                           &#x27;                .build();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   &#x27;
                           &#x27;非local模式或者shipfile部署模式，remoteSqlPluginPath必填\n&#x27;
                           &#x27;     * @param remoteSqlPluginPath\n&#x27;
                           &#x27;     * @param deployMode\n&#x27;
                           &#x27;     * @param pluginLoadMode\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static boolean &#x27;
                           &#x27;checkRemoteSqlPluginPath(String &#x27;
                           &#x27;remoteSqlPluginPath, String deployMode, String &#x27;
                           &#x27;pluginLoadMode) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(StringUtils.isEmpty(remoteSqlPluginPath)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;StringUtils.equalsIgnoreCase(pluginLoadMode, &#x27;
                           &#x27;EPluginLoadMode.SHIPFILE.name())\n&#x27;
                           &#x27;                    || &#x27;
                           &#x27;StringUtils.equalsIgnoreCase(deployMode, &#x27;
                           &#x27;ClusterMode.local.name());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static StreamExecutionEnvironment &#x27;
                           &#x27;getStreamExecution(ParamsInfo paramsInfo) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), &#x27;
                           &#x27;paramsInfo.getDeployMode());\n&#x27;
                           &#x27;        StreamTableEnvironment tableEnv = &#x27;
                           &#x27;StreamTableEnvironment.create(env);\n&#x27;
                           &#x27;        StreamQueryConfig streamQueryConfig = &#x27;
                           &#x27;StreamEnvConfigManager.getStreamQueryConfig(tableEnv, &#x27;
                           &#x27;paramsInfo.getConfProp());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());\n&#x27;
                           &#x27;        SqlTree sqlTree = &#x27;
                           &#x27;SqlParser.parseSql(paramsInfo.getSql());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, SideTableInfo&gt; sideTableMap = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;        Map&lt;String, Table&gt; registerTableCache = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //register udf\n&#x27;
                           &#x27;        &#x27;
                           &#x27;ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, &#x27;
                           &#x27;paramsInfo.getJarUrlList(), tableEnv);\n&#x27;
                           &#x27;        //register table schema\n&#x27;
                           &#x27;        Set&lt;URL&gt; classPathSets = &#x27;
                           &#x27;ExecuteProcessHelper.registerTable(sqlTree, env, &#x27;
                           &#x27;tableEnv, paramsInfo.getLocalSqlPluginPath(),\n&#x27;
                           &#x27;                &#x27;
                           &#x27;paramsInfo.getRemoteSqlPluginPath(), &#x27;
                           &#x27;paramsInfo.getPluginLoadMode(), sideTableMap, &#x27;
                           &#x27;registerTableCache);\n&#x27;
                           &#x27;        // cache classPathSets\n&#x27;
                           &#x27;        &#x27;
                           &#x27;ExecuteProcessHelper.registerPluginUrlToCachedFile(env, &#x27;
                           &#x27;classPathSets);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), &#x27;
                           &#x27;tableEnv, sqlTree, sideTableMap, &#x27;
                           &#x27;registerTableCache, streamQueryConfig);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (env instanceof &#x27;
                           &#x27;MyLocalStreamEnvironment) {\n&#x27;
                           &#x27;            ((MyLocalStreamEnvironment) &#x27;
                           &#x27;env).setClasspaths(ClassLoaderManager.getClassPath());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return env;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static List&lt;URL&gt; &#x27;
                           &#x27;getExternalJarUrls(String addJarListStr) throws &#x27;
                           &#x27;java.io.IOException {\n&#x27;
                           &#x27;        List&lt;URL&gt; jarUrlList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        if (Strings.isNullOrEmpty(addJarListStr)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            return jarUrlList;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; addJarFileList = &#x27;
                           &#x27;OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, &#x27;
                           &#x27;Charsets.UTF_8.name()), List.class);\n&#x27;
                           &#x27;        //Get External jar to load\n&#x27;
                           &#x27;        for (String addJarPath : addJarFileList) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            jarUrlList.add(new &#x27;
                           &#x27;File(addJarPath).toURI().toURL());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return jarUrlList;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static void sqlTranslation(String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;            StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;            SqlTree sqlTree,Map&lt;String, &#x27;
                           &#x27;SideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;            Map&lt;String, Table&gt; &#x27;
                           &#x27;registerTableCache,\n&#x27;
                           &#x27;            StreamQueryConfig queryConfig) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    \tSideSqlExec sideSqlExec = new &#x27;
                           &#x27;SideSqlExec();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);\n&#x27;
                           &#x27;        for (CreateTmpTableParser.SqlParserResult &#x27;
                           &#x27;result : sqlTree.getTmpSqlList()) {\n&#x27;
                           &#x27;            sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, result);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (InsertSqlParser.SqlParseResult result &#x27;
                           &#x27;: sqlTree.getExecSqlList()) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;exe-sql:\\n&quot; + &#x27;
                           &#x27;result.getExecSql());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            boolean isSide = false;\n&#x27;
                           &#x27;            for (String tableName : &#x27;
                           &#x27;result.getTargetTableList()) {\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(sqlTree.getTmpTableMap().containsKey(tableName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult tmp = &#x27;
                           &#x27;sqlTree.getTmpTableMap().get(tableName);\n&#x27;
                           &#x27;                    String realSql = &#x27;
                           &#x27;DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &#x27;
                           &#x27;&quot;`&quot;, &quot;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    SqlNode sqlNode = &#x27;
                           &#x27;org.apache.calcite.sql.parser.SqlParser.create(realSql, &#x27;
                           &#x27;CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();\n&#x27;
                           &#x27;                    String tmpSql = ((SqlInsert) &#x27;
                           &#x27;sqlNode).getSource().toString();\n&#x27;
                           &#x27;                    tmp.setExecSql(tmpSql);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;sideSqlExec.exec(tmp.getExecSql(), sideTableMap, &#x27;
                           &#x27;tableEnv, registerTableCache, queryConfig, tmp);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    for (String sourceTable : &#x27;
                           &#x27;result.getSourceTableList()) {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sideTableMap.containsKey(sourceTable)) {\n&#x27;
                           &#x27;                            isSide = true;\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    if (isSide) {\n&#x27;
                           &#x27;                        //sql-dimensional table &#x27;
                           &#x27;contains the dimension table of execution\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, null);\n&#x27;
                           &#x27;                    } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------exec sql without &#x27;
                           &#x27;dimension join-----------&quot;);\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------real sql exec &#x27;
                           &#x27;is--------------------------&quot;);\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(result.getExecSql());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                           &#x27;result.getExecSql(), queryConfig);\n&#x27;
                           &#x27;                        if (LOG.isInfoEnabled()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                            LOG.info(&quot;exec sql: &quot; &#x27;
                           &#x27;+ result.getExecSql());\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static void &#x27;
                           &#x27;registerUserDefinedFunction(SqlTree sqlTree, &#x27;
                           &#x27;List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)\n&#x27;
                           &#x27;            throws IllegalAccessException, &#x27;
                           &#x27;InvocationTargetException {\n&#x27;
                           &#x27;        // udf和tableEnv须由同一个类加载器加载\n&#x27;
                           &#x27;        ClassLoader levelClassLoader = &#x27;
                           &#x27;tableEnv.getClass().getClassLoader();\n&#x27;
                           &#x27;        URLClassLoader classLoader = null;\n&#x27;
                           &#x27;        List&lt;CreateFuncParser.SqlParserResult&gt; &#x27;
                           &#x27;funcList = sqlTree.getFunctionList();\n&#x27;
                           &#x27;        for (CreateFuncParser.SqlParserResult &#x27;
                           &#x27;funcInfo : funcList) {\n&#x27;
                           &#x27;            //classloader\n&#x27;
                           &#x27;            if (classLoader == null) {\n&#x27;
                           &#x27;                classLoader = &#x27;
                           &#x27;ClassLoaderManager.loadExtraJar(jarUrlList, &#x27;
                           &#x27;(URLClassLoader) levelClassLoader);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;FunctionManager.registerUDF(funcInfo.getType(), &#x27;
                           &#x27;funcInfo.getClassName(), funcInfo.getName(), &#x27;
                           &#x27;tableEnv, classLoader);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *    向Flink注册源表和结果表，返回执行时插件包的全路径\n&#x27;
                           &#x27;     * @param sqlTree\n&#x27;
                           &#x27;     * @param env\n&#x27;
                           &#x27;     * @param tableEnv\n&#x27;
                           &#x27;     * @param localSqlPluginPath\n&#x27;
                           &#x27;     * @param remoteSqlPluginPath\n&#x27;
                           &#x27;     * @param pluginLoadMode   插件加载模式 classpath or &#x27;
                           &#x27;shipfile\n&#x27;
                           &#x27;     * @param sideTableMap\n&#x27;
                           &#x27;     * @param registerTableCache\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     * @throws Exception\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static Set&lt;URL&gt; registerTable(SqlTree &#x27;
                           &#x27;sqlTree, StreamExecutionEnvironment env, &#x27;
                           &#x27;StreamTableEnvironment tableEnv, String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;                                         String &#x27;
                           &#x27;remoteSqlPluginPath, String pluginLoadMode, &#x27;
                           &#x27;Map&lt;String, SideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;Map&lt;String, Table&gt; registerTableCache) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;        Set&lt;URL&gt; pluginClassPatshSets = &#x27;
                           &#x27;Sets.newHashSet();\n&#x27;
                           &#x27;        WaterMarkerAssigner waterMarkerAssigner = &#x27;
                           &#x27;new WaterMarkerAssigner();\n&#x27;
                           &#x27;        for (TableInfo tableInfo : &#x27;
                           &#x27;sqlTree.getTableInfoMap().values()) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (tableInfo instanceof &#x27;
                           &#x27;SourceTableInfo) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SourceTableInfo sourceTableInfo = &#x27;
                           &#x27;(SourceTableInfo) tableInfo;\n&#x27;
                           &#x27;                Table table = &#x27;
                           &#x27;StreamSourceFactory.getStreamSource(sourceTableInfo, &#x27;
                           &#x27;env, tableEnv, localSqlPluginPath);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTable(sourceTableInfo.getAdaptName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                //Note --- parameter conversion &#x27;
                           &#x27;function can not be used inside a function of the &#x27;
                           &#x27;type of polymerization\n&#x27;
                           &#x27;                //Create table in which the &#x27;
                           &#x27;function is arranged only need adaptation sql\n&#x27;
                           &#x27;                String adaptSql = &#x27;
                           &#x27;sourceTableInfo.getAdaptSelectSql();\n&#x27;
                           &#x27;                Table adaptTable = adaptSql == &#x27;
                           &#x27;null ? table : tableEnv.sqlQuery(adaptSql);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                RowTypeInfo typeInfo = new &#x27;
                           &#x27;RowTypeInfo(adaptTable.getSchema().getFieldTypes(), &#x27;
                           &#x27;adaptTable.getSchema().getFieldNames());\n&#x27;
                           &#x27;                DataStream adaptStream = &#x27;
                           &#x27;tableEnv.toRetractStream(adaptTable, typeInfo)\n&#x27;
                           &#x27;                        .map((Tuple2&lt;Boolean, Row&gt; &#x27;
                           &#x27;f0) -&gt; {\n&#x27;
                           &#x27;                            return f0.f1;\n&#x27;
                           &#x27;                        })\n&#x27;
                           &#x27;                        .returns(typeInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                String fields = String.join(&quot;,&quot;, &#x27;
                           &#x27;typeInfo.getFieldNames());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    adaptStream = &#x27;
                           &#x27;waterMarkerAssigner.assignWaterMarker(adaptStream, &#x27;
                           &#x27;typeInfo, sourceTableInfo);\n&#x27;
                           &#x27;                    fields += &quot;,ROWTIME.ROWTIME&quot;;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    fields += &#x27;
                           &#x27;&quot;,PROCTIME.PROCTIME&quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                Table regTable = &#x27;
                           &#x27;tableEnv.fromDataStream(adaptStream, fields);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTable(tableInfo.getName(), &#x27;
                           &#x27;regTable);\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;registe table {} &#x27;
                           &#x27;success.&quot;, tableInfo.getName());\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;registerTableCache.put(tableInfo.getName(), &#x27;
                           &#x27;regTable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sourceTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;SourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, &#x27;
                           &#x27;remoteSqlPluginPath, pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sourceTablePathUrl);\n&#x27;
                           &#x27;            } else if (tableInfo instanceof &#x27;
                           &#x27;TargetTableInfo) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                TableSink tableSink = &#x27;
                           &#x27;StreamSinkFactory.getTableSink((TargetTableInfo) &#x27;
                           &#x27;tableInfo, localSqlPluginPath);\n&#x27;
                           &#x27;                TypeInformation[] flinkTypes = &#x27;
                           &#x27;FunctionManager.transformTypes(tableInfo.getFieldClasses());\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTableSink(tableInfo.getName(), &#x27;
                           &#x27;tableInfo.getFields(), flinkTypes, tableSink);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sinkTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;TargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, &#x27;
                           &#x27;remoteSqlPluginPath, pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sinkTablePathUrl);\n&#x27;
                           &#x27;            } else if (tableInfo instanceof &#x27;
                           &#x27;SideTableInfo) {\n&#x27;
                           &#x27;                String sideOperator = &#x27;
                           &#x27;ECacheType.ALL.name().equals(((SideTableInfo) &#x27;
                           &#x27;tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;\n&#x27;
                           &#x27;                &#x27;
                           &#x27;sideTableMap.put(tableInfo.getName(), &#x27;
                           &#x27;(SideTableInfo) tableInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sideTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;sideOperator, SideTableInfo.TARGET_SUFFIX, &#x27;
                           &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                           &#x27;pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sideTablePathUrl);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;not &#x27;
                           &#x27;support table type:&quot; + tableInfo.getType());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return pluginClassPatshSets;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   &#x27;
                           &#x27;perjob模式将job依赖的插件包路径存储到cacheFile，在外围将插件包路径传递给jobgraph\n&#x27;
                           &#x27;     * @param env\n&#x27;
                           &#x27;     * @param classPathSet\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static void &#x27;
                           &#x27;registerPluginUrlToCachedFile(StreamExecutionEnvironment &#x27;
                           &#x27;env, Set&lt;URL&gt; classPathSet) {\n&#x27;
                           &#x27;        int i = 0;\n&#x27;
                           &#x27;        for (URL url : classPathSet) {\n&#x27;
                           &#x27;            String classFileName = &#x27;
                           &#x27;String.format(CLASS_FILE_NAME_FMT, i);\n&#x27;
                           &#x27;            env.registerCachedFile(url.getPath(), &#x27;
                           &#x27;classFileName, true);\n&#x27;
                           &#x27;            i++;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static StreamExecutionEnvironment &#x27;
                           &#x27;getStreamExeEnv(Properties confProperties, String &#x27;
                           &#x27;deployMode) throws Exception {\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;!ClusterMode.local.name().equals(deployMode) ?\n&#x27;
                           &#x27;                &#x27;
                           &#x27;StreamExecutionEnvironment.getExecutionEnvironment() &#x27;
                           &#x27;:\n&#x27;
                           &#x27;                new MyLocalStreamEnvironment();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, &#x27;
                           &#x27;confProperties);\n&#x27;
                           &#x27;        return env;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        List&lt;URL&gt; jarUrlList = &#x27;
                         &#x27;getExternalJarUrls(options.getAddjar());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        List&lt;URL&gt; jarURList = &#x27;
                           &#x27;getExternalJarUrls(options.getAddjar());\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;jarUrlList\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\njarURList\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;{\n&#x27;
                         &#x27;                            System.out.println();\n&#x27;
                         &#x27;                            LOG.info(&quot;exec sql: &quot; + &#x27;
                         &#x27;result.getExecSql());\n&#x27;
                         &#x27;                        }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;{\n&#x27;
                           &#x27;                            LOG.info(&quot;exec sql: &quot; &#x27;
                           &#x27;+ result.getExecSql());\n&#x27;
                           &#x27;                        }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;AbstractTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nTableInfo\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSourceTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSourceTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSourceTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSourceTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSourceTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSourceTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSourceTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSourceTableInfo\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;AbstractTargetTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nTargetTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractTargetTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nTargetTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractTargetTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nTargetTableInfo\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.StreamQueryConfig;\n&#x27;
                           &#x27;import org.apache.flink.table.api.Table;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.TableEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.java.StreamTableEnvironment;\n&#x27;
                           &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.classloader.ClassLoaderManager;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.config.CalciteConfig;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.constrant.ConfigConstrant;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ClusterMode;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.EPluginLoadMode;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.environment.StreamEnvConfigManager;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.function.FunctionManager;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.option.OptionParser;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.option.Options;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.parser.CreateFuncParser;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.parser.CreateTmpTableParser;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.parser.InsertSqlParser;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.parser.SqlParser;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.parser.SqlTree;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.SideSqlExec;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.AbstractSideTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.table.AbstractSourceTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.table.AbstractTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.table.AbstractTargetTableInfo;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.PluginUtil;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;\n&#x27;
                         &#x27;import com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                         &#x27;import com.google.common.base.Preconditions;\n&#x27;
                         &#x27;import com.google.common.base.Strings;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import com.google.common.collect.Sets;\n&#x27;
                         &#x27;import org.apache.calcite.sql.SqlInsert;\n&#x27;
                         &#x27;import org.apache.calcite.sql.SqlNode;\n&#x27;
                         &#x27;import org.apache.commons.io.Charsets;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.api.StreamQueryConfig;\n&#x27;
                         &#x27;import org.apache.flink.table.api.Table;\n&#x27;
                         &#x27;import org.apache.flink.table.api.TableEnvironment;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.api.java.StreamTableEnvironment;\n&#x27;
                         &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.lang.reflect.InvocationTargetException;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.net.URLClassLoader;\n&#x27;
                         &#x27;import java.net.URLDecoder;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.Set;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; *  任务执行时的流程方法\n&#x27;
                         &#x27; * Date: 2020/2/17\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class ExecuteProcessHelper {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String CLASS_FILE_NAME_FMT &#x27;
                         &#x27;= &quot;class_path_%d&quot;;\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(ExecuteProcessHelper.class);\n&#x27;
                         &#x27;    private static final ObjectMapper OBJECT_MAPPER &#x27;
                         &#x27;= new ObjectMapper();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static ParamsInfo parseParams(String[] &#x27;
                         &#x27;args) throws Exception {\n&#x27;
                         &#x27;        LOG.info(&quot;------------program &#x27;
                         &#x27;params-------------------------&quot;);\n&#x27;
                         &#x27;        System.out.println(&quot;------------program &#x27;
                         &#x27;params-------------------------&quot;);\n&#x27;
                         &#x27;        Arrays.stream(args).forEach(arg -&gt; &#x27;
                         &#x27;LOG.info(&quot;{}&quot;, arg));\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Arrays.stream(args).forEach(System.out::println);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;LOG.info(&quot;-------------------------------------------&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;System.out.println(&quot;----------------------------------------&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        OptionParser optionParser = new &#x27;
                         &#x27;OptionParser(args);\n&#x27;
                         &#x27;        Options options = &#x27;
                         &#x27;optionParser.getOptions();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String sql = &#x27;
                         &#x27;URLDecoder.decode(options.getSql(), &#x27;
                         &#x27;Charsets.UTF_8.name());\n&#x27;
                         &#x27;        String name = options.getName();\n&#x27;
                         &#x27;        String localSqlPluginPath = &#x27;
                         &#x27;options.getLocalSqlPluginPath();\n&#x27;
                         &#x27;        String remoteSqlPluginPath = &#x27;
                         &#x27;options.getRemoteSqlPluginPath();\n&#x27;
                         &#x27;        String pluginLoadMode = &#x27;
                         &#x27;options.getPluginLoadMode();\n&#x27;
                         &#x27;        String deployMode = options.getMode();\n&#x27;
                         &#x27;        String logLevel = options.getLogLevel();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, &#x27;
                         &#x27;deployMode, pluginLoadMode),\n&#x27;
                         &#x27;                &quot;Non-local mode or shipfile &#x27;
                         &#x27;deployment mode, remoteSqlPluginPath is required&quot;);\n&#x27;
                         &#x27;        String confProp = &#x27;
                         &#x27;URLDecoder.decode(options.getConfProp(), &#x27;
                         &#x27;Charsets.UTF_8.toString());\n&#x27;
                         &#x27;        Properties confProperties = &#x27;
                         &#x27;PluginUtil.jsonStrToObject(confProp, &#x27;
                         &#x27;Properties.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;URL&gt; jarUrlList = &#x27;
                         &#x27;getExternalJarUrls(options.getAddjar());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return ParamsInfo.builder()\n&#x27;
                         &#x27;                .setSql(sql)\n&#x27;
                         &#x27;                .setName(name)\n&#x27;
                         &#x27;                &#x27;
                         &#x27;.setLocalSqlPluginPath(localSqlPluginPath)\n&#x27;
                         &#x27;                &#x27;
                         &#x27;.setRemoteSqlPluginPath(remoteSqlPluginPath)\n&#x27;
                         &#x27;                .setPluginLoadMode(pluginLoadMode)\n&#x27;
                         &#x27;                .setDeployMode(deployMode)\n&#x27;
                         &#x27;                .setConfProp(confProperties)\n&#x27;
                         &#x27;                .setJarUrlList(jarUrlList)\n&#x27;
                         &#x27;                .build();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     *   &#x27;
                         &#x27;非local模式或者shipfile部署模式，remoteSqlPluginPath必填\n&#x27;
                         &#x27;     * @param remoteSqlPluginPath\n&#x27;
                         &#x27;     * @param deployMode\n&#x27;
                         &#x27;     * @param pluginLoadMode\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public static boolean &#x27;
                         &#x27;checkRemoteSqlPluginPath(String remoteSqlPluginPath, &#x27;
                         &#x27;String deployMode, String pluginLoadMode) {\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(StringUtils.isEmpty(remoteSqlPluginPath)) {\n&#x27;
                         &#x27;            return &#x27;
                         &#x27;StringUtils.equalsIgnoreCase(pluginLoadMode, &#x27;
                         &#x27;EPluginLoadMode.SHIPFILE.name())\n&#x27;
                         &#x27;                    || &#x27;
                         &#x27;StringUtils.equalsIgnoreCase(deployMode, &#x27;
                         &#x27;ClusterMode.local.name());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static StreamExecutionEnvironment &#x27;
                         &#x27;getStreamExecution(ParamsInfo paramsInfo) throws &#x27;
                         &#x27;Exception {\n&#x27;
                         &#x27;        StreamExecutionEnvironment env = &#x27;
                         &#x27;ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), &#x27;
                         &#x27;paramsInfo.getDeployMode());\n&#x27;
                         &#x27;        StreamTableEnvironment tableEnv = &#x27;
                         &#x27;StreamTableEnvironment.create(env);\n&#x27;
                         &#x27;        StreamQueryConfig streamQueryConfig = &#x27;
                         &#x27;StreamEnvConfigManager.getStreamQueryConfig(tableEnv, &#x27;
                         &#x27;paramsInfo.getConfProp());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());\n&#x27;
                         &#x27;        SqlTree sqlTree = &#x27;
                         &#x27;SqlParser.parseSql(paramsInfo.getSql());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Map&lt;String, AbstractSideTableInfo&gt; &#x27;
                         &#x27;sideTableMap = Maps.newHashMap();\n&#x27;
                         &#x27;        Map&lt;String, Table&gt; registerTableCache = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //register udf\n&#x27;
                         &#x27;        &#x27;
                         &#x27;ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, &#x27;
                         &#x27;paramsInfo.getJarUrlList(), tableEnv);\n&#x27;
                         &#x27;        //register table schema\n&#x27;
                         &#x27;        Set&lt;URL&gt; classPathSets = &#x27;
                         &#x27;ExecuteProcessHelper.registerTable(sqlTree, env, &#x27;
                         &#x27;tableEnv, paramsInfo.getLocalSqlPluginPath(),\n&#x27;
                         &#x27;                paramsInfo.getRemoteSqlPluginPath(), &#x27;
                         &#x27;paramsInfo.getPluginLoadMode(), sideTableMap, &#x27;
                         &#x27;registerTableCache);\n&#x27;
                         &#x27;        // cache classPathSets\n&#x27;
                         &#x27;        &#x27;
                         &#x27;ExecuteProcessHelper.registerPluginUrlToCachedFile(env, &#x27;
                         &#x27;classPathSets);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), &#x27;
                         &#x27;tableEnv, sqlTree, sideTableMap, registerTableCache, &#x27;
                         &#x27;streamQueryConfig);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (env instanceof MyLocalStreamEnvironment) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            ((MyLocalStreamEnvironment) &#x27;
                         &#x27;env).setClasspaths(ClassLoaderManager.getClassPath());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return env;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static List&lt;URL&gt; &#x27;
                         &#x27;getExternalJarUrls(String addJarListStr) throws &#x27;
                         &#x27;java.io.IOException {\n&#x27;
                         &#x27;        List&lt;URL&gt; jarUrlList = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;        if (Strings.isNullOrEmpty(addJarListStr)) {\n&#x27;
                         &#x27;            return jarUrlList;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; addJarFileList = &#x27;
                         &#x27;OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, &#x27;
                         &#x27;Charsets.UTF_8.name()), List.class);\n&#x27;
                         &#x27;        //Get External jar to load\n&#x27;
                         &#x27;        for (String addJarPath : addJarFileList) {\n&#x27;
                         &#x27;            jarUrlList.add(new &#x27;
                         &#x27;File(addJarPath).toURI().toURL());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return jarUrlList;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static void sqlTranslation(String &#x27;
                         &#x27;localSqlPluginPath,\n&#x27;
                         &#x27;                                       &#x27;
                         &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                         &#x27;                                       SqlTree &#x27;
                         &#x27;sqlTree,Map&lt;String, AbstractSideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                                       Map&lt;String, &#x27;
                         &#x27;Table&gt; registerTableCache,\n&#x27;
                         &#x27;                                       &#x27;
                         &#x27;StreamQueryConfig queryConfig) throws Exception {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        SideSqlExec sideSqlExec = new &#x27;
                         &#x27;SideSqlExec();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);\n&#x27;
                         &#x27;        for (CreateTmpTableParser.SqlParserResult &#x27;
                         &#x27;result : sqlTree.getTmpSqlList()) {\n&#x27;
                         &#x27;            sideSqlExec.exec(result.getExecSql(), &#x27;
                         &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                         &#x27;queryConfig, result);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (InsertSqlParser.SqlParseResult result : &#x27;
                         &#x27;sqlTree.getExecSqlList()) {\n&#x27;
                         &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                         &#x27;                LOG.info(&quot;exe-sql:\\n&quot; + &#x27;
                         &#x27;result.getExecSql());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            boolean isSide = false;\n&#x27;
                         &#x27;            for (String tableName : &#x27;
                         &#x27;result.getTargetTableList()) {\n&#x27;
                         &#x27;                if &#x27;
                         &#x27;(sqlTree.getTmpTableMap().containsKey(tableName)) {\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult tmp = &#x27;
                         &#x27;sqlTree.getTmpTableMap().get(tableName);\n&#x27;
                         &#x27;                    String realSql = &#x27;
                         &#x27;DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &#x27;
                         &#x27;&quot;`&quot;, &quot;&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                    SqlNode sqlNode = &#x27;
                         &#x27;org.apache.calcite.sql.parser.SqlParser.create(realSql, &#x27;
                         &#x27;CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();\n&#x27;
                         &#x27;                    String tmpSql = ((SqlInsert) &#x27;
                         &#x27;sqlNode).getSource().toString();\n&#x27;
                         &#x27;                    tmp.setExecSql(tmpSql);\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;sideSqlExec.exec(tmp.getExecSql(), sideTableMap, &#x27;
                         &#x27;tableEnv, registerTableCache, queryConfig, tmp);\n&#x27;
                         &#x27;                } else {\n&#x27;
                         &#x27;                    for (String sourceTable : &#x27;
                         &#x27;result.getSourceTableList()) {\n&#x27;
                         &#x27;                        if &#x27;
                         &#x27;(sideTableMap.containsKey(sourceTable)) {\n&#x27;
                         &#x27;                            isSide = true;\n&#x27;
                         &#x27;                            break;\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    if (isSide) {\n&#x27;
                         &#x27;                        //sql-dimensional table &#x27;
                         &#x27;contains the dimension table of execution\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;sideSqlExec.exec(result.getExecSql(), sideTableMap, &#x27;
                         &#x27;tableEnv, registerTableCache, queryConfig, null);\n&#x27;
                         &#x27;                    } else {\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;System.out.println(&quot;----------exec sql without &#x27;
                         &#x27;dimension join-----------&quot;);\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;System.out.println(&quot;----------real sql exec &#x27;
                         &#x27;is--------------------------&quot;);\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;System.out.println(result.getExecSql());\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                         &#x27;result.getExecSql(), queryConfig);\n&#x27;
                         &#x27;                        if (LOG.isInfoEnabled()) {\n&#x27;
                         &#x27;                            System.out.println();\n&#x27;
                         &#x27;                            LOG.info(&quot;exec sql: &quot; + &#x27;
                         &#x27;result.getExecSql());\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static void &#x27;
                         &#x27;registerUserDefinedFunction(SqlTree sqlTree, &#x27;
                         &#x27;List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)\n&#x27;
                         &#x27;            throws IllegalAccessException, &#x27;
                         &#x27;InvocationTargetException {\n&#x27;
                         &#x27;        // udf和tableEnv须由同一个类加载器加载\n&#x27;
                         &#x27;        ClassLoader levelClassLoader = &#x27;
                         &#x27;tableEnv.getClass().getClassLoader();\n&#x27;
                         &#x27;        URLClassLoader classLoader = null;\n&#x27;
                         &#x27;        List&lt;CreateFuncParser.SqlParserResult&gt; &#x27;
                         &#x27;funcList = sqlTree.getFunctionList();\n&#x27;
                         &#x27;        for (CreateFuncParser.SqlParserResult &#x27;
                         &#x27;funcInfo : funcList) {\n&#x27;
                         &#x27;            //classloader\n&#x27;
                         &#x27;            if (classLoader == null) {\n&#x27;
                         &#x27;                classLoader = &#x27;
                         &#x27;ClassLoaderManager.loadExtraJar(jarUrlList, &#x27;
                         &#x27;(URLClassLoader) levelClassLoader);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            &#x27;
                         &#x27;FunctionManager.registerUDF(funcInfo.getType(), &#x27;
                         &#x27;funcInfo.getClassName(), funcInfo.getName(), &#x27;
                         &#x27;tableEnv, classLoader);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     *    向Flink注册源表和结果表，返回执行时插件包的全路径\n&#x27;
                         &#x27;     * @param sqlTree\n&#x27;
                         &#x27;     * @param env\n&#x27;
                         &#x27;     * @param tableEnv\n&#x27;
                         &#x27;     * @param localSqlPluginPath\n&#x27;
                         &#x27;     * @param remoteSqlPluginPath\n&#x27;
                         &#x27;     * @param pluginLoadMode   插件加载模式 classpath or &#x27;
                         &#x27;shipfile\n&#x27;
                         &#x27;     * @param sideTableMap\n&#x27;
                         &#x27;     * @param registerTableCache\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     * @throws Exception\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public static Set&lt;URL&gt; registerTable(SqlTree &#x27;
                         &#x27;sqlTree, StreamExecutionEnvironment env, &#x27;
                         &#x27;StreamTableEnvironment tableEnv, String &#x27;
                         &#x27;localSqlPluginPath,\n&#x27;
                         &#x27;                                         String &#x27;
                         &#x27;remoteSqlPluginPath, String pluginLoadMode, &#x27;
                         &#x27;Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, &#x27;
                         &#x27;Map&lt;String, Table&gt; registerTableCache) throws &#x27;
                         &#x27;Exception {\n&#x27;
                         &#x27;        Set&lt;URL&gt; pluginClassPatshSets = &#x27;
                         &#x27;Sets.newHashSet();\n&#x27;
                         &#x27;        WaterMarkerAssigner waterMarkerAssigner = &#x27;
                         &#x27;new WaterMarkerAssigner();\n&#x27;
                         &#x27;        for (AbstractTableInfo tableInfo : &#x27;
                         &#x27;sqlTree.getTableInfoMap().values()) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if (tableInfo instanceof &#x27;
                         &#x27;AbstractSourceTableInfo) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                AbstractSourceTableInfo &#x27;
                         &#x27;sourceTableInfo = (AbstractSourceTableInfo) &#x27;
                         &#x27;tableInfo;\n&#x27;
                         &#x27;                Table table = &#x27;
                         &#x27;StreamSourceFactory.getStreamSource(sourceTableInfo, &#x27;
                         &#x27;env, tableEnv, localSqlPluginPath);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;tableEnv.registerTable(sourceTableInfo.getAdaptName(), &#x27;
                         &#x27;table);\n&#x27;
                         &#x27;                //Note --- parameter conversion &#x27;
                         &#x27;function can not be used inside a function of the &#x27;
                         &#x27;type of polymerization\n&#x27;
                         &#x27;                //Create table in which the function &#x27;
                         &#x27;is arranged only need adaptation sql\n&#x27;
                         &#x27;                String adaptSql = &#x27;
                         &#x27;sourceTableInfo.getAdaptSelectSql();\n&#x27;
                         &#x27;                Table adaptTable = adaptSql == null &#x27;
                         &#x27;? table : tableEnv.sqlQuery(adaptSql);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                RowTypeInfo typeInfo = new &#x27;
                         &#x27;RowTypeInfo(adaptTable.getSchema().getFieldTypes(), &#x27;
                         &#x27;adaptTable.getSchema().getFieldNames());\n&#x27;
                         &#x27;                DataStream adaptStream = &#x27;
                         &#x27;tableEnv.toRetractStream(adaptTable, typeInfo)\n&#x27;
                         &#x27;                        .map((Tuple2&lt;Boolean, Row&gt; &#x27;
                         &#x27;f0) -&gt; {\n&#x27;
                         &#x27;                            return f0.f1;\n&#x27;
                         &#x27;                        })\n&#x27;
                         &#x27;                        .returns(typeInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                String fields = String.join(&quot;,&quot;, &#x27;
                         &#x27;typeInfo.getFieldNames());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                if &#x27;
                         &#x27;(waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                    adaptStream = &#x27;
                         &#x27;waterMarkerAssigner.assignWaterMarker(adaptStream, &#x27;
                         &#x27;typeInfo, sourceTableInfo);\n&#x27;
                         &#x27;                    fields += &quot;,ROWTIME.ROWTIME&quot;;\n&#x27;
                         &#x27;                } else {\n&#x27;
                         &#x27;                    fields += &quot;,PROCTIME.PROCTIME&quot;;\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                Table regTable = &#x27;
                         &#x27;tableEnv.fromDataStream(adaptStream, fields);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;tableEnv.registerTable(tableInfo.getName(), &#x27;
                         &#x27;regTable);\n&#x27;
                         &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                         &#x27;                    LOG.info(&quot;registe table {} &#x27;
                         &#x27;success.&quot;, tableInfo.getName());\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                &#x27;
                         &#x27;registerTableCache.put(tableInfo.getName(), &#x27;
                         &#x27;regTable);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                URL sourceTablePathUrl = &#x27;
                         &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                         &#x27;AbstractSourceTableInfo.SOURCE_SUFFIX, &#x27;
                         &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                         &#x27;pluginLoadMode);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;pluginClassPatshSets.add(sourceTablePathUrl);\n&#x27;
                         &#x27;            } else if (tableInfo instanceof &#x27;
                         &#x27;AbstractTargetTableInfo) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                TableSink tableSink = &#x27;
                         &#x27;StreamSinkFactory.getTableSink((AbstractTargetTableInfo) &#x27;
                         &#x27;tableInfo, localSqlPluginPath);\n&#x27;
                         &#x27;                TypeInformation[] flinkTypes = &#x27;
                         &#x27;FunctionManager.transformTypes(tableInfo.getFieldClasses());\n&#x27;
                         &#x27;                &#x27;
                         &#x27;tableEnv.registerTableSink(tableInfo.getName(), &#x27;
                         &#x27;tableInfo.getFields(), flinkTypes, tableSink);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                URL sinkTablePathUrl = &#x27;
                         &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                         &#x27;AbstractTargetTableInfo.TARGET_SUFFIX, &#x27;
                         &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                         &#x27;pluginLoadMode);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;pluginClassPatshSets.add(sinkTablePathUrl);\n&#x27;
                         &#x27;            } else if (tableInfo instanceof &#x27;
                         &#x27;AbstractSideTableInfo) {\n&#x27;
                         &#x27;                String sideOperator = &#x27;
                         &#x27;ECacheType.ALL.name().equals(((AbstractSideTableInfo) &#x27;
                         &#x27;tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;\n&#x27;
                         &#x27;                &#x27;
                         &#x27;sideTableMap.put(tableInfo.getName(), &#x27;
                         &#x27;(AbstractSideTableInfo) tableInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                URL sideTablePathUrl = &#x27;
                         &#x27;PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), &#x27;
                         &#x27;sideOperator, AbstractSideTableInfo.TARGET_SUFFIX, &#x27;
                         &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                         &#x27;pluginLoadMode);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;pluginClassPatshSets.add(sideTablePathUrl);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                throw new RuntimeException(&quot;not &#x27;
                         &#x27;support table type:&quot; + tableInfo.getType());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return pluginClassPatshSets;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     *   &#x27;
                         &#x27;perjob模式将job依赖的插件包路径存储到cacheFile，在外围将插件包路径传递给jobgraph\n&#x27;
                         &#x27;     * @param env\n&#x27;
                         &#x27;     * @param classPathSet\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public static void &#x27;
                         &#x27;registerPluginUrlToCachedFile(StreamExecutionEnvironment &#x27;
                         &#x27;env, Set&lt;URL&gt; classPathSet) {\n&#x27;
                         &#x27;        int i = 0;\n&#x27;
                         &#x27;        for (URL url : classPathSet) {\n&#x27;
                         &#x27;            String classFileName = &#x27;
                         &#x27;String.format(CLASS_FILE_NAME_FMT, i);\n&#x27;
                         &#x27;            env.registerCachedFile(url.getPath(), &#x27;
                         &#x27;classFileName, true);\n&#x27;
                         &#x27;            i++;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static StreamExecutionEnvironment &#x27;
                         &#x27;getStreamExeEnv(Properties confProperties, String &#x27;
                         &#x27;deployMode) throws Exception {\n&#x27;
                         &#x27;        StreamExecutionEnvironment env = &#x27;
                         &#x27;!ClusterMode.local.name().equals(deployMode) ?\n&#x27;
                         &#x27;                &#x27;
                         &#x27;StreamExecutionEnvironment.getExecutionEnvironment() &#x27;
                         &#x27;:\n&#x27;
                         &#x27;                new MyLocalStreamEnvironment();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, &#x27;
                         &#x27;confProperties);\n&#x27;
                         &#x27;        return env;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static void setLogLevel(ParamsInfo &#x27;
                         &#x27;paramsInfo){\n&#x27;
                         &#x27;        String logLevel = &#x27;
                         &#x27;paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        ChangeLogLevelProcess logLevelProcess = new &#x27;
                         &#x27;ChangeLogLevelProcess();\n&#x27;
                         &#x27;        logLevelProcess.process(logLevel);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.StreamQueryConfig;\n&#x27;
                           &#x27;import org.apache.flink.table.api.Table;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.TableEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.java.StreamTableEnvironment;\n&#x27;
                           &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.classloader.ClassLoaderManager;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.config.CalciteConfig;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ClusterMode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.enums.EPluginLoadMode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.environment.StreamEnvConfigManager;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.function.FunctionManager;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.option.OptionParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.option.Options;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateFuncParser;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTmpTableParser;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.InsertSqlParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.SqlParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.SqlTree;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideSqlExec;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.table.SourceTableInfo;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.table.TableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.PluginUtil;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import com.google.common.base.Preconditions;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import com.google.common.collect.Sets;\n&#x27;
                           &#x27;import org.apache.calcite.sql.SqlInsert;\n&#x27;
                           &#x27;import org.apache.calcite.sql.SqlNode;\n&#x27;
                           &#x27;import org.apache.commons.io.Charsets;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import org.slf4j.Logger;\n&#x27;
                           &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.lang.reflect.InvocationTargetException;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLClassLoader;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *  任务执行时的流程方法\n&#x27;
                           &#x27; * Date: 2020/2/17\n&#x27;
                           &#x27; * Company: www.dtstack.com\n&#x27;
                           &#x27; * @author maqi\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class ExecuteProcessHelper {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final String &#x27;
                           &#x27;CLASS_FILE_NAME_FMT = &quot;class_path_%d&quot;;\n&#x27;
                           &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(ExecuteProcessHelper.class);\n&#x27;
                           &#x27;    private static final ObjectMapper &#x27;
                           &#x27;OBJECT_MAPPER = new ObjectMapper();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static ParamsInfo parseParams(String[] &#x27;
                           &#x27;args) throws Exception {\n&#x27;
                           &#x27;        LOG.info(&quot;------------program &#x27;
                           &#x27;params-------------------------&quot;);\n&#x27;
                           &#x27;        System.out.println(&quot;------------program &#x27;
                           &#x27;params-------------------------&quot;);\n&#x27;
                           &#x27;        Arrays.stream(args).forEach(arg -&gt; &#x27;
                           &#x27;LOG.info(&quot;{}&quot;, arg));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;Arrays.stream(args).forEach(System.out::println);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;LOG.info(&quot;-------------------------------------------&quot;);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;System.out.println(&quot;----------------------------------------&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        OptionParser optionParser = new &#x27;
                           &#x27;OptionParser(args);\n&#x27;
                           &#x27;        Options options = &#x27;
                           &#x27;optionParser.getOptions();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String sql = &#x27;
                           &#x27;URLDecoder.decode(options.getSql(), &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;        String name = options.getName();\n&#x27;
                           &#x27;        String localSqlPluginPath = &#x27;
                           &#x27;options.getLocalSqlPluginPath();\n&#x27;
                           &#x27;        String remoteSqlPluginPath = &#x27;
                           &#x27;options.getRemoteSqlPluginPath();\n&#x27;
                           &#x27;        String pluginLoadMode = &#x27;
                           &#x27;options.getPluginLoadMode();\n&#x27;
                           &#x27;        String deployMode = options.getMode();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, &#x27;
                           &#x27;deployMode, pluginLoadMode),\n&#x27;
                           &#x27;                &quot;Non-local mode or shipfile &#x27;
                           &#x27;deployment mode, remoteSqlPluginPath is &#x27;
                           &#x27;required&quot;);\n&#x27;
                           &#x27;        String confProp = &#x27;
                           &#x27;URLDecoder.decode(options.getConfProp(), &#x27;
                           &#x27;Charsets.UTF_8.toString());\n&#x27;
                           &#x27;        Properties confProperties = &#x27;
                           &#x27;PluginUtil.jsonStrToObject(confProp, &#x27;
                           &#x27;Properties.class);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;URL&gt; jarURList = &#x27;
                           &#x27;getExternalJarUrls(options.getAddjar());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return ParamsInfo.builder()\n&#x27;
                           &#x27;                .setSql(sql)\n&#x27;
                           &#x27;                .setName(name)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;.setLocalSqlPluginPath(localSqlPluginPath)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;.setRemoteSqlPluginPath(remoteSqlPluginPath)\n&#x27;
                           &#x27;                &#x27;
                           &#x27;.setPluginLoadMode(pluginLoadMode)\n&#x27;
                           &#x27;                .setDeployMode(deployMode)\n&#x27;
                           &#x27;                .setConfProp(confProperties)\n&#x27;
                           &#x27;                .setJarUrlList(jarURList)\n&#x27;
                           &#x27;                .build();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   &#x27;
                           &#x27;非local模式或者shipfile部署模式，remoteSqlPluginPath必填\n&#x27;
                           &#x27;     * @param remoteSqlPluginPath\n&#x27;
                           &#x27;     * @param deployMode\n&#x27;
                           &#x27;     * @param pluginLoadMode\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static boolean &#x27;
                           &#x27;checkRemoteSqlPluginPath(String &#x27;
                           &#x27;remoteSqlPluginPath, String deployMode, String &#x27;
                           &#x27;pluginLoadMode) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(StringUtils.isEmpty(remoteSqlPluginPath)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;StringUtils.equalsIgnoreCase(pluginLoadMode, &#x27;
                           &#x27;EPluginLoadMode.SHIPFILE.name())\n&#x27;
                           &#x27;                    || &#x27;
                           &#x27;StringUtils.equalsIgnoreCase(deployMode, &#x27;
                           &#x27;ClusterMode.local.name());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static StreamExecutionEnvironment &#x27;
                           &#x27;getStreamExecution(ParamsInfo paramsInfo) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), &#x27;
                           &#x27;paramsInfo.getDeployMode());\n&#x27;
                           &#x27;        StreamTableEnvironment tableEnv = &#x27;
                           &#x27;StreamTableEnvironment.create(env);\n&#x27;
                           &#x27;        StreamQueryConfig streamQueryConfig = &#x27;
                           &#x27;StreamEnvConfigManager.getStreamQueryConfig(tableEnv, &#x27;
                           &#x27;paramsInfo.getConfProp());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());\n&#x27;
                           &#x27;        SqlTree sqlTree = &#x27;
                           &#x27;SqlParser.parseSql(paramsInfo.getSql());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, SideTableInfo&gt; sideTableMap = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;        Map&lt;String, Table&gt; registerTableCache = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //register udf\n&#x27;
                           &#x27;        &#x27;
                           &#x27;ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, &#x27;
                           &#x27;paramsInfo.getJarUrlList(), tableEnv);\n&#x27;
                           &#x27;        //register table schema\n&#x27;
                           &#x27;        Set&lt;URL&gt; classPathSets = &#x27;
                           &#x27;ExecuteProcessHelper.registerTable(sqlTree, env, &#x27;
                           &#x27;tableEnv, paramsInfo.getLocalSqlPluginPath(),\n&#x27;
                           &#x27;                &#x27;
                           &#x27;paramsInfo.getRemoteSqlPluginPath(), &#x27;
                           &#x27;paramsInfo.getPluginLoadMode(), sideTableMap, &#x27;
                           &#x27;registerTableCache);\n&#x27;
                           &#x27;        // cache classPathSets\n&#x27;
                           &#x27;        &#x27;
                           &#x27;ExecuteProcessHelper.registerPluginUrlToCachedFile(env, &#x27;
                           &#x27;classPathSets);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), &#x27;
                           &#x27;tableEnv, sqlTree, sideTableMap, &#x27;
                           &#x27;registerTableCache, streamQueryConfig);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (env instanceof &#x27;
                           &#x27;MyLocalStreamEnvironment) {\n&#x27;
                           &#x27;            ((MyLocalStreamEnvironment) &#x27;
                           &#x27;env).setClasspaths(ClassLoaderManager.getClassPath());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return env;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static List&lt;URL&gt; &#x27;
                           &#x27;getExternalJarUrls(String addJarListStr) throws &#x27;
                           &#x27;java.io.IOException {\n&#x27;
                           &#x27;        List&lt;URL&gt; jarUrlList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        if (Strings.isNullOrEmpty(addJarListStr)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            return jarUrlList;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; addJarFileList = &#x27;
                           &#x27;OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, &#x27;
                           &#x27;Charsets.UTF_8.name()), List.class);\n&#x27;
                           &#x27;        //Get External jar to load\n&#x27;
                           &#x27;        for (String addJarPath : addJarFileList) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            jarUrlList.add(new &#x27;
                           &#x27;File(addJarPath).toURI().toURL());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return jarUrlList;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static void sqlTranslation(String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;            StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;            SqlTree sqlTree,Map&lt;String, &#x27;
                           &#x27;SideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;            Map&lt;String, Table&gt; &#x27;
                           &#x27;registerTableCache,\n&#x27;
                           &#x27;            StreamQueryConfig queryConfig) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    \tSideSqlExec sideSqlExec = new &#x27;
                           &#x27;SideSqlExec();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);\n&#x27;
                           &#x27;        for (CreateTmpTableParser.SqlParserResult &#x27;
                           &#x27;result : sqlTree.getTmpSqlList()) {\n&#x27;
                           &#x27;            sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, result);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (InsertSqlParser.SqlParseResult result &#x27;
                           &#x27;: sqlTree.getExecSqlList()) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;exe-sql:\\n&quot; + &#x27;
                           &#x27;result.getExecSql());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            boolean isSide = false;\n&#x27;
                           &#x27;            for (String tableName : &#x27;
                           &#x27;result.getTargetTableList()) {\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(sqlTree.getTmpTableMap().containsKey(tableName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult tmp = &#x27;
                           &#x27;sqlTree.getTmpTableMap().get(tableName);\n&#x27;
                           &#x27;                    String realSql = &#x27;
                           &#x27;DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &#x27;
                           &#x27;&quot;`&quot;, &quot;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    SqlNode sqlNode = &#x27;
                           &#x27;org.apache.calcite.sql.parser.SqlParser.create(realSql, &#x27;
                           &#x27;CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();\n&#x27;
                           &#x27;                    String tmpSql = ((SqlInsert) &#x27;
                           &#x27;sqlNode).getSource().toString();\n&#x27;
                           &#x27;                    tmp.setExecSql(tmpSql);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;sideSqlExec.exec(tmp.getExecSql(), sideTableMap, &#x27;
                           &#x27;tableEnv, registerTableCache, queryConfig, tmp);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    for (String sourceTable : &#x27;
                           &#x27;result.getSourceTableList()) {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sideTableMap.containsKey(sourceTable)) {\n&#x27;
                           &#x27;                            isSide = true;\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    if (isSide) {\n&#x27;
                           &#x27;                        //sql-dimensional table &#x27;
                           &#x27;contains the dimension table of execution\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, null);\n&#x27;
                           &#x27;                    } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------exec sql without &#x27;
                           &#x27;dimension join-----------&quot;);\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------real sql exec &#x27;
                           &#x27;is--------------------------&quot;);\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(result.getExecSql());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                           &#x27;result.getExecSql(), queryConfig);\n&#x27;
                           &#x27;                        if (LOG.isInfoEnabled()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                            LOG.info(&quot;exec sql: &quot; &#x27;
                           &#x27;+ result.getExecSql());\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static void &#x27;
                           &#x27;registerUserDefinedFunction(SqlTree sqlTree, &#x27;
                           &#x27;List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)\n&#x27;
                           &#x27;            throws IllegalAccessException, &#x27;
                           &#x27;InvocationTargetException {\n&#x27;
                           &#x27;        // udf和tableEnv须由同一个类加载器加载\n&#x27;
                           &#x27;        ClassLoader levelClassLoader = &#x27;
                           &#x27;tableEnv.getClass().getClassLoader();\n&#x27;
                           &#x27;        URLClassLoader classLoader = null;\n&#x27;
                           &#x27;        List&lt;CreateFuncParser.SqlParserResult&gt; &#x27;
                           &#x27;funcList = sqlTree.getFunctionList();\n&#x27;
                           &#x27;        for (CreateFuncParser.SqlParserResult &#x27;
                           &#x27;funcInfo : funcList) {\n&#x27;
                           &#x27;            //classloader\n&#x27;
                           &#x27;            if (classLoader == null) {\n&#x27;
                           &#x27;                classLoader = &#x27;
                           &#x27;ClassLoaderManager.loadExtraJar(jarUrlList, &#x27;
                           &#x27;(URLClassLoader) levelClassLoader);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;FunctionManager.registerUDF(funcInfo.getType(), &#x27;
                           &#x27;funcInfo.getClassName(), funcInfo.getName(), &#x27;
                           &#x27;tableEnv, classLoader);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *    向Flink注册源表和结果表，返回执行时插件包的全路径\n&#x27;
                           &#x27;     * @param sqlTree\n&#x27;
                           &#x27;     * @param env\n&#x27;
                           &#x27;     * @param tableEnv\n&#x27;
                           &#x27;     * @param localSqlPluginPath\n&#x27;
                           &#x27;     * @param remoteSqlPluginPath\n&#x27;
                           &#x27;     * @param pluginLoadMode   插件加载模式 classpath or &#x27;
                           &#x27;shipfile\n&#x27;
                           &#x27;     * @param sideTableMap\n&#x27;
                           &#x27;     * @param registerTableCache\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     * @throws Exception\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static Set&lt;URL&gt; registerTable(SqlTree &#x27;
                           &#x27;sqlTree, StreamExecutionEnvironment env, &#x27;
                           &#x27;StreamTableEnvironment tableEnv, String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;                                         String &#x27;
                           &#x27;remoteSqlPluginPath, String pluginLoadMode, &#x27;
                           &#x27;Map&lt;String, SideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;Map&lt;String, Table&gt; registerTableCache) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;        Set&lt;URL&gt; pluginClassPatshSets = &#x27;
                           &#x27;Sets.newHashSet();\n&#x27;
                           &#x27;        WaterMarkerAssigner waterMarkerAssigner = &#x27;
                           &#x27;new WaterMarkerAssigner();\n&#x27;
                           &#x27;        for (TableInfo tableInfo : &#x27;
                           &#x27;sqlTree.getTableInfoMap().values()) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (tableInfo instanceof &#x27;
                           &#x27;SourceTableInfo) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SourceTableInfo sourceTableInfo = &#x27;
                           &#x27;(SourceTableInfo) tableInfo;\n&#x27;
                           &#x27;                Table table = &#x27;
                           &#x27;StreamSourceFactory.getStreamSource(sourceTableInfo, &#x27;
                           &#x27;env, tableEnv, localSqlPluginPath);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTable(sourceTableInfo.getAdaptName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                //Note --- parameter conversion &#x27;
                           &#x27;function can not be used inside a function of the &#x27;
                           &#x27;type of polymerization\n&#x27;
                           &#x27;                //Create table in which the &#x27;
                           &#x27;function is arranged only need adaptation sql\n&#x27;
                           &#x27;                String adaptSql = &#x27;
                           &#x27;sourceTableInfo.getAdaptSelectSql();\n&#x27;
                           &#x27;                Table adaptTable = adaptSql == &#x27;
                           &#x27;null ? table : tableEnv.sqlQuery(adaptSql);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                RowTypeInfo typeInfo = new &#x27;
                           &#x27;RowTypeInfo(adaptTable.getSchema().getFieldTypes(), &#x27;
                           &#x27;adaptTable.getSchema().getFieldNames());\n&#x27;
                           &#x27;                DataStream adaptStream = &#x27;
                           &#x27;tableEnv.toRetractStream(adaptTable, typeInfo)\n&#x27;
                           &#x27;                        .map((Tuple2&lt;Boolean, Row&gt; &#x27;
                           &#x27;f0) -&gt; {\n&#x27;
                           &#x27;                            return f0.f1;\n&#x27;
                           &#x27;                        })\n&#x27;
                           &#x27;                        .returns(typeInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                String fields = String.join(&quot;,&quot;, &#x27;
                           &#x27;typeInfo.getFieldNames());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    adaptStream = &#x27;
                           &#x27;waterMarkerAssigner.assignWaterMarker(adaptStream, &#x27;
                           &#x27;typeInfo, sourceTableInfo);\n&#x27;
                           &#x27;                    fields += &quot;,ROWTIME.ROWTIME&quot;;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    fields += &#x27;
                           &#x27;&quot;,PROCTIME.PROCTIME&quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                Table regTable = &#x27;
                           &#x27;tableEnv.fromDataStream(adaptStream, fields);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTable(tableInfo.getName(), &#x27;
                           &#x27;regTable);\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;registe table {} &#x27;
                           &#x27;success.&quot;, tableInfo.getName());\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;registerTableCache.put(tableInfo.getName(), &#x27;
                           &#x27;regTable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sourceTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;SourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, &#x27;
                           &#x27;remoteSqlPluginPath, pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sourceTablePathUrl);\n&#x27;
                           &#x27;            } else if (tableInfo instanceof &#x27;
                           &#x27;TargetTableInfo) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                TableSink tableSink = &#x27;
                           &#x27;StreamSinkFactory.getTableSink((TargetTableInfo) &#x27;
                           &#x27;tableInfo, localSqlPluginPath);\n&#x27;
                           &#x27;                TypeInformation[] flinkTypes = &#x27;
                           &#x27;FunctionManager.transformTypes(tableInfo.getFieldClasses());\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTableSink(tableInfo.getName(), &#x27;
                           &#x27;tableInfo.getFields(), flinkTypes, tableSink);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sinkTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;TargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, &#x27;
                           &#x27;remoteSqlPluginPath, pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sinkTablePathUrl);\n&#x27;
                           &#x27;            } else if (tableInfo instanceof &#x27;
                           &#x27;SideTableInfo) {\n&#x27;
                           &#x27;                String sideOperator = &#x27;
                           &#x27;ECacheType.ALL.name().equals(((SideTableInfo) &#x27;
                           &#x27;tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;\n&#x27;
                           &#x27;                &#x27;
                           &#x27;sideTableMap.put(tableInfo.getName(), &#x27;
                           &#x27;(SideTableInfo) tableInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sideTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;sideOperator, SideTableInfo.TARGET_SUFFIX, &#x27;
                           &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                           &#x27;pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sideTablePathUrl);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;not &#x27;
                           &#x27;support table type:&quot; + tableInfo.getType());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return pluginClassPatshSets;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   &#x27;
                           &#x27;perjob模式将job依赖的插件包路径存储到cacheFile，在外围将插件包路径传递给jobgraph\n&#x27;
                           &#x27;     * @param env\n&#x27;
                           &#x27;     * @param classPathSet\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public static void &#x27;
                           &#x27;registerPluginUrlToCachedFile(StreamExecutionEnvironment &#x27;
                           &#x27;env, Set&lt;URL&gt; classPathSet) {\n&#x27;
                           &#x27;        int i = 0;\n&#x27;
                           &#x27;        for (URL url : classPathSet) {\n&#x27;
                           &#x27;            String classFileName = &#x27;
                           &#x27;String.format(CLASS_FILE_NAME_FMT, i);\n&#x27;
                           &#x27;            env.registerCachedFile(url.getPath(), &#x27;
                           &#x27;classFileName, true);\n&#x27;
                           &#x27;            i++;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static StreamExecutionEnvironment &#x27;
                           &#x27;getStreamExeEnv(Properties confProperties, String &#x27;
                           &#x27;deployMode) throws Exception {\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;!ClusterMode.local.name().equals(deployMode) ?\n&#x27;
                           &#x27;                &#x27;
                           &#x27;StreamExecutionEnvironment.getExecutionEnvironment() &#x27;
                           &#x27;:\n&#x27;
                           &#x27;                new MyLocalStreamEnvironment();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, &#x27;
                           &#x27;confProperties);\n&#x27;
                           &#x27;        return env;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        List&lt;URL&gt; jarUrlList = &#x27;
                         &#x27;getExternalJarUrls(options.getAddjar());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        List&lt;URL&gt; jarURList = &#x27;
                           &#x27;getExternalJarUrls(options.getAddjar());\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;jarUrlList\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\njarURList\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;{\n&#x27;
                         &#x27;                            System.out.println();\n&#x27;
                         &#x27;                            LOG.info(&quot;exec sql: &quot; + &#x27;
                         &#x27;result.getExecSql());\n&#x27;
                         &#x27;                        }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;{\n&#x27;
                           &#x27;                            LOG.info(&quot;exec sql: &quot; &#x27;
                           &#x27;+ result.getExecSql());\n&#x27;
                           &#x27;                        }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSourceTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSourceTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSourceTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSourceTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSourceTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSourceTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSourceTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSourceTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractTargetTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nTargetTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractTargetTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nTargetTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractTargetTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nTargetTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;AbstractSideTableInfo\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nSideTableInfo\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                .setJarUrlList(jarUrlList)\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                .setJarUrlList(jarURList)\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private static void sqlTranslation(String &#x27;
                         &#x27;localSqlPluginPath,\n&#x27;
                         &#x27;                                       &#x27;
                         &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                         &#x27;                                       SqlTree &#x27;
                         &#x27;sqlTree,Map&lt;String, AbstractSideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                                       Map&lt;String, &#x27;
                         &#x27;Table&gt; registerTableCache,\n&#x27;
                         &#x27;                                       &#x27;
                         &#x27;StreamQueryConfig queryConfig) throws Exception {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        SideSqlExec sideSqlExec = new &#x27;
                         &#x27;SideSqlExec();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    \tSideSqlExec sideSqlExec = new &#x27;
                           &#x27;SideSqlExec();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public static void setLogLevel(ParamsInfo &#x27;
                         &#x27;paramsInfo){\n&#x27;
                         &#x27;        String logLevel = &#x27;
                         &#x27;paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        ChangeLogLevelProcess logLevelProcess = new &#x27;
                         &#x27;ChangeLogLevelProcess();\n&#x27;
                         &#x27;        logLevelProcess.process(logLevel);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}]]</pre>
          </body>
        </html>
        