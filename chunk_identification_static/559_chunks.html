<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>559 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.annotation.PublicEvolving;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowDeserializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectWriter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvSchema;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a CSV bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input row into a {@link &#x27;
                           &#x27;ObjectNode} and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Result &lt;code&gt;byte[]&lt;/code&gt; messages can be &#x27;
                           &#x27;deserialized using {@link &#x27;
                           &#x27;CsvRowDeserializationSchema}.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@PublicEvolving\n&#x27;
                           &#x27;public final class CsvCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static final long serialVersionUID = &#x27;
                           &#x27;2098447220136965L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Type information describing the input CSV &#x27;
                           &#x27;data. */\n&#x27;
                           &#x27;\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Runtime instance that performs the actual &#x27;
                           &#x27;work. */\n&#x27;
                           &#x27;\tprivate final RuntimeConverter &#x27;
                           &#x27;runtimeConverter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** CsvMapper used to write {@link JsonNode} &#x27;
                           &#x27;into bytes. */\n&#x27;
                           &#x27;\tprivate final CsvMapper csvMapper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Schema describing the input CSV data. */\n&#x27;
                           &#x27;\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Object writer used to write rows. It is &#x27;
                           &#x27;configured by {@link CsvSchema}. */\n&#x27;
                           &#x27;\tprivate ObjectWriter objectWriter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Reusable object node. */\n&#x27;
                           &#x27;\tprivate transient ObjectNode root;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\tRowTypeInfo typeInfo,\n&#x27;
                           &#x27;\t\t\tCsvSchema csvSchema,\n&#x27;
                           &#x27;\t\t\tString updateMode) {\n&#x27;
                           &#x27;\t\tthis.typeInfo = typeInfo;\n&#x27;
                           &#x27;\t\tthis.runtimeConverter = &#x27;
                           &#x27;createRowRuntimeConverter(typeInfo, true);\n&#x27;
                           &#x27;\t\tthis.csvMapper = new CsvMapper();\n&#x27;
                           &#x27;\t\tthis.csvSchema = csvSchema;\n&#x27;
                           &#x27;\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/**\n&#x27;
                           &#x27;\t * A builder for creating a {@link &#x27;
                           &#x27;CsvRowSerializationSchema}.\n&#x27;
                           &#x27;\t */\n&#x27;
                           &#x27;\t@PublicEvolving\n&#x27;
                           &#x27;\tpublic static class Builder {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\t\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\t\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t/**\n&#x27;
                           &#x27;\t\t * Creates a {@link CsvRowSerializationSchema} &#x27;
                           &#x27;expecting the given {@link TypeInformation}.\n&#x27;
                           &#x27;\t\t *\n&#x27;
                           &#x27;\t\t * @param typeInfo type information used to &#x27;
                           &#x27;create schema.\n&#x27;
                           &#x27;\t\t */\n&#x27;
                           &#x27;\t\tpublic Builder(TypeInformation&lt;CRow&gt; typeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information must not be null.&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\tif (!(typeInfo instanceof CRowTypeInfo)) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(&quot;Row &#x27;
                           &#x27;type information expected.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tRowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;\t\t\tthis.typeInfo = rowTypeInfo;\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;CsvRowSchemaConverter.convert(rowTypeInfo);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setFieldDelimiter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setColumnSeparator(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setLineDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tif (!(&quot;\\n&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r\\n&quot;.equals(delimiter))) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(\n&#x27;
                           &#x27;\t\t\t\t\t\t&quot;Unsupported new line delimiter. Only &#x27;
                           &#x27;\\\\n, \\\\r, or \\\\r\\\\n are supported.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setLineSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setArrayElementDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setArrayElementSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setQuoteCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setQuoteChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setEscapeCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setEscapeChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setNullLiteral(String s) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setNullValue(s).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setUpdateMode(String &#x27;
                           &#x27;updateMode) {\n&#x27;
                           &#x27;\t\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic CsvCRowSerializationSchema build() {\n&#x27;
                           &#x27;\t\t\treturn new CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\t\t\tcsvSchema,\n&#x27;
                           &#x27;\t\t\t\t\tupdateMode);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;\t\tRow row = crow.row();\n&#x27;
                           &#x27;\t\tboolean change = crow.change();\n&#x27;
                           &#x27;\t\tif (root == null) {\n&#x27;
                           &#x27;\t\t\troot = csvMapper.createObjectNode();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\ttry {\n&#x27;
                           &#x27;\t\t\truntimeConverter.convert(csvMapper, root, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;\t\t\tif (StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;\t\t\t\tfillRetractField(row, change);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;objectWriter.writeValueAsBytes(root);\n&#x27;
                           &#x27;\t\t} catch (Throwable t) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;.&quot;, t);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprotected void fillRetractField(Row row, boolean &#x27;
                           &#x27;change) {\n&#x27;
                           &#x27;\t\troot.put(retractKey, change);\n&#x27;
                           &#x27;\t\tCsvSchema.Builder newBuilder = new &#x27;
                           &#x27;CsvSchema.Builder(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tCsvSchema.Column retractColumn = new &#x27;
                           &#x27;CsvSchema.Column(row.getArity(), retractKey, &#x27;
                           &#x27;CsvSchema.ColumnType.BOOLEAN);\n&#x27;
                           &#x27;\t\tnewBuilder.addColumn(retractColumn);\n&#x27;
                           &#x27;\t\tcsvSchema = newBuilder.build();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic boolean equals(Object o) {\n&#x27;
                           &#x27;\t\tif (o == null || o.getClass() != &#x27;
                           &#x27;this.getClass()) {\n&#x27;
                           &#x27;\t\t\treturn false;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tif (this == o) {\n&#x27;
                           &#x27;\t\t\treturn true;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tfinal CsvCRowSerializationSchema that = &#x27;
                           &#x27;(CsvCRowSerializationSchema) o;\n&#x27;
                           &#x27;\t\tfinal CsvSchema otherSchema = that.csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn typeInfo.equals(that.typeInfo) &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator() == &#x27;
                           &#x27;otherSchema.getColumnSeparator() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getLineSeparator(), &#x27;
                           &#x27;otherSchema.getLineSeparator()) &amp;&amp;\n&#x27;
                           &#x27;\t\t\t&#x27;
                           &#x27;csvSchema.getArrayElementSeparator().equals(otherSchema.getArrayElementSeparator()) &#x27;
                           &#x27;&amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar() == &#x27;
                           &#x27;otherSchema.getQuoteChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar() == &#x27;
                           &#x27;otherSchema.getEscapeChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getNullValue(), &#x27;
                           &#x27;otherSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic int hashCode() {\n&#x27;
                           &#x27;\t\treturn Objects.hash(\n&#x27;
                           &#x27;\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getLineSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getArrayElementSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t// &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate interface RuntimeConverter extends &#x27;
                           &#x27;Serializable {\n&#x27;
                           &#x27;\t\tJsonNode convert(CsvMapper csvMapper, &#x27;
                           &#x27;ContainerNode&lt;?&gt; container, Object obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRowRuntimeConverter(RowTypeInfo rowTypeInfo, &#x27;
                           &#x27;boolean isTopLevel) {\n&#x27;
                           &#x27;\t\tfinal TypeInformation[] fieldTypes = &#x27;
                           &#x27;rowTypeInfo.getFieldTypes();\n&#x27;
                           &#x27;\t\tfinal String[] fieldNames = &#x27;
                           &#x27;rowTypeInfo.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = &#x27;
                           &#x27;createFieldRuntimeConverters(fieldTypes);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn assembleRowRuntimeConverter(isTopLevel, &#x27;
                           &#x27;fieldNames, fieldConverters);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter[] &#x27;
                           &#x27;createFieldRuntimeConverters(TypeInformation&lt;?&gt;[] &#x27;
                           &#x27;fieldTypes) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = new &#x27;
                           &#x27;RuntimeConverter[fieldTypes.length];\n&#x27;
                           &#x27;\t\tfor (int i = 0; i &lt; fieldTypes.length; i++) {\n&#x27;
                           &#x27;\t\t\tfieldConverters[i] = &#x27;
                           &#x27;createNullableRuntimeConverter(fieldTypes[i]);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\treturn fieldConverters;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;assembleRowRuntimeConverter(\n&#x27;
                           &#x27;\t\t\tboolean isTopLevel,\n&#x27;
                           &#x27;\t\t\tString[] fieldNames,\n&#x27;
                           &#x27;\t\t\tRuntimeConverter[] fieldConverters) {\n&#x27;
                           &#x27;\t\tfinal int rowArity = fieldNames.length;\n&#x27;
                           &#x27;\t\t// top level reuses the object node container\n&#x27;
                           &#x27;\t\tif (isTopLevel) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ObjectNode objectNode = (ObjectNode) &#x27;
                           &#x27;container;\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\tobjectNode.set(\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldNames[i],\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;container, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn objectNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t} else {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\t&#x27;
                           &#x27;arrayNode.add(fieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;arrayNode, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createNullableRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;info) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter valueConverter = &#x27;
                           &#x27;createRuntimeConverter(info);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tif (obj == null) {\n&#x27;
                           &#x27;\t\t\t\treturn container.nullNode();\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn valueConverter.convert(csvMapper, &#x27;
                           &#x27;container, obj);\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRuntimeConverter(TypeInformation&lt;?&gt; info) {\n&#x27;
                           &#x27;\t\tif (info.equals(Types.VOID)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.nullNode();\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode((String) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.booleanNode((Boolean) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BYTE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Byte) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SHORT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Short) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Integer) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.LONG)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Long) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.FLOAT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Float) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.DOUBLE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Double) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigDecimal) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigInteger) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIMESTAMP)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info instanceof RowTypeInfo){\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createRowRuntimeConverter((RowTypeInfo) info, &#x27;
                           &#x27;false);\n&#x27;
                           &#x27;\t\t} else if (info instanceof BasicArrayTypeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((BasicArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((ObjectArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp;\n&#x27;
                           &#x27;\t\t\t\t((PrimitiveArrayTypeInfo) &#x27;
                           &#x27;info).getComponentType() == Types.BYTE) {\n&#x27;
                           &#x27;\t\t\treturn createByteArrayRuntimeConverter();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\telse {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createObjectArrayRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;elementType) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter elementConverter = &#x27;
                           &#x27;createNullableRuntimeConverter(elementType);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tfinal Object[] array = (Object[]) obj;\n&#x27;
                           &#x27;\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\tfor (Object element : array) {\n&#x27;
                           &#x27;\t\t\t\t&#x27;
                           &#x27;arrayNode.add(elementConverter.convert(csvMapper, &#x27;
                           &#x27;arrayNode, element));\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createByteArrayRuntimeConverter() {\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.binaryNode((byte[]) obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static void validateArity(int expected, &#x27;
                           &#x27;int actual) {\n&#x27;
                           &#x27;\t\tif (expected != actual) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Row length &#x27;
                           &#x27;mismatch. &quot; + expected +\n&#x27;
                           &#x27;\t\t\t\t&quot; fields expected but was &quot; + actual + &#x27;
                           &#x27;&quot;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.annotation.PublicEvolving;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowDeserializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectWriter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvSchema;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a CSV bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input row into a {@link &#x27;
                           &#x27;ObjectNode} and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Result &lt;code&gt;byte[]&lt;/code&gt; messages can be &#x27;
                           &#x27;deserialized using {@link &#x27;
                           &#x27;CsvRowDeserializationSchema}.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@PublicEvolving\n&#x27;
                           &#x27;public final class CsvCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static final long serialVersionUID = &#x27;
                           &#x27;2098447220136965L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Type information describing the input CSV &#x27;
                           &#x27;data. */\n&#x27;
                           &#x27;\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Runtime instance that performs the actual &#x27;
                           &#x27;work. */\n&#x27;
                           &#x27;\tprivate final RuntimeConverter &#x27;
                           &#x27;runtimeConverter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** CsvMapper used to write {@link JsonNode} &#x27;
                           &#x27;into bytes. */\n&#x27;
                           &#x27;\tprivate final CsvMapper csvMapper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Schema describing the input CSV data. */\n&#x27;
                           &#x27;\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Object writer used to write rows. It is &#x27;
                           &#x27;configured by {@link CsvSchema}. */\n&#x27;
                           &#x27;\tprivate ObjectWriter objectWriter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Reusable object node. */\n&#x27;
                           &#x27;\tprivate transient ObjectNode root;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\tRowTypeInfo typeInfo,\n&#x27;
                           &#x27;\t\t\tCsvSchema csvSchema,\n&#x27;
                           &#x27;\t\t\tString updateMode) {\n&#x27;
                           &#x27;\t\tthis.typeInfo = typeInfo;\n&#x27;
                           &#x27;\t\tthis.runtimeConverter = &#x27;
                           &#x27;createRowRuntimeConverter(typeInfo, true);\n&#x27;
                           &#x27;\t\tthis.csvMapper = new CsvMapper();\n&#x27;
                           &#x27;\t\tthis.csvSchema = csvSchema;\n&#x27;
                           &#x27;\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/**\n&#x27;
                           &#x27;\t * A builder for creating a {@link &#x27;
                           &#x27;CsvRowSerializationSchema}.\n&#x27;
                           &#x27;\t */\n&#x27;
                           &#x27;\t@PublicEvolving\n&#x27;
                           &#x27;\tpublic static class Builder {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\t\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\t\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t/**\n&#x27;
                           &#x27;\t\t * Creates a {@link CsvRowSerializationSchema} &#x27;
                           &#x27;expecting the given {@link TypeInformation}.\n&#x27;
                           &#x27;\t\t *\n&#x27;
                           &#x27;\t\t * @param typeInfo type information used to &#x27;
                           &#x27;create schema.\n&#x27;
                           &#x27;\t\t */\n&#x27;
                           &#x27;\t\tpublic Builder(TypeInformation&lt;CRow&gt; typeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information must not be null.&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\tif (!(typeInfo instanceof CRowTypeInfo)) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(&quot;Row &#x27;
                           &#x27;type information expected.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tRowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;\t\t\tthis.typeInfo = rowTypeInfo;\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;CsvRowSchemaConverter.convert(rowTypeInfo);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setFieldDelimiter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setColumnSeparator(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setLineDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tif (!(&quot;\\n&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r\\n&quot;.equals(delimiter))) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(\n&#x27;
                           &#x27;\t\t\t\t\t\t&quot;Unsupported new line delimiter. Only &#x27;
                           &#x27;\\\\n, \\\\r, or \\\\r\\\\n are supported.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setLineSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setArrayElementDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setArrayElementSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setQuoteCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setQuoteChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setEscapeCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setEscapeChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setNullLiteral(String s) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setNullValue(s).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setUpdateMode(String &#x27;
                           &#x27;updateMode) {\n&#x27;
                           &#x27;\t\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic CsvCRowSerializationSchema build() {\n&#x27;
                           &#x27;\t\t\treturn new CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\t\t\tcsvSchema,\n&#x27;
                           &#x27;\t\t\t\t\tupdateMode);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;\t\tRow row = crow.row();\n&#x27;
                           &#x27;\t\tboolean change = crow.change();\n&#x27;
                           &#x27;\t\tif (root == null) {\n&#x27;
                           &#x27;\t\t\troot = csvMapper.createObjectNode();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\ttry {\n&#x27;
                           &#x27;\t\t\truntimeConverter.convert(csvMapper, root, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;\t\t\tif (StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;\t\t\t\tfillRetractField(row, change);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;objectWriter.writeValueAsBytes(root);\n&#x27;
                           &#x27;\t\t} catch (Throwable t) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;.&quot;, t);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprotected void fillRetractField(Row row, boolean &#x27;
                           &#x27;change) {\n&#x27;
                           &#x27;\t\troot.put(retractKey, change);\n&#x27;
                           &#x27;\t\tCsvSchema.Builder newBuilder = new &#x27;
                           &#x27;CsvSchema.Builder(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tCsvSchema.Column retractColumn = new &#x27;
                           &#x27;CsvSchema.Column(row.getArity(), retractKey, &#x27;
                           &#x27;CsvSchema.ColumnType.BOOLEAN);\n&#x27;
                           &#x27;\t\tnewBuilder.addColumn(retractColumn);\n&#x27;
                           &#x27;\t\tcsvSchema = newBuilder.build();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic boolean equals(Object o) {\n&#x27;
                           &#x27;\t\tif (o == null || o.getClass() != &#x27;
                           &#x27;this.getClass()) {\n&#x27;
                           &#x27;\t\t\treturn false;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tif (this == o) {\n&#x27;
                           &#x27;\t\t\treturn true;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tfinal CsvCRowSerializationSchema that = &#x27;
                           &#x27;(CsvCRowSerializationSchema) o;\n&#x27;
                           &#x27;\t\tfinal CsvSchema otherSchema = that.csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn typeInfo.equals(that.typeInfo) &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator() == &#x27;
                           &#x27;otherSchema.getColumnSeparator() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getLineSeparator(), &#x27;
                           &#x27;otherSchema.getLineSeparator()) &amp;&amp;\n&#x27;
                           &#x27;\t\t\t&#x27;
                           &#x27;csvSchema.getArrayElementSeparator().equals(otherSchema.getArrayElementSeparator()) &#x27;
                           &#x27;&amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar() == &#x27;
                           &#x27;otherSchema.getQuoteChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar() == &#x27;
                           &#x27;otherSchema.getEscapeChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getNullValue(), &#x27;
                           &#x27;otherSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic int hashCode() {\n&#x27;
                           &#x27;\t\treturn Objects.hash(\n&#x27;
                           &#x27;\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getLineSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getArrayElementSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t// &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate interface RuntimeConverter extends &#x27;
                           &#x27;Serializable {\n&#x27;
                           &#x27;\t\tJsonNode convert(CsvMapper csvMapper, &#x27;
                           &#x27;ContainerNode&lt;?&gt; container, Object obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRowRuntimeConverter(RowTypeInfo rowTypeInfo, &#x27;
                           &#x27;boolean isTopLevel) {\n&#x27;
                           &#x27;\t\tfinal TypeInformation[] fieldTypes = &#x27;
                           &#x27;rowTypeInfo.getFieldTypes();\n&#x27;
                           &#x27;\t\tfinal String[] fieldNames = &#x27;
                           &#x27;rowTypeInfo.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = &#x27;
                           &#x27;createFieldRuntimeConverters(fieldTypes);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn assembleRowRuntimeConverter(isTopLevel, &#x27;
                           &#x27;fieldNames, fieldConverters);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter[] &#x27;
                           &#x27;createFieldRuntimeConverters(TypeInformation&lt;?&gt;[] &#x27;
                           &#x27;fieldTypes) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = new &#x27;
                           &#x27;RuntimeConverter[fieldTypes.length];\n&#x27;
                           &#x27;\t\tfor (int i = 0; i &lt; fieldTypes.length; i++) {\n&#x27;
                           &#x27;\t\t\tfieldConverters[i] = &#x27;
                           &#x27;createNullableRuntimeConverter(fieldTypes[i]);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\treturn fieldConverters;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;assembleRowRuntimeConverter(\n&#x27;
                           &#x27;\t\t\tboolean isTopLevel,\n&#x27;
                           &#x27;\t\t\tString[] fieldNames,\n&#x27;
                           &#x27;\t\t\tRuntimeConverter[] fieldConverters) {\n&#x27;
                           &#x27;\t\tfinal int rowArity = fieldNames.length;\n&#x27;
                           &#x27;\t\t// top level reuses the object node container\n&#x27;
                           &#x27;\t\tif (isTopLevel) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ObjectNode objectNode = (ObjectNode) &#x27;
                           &#x27;container;\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\tobjectNode.set(\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldNames[i],\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;container, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn objectNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t} else {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\t&#x27;
                           &#x27;arrayNode.add(fieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;arrayNode, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createNullableRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;info) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter valueConverter = &#x27;
                           &#x27;createRuntimeConverter(info);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tif (obj == null) {\n&#x27;
                           &#x27;\t\t\t\treturn container.nullNode();\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn valueConverter.convert(csvMapper, &#x27;
                           &#x27;container, obj);\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRuntimeConverter(TypeInformation&lt;?&gt; info) {\n&#x27;
                           &#x27;\t\tif (info.equals(Types.VOID)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.nullNode();\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode((String) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.booleanNode((Boolean) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BYTE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Byte) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SHORT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Short) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Integer) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.LONG)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Long) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.FLOAT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Float) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.DOUBLE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Double) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigDecimal) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigInteger) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIMESTAMP)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info instanceof RowTypeInfo){\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createRowRuntimeConverter((RowTypeInfo) info, &#x27;
                           &#x27;false);\n&#x27;
                           &#x27;\t\t} else if (info instanceof BasicArrayTypeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((BasicArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((ObjectArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp;\n&#x27;
                           &#x27;\t\t\t\t((PrimitiveArrayTypeInfo) &#x27;
                           &#x27;info).getComponentType() == Types.BYTE) {\n&#x27;
                           &#x27;\t\t\treturn createByteArrayRuntimeConverter();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\telse {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createObjectArrayRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;elementType) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter elementConverter = &#x27;
                           &#x27;createNullableRuntimeConverter(elementType);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tfinal Object[] array = (Object[]) obj;\n&#x27;
                           &#x27;\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\tfor (Object element : array) {\n&#x27;
                           &#x27;\t\t\t\t&#x27;
                           &#x27;arrayNode.add(elementConverter.convert(csvMapper, &#x27;
                           &#x27;arrayNode, element));\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createByteArrayRuntimeConverter() {\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.binaryNode((byte[]) obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static void validateArity(int expected, &#x27;
                           &#x27;int actual) {\n&#x27;
                           &#x27;\t\tif (expected != actual) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Row length &#x27;
                           &#x27;mismatch. &quot; + expected +\n&#x27;
                           &#x27;\t\t\t\t&quot; fields expected but was &quot; + actual + &#x27;
                           &#x27;&quot;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.annotation.PublicEvolving;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowDeserializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectWriter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvSchema;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a CSV bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input row into a {@link &#x27;
                           &#x27;ObjectNode} and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Result &lt;code&gt;byte[]&lt;/code&gt; messages can be &#x27;
                           &#x27;deserialized using {@link &#x27;
                           &#x27;CsvRowDeserializationSchema}.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@PublicEvolving\n&#x27;
                           &#x27;public final class CsvCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static final long serialVersionUID = &#x27;
                           &#x27;2098447220136965L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Type information describing the input CSV &#x27;
                           &#x27;data. */\n&#x27;
                           &#x27;\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Runtime instance that performs the actual &#x27;
                           &#x27;work. */\n&#x27;
                           &#x27;\tprivate final RuntimeConverter &#x27;
                           &#x27;runtimeConverter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** CsvMapper used to write {@link JsonNode} &#x27;
                           &#x27;into bytes. */\n&#x27;
                           &#x27;\tprivate final CsvMapper csvMapper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Schema describing the input CSV data. */\n&#x27;
                           &#x27;\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Object writer used to write rows. It is &#x27;
                           &#x27;configured by {@link CsvSchema}. */\n&#x27;
                           &#x27;\tprivate ObjectWriter objectWriter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Reusable object node. */\n&#x27;
                           &#x27;\tprivate transient ObjectNode root;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\tRowTypeInfo typeInfo,\n&#x27;
                           &#x27;\t\t\tCsvSchema csvSchema,\n&#x27;
                           &#x27;\t\t\tString updateMode) {\n&#x27;
                           &#x27;\t\tthis.typeInfo = typeInfo;\n&#x27;
                           &#x27;\t\tthis.runtimeConverter = &#x27;
                           &#x27;createRowRuntimeConverter(typeInfo, true);\n&#x27;
                           &#x27;\t\tthis.csvMapper = new CsvMapper();\n&#x27;
                           &#x27;\t\tthis.csvSchema = csvSchema;\n&#x27;
                           &#x27;\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/**\n&#x27;
                           &#x27;\t * A builder for creating a {@link &#x27;
                           &#x27;CsvRowSerializationSchema}.\n&#x27;
                           &#x27;\t */\n&#x27;
                           &#x27;\t@PublicEvolving\n&#x27;
                           &#x27;\tpublic static class Builder {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\t\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\t\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t/**\n&#x27;
                           &#x27;\t\t * Creates a {@link CsvRowSerializationSchema} &#x27;
                           &#x27;expecting the given {@link TypeInformation}.\n&#x27;
                           &#x27;\t\t *\n&#x27;
                           &#x27;\t\t * @param typeInfo type information used to &#x27;
                           &#x27;create schema.\n&#x27;
                           &#x27;\t\t */\n&#x27;
                           &#x27;\t\tpublic Builder(TypeInformation&lt;CRow&gt; typeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information must not be null.&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\tif (!(typeInfo instanceof CRowTypeInfo)) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(&quot;Row &#x27;
                           &#x27;type information expected.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tRowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;\t\t\tthis.typeInfo = rowTypeInfo;\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;CsvRowSchemaConverter.convert(rowTypeInfo);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setFieldDelimiter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setColumnSeparator(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setLineDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tif (!(&quot;\\n&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r\\n&quot;.equals(delimiter))) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(\n&#x27;
                           &#x27;\t\t\t\t\t\t&quot;Unsupported new line delimiter. Only &#x27;
                           &#x27;\\\\n, \\\\r, or \\\\r\\\\n are supported.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setLineSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setArrayElementDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setArrayElementSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setQuoteCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setQuoteChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setEscapeCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setEscapeChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setNullLiteral(String s) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setNullValue(s).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setUpdateMode(String &#x27;
                           &#x27;updateMode) {\n&#x27;
                           &#x27;\t\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic CsvCRowSerializationSchema build() {\n&#x27;
                           &#x27;\t\t\treturn new CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\t\t\tcsvSchema,\n&#x27;
                           &#x27;\t\t\t\t\tupdateMode);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;\t\tRow row = crow.row();\n&#x27;
                           &#x27;\t\tboolean change = crow.change();\n&#x27;
                           &#x27;\t\tif (root == null) {\n&#x27;
                           &#x27;\t\t\troot = csvMapper.createObjectNode();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\ttry {\n&#x27;
                           &#x27;\t\t\truntimeConverter.convert(csvMapper, root, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;\t\t\tif (StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;\t\t\t\tfillRetractField(row, change);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;objectWriter.writeValueAsBytes(root);\n&#x27;
                           &#x27;\t\t} catch (Throwable t) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;.&quot;, t);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprotected void fillRetractField(Row row, boolean &#x27;
                           &#x27;change) {\n&#x27;
                           &#x27;\t\troot.put(retractKey, change);\n&#x27;
                           &#x27;\t\tCsvSchema.Builder newBuilder = new &#x27;
                           &#x27;CsvSchema.Builder(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tCsvSchema.Column retractColumn = new &#x27;
                           &#x27;CsvSchema.Column(row.getArity(), retractKey, &#x27;
                           &#x27;CsvSchema.ColumnType.BOOLEAN);\n&#x27;
                           &#x27;\t\tnewBuilder.addColumn(retractColumn);\n&#x27;
                           &#x27;\t\tcsvSchema = newBuilder.build();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic boolean equals(Object o) {\n&#x27;
                           &#x27;\t\tif (o == null || o.getClass() != &#x27;
                           &#x27;this.getClass()) {\n&#x27;
                           &#x27;\t\t\treturn false;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tif (this == o) {\n&#x27;
                           &#x27;\t\t\treturn true;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tfinal CsvCRowSerializationSchema that = &#x27;
                           &#x27;(CsvCRowSerializationSchema) o;\n&#x27;
                           &#x27;\t\tfinal CsvSchema otherSchema = that.csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn typeInfo.equals(that.typeInfo) &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator() == &#x27;
                           &#x27;otherSchema.getColumnSeparator() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getLineSeparator(), &#x27;
                           &#x27;otherSchema.getLineSeparator()) &amp;&amp;\n&#x27;
                           &#x27;\t\t\t&#x27;
                           &#x27;csvSchema.getArrayElementSeparator().equals(otherSchema.getArrayElementSeparator()) &#x27;
                           &#x27;&amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar() == &#x27;
                           &#x27;otherSchema.getQuoteChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar() == &#x27;
                           &#x27;otherSchema.getEscapeChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getNullValue(), &#x27;
                           &#x27;otherSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic int hashCode() {\n&#x27;
                           &#x27;\t\treturn Objects.hash(\n&#x27;
                           &#x27;\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getLineSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getArrayElementSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t// &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate interface RuntimeConverter extends &#x27;
                           &#x27;Serializable {\n&#x27;
                           &#x27;\t\tJsonNode convert(CsvMapper csvMapper, &#x27;
                           &#x27;ContainerNode&lt;?&gt; container, Object obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRowRuntimeConverter(RowTypeInfo rowTypeInfo, &#x27;
                           &#x27;boolean isTopLevel) {\n&#x27;
                           &#x27;\t\tfinal TypeInformation[] fieldTypes = &#x27;
                           &#x27;rowTypeInfo.getFieldTypes();\n&#x27;
                           &#x27;\t\tfinal String[] fieldNames = &#x27;
                           &#x27;rowTypeInfo.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = &#x27;
                           &#x27;createFieldRuntimeConverters(fieldTypes);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn assembleRowRuntimeConverter(isTopLevel, &#x27;
                           &#x27;fieldNames, fieldConverters);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter[] &#x27;
                           &#x27;createFieldRuntimeConverters(TypeInformation&lt;?&gt;[] &#x27;
                           &#x27;fieldTypes) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = new &#x27;
                           &#x27;RuntimeConverter[fieldTypes.length];\n&#x27;
                           &#x27;\t\tfor (int i = 0; i &lt; fieldTypes.length; i++) {\n&#x27;
                           &#x27;\t\t\tfieldConverters[i] = &#x27;
                           &#x27;createNullableRuntimeConverter(fieldTypes[i]);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\treturn fieldConverters;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;assembleRowRuntimeConverter(\n&#x27;
                           &#x27;\t\t\tboolean isTopLevel,\n&#x27;
                           &#x27;\t\t\tString[] fieldNames,\n&#x27;
                           &#x27;\t\t\tRuntimeConverter[] fieldConverters) {\n&#x27;
                           &#x27;\t\tfinal int rowArity = fieldNames.length;\n&#x27;
                           &#x27;\t\t// top level reuses the object node container\n&#x27;
                           &#x27;\t\tif (isTopLevel) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ObjectNode objectNode = (ObjectNode) &#x27;
                           &#x27;container;\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\tobjectNode.set(\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldNames[i],\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;container, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn objectNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t} else {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\t&#x27;
                           &#x27;arrayNode.add(fieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;arrayNode, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createNullableRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;info) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter valueConverter = &#x27;
                           &#x27;createRuntimeConverter(info);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tif (obj == null) {\n&#x27;
                           &#x27;\t\t\t\treturn container.nullNode();\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn valueConverter.convert(csvMapper, &#x27;
                           &#x27;container, obj);\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRuntimeConverter(TypeInformation&lt;?&gt; info) {\n&#x27;
                           &#x27;\t\tif (info.equals(Types.VOID)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.nullNode();\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode((String) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.booleanNode((Boolean) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BYTE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Byte) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SHORT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Short) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Integer) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.LONG)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Long) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.FLOAT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Float) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.DOUBLE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Double) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigDecimal) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigInteger) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIMESTAMP)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info instanceof RowTypeInfo){\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createRowRuntimeConverter((RowTypeInfo) info, &#x27;
                           &#x27;false);\n&#x27;
                           &#x27;\t\t} else if (info instanceof BasicArrayTypeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((BasicArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((ObjectArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp;\n&#x27;
                           &#x27;\t\t\t\t((PrimitiveArrayTypeInfo) &#x27;
                           &#x27;info).getComponentType() == Types.BYTE) {\n&#x27;
                           &#x27;\t\t\treturn createByteArrayRuntimeConverter();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\telse {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createObjectArrayRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;elementType) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter elementConverter = &#x27;
                           &#x27;createNullableRuntimeConverter(elementType);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tfinal Object[] array = (Object[]) obj;\n&#x27;
                           &#x27;\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\tfor (Object element : array) {\n&#x27;
                           &#x27;\t\t\t\t&#x27;
                           &#x27;arrayNode.add(elementConverter.convert(csvMapper, &#x27;
                           &#x27;arrayNode, element));\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createByteArrayRuntimeConverter() {\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.binaryNode((byte[]) obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static void validateArity(int expected, &#x27;
                           &#x27;int actual) {\n&#x27;
                           &#x27;\t\tif (expected != actual) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Row length &#x27;
                           &#x27;mismatch. &quot; + expected +\n&#x27;
                           &#x27;\t\t\t\t&quot; fields expected but was &quot; + actual + &#x27;
                           &#x27;&quot;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.annotation.PublicEvolving;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowDeserializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectWriter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvSchema;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a CSV bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input row into a {@link &#x27;
                           &#x27;ObjectNode} and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Result &lt;code&gt;byte[]&lt;/code&gt; messages can be &#x27;
                           &#x27;deserialized using {@link &#x27;
                           &#x27;CsvRowDeserializationSchema}.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@PublicEvolving\n&#x27;
                           &#x27;public final class CsvCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static final long serialVersionUID = &#x27;
                           &#x27;2098447220136965L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Type information describing the input CSV &#x27;
                           &#x27;data. */\n&#x27;
                           &#x27;\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Runtime instance that performs the actual &#x27;
                           &#x27;work. */\n&#x27;
                           &#x27;\tprivate final RuntimeConverter &#x27;
                           &#x27;runtimeConverter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** CsvMapper used to write {@link JsonNode} &#x27;
                           &#x27;into bytes. */\n&#x27;
                           &#x27;\tprivate final CsvMapper csvMapper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Schema describing the input CSV data. */\n&#x27;
                           &#x27;\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Object writer used to write rows. It is &#x27;
                           &#x27;configured by {@link CsvSchema}. */\n&#x27;
                           &#x27;\tprivate ObjectWriter objectWriter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Reusable object node. */\n&#x27;
                           &#x27;\tprivate transient ObjectNode root;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\tRowTypeInfo typeInfo,\n&#x27;
                           &#x27;\t\t\tCsvSchema csvSchema,\n&#x27;
                           &#x27;\t\t\tString updateMode) {\n&#x27;
                           &#x27;\t\tthis.typeInfo = typeInfo;\n&#x27;
                           &#x27;\t\tthis.runtimeConverter = &#x27;
                           &#x27;createRowRuntimeConverter(typeInfo, true);\n&#x27;
                           &#x27;\t\tthis.csvMapper = new CsvMapper();\n&#x27;
                           &#x27;\t\tthis.csvSchema = csvSchema;\n&#x27;
                           &#x27;\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/**\n&#x27;
                           &#x27;\t * A builder for creating a {@link &#x27;
                           &#x27;CsvRowSerializationSchema}.\n&#x27;
                           &#x27;\t */\n&#x27;
                           &#x27;\t@PublicEvolving\n&#x27;
                           &#x27;\tpublic static class Builder {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\t\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\t\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t/**\n&#x27;
                           &#x27;\t\t * Creates a {@link CsvRowSerializationSchema} &#x27;
                           &#x27;expecting the given {@link TypeInformation}.\n&#x27;
                           &#x27;\t\t *\n&#x27;
                           &#x27;\t\t * @param typeInfo type information used to &#x27;
                           &#x27;create schema.\n&#x27;
                           &#x27;\t\t */\n&#x27;
                           &#x27;\t\tpublic Builder(TypeInformation&lt;CRow&gt; typeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information must not be null.&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\tif (!(typeInfo instanceof CRowTypeInfo)) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(&quot;Row &#x27;
                           &#x27;type information expected.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tRowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;\t\t\tthis.typeInfo = rowTypeInfo;\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;CsvRowSchemaConverter.convert(rowTypeInfo);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setFieldDelimiter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setColumnSeparator(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setLineDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tif (!(&quot;\\n&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r\\n&quot;.equals(delimiter))) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(\n&#x27;
                           &#x27;\t\t\t\t\t\t&quot;Unsupported new line delimiter. Only &#x27;
                           &#x27;\\\\n, \\\\r, or \\\\r\\\\n are supported.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setLineSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setArrayElementDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setArrayElementSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setQuoteCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setQuoteChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setEscapeCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setEscapeChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setNullLiteral(String s) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setNullValue(s).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setUpdateMode(String &#x27;
                           &#x27;updateMode) {\n&#x27;
                           &#x27;\t\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic CsvCRowSerializationSchema build() {\n&#x27;
                           &#x27;\t\t\treturn new CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\t\t\tcsvSchema,\n&#x27;
                           &#x27;\t\t\t\t\tupdateMode);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;\t\tRow row = crow.row();\n&#x27;
                           &#x27;\t\tboolean change = crow.change();\n&#x27;
                           &#x27;\t\tif (root == null) {\n&#x27;
                           &#x27;\t\t\troot = csvMapper.createObjectNode();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\ttry {\n&#x27;
                           &#x27;\t\t\truntimeConverter.convert(csvMapper, root, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;\t\t\tif (StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;\t\t\t\tfillRetractField(row, change);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;objectWriter.writeValueAsBytes(root);\n&#x27;
                           &#x27;\t\t} catch (Throwable t) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;.&quot;, t);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprotected void fillRetractField(Row row, boolean &#x27;
                           &#x27;change) {\n&#x27;
                           &#x27;\t\troot.put(retractKey, change);\n&#x27;
                           &#x27;\t\tCsvSchema.Builder newBuilder = new &#x27;
                           &#x27;CsvSchema.Builder(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tCsvSchema.Column retractColumn = new &#x27;
                           &#x27;CsvSchema.Column(row.getArity(), retractKey, &#x27;
                           &#x27;CsvSchema.ColumnType.BOOLEAN);\n&#x27;
                           &#x27;\t\tnewBuilder.addColumn(retractColumn);\n&#x27;
                           &#x27;\t\tcsvSchema = newBuilder.build();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic boolean equals(Object o) {\n&#x27;
                           &#x27;\t\tif (o == null || o.getClass() != &#x27;
                           &#x27;this.getClass()) {\n&#x27;
                           &#x27;\t\t\treturn false;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tif (this == o) {\n&#x27;
                           &#x27;\t\t\treturn true;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tfinal CsvCRowSerializationSchema that = &#x27;
                           &#x27;(CsvCRowSerializationSchema) o;\n&#x27;
                           &#x27;\t\tfinal CsvSchema otherSchema = that.csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn typeInfo.equals(that.typeInfo) &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator() == &#x27;
                           &#x27;otherSchema.getColumnSeparator() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getLineSeparator(), &#x27;
                           &#x27;otherSchema.getLineSeparator()) &amp;&amp;\n&#x27;
                           &#x27;\t\t\t&#x27;
                           &#x27;csvSchema.getArrayElementSeparator().equals(otherSchema.getArrayElementSeparator()) &#x27;
                           &#x27;&amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar() == &#x27;
                           &#x27;otherSchema.getQuoteChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar() == &#x27;
                           &#x27;otherSchema.getEscapeChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getNullValue(), &#x27;
                           &#x27;otherSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic int hashCode() {\n&#x27;
                           &#x27;\t\treturn Objects.hash(\n&#x27;
                           &#x27;\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getLineSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getArrayElementSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t// &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate interface RuntimeConverter extends &#x27;
                           &#x27;Serializable {\n&#x27;
                           &#x27;\t\tJsonNode convert(CsvMapper csvMapper, &#x27;
                           &#x27;ContainerNode&lt;?&gt; container, Object obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRowRuntimeConverter(RowTypeInfo rowTypeInfo, &#x27;
                           &#x27;boolean isTopLevel) {\n&#x27;
                           &#x27;\t\tfinal TypeInformation[] fieldTypes = &#x27;
                           &#x27;rowTypeInfo.getFieldTypes();\n&#x27;
                           &#x27;\t\tfinal String[] fieldNames = &#x27;
                           &#x27;rowTypeInfo.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = &#x27;
                           &#x27;createFieldRuntimeConverters(fieldTypes);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn assembleRowRuntimeConverter(isTopLevel, &#x27;
                           &#x27;fieldNames, fieldConverters);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter[] &#x27;
                           &#x27;createFieldRuntimeConverters(TypeInformation&lt;?&gt;[] &#x27;
                           &#x27;fieldTypes) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = new &#x27;
                           &#x27;RuntimeConverter[fieldTypes.length];\n&#x27;
                           &#x27;\t\tfor (int i = 0; i &lt; fieldTypes.length; i++) {\n&#x27;
                           &#x27;\t\t\tfieldConverters[i] = &#x27;
                           &#x27;createNullableRuntimeConverter(fieldTypes[i]);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\treturn fieldConverters;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;assembleRowRuntimeConverter(\n&#x27;
                           &#x27;\t\t\tboolean isTopLevel,\n&#x27;
                           &#x27;\t\t\tString[] fieldNames,\n&#x27;
                           &#x27;\t\t\tRuntimeConverter[] fieldConverters) {\n&#x27;
                           &#x27;\t\tfinal int rowArity = fieldNames.length;\n&#x27;
                           &#x27;\t\t// top level reuses the object node container\n&#x27;
                           &#x27;\t\tif (isTopLevel) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ObjectNode objectNode = (ObjectNode) &#x27;
                           &#x27;container;\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\tobjectNode.set(\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldNames[i],\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;container, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn objectNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t} else {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\t&#x27;
                           &#x27;arrayNode.add(fieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;arrayNode, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createNullableRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;info) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter valueConverter = &#x27;
                           &#x27;createRuntimeConverter(info);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tif (obj == null) {\n&#x27;
                           &#x27;\t\t\t\treturn container.nullNode();\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn valueConverter.convert(csvMapper, &#x27;
                           &#x27;container, obj);\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRuntimeConverter(TypeInformation&lt;?&gt; info) {\n&#x27;
                           &#x27;\t\tif (info.equals(Types.VOID)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.nullNode();\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode((String) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.booleanNode((Boolean) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BYTE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Byte) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SHORT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Short) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Integer) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.LONG)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Long) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.FLOAT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Float) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.DOUBLE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Double) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigDecimal) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigInteger) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIMESTAMP)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info instanceof RowTypeInfo){\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createRowRuntimeConverter((RowTypeInfo) info, &#x27;
                           &#x27;false);\n&#x27;
                           &#x27;\t\t} else if (info instanceof BasicArrayTypeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((BasicArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((ObjectArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp;\n&#x27;
                           &#x27;\t\t\t\t((PrimitiveArrayTypeInfo) &#x27;
                           &#x27;info).getComponentType() == Types.BYTE) {\n&#x27;
                           &#x27;\t\t\treturn createByteArrayRuntimeConverter();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\telse {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createObjectArrayRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;elementType) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter elementConverter = &#x27;
                           &#x27;createNullableRuntimeConverter(elementType);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tfinal Object[] array = (Object[]) obj;\n&#x27;
                           &#x27;\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\tfor (Object element : array) {\n&#x27;
                           &#x27;\t\t\t\t&#x27;
                           &#x27;arrayNode.add(elementConverter.convert(csvMapper, &#x27;
                           &#x27;arrayNode, element));\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createByteArrayRuntimeConverter() {\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.binaryNode((byte[]) obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static void validateArity(int expected, &#x27;
                           &#x27;int actual) {\n&#x27;
                           &#x27;\t\tif (expected != actual) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Row length &#x27;
                           &#x27;mismatch. &quot; + expected +\n&#x27;
                           &#x27;\t\t\t\t&quot; fields expected but was &quot; + actual + &#x27;
                           &#x27;&quot;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.annotation.PublicEvolving;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowDeserializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectWriter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvSchema;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a CSV bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input row into a {@link &#x27;
                           &#x27;ObjectNode} and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Result &lt;code&gt;byte[]&lt;/code&gt; messages can be &#x27;
                           &#x27;deserialized using {@link &#x27;
                           &#x27;CsvRowDeserializationSchema}.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@PublicEvolving\n&#x27;
                           &#x27;public final class CsvCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static final long serialVersionUID = &#x27;
                           &#x27;2098447220136965L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Type information describing the input CSV &#x27;
                           &#x27;data. */\n&#x27;
                           &#x27;\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Runtime instance that performs the actual &#x27;
                           &#x27;work. */\n&#x27;
                           &#x27;\tprivate final RuntimeConverter &#x27;
                           &#x27;runtimeConverter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** CsvMapper used to write {@link JsonNode} &#x27;
                           &#x27;into bytes. */\n&#x27;
                           &#x27;\tprivate final CsvMapper csvMapper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Schema describing the input CSV data. */\n&#x27;
                           &#x27;\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Object writer used to write rows. It is &#x27;
                           &#x27;configured by {@link CsvSchema}. */\n&#x27;
                           &#x27;\tprivate ObjectWriter objectWriter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Reusable object node. */\n&#x27;
                           &#x27;\tprivate transient ObjectNode root;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\tRowTypeInfo typeInfo,\n&#x27;
                           &#x27;\t\t\tCsvSchema csvSchema,\n&#x27;
                           &#x27;\t\t\tString updateMode) {\n&#x27;
                           &#x27;\t\tthis.typeInfo = typeInfo;\n&#x27;
                           &#x27;\t\tthis.runtimeConverter = &#x27;
                           &#x27;createRowRuntimeConverter(typeInfo, true);\n&#x27;
                           &#x27;\t\tthis.csvMapper = new CsvMapper();\n&#x27;
                           &#x27;\t\tthis.csvSchema = csvSchema;\n&#x27;
                           &#x27;\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/**\n&#x27;
                           &#x27;\t * A builder for creating a {@link &#x27;
                           &#x27;CsvRowSerializationSchema}.\n&#x27;
                           &#x27;\t */\n&#x27;
                           &#x27;\t@PublicEvolving\n&#x27;
                           &#x27;\tpublic static class Builder {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\t\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\t\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t/**\n&#x27;
                           &#x27;\t\t * Creates a {@link CsvRowSerializationSchema} &#x27;
                           &#x27;expecting the given {@link TypeInformation}.\n&#x27;
                           &#x27;\t\t *\n&#x27;
                           &#x27;\t\t * @param typeInfo type information used to &#x27;
                           &#x27;create schema.\n&#x27;
                           &#x27;\t\t */\n&#x27;
                           &#x27;\t\tpublic Builder(TypeInformation&lt;CRow&gt; typeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information must not be null.&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\tif (!(typeInfo instanceof CRowTypeInfo)) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(&quot;Row &#x27;
                           &#x27;type information expected.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tRowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;\t\t\tthis.typeInfo = rowTypeInfo;\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;CsvRowSchemaConverter.convert(rowTypeInfo);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setFieldDelimiter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setColumnSeparator(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setLineDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tif (!(&quot;\\n&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r\\n&quot;.equals(delimiter))) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(\n&#x27;
                           &#x27;\t\t\t\t\t\t&quot;Unsupported new line delimiter. Only &#x27;
                           &#x27;\\\\n, \\\\r, or \\\\r\\\\n are supported.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setLineSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setArrayElementDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setArrayElementSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setQuoteCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setQuoteChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setEscapeCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setEscapeChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setNullLiteral(String s) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setNullValue(s).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setUpdateMode(String &#x27;
                           &#x27;updateMode) {\n&#x27;
                           &#x27;\t\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic CsvCRowSerializationSchema build() {\n&#x27;
                           &#x27;\t\t\treturn new CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\t\t\tcsvSchema,\n&#x27;
                           &#x27;\t\t\t\t\tupdateMode);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;\t\tRow row = crow.row();\n&#x27;
                           &#x27;\t\tboolean change = crow.change();\n&#x27;
                           &#x27;\t\tif (root == null) {\n&#x27;
                           &#x27;\t\t\troot = csvMapper.createObjectNode();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\ttry {\n&#x27;
                           &#x27;\t\t\truntimeConverter.convert(csvMapper, root, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;\t\t\tif (StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;\t\t\t\tfillRetractField(row, change);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;objectWriter.writeValueAsBytes(root);\n&#x27;
                           &#x27;\t\t} catch (Throwable t) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;.&quot;, t);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprotected void fillRetractField(Row row, boolean &#x27;
                           &#x27;change) {\n&#x27;
                           &#x27;\t\troot.put(retractKey, change);\n&#x27;
                           &#x27;\t\tCsvSchema.Builder newBuilder = new &#x27;
                           &#x27;CsvSchema.Builder(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tCsvSchema.Column retractColumn = new &#x27;
                           &#x27;CsvSchema.Column(row.getArity(), retractKey, &#x27;
                           &#x27;CsvSchema.ColumnType.BOOLEAN);\n&#x27;
                           &#x27;\t\tnewBuilder.addColumn(retractColumn);\n&#x27;
                           &#x27;\t\tcsvSchema = newBuilder.build();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic boolean equals(Object o) {\n&#x27;
                           &#x27;\t\tif (o == null || o.getClass() != &#x27;
                           &#x27;this.getClass()) {\n&#x27;
                           &#x27;\t\t\treturn false;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tif (this == o) {\n&#x27;
                           &#x27;\t\t\treturn true;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tfinal CsvCRowSerializationSchema that = &#x27;
                           &#x27;(CsvCRowSerializationSchema) o;\n&#x27;
                           &#x27;\t\tfinal CsvSchema otherSchema = that.csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn typeInfo.equals(that.typeInfo) &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator() == &#x27;
                           &#x27;otherSchema.getColumnSeparator() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getLineSeparator(), &#x27;
                           &#x27;otherSchema.getLineSeparator()) &amp;&amp;\n&#x27;
                           &#x27;\t\t\t&#x27;
                           &#x27;csvSchema.getArrayElementSeparator().equals(otherSchema.getArrayElementSeparator()) &#x27;
                           &#x27;&amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar() == &#x27;
                           &#x27;otherSchema.getQuoteChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar() == &#x27;
                           &#x27;otherSchema.getEscapeChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getNullValue(), &#x27;
                           &#x27;otherSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic int hashCode() {\n&#x27;
                           &#x27;\t\treturn Objects.hash(\n&#x27;
                           &#x27;\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getLineSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getArrayElementSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t// &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate interface RuntimeConverter extends &#x27;
                           &#x27;Serializable {\n&#x27;
                           &#x27;\t\tJsonNode convert(CsvMapper csvMapper, &#x27;
                           &#x27;ContainerNode&lt;?&gt; container, Object obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRowRuntimeConverter(RowTypeInfo rowTypeInfo, &#x27;
                           &#x27;boolean isTopLevel) {\n&#x27;
                           &#x27;\t\tfinal TypeInformation[] fieldTypes = &#x27;
                           &#x27;rowTypeInfo.getFieldTypes();\n&#x27;
                           &#x27;\t\tfinal String[] fieldNames = &#x27;
                           &#x27;rowTypeInfo.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = &#x27;
                           &#x27;createFieldRuntimeConverters(fieldTypes);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn assembleRowRuntimeConverter(isTopLevel, &#x27;
                           &#x27;fieldNames, fieldConverters);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter[] &#x27;
                           &#x27;createFieldRuntimeConverters(TypeInformation&lt;?&gt;[] &#x27;
                           &#x27;fieldTypes) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = new &#x27;
                           &#x27;RuntimeConverter[fieldTypes.length];\n&#x27;
                           &#x27;\t\tfor (int i = 0; i &lt; fieldTypes.length; i++) {\n&#x27;
                           &#x27;\t\t\tfieldConverters[i] = &#x27;
                           &#x27;createNullableRuntimeConverter(fieldTypes[i]);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\treturn fieldConverters;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;assembleRowRuntimeConverter(\n&#x27;
                           &#x27;\t\t\tboolean isTopLevel,\n&#x27;
                           &#x27;\t\t\tString[] fieldNames,\n&#x27;
                           &#x27;\t\t\tRuntimeConverter[] fieldConverters) {\n&#x27;
                           &#x27;\t\tfinal int rowArity = fieldNames.length;\n&#x27;
                           &#x27;\t\t// top level reuses the object node container\n&#x27;
                           &#x27;\t\tif (isTopLevel) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ObjectNode objectNode = (ObjectNode) &#x27;
                           &#x27;container;\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\tobjectNode.set(\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldNames[i],\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;container, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn objectNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t} else {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\t&#x27;
                           &#x27;arrayNode.add(fieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;arrayNode, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createNullableRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;info) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter valueConverter = &#x27;
                           &#x27;createRuntimeConverter(info);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tif (obj == null) {\n&#x27;
                           &#x27;\t\t\t\treturn container.nullNode();\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn valueConverter.convert(csvMapper, &#x27;
                           &#x27;container, obj);\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRuntimeConverter(TypeInformation&lt;?&gt; info) {\n&#x27;
                           &#x27;\t\tif (info.equals(Types.VOID)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.nullNode();\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode((String) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.booleanNode((Boolean) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BYTE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Byte) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SHORT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Short) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Integer) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.LONG)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Long) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.FLOAT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Float) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.DOUBLE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Double) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigDecimal) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigInteger) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIMESTAMP)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info instanceof RowTypeInfo){\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createRowRuntimeConverter((RowTypeInfo) info, &#x27;
                           &#x27;false);\n&#x27;
                           &#x27;\t\t} else if (info instanceof BasicArrayTypeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((BasicArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((ObjectArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp;\n&#x27;
                           &#x27;\t\t\t\t((PrimitiveArrayTypeInfo) &#x27;
                           &#x27;info).getComponentType() == Types.BYTE) {\n&#x27;
                           &#x27;\t\t\treturn createByteArrayRuntimeConverter();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\telse {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createObjectArrayRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;elementType) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter elementConverter = &#x27;
                           &#x27;createNullableRuntimeConverter(elementType);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tfinal Object[] array = (Object[]) obj;\n&#x27;
                           &#x27;\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\tfor (Object element : array) {\n&#x27;
                           &#x27;\t\t\t\t&#x27;
                           &#x27;arrayNode.add(elementConverter.convert(csvMapper, &#x27;
                           &#x27;arrayNode, element));\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createByteArrayRuntimeConverter() {\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.binaryNode((byte[]) obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static void validateArity(int expected, &#x27;
                           &#x27;int actual) {\n&#x27;
                           &#x27;\t\tif (expected != actual) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Row length &#x27;
                           &#x27;mismatch. &quot; + expected +\n&#x27;
                           &#x27;\t\t\t\t&quot; fields expected but was &quot; + actual + &#x27;
                           &#x27;&quot;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.annotation.PublicEvolving;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowDeserializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.csv.CsvRowSerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectWriter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.csv.CsvSchema;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a CSV bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input row into a {@link &#x27;
                           &#x27;ObjectNode} and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Result &lt;code&gt;byte[]&lt;/code&gt; messages can be &#x27;
                           &#x27;deserialized using {@link &#x27;
                           &#x27;CsvRowDeserializationSchema}.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@PublicEvolving\n&#x27;
                           &#x27;public final class CsvCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static final long serialVersionUID = &#x27;
                           &#x27;2098447220136965L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Type information describing the input CSV &#x27;
                           &#x27;data. */\n&#x27;
                           &#x27;\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Runtime instance that performs the actual &#x27;
                           &#x27;work. */\n&#x27;
                           &#x27;\tprivate final RuntimeConverter &#x27;
                           &#x27;runtimeConverter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** CsvMapper used to write {@link JsonNode} &#x27;
                           &#x27;into bytes. */\n&#x27;
                           &#x27;\tprivate final CsvMapper csvMapper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Schema describing the input CSV data. */\n&#x27;
                           &#x27;\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Object writer used to write rows. It is &#x27;
                           &#x27;configured by {@link CsvSchema}. */\n&#x27;
                           &#x27;\tprivate ObjectWriter objectWriter;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/** Reusable object node. */\n&#x27;
                           &#x27;\tprivate transient ObjectNode root;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\tRowTypeInfo typeInfo,\n&#x27;
                           &#x27;\t\t\tCsvSchema csvSchema,\n&#x27;
                           &#x27;\t\t\tString updateMode) {\n&#x27;
                           &#x27;\t\tthis.typeInfo = typeInfo;\n&#x27;
                           &#x27;\t\tthis.runtimeConverter = &#x27;
                           &#x27;createRowRuntimeConverter(typeInfo, true);\n&#x27;
                           &#x27;\t\tthis.csvMapper = new CsvMapper();\n&#x27;
                           &#x27;\t\tthis.csvSchema = csvSchema;\n&#x27;
                           &#x27;\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t/**\n&#x27;
                           &#x27;\t * A builder for creating a {@link &#x27;
                           &#x27;CsvRowSerializationSchema}.\n&#x27;
                           &#x27;\t */\n&#x27;
                           &#x27;\t@PublicEvolving\n&#x27;
                           &#x27;\tpublic static class Builder {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tprivate final RowTypeInfo typeInfo;\n&#x27;
                           &#x27;\t\tprivate CsvSchema csvSchema;\n&#x27;
                           &#x27;\t\tprivate String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t/**\n&#x27;
                           &#x27;\t\t * Creates a {@link CsvRowSerializationSchema} &#x27;
                           &#x27;expecting the given {@link TypeInformation}.\n&#x27;
                           &#x27;\t\t *\n&#x27;
                           &#x27;\t\t * @param typeInfo type information used to &#x27;
                           &#x27;create schema.\n&#x27;
                           &#x27;\t\t */\n&#x27;
                           &#x27;\t\tpublic Builder(TypeInformation&lt;CRow&gt; typeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information must not be null.&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\tif (!(typeInfo instanceof CRowTypeInfo)) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(&quot;Row &#x27;
                           &#x27;type information expected.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tRowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;\t\t\tthis.typeInfo = rowTypeInfo;\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;CsvRowSchemaConverter.convert(rowTypeInfo);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setFieldDelimiter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setColumnSeparator(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setLineDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tif (!(&quot;\\n&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r&quot;.equals(delimiter)) &amp;&amp; &#x27;
                           &#x27;!(&quot;\\r\\n&quot;.equals(delimiter))) {\n&#x27;
                           &#x27;\t\t\t\tthrow new IllegalArgumentException(\n&#x27;
                           &#x27;\t\t\t\t\t\t&quot;Unsupported new line delimiter. Only &#x27;
                           &#x27;\\\\n, \\\\r, or \\\\r\\\\n are supported.&quot;);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setLineSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setArrayElementDelimiter(String &#x27;
                           &#x27;delimiter) {\n&#x27;
                           &#x27;\t\t\tPreconditions.checkNotNull(delimiter, &#x27;
                           &#x27;&quot;Delimiter must not be null.&quot;);\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setArrayElementSeparator(delimiter).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setQuoteCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setQuoteChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setEscapeCharacter(char c) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setEscapeChar(c).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setNullLiteral(String s) {\n&#x27;
                           &#x27;\t\t\tthis.csvSchema = &#x27;
                           &#x27;this.csvSchema.rebuild().setNullValue(s).build();\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic Builder setUpdateMode(String &#x27;
                           &#x27;updateMode) {\n&#x27;
                           &#x27;\t\t\tthis.updateMode = updateMode;\n&#x27;
                           &#x27;\t\t\treturn this;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tpublic CsvCRowSerializationSchema build() {\n&#x27;
                           &#x27;\t\t\treturn new CsvCRowSerializationSchema(\n&#x27;
                           &#x27;\t\t\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\t\t\tcsvSchema,\n&#x27;
                           &#x27;\t\t\t\t\tupdateMode);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;\t\tRow row = crow.row();\n&#x27;
                           &#x27;\t\tboolean change = crow.change();\n&#x27;
                           &#x27;\t\tif (root == null) {\n&#x27;
                           &#x27;\t\t\troot = csvMapper.createObjectNode();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\ttry {\n&#x27;
                           &#x27;\t\t\truntimeConverter.convert(csvMapper, root, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;\t\t\tif (StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;\t\t\t\tfillRetractField(row, change);\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;objectWriter.writeValueAsBytes(root);\n&#x27;
                           &#x27;\t\t} catch (Throwable t) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;.&quot;, t);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprotected void fillRetractField(Row row, boolean &#x27;
                           &#x27;change) {\n&#x27;
                           &#x27;\t\troot.put(retractKey, change);\n&#x27;
                           &#x27;\t\tCsvSchema.Builder newBuilder = new &#x27;
                           &#x27;CsvSchema.Builder(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tCsvSchema.Column retractColumn = new &#x27;
                           &#x27;CsvSchema.Column(row.getArity(), retractKey, &#x27;
                           &#x27;CsvSchema.ColumnType.BOOLEAN);\n&#x27;
                           &#x27;\t\tnewBuilder.addColumn(retractColumn);\n&#x27;
                           &#x27;\t\tcsvSchema = newBuilder.build();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tthis.objectWriter = &#x27;
                           &#x27;csvMapper.writer(csvSchema);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic boolean equals(Object o) {\n&#x27;
                           &#x27;\t\tif (o == null || o.getClass() != &#x27;
                           &#x27;this.getClass()) {\n&#x27;
                           &#x27;\t\t\treturn false;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tif (this == o) {\n&#x27;
                           &#x27;\t\t\treturn true;\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\tfinal CsvCRowSerializationSchema that = &#x27;
                           &#x27;(CsvCRowSerializationSchema) o;\n&#x27;
                           &#x27;\t\tfinal CsvSchema otherSchema = that.csvSchema;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn typeInfo.equals(that.typeInfo) &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator() == &#x27;
                           &#x27;otherSchema.getColumnSeparator() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getLineSeparator(), &#x27;
                           &#x27;otherSchema.getLineSeparator()) &amp;&amp;\n&#x27;
                           &#x27;\t\t\t&#x27;
                           &#x27;csvSchema.getArrayElementSeparator().equals(otherSchema.getArrayElementSeparator()) &#x27;
                           &#x27;&amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar() == &#x27;
                           &#x27;otherSchema.getQuoteChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar() == &#x27;
                           &#x27;otherSchema.getEscapeChar() &amp;&amp;\n&#x27;
                           &#x27;\t\t\tArrays.equals(csvSchema.getNullValue(), &#x27;
                           &#x27;otherSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t@Override\n&#x27;
                           &#x27;\tpublic int hashCode() {\n&#x27;
                           &#x27;\t\treturn Objects.hash(\n&#x27;
                           &#x27;\t\t\ttypeInfo,\n&#x27;
                           &#x27;\t\t\tcsvSchema.getColumnSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getLineSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getArrayElementSeparator(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getQuoteChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getEscapeChar(),\n&#x27;
                           &#x27;\t\t\tcsvSchema.getNullValue());\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t// &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate interface RuntimeConverter extends &#x27;
                           &#x27;Serializable {\n&#x27;
                           &#x27;\t\tJsonNode convert(CsvMapper csvMapper, &#x27;
                           &#x27;ContainerNode&lt;?&gt; container, Object obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRowRuntimeConverter(RowTypeInfo rowTypeInfo, &#x27;
                           &#x27;boolean isTopLevel) {\n&#x27;
                           &#x27;\t\tfinal TypeInformation[] fieldTypes = &#x27;
                           &#x27;rowTypeInfo.getFieldTypes();\n&#x27;
                           &#x27;\t\tfinal String[] fieldNames = &#x27;
                           &#x27;rowTypeInfo.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = &#x27;
                           &#x27;createFieldRuntimeConverters(fieldTypes);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\treturn assembleRowRuntimeConverter(isTopLevel, &#x27;
                           &#x27;fieldNames, fieldConverters);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter[] &#x27;
                           &#x27;createFieldRuntimeConverters(TypeInformation&lt;?&gt;[] &#x27;
                           &#x27;fieldTypes) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter[] fieldConverters = new &#x27;
                           &#x27;RuntimeConverter[fieldTypes.length];\n&#x27;
                           &#x27;\t\tfor (int i = 0; i &lt; fieldTypes.length; i++) {\n&#x27;
                           &#x27;\t\t\tfieldConverters[i] = &#x27;
                           &#x27;createNullableRuntimeConverter(fieldTypes[i]);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\treturn fieldConverters;\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;assembleRowRuntimeConverter(\n&#x27;
                           &#x27;\t\t\tboolean isTopLevel,\n&#x27;
                           &#x27;\t\t\tString[] fieldNames,\n&#x27;
                           &#x27;\t\t\tRuntimeConverter[] fieldConverters) {\n&#x27;
                           &#x27;\t\tfinal int rowArity = fieldNames.length;\n&#x27;
                           &#x27;\t\t// top level reuses the object node container\n&#x27;
                           &#x27;\t\tif (isTopLevel) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ObjectNode objectNode = (ObjectNode) &#x27;
                           &#x27;container;\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\tobjectNode.set(\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldNames[i],\n&#x27;
                           &#x27;\t\t\t\t\t\tfieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;container, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn objectNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t} else {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\t\tfinal Row row = (Row) obj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tvalidateArity(rowArity, row.getArity());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\t\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\t\tfor (int i = 0; i &lt; rowArity; i++) {\n&#x27;
                           &#x27;\t\t\t\t\t&#x27;
                           &#x27;arrayNode.add(fieldConverters[i].convert(csvMapper, &#x27;
                           &#x27;arrayNode, row.getField(i)));\n&#x27;
                           &#x27;\t\t\t\t}\n&#x27;
                           &#x27;\t\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t\t};\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createNullableRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;info) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter valueConverter = &#x27;
                           &#x27;createRuntimeConverter(info);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tif (obj == null) {\n&#x27;
                           &#x27;\t\t\t\treturn container.nullNode();\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn valueConverter.convert(csvMapper, &#x27;
                           &#x27;container, obj);\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createRuntimeConverter(TypeInformation&lt;?&gt; info) {\n&#x27;
                           &#x27;\t\tif (info.equals(Types.VOID)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.nullNode();\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode((String) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.booleanNode((Boolean) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BYTE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Byte) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SHORT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Short) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Integer) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.LONG)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Long) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.FLOAT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Float) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.DOUBLE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((Double) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigDecimal) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.numberNode((BigInteger) obj);\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info.equals(Types.SQL_TIMESTAMP)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.textNode(obj.toString());\n&#x27;
                           &#x27;\t\t} else if (info instanceof RowTypeInfo){\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createRowRuntimeConverter((RowTypeInfo) info, &#x27;
                           &#x27;false);\n&#x27;
                           &#x27;\t\t} else if (info instanceof BasicArrayTypeInfo) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((BasicArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;\t\t\treturn &#x27;
                           &#x27;createObjectArrayRuntimeConverter(((ObjectArrayTypeInfo) &#x27;
                           &#x27;info).getComponentInfo());\n&#x27;
                           &#x27;\t\t} else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp;\n&#x27;
                           &#x27;\t\t\t\t((PrimitiveArrayTypeInfo) &#x27;
                           &#x27;info).getComponentType() == Types.BYTE) {\n&#x27;
                           &#x27;\t\t\treturn createByteArrayRuntimeConverter();\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t\telse {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createObjectArrayRuntimeConverter(TypeInformation&lt;?&gt; &#x27;
                           &#x27;elementType) {\n&#x27;
                           &#x27;\t\tfinal RuntimeConverter elementConverter = &#x27;
                           &#x27;createNullableRuntimeConverter(elementType);\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; {\n&#x27;
                           &#x27;\t\t\tfinal Object[] array = (Object[]) obj;\n&#x27;
                           &#x27;\t\t\tfinal ArrayNode arrayNode = &#x27;
                           &#x27;csvMapper.createArrayNode();\n&#x27;
                           &#x27;\t\t\tfor (Object element : array) {\n&#x27;
                           &#x27;\t\t\t\t&#x27;
                           &#x27;arrayNode.add(elementConverter.convert(csvMapper, &#x27;
                           &#x27;arrayNode, element));\n&#x27;
                           &#x27;\t\t\t}\n&#x27;
                           &#x27;\t\t\treturn arrayNode;\n&#x27;
                           &#x27;\t\t};\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static RuntimeConverter &#x27;
                           &#x27;createByteArrayRuntimeConverter() {\n&#x27;
                           &#x27;\t\treturn (csvMapper, container, obj) -&gt; &#x27;
                           &#x27;container.binaryNode((byte[]) obj);\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\tprivate static void validateArity(int expected, &#x27;
                           &#x27;int actual) {\n&#x27;
                           &#x27;\t\tif (expected != actual) {\n&#x27;
                           &#x27;\t\t\tthrow new RuntimeException(&quot;Row length &#x27;
                           &#x27;mismatch. &quot; + expected +\n&#x27;
                           &#x27;\t\t\t\t&quot; fields expected but was &quot; + actual + &#x27;
                           &#x27;&quot;.&quot;);\n&#x27;
                           &#x27;\t\t}\n&#x27;
                           &#x27;\t}\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        