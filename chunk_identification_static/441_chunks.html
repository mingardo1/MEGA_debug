<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>441 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.sink.rdb.format;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.enums.EConnectionErrorCode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.sink.rdb.RdbSink;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.JDBCUtils;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.slf4j.Logger;\n&#x27;
                           &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.sql.Connection;\n&#x27;
                           &#x27;import java.sql.DriverManager;\n&#x27;
                           &#x27;import java.sql.PreparedStatement;\n&#x27;
                           &#x27;import java.sql.SQLException;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.util.concurrent.ScheduledThreadPoolExecutor;\n&#x27;
                           &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.outputformat.DtRichOutputFormat;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * OutputFormat to write tuples into a database.\n&#x27;
                           &#x27; * The OutputFormat has to be configured using the &#x27;
                           &#x27;supplied OutputFormatBuilder.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RetractJDBCOutputFormat extends &#x27;
                           &#x27;DtRichOutputFormat {\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;1L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(RetractJDBCOutputFormat.class);\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY = 100;\n&#x27;
                           &#x27;    private int checkTimes;\n&#x27;
                           &#x27;    private String username;\n&#x27;
                           &#x27;    private String password;\n&#x27;
                           &#x27;    private String drivername;\n&#x27;
                           &#x27;    private String dbURL;\n&#x27;
                           &#x27;    private String tableName;\n&#x27;
                           &#x27;    private String dbType;\n&#x27;
                           &#x27;    private String schema;\n&#x27;
                           &#x27;    private RdbSink dbSink;\n&#x27;
                           &#x27;    // trigger preparedStatement execute batch &#x27;
                           &#x27;interval\n&#x27;
                           &#x27;    private long batchWaitInterval = 10000l;\n&#x27;
                           &#x27;    // PreparedStatement execute batch num\n&#x27;
                           &#x27;    private int batchNum = 100;\n&#x27;
                           &#x27;    private String insertQuery;\n&#x27;
                           &#x27;    public int[] typesArray;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** 存储用于批量写入的数据 */\n&#x27;
                           &#x27;    protected List&lt;Row&gt; rows = new ArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Connection dbConn;\n&#x27;
                           &#x27;    private PreparedStatement upload;\n&#x27;
                           &#x27;    private transient ScheduledThreadPoolExecutor &#x27;
                           &#x27;timerService;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //index field\n&#x27;
                           &#x27;    private Map&lt;String, List&lt;String&gt;&gt; realIndexes &#x27;
                           &#x27;= Maps.newHashMap();\n&#x27;
                           &#x27;    //full field\n&#x27;
                           &#x27;    private List&lt;String&gt; fullField = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RetractJDBCOutputFormat() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void configure(Configuration &#x27;
                           &#x27;parameters) {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Connects to the target database and &#x27;
                           &#x27;initializes the prepared statement.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param taskNumber The number of the &#x27;
                           &#x27;parallel instance.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the output &#x27;
                           &#x27;could not be opened due to an\n&#x27;
                           &#x27;     *                     I/O problem.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void open(int taskNumber, int numTasks) &#x27;
                           &#x27;throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;PreparedStatement execute &#x27;
                           &#x27;batch num is {}&quot;, batchNum);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            initMetric();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (existTabname()) {\n&#x27;
                           &#x27;                if (isReplaceInsertQuery()) {\n&#x27;
                           &#x27;                    insertQuery = &#x27;
                           &#x27;dbSink.buildUpdateSql(schema , tableName, &#x27;
                           &#x27;Arrays.asList(dbSink.getFieldNames()), &#x27;
                           &#x27;realIndexes, fullField);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new SQLException(&quot;Table &quot; + &#x27;
                           &#x27;tableName + &quot; doesn\&#x27;t exist&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (batchWaitInterval &gt; 0 &amp;&amp; batchNum &#x27;
                           &#x27;&gt; 1) {\n&#x27;
                           &#x27;                LOG.info(&quot;open batch wait interval &#x27;
                           &#x27;scheduled, interval is {} ms&quot;, &#x27;
                           &#x27;batchWaitInterval);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                timerService = new &#x27;
                           &#x27;ScheduledThreadPoolExecutor(1);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;timerService.scheduleAtFixedRate(() -&gt; {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }, 0, batchWaitInterval, &#x27;
                           &#x27;TimeUnit.MILLISECONDS);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        } catch (SQLException sqe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, sqe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;open() failed.&quot;, sqe);\n&#x27;
                           &#x27;        } catch (ClassNotFoundException cnfe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, cnfe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;JDBC driver class not &#x27;
                           &#x27;found.&quot;, cnfe);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection establishConnection() throws &#x27;
                           &#x27;SQLException, ClassNotFoundException, IOException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        Connection connection ;\n&#x27;
                           &#x27;        JDBCUtils.forName(drivername, &#x27;
                           &#x27;getClass().getClassLoader());\n&#x27;
                           &#x27;        if (username == null) {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL, username, &#x27;
                           &#x27;password);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        connection.setAutoCommit(false);\n&#x27;
                           &#x27;        return connection;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Adds a record to the prepared statement.\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * When this method is called, the output &#x27;
                           &#x27;format is guaranteed to be opened.\n&#x27;
                           &#x27;     * &lt;/p&gt;\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * WARNING: this may fail when no column types &#x27;
                           &#x27;specified (because a best effort approach is &#x27;
                           &#x27;attempted in order to\n&#x27;
                           &quot;     * insert a null value but it&#x27;s not guaranteed &quot;
                           &#x27;that the JDBC driver handles &#x27;
                           &#x27;PreparedStatement.setObject(pos, null))\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param tuple2 The records to add to the &#x27;
                           &#x27;output.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the records &#x27;
                           &#x27;could not be added due to an I/O problem.\n&#x27;
                           &#x27;     * @see PreparedStatement\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void writeRecord(Tuple2 tuple2)  {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Tuple2&lt;Boolean, Row&gt; tupleTrans = tuple2;\n&#x27;
                           &#x27;        Boolean retract = tupleTrans.getField(0);\n&#x27;
                           &#x27;        Row row = tupleTrans.getField(1);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (typesArray != null &amp;&amp; &#x27;
                           &#x27;typesArray.length &gt; 0 &amp;&amp; typesArray.length != &#x27;
                           &#x27;row.getArity()) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Column SQL types array &#x27;
                           &quot;doesn&#x27;t match arity of passed Row! Check the &quot;
                           &#x27;passed array...&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (retract) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (outRecords.getCount() % &#x27;
                           &#x27;ROW_PRINT_FREQUENCY == 0) {\n&#x27;
                           &#x27;                LOG.info(&quot;Receive data : {}&quot;, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outRecords.inc();\n&#x27;
                           &#x27;            insertWrite(row);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            //do nothing\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void insertWrite(Row row)  {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (batchNum == 1) {\n&#x27;
                           &#x27;                writeSingleRecord(row);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;                rows.add(row);\n&#x27;
                           &#x27;                upload.addBatch();\n&#x27;
                           &#x27;                if (rows.size() &gt;= batchNum) {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void writeSingleRecord(Row row) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;            upload.executeUpdate();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            dealSQLException(e);\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outDirtyRecords.inc();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void updatePreparedStmt(Row row, &#x27;
                           &#x27;PreparedStatement pstmt) throws SQLException {\n&#x27;
                           &#x27;        if (typesArray == null) {\n&#x27;
                           &#x27;            // no types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;                LOG.warn(&quot;Unknown column type for &#x27;
                           &#x27;column %s. Best effort approach to set its value: &#x27;
                           &#x27;%s.&quot;, index + 1, row.getField(index));\n&#x27;
                           &#x27;                pstmt.setObject(index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if (row.getField(index) == null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    pstmt.setNull(index + 1, &#x27;
                           &#x27;typesArray[index]);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    // casting values as suggested &#x27;
                           &#x27;by &#x27;
                           &#x27;http://docs.oracle.com/javase/1.5.0/docs/guide/jdbc/getstart/mapping.html\n&#x27;
                           &#x27;                    switch (typesArray[index]) {\n&#x27;
                           &#x27;                        case java.sql.Types.NULL:\n&#x27;
                           &#x27;                            pstmt.setNull(index + &#x27;
                           &#x27;1, typesArray[index]);\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BOOLEAN:\n&#x27;
                           &#x27;                        case java.sql.Types.BIT:\n&#x27;
                           &#x27;                            pstmt.setBoolean(index &#x27;
                           &#x27;+ 1, (boolean) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.CHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGNVARCHAR:\n&#x27;
                           &#x27;                            pstmt.setString(index &#x27;
                           &#x27;+ 1, (String) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TINYINT:\n&#x27;
                           &#x27;                            pstmt.setByte(index + &#x27;
                           &#x27;1, (byte) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.SMALLINT:\n&#x27;
                           &#x27;                            pstmt.setShort(index + &#x27;
                           &#x27;1, (short) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.INTEGER:\n&#x27;
                           &#x27;                            pstmt.setInt(index + &#x27;
                           &#x27;1, (int) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BIGINT:\n&#x27;
                           &#x27;                            pstmt.setLong(index + &#x27;
                           &#x27;1, (long) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.REAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.FLOAT:\n&#x27;
                           &#x27;                            pstmt.setFloat(index + &#x27;
                           &#x27;1, (float) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DOUBLE:\n&#x27;
                           &#x27;                            pstmt.setDouble(index &#x27;
                           &#x27;+ 1, (double) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DECIMAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NUMERIC:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setBigDecimal(index + 1, &#x27;
                           &#x27;(java.math.BigDecimal) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.DATE:\n&#x27;
                           &#x27;                            pstmt.setDate(index + &#x27;
                           &#x27;1, (java.sql.Date) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.TIME:\n&#x27;
                           &#x27;                            pstmt.setTime(index + &#x27;
                           &#x27;1, (java.sql.Time) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TIMESTAMP:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setTimestamp(index + 1, (java.sql.Timestamp) &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARBINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARBINARY:\n&#x27;
                           &#x27;                            pstmt.setBytes(index + &#x27;
                           &#x27;1, (byte[]) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        default:\n&#x27;
                           &#x27;                            pstmt.setObject(index &#x27;
                           &#x27;+ 1, row.getField(index));\n&#x27;
                           &#x27;                            LOG.warn(&quot;Unmanaged &#x27;
                           &#x27;sql type (%s) for column %s. Best effort approach &#x27;
                           &#x27;to set its value: %s.&quot;,\n&#x27;
                           &#x27;                                    &#x27;
                           &#x27;typesArray[index], index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.SQLXML\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ARRAY:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.JAVA_OBJECT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.BLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.CLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.NCLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DATALINK:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DISTINCT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.OTHER:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.REF:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ROWID:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.STRUC\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private synchronized void submitExecuteBatch() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            regularlyCheckConnection();\n&#x27;
                           &#x27;            this.upload.executeBatch();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            LOG.warn(&quot;submitExecuteBatch error &#x27;
                           &#x27;{}&quot;, e);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                dbConn.rollback();\n&#x27;
                           &#x27;            } catch (SQLException e1) {\n&#x27;
                           &#x27;                dealSQLException(e1);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;rows.forEach(this::writeSingleRecord);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void dealSQLException(Exception e) {\n&#x27;
                           &#x27;        EConnectionErrorCode errorCode = &#x27;
                           &#x27;EConnectionErrorCode.resolveErrorCodeFromException(e);\n&#x27;
                           &#x27;        switch (errorCode) {\n&#x27;
                           &#x27;            case CONN_DB_INVALID:\n&#x27;
                           &#x27;                reconnection();\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case CONN_DB_FAILED:\n&#x27;
                           &#x27;            case DB_TABLE_NOT_EXIST:\n&#x27;
                           &#x27;                throw new RuntimeException(e);\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void regularlyCheckConnection() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        checkTimes++;\n&#x27;
                           &#x27;        if (checkTimes % &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY != 0) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        LOG.warn(&quot;db connection Valid check !&quot;);\n&#x27;
                           &#x27;        if (dbConn.isClosed() || &#x27;
                           &#x27;!dbConn.isValid(100)) {\n&#x27;
                           &#x27;            reconnection();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        checkTimes = 0;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void reconnection() throws &#x27;
                           &#x27;RuntimeException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;db connection &#x27;
                           &#x27;reconnect..&quot;);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            this.dbConn = dbConn;\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;connection &#x27;
                           &#x27;open failed..&quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Executes prepared statement and closes all &#x27;
                           &#x27;resources of this instance.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the input &#x27;
                           &#x27;could not be closed properly.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void close() throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (upload != null) {\n&#x27;
                           &#x27;                upload.executeBatch();\n&#x27;
                           &#x27;                upload.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if (null != timerService) {\n&#x27;
                           &#x27;                timerService.shutdown();\n&#x27;
                           &#x27;                LOG.info(&quot;batch wait interval &#x27;
                           &#x27;scheduled service  closed &quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            upload = null;\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (dbConn != null) {\n&#x27;
                           &#x27;                dbConn.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            dbConn = null;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean isReplaceInsertQuery() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void verifyField() {\n&#x27;
                           &#x27;        if (StringUtils.isBlank(username)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(password)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(dbURL)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;dababase URL supplied.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(insertQuery)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;insertQuery supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(drivername)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;driver supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setUsername(String username) {\n&#x27;
                           &#x27;        this.username = username;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getSchema() {\n&#x27;
                           &#x27;        if (StringUtils.isNotEmpty(schema)) {\n&#x27;
                           &#x27;            return schema;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setSchema(String schema) {\n&#x27;
                           &#x27;        this.schema = schema;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean existTabname() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;dbConn.getMetaData().getTables(null, getSchema(), &#x27;
                           &#x27;tableName, null).next();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPassword(String password) {\n&#x27;
                           &#x27;        this.password = password;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDrivername(String drivername) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.drivername = drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDrivername() {\n&#x27;
                           &#x27;        return this.drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbURL(String dbURL) {\n&#x27;
                           &#x27;        this.dbURL = dbURL;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTableName(String tableName) {\n&#x27;
                           &#x27;        this.tableName = tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbType(String dbType) {\n&#x27;
                           &#x27;        this.dbType = dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbSink(RdbSink dbSink) {\n&#x27;
                           &#x27;        this.dbSink = dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                           &#x27;        this.batchNum = batchNum;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setInsertQuery(String insertQuery) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.insertQuery = insertQuery;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTypesArray(int[] typesArray) {\n&#x27;
                           &#x27;        this.typesArray = typesArray;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDbType() {\n&#x27;
                           &#x27;        return dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RdbSink getDbSink() {\n&#x27;
                           &#x27;        return dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection getDbConn() {\n&#x27;
                           &#x27;        return dbConn;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getTableName() {\n&#x27;
                           &#x27;        return tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void realIndexesAdd(String index, &#x27;
                           &#x27;List&lt;String&gt; fieldes) {\n&#x27;
                           &#x27;        this.realIndexes.put(index, fieldes);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Map&lt;String,List&lt;String&gt;&gt; &#x27;
                           &#x27;getRealIndexes() {\n&#x27;
                           &#x27;        return realIndexes;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchWaitInterval(long &#x27;
                           &#x27;batchWaitInterval) {\n&#x27;
                           &#x27;        this.batchWaitInterval = &#x27;
                           &#x27;batchWaitInterval;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public List&lt;String&gt; getFullField() {\n&#x27;
                           &#x27;        return fullField;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void fullFieldAdd(String colName) {\n&#x27;
                           &#x27;        this.fullField.add(colName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.sink.rdb.format;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.enums.EConnectionErrorCode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.sink.rdb.RdbSink;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.JDBCUtils;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.slf4j.Logger;\n&#x27;
                           &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.sql.Connection;\n&#x27;
                           &#x27;import java.sql.DriverManager;\n&#x27;
                           &#x27;import java.sql.PreparedStatement;\n&#x27;
                           &#x27;import java.sql.SQLException;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.util.concurrent.ScheduledThreadPoolExecutor;\n&#x27;
                           &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.outputformat.DtRichOutputFormat;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * OutputFormat to write tuples into a database.\n&#x27;
                           &#x27; * The OutputFormat has to be configured using the &#x27;
                           &#x27;supplied OutputFormatBuilder.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RetractJDBCOutputFormat extends &#x27;
                           &#x27;DtRichOutputFormat {\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;1L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(RetractJDBCOutputFormat.class);\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY = 100;\n&#x27;
                           &#x27;    private int checkTimes;\n&#x27;
                           &#x27;    private String username;\n&#x27;
                           &#x27;    private String password;\n&#x27;
                           &#x27;    private String drivername;\n&#x27;
                           &#x27;    private String dbURL;\n&#x27;
                           &#x27;    private String tableName;\n&#x27;
                           &#x27;    private String dbType;\n&#x27;
                           &#x27;    private String schema;\n&#x27;
                           &#x27;    private RdbSink dbSink;\n&#x27;
                           &#x27;    // trigger preparedStatement execute batch &#x27;
                           &#x27;interval\n&#x27;
                           &#x27;    private long batchWaitInterval = 10000l;\n&#x27;
                           &#x27;    // PreparedStatement execute batch num\n&#x27;
                           &#x27;    private int batchNum = 100;\n&#x27;
                           &#x27;    private String insertQuery;\n&#x27;
                           &#x27;    public int[] typesArray;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** 存储用于批量写入的数据 */\n&#x27;
                           &#x27;    protected List&lt;Row&gt; rows = new ArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Connection dbConn;\n&#x27;
                           &#x27;    private PreparedStatement upload;\n&#x27;
                           &#x27;    private transient ScheduledThreadPoolExecutor &#x27;
                           &#x27;timerService;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //index field\n&#x27;
                           &#x27;    private Map&lt;String, List&lt;String&gt;&gt; realIndexes &#x27;
                           &#x27;= Maps.newHashMap();\n&#x27;
                           &#x27;    //full field\n&#x27;
                           &#x27;    private List&lt;String&gt; fullField = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RetractJDBCOutputFormat() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void configure(Configuration &#x27;
                           &#x27;parameters) {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Connects to the target database and &#x27;
                           &#x27;initializes the prepared statement.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param taskNumber The number of the &#x27;
                           &#x27;parallel instance.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the output &#x27;
                           &#x27;could not be opened due to an\n&#x27;
                           &#x27;     *                     I/O problem.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void open(int taskNumber, int numTasks) &#x27;
                           &#x27;throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;PreparedStatement execute &#x27;
                           &#x27;batch num is {}&quot;, batchNum);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            initMetric();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (existTabname()) {\n&#x27;
                           &#x27;                if (isReplaceInsertQuery()) {\n&#x27;
                           &#x27;                    insertQuery = &#x27;
                           &#x27;dbSink.buildUpdateSql(schema , tableName, &#x27;
                           &#x27;Arrays.asList(dbSink.getFieldNames()), &#x27;
                           &#x27;realIndexes, fullField);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new SQLException(&quot;Table &quot; + &#x27;
                           &#x27;tableName + &quot; doesn\&#x27;t exist&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (batchWaitInterval &gt; 0 &amp;&amp; batchNum &#x27;
                           &#x27;&gt; 1) {\n&#x27;
                           &#x27;                LOG.info(&quot;open batch wait interval &#x27;
                           &#x27;scheduled, interval is {} ms&quot;, &#x27;
                           &#x27;batchWaitInterval);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                timerService = new &#x27;
                           &#x27;ScheduledThreadPoolExecutor(1);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;timerService.scheduleAtFixedRate(() -&gt; {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }, 0, batchWaitInterval, &#x27;
                           &#x27;TimeUnit.MILLISECONDS);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        } catch (SQLException sqe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, sqe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;open() failed.&quot;, sqe);\n&#x27;
                           &#x27;        } catch (ClassNotFoundException cnfe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, cnfe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;JDBC driver class not &#x27;
                           &#x27;found.&quot;, cnfe);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection establishConnection() throws &#x27;
                           &#x27;SQLException, ClassNotFoundException, IOException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        Connection connection ;\n&#x27;
                           &#x27;        JDBCUtils.forName(drivername, &#x27;
                           &#x27;getClass().getClassLoader());\n&#x27;
                           &#x27;        if (username == null) {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL, username, &#x27;
                           &#x27;password);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        connection.setAutoCommit(false);\n&#x27;
                           &#x27;        return connection;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Adds a record to the prepared statement.\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * When this method is called, the output &#x27;
                           &#x27;format is guaranteed to be opened.\n&#x27;
                           &#x27;     * &lt;/p&gt;\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * WARNING: this may fail when no column types &#x27;
                           &#x27;specified (because a best effort approach is &#x27;
                           &#x27;attempted in order to\n&#x27;
                           &quot;     * insert a null value but it&#x27;s not guaranteed &quot;
                           &#x27;that the JDBC driver handles &#x27;
                           &#x27;PreparedStatement.setObject(pos, null))\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param tuple2 The records to add to the &#x27;
                           &#x27;output.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the records &#x27;
                           &#x27;could not be added due to an I/O problem.\n&#x27;
                           &#x27;     * @see PreparedStatement\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void writeRecord(Tuple2 tuple2)  {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Tuple2&lt;Boolean, Row&gt; tupleTrans = tuple2;\n&#x27;
                           &#x27;        Boolean retract = tupleTrans.getField(0);\n&#x27;
                           &#x27;        Row row = tupleTrans.getField(1);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (typesArray != null &amp;&amp; &#x27;
                           &#x27;typesArray.length &gt; 0 &amp;&amp; typesArray.length != &#x27;
                           &#x27;row.getArity()) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Column SQL types array &#x27;
                           &quot;doesn&#x27;t match arity of passed Row! Check the &quot;
                           &#x27;passed array...&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (retract) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (outRecords.getCount() % &#x27;
                           &#x27;ROW_PRINT_FREQUENCY == 0) {\n&#x27;
                           &#x27;                LOG.info(&quot;Receive data : {}&quot;, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outRecords.inc();\n&#x27;
                           &#x27;            insertWrite(row);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            //do nothing\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void insertWrite(Row row)  {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (batchNum == 1) {\n&#x27;
                           &#x27;                writeSingleRecord(row);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;                rows.add(row);\n&#x27;
                           &#x27;                upload.addBatch();\n&#x27;
                           &#x27;                if (rows.size() &gt;= batchNum) {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void writeSingleRecord(Row row) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;            upload.executeUpdate();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            dealSQLException(e);\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outDirtyRecords.inc();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void updatePreparedStmt(Row row, &#x27;
                           &#x27;PreparedStatement pstmt) throws SQLException {\n&#x27;
                           &#x27;        if (typesArray == null) {\n&#x27;
                           &#x27;            // no types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;                LOG.warn(&quot;Unknown column type for &#x27;
                           &#x27;column %s. Best effort approach to set its value: &#x27;
                           &#x27;%s.&quot;, index + 1, row.getField(index));\n&#x27;
                           &#x27;                pstmt.setObject(index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if (row.getField(index) == null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    pstmt.setNull(index + 1, &#x27;
                           &#x27;typesArray[index]);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    // casting values as suggested &#x27;
                           &#x27;by &#x27;
                           &#x27;http://docs.oracle.com/javase/1.5.0/docs/guide/jdbc/getstart/mapping.html\n&#x27;
                           &#x27;                    switch (typesArray[index]) {\n&#x27;
                           &#x27;                        case java.sql.Types.NULL:\n&#x27;
                           &#x27;                            pstmt.setNull(index + &#x27;
                           &#x27;1, typesArray[index]);\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BOOLEAN:\n&#x27;
                           &#x27;                        case java.sql.Types.BIT:\n&#x27;
                           &#x27;                            pstmt.setBoolean(index &#x27;
                           &#x27;+ 1, (boolean) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.CHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGNVARCHAR:\n&#x27;
                           &#x27;                            pstmt.setString(index &#x27;
                           &#x27;+ 1, (String) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TINYINT:\n&#x27;
                           &#x27;                            pstmt.setByte(index + &#x27;
                           &#x27;1, (byte) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.SMALLINT:\n&#x27;
                           &#x27;                            pstmt.setShort(index + &#x27;
                           &#x27;1, (short) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.INTEGER:\n&#x27;
                           &#x27;                            pstmt.setInt(index + &#x27;
                           &#x27;1, (int) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BIGINT:\n&#x27;
                           &#x27;                            pstmt.setLong(index + &#x27;
                           &#x27;1, (long) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.REAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.FLOAT:\n&#x27;
                           &#x27;                            pstmt.setFloat(index + &#x27;
                           &#x27;1, (float) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DOUBLE:\n&#x27;
                           &#x27;                            pstmt.setDouble(index &#x27;
                           &#x27;+ 1, (double) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DECIMAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NUMERIC:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setBigDecimal(index + 1, &#x27;
                           &#x27;(java.math.BigDecimal) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.DATE:\n&#x27;
                           &#x27;                            pstmt.setDate(index + &#x27;
                           &#x27;1, (java.sql.Date) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.TIME:\n&#x27;
                           &#x27;                            pstmt.setTime(index + &#x27;
                           &#x27;1, (java.sql.Time) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TIMESTAMP:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setTimestamp(index + 1, (java.sql.Timestamp) &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARBINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARBINARY:\n&#x27;
                           &#x27;                            pstmt.setBytes(index + &#x27;
                           &#x27;1, (byte[]) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        default:\n&#x27;
                           &#x27;                            pstmt.setObject(index &#x27;
                           &#x27;+ 1, row.getField(index));\n&#x27;
                           &#x27;                            LOG.warn(&quot;Unmanaged &#x27;
                           &#x27;sql type (%s) for column %s. Best effort approach &#x27;
                           &#x27;to set its value: %s.&quot;,\n&#x27;
                           &#x27;                                    &#x27;
                           &#x27;typesArray[index], index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.SQLXML\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ARRAY:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.JAVA_OBJECT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.BLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.CLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.NCLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DATALINK:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DISTINCT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.OTHER:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.REF:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ROWID:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.STRUC\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private synchronized void submitExecuteBatch() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            regularlyCheckConnection();\n&#x27;
                           &#x27;            this.upload.executeBatch();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            LOG.warn(&quot;submitExecuteBatch error &#x27;
                           &#x27;{}&quot;, e);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                dbConn.rollback();\n&#x27;
                           &#x27;            } catch (SQLException e1) {\n&#x27;
                           &#x27;                dealSQLException(e1);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;rows.forEach(this::writeSingleRecord);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void dealSQLException(Exception e) {\n&#x27;
                           &#x27;        EConnectionErrorCode errorCode = &#x27;
                           &#x27;EConnectionErrorCode.resolveErrorCodeFromException(e);\n&#x27;
                           &#x27;        switch (errorCode) {\n&#x27;
                           &#x27;            case CONN_DB_INVALID:\n&#x27;
                           &#x27;                reconnection();\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case CONN_DB_FAILED:\n&#x27;
                           &#x27;            case DB_TABLE_NOT_EXIST:\n&#x27;
                           &#x27;                throw new RuntimeException(e);\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void regularlyCheckConnection() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        checkTimes++;\n&#x27;
                           &#x27;        if (checkTimes % &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY != 0) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        LOG.warn(&quot;db connection Valid check !&quot;);\n&#x27;
                           &#x27;        if (dbConn.isClosed() || &#x27;
                           &#x27;!dbConn.isValid(100)) {\n&#x27;
                           &#x27;            reconnection();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        checkTimes = 0;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void reconnection() throws &#x27;
                           &#x27;RuntimeException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;db connection &#x27;
                           &#x27;reconnect..&quot;);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            this.dbConn = dbConn;\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;connection &#x27;
                           &#x27;open failed..&quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Executes prepared statement and closes all &#x27;
                           &#x27;resources of this instance.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the input &#x27;
                           &#x27;could not be closed properly.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void close() throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (upload != null) {\n&#x27;
                           &#x27;                upload.executeBatch();\n&#x27;
                           &#x27;                upload.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if (null != timerService) {\n&#x27;
                           &#x27;                timerService.shutdown();\n&#x27;
                           &#x27;                LOG.info(&quot;batch wait interval &#x27;
                           &#x27;scheduled service  closed &quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            upload = null;\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (dbConn != null) {\n&#x27;
                           &#x27;                dbConn.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            dbConn = null;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean isReplaceInsertQuery() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void verifyField() {\n&#x27;
                           &#x27;        if (StringUtils.isBlank(username)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(password)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(dbURL)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;dababase URL supplied.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(insertQuery)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;insertQuery supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(drivername)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;driver supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setUsername(String username) {\n&#x27;
                           &#x27;        this.username = username;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getSchema() {\n&#x27;
                           &#x27;        if (StringUtils.isNotEmpty(schema)) {\n&#x27;
                           &#x27;            return schema;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setSchema(String schema) {\n&#x27;
                           &#x27;        this.schema = schema;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean existTabname() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;dbConn.getMetaData().getTables(null, getSchema(), &#x27;
                           &#x27;tableName, null).next();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPassword(String password) {\n&#x27;
                           &#x27;        this.password = password;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDrivername(String drivername) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.drivername = drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDrivername() {\n&#x27;
                           &#x27;        return this.drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbURL(String dbURL) {\n&#x27;
                           &#x27;        this.dbURL = dbURL;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTableName(String tableName) {\n&#x27;
                           &#x27;        this.tableName = tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbType(String dbType) {\n&#x27;
                           &#x27;        this.dbType = dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbSink(RdbSink dbSink) {\n&#x27;
                           &#x27;        this.dbSink = dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                           &#x27;        this.batchNum = batchNum;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setInsertQuery(String insertQuery) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.insertQuery = insertQuery;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTypesArray(int[] typesArray) {\n&#x27;
                           &#x27;        this.typesArray = typesArray;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDbType() {\n&#x27;
                           &#x27;        return dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RdbSink getDbSink() {\n&#x27;
                           &#x27;        return dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection getDbConn() {\n&#x27;
                           &#x27;        return dbConn;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getTableName() {\n&#x27;
                           &#x27;        return tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void realIndexesAdd(String index, &#x27;
                           &#x27;List&lt;String&gt; fieldes) {\n&#x27;
                           &#x27;        this.realIndexes.put(index, fieldes);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Map&lt;String,List&lt;String&gt;&gt; &#x27;
                           &#x27;getRealIndexes() {\n&#x27;
                           &#x27;        return realIndexes;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchWaitInterval(long &#x27;
                           &#x27;batchWaitInterval) {\n&#x27;
                           &#x27;        this.batchWaitInterval = &#x27;
                           &#x27;batchWaitInterval;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public List&lt;String&gt; getFullField() {\n&#x27;
                           &#x27;        return fullField;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void fullFieldAdd(String colName) {\n&#x27;
                           &#x27;        this.fullField.add(colName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.sink.rdb.format;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.enums.EConnectionErrorCode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.sink.rdb.RdbSink;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.JDBCUtils;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.slf4j.Logger;\n&#x27;
                           &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.sql.Connection;\n&#x27;
                           &#x27;import java.sql.DriverManager;\n&#x27;
                           &#x27;import java.sql.PreparedStatement;\n&#x27;
                           &#x27;import java.sql.SQLException;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.util.concurrent.ScheduledThreadPoolExecutor;\n&#x27;
                           &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.outputformat.DtRichOutputFormat;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * OutputFormat to write tuples into a database.\n&#x27;
                           &#x27; * The OutputFormat has to be configured using the &#x27;
                           &#x27;supplied OutputFormatBuilder.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RetractJDBCOutputFormat extends &#x27;
                           &#x27;DtRichOutputFormat {\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;1L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(RetractJDBCOutputFormat.class);\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY = 100;\n&#x27;
                           &#x27;    private int checkTimes;\n&#x27;
                           &#x27;    private String username;\n&#x27;
                           &#x27;    private String password;\n&#x27;
                           &#x27;    private String drivername;\n&#x27;
                           &#x27;    private String dbURL;\n&#x27;
                           &#x27;    private String tableName;\n&#x27;
                           &#x27;    private String dbType;\n&#x27;
                           &#x27;    private String schema;\n&#x27;
                           &#x27;    private RdbSink dbSink;\n&#x27;
                           &#x27;    // trigger preparedStatement execute batch &#x27;
                           &#x27;interval\n&#x27;
                           &#x27;    private long batchWaitInterval = 10000l;\n&#x27;
                           &#x27;    // PreparedStatement execute batch num\n&#x27;
                           &#x27;    private int batchNum = 100;\n&#x27;
                           &#x27;    private String insertQuery;\n&#x27;
                           &#x27;    public int[] typesArray;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** 存储用于批量写入的数据 */\n&#x27;
                           &#x27;    protected List&lt;Row&gt; rows = new ArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Connection dbConn;\n&#x27;
                           &#x27;    private PreparedStatement upload;\n&#x27;
                           &#x27;    private transient ScheduledThreadPoolExecutor &#x27;
                           &#x27;timerService;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //index field\n&#x27;
                           &#x27;    private Map&lt;String, List&lt;String&gt;&gt; realIndexes &#x27;
                           &#x27;= Maps.newHashMap();\n&#x27;
                           &#x27;    //full field\n&#x27;
                           &#x27;    private List&lt;String&gt; fullField = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RetractJDBCOutputFormat() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void configure(Configuration &#x27;
                           &#x27;parameters) {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Connects to the target database and &#x27;
                           &#x27;initializes the prepared statement.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param taskNumber The number of the &#x27;
                           &#x27;parallel instance.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the output &#x27;
                           &#x27;could not be opened due to an\n&#x27;
                           &#x27;     *                     I/O problem.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void open(int taskNumber, int numTasks) &#x27;
                           &#x27;throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;PreparedStatement execute &#x27;
                           &#x27;batch num is {}&quot;, batchNum);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            initMetric();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (existTabname()) {\n&#x27;
                           &#x27;                if (isReplaceInsertQuery()) {\n&#x27;
                           &#x27;                    insertQuery = &#x27;
                           &#x27;dbSink.buildUpdateSql(schema , tableName, &#x27;
                           &#x27;Arrays.asList(dbSink.getFieldNames()), &#x27;
                           &#x27;realIndexes, fullField);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new SQLException(&quot;Table &quot; + &#x27;
                           &#x27;tableName + &quot; doesn\&#x27;t exist&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (batchWaitInterval &gt; 0 &amp;&amp; batchNum &#x27;
                           &#x27;&gt; 1) {\n&#x27;
                           &#x27;                LOG.info(&quot;open batch wait interval &#x27;
                           &#x27;scheduled, interval is {} ms&quot;, &#x27;
                           &#x27;batchWaitInterval);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                timerService = new &#x27;
                           &#x27;ScheduledThreadPoolExecutor(1);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;timerService.scheduleAtFixedRate(() -&gt; {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }, 0, batchWaitInterval, &#x27;
                           &#x27;TimeUnit.MILLISECONDS);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        } catch (SQLException sqe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, sqe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;open() failed.&quot;, sqe);\n&#x27;
                           &#x27;        } catch (ClassNotFoundException cnfe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, cnfe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;JDBC driver class not &#x27;
                           &#x27;found.&quot;, cnfe);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection establishConnection() throws &#x27;
                           &#x27;SQLException, ClassNotFoundException, IOException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        Connection connection ;\n&#x27;
                           &#x27;        JDBCUtils.forName(drivername, &#x27;
                           &#x27;getClass().getClassLoader());\n&#x27;
                           &#x27;        if (username == null) {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL, username, &#x27;
                           &#x27;password);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        connection.setAutoCommit(false);\n&#x27;
                           &#x27;        return connection;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Adds a record to the prepared statement.\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * When this method is called, the output &#x27;
                           &#x27;format is guaranteed to be opened.\n&#x27;
                           &#x27;     * &lt;/p&gt;\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * WARNING: this may fail when no column types &#x27;
                           &#x27;specified (because a best effort approach is &#x27;
                           &#x27;attempted in order to\n&#x27;
                           &quot;     * insert a null value but it&#x27;s not guaranteed &quot;
                           &#x27;that the JDBC driver handles &#x27;
                           &#x27;PreparedStatement.setObject(pos, null))\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param tuple2 The records to add to the &#x27;
                           &#x27;output.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the records &#x27;
                           &#x27;could not be added due to an I/O problem.\n&#x27;
                           &#x27;     * @see PreparedStatement\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void writeRecord(Tuple2 tuple2)  {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Tuple2&lt;Boolean, Row&gt; tupleTrans = tuple2;\n&#x27;
                           &#x27;        Boolean retract = tupleTrans.getField(0);\n&#x27;
                           &#x27;        Row row = tupleTrans.getField(1);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (typesArray != null &amp;&amp; &#x27;
                           &#x27;typesArray.length &gt; 0 &amp;&amp; typesArray.length != &#x27;
                           &#x27;row.getArity()) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Column SQL types array &#x27;
                           &quot;doesn&#x27;t match arity of passed Row! Check the &quot;
                           &#x27;passed array...&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (retract) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (outRecords.getCount() % &#x27;
                           &#x27;ROW_PRINT_FREQUENCY == 0) {\n&#x27;
                           &#x27;                LOG.info(&quot;Receive data : {}&quot;, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outRecords.inc();\n&#x27;
                           &#x27;            insertWrite(row);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            //do nothing\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void insertWrite(Row row)  {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (batchNum == 1) {\n&#x27;
                           &#x27;                writeSingleRecord(row);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;                rows.add(row);\n&#x27;
                           &#x27;                upload.addBatch();\n&#x27;
                           &#x27;                if (rows.size() &gt;= batchNum) {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void writeSingleRecord(Row row) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;            upload.executeUpdate();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            dealSQLException(e);\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outDirtyRecords.inc();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void updatePreparedStmt(Row row, &#x27;
                           &#x27;PreparedStatement pstmt) throws SQLException {\n&#x27;
                           &#x27;        if (typesArray == null) {\n&#x27;
                           &#x27;            // no types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;                LOG.warn(&quot;Unknown column type for &#x27;
                           &#x27;column %s. Best effort approach to set its value: &#x27;
                           &#x27;%s.&quot;, index + 1, row.getField(index));\n&#x27;
                           &#x27;                pstmt.setObject(index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if (row.getField(index) == null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    pstmt.setNull(index + 1, &#x27;
                           &#x27;typesArray[index]);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    // casting values as suggested &#x27;
                           &#x27;by &#x27;
                           &#x27;http://docs.oracle.com/javase/1.5.0/docs/guide/jdbc/getstart/mapping.html\n&#x27;
                           &#x27;                    switch (typesArray[index]) {\n&#x27;
                           &#x27;                        case java.sql.Types.NULL:\n&#x27;
                           &#x27;                            pstmt.setNull(index + &#x27;
                           &#x27;1, typesArray[index]);\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BOOLEAN:\n&#x27;
                           &#x27;                        case java.sql.Types.BIT:\n&#x27;
                           &#x27;                            pstmt.setBoolean(index &#x27;
                           &#x27;+ 1, (boolean) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.CHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGNVARCHAR:\n&#x27;
                           &#x27;                            pstmt.setString(index &#x27;
                           &#x27;+ 1, (String) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TINYINT:\n&#x27;
                           &#x27;                            pstmt.setByte(index + &#x27;
                           &#x27;1, (byte) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.SMALLINT:\n&#x27;
                           &#x27;                            pstmt.setShort(index + &#x27;
                           &#x27;1, (short) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.INTEGER:\n&#x27;
                           &#x27;                            pstmt.setInt(index + &#x27;
                           &#x27;1, (int) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BIGINT:\n&#x27;
                           &#x27;                            pstmt.setLong(index + &#x27;
                           &#x27;1, (long) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.REAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.FLOAT:\n&#x27;
                           &#x27;                            pstmt.setFloat(index + &#x27;
                           &#x27;1, (float) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DOUBLE:\n&#x27;
                           &#x27;                            pstmt.setDouble(index &#x27;
                           &#x27;+ 1, (double) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DECIMAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NUMERIC:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setBigDecimal(index + 1, &#x27;
                           &#x27;(java.math.BigDecimal) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.DATE:\n&#x27;
                           &#x27;                            pstmt.setDate(index + &#x27;
                           &#x27;1, (java.sql.Date) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.TIME:\n&#x27;
                           &#x27;                            pstmt.setTime(index + &#x27;
                           &#x27;1, (java.sql.Time) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TIMESTAMP:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setTimestamp(index + 1, (java.sql.Timestamp) &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARBINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARBINARY:\n&#x27;
                           &#x27;                            pstmt.setBytes(index + &#x27;
                           &#x27;1, (byte[]) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        default:\n&#x27;
                           &#x27;                            pstmt.setObject(index &#x27;
                           &#x27;+ 1, row.getField(index));\n&#x27;
                           &#x27;                            LOG.warn(&quot;Unmanaged &#x27;
                           &#x27;sql type (%s) for column %s. Best effort approach &#x27;
                           &#x27;to set its value: %s.&quot;,\n&#x27;
                           &#x27;                                    &#x27;
                           &#x27;typesArray[index], index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.SQLXML\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ARRAY:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.JAVA_OBJECT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.BLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.CLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.NCLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DATALINK:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DISTINCT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.OTHER:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.REF:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ROWID:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.STRUC\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private synchronized void submitExecuteBatch() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            regularlyCheckConnection();\n&#x27;
                           &#x27;            this.upload.executeBatch();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            LOG.warn(&quot;submitExecuteBatch error &#x27;
                           &#x27;{}&quot;, e);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                dbConn.rollback();\n&#x27;
                           &#x27;            } catch (SQLException e1) {\n&#x27;
                           &#x27;                dealSQLException(e1);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;rows.forEach(this::writeSingleRecord);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void dealSQLException(Exception e) {\n&#x27;
                           &#x27;        EConnectionErrorCode errorCode = &#x27;
                           &#x27;EConnectionErrorCode.resolveErrorCodeFromException(e);\n&#x27;
                           &#x27;        switch (errorCode) {\n&#x27;
                           &#x27;            case CONN_DB_INVALID:\n&#x27;
                           &#x27;                reconnection();\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case CONN_DB_FAILED:\n&#x27;
                           &#x27;            case DB_TABLE_NOT_EXIST:\n&#x27;
                           &#x27;                throw new RuntimeException(e);\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void regularlyCheckConnection() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        checkTimes++;\n&#x27;
                           &#x27;        if (checkTimes % &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY != 0) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        LOG.warn(&quot;db connection Valid check !&quot;);\n&#x27;
                           &#x27;        if (dbConn.isClosed() || &#x27;
                           &#x27;!dbConn.isValid(100)) {\n&#x27;
                           &#x27;            reconnection();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        checkTimes = 0;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void reconnection() throws &#x27;
                           &#x27;RuntimeException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;db connection &#x27;
                           &#x27;reconnect..&quot;);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            this.dbConn = dbConn;\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;connection &#x27;
                           &#x27;open failed..&quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Executes prepared statement and closes all &#x27;
                           &#x27;resources of this instance.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the input &#x27;
                           &#x27;could not be closed properly.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void close() throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (upload != null) {\n&#x27;
                           &#x27;                upload.executeBatch();\n&#x27;
                           &#x27;                upload.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if (null != timerService) {\n&#x27;
                           &#x27;                timerService.shutdown();\n&#x27;
                           &#x27;                LOG.info(&quot;batch wait interval &#x27;
                           &#x27;scheduled service  closed &quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            upload = null;\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (dbConn != null) {\n&#x27;
                           &#x27;                dbConn.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            dbConn = null;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean isReplaceInsertQuery() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void verifyField() {\n&#x27;
                           &#x27;        if (StringUtils.isBlank(username)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(password)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(dbURL)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;dababase URL supplied.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(insertQuery)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;insertQuery supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(drivername)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;driver supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setUsername(String username) {\n&#x27;
                           &#x27;        this.username = username;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getSchema() {\n&#x27;
                           &#x27;        if (StringUtils.isNotEmpty(schema)) {\n&#x27;
                           &#x27;            return schema;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setSchema(String schema) {\n&#x27;
                           &#x27;        this.schema = schema;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean existTabname() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;dbConn.getMetaData().getTables(null, getSchema(), &#x27;
                           &#x27;tableName, null).next();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPassword(String password) {\n&#x27;
                           &#x27;        this.password = password;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDrivername(String drivername) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.drivername = drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDrivername() {\n&#x27;
                           &#x27;        return this.drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbURL(String dbURL) {\n&#x27;
                           &#x27;        this.dbURL = dbURL;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTableName(String tableName) {\n&#x27;
                           &#x27;        this.tableName = tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbType(String dbType) {\n&#x27;
                           &#x27;        this.dbType = dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbSink(RdbSink dbSink) {\n&#x27;
                           &#x27;        this.dbSink = dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                           &#x27;        this.batchNum = batchNum;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setInsertQuery(String insertQuery) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.insertQuery = insertQuery;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTypesArray(int[] typesArray) {\n&#x27;
                           &#x27;        this.typesArray = typesArray;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDbType() {\n&#x27;
                           &#x27;        return dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RdbSink getDbSink() {\n&#x27;
                           &#x27;        return dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection getDbConn() {\n&#x27;
                           &#x27;        return dbConn;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getTableName() {\n&#x27;
                           &#x27;        return tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void realIndexesAdd(String index, &#x27;
                           &#x27;List&lt;String&gt; fieldes) {\n&#x27;
                           &#x27;        this.realIndexes.put(index, fieldes);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Map&lt;String,List&lt;String&gt;&gt; &#x27;
                           &#x27;getRealIndexes() {\n&#x27;
                           &#x27;        return realIndexes;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchWaitInterval(long &#x27;
                           &#x27;batchWaitInterval) {\n&#x27;
                           &#x27;        this.batchWaitInterval = &#x27;
                           &#x27;batchWaitInterval;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public List&lt;String&gt; getFullField() {\n&#x27;
                           &#x27;        return fullField;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void fullFieldAdd(String colName) {\n&#x27;
                           &#x27;        this.fullField.add(colName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.sink.rdb.format;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.enums.EConnectionErrorCode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.sink.rdb.RdbSink;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.JDBCUtils;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.slf4j.Logger;\n&#x27;
                           &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.sql.Connection;\n&#x27;
                           &#x27;import java.sql.DriverManager;\n&#x27;
                           &#x27;import java.sql.PreparedStatement;\n&#x27;
                           &#x27;import java.sql.SQLException;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.util.concurrent.ScheduledThreadPoolExecutor;\n&#x27;
                           &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.outputformat.DtRichOutputFormat;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * OutputFormat to write tuples into a database.\n&#x27;
                           &#x27; * The OutputFormat has to be configured using the &#x27;
                           &#x27;supplied OutputFormatBuilder.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RetractJDBCOutputFormat extends &#x27;
                           &#x27;DtRichOutputFormat {\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;1L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(RetractJDBCOutputFormat.class);\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY = 100;\n&#x27;
                           &#x27;    private int checkTimes;\n&#x27;
                           &#x27;    private String username;\n&#x27;
                           &#x27;    private String password;\n&#x27;
                           &#x27;    private String drivername;\n&#x27;
                           &#x27;    private String dbURL;\n&#x27;
                           &#x27;    private String tableName;\n&#x27;
                           &#x27;    private String dbType;\n&#x27;
                           &#x27;    private String schema;\n&#x27;
                           &#x27;    private RdbSink dbSink;\n&#x27;
                           &#x27;    // trigger preparedStatement execute batch &#x27;
                           &#x27;interval\n&#x27;
                           &#x27;    private long batchWaitInterval = 10000l;\n&#x27;
                           &#x27;    // PreparedStatement execute batch num\n&#x27;
                           &#x27;    private int batchNum = 100;\n&#x27;
                           &#x27;    private String insertQuery;\n&#x27;
                           &#x27;    public int[] typesArray;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** 存储用于批量写入的数据 */\n&#x27;
                           &#x27;    protected List&lt;Row&gt; rows = new ArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Connection dbConn;\n&#x27;
                           &#x27;    private PreparedStatement upload;\n&#x27;
                           &#x27;    private transient ScheduledThreadPoolExecutor &#x27;
                           &#x27;timerService;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //index field\n&#x27;
                           &#x27;    private Map&lt;String, List&lt;String&gt;&gt; realIndexes &#x27;
                           &#x27;= Maps.newHashMap();\n&#x27;
                           &#x27;    //full field\n&#x27;
                           &#x27;    private List&lt;String&gt; fullField = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RetractJDBCOutputFormat() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void configure(Configuration &#x27;
                           &#x27;parameters) {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Connects to the target database and &#x27;
                           &#x27;initializes the prepared statement.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param taskNumber The number of the &#x27;
                           &#x27;parallel instance.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the output &#x27;
                           &#x27;could not be opened due to an\n&#x27;
                           &#x27;     *                     I/O problem.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void open(int taskNumber, int numTasks) &#x27;
                           &#x27;throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;PreparedStatement execute &#x27;
                           &#x27;batch num is {}&quot;, batchNum);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            initMetric();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (existTabname()) {\n&#x27;
                           &#x27;                if (isReplaceInsertQuery()) {\n&#x27;
                           &#x27;                    insertQuery = &#x27;
                           &#x27;dbSink.buildUpdateSql(schema , tableName, &#x27;
                           &#x27;Arrays.asList(dbSink.getFieldNames()), &#x27;
                           &#x27;realIndexes, fullField);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new SQLException(&quot;Table &quot; + &#x27;
                           &#x27;tableName + &quot; doesn\&#x27;t exist&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (batchWaitInterval &gt; 0 &amp;&amp; batchNum &#x27;
                           &#x27;&gt; 1) {\n&#x27;
                           &#x27;                LOG.info(&quot;open batch wait interval &#x27;
                           &#x27;scheduled, interval is {} ms&quot;, &#x27;
                           &#x27;batchWaitInterval);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                timerService = new &#x27;
                           &#x27;ScheduledThreadPoolExecutor(1);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;timerService.scheduleAtFixedRate(() -&gt; {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }, 0, batchWaitInterval, &#x27;
                           &#x27;TimeUnit.MILLISECONDS);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        } catch (SQLException sqe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, sqe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;open() failed.&quot;, sqe);\n&#x27;
                           &#x27;        } catch (ClassNotFoundException cnfe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, cnfe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;JDBC driver class not &#x27;
                           &#x27;found.&quot;, cnfe);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection establishConnection() throws &#x27;
                           &#x27;SQLException, ClassNotFoundException, IOException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        Connection connection ;\n&#x27;
                           &#x27;        JDBCUtils.forName(drivername, &#x27;
                           &#x27;getClass().getClassLoader());\n&#x27;
                           &#x27;        if (username == null) {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL, username, &#x27;
                           &#x27;password);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        connection.setAutoCommit(false);\n&#x27;
                           &#x27;        return connection;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Adds a record to the prepared statement.\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * When this method is called, the output &#x27;
                           &#x27;format is guaranteed to be opened.\n&#x27;
                           &#x27;     * &lt;/p&gt;\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * WARNING: this may fail when no column types &#x27;
                           &#x27;specified (because a best effort approach is &#x27;
                           &#x27;attempted in order to\n&#x27;
                           &quot;     * insert a null value but it&#x27;s not guaranteed &quot;
                           &#x27;that the JDBC driver handles &#x27;
                           &#x27;PreparedStatement.setObject(pos, null))\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param tuple2 The records to add to the &#x27;
                           &#x27;output.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the records &#x27;
                           &#x27;could not be added due to an I/O problem.\n&#x27;
                           &#x27;     * @see PreparedStatement\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void writeRecord(Tuple2 tuple2)  {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Tuple2&lt;Boolean, Row&gt; tupleTrans = tuple2;\n&#x27;
                           &#x27;        Boolean retract = tupleTrans.getField(0);\n&#x27;
                           &#x27;        Row row = tupleTrans.getField(1);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (typesArray != null &amp;&amp; &#x27;
                           &#x27;typesArray.length &gt; 0 &amp;&amp; typesArray.length != &#x27;
                           &#x27;row.getArity()) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Column SQL types array &#x27;
                           &quot;doesn&#x27;t match arity of passed Row! Check the &quot;
                           &#x27;passed array...&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (retract) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (outRecords.getCount() % &#x27;
                           &#x27;ROW_PRINT_FREQUENCY == 0) {\n&#x27;
                           &#x27;                LOG.info(&quot;Receive data : {}&quot;, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outRecords.inc();\n&#x27;
                           &#x27;            insertWrite(row);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            //do nothing\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void insertWrite(Row row)  {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (batchNum == 1) {\n&#x27;
                           &#x27;                writeSingleRecord(row);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;                rows.add(row);\n&#x27;
                           &#x27;                upload.addBatch();\n&#x27;
                           &#x27;                if (rows.size() &gt;= batchNum) {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void writeSingleRecord(Row row) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;            upload.executeUpdate();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            dealSQLException(e);\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outDirtyRecords.inc();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void updatePreparedStmt(Row row, &#x27;
                           &#x27;PreparedStatement pstmt) throws SQLException {\n&#x27;
                           &#x27;        if (typesArray == null) {\n&#x27;
                           &#x27;            // no types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;                LOG.warn(&quot;Unknown column type for &#x27;
                           &#x27;column %s. Best effort approach to set its value: &#x27;
                           &#x27;%s.&quot;, index + 1, row.getField(index));\n&#x27;
                           &#x27;                pstmt.setObject(index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if (row.getField(index) == null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    pstmt.setNull(index + 1, &#x27;
                           &#x27;typesArray[index]);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    // casting values as suggested &#x27;
                           &#x27;by &#x27;
                           &#x27;http://docs.oracle.com/javase/1.5.0/docs/guide/jdbc/getstart/mapping.html\n&#x27;
                           &#x27;                    switch (typesArray[index]) {\n&#x27;
                           &#x27;                        case java.sql.Types.NULL:\n&#x27;
                           &#x27;                            pstmt.setNull(index + &#x27;
                           &#x27;1, typesArray[index]);\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BOOLEAN:\n&#x27;
                           &#x27;                        case java.sql.Types.BIT:\n&#x27;
                           &#x27;                            pstmt.setBoolean(index &#x27;
                           &#x27;+ 1, (boolean) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.CHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGNVARCHAR:\n&#x27;
                           &#x27;                            pstmt.setString(index &#x27;
                           &#x27;+ 1, (String) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TINYINT:\n&#x27;
                           &#x27;                            pstmt.setByte(index + &#x27;
                           &#x27;1, (byte) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.SMALLINT:\n&#x27;
                           &#x27;                            pstmt.setShort(index + &#x27;
                           &#x27;1, (short) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.INTEGER:\n&#x27;
                           &#x27;                            pstmt.setInt(index + &#x27;
                           &#x27;1, (int) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BIGINT:\n&#x27;
                           &#x27;                            pstmt.setLong(index + &#x27;
                           &#x27;1, (long) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.REAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.FLOAT:\n&#x27;
                           &#x27;                            pstmt.setFloat(index + &#x27;
                           &#x27;1, (float) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DOUBLE:\n&#x27;
                           &#x27;                            pstmt.setDouble(index &#x27;
                           &#x27;+ 1, (double) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DECIMAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NUMERIC:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setBigDecimal(index + 1, &#x27;
                           &#x27;(java.math.BigDecimal) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.DATE:\n&#x27;
                           &#x27;                            pstmt.setDate(index + &#x27;
                           &#x27;1, (java.sql.Date) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.TIME:\n&#x27;
                           &#x27;                            pstmt.setTime(index + &#x27;
                           &#x27;1, (java.sql.Time) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TIMESTAMP:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setTimestamp(index + 1, (java.sql.Timestamp) &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARBINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARBINARY:\n&#x27;
                           &#x27;                            pstmt.setBytes(index + &#x27;
                           &#x27;1, (byte[]) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        default:\n&#x27;
                           &#x27;                            pstmt.setObject(index &#x27;
                           &#x27;+ 1, row.getField(index));\n&#x27;
                           &#x27;                            LOG.warn(&quot;Unmanaged &#x27;
                           &#x27;sql type (%s) for column %s. Best effort approach &#x27;
                           &#x27;to set its value: %s.&quot;,\n&#x27;
                           &#x27;                                    &#x27;
                           &#x27;typesArray[index], index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.SQLXML\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ARRAY:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.JAVA_OBJECT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.BLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.CLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.NCLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DATALINK:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DISTINCT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.OTHER:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.REF:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ROWID:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.STRUC\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private synchronized void submitExecuteBatch() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            regularlyCheckConnection();\n&#x27;
                           &#x27;            this.upload.executeBatch();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            LOG.warn(&quot;submitExecuteBatch error &#x27;
                           &#x27;{}&quot;, e);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                dbConn.rollback();\n&#x27;
                           &#x27;            } catch (SQLException e1) {\n&#x27;
                           &#x27;                dealSQLException(e1);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;rows.forEach(this::writeSingleRecord);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void dealSQLException(Exception e) {\n&#x27;
                           &#x27;        EConnectionErrorCode errorCode = &#x27;
                           &#x27;EConnectionErrorCode.resolveErrorCodeFromException(e);\n&#x27;
                           &#x27;        switch (errorCode) {\n&#x27;
                           &#x27;            case CONN_DB_INVALID:\n&#x27;
                           &#x27;                reconnection();\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case CONN_DB_FAILED:\n&#x27;
                           &#x27;            case DB_TABLE_NOT_EXIST:\n&#x27;
                           &#x27;                throw new RuntimeException(e);\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void regularlyCheckConnection() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        checkTimes++;\n&#x27;
                           &#x27;        if (checkTimes % &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY != 0) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        LOG.warn(&quot;db connection Valid check !&quot;);\n&#x27;
                           &#x27;        if (dbConn.isClosed() || &#x27;
                           &#x27;!dbConn.isValid(100)) {\n&#x27;
                           &#x27;            reconnection();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        checkTimes = 0;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void reconnection() throws &#x27;
                           &#x27;RuntimeException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;db connection &#x27;
                           &#x27;reconnect..&quot;);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            this.dbConn = dbConn;\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;connection &#x27;
                           &#x27;open failed..&quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Executes prepared statement and closes all &#x27;
                           &#x27;resources of this instance.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the input &#x27;
                           &#x27;could not be closed properly.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void close() throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (upload != null) {\n&#x27;
                           &#x27;                upload.executeBatch();\n&#x27;
                           &#x27;                upload.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if (null != timerService) {\n&#x27;
                           &#x27;                timerService.shutdown();\n&#x27;
                           &#x27;                LOG.info(&quot;batch wait interval &#x27;
                           &#x27;scheduled service  closed &quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            upload = null;\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (dbConn != null) {\n&#x27;
                           &#x27;                dbConn.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            dbConn = null;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean isReplaceInsertQuery() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void verifyField() {\n&#x27;
                           &#x27;        if (StringUtils.isBlank(username)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(password)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(dbURL)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;dababase URL supplied.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(insertQuery)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;insertQuery supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(drivername)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;driver supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setUsername(String username) {\n&#x27;
                           &#x27;        this.username = username;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getSchema() {\n&#x27;
                           &#x27;        if (StringUtils.isNotEmpty(schema)) {\n&#x27;
                           &#x27;            return schema;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setSchema(String schema) {\n&#x27;
                           &#x27;        this.schema = schema;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean existTabname() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;dbConn.getMetaData().getTables(null, getSchema(), &#x27;
                           &#x27;tableName, null).next();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPassword(String password) {\n&#x27;
                           &#x27;        this.password = password;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDrivername(String drivername) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.drivername = drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDrivername() {\n&#x27;
                           &#x27;        return this.drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbURL(String dbURL) {\n&#x27;
                           &#x27;        this.dbURL = dbURL;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTableName(String tableName) {\n&#x27;
                           &#x27;        this.tableName = tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbType(String dbType) {\n&#x27;
                           &#x27;        this.dbType = dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbSink(RdbSink dbSink) {\n&#x27;
                           &#x27;        this.dbSink = dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                           &#x27;        this.batchNum = batchNum;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setInsertQuery(String insertQuery) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.insertQuery = insertQuery;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTypesArray(int[] typesArray) {\n&#x27;
                           &#x27;        this.typesArray = typesArray;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDbType() {\n&#x27;
                           &#x27;        return dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RdbSink getDbSink() {\n&#x27;
                           &#x27;        return dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection getDbConn() {\n&#x27;
                           &#x27;        return dbConn;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getTableName() {\n&#x27;
                           &#x27;        return tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void realIndexesAdd(String index, &#x27;
                           &#x27;List&lt;String&gt; fieldes) {\n&#x27;
                           &#x27;        this.realIndexes.put(index, fieldes);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Map&lt;String,List&lt;String&gt;&gt; &#x27;
                           &#x27;getRealIndexes() {\n&#x27;
                           &#x27;        return realIndexes;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchWaitInterval(long &#x27;
                           &#x27;batchWaitInterval) {\n&#x27;
                           &#x27;        this.batchWaitInterval = &#x27;
                           &#x27;batchWaitInterval;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public List&lt;String&gt; getFullField() {\n&#x27;
                           &#x27;        return fullField;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void fullFieldAdd(String colName) {\n&#x27;
                           &#x27;        this.fullField.add(colName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.sink.rdb.format;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.enums.EConnectionErrorCode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.sink.rdb.RdbSink;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.JDBCUtils;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.slf4j.Logger;\n&#x27;
                           &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.sql.Connection;\n&#x27;
                           &#x27;import java.sql.DriverManager;\n&#x27;
                           &#x27;import java.sql.PreparedStatement;\n&#x27;
                           &#x27;import java.sql.SQLException;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.util.concurrent.ScheduledThreadPoolExecutor;\n&#x27;
                           &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.outputformat.DtRichOutputFormat;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * OutputFormat to write tuples into a database.\n&#x27;
                           &#x27; * The OutputFormat has to be configured using the &#x27;
                           &#x27;supplied OutputFormatBuilder.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RetractJDBCOutputFormat extends &#x27;
                           &#x27;DtRichOutputFormat {\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;1L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(RetractJDBCOutputFormat.class);\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY = 100;\n&#x27;
                           &#x27;    private int checkTimes;\n&#x27;
                           &#x27;    private String username;\n&#x27;
                           &#x27;    private String password;\n&#x27;
                           &#x27;    private String drivername;\n&#x27;
                           &#x27;    private String dbURL;\n&#x27;
                           &#x27;    private String tableName;\n&#x27;
                           &#x27;    private String dbType;\n&#x27;
                           &#x27;    private String schema;\n&#x27;
                           &#x27;    private RdbSink dbSink;\n&#x27;
                           &#x27;    // trigger preparedStatement execute batch &#x27;
                           &#x27;interval\n&#x27;
                           &#x27;    private long batchWaitInterval = 10000l;\n&#x27;
                           &#x27;    // PreparedStatement execute batch num\n&#x27;
                           &#x27;    private int batchNum = 100;\n&#x27;
                           &#x27;    private String insertQuery;\n&#x27;
                           &#x27;    public int[] typesArray;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** 存储用于批量写入的数据 */\n&#x27;
                           &#x27;    protected List&lt;Row&gt; rows = new ArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Connection dbConn;\n&#x27;
                           &#x27;    private PreparedStatement upload;\n&#x27;
                           &#x27;    private transient ScheduledThreadPoolExecutor &#x27;
                           &#x27;timerService;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //index field\n&#x27;
                           &#x27;    private Map&lt;String, List&lt;String&gt;&gt; realIndexes &#x27;
                           &#x27;= Maps.newHashMap();\n&#x27;
                           &#x27;    //full field\n&#x27;
                           &#x27;    private List&lt;String&gt; fullField = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RetractJDBCOutputFormat() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void configure(Configuration &#x27;
                           &#x27;parameters) {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Connects to the target database and &#x27;
                           &#x27;initializes the prepared statement.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param taskNumber The number of the &#x27;
                           &#x27;parallel instance.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the output &#x27;
                           &#x27;could not be opened due to an\n&#x27;
                           &#x27;     *                     I/O problem.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void open(int taskNumber, int numTasks) &#x27;
                           &#x27;throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;PreparedStatement execute &#x27;
                           &#x27;batch num is {}&quot;, batchNum);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            initMetric();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (existTabname()) {\n&#x27;
                           &#x27;                if (isReplaceInsertQuery()) {\n&#x27;
                           &#x27;                    insertQuery = &#x27;
                           &#x27;dbSink.buildUpdateSql(schema , tableName, &#x27;
                           &#x27;Arrays.asList(dbSink.getFieldNames()), &#x27;
                           &#x27;realIndexes, fullField);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new SQLException(&quot;Table &quot; + &#x27;
                           &#x27;tableName + &quot; doesn\&#x27;t exist&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (batchWaitInterval &gt; 0 &amp;&amp; batchNum &#x27;
                           &#x27;&gt; 1) {\n&#x27;
                           &#x27;                LOG.info(&quot;open batch wait interval &#x27;
                           &#x27;scheduled, interval is {} ms&quot;, &#x27;
                           &#x27;batchWaitInterval);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                timerService = new &#x27;
                           &#x27;ScheduledThreadPoolExecutor(1);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;timerService.scheduleAtFixedRate(() -&gt; {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }, 0, batchWaitInterval, &#x27;
                           &#x27;TimeUnit.MILLISECONDS);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        } catch (SQLException sqe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, sqe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;open() failed.&quot;, sqe);\n&#x27;
                           &#x27;        } catch (ClassNotFoundException cnfe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, cnfe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;JDBC driver class not &#x27;
                           &#x27;found.&quot;, cnfe);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection establishConnection() throws &#x27;
                           &#x27;SQLException, ClassNotFoundException, IOException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        Connection connection ;\n&#x27;
                           &#x27;        JDBCUtils.forName(drivername, &#x27;
                           &#x27;getClass().getClassLoader());\n&#x27;
                           &#x27;        if (username == null) {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL, username, &#x27;
                           &#x27;password);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        connection.setAutoCommit(false);\n&#x27;
                           &#x27;        return connection;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Adds a record to the prepared statement.\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * When this method is called, the output &#x27;
                           &#x27;format is guaranteed to be opened.\n&#x27;
                           &#x27;     * &lt;/p&gt;\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * WARNING: this may fail when no column types &#x27;
                           &#x27;specified (because a best effort approach is &#x27;
                           &#x27;attempted in order to\n&#x27;
                           &quot;     * insert a null value but it&#x27;s not guaranteed &quot;
                           &#x27;that the JDBC driver handles &#x27;
                           &#x27;PreparedStatement.setObject(pos, null))\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param tuple2 The records to add to the &#x27;
                           &#x27;output.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the records &#x27;
                           &#x27;could not be added due to an I/O problem.\n&#x27;
                           &#x27;     * @see PreparedStatement\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void writeRecord(Tuple2 tuple2)  {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Tuple2&lt;Boolean, Row&gt; tupleTrans = tuple2;\n&#x27;
                           &#x27;        Boolean retract = tupleTrans.getField(0);\n&#x27;
                           &#x27;        Row row = tupleTrans.getField(1);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (typesArray != null &amp;&amp; &#x27;
                           &#x27;typesArray.length &gt; 0 &amp;&amp; typesArray.length != &#x27;
                           &#x27;row.getArity()) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Column SQL types array &#x27;
                           &quot;doesn&#x27;t match arity of passed Row! Check the &quot;
                           &#x27;passed array...&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (retract) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (outRecords.getCount() % &#x27;
                           &#x27;ROW_PRINT_FREQUENCY == 0) {\n&#x27;
                           &#x27;                LOG.info(&quot;Receive data : {}&quot;, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outRecords.inc();\n&#x27;
                           &#x27;            insertWrite(row);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            //do nothing\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void insertWrite(Row row)  {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (batchNum == 1) {\n&#x27;
                           &#x27;                writeSingleRecord(row);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;                rows.add(row);\n&#x27;
                           &#x27;                upload.addBatch();\n&#x27;
                           &#x27;                if (rows.size() &gt;= batchNum) {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void writeSingleRecord(Row row) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;            upload.executeUpdate();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            dealSQLException(e);\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outDirtyRecords.inc();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void updatePreparedStmt(Row row, &#x27;
                           &#x27;PreparedStatement pstmt) throws SQLException {\n&#x27;
                           &#x27;        if (typesArray == null) {\n&#x27;
                           &#x27;            // no types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;                LOG.warn(&quot;Unknown column type for &#x27;
                           &#x27;column %s. Best effort approach to set its value: &#x27;
                           &#x27;%s.&quot;, index + 1, row.getField(index));\n&#x27;
                           &#x27;                pstmt.setObject(index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if (row.getField(index) == null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    pstmt.setNull(index + 1, &#x27;
                           &#x27;typesArray[index]);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    // casting values as suggested &#x27;
                           &#x27;by &#x27;
                           &#x27;http://docs.oracle.com/javase/1.5.0/docs/guide/jdbc/getstart/mapping.html\n&#x27;
                           &#x27;                    switch (typesArray[index]) {\n&#x27;
                           &#x27;                        case java.sql.Types.NULL:\n&#x27;
                           &#x27;                            pstmt.setNull(index + &#x27;
                           &#x27;1, typesArray[index]);\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BOOLEAN:\n&#x27;
                           &#x27;                        case java.sql.Types.BIT:\n&#x27;
                           &#x27;                            pstmt.setBoolean(index &#x27;
                           &#x27;+ 1, (boolean) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.CHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGNVARCHAR:\n&#x27;
                           &#x27;                            pstmt.setString(index &#x27;
                           &#x27;+ 1, (String) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TINYINT:\n&#x27;
                           &#x27;                            pstmt.setByte(index + &#x27;
                           &#x27;1, (byte) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.SMALLINT:\n&#x27;
                           &#x27;                            pstmt.setShort(index + &#x27;
                           &#x27;1, (short) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.INTEGER:\n&#x27;
                           &#x27;                            pstmt.setInt(index + &#x27;
                           &#x27;1, (int) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BIGINT:\n&#x27;
                           &#x27;                            pstmt.setLong(index + &#x27;
                           &#x27;1, (long) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.REAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.FLOAT:\n&#x27;
                           &#x27;                            pstmt.setFloat(index + &#x27;
                           &#x27;1, (float) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DOUBLE:\n&#x27;
                           &#x27;                            pstmt.setDouble(index &#x27;
                           &#x27;+ 1, (double) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DECIMAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NUMERIC:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setBigDecimal(index + 1, &#x27;
                           &#x27;(java.math.BigDecimal) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.DATE:\n&#x27;
                           &#x27;                            pstmt.setDate(index + &#x27;
                           &#x27;1, (java.sql.Date) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.TIME:\n&#x27;
                           &#x27;                            pstmt.setTime(index + &#x27;
                           &#x27;1, (java.sql.Time) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TIMESTAMP:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setTimestamp(index + 1, (java.sql.Timestamp) &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARBINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARBINARY:\n&#x27;
                           &#x27;                            pstmt.setBytes(index + &#x27;
                           &#x27;1, (byte[]) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        default:\n&#x27;
                           &#x27;                            pstmt.setObject(index &#x27;
                           &#x27;+ 1, row.getField(index));\n&#x27;
                           &#x27;                            LOG.warn(&quot;Unmanaged &#x27;
                           &#x27;sql type (%s) for column %s. Best effort approach &#x27;
                           &#x27;to set its value: %s.&quot;,\n&#x27;
                           &#x27;                                    &#x27;
                           &#x27;typesArray[index], index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.SQLXML\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ARRAY:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.JAVA_OBJECT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.BLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.CLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.NCLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DATALINK:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DISTINCT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.OTHER:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.REF:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ROWID:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.STRUC\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private synchronized void submitExecuteBatch() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            regularlyCheckConnection();\n&#x27;
                           &#x27;            this.upload.executeBatch();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            LOG.warn(&quot;submitExecuteBatch error &#x27;
                           &#x27;{}&quot;, e);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                dbConn.rollback();\n&#x27;
                           &#x27;            } catch (SQLException e1) {\n&#x27;
                           &#x27;                dealSQLException(e1);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;rows.forEach(this::writeSingleRecord);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void dealSQLException(Exception e) {\n&#x27;
                           &#x27;        EConnectionErrorCode errorCode = &#x27;
                           &#x27;EConnectionErrorCode.resolveErrorCodeFromException(e);\n&#x27;
                           &#x27;        switch (errorCode) {\n&#x27;
                           &#x27;            case CONN_DB_INVALID:\n&#x27;
                           &#x27;                reconnection();\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case CONN_DB_FAILED:\n&#x27;
                           &#x27;            case DB_TABLE_NOT_EXIST:\n&#x27;
                           &#x27;                throw new RuntimeException(e);\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void regularlyCheckConnection() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        checkTimes++;\n&#x27;
                           &#x27;        if (checkTimes % &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY != 0) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        LOG.warn(&quot;db connection Valid check !&quot;);\n&#x27;
                           &#x27;        if (dbConn.isClosed() || &#x27;
                           &#x27;!dbConn.isValid(100)) {\n&#x27;
                           &#x27;            reconnection();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        checkTimes = 0;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void reconnection() throws &#x27;
                           &#x27;RuntimeException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;db connection &#x27;
                           &#x27;reconnect..&quot;);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            this.dbConn = dbConn;\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;connection &#x27;
                           &#x27;open failed..&quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Executes prepared statement and closes all &#x27;
                           &#x27;resources of this instance.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the input &#x27;
                           &#x27;could not be closed properly.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void close() throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (upload != null) {\n&#x27;
                           &#x27;                upload.executeBatch();\n&#x27;
                           &#x27;                upload.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if (null != timerService) {\n&#x27;
                           &#x27;                timerService.shutdown();\n&#x27;
                           &#x27;                LOG.info(&quot;batch wait interval &#x27;
                           &#x27;scheduled service  closed &quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            upload = null;\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (dbConn != null) {\n&#x27;
                           &#x27;                dbConn.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            dbConn = null;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean isReplaceInsertQuery() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void verifyField() {\n&#x27;
                           &#x27;        if (StringUtils.isBlank(username)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(password)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(dbURL)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;dababase URL supplied.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(insertQuery)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;insertQuery supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(drivername)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;driver supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setUsername(String username) {\n&#x27;
                           &#x27;        this.username = username;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getSchema() {\n&#x27;
                           &#x27;        if (StringUtils.isNotEmpty(schema)) {\n&#x27;
                           &#x27;            return schema;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setSchema(String schema) {\n&#x27;
                           &#x27;        this.schema = schema;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean existTabname() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;dbConn.getMetaData().getTables(null, getSchema(), &#x27;
                           &#x27;tableName, null).next();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPassword(String password) {\n&#x27;
                           &#x27;        this.password = password;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDrivername(String drivername) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.drivername = drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDrivername() {\n&#x27;
                           &#x27;        return this.drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbURL(String dbURL) {\n&#x27;
                           &#x27;        this.dbURL = dbURL;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTableName(String tableName) {\n&#x27;
                           &#x27;        this.tableName = tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbType(String dbType) {\n&#x27;
                           &#x27;        this.dbType = dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbSink(RdbSink dbSink) {\n&#x27;
                           &#x27;        this.dbSink = dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                           &#x27;        this.batchNum = batchNum;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setInsertQuery(String insertQuery) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.insertQuery = insertQuery;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTypesArray(int[] typesArray) {\n&#x27;
                           &#x27;        this.typesArray = typesArray;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDbType() {\n&#x27;
                           &#x27;        return dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RdbSink getDbSink() {\n&#x27;
                           &#x27;        return dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection getDbConn() {\n&#x27;
                           &#x27;        return dbConn;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getTableName() {\n&#x27;
                           &#x27;        return tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void realIndexesAdd(String index, &#x27;
                           &#x27;List&lt;String&gt; fieldes) {\n&#x27;
                           &#x27;        this.realIndexes.put(index, fieldes);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Map&lt;String,List&lt;String&gt;&gt; &#x27;
                           &#x27;getRealIndexes() {\n&#x27;
                           &#x27;        return realIndexes;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchWaitInterval(long &#x27;
                           &#x27;batchWaitInterval) {\n&#x27;
                           &#x27;        this.batchWaitInterval = &#x27;
                           &#x27;batchWaitInterval;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public List&lt;String&gt; getFullField() {\n&#x27;
                           &#x27;        return fullField;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void fullFieldAdd(String colName) {\n&#x27;
                           &#x27;        this.fullField.add(colName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.sink.rdb.format;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.enums.EConnectionErrorCode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.sink.rdb.RdbSink;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.JDBCUtils;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.slf4j.Logger;\n&#x27;
                           &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.sql.Connection;\n&#x27;
                           &#x27;import java.sql.DriverManager;\n&#x27;
                           &#x27;import java.sql.PreparedStatement;\n&#x27;
                           &#x27;import java.sql.SQLException;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.util.concurrent.ScheduledThreadPoolExecutor;\n&#x27;
                           &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.outputformat.DtRichOutputFormat;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * OutputFormat to write tuples into a database.\n&#x27;
                           &#x27; * The OutputFormat has to be configured using the &#x27;
                           &#x27;supplied OutputFormatBuilder.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RetractJDBCOutputFormat extends &#x27;
                           &#x27;DtRichOutputFormat {\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;1L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(RetractJDBCOutputFormat.class);\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY = 100;\n&#x27;
                           &#x27;    private int checkTimes;\n&#x27;
                           &#x27;    private String username;\n&#x27;
                           &#x27;    private String password;\n&#x27;
                           &#x27;    private String drivername;\n&#x27;
                           &#x27;    private String dbURL;\n&#x27;
                           &#x27;    private String tableName;\n&#x27;
                           &#x27;    private String dbType;\n&#x27;
                           &#x27;    private String schema;\n&#x27;
                           &#x27;    private RdbSink dbSink;\n&#x27;
                           &#x27;    // trigger preparedStatement execute batch &#x27;
                           &#x27;interval\n&#x27;
                           &#x27;    private long batchWaitInterval = 10000l;\n&#x27;
                           &#x27;    // PreparedStatement execute batch num\n&#x27;
                           &#x27;    private int batchNum = 100;\n&#x27;
                           &#x27;    private String insertQuery;\n&#x27;
                           &#x27;    public int[] typesArray;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** 存储用于批量写入的数据 */\n&#x27;
                           &#x27;    protected List&lt;Row&gt; rows = new ArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Connection dbConn;\n&#x27;
                           &#x27;    private PreparedStatement upload;\n&#x27;
                           &#x27;    private transient ScheduledThreadPoolExecutor &#x27;
                           &#x27;timerService;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //index field\n&#x27;
                           &#x27;    private Map&lt;String, List&lt;String&gt;&gt; realIndexes &#x27;
                           &#x27;= Maps.newHashMap();\n&#x27;
                           &#x27;    //full field\n&#x27;
                           &#x27;    private List&lt;String&gt; fullField = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RetractJDBCOutputFormat() {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void configure(Configuration &#x27;
                           &#x27;parameters) {\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Connects to the target database and &#x27;
                           &#x27;initializes the prepared statement.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param taskNumber The number of the &#x27;
                           &#x27;parallel instance.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the output &#x27;
                           &#x27;could not be opened due to an\n&#x27;
                           &#x27;     *                     I/O problem.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void open(int taskNumber, int numTasks) &#x27;
                           &#x27;throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;PreparedStatement execute &#x27;
                           &#x27;batch num is {}&quot;, batchNum);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            initMetric();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (existTabname()) {\n&#x27;
                           &#x27;                if (isReplaceInsertQuery()) {\n&#x27;
                           &#x27;                    insertQuery = &#x27;
                           &#x27;dbSink.buildUpdateSql(schema , tableName, &#x27;
                           &#x27;Arrays.asList(dbSink.getFieldNames()), &#x27;
                           &#x27;realIndexes, fullField);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new SQLException(&quot;Table &quot; + &#x27;
                           &#x27;tableName + &quot; doesn\&#x27;t exist&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (batchWaitInterval &gt; 0 &amp;&amp; batchNum &#x27;
                           &#x27;&gt; 1) {\n&#x27;
                           &#x27;                LOG.info(&quot;open batch wait interval &#x27;
                           &#x27;scheduled, interval is {} ms&quot;, &#x27;
                           &#x27;batchWaitInterval);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                timerService = new &#x27;
                           &#x27;ScheduledThreadPoolExecutor(1);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;timerService.scheduleAtFixedRate(() -&gt; {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }, 0, batchWaitInterval, &#x27;
                           &#x27;TimeUnit.MILLISECONDS);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        } catch (SQLException sqe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, sqe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;open() failed.&quot;, sqe);\n&#x27;
                           &#x27;        } catch (ClassNotFoundException cnfe) {\n&#x27;
                           &#x27;            LOG.error(&quot;&quot;, cnfe);\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;JDBC driver class not &#x27;
                           &#x27;found.&quot;, cnfe);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection establishConnection() throws &#x27;
                           &#x27;SQLException, ClassNotFoundException, IOException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        Connection connection ;\n&#x27;
                           &#x27;        JDBCUtils.forName(drivername, &#x27;
                           &#x27;getClass().getClassLoader());\n&#x27;
                           &#x27;        if (username == null) {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbURL, username, &#x27;
                           &#x27;password);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        connection.setAutoCommit(false);\n&#x27;
                           &#x27;        return connection;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Adds a record to the prepared statement.\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * When this method is called, the output &#x27;
                           &#x27;format is guaranteed to be opened.\n&#x27;
                           &#x27;     * &lt;/p&gt;\n&#x27;
                           &#x27;     * &lt;p&gt;\n&#x27;
                           &#x27;     * WARNING: this may fail when no column types &#x27;
                           &#x27;specified (because a best effort approach is &#x27;
                           &#x27;attempted in order to\n&#x27;
                           &quot;     * insert a null value but it&#x27;s not guaranteed &quot;
                           &#x27;that the JDBC driver handles &#x27;
                           &#x27;PreparedStatement.setObject(pos, null))\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param tuple2 The records to add to the &#x27;
                           &#x27;output.\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the records &#x27;
                           &#x27;could not be added due to an I/O problem.\n&#x27;
                           &#x27;     * @see PreparedStatement\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void writeRecord(Tuple2 tuple2)  {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Tuple2&lt;Boolean, Row&gt; tupleTrans = tuple2;\n&#x27;
                           &#x27;        Boolean retract = tupleTrans.getField(0);\n&#x27;
                           &#x27;        Row row = tupleTrans.getField(1);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (typesArray != null &amp;&amp; &#x27;
                           &#x27;typesArray.length &gt; 0 &amp;&amp; typesArray.length != &#x27;
                           &#x27;row.getArity()) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Column SQL types array &#x27;
                           &quot;doesn&#x27;t match arity of passed Row! Check the &quot;
                           &#x27;passed array...&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (retract) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (outRecords.getCount() % &#x27;
                           &#x27;ROW_PRINT_FREQUENCY == 0) {\n&#x27;
                           &#x27;                LOG.info(&quot;Receive data : {}&quot;, &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outRecords.inc();\n&#x27;
                           &#x27;            insertWrite(row);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            //do nothing\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void insertWrite(Row row)  {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (batchNum == 1) {\n&#x27;
                           &#x27;                writeSingleRecord(row);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;                rows.add(row);\n&#x27;
                           &#x27;                upload.addBatch();\n&#x27;
                           &#x27;                if (rows.size() &gt;= batchNum) {\n&#x27;
                           &#x27;                    submitExecuteBatch();\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                outDirtyRecords.inc(batchNum == 1 &#x27;
                           &#x27;? batchNum : rows.size());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void writeSingleRecord(Row row) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            updatePreparedStmt(row, upload);\n&#x27;
                           &#x27;            upload.executeUpdate();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            dealSQLException(e);\n&#x27;
                           &#x27;            if (outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                LOG.error(&quot;record insert &#x27;
                           &#x27;failed,dirty record num:{}, current row:{}&quot;, &#x27;
                           &#x27;outDirtyRecords.getCount(), row.toString());\n&#x27;
                           &#x27;                LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            outDirtyRecords.inc();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void updatePreparedStmt(Row row, &#x27;
                           &#x27;PreparedStatement pstmt) throws SQLException {\n&#x27;
                           &#x27;        if (typesArray == null) {\n&#x27;
                           &#x27;            // no types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;                LOG.warn(&quot;Unknown column type for &#x27;
                           &#x27;column %s. Best effort approach to set its value: &#x27;
                           &#x27;%s.&quot;, index + 1, row.getField(index));\n&#x27;
                           &#x27;                pstmt.setObject(index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // types provided\n&#x27;
                           &#x27;            for (int index = 0; index &lt; &#x27;
                           &#x27;row.getArity(); index++) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if (row.getField(index) == null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    pstmt.setNull(index + 1, &#x27;
                           &#x27;typesArray[index]);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    // casting values as suggested &#x27;
                           &#x27;by &#x27;
                           &#x27;http://docs.oracle.com/javase/1.5.0/docs/guide/jdbc/getstart/mapping.html\n&#x27;
                           &#x27;                    switch (typesArray[index]) {\n&#x27;
                           &#x27;                        case java.sql.Types.NULL:\n&#x27;
                           &#x27;                            pstmt.setNull(index + &#x27;
                           &#x27;1, typesArray[index]);\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BOOLEAN:\n&#x27;
                           &#x27;                        case java.sql.Types.BIT:\n&#x27;
                           &#x27;                            pstmt.setBoolean(index &#x27;
                           &#x27;+ 1, (boolean) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.CHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARCHAR:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGNVARCHAR:\n&#x27;
                           &#x27;                            pstmt.setString(index &#x27;
                           &#x27;+ 1, (String) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TINYINT:\n&#x27;
                           &#x27;                            pstmt.setByte(index + &#x27;
                           &#x27;1, (byte) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.SMALLINT:\n&#x27;
                           &#x27;                            pstmt.setShort(index + &#x27;
                           &#x27;1, (short) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.INTEGER:\n&#x27;
                           &#x27;                            pstmt.setInt(index + &#x27;
                           &#x27;1, (int) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BIGINT:\n&#x27;
                           &#x27;                            pstmt.setLong(index + &#x27;
                           &#x27;1, (long) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.REAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.FLOAT:\n&#x27;
                           &#x27;                            pstmt.setFloat(index + &#x27;
                           &#x27;1, (float) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DOUBLE:\n&#x27;
                           &#x27;                            pstmt.setDouble(index &#x27;
                           &#x27;+ 1, (double) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.DECIMAL:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.NUMERIC:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setBigDecimal(index + 1, &#x27;
                           &#x27;(java.math.BigDecimal) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.DATE:\n&#x27;
                           &#x27;                            pstmt.setDate(index + &#x27;
                           &#x27;1, (java.sql.Date) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case java.sql.Types.TIME:\n&#x27;
                           &#x27;                            pstmt.setTime(index + &#x27;
                           &#x27;1, (java.sql.Time) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.TIMESTAMP:\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;pstmt.setTimestamp(index + 1, (java.sql.Timestamp) &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.BINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.VARBINARY:\n&#x27;
                           &#x27;                        case &#x27;
                           &#x27;java.sql.Types.LONGVARBINARY:\n&#x27;
                           &#x27;                            pstmt.setBytes(index + &#x27;
                           &#x27;1, (byte[]) row.getField(index));\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        default:\n&#x27;
                           &#x27;                            pstmt.setObject(index &#x27;
                           &#x27;+ 1, row.getField(index));\n&#x27;
                           &#x27;                            LOG.warn(&quot;Unmanaged &#x27;
                           &#x27;sql type (%s) for column %s. Best effort approach &#x27;
                           &#x27;to set its value: %s.&quot;,\n&#x27;
                           &#x27;                                    &#x27;
                           &#x27;typesArray[index], index + 1, &#x27;
                           &#x27;row.getField(index));\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.SQLXML\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ARRAY:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.JAVA_OBJECT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.BLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.CLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.NCLOB:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DATALINK:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.DISTINCT:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.OTHER:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.REF:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.ROWID:\n&#x27;
                           &#x27;                            // case &#x27;
                           &#x27;java.sql.Types.STRUC\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private synchronized void submitExecuteBatch() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            regularlyCheckConnection();\n&#x27;
                           &#x27;            this.upload.executeBatch();\n&#x27;
                           &#x27;            dbConn.commit();\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            LOG.warn(&quot;submitExecuteBatch error &#x27;
                           &#x27;{}&quot;, e);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                dbConn.rollback();\n&#x27;
                           &#x27;            } catch (SQLException e1) {\n&#x27;
                           &#x27;                dealSQLException(e1);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;rows.forEach(this::writeSingleRecord);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void dealSQLException(Exception e) {\n&#x27;
                           &#x27;        EConnectionErrorCode errorCode = &#x27;
                           &#x27;EConnectionErrorCode.resolveErrorCodeFromException(e);\n&#x27;
                           &#x27;        switch (errorCode) {\n&#x27;
                           &#x27;            case CONN_DB_INVALID:\n&#x27;
                           &#x27;                reconnection();\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case CONN_DB_FAILED:\n&#x27;
                           &#x27;            case DB_TABLE_NOT_EXIST:\n&#x27;
                           &#x27;                throw new RuntimeException(e);\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void regularlyCheckConnection() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        checkTimes++;\n&#x27;
                           &#x27;        if (checkTimes % &#x27;
                           &#x27;CONNECTION_CHECK_FREQUENCY != 0) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        LOG.warn(&quot;db connection Valid check !&quot;);\n&#x27;
                           &#x27;        if (dbConn.isClosed() || &#x27;
                           &#x27;!dbConn.isValid(100)) {\n&#x27;
                           &#x27;            reconnection();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        checkTimes = 0;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void reconnection() throws &#x27;
                           &#x27;RuntimeException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            LOG.info(&quot;db connection &#x27;
                           &#x27;reconnect..&quot;);\n&#x27;
                           &#x27;            dbConn = establishConnection();\n&#x27;
                           &#x27;            upload = &#x27;
                           &#x27;dbConn.prepareStatement(insertQuery);\n&#x27;
                           &#x27;            this.dbConn = dbConn;\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;connection &#x27;
                           &#x27;open failed..&quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Executes prepared statement and closes all &#x27;
                           &#x27;resources of this instance.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @throws IOException Thrown, if the input &#x27;
                           &#x27;could not be closed properly.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void close() throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (upload != null) {\n&#x27;
                           &#x27;                upload.executeBatch();\n&#x27;
                           &#x27;                upload.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if (null != timerService) {\n&#x27;
                           &#x27;                timerService.shutdown();\n&#x27;
                           &#x27;                LOG.info(&quot;batch wait interval &#x27;
                           &#x27;scheduled service  closed &quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            upload = null;\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (dbConn != null) {\n&#x27;
                           &#x27;                dbConn.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException se) {\n&#x27;
                           &#x27;            LOG.info(&quot;Inputformat couldn\&#x27;t be &#x27;
                           &#x27;closed - &quot;, se);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            dbConn = null;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean isReplaceInsertQuery() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void verifyField() {\n&#x27;
                           &#x27;        if (StringUtils.isBlank(username)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(password)) {\n&#x27;
                           &#x27;            LOG.warn(&quot;Username was not supplied &#x27;
                           &#x27;separately.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(dbURL)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;dababase URL supplied.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(insertQuery)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;insertQuery supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (StringUtils.isBlank(drivername)) {\n&#x27;
                           &#x27;            throw new IllegalArgumentException(&quot;No &#x27;
                           &#x27;driver supplied&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setUsername(String username) {\n&#x27;
                           &#x27;        this.username = username;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getSchema() {\n&#x27;
                           &#x27;        if (StringUtils.isNotEmpty(schema)) {\n&#x27;
                           &#x27;            return schema;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setSchema(String schema) {\n&#x27;
                           &#x27;        this.schema = schema;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean existTabname() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;dbConn.getMetaData().getTables(null, getSchema(), &#x27;
                           &#x27;tableName, null).next();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setPassword(String password) {\n&#x27;
                           &#x27;        this.password = password;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDrivername(String drivername) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.drivername = drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDrivername() {\n&#x27;
                           &#x27;        return this.drivername;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbURL(String dbURL) {\n&#x27;
                           &#x27;        this.dbURL = dbURL;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTableName(String tableName) {\n&#x27;
                           &#x27;        this.tableName = tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbType(String dbType) {\n&#x27;
                           &#x27;        this.dbType = dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setDbSink(RdbSink dbSink) {\n&#x27;
                           &#x27;        this.dbSink = dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                           &#x27;        this.batchNum = batchNum;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setInsertQuery(String insertQuery) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        this.insertQuery = insertQuery;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setTypesArray(int[] typesArray) {\n&#x27;
                           &#x27;        this.typesArray = typesArray;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getDbType() {\n&#x27;
                           &#x27;        return dbType;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public RdbSink getDbSink() {\n&#x27;
                           &#x27;        return dbSink;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Connection getDbConn() {\n&#x27;
                           &#x27;        return dbConn;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String getTableName() {\n&#x27;
                           &#x27;        return tableName;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void realIndexesAdd(String index, &#x27;
                           &#x27;List&lt;String&gt; fieldes) {\n&#x27;
                           &#x27;        this.realIndexes.put(index, fieldes);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Map&lt;String,List&lt;String&gt;&gt; &#x27;
                           &#x27;getRealIndexes() {\n&#x27;
                           &#x27;        return realIndexes;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void setBatchWaitInterval(long &#x27;
                           &#x27;batchWaitInterval) {\n&#x27;
                           &#x27;        this.batchWaitInterval = &#x27;
                           &#x27;batchWaitInterval;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public List&lt;String&gt; getFullField() {\n&#x27;
                           &#x27;        return fullField;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void fullFieldAdd(String colName) {\n&#x27;
                           &#x27;        this.fullField.add(colName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        