<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>529</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    529
                    <a href="528.html">prev</a>
                    <a href="530.html">next</a>
                    <a href="529_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_f05e92b15d5e4c94442e53a9f83e2659c369aa5e_cassandra/cassandra-side/cassandra-async-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f05e92b15d5e4c94442e53a9f83e2659c369aa5e:cassandra/cassandra-side/cassandra-async-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f05e92b15d5e4c94442e53a9f83e2659c369aa5e^1:cassandra/cassandra-side/cassandra-async-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f05e92b15d5e4c94442e53a9f83e2659c369aa5e^2:cassandra/cassandra-side/cassandra-async-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;14446f4dd844b1bb9da6c412e3556e135bafcba4:cassandra/cassandra-side/cassandra-async-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.cassandra;
  21 
  22 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  23 import org.apache.flink.configuration.Configuration;
  24 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  25 import org.apache.flink.table.runtime.types.CRow;
  26 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  27 import org.apache.flink.types.Row;
  28 
  29 import com.datastax.driver.core.Cluster;
  30 import com.datastax.driver.core.ConsistencyLevel;
  31 import com.datastax.driver.core.HostDistance;
  32 import com.datastax.driver.core.PoolingOptions;
  33 import com.datastax.driver.core.QueryOptions;
  34 import com.datastax.driver.core.ResultSet;
  35 import com.datastax.driver.core.Session;
  36 import com.datastax.driver.core.SocketOptions;
  37 import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  38 import com.datastax.driver.core.policies.RetryPolicy;
  39 import com.dtstack.flink.sql.enums.ECacheContentType;
  40 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  41 import com.dtstack.flink.sql.side.CacheMissVal;
  42 import com.dtstack.flink.sql.side.FieldInfo;
  43 import com.dtstack.flink.sql.side.JoinInfo;
  44 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  45 import com.dtstack.flink.sql.side.cache.CacheObj;
  46 import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
  47 import com.google.common.base.Function;
  48 import com.google.common.collect.Lists;
  49 import com.google.common.util.concurrent.AsyncFunction;
  50 import com.google.common.util.concurrent.FutureCallback;
  51 import com.google.common.util.concurrent.Futures;
  52 import com.google.common.util.concurrent.ListenableFuture;
  53 import io.vertx.core.json.JsonArray;
  54 import org.apache.commons.lang3.StringUtils;
  55 import org.slf4j.Logger;
  56 import org.slf4j.LoggerFactory;
  57 
  58 import java.net.InetAddress;
  59 import java.sql.Timestamp;
  60 import java.util.ArrayList;
  61 import java.util.List;
  62 import java.util.Map;
  63 
  64 /**
  65  * Reason:
  66  * Date: 2018/11/22
  67  *
  68  * @author xuqianjin
  69  */
  70 public class CassandraAsyncReqRow extends BaseAsyncReqRow {
  71 
  72     private static final long serialVersionUID = 6631584128079864735L;
  73 
  74     private static final Logger LOG = LoggerFactory.getLogger(CassandraAsyncReqRow.class);
  75 
  76     private final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 10;
  77 
  78     private final static int DEFAULT_VERTX_WORKER_POOL_SIZE = 20;
  79 
  80     private final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = 20;
  81 
  82     private transient Cluster cluster;
  83     private transient ListenableFuture session;
  84     private transient CassandraSideTableInfo cassandraSideTableInfo;
  85 
<abbr title="  86     public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  86     public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoL🔵</abbr>
<abbr title="  87         super(new com.dtstack.flink.sql.side.cassandra.CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));">  87         super(new com.dtstack.flink.sql.side.cassandra.CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outF🔵</abbr>
  88     }
  89 
  90 
  91     @Override
  92     public void open(Configuration parameters) throws Exception {
  93         super.open(parameters);
  94         cassandraSideTableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
  95         connCassandraDB(cassandraSideTableInfo);
  96     }
  97 
  98     private void connCassandraDB(CassandraSideTableInfo tableInfo) {
  99         try {
 100             if (session == null) {
 101                 QueryOptions queryOptions = new QueryOptions();
 102                 //The default consistency level for queries: ConsistencyLevel.TWO.
 103                 queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 104                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 104                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : 🔵</abbr>
<abbr title=" 105                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 105                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tabl🔵</abbr>
<abbr title=" 106                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 106                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : ta🔵</abbr>
<abbr title=" 107                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();"> 107                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQue🔵</abbr>
<abbr title=" 108                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 108                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
<abbr title=" 109                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 109                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tabl🔵</abbr>
<abbr title=" 110                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 110                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
 111                 Integer cassandraPort = 0;
 112                 String address = tableInfo.getAddress();
 113                 String userName = tableInfo.getUserName();
 114                 String password = tableInfo.getPassword();
 115                 String database = tableInfo.getDatabase();
 116 
 117                 ArrayList serversList = new ArrayList();
 118                 //Read timeout or connection timeout Settings
 119                 SocketOptions so = new SocketOptions()
 120                         .setReadTimeoutMillis(readTimeoutMillis)
 121                         .setConnectTimeoutMillis(connectTimeoutMillis);
 122 
 123                 //The cluster USES hostdistance.local in the same machine room
 124                 //Hostdistance. REMOTE is used for different machine rooms
 125                 //Ignore use HostDistance. IGNORED
 126                 PoolingOptions poolingOptions = new PoolingOptions()
 127                         //Each connection allows a maximum of 64 concurrent requests
 128                         .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 129                         //Have at least two connections to each machine in the cluster
 130                         .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 131                         //There are up to eight connections to each machine in the cluster
 132                         .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 133                         .setMaxQueueSize(maxQueueSize)
 134                         .setPoolTimeoutMillis(poolTimeoutMillis);
 135                 //重试策略
 136                 RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 137 
 138                 for (String server : StringUtils.split(address, &quot;,&quot;)) {
 139                     cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 140                     serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 141                 }
 142 
 143                 if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
<abbr title=" 144                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 144                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 145                             .withPort(cassandraPort)
 146                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 147                             .withQueryOptions(queryOptions).build();
 148                 } else {
<abbr title=" 149                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 149                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 150                             .withPort(cassandraPort)
 151                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 152                             .withCredentials(userName, password)
 153                             .withQueryOptions(queryOptions).build();
 154                 }
 155                 // 建立连接 连接已存在的键空间
 156                 session = cluster.connectAsync(database);
 157                 LOG.info(&quot;connect cassandra is successed!&quot;);
 158             }
 159         } catch (Exception e) {
 160             LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 161         }
 162     }
 163 
 164     @Override
<abbr title=" 165     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 165     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultF🔵</abbr>
 166 
 167         String key = buildCacheKey(inputParams);
 168         //connect Cassandra
 169         connCassandraDB(cassandraSideTableInfo);
 170 
 171 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 172         String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + buildWhereCondition(inputParams) + &quot;  ALLOW FILTERING &quot;;"> 172         String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + buildWhereCondition(inputParams) + &quot;  AL🔵</abbr></span>
 173 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174         for (int i = 0; i &lt; sideInfo.getEqualFieldList().size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175             Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176             Object equalObj = inputCopy.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177             if (equalObj == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178                 dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 179                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 180             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 181             inputParams.add(equalObj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182             StringBuffer sqlTemp = stringBuffer.append(sideInfo.getEqualFieldList().get(i))</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183                     .append(&quot; = &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184             if (equalObj instanceof String) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185                 sqlTemp.append(&quot;&#x27;&quot; + equalObj + &quot;&#x27;&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186                         .append(&quot; and &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188                 sqlTemp.append(equalObj)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189                         .append(&quot; and &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194         String key = buildCacheKey(inputParams);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195         sqlWhere = sqlWhere + stringBuffer.toString().substring(0, stringBuffer.lastIndexOf(&quot; and &quot;));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197         if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198             CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199             if (val != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201                 if (ECacheContentType.MissVal == val.getType()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203                     return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204                 } else if (ECacheContentType.MultiLine == val.getType()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205                     List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206                     for (Object jsonArray : (List) val.getContent()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207                         Row row = fillData(inputCopy.row(), jsonArray);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208                         rowList.add(new CRow(row, inputCopy.change()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210                     resultFuture.complete(rowList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212                     throw new RuntimeException(&quot;not support cache obj type &quot; + val.getType());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218         //connect Cassandra</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219         connCassandraDB(cassandraSideTableInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221         String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + sqlWhere + &quot;  ALLOW FILTERING &quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222         System.out.println(&quot;sqlCondition:&quot; + sqlCondition);</span>
 223 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 224         String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + sqlWhere + &quot;  ALLOW FILTERING &quot;;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225         LOG.info(&quot;sqlCondition:{}&quot; + sqlCondition);</span>
 226 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 227 
 228         ListenableFuture&lt;ResultSet&gt; resultSet = Futures.transformAsync(session,
 229                 new AsyncFunction&lt;Session, ResultSet&gt;() {
 230                     @Override
 231                     public ListenableFuture&lt;ResultSet&gt; apply(Session session) throws Exception {
 232                         return session.executeAsync(sqlCondition);
 233                     }
 234                 });
 235 
 236         ListenableFuture&lt;List&lt;com.datastax.driver.core.Row&gt;&gt; data = Futures.transform(resultSet,
 237                 new Function&lt;ResultSet, List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 238                     @Override
 239                     public List&lt;com.datastax.driver.core.Row&gt; apply(ResultSet rs) {
 240                         return rs.all();
 241                     }
 242                 });
 243 
 244         Futures.addCallback(data, new FutureCallback&lt;List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 245             @Override
 246             public void onSuccess(List&lt;com.datastax.driver.core.Row&gt; rows) {
 247                 cluster.closeAsync();
 248                 if (rows.size() &gt; 0) {
 249                     List&lt;com.datastax.driver.core.Row&gt; cacheContent = Lists.newArrayList();
 250                     List&lt;CRow&gt; rowList = Lists.newArrayList();
 251                     for (com.datastax.driver.core.Row line : rows) {
 252                         Row row = fillData(input.row(), line);
 253                         if (openCache()) {
 254                             cacheContent.add(line);
 255                         }
 256                         rowList.add(new CRow(row, input.change()));
 257                     }
 258                     resultFuture.complete(rowList);
 259                     if (openCache()) {
 260                         putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 261                     }
 262                 } else {
 263                     dealMissKey(input, resultFuture);
 264                     if (openCache()) {
 265                         putCache(key, CacheMissVal.getMissKeyObj());
 266                     }
 267                     resultFuture.complete(null);
 268                 }
 269             }
 270 
 271             @Override
 272             public void onFailure(Throwable t) {
 273                 LOG.error(&quot;Failed to retrieve the data: %s%n&quot;,
 274                         t.getMessage());
 275                 cluster.closeAsync();
 276                 resultFuture.completeExceptionally(t);
 277             }
 278         });
 279     }
 280 
 281     @Override
 282     public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {
 283         StringBuilder sb = new StringBuilder();
 284         for (Object ele : inputParams.values()) {
 285             sb.append(ele.toString()).append(&quot;_&quot;);
 286         }
 287         return sb.toString();
 288     }
 289 
 290     private String buildWhereCondition(Map&lt;String, Object&gt; inputParams){
 291         StringBuilder sb = new StringBuilder(&quot; where &quot;);
 292         for(Map.Entry&lt;String, Object&gt; entry : inputParams.entrySet()){
<abbr title=" 293             Object value = entry.getValue() instanceof String ? &quot;&#x27;&quot; + entry.getValue() + &quot;&#x27;&quot; : entry.getValue();"> 293             Object value = entry.getValue() instanceof String ? &quot;&#x27;&quot; + entry.getValue() + &quot;&#x27;&quot; : entry.getV🔵</abbr>
 294             sb.append(String.format(&quot;%s = %s&quot;, entry.getKey(), value));
 295         }
 296         return sb.toString();
 297     }
 298 
 299     @Override
 300     public Row fillData(Row input, Object line) {
 301         com.datastax.driver.core.Row rowArray = (com.datastax.driver.core.Row) line;
 302         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 303         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 304             Object obj = input.getField(entry.getValue());
<abbr title=" 305             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 305             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr>
 306 
 307             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 308                 obj = ((Timestamp) obj).getTime();
 309             }
 310 
 311             row.setField(entry.getKey(), obj);
 312         }
 313 
 314         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 315             if (rowArray == null) {
 316                 row.setField(entry.getKey(), null);
 317             } else {
 318                 row.setField(entry.getKey(), rowArray.getObject(entry.getValue()));
 319             }
 320         }
 321 
 322         return row;
 323     }
 324 
 325     @Override
 326     public void close() throws Exception {
 327         super.close();
 328         if (cluster != null) {
 329             cluster.close();
 330             cluster = null;
 331         }
 332     }
 333 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.cassandra;
  21 
  22 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  23 import org.apache.flink.configuration.Configuration;
  24 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  25 import org.apache.flink.table.runtime.types.CRow;
  26 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  27 import org.apache.flink.types.Row;
  28 
  29 import com.datastax.driver.core.Cluster;
  30 import com.datastax.driver.core.ConsistencyLevel;
  31 import com.datastax.driver.core.HostDistance;
  32 import com.datastax.driver.core.PoolingOptions;
  33 import com.datastax.driver.core.QueryOptions;
  34 import com.datastax.driver.core.ResultSet;
  35 import com.datastax.driver.core.Session;
  36 import com.datastax.driver.core.SocketOptions;
  37 import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  38 import com.datastax.driver.core.policies.RetryPolicy;
  39 import com.dtstack.flink.sql.enums.ECacheContentType;
  40 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  41 import com.dtstack.flink.sql.side.CacheMissVal;
  42 import com.dtstack.flink.sql.side.FieldInfo;
  43 import com.dtstack.flink.sql.side.JoinInfo;
  44 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  45 import com.dtstack.flink.sql.side.cache.CacheObj;
  46 import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
  47 import com.google.common.base.Function;
  48 import com.google.common.collect.Lists;
  49 import com.google.common.util.concurrent.AsyncFunction;
  50 import com.google.common.util.concurrent.FutureCallback;
  51 import com.google.common.util.concurrent.Futures;
  52 import com.google.common.util.concurrent.ListenableFuture;
  53 import io.vertx.core.json.JsonArray;
  54 import org.apache.commons.lang3.StringUtils;
  55 import org.slf4j.Logger;
  56 import org.slf4j.LoggerFactory;
  57 
  58 import java.net.InetAddress;
  59 import java.sql.Timestamp;
  60 import java.util.ArrayList;
  61 import java.util.List;
  62 import java.util.Map;
  63 
  64 /**
  65  * Reason:
  66  * Date: 2018/11/22
  67  *
  68  * @author xuqianjin
  69  */
  70 public class CassandraAsyncReqRow extends BaseAsyncReqRow {
  71 
  72     private static final long serialVersionUID = 6631584128079864735L;
  73 
  74     private static final Logger LOG = LoggerFactory.getLogger(CassandraAsyncReqRow.class);
  75 
  76     private final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 10;
  77 
  78     private final static int DEFAULT_VERTX_WORKER_POOL_SIZE = 20;
  79 
  80     private final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = 20;
  81 
  82     private transient Cluster cluster;
  83     private transient ListenableFuture session;
  84     private transient CassandraSideTableInfo cassandraSideTableInfo;
  85 
<abbr title="  86     public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  86     public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoL🔵</abbr>
<abbr title="  87         super(new com.dtstack.flink.sql.side.cassandra.CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));">  87         super(new com.dtstack.flink.sql.side.cassandra.CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outF🔵</abbr>
  88     }
  89 
  90 
  91     @Override
  92     public void open(Configuration parameters) throws Exception {
  93         super.open(parameters);
  94         cassandraSideTableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
  95         connCassandraDB(cassandraSideTableInfo);
  96     }
  97 
  98     private void connCassandraDB(CassandraSideTableInfo tableInfo) {
  99         try {
 100             if (session == null) {
 101                 QueryOptions queryOptions = new QueryOptions();
 102                 //The default consistency level for queries: ConsistencyLevel.TWO.
 103                 queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 104                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 104                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : 🔵</abbr>
<abbr title=" 105                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 105                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tabl🔵</abbr>
<abbr title=" 106                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 106                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : ta🔵</abbr>
<abbr title=" 107                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();"> 107                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQue🔵</abbr>
<abbr title=" 108                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 108                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
<abbr title=" 109                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 109                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tabl🔵</abbr>
<abbr title=" 110                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 110                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
 111                 Integer cassandraPort = 0;
 112                 String address = tableInfo.getAddress();
 113                 String userName = tableInfo.getUserName();
 114                 String password = tableInfo.getPassword();
 115                 String database = tableInfo.getDatabase();
 116 
 117                 ArrayList serversList = new ArrayList();
 118                 //Read timeout or connection timeout Settings
 119                 SocketOptions so = new SocketOptions()
 120                         .setReadTimeoutMillis(readTimeoutMillis)
 121                         .setConnectTimeoutMillis(connectTimeoutMillis);
 122 
 123                 //The cluster USES hostdistance.local in the same machine room
 124                 //Hostdistance. REMOTE is used for different machine rooms
 125                 //Ignore use HostDistance. IGNORED
 126                 PoolingOptions poolingOptions = new PoolingOptions()
 127                         //Each connection allows a maximum of 64 concurrent requests
 128                         .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 129                         //Have at least two connections to each machine in the cluster
 130                         .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 131                         //There are up to eight connections to each machine in the cluster
 132                         .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 133                         .setMaxQueueSize(maxQueueSize)
 134                         .setPoolTimeoutMillis(poolTimeoutMillis);
 135                 //重试策略
 136                 RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 137 
 138                 for (String server : StringUtils.split(address, &quot;,&quot;)) {
 139                     cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 140                     serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 141                 }
 142 
 143                 if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
<abbr title=" 144                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 144                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 145                             .withPort(cassandraPort)
 146                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 147                             .withQueryOptions(queryOptions).build();
 148                 } else {
<abbr title=" 149                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 149                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 150                             .withPort(cassandraPort)
 151                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 152                             .withCredentials(userName, password)
 153                             .withQueryOptions(queryOptions).build();
 154                 }
 155                 // 建立连接 连接已存在的键空间
 156                 session = cluster.connectAsync(database);
 157                 LOG.info(&quot;connect cassandra is successed!&quot;);
 158             }
 159         } catch (Exception e) {
 160             LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 161         }
 162     }
 163 
 164     @Override
<abbr title=" 165     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 165     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultF🔵</abbr>
 166 
 167         String key = buildCacheKey(inputParams);
 168         //connect Cassandra
 169         connCassandraDB(cassandraSideTableInfo);
 170 
<abbr title=" 171         String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + buildWhereCondition(inputParams) + &quot;  ALLOW FILTERING &quot;;"> 171         String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + buildWhereCondition(inputParams) + &quot;  AL🔵</abbr>
 172 
 173         ListenableFuture&lt;ResultSet&gt; resultSet = Futures.transformAsync(session,
 174                 new AsyncFunction&lt;Session, ResultSet&gt;() {
 175                     @Override
 176                     public ListenableFuture&lt;ResultSet&gt; apply(Session session) throws Exception {
 177                         return session.executeAsync(sqlCondition);
 178                     }
 179                 });
 180 
 181         ListenableFuture&lt;List&lt;com.datastax.driver.core.Row&gt;&gt; data = Futures.transform(resultSet,
 182                 new Function&lt;ResultSet, List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 183                     @Override
 184                     public List&lt;com.datastax.driver.core.Row&gt; apply(ResultSet rs) {
 185                         return rs.all();
 186                     }
 187                 });
 188 
 189         Futures.addCallback(data, new FutureCallback&lt;List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 190             @Override
 191             public void onSuccess(List&lt;com.datastax.driver.core.Row&gt; rows) {
 192                 cluster.closeAsync();
 193                 if (rows.size() &gt; 0) {
 194                     List&lt;com.datastax.driver.core.Row&gt; cacheContent = Lists.newArrayList();
 195                     List&lt;CRow&gt; rowList = Lists.newArrayList();
 196                     for (com.datastax.driver.core.Row line : rows) {
 197                         Row row = fillData(input.row(), line);
 198                         if (openCache()) {
 199                             cacheContent.add(line);
 200                         }
 201                         rowList.add(new CRow(row, input.change()));
 202                     }
 203                     resultFuture.complete(rowList);
 204                     if (openCache()) {
 205                         putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 206                     }
 207                 } else {
 208                     dealMissKey(input, resultFuture);
 209                     if (openCache()) {
 210                         putCache(key, CacheMissVal.getMissKeyObj());
 211                     }
 212                     resultFuture.complete(null);
 213                 }
 214             }
 215 
 216             @Override
 217             public void onFailure(Throwable t) {
 218                 LOG.error(&quot;Failed to retrieve the data: %s%n&quot;,
 219                         t.getMessage());
 220                 cluster.closeAsync();
 221                 resultFuture.completeExceptionally(t);
 222             }
 223         });
 224     }
 225 
 226     @Override
 227     public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {
 228         StringBuilder sb = new StringBuilder();
 229         for (Object ele : inputParams.values()) {
 230             sb.append(ele.toString()).append(&quot;_&quot;);
 231         }
 232         return sb.toString();
 233     }
 234 
 235     private String buildWhereCondition(Map&lt;String, Object&gt; inputParams){
 236         StringBuilder sb = new StringBuilder(&quot; where &quot;);
 237         for(Map.Entry&lt;String, Object&gt; entry : inputParams.entrySet()){
<abbr title=" 238             Object value = entry.getValue() instanceof String ? &quot;&#x27;&quot; + entry.getValue() + &quot;&#x27;&quot; : entry.getValue();"> 238             Object value = entry.getValue() instanceof String ? &quot;&#x27;&quot; + entry.getValue() + &quot;&#x27;&quot; : entry.getV🔵</abbr>
 239             sb.append(String.format(&quot;%s = %s&quot;, entry.getKey(), value));
 240         }
 241         return sb.toString();
 242     }
 243 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 244 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 245 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 246     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 247         CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 248         JsonArray inputParams = new JsonArray();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 249         StringBuffer stringBuffer = new StringBuffer();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 250         String sqlWhere = &quot; where &quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 251 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 252         for (int i = 0; i &lt; sideInfo.getEqualFieldList().size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 253             Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 254             Object equalObj = inputCopy.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 255             if (equalObj == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 256                 dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 257                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 258             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 259             inputParams.add(equalObj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 260             StringBuffer sqlTemp = stringBuffer.append(sideInfo.getEqualFieldList().get(i))</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 261                     .append(&quot; = &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 262             if (equalObj instanceof String) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 263                 sqlTemp.append(&quot;&#x27;&quot; + equalObj + &quot;&#x27;&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 264                         .append(&quot; and &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 265             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 266                 sqlTemp.append(equalObj)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 267                         .append(&quot; and &quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 268             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 269 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 270         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 271 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 272         String key = buildCacheKey(inputParams);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 273         sqlWhere = sqlWhere + stringBuffer.toString().substring(0, stringBuffer.lastIndexOf(&quot; and &quot;));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 274 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 275         if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 276             CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 277             if (val != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 278 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 279                 if (ECacheContentType.MissVal == val.getType()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 280                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 281                     return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 282                 } else if (ECacheContentType.MultiLine == val.getType()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 283                     List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 284                     for (Object jsonArray : (List) val.getContent()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 285                         Row row = fillData(inputCopy.row(), jsonArray);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 286                         rowList.add(new CRow(row, inputCopy.change()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 287                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 288                     resultFuture.complete(rowList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 289                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 290                     throw new RuntimeException(&quot;not support cache obj type &quot; + val.getType());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 291                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 292                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 293             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 294         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 295 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 296         //connect Cassandra</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 297         connCassandraDB(cassandraSideTableInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 298 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 299         String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + sqlWhere + &quot;  ALLOW FILTERING &quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 300         System.out.println(&quot;sqlCondition:&quot; + sqlCondition);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 301 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 302         ListenableFuture&lt;ResultSet&gt; resultSet = Futures.transformAsync(session,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 303                 new AsyncFunction&lt;Session, ResultSet&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 304                     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 305                     public ListenableFuture&lt;ResultSet&gt; apply(Session session) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 306                         return session.executeAsync(sqlCondition);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 307                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 308                 });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 309 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 310         ListenableFuture&lt;List&lt;com.datastax.driver.core.Row&gt;&gt; data = Futures.transform(resultSet,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 311                 new Function&lt;ResultSet, List&lt;com.datastax.driver.core.Row&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 312                     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 313                     public List&lt;com.datastax.driver.core.Row&gt; apply(ResultSet rs) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 314                         return rs.all();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 315                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 316                 });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 317 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 318         Futures.addCallback(data, new FutureCallback&lt;List&lt;com.datastax.driver.core.Row&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 319             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 320             public void onSuccess(List&lt;com.datastax.driver.core.Row&gt; rows) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 321                 cluster.closeAsync();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 322                 if (rows.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 323                     List&lt;com.datastax.driver.core.Row&gt; cacheContent = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 324                     List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 325                     for (com.datastax.driver.core.Row line : rows) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 326                         Row row = fillData(inputCopy.row(), line);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 327                         if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 328                             cacheContent.add(line);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 329                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 330                         rowList.add(new CRow(row,inputCopy.change()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 331                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 332                     resultFuture.complete(rowList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 333                     if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 334                         putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 335                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 336                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 337                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 338                     if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 339                         putCache(key, CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 340                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 341                     resultFuture.complete(null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 342                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 343             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 344 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 345             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 346             public void onFailure(Throwable t) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 347                 LOG.error(&quot;Failed to retrieve the data: %s%n&quot;,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 348                         t.getMessage());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 349                 System.out.println(&quot;Failed to retrieve the data: &quot; + t.getMessage());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 350                 cluster.closeAsync();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 351                 resultFuture.completeExceptionally(t);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 352             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 353         });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 354     }</span>
 355 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 356 @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 357     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 358         CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 359         JsonArray inputParams = new JsonArray();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 360         StringBuffer stringBuffer = new StringBuffer();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 361         String sqlWhere = &quot; where &quot;;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 362 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 363         for (int i = 0; i &lt; sideInfo.getEqualFieldList().size(); i++) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 364             Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 365             Object equalObj = inputCopy.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 366             if (equalObj == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 367                 dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 368                 return;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 369             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 370             inputParams.add(equalObj);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 371             StringBuffer sqlTemp = stringBuffer.append(sideInfo.getEqualFieldList().get(i))</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 372                     .append(&quot; = &quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 373             if (equalObj instanceof String) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 374                 sqlTemp.append(&quot;&#x27;&quot; + equalObj + &quot;&#x27;&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 375                         .append(&quot; and &quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 376             } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 377                 sqlTemp.append(equalObj)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 378                         .append(&quot; and &quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 379             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 380 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 381         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 382 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 383         String key = buildCacheKey(inputParams);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 384         sqlWhere = sqlWhere + stringBuffer.toString().substring(0, stringBuffer.lastIndexOf(&quot; and &quot;));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 385 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 386         if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 387             CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 388             if (val != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 389 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 390                 if (ECacheContentType.MissVal == val.getType()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 391                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 392                     return;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 393                 } else if (ECacheContentType.MultiLine == val.getType()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 394                     List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 395                     for (Object jsonArray : (List) val.getContent()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 396                         Row row = fillData(inputCopy.row(), jsonArray);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 397                         rowList.add(new CRow(row, inputCopy.change()));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 398                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 399                     resultFuture.complete(rowList);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 400                 } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 401                     throw new RuntimeException(&quot;not support cache obj type &quot; + val.getType());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 402                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 403                 return;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 404             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 405         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 406 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 407         //connect Cassandra</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 408         connCassandraDB(cassandraSideTableInfo);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 409 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 410         String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + sqlWhere + &quot;  ALLOW FILTERING &quot;;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 411         LOG.info(&quot;sqlCondition:{}&quot; + sqlCondition);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 412 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 413         ListenableFuture&lt;ResultSet&gt; resultSet = Futures.transformAsync(session,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 414                 new AsyncFunction&lt;Session, ResultSet&gt;() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 415                     @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 416                     public ListenableFuture&lt;ResultSet&gt; apply(Session session) throws Exception {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 417                         return session.executeAsync(sqlCondition);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 418                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 419                 });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 420 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 421         ListenableFuture&lt;List&lt;com.datastax.driver.core.Row&gt;&gt; data = Futures.transform(resultSet,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 422                 new Function&lt;ResultSet, List&lt;com.datastax.driver.core.Row&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 423                     @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 424                     public List&lt;com.datastax.driver.core.Row&gt; apply(ResultSet rs) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 425                         return rs.all();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 426                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 427                 });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 428 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 429         Futures.addCallback(data, new FutureCallback&lt;List&lt;com.datastax.driver.core.Row&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 430             @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 431             public void onSuccess(List&lt;com.datastax.driver.core.Row&gt; rows) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 432                 cluster.closeAsync();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 433                 if (rows.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 434                     List&lt;com.datastax.driver.core.Row&gt; cacheContent = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 435                     List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 436                     for (com.datastax.driver.core.Row line : rows) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 437                         Row row = fillData(inputCopy.row(), line);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 438                         if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 439                             cacheContent.add(line);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 440                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 441                         rowList.add(new CRow(row,inputCopy.change()));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 442                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 443                     resultFuture.complete(rowList);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 444                     if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 445                         putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 446                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 447                 } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 448                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 449                     if (openCache()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 450                         putCache(key, CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 451                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 452                     resultFuture.complete(null);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 453                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 454             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 455 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 456             @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 457             public void onFailure(Throwable t) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 458                 LOG.error(&quot;Failed to retrieve the data: %s%n&quot;,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 459                         t.getMessage());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 460                 cluster.closeAsync();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 461                 resultFuture.completeExceptionally(t);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 462             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 463         });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 464     }</span>
 465 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 466 
 467 
 468     @Override
 469     public Row fillData(Row input, Object line) {
 470         com.datastax.driver.core.Row rowArray = (com.datastax.driver.core.Row) line;
 471         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 472         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 473             Object obj = input.getField(entry.getValue());
<abbr title=" 474             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 474             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr>
 475 
 476             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 477                 obj = ((Timestamp) obj).getTime();
 478             }
 479 
 480             row.setField(entry.getKey(), obj);
 481         }
 482 
 483         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 484             if (rowArray == null) {
 485                 row.setField(entry.getKey(), null);
 486             } else {
 487                 row.setField(entry.getKey(), rowArray.getObject(entry.getValue()));
 488             }
 489         }
 490 
 491         return row;
 492     }
 493 
 494     @Override
 495     public void close() throws Exception {
 496         super.close();
 497         if (cluster != null) {
 498             cluster.close();
 499             cluster = null;
 500         }
 501     }
 502 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.cassandra;
  19 
  20 import com.datastax.driver.core.Cluster;
  21 import com.datastax.driver.core.ConsistencyLevel;
  22 import com.datastax.driver.core.HostDistance;
  23 import com.datastax.driver.core.PoolingOptions;
  24 import com.datastax.driver.core.QueryOptions;
  25 import com.datastax.driver.core.ResultSet;
  26 import com.datastax.driver.core.Session;
  27 import com.datastax.driver.core.SocketOptions;
  28 import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  29 import com.datastax.driver.core.policies.RetryPolicy;
  30 import com.dtstack.flink.sql.enums.ECacheContentType;
  31 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  32 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  33 import com.dtstack.flink.sql.side.CacheMissVal;
  34 import com.dtstack.flink.sql.side.FieldInfo;
  35 import com.dtstack.flink.sql.side.JoinInfo;
  36 import com.dtstack.flink.sql.side.cache.CacheObj;
  37 import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
  38 import com.google.common.base.Function;
  39 import com.google.common.collect.Lists;
  40 import com.google.common.util.concurrent.AsyncFunction;
  41 import com.google.common.util.concurrent.FutureCallback;
  42 import com.google.common.util.concurrent.Futures;
  43 import com.google.common.util.concurrent.ListenableFuture;
  44 import io.vertx.core.json.JsonArray;
  45 import java.net.InetAddress;
  46 import java.sql.Timestamp;
  47 import java.util.ArrayList;
  48 import java.util.List;
  49 import java.util.Map;
  50 import org.apache.commons.lang3.StringUtils;
  51 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  52 import org.apache.flink.configuration.Configuration;
  53 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  54 import org.apache.flink.table.runtime.types.CRow;
  55 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  56 import org.apache.flink.types.Row;
  57 import org.slf4j.Logger;
  58 import org.slf4j.LoggerFactory;
  59 
  60 
  61 /**
  62  * Reason:
  63  * Date: 2018/11/22
  64  *
  65  * @author xuqianjin
  66  */
  67 public class CassandraAsyncReqRow extends BaseAsyncReqRow {
  68     private static final long serialVersionUID = 6631584128079864735L;
  69 
  70     private static final Logger LOG = LoggerFactory.getLogger(CassandraAsyncReqRow.class);
  71 
  72     private final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 10;
  73 
  74     private final static int DEFAULT_VERTX_WORKER_POOL_SIZE = 20;
  75 
  76     private final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = 20;
  77 
  78     private transient Cluster cluster;
  79 
  80     private transient ListenableFuture session;
  81 
  82     private transient CassandraSideTableInfo cassandraSideTableInfo;
  83 
<abbr title="  84     public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  84     public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoL🔵</abbr>
  85         super(new CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  86     }
  87 
  88     @Override
  89     public void open(Configuration parameters) throws Exception {
  90         super.open(parameters);
  91         cassandraSideTableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
  92         connCassandraDB(cassandraSideTableInfo);
  93     }
  94 
  95     private void connCassandraDB(CassandraSideTableInfo tableInfo) {
  96         try {
  97             if (session == null) {
  98                 QueryOptions queryOptions = new QueryOptions();
  99                 //The default consistency level for queries: ConsistencyLevel.TWO.
 100                 queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 101                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 101                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : 🔵</abbr>
<abbr title=" 102                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 102                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tabl🔵</abbr>
<abbr title=" 103                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 103                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : ta🔵</abbr>
<abbr title=" 104                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();"> 104                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQue🔵</abbr>
<abbr title=" 105                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 105                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
<abbr title=" 106                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 106                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tabl🔵</abbr>
<abbr title=" 107                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 107                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
 108                 Integer cassandraPort = 0;
 109                 String address = tableInfo.getAddress();
 110                 String userName = tableInfo.getUserName();
 111                 String password = tableInfo.getPassword();
 112                 String database = tableInfo.getDatabase();
 113 
 114                 ArrayList serversList = new ArrayList();
 115                 //Read timeout or connection timeout Settings
 116                 SocketOptions so = new SocketOptions()
 117                         .setReadTimeoutMillis(readTimeoutMillis)
 118                         .setConnectTimeoutMillis(connectTimeoutMillis);
 119 
 120                 //The cluster USES hostdistance.local in the same machine room
 121                 //Hostdistance. REMOTE is used for different machine rooms
 122                 //Ignore use HostDistance. IGNORED
 123                 PoolingOptions poolingOptions = new PoolingOptions()
 124                         //Each connection allows a maximum of 64 concurrent requests
 125                         .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 126                         //Have at least two connections to each machine in the cluster
 127                         .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 128                         //There are up to eight connections to each machine in the cluster
 129                         .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 130                         .setMaxQueueSize(maxQueueSize)
 131                         .setPoolTimeoutMillis(poolTimeoutMillis);
 132                 //重试策略
 133                 RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 134 
 135                 for (String server : StringUtils.split(address, &quot;,&quot;)) {
 136                     cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 137                     serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 138                 }
 139 
 140                 if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
<abbr title=" 141                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 141                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 142                             .withPort(cassandraPort)
 143                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 144                             .withQueryOptions(queryOptions).build();
 145                 } else {
<abbr title=" 146                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 146                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 147                             .withPort(cassandraPort)
 148                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 149                             .withCredentials(userName, password)
 150                             .withQueryOptions(queryOptions).build();
 151                 }
 152                 // 建立连接 连接已存在的键空间
 153                 session = cluster.connectAsync(database);
 154                 LOG.info(&quot;connect cassandra is successed!&quot;);
 155             }
 156         } catch (Exception e) {
 157             LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 158         }
 159     }
 160 
 161     @Override
<abbr title=" 162     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 162     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultF🔵</abbr>
 163         String key = buildCacheKey(inputParams);
 164         // connect Cassandra
 165         connCassandraDB(cassandraSideTableInfo);
<abbr title=" 166         String sqlCondition = ((sideInfo.getSqlCondition() + &quot; &quot;) + buildWhereCondition(inputParams)) + &quot;  ALLOW FILTERING &quot;;"> 166         String sqlCondition = ((sideInfo.getSqlCondition() + &quot; &quot;) + buildWhereCondition(inputParams)) + &quot;🔵</abbr>
<abbr title=" 167         ListenableFuture&lt;ResultSet&gt; resultSet = Futures.transformAsync(session, new AsyncFunction&lt;Session, ResultSet&gt;() {"> 167         ListenableFuture&lt;ResultSet&gt; resultSet = Futures.transformAsync(session, new AsyncFunction&lt;Session🔵</abbr>
 168             @Override
 169             public ListenableFuture&lt;ResultSet&gt; apply(Session session) throws Exception {
 170                 return session.executeAsync(sqlCondition);
 171             }
 172         });
<abbr title=" 173         ListenableFuture&lt;List&lt;com.datastax.driver.core.Row&gt;&gt; data = Futures.transform(resultSet, new Function&lt;ResultSet, List&lt;com.datastax.driver.core.Row&gt;&gt;() {"> 173         ListenableFuture&lt;List&lt;com.datastax.driver.core.Row&gt;&gt; data = Futures.transform(resultSet, new Func🔵</abbr>
 174             @Override
 175             public List&lt;com.datastax.driver.core.Row&gt; apply(ResultSet rs) {
 176                 return rs.all();
 177             }
 178         });
 179         Futures.addCallback(data, new FutureCallback&lt;List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 180             @Override
 181             public void onSuccess(List&lt;com.datastax.driver.core.Row&gt; rows) {
 182                 cluster.closeAsync();
 183                 if (rows.size() &gt; 0) {
 184                     List&lt;com.datastax.driver.core.Row&gt; cacheContent = Lists.newArrayList();
 185                     List&lt;CRow&gt; rowList = Lists.newArrayList();
 186                     for (com.datastax.driver.core.Row line : rows) {
 187                         Row row = fillData(input.row(), line);
 188                         if (openCache()) {
 189                             cacheContent.add(line);
 190                         }
 191                         rowList.add(new CRow(row, input.change()));
 192                     }
 193                     resultFuture.complete(rowList);
 194                     if (openCache()) {
 195                         putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 196                     }
 197                 } else {
 198                     dealMissKey(input, resultFuture);
 199                     if (openCache()) {
 200                         putCache(key, CacheMissVal.getMissKeyObj());
 201                     }
 202                     resultFuture.complete(null);
 203                 }
 204             }
 205 
 206             @Override
 207             public void onFailure(Throwable t) {
 208                 LOG.error(&quot;Failed to retrieve the data: %s%n&quot;, t.getMessage());
 209                 cluster.closeAsync();
 210                 resultFuture.completeExceptionally(t);
 211             }
 212         });
 213     }
 214 
 215     @Override
 216     public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {
 217         StringBuilder sb = new StringBuilder();
 218         for (Object ele : inputParams.values()) {
 219             sb.append(ele.toString()).append(&quot;_&quot;);
 220         }
 221         return sb.toString();
 222     }
 223 
 224     private String buildWhereCondition(Map&lt;String, Object&gt; inputParams) {
 225         StringBuilder sb = new StringBuilder(&quot; where &quot;);
 226         for (Map.Entry&lt;String, Object&gt; entry : inputParams.entrySet()) {
<abbr title=" 227             Object value = (entry.getValue() instanceof String) ? (&quot;&#x27;&quot; + entry.getValue()) + &quot;&#x27;&quot; : entry.getValue();"> 227             Object value = (entry.getValue() instanceof String) ? (&quot;&#x27;&quot; + entry.getValue()) + &quot;&#x27;&quot; : entry.🔵</abbr>
 228             sb.append(String.format(&quot;%s = %s&quot;, entry.getKey(), value));
 229         }
 230         return sb.toString();
 231     }
 232 
 233     @Override
 234     public Row fillData(Row input, Object line) {
 235         com.datastax.driver.core.Row rowArray = (com.datastax.driver.core.Row) line;
 236         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 237         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 238             Object obj = input.getField(entry.getValue());
<abbr title=" 239             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 239             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr>
 240 
 241             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 242                 obj = ((Timestamp) obj).getTime();
 243             }
 244 
 245             row.setField(entry.getKey(), obj);
 246         }
 247 
 248         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 249             if (rowArray == null) {
 250                 row.setField(entry.getKey(), null);
 251             } else {
 252                 row.setField(entry.getKey(), rowArray.getObject(entry.getValue()));
 253             }
 254         }
 255 
 256         return row;
 257     }
 258 
 259     @Override
 260     public void close() throws Exception {
 261         super.close();
 262         if (cluster != null) {
 263             cluster.close();
 264             cluster = null;
 265         }
 266     }
 267 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.cassandra;
  21  
  22  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  23  import org.apache.flink.configuration.Configuration;
  24  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  25  import org.apache.flink.table.runtime.types.CRow;
  26  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  27  import org.apache.flink.types.Row;
  28  
  29  import com.datastax.driver.core.Cluster;
  30  import com.datastax.driver.core.ConsistencyLevel;
  31  import com.datastax.driver.core.HostDistance;
  32  import com.datastax.driver.core.PoolingOptions;
  33  import com.datastax.driver.core.QueryOptions;
  34  import com.datastax.driver.core.ResultSet;
  35  import com.datastax.driver.core.Session;
  36  import com.datastax.driver.core.SocketOptions;
  37  import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  38  import com.datastax.driver.core.policies.RetryPolicy;
  39  import com.dtstack.flink.sql.enums.ECacheContentType;
  40  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  41  import com.dtstack.flink.sql.side.CacheMissVal;
  42  import com.dtstack.flink.sql.side.FieldInfo;
  43  import com.dtstack.flink.sql.side.JoinInfo;
  44  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  45  import com.dtstack.flink.sql.side.cache.CacheObj;
  46  import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
  47  import com.google.common.base.Function;
  48  import com.google.common.collect.Lists;
  49  import com.google.common.util.concurrent.AsyncFunction;
  50  import com.google.common.util.concurrent.FutureCallback;
  51  import com.google.common.util.concurrent.Futures;
  52  import com.google.common.util.concurrent.ListenableFuture;
  53  import io.vertx.core.json.JsonArray;
  54  import org.apache.commons.lang3.StringUtils;
  55  import org.slf4j.Logger;
  56  import org.slf4j.LoggerFactory;
  57  
  58  import java.net.InetAddress;
  59  import java.sql.Timestamp;
  60  import java.util.ArrayList;
  61  import java.util.List;
  62  import java.util.Map;
  63  
  64  /**
  65   * Reason:
  66   * Date: 2018/11/22
  67   *
  68   * @author xuqianjin
  69   */
  70  public class CassandraAsyncReqRow extends BaseAsyncReqRow {
  71  
  72      private static final long serialVersionUID = 6631584128079864735L;
  73  
  74      private static final Logger LOG = LoggerFactory.getLogger(CassandraAsyncReqRow.class);
  75  
  76      private final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 10;
  77  
  78      private final static int DEFAULT_VERTX_WORKER_POOL_SIZE = 20;
  79  
  80      private final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = 20;
  81  
  82      private transient Cluster cluster;
  83      private transient ListenableFuture session;
  84      private transient CassandraSideTableInfo cassandraSideTableInfo;
  85  
<abbr title="  86      public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  86      public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, Abst🔵</abbr>
<abbr title="  87          super(new com.dtstack.flink.sql.side.cassandra.CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));">  87          super(new com.dtstack.flink.sql.side.cassandra.CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoL🔵</abbr>
  88      }
  89  
  90  
  91      @Override
  92      public void open(Configuration parameters) throws Exception {
  93          super.open(parameters);
  94          cassandraSideTableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
  95          connCassandraDB(cassandraSideTableInfo);
  96      }
  97  
  98      private void connCassandraDB(CassandraSideTableInfo tableInfo) {
  99          try {
 100              if (session == null) {
 101                  QueryOptions queryOptions = new QueryOptions();
 102                  //The default consistency level for queries: ConsistencyLevel.TWO.
 103                  queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 104                  Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 104                  Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo🔵</abbr>
<abbr title=" 105                  Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 105                  Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.get🔵</abbr>
<abbr title=" 106                  Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 106                  Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.g🔵</abbr>
 107                  Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();
<abbr title=" 108                  Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 108                  Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTi🔵</abbr>
<abbr title=" 109                  Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 109                  Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.get🔵</abbr>
<abbr title=" 110                  Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 110                  Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTi🔵</abbr>
 111                  Integer cassandraPort = 0;
 112                  String address = tableInfo.getAddress();
 113                  String userName = tableInfo.getUserName();
 114                  String password = tableInfo.getPassword();
 115                  String database = tableInfo.getDatabase();
 116  
 117                  ArrayList serversList = new ArrayList();
 118                  //Read timeout or connection timeout Settings
 119                  SocketOptions so = new SocketOptions()
 120                          .setReadTimeoutMillis(readTimeoutMillis)
 121                          .setConnectTimeoutMillis(connectTimeoutMillis);
 122  
 123                  //The cluster USES hostdistance.local in the same machine room
 124                  //Hostdistance. REMOTE is used for different machine rooms
 125                  //Ignore use HostDistance. IGNORED
 126                  PoolingOptions poolingOptions = new PoolingOptions()
 127                          //Each connection allows a maximum of 64 concurrent requests
 128                          .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 129                          //Have at least two connections to each machine in the cluster
 130                          .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 131                          //There are up to eight connections to each machine in the cluster
 132                          .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 133                          .setMaxQueueSize(maxQueueSize)
 134                          .setPoolTimeoutMillis(poolTimeoutMillis);
 135                  //重试策略
 136                  RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 137  
 138                  for (String server : StringUtils.split(address, &quot;,&quot;)) {
 139                      cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 140                      serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 141                  }
 142  
 143                  if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
 144                      cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)
 145                              .withPort(cassandraPort)
 146                              .withPoolingOptions(poolingOptions).withSocketOptions(so)
 147                              .withQueryOptions(queryOptions).build();
 148                  } else {
 149                      cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)
 150                              .withPort(cassandraPort)
 151                              .withPoolingOptions(poolingOptions).withSocketOptions(so)
 152                              .withCredentials(userName, password)
 153                              .withQueryOptions(queryOptions).build();
 154                  }
 155                  // 建立连接 连接已存在的键空间
 156                  session = cluster.connectAsync(database);
 157                  LOG.info(&quot;connect cassandra is successed!&quot;);
 158              }
 159          } catch (Exception e) {
 160              LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 161          }
 162      }
 163  
 164      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -    public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -        CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -        JsonArray inputParams = new JsonArray();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -        StringBuffer stringBuffer = new StringBuffer();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -        String sqlWhere = &quot; where &quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -        for (int i = 0; i &lt; sideInfo.getEqualFieldList().size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -            Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -            Object equalObj = inputCopy.row().getField(conValIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 174 -            if (equalObj == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 175 -                dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 176 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 177 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -            inputParams.add(equalObj);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -            StringBuffer sqlTemp = stringBuffer.append(sideInfo.getEqualFieldList().get(i))</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -                    .append(&quot; = &quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 181 -            if (equalObj instanceof String) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -                sqlTemp.append(&quot;&#x27;&quot; + equalObj + &quot;&#x27;&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -                        .append(&quot; and &quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -                sqlTemp.append(equalObj)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -                        .append(&quot; and &quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 190 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 190 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) th🔵</abbr></span>
 191  
 192          String key = buildCacheKey(inputParams);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -        sqlWhere = sqlWhere + stringBuffer.toString().substring(0, stringBuffer.lastIndexOf(&quot; and &quot;));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 194 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -        if (openCache()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -            CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -            if (val != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -                if (ECacheContentType.MissVal == val.getType()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -                    dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -                    return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -                } else if (ECacheContentType.MultiLine == val.getType()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -                    List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -                    for (Object jsonArray : (List) val.getContent()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -                        Row row = fillData(inputCopy.row(), jsonArray);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -                        rowList.add(new CRow(row, inputCopy.change()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -                    resultFuture.complete(rowList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 210 -                    throw new RuntimeException(&quot;not support cache obj type &quot; + val.getType());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 211 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 214 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 215 -</span>
 216          //connect Cassandra
 217          connCassandraDB(cassandraSideTableInfo);
 218  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -        String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + sqlWhere + &quot;  ALLOW FILTERING &quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -        System.out.println(&quot;sqlCondition:&quot; + sqlCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 221 +        String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + buildWhereCondition(inputParams) + &quot;  ALLOW FILTERING &quot;;"> 221 +        String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + buildWhereCondition(inputParams) + &quot;  ALLOW FILTE🔵</abbr></span>
 222  
 223          ListenableFuture&lt;ResultSet&gt; resultSet = Futures.transformAsync(session,
 224                  new AsyncFunction&lt;Session, ResultSet&gt;() {
 225                      @Override
 226                      public ListenableFuture&lt;ResultSet&gt; apply(Session session) throws Exception {
 227                          return session.executeAsync(sqlCondition);
 228                      }
 229                  });
 230  
 231          ListenableFuture&lt;List&lt;com.datastax.driver.core.Row&gt;&gt; data = Futures.transform(resultSet,
 232                  new Function&lt;ResultSet, List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 233                      @Override
 234                      public List&lt;com.datastax.driver.core.Row&gt; apply(ResultSet rs) {
 235                          return rs.all();
 236                      }
 237                  });
 238  
 239          Futures.addCallback(data, new FutureCallback&lt;List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 240              @Override
 241              public void onSuccess(List&lt;com.datastax.driver.core.Row&gt; rows) {
 242                  cluster.closeAsync();
 243                  if (rows.size() &gt; 0) {
 244                      List&lt;com.datastax.driver.core.Row&gt; cacheContent = Lists.newArrayList();
 245                      List&lt;CRow&gt; rowList = Lists.newArrayList();
 246                      for (com.datastax.driver.core.Row line : rows) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -                        Row row = fillData(inputCopy.row(), line);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +                        Row row = fillData(input.row(), line);</span>
 249                          if (openCache()) {
 250                              cacheContent.add(line);
 251                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -                        rowList.add(new CRow(row,inputCopy.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +                        rowList.add(new CRow(row, input.change()));</span>
 254                      }
 255                      resultFuture.complete(rowList);
 256                      if (openCache()) {
 257                          putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 258                      }
 259                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 260 -                    dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +                    dealMissKey(input, resultFuture);</span>
 262                      if (openCache()) {
 263                          putCache(key, CacheMissVal.getMissKeyObj());
 264                      }
 265                      resultFuture.complete(null);
 266                  }
 267              }
 268  
 269              @Override
 270              public void onFailure(Throwable t) {
 271                  LOG.error(&quot;Failed to retrieve the data: %s%n&quot;,
 272                          t.getMessage());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 273 -                System.out.println(&quot;Failed to retrieve the data: &quot; + t.getMessage());</span>
 274                  cluster.closeAsync();
 275                  resultFuture.completeExceptionally(t);
 276              }
 277          });
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 280 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +    public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +        StringBuilder sb = new StringBuilder();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +        for (Object ele : inputParams.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +            sb.append(ele.toString()).append(&quot;_&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +        return sb.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +    private String buildWhereCondition(Map&lt;String, Object&gt; inputParams){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +        StringBuilder sb = new StringBuilder(&quot; where &quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +        for(Map.Entry&lt;String, Object&gt; entry : inputParams.entrySet()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +            Object value = entry.getValue() instanceof String ? &quot;&#x27;&quot; + entry.getValue() + &quot;&#x27;&quot; : entry.getValue();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +            sb.append(String.format(&quot;%s = %s&quot;, entry.getKey(), value));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 295 +        return sb.toString();</span>
 296      }
 297  
 298      @Override
 299      public Row fillData(Row input, Object line) {
 300          com.datastax.driver.core.Row rowArray = (com.datastax.driver.core.Row) line;
 301          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 302          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 303              Object obj = input.getField(entry.getValue());
<abbr title=" 304              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 304              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr>
 305  
 306              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 307                  obj = ((Timestamp) obj).getTime();
 308              }
 309  
 310              row.setField(entry.getKey(), obj);
 311          }
 312  
 313          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 314              if (rowArray == null) {
 315                  row.setField(entry.getKey(), null);
 316              } else {
 317                  row.setField(entry.getKey(), rowArray.getObject(entry.getValue()));
 318              }
 319          }
 320  
 321          return row;
 322      }
 323  
 324      @Override
 325      public void close() throws Exception {
 326          super.close();
 327          if (cluster != null) {
 328              cluster.close();
 329              cluster = null;
 330          }
 331      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 332 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 333 -    public String buildCacheKey(JsonArray jsonArray) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 334 -        StringBuilder sb = new StringBuilder();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 335 -        for (Object ele : jsonArray.getList()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 336 -            sb.append(ele.toString())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 337 -                    .append(&quot;_&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 338 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 339 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 340 -        return sb.toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 341 -    }</span>
 342  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.cassandra;
  21  
  22  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  23  import org.apache.flink.configuration.Configuration;
  24  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  25  import org.apache.flink.table.runtime.types.CRow;
  26  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  27  import org.apache.flink.types.Row;
  28  
  29  import com.datastax.driver.core.Cluster;
  30  import com.datastax.driver.core.ConsistencyLevel;
  31  import com.datastax.driver.core.HostDistance;
  32  import com.datastax.driver.core.PoolingOptions;
  33  import com.datastax.driver.core.QueryOptions;
  34  import com.datastax.driver.core.ResultSet;
  35  import com.datastax.driver.core.Session;
  36  import com.datastax.driver.core.SocketOptions;
  37  import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  38  import com.datastax.driver.core.policies.RetryPolicy;
  39  import com.dtstack.flink.sql.enums.ECacheContentType;
  40  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  41  import com.dtstack.flink.sql.side.CacheMissVal;
  42  import com.dtstack.flink.sql.side.FieldInfo;
  43  import com.dtstack.flink.sql.side.JoinInfo;
  44  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  45  import com.dtstack.flink.sql.side.cache.CacheObj;
  46  import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
  47  import com.google.common.base.Function;
  48  import com.google.common.collect.Lists;
  49  import com.google.common.util.concurrent.AsyncFunction;
  50  import com.google.common.util.concurrent.FutureCallback;
  51  import com.google.common.util.concurrent.Futures;
  52  import com.google.common.util.concurrent.ListenableFuture;
  53  import io.vertx.core.json.JsonArray;
  54  import org.apache.commons.lang3.StringUtils;
  55  import org.slf4j.Logger;
  56  import org.slf4j.LoggerFactory;
  57  
  58  import java.net.InetAddress;
  59  import java.sql.Timestamp;
  60  import java.util.ArrayList;
  61  import java.util.List;
  62  import java.util.Map;
  63  
  64  /**
  65   * Reason:
  66   * Date: 2018/11/22
  67   *
  68   * @author xuqianjin
  69   */
  70  public class CassandraAsyncReqRow extends BaseAsyncReqRow {
  71  
  72      private static final long serialVersionUID = 6631584128079864735L;
  73  
  74      private static final Logger LOG = LoggerFactory.getLogger(CassandraAsyncReqRow.class);
  75  
  76      private final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 10;
  77  
  78      private final static int DEFAULT_VERTX_WORKER_POOL_SIZE = 20;
  79  
  80      private final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = 20;
  81  
  82      private transient Cluster cluster;
  83      private transient ListenableFuture session;
  84      private transient CassandraSideTableInfo cassandraSideTableInfo;
  85  
<abbr title="  86      public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  86      public CassandraAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, Abst🔵</abbr>
<abbr title="  87          super(new com.dtstack.flink.sql.side.cassandra.CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));">  87          super(new com.dtstack.flink.sql.side.cassandra.CassandraAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoL🔵</abbr>
  88      }
  89  
  90  
  91      @Override
  92      public void open(Configuration parameters) throws Exception {
  93          super.open(parameters);
  94          cassandraSideTableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
  95          connCassandraDB(cassandraSideTableInfo);
  96      }
  97  
  98      private void connCassandraDB(CassandraSideTableInfo tableInfo) {
  99          try {
 100              if (session == null) {
 101                  QueryOptions queryOptions = new QueryOptions();
 102                  //The default consistency level for queries: ConsistencyLevel.TWO.
 103                  queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 104                  Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 104                  Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo🔵</abbr>
<abbr title=" 105                  Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 105                  Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.get🔵</abbr>
<abbr title=" 106                  Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 106                  Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.g🔵</abbr>
 107                  Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();
<abbr title=" 108                  Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 108                  Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTi🔵</abbr>
<abbr title=" 109                  Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 109                  Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.get🔵</abbr>
<abbr title=" 110                  Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 110                  Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTi🔵</abbr>
 111                  Integer cassandraPort = 0;
 112                  String address = tableInfo.getAddress();
 113                  String userName = tableInfo.getUserName();
 114                  String password = tableInfo.getPassword();
 115                  String database = tableInfo.getDatabase();
 116  
 117                  ArrayList serversList = new ArrayList();
 118                  //Read timeout or connection timeout Settings
 119                  SocketOptions so = new SocketOptions()
 120                          .setReadTimeoutMillis(readTimeoutMillis)
 121                          .setConnectTimeoutMillis(connectTimeoutMillis);
 122  
 123                  //The cluster USES hostdistance.local in the same machine room
 124                  //Hostdistance. REMOTE is used for different machine rooms
 125                  //Ignore use HostDistance. IGNORED
 126                  PoolingOptions poolingOptions = new PoolingOptions()
 127                          //Each connection allows a maximum of 64 concurrent requests
 128                          .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 129                          //Have at least two connections to each machine in the cluster
 130                          .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 131                          //There are up to eight connections to each machine in the cluster
 132                          .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 133                          .setMaxQueueSize(maxQueueSize)
 134                          .setPoolTimeoutMillis(poolTimeoutMillis);
 135                  //重试策略
 136                  RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 137  
 138                  for (String server : StringUtils.split(address, &quot;,&quot;)) {
 139                      cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 140                      serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 141                  }
 142  
 143                  if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
 144                      cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)
 145                              .withPort(cassandraPort)
 146                              .withPoolingOptions(poolingOptions).withSocketOptions(so)
 147                              .withQueryOptions(queryOptions).build();
 148                  } else {
 149                      cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)
 150                              .withPort(cassandraPort)
 151                              .withPoolingOptions(poolingOptions).withSocketOptions(so)
 152                              .withCredentials(userName, password)
 153                              .withQueryOptions(queryOptions).build();
 154                  }
 155                  // 建立连接 连接已存在的键空间
 156                  session = cluster.connectAsync(database);
 157                  LOG.info(&quot;connect cassandra is successed!&quot;);
 158              }
 159          } catch (Exception e) {
 160              LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 161          }
 162      }
 163  
 164      @Override
 165      public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 166          CRow inputCopy = new CRow(input.row(), input.change());
 167          JsonArray inputParams = new JsonArray();
 168          StringBuffer stringBuffer = new StringBuffer();
 169          String sqlWhere = &quot; where &quot;;
 170  
 171          for (int i = 0; i &lt; sideInfo.getEqualFieldList().size(); i++) {
 172              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 173              Object equalObj = inputCopy.row().getField(conValIndex);
 174              if (equalObj == null) {
 175                  dealMissKey(inputCopy, resultFuture);
 176                  return;
 177              }
 178              inputParams.add(equalObj);
 179              StringBuffer sqlTemp = stringBuffer.append(sideInfo.getEqualFieldList().get(i))
 180                      .append(&quot; = &quot;);
 181              if (equalObj instanceof String) {
 182                  sqlTemp.append(&quot;&#x27;&quot; + equalObj + &quot;&#x27;&quot;)
 183                          .append(&quot; and &quot;);
 184              } else {
 185                  sqlTemp.append(equalObj)
 186                          .append(&quot; and &quot;);
 187              }
 188  
 189          }

 190  
 191          String key = buildCacheKey(inputParams);
 192          sqlWhere = sqlWhere + stringBuffer.toString().substring(0, stringBuffer.lastIndexOf(&quot; and &quot;));
 193  
 194          if (openCache()) {
 195              CacheObj val = getFromCache(key);
 196              if (val != null) {
 197  
 198                  if (ECacheContentType.MissVal == val.getType()) {
 199                      dealMissKey(inputCopy, resultFuture);
 200                      return;
 201                  } else if (ECacheContentType.MultiLine == val.getType()) {
 202                      List&lt;CRow&gt; rowList = Lists.newArrayList();
 203                      for (Object jsonArray : (List) val.getContent()) {
 204                          Row row = fillData(inputCopy.row(), jsonArray);
 205                          rowList.add(new CRow(row, inputCopy.change()));
 206                      }
 207                      resultFuture.complete(rowList);
 208                  } else {
 209                      throw new RuntimeException(&quot;not support cache obj type &quot; + val.getType());
 210                  }
 211                  return;
 212              }
 213          }
 214  
 215          //connect Cassandra
 216          connCassandraDB(cassandraSideTableInfo);
 217  
 218          String sqlCondition = sideInfo.getSqlCondition() + &quot; &quot; + sqlWhere + &quot;  ALLOW FILTERING &quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -        System.out.println(&quot;sqlCondition:&quot; + sqlCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +        LOG.info(&quot;sqlCondition:{}&quot; + sqlCondition);</span>
 221  
 222          ListenableFuture&lt;ResultSet&gt; resultSet = Futures.transformAsync(session,
 223                  new AsyncFunction&lt;Session, ResultSet&gt;() {
 224                      @Override
 225                      public ListenableFuture&lt;ResultSet&gt; apply(Session session) throws Exception {
 226                          return session.executeAsync(sqlCondition);
 227                      }
 228                  });
 229  
 230          ListenableFuture&lt;List&lt;com.datastax.driver.core.Row&gt;&gt; data = Futures.transform(resultSet,
 231                  new Function&lt;ResultSet, List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 232                      @Override
 233                      public List&lt;com.datastax.driver.core.Row&gt; apply(ResultSet rs) {
 234                          return rs.all();
 235                      }
 236                  });
 237  
 238          Futures.addCallback(data, new FutureCallback&lt;List&lt;com.datastax.driver.core.Row&gt;&gt;() {
 239              @Override
 240              public void onSuccess(List&lt;com.datastax.driver.core.Row&gt; rows) {
 241                  cluster.closeAsync();
 242                  if (rows.size() &gt; 0) {
 243                      List&lt;com.datastax.driver.core.Row&gt; cacheContent = Lists.newArrayList();
 244                      List&lt;CRow&gt; rowList = Lists.newArrayList();
 245                      for (com.datastax.driver.core.Row line : rows) {
 246                          Row row = fillData(inputCopy.row(), line);

 247                          if (openCache()) {
 248                              cacheContent.add(line);
 249                          }
 250                          rowList.add(new CRow(row,inputCopy.change()));

 251                      }
 252                      resultFuture.complete(rowList);
 253                      if (openCache()) {
 254                          putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 255                      }
 256                  } else {
 257                      dealMissKey(inputCopy, resultFuture);

 258                      if (openCache()) {
 259                          putCache(key, CacheMissVal.getMissKeyObj());
 260                      }
 261                      resultFuture.complete(null);
 262                  }
 263              }
 264  
 265              @Override
 266              public void onFailure(Throwable t) {
 267                  LOG.error(&quot;Failed to retrieve the data: %s%n&quot;,
 268                          t.getMessage());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 269 -                System.out.println(&quot;Failed to retrieve the data: &quot; + t.getMessage());</span>
 270                  cluster.closeAsync();
 271                  resultFuture.completeExceptionally(t);
 272              }
 273          });


















 274      }
 275  
 276      @Override
 277      public Row fillData(Row input, Object line) {
 278          com.datastax.driver.core.Row rowArray = (com.datastax.driver.core.Row) line;
 279          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 280          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 281              Object obj = input.getField(entry.getValue());
<abbr title=" 282              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 282              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr>
 283  
 284              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 285                  obj = ((Timestamp) obj).getTime();
 286              }
 287  
 288              row.setField(entry.getKey(), obj);
 289          }
 290  
 291          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 292              if (rowArray == null) {
 293                  row.setField(entry.getKey(), null);
 294              } else {
 295                  row.setField(entry.getKey(), rowArray.getObject(entry.getValue()));
 296              }
 297          }
 298  
 299          return row;
 300      }
 301  
 302      @Override
 303      public void close() throws Exception {
 304          super.close();
 305          if (cluster != null) {
 306              cluster.close();
 307              cluster = null;
 308          }
 309      }
 310  
 311      public String buildCacheKey(JsonArray jsonArray) {
 312          StringBuilder sb = new StringBuilder();
 313          for (Object ele : jsonArray.getList()) {
 314              sb.append(ele.toString())
 315                      .append(&quot;_&quot;);
 316          }
 317  
 318          return sb.toString();
 319      }
 320  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            