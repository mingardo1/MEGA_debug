<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>524</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    524
                    <a href="523.html">prev</a>
                    <a href="525.html">next</a>
                    <a href="524_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_f05e92b15d5e4c94442e53a9f83e2659c369aa5e_core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f05e92b15d5e4c94442e53a9f83e2659c369aa5e:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f05e92b15d5e4c94442e53a9f83e2659c369aa5e^1:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f05e92b15d5e4c94442e53a9f83e2659c369aa5e^2:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;14446f4dd844b1bb9da6c412e3556e135bafcba4:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheContentType;
  24 import com.dtstack.flink.sql.enums.ECacheType;
  25 import com.dtstack.flink.sql.metric.MetricConstant;
  26 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  27 import com.dtstack.flink.sql.side.cache.CacheObj;
  28 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  29 import com.google.common.collect.Lists;
  30 import com.google.common.collect.Maps;
  31 import org.apache.calcite.sql.JoinType;
  32 import org.apache.commons.collections.MapUtils;
  33 import org.apache.flink.api.common.functions.RuntimeContext;
  34 import org.apache.flink.configuration.Configuration;
  35 import org.apache.flink.metrics.Counter;
  36 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  37 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  38 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  39 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  40 import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  41 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  42 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;</span>
  43 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  44 import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  45 import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  46 import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  47 import org.slf4j.Logger;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  48 import org.slf4j.LoggerFactory;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  49 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  50 import java.util.Collections;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  51 import java.util.concurrent.TimeoutException;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  52 </span>
  53 =======
  54 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  55 import org.apache.flink.table.runtime.types.CRow;
  56 import org.apache.flink.types.Row;
  57 import org.slf4j.Logger;
  58 import org.slf4j.LoggerFactory;
  59 
  60 import java.util.Collections;
  61 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  62 import java.util.List;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  63 import java.util.Map;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  64 import java.util.concurrent.LinkedBlockingQueue;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  65 import java.util.concurrent.ScheduledFuture;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  66 import java.util.concurrent.ThreadPoolExecutor;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  67 import java.util.concurrent.TimeUnit;</span>
  68 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  69 import java.util.Collections;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  70 import java.util.concurrent.TimeoutException;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  71 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  72 /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  73  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  74  * only support Left join / inner join(join),not support right join</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  75  * Date: 2018/7/9</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  76  * Company: www.dtstack.com</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  77  * @author xuchao</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  78  */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  79 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  80 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  81     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  82     private static final long serialVersionUID = 2098635244857937717L;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  83 </span>
  84 =======
  85 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  86 
  87 /**
  88  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  89  * only support Left join / inner join(join),not support right join
  90  * Date: 2018/7/9
  91  * Company: www.dtstack.com
  92  * @author xuchao
  93  */
  94 
  95 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {
  96     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  97     private static final long serialVersionUID = 2098635244857937717L;
  98     private RuntimeContext runtimeContext;
  99 
 100     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
 101     private int timeOutNum = 0;
 102 
 103     protected BaseSideInfo sideInfo;
 104     protected transient Counter parseErrorRecords;
 105 
 106     public BaseAsyncReqRow(BaseSideInfo sideInfo){
 107         this.sideInfo = sideInfo;
 108     }
 109     @Override
 110     public void setRuntimeContext(RuntimeContext runtimeContext) {
 111         super.setRuntimeContext(runtimeContext);
 112         this.runtimeContext = runtimeContext;
 113     }
 114     @Override
 115     public void open(Configuration parameters) throws Exception {
 116         super.open(parameters);
 117         initCache();
 118         initMetric();
 119     }
 120 
 121     private void initCache(){
 122         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title=" 123         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){"> 123         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
 124             return;
 125         }
 126 
 127         AbstractSideCache sideCache;
 128         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
 129             sideCache = new LRUSideCache(sideTableInfo);
 130             sideInfo.setSideCache(sideCache);
 131         }else{
<abbr title=" 132             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());"> 132             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 133         }
 134         sideCache.initCache();
 135     }
 136 
 137     private void initMetric() {
<abbr title=" 138         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 138         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 139     }
 140 
 141     protected CacheObj getFromCache(String key){
 142         return sideInfo.getSideCache().getFromCache(key);
 143     }
 144 
 145     protected void putCache(String key, CacheObj value){
 146         sideInfo.getSideCache().putCache(key, value);
 147     }
 148 
 149     protected boolean openCache(){
 150         return sideInfo.getSideCache() != null;
 151     }
 152 
 153     protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 154         if(sideInfo.getJoinType() == JoinType.LEFT){
 155             //Reserved left table data
 156             try {
 157                 Row row = fillData(input.row(), null);
 158                 resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 159             } catch (Exception e) {
 160                 dealFillDataError(resultFuture, e, input);
 161             }
 162         }else{
 163             resultFuture.complete(null);
 164         }
 165     }
 166 
 167     protected void dealCacheData(String key, CacheObj missKeyObj) {
 168         if (openCache()) {
 169             putCache(key, missKeyObj);
 170         }
 171     }
 172 
 173     @Override
 174     public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 175 
 176         if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
<abbr title=" 177             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);"> 177             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOðŸ”µ</abbr>
 178         }
 179         timeOutNum ++;
 180         if(sideInfo.getJoinType() == JoinType.LEFT){
 181             resultFuture.complete(null);
 182             return;
 183         }
 184         if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
<abbr title=" 185             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 185             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 186             return;
 187         }
 188         resultFuture.complete(null);
 189     }
 190 
 191     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 192         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 193         cancelTimerWhenComplete(resultFuture, timeFuture);
 194     }
 195 
 196     @Override
 197     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 198         preInvoke(input, resultFuture);
 199         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 200         if(MapUtils.isEmpty(inputParams)){
 201             dealMissKey(input, resultFuture);
 202             return;
 203         }
 204         if(isUseCache(inputParams)){
 205             invokeWithCache(inputParams, input, resultFuture);
 206             return;
 207         }
 208         handleAsyncInvoke(inputParams, input, resultFuture);
 209     }
 210 
 211     private Map&lt;String, Object&gt; parseInputParam(CRow input){
 212         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 213         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 214             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 215             Object equalObj = input.row().getField(conValIndex);
 216             if(equalObj == null){
 217                 return inputParams;
 218             }
 219             String columnName = sideInfo.getEqualFieldList().get(conValIndex);
 220             inputParams.put(columnName, equalObj.toString());
 221         }
 222         return inputParams;
 223     }
 224     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 225         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 226     }
 227 
<abbr title=" 228     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 228     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuðŸ”µ</abbr>
 229         if (openCache()) {
 230             CacheObj val = getFromCache(buildCacheKey(inputParams));
 231             if (val != null) {
 232                 if (ECacheContentType.MissVal == val.getType()) {
 233                     dealMissKey(input, resultFuture);
 234                     return;
 235                 }else if(ECacheContentType.SingleLine == val.getType()){
 236                     try {
 237                         Row row = fillData(input.row(), val);
 238                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 239                     } catch (Exception e) {
 240                         dealFillDataError(resultFuture, e, input);
 241                     }
 242                 } else if (ECacheContentType.MultiLine == val.getType()) {
 243                     try {
 244                         List&lt;CRow&gt; rowList = Lists.newArrayList();
 245                         for (Object one : (List) val.getContent()) {
 246                             Row row = fillData(input.row(), one);
 247                             rowList.add(new CRow(row, input.change()));
 248                         }
 249                         resultFuture.complete(rowList);
 250                     } catch (Exception e) {
 251                         dealFillDataError(resultFuture, e, input);
 252                     }
 253                 } else {
<abbr title=" 254                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 254                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 255                 }
 256                 return;
 257             }
 258         }
 259     }
 260 
<abbr title=" 261     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 261     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRoðŸ”µ</abbr>
 262 
 263     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 264 
 265     private ProcessingTimeService getProcessingTimeService(){
 266         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 267     }
 268 
 269     protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
<abbr title=" 270         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 270         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr>
 271         return getProcessingTimeService().registerTimer(
 272                 timeoutTimestamp,
 273                 new ProcessingTimeCallback() {
 274                     @Override
 275                     public void onProcessingTime(long timestamp) throws Exception {
 276                         timeout(input, resultFuture);
 277                     }
 278                 });
 279     }
 280 
<abbr title=" 281     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){"> 281     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuturðŸ”µ</abbr>
<abbr title=" 282         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 282         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBðŸ”µ</abbr>
 283         if(resultFuture instanceof StreamRecordQueueEntry){
 284             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;
 285             streamRecordBufferEntry.onComplete((Object value) -&gt; {
 286                 timerFuture.cancel(true);
 287             },executors);
 288         }
 289     }
 290 
 291     protected void dealFillDataError(ResultFuture&lt;CRow&gt; resultFuture, Exception e, Object sourceData) {
 292         LOG.debug(&quot;source data {} join side table error &quot;, sourceData);
 293         LOG.debug(&quot;async buid row error..{}&quot;, e);
 294         parseErrorRecords.inc();
 295         resultFuture.complete(Collections.emptyList());
 296     }
 297 
 298     @Override
 299     public void close() throws Exception {
 300         super.close();
 301     }
 302 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheContentType;
  24 import com.dtstack.flink.sql.enums.ECacheType;
  25 import com.dtstack.flink.sql.metric.MetricConstant;
  26 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  27 import com.dtstack.flink.sql.side.cache.CacheObj;
  28 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  29 import com.google.common.collect.Lists;
  30 import com.google.common.collect.Maps;
  31 import org.apache.calcite.sql.JoinType;
  32 import org.apache.commons.collections.MapUtils;
  33 import org.apache.flink.api.common.functions.RuntimeContext;
  34 import org.apache.flink.configuration.Configuration;
  35 import org.apache.flink.metrics.Counter;
  36 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  37 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  38 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
  39 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  40 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
  41 import org.apache.flink.table.runtime.types.CRow;
  42 import org.apache.flink.types.Row;
  43 import org.slf4j.Logger;
  44 import org.slf4j.LoggerFactory;
  45 
  46 import java.util.Collections;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.concurrent.LinkedBlockingQueue;
  50 import java.util.concurrent.ScheduledFuture;
  51 import java.util.concurrent.ThreadPoolExecutor;
  52 import java.util.concurrent.TimeUnit;
  53 
  54 /**
  55  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  56  * only support Left join / inner join(join),not support right join
  57  * Date: 2018/7/9
  58  * Company: www.dtstack.com
  59  * @author xuchao
  60  */
  61 
  62 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {
  63     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  64     private static final long serialVersionUID = 2098635244857937717L;
  65     private RuntimeContext runtimeContext;
  66 
  67     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  68     private int timeOutNum = 0;
  69 
  70     protected BaseSideInfo sideInfo;
  71     protected transient Counter parseErrorRecords;
  72 
  73     public BaseAsyncReqRow(BaseSideInfo sideInfo){
  74         this.sideInfo = sideInfo;
  75     }
  76     @Override
  77     public void setRuntimeContext(RuntimeContext runtimeContext) {
  78         super.setRuntimeContext(runtimeContext);
  79         this.runtimeContext = runtimeContext;
  80     }
  81     @Override
  82     public void open(Configuration parameters) throws Exception {
  83         super.open(parameters);
  84         initCache();
  85         initMetric();
  86     }
  87 
  88     private void initCache(){
  89         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  90         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  90         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
  91             return;
  92         }
  93 
  94         AbstractSideCache sideCache;
  95         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
  96             sideCache = new LRUSideCache(sideTableInfo);
  97             sideInfo.setSideCache(sideCache);
  98         }else{
<abbr title="  99             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());">  99             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 100         }
 101         sideCache.initCache();
 102     }
 103 
 104     private void initMetric() {
<abbr title=" 105         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 105         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 106     }
 107 
 108     protected CacheObj getFromCache(String key){
 109         return sideInfo.getSideCache().getFromCache(key);
 110     }
 111 
 112     protected void putCache(String key, CacheObj value){
 113         sideInfo.getSideCache().putCache(key, value);
 114     }
 115 
 116     protected boolean openCache(){
 117         return sideInfo.getSideCache() != null;
 118     }
 119 
 120     protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 121         if(sideInfo.getJoinType() == JoinType.LEFT){
 122             //Reserved left table data
 123             try {
 124                 Row row = fillData(input.row(), null);
 125                 resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 126             } catch (Exception e) {
 127                 dealFillDataError(resultFuture, e, input);
 128             }
 129         }else{
 130             resultFuture.complete(null);
 131         }
 132     }
 133 
 134     protected void dealCacheData(String key, CacheObj missKeyObj) {
 135         if (openCache()) {
 136             putCache(key, missKeyObj);
 137         }
 138     }
 139 
 140     @Override
 141     public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 142 
 143         if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
<abbr title=" 144             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);"> 144             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOðŸ”µ</abbr>
 145         }
 146         timeOutNum ++;
 147         if(sideInfo.getJoinType() == JoinType.LEFT){
 148             resultFuture.complete(null);
 149             return;
 150         }
 151         if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
<abbr title=" 152             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 152             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 153             return;
 154         }
 155         resultFuture.complete(null);
 156     }
 157 
 158     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 159         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 160         cancelTimerWhenComplete(resultFuture, timeFuture);
 161     }
 162 
 163     @Override
 164     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 165         preInvoke(input, resultFuture);
 166         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 167         if(MapUtils.isEmpty(inputParams)){
 168             dealMissKey(input, resultFuture);
 169             return;
 170         }
 171         if(isUseCache(inputParams)){
 172             invokeWithCache(inputParams, input, resultFuture);
 173             return;
 174         }
 175         handleAsyncInvoke(inputParams, input, resultFuture);
 176     }
 177 
 178     private Map&lt;String, Object&gt; parseInputParam(CRow input){
 179         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 180         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 181             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 182             Object equalObj = input.row().getField(conValIndex);
 183             if(equalObj == null){
 184                 return inputParams;
 185             }
 186             String columnName = sideInfo.getEqualFieldList().get(conValIndex);
 187             inputParams.put(columnName, equalObj.toString());
 188         }
 189         return inputParams;
 190     }
 191     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 192         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 193     }
 194 
<abbr title=" 195     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 195     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuðŸ”µ</abbr>
 196         if (openCache()) {
 197             CacheObj val = getFromCache(buildCacheKey(inputParams));
 198             if (val != null) {
 199                 if (ECacheContentType.MissVal == val.getType()) {
 200                     dealMissKey(input, resultFuture);
 201                     return;
 202                 }else if(ECacheContentType.SingleLine == val.getType()){
 203                     try {
 204                         Row row = fillData(input.row(), val);
 205                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 206                     } catch (Exception e) {
 207                         dealFillDataError(resultFuture, e, input);
 208                     }
 209                 } else if (ECacheContentType.MultiLine == val.getType()) {
 210                     try {
 211                         List&lt;CRow&gt; rowList = Lists.newArrayList();
 212                         for (Object one : (List) val.getContent()) {
 213                             Row row = fillData(input.row(), one);
 214                             rowList.add(new CRow(row, input.change()));
 215                         }
 216                         resultFuture.complete(rowList);
 217                     } catch (Exception e) {
 218                         dealFillDataError(resultFuture, e, input);
 219                     }
 220                 } else {
<abbr title=" 221                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 221                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 222                 }
 223                 return;
 224             }
 225         }
 226     }
 227 
<abbr title=" 228     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 228     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRoðŸ”µ</abbr>
 229 
 230     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 231 
 232     private ProcessingTimeService getProcessingTimeService(){
 233         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 234     }
 235 
 236     protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
<abbr title=" 237         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 237         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr>
 238         return getProcessingTimeService().registerTimer(
 239                 timeoutTimestamp,
 240                 new ProcessingTimeCallback() {
 241                     @Override
 242                     public void onProcessingTime(long timestamp) throws Exception {
 243                         timeout(input, resultFuture);
 244                     }
 245                 });
 246     }
 247 
<abbr title=" 248     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){"> 248     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuturðŸ”µ</abbr>
<abbr title=" 249         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 249         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBðŸ”µ</abbr>
 250         if(resultFuture instanceof StreamRecordQueueEntry){
 251             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;
 252             streamRecordBufferEntry.onComplete((Object value) -&gt; {
 253                 timerFuture.cancel(true);
 254             },executors);
 255         }
 256     }
 257 
 258     protected void dealFillDataError(ResultFuture&lt;CRow&gt; resultFuture, Exception e, Object sourceData) {
 259         LOG.debug(&quot;source data {} join side table error &quot;, sourceData);
 260         LOG.debug(&quot;async buid row error..{}&quot;, e);
 261         parseErrorRecords.inc();
 262         resultFuture.complete(Collections.emptyList());
 263     }
 264 
 265     @Override
 266     public void close() throws Exception {
 267         super.close();
 268     }
 269 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.enums.ECacheType;
  22 import com.dtstack.flink.sql.metric.MetricConstant;
  23 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  24 import com.dtstack.flink.sql.side.cache.CacheObj;
  25 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  26 import com.google.common.collect.Lists;
  27 import com.google.common.collect.Maps;
  28 import java.util.Collections;
  29 import java.util.List;
  30 import java.util.Map;
  31 import java.util.concurrent.LinkedBlockingQueue;
  32 import java.util.concurrent.ScheduledFuture;
  33 import java.util.concurrent.ThreadPoolExecutor;
  34 import java.util.concurrent.TimeUnit;
  35 import org.apache.calcite.sql.JoinType;
  36 import org.apache.commons.collections.MapUtils;
  37 import org.apache.flink.api.common.functions.RuntimeContext;
  38 import org.apache.flink.configuration.Configuration;
  39 import org.apache.flink.metrics.Counter;
  40 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  41 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  42 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
  43 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  44 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
  45 import org.apache.flink.table.runtime.types.CRow;
  46 import org.apache.flink.types.Row;
  47 import org.slf4j.Logger;
  48 import org.slf4j.LoggerFactory;
  49 
  50 
  51 /**
  52  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  53  * only support Left join / inner join(join),not support right join
  54  * Date: 2018/7/9
  55  * Company: www.dtstack.com
  56  * @author xuchao
  57  */
  58 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {
  59     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  60 
  61     private static final long serialVersionUID = 2098635244857937717L;
  62 
  63     private RuntimeContext runtimeContext;
  64 
  65     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  66 
  67     private int timeOutNum = 0;
  68 
  69     protected BaseSideInfo sideInfo;
  70 
  71     protected transient Counter parseErrorRecords;
  72 
  73     public BaseAsyncReqRow(BaseSideInfo sideInfo) {
  74         this.sideInfo = sideInfo;
  75     }
  76 
  77     @Override
  78     public void setRuntimeContext(RuntimeContext runtimeContext) {
  79         super.setRuntimeContext(runtimeContext);
  80         this.runtimeContext = runtimeContext;
  81     }
  82 
  83     @Override
  84     public void open(Configuration parameters) throws Exception {
  85         super.open(parameters);
  86         initCache();
  87         initMetric();
  88     }
  89 
  90     private void initCache(){
  91         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  92         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  92         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
  93             return;
  94         }
  95 
  96         AbstractSideCache sideCache;
  97         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
  98             sideCache = new LRUSideCache(sideTableInfo);
  99             sideInfo.setSideCache(sideCache);
 100         }else{
<abbr title=" 101             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());"> 101             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 102         }
 103         sideCache.initCache();
 104     }
 105 
 106     private void initMetric() {
<abbr title=" 107         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 107         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 108     }
 109 
 110     protected CacheObj getFromCache(String key){
 111         return sideInfo.getSideCache().getFromCache(key);
 112     }
 113 
 114     protected void putCache(String key, CacheObj value){
 115         sideInfo.getSideCache().putCache(key, value);
 116     }
 117 
 118     protected boolean openCache(){
 119         return sideInfo.getSideCache() != null;
 120     }
 121 
 122     protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 123         if(sideInfo.getJoinType() == JoinType.LEFT){
 124             //Reserved left table data
 125             try {
 126                 Row row = fillData(input.row(), null);
 127                 resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 128             } catch (Exception e) {
 129                 dealFillDataError(resultFuture, e, input);
 130             }
 131         }else{
 132             resultFuture.complete(null);
 133         }
 134     }
 135 
 136     protected void dealCacheData(String key, CacheObj missKeyObj) {
 137         if (openCache()) {
 138             putCache(key, missKeyObj);
 139         }
 140     }
 141 
 142     @Override
 143     public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 144         if ((timeOutNum % TIMEOUT_LOG_FLUSH_NUM) == 0) {
<abbr title=" 145             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;, input.toString(), timeOutNum);"> 145             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;, input.toString(), timeðŸ”µ</abbr>
 146         }
 147         timeOutNum++;
 148         if (sideInfo.getJoinType() == JoinType.LEFT) {
 149             resultFuture.complete(null);
 150             return;
 151         }
 152         if (timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)) {
<abbr title=" 153             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 153             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 154             return;
 155         }
 156         resultFuture.complete(null);
 157     }
 158 
 159     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 160         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 161         cancelTimerWhenComplete(resultFuture, timeFuture);
 162     }
 163 
 164     @Override
 165     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 166         preInvoke(input, resultFuture);
 167         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 168         if(MapUtils.isEmpty(inputParams)){
 169             dealMissKey(input, resultFuture);
 170             return;
 171         }
 172         if(isUseCache(inputParams)){
 173             invokeWithCache(inputParams, input, resultFuture);
 174             return;
 175         }
 176         handleAsyncInvoke(inputParams, input, resultFuture);
 177     }
 178 
 179     private Map&lt;String, Object&gt; parseInputParam(CRow input){
 180         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 181         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 182             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 183             Object equalObj = input.row().getField(conValIndex);
 184             if(equalObj == null){
 185                 return inputParams;
 186             }
 187             String columnName = sideInfo.getEqualFieldList().get(conValIndex);
 188             inputParams.put(columnName, equalObj.toString());
 189         }
 190         return inputParams;
 191     }
 192 
 193     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 194         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 195     }
 196 
<abbr title=" 197     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 197     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuðŸ”µ</abbr>
 198         if (openCache()) {
 199             CacheObj val = getFromCache(buildCacheKey(inputParams));
 200             if (val != null) {
 201                 if (ECacheContentType.MissVal == val.getType()) {
 202                     dealMissKey(input, resultFuture);
 203                     return;
 204                 }else if(ECacheContentType.SingleLine == val.getType()){
 205                     try {
 206                         Row row = fillData(input.row(), val);
 207                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 208                     } catch (Exception e) {
 209                         dealFillDataError(resultFuture, e, input);
 210                     }
 211                 } else if (ECacheContentType.MultiLine == val.getType()) {
 212                     try {
 213                         List&lt;CRow&gt; rowList = Lists.newArrayList();
 214                         for (Object one : (List) val.getContent()) {
 215                             Row row = fillData(input.row(), one);
 216                             rowList.add(new CRow(row, input.change()));
 217                         }
 218                         resultFuture.complete(rowList);
 219                     } catch (Exception e) {
 220                         dealFillDataError(resultFuture, e, input);
 221                     }
 222                 } else {
<abbr title=" 223                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 223                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 224                 }
 225                 return;
 226             }
 227         }
 228     }
 229 
<abbr title=" 230     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 230     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRoðŸ”µ</abbr>
 231 
 232     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 233 
 234     private ProcessingTimeService getProcessingTimeService(){
 235         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 236     }
 237 
 238     protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
<abbr title=" 239         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 239         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr>
 240         return getProcessingTimeService().registerTimer(
 241                 timeoutTimestamp,
 242                 new ProcessingTimeCallback() {
 243                     @Override
 244                     public void onProcessingTime(long timestamp) throws Exception {
 245                         timeout(input, resultFuture);
 246                     }
 247                 });
 248     }
 249 
<abbr title=" 250     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){"> 250     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuturðŸ”µ</abbr>
<abbr title=" 251         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 251         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBðŸ”µ</abbr>
 252         if(resultFuture instanceof StreamRecordQueueEntry){
 253             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;
 254             streamRecordBufferEntry.onComplete((Object value) -&gt; {
 255                 timerFuture.cancel(true);
 256             },executors);
 257         }
 258     }
 259 
 260     protected void dealFillDataError(ResultFuture&lt;CRow&gt; resultFuture, Exception e, Object sourceData) {
 261         LOG.debug(&quot;source data {} join side table error &quot;, sourceData);
 262         LOG.debug(&quot;async buid row error..{}&quot;, e);
 263         parseErrorRecords.inc();
 264         resultFuture.complete(Collections.emptyList());
 265     }
 266 
 267     @Override
 268     public void close() throws Exception {
 269         super.close();
 270     }
 271 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import com.dtstack.flink.sql.enums.ECacheContentType;</span>
  24  import com.dtstack.flink.sql.enums.ECacheType;
  25  import com.dtstack.flink.sql.metric.MetricConstant;
  26  import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  27  import com.dtstack.flink.sql.side.cache.CacheObj;
  28  import com.dtstack.flink.sql.side.cache.LRUSideCache;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import com.google.common.collect.Maps;</span>
  31  import org.apache.calcite.sql.JoinType;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import org.apache.commons.collections.MapUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import org.apache.flink.api.common.functions.RuntimeContext;</span>
  34  import org.apache.flink.configuration.Configuration;
  35  import org.apache.flink.metrics.Counter;
  36  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  37  import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;</span>
  39  import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;</span>
  42  import org.apache.flink.table.runtime.types.CRow;
  43  import org.apache.flink.types.Row;
  44  import org.slf4j.Logger;
  45  import org.slf4j.LoggerFactory;
  46  
  47  import java.util.Collections;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import java.util.concurrent.TimeoutException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import java.util.List;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import java.util.Map;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +import java.util.concurrent.LinkedBlockingQueue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  52 +import java.util.concurrent.ScheduledFuture;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +import java.util.concurrent.ThreadPoolExecutor;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +import java.util.concurrent.TimeUnit;</span>
  55  
  56  /**
  57   * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  58   * only support Left join / inner join(join),not support right join
  59   * Date: 2018/7/9
  60   * Company: www.dtstack.com
  61   * @author xuchao
  62   */
  63  
  64  public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {
  65      private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  66      private static final long serialVersionUID = 2098635244857937717L;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +    private RuntimeContext runtimeContext;</span>
  68  
  69      private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  70      private int timeOutNum = 0;
  71  
  72      protected BaseSideInfo sideInfo;
  73      protected transient Counter parseErrorRecords;
  74  
  75      public BaseAsyncReqRow(BaseSideInfo sideInfo){
  76          this.sideInfo = sideInfo;
  77      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +    public void setRuntimeContext(RuntimeContext runtimeContext) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +        super.setRuntimeContext(runtimeContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +        this.runtimeContext = runtimeContext;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +    }</span>
  84      @Override
  85      public void open(Configuration parameters) throws Exception {
  86          super.open(parameters);
  87          initCache();
  88          initMetric();
  89      }
  90  
  91      private void initCache(){
  92          AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  93          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  93          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheTðŸ”µ</abbr>
  94              return;
  95          }
  96  
  97          AbstractSideCache sideCache;
  98          if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
  99              sideCache = new LRUSideCache(sideTableInfo);
 100              sideInfo.setSideCache(sideCache);
 101          }else{
 102              throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());
 103          }
 104          sideCache.initCache();
 105      }
 106  
 107      private void initMetric() {
<abbr title=" 108          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 108          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_REðŸ”µ</abbr>
 109      }
 110  
 111      protected CacheObj getFromCache(String key){
 112          return sideInfo.getSideCache().getFromCache(key);
 113      }
 114  
 115      protected void putCache(String key, CacheObj value){
 116          sideInfo.getSideCache().putCache(key, value);
 117      }
 118  
 119      protected boolean openCache(){
 120          return sideInfo.getSideCache() != null;
 121      }
 122  
 123      protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 124          if(sideInfo.getJoinType() == JoinType.LEFT){
 125              //Reserved left table data
 126              try {
 127                  Row row = fillData(input.row(), null);
 128                  resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 129              } catch (Exception e) {
 130                  dealFillDataError(resultFuture, e, input);
 131              }
 132          }else{
 133              resultFuture.complete(null);
 134          }
 135      }
 136  
 137      protected void dealCacheData(String key, CacheObj missKeyObj) {
 138          if (openCache()) {
 139              putCache(key, missKeyObj);
 140          }
 141      }
 142  
 143      @Override
 144      public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 145  
 146          if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
 147              LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);
 148          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -</span>
 150          timeOutNum ++;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -        if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncTimeoutNumLimit()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +        if(sideInfo.getJoinType() == JoinType.LEFT){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +            resultFuture.complete(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +        if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){</span>
 157              resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -            resultFuture.complete(null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +        resultFuture.complete(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +    protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +        ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +        cancelTimerWhenComplete(resultFuture, timeFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +    public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +        preInvoke(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +        Map&lt;String, Object&gt; inputParams = parseInputParam(input);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +        if(MapUtils.isEmpty(inputParams)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +            dealMissKey(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +        if(isUseCache(inputParams)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +            invokeWithCache(inputParams, input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +        handleAsyncInvoke(inputParams, input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +    private Map&lt;String, Object&gt; parseInputParam(CRow input){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +        Map&lt;String, Object&gt; inputParams = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +        for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +            Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +            Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +            if(equalObj == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +                return inputParams;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +            String columnName = sideInfo.getEqualFieldList().get(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +            inputParams.put(columnName, equalObj.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 199 +        return inputParams;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +    protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +        return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +    private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +        if (openCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +            CacheObj val = getFromCache(buildCacheKey(inputParams));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +            if (val != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +                if (ECacheContentType.MissVal == val.getType()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +                    dealMissKey(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +                    return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +                }else if(ECacheContentType.SingleLine == val.getType()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +                        Row row = fillData(input.row(), val);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +                    } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +                        dealFillDataError(resultFuture, e, input);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +                } else if (ECacheContentType.MultiLine == val.getType()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +                        List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +                        for (Object one : (List) val.getContent()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +                            Row row = fillData(input.row(), one);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +                            rowList.add(new CRow(row, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +                        resultFuture.complete(rowList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                    } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +                        dealFillDataError(resultFuture, e, input);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 231 +                    resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 231 +                    resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.geðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 238 +    public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 238 +    public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +    public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +    private ProcessingTimeService getProcessingTimeService(){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +        return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +    protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 247 +        long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 247 +        long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +        return getProcessingTimeService().registerTimer(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +                timeoutTimestamp,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +                new ProcessingTimeCallback() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +                    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +                    public void onProcessingTime(long timestamp) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +                        timeout(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +                });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +    protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 259 +        ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 259 +        ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQuðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +        if(resultFuture instanceof StreamRecordQueueEntry){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +            StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +            streamRecordBufferEntry.onComplete((Object value) -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +                timerFuture.cancel(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +            },executors);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 265 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 266 +    }</span>
 267  
 268      protected void dealFillDataError(ResultFuture&lt;CRow&gt; resultFuture, Exception e, Object sourceData) {
 269          LOG.debug(&quot;source data {} join side table error &quot;, sourceData);
 270          LOG.debug(&quot;async buid row error..{}&quot;, e);
 271          parseErrorRecords.inc();
 272          resultFuture.complete(Collections.emptyList());
 273      }
 274  
 275      @Override
 276      public void close() throws Exception {
 277          super.close();
 278      }
 279  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  

  23  import com.dtstack.flink.sql.enums.ECacheType;
  24  import com.dtstack.flink.sql.metric.MetricConstant;
  25  import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  26  import com.dtstack.flink.sql.side.cache.CacheObj;
  27  import com.dtstack.flink.sql.side.cache.LRUSideCache;


  28  import org.apache.calcite.sql.JoinType;


  29  import org.apache.flink.configuration.Configuration;
  30  import org.apache.flink.metrics.Counter;
  31  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  32  import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;</span>


  34  import org.apache.flink.table.runtime.types.CRow;
  35  import org.apache.flink.types.Row;
  36  import org.slf4j.Logger;
  37  import org.slf4j.LoggerFactory;
  38  
  39  import java.util.Collections;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  40 -import java.util.concurrent.TimeoutException;</span>






  41  
  42  /**
  43   * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  44   * only support Left join / inner join(join),not support right join
  45   * Date: 2018/7/9
  46   * Company: www.dtstack.com
  47   * @author xuchao
  48   */
  49  
  50  public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {
  51      private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  52      private static final long serialVersionUID = 2098635244857937717L;

  53  
  54      private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  55      private int timeOutNum = 0;
  56  
  57      protected BaseSideInfo sideInfo;
  58      protected transient Counter parseErrorRecords;
  59  
  60      public BaseAsyncReqRow(BaseSideInfo sideInfo){
  61          this.sideInfo = sideInfo;
  62      }
  63  





  64      @Override
  65      public void open(Configuration parameters) throws Exception {
  66          super.open(parameters);
  67          initCache();
  68          initMetric();
  69      }
  70  
  71      private void initCache(){
  72          AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  73          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  73          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheTðŸ”µ</abbr>
  74              return;
  75          }
  76  
  77          AbstractSideCache sideCache;
  78          if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
  79              sideCache = new LRUSideCache(sideTableInfo);
  80              sideInfo.setSideCache(sideCache);
  81          }else{
  82              throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());
  83          }
  84          sideCache.initCache();
  85      }
  86  
  87      private void initMetric() {
<abbr title="  88          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);">  88          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_REðŸ”µ</abbr>
  89      }
  90  
  91      protected CacheObj getFromCache(String key){
  92          return sideInfo.getSideCache().getFromCache(key);
  93      }
  94  
  95      protected void putCache(String key, CacheObj value){
  96          sideInfo.getSideCache().putCache(key, value);
  97      }
  98  
  99      protected boolean openCache(){
 100          return sideInfo.getSideCache() != null;
 101      }
 102  
 103      protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 104          if(sideInfo.getJoinType() == JoinType.LEFT){
 105              //Reserved left table data
 106              try {
 107                  Row row = fillData(input.row(), null);
 108                  resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 109              } catch (Exception e) {
 110                  dealFillDataError(resultFuture, e, input);
 111              }
 112          }else{
 113              resultFuture.complete(null);
 114          }
 115      }
 116  
 117      protected void dealCacheData(String key, CacheObj missKeyObj) {
 118          if (openCache()) {
 119              putCache(key, missKeyObj);
 120          }
 121      }
 122  
 123      @Override
 124      public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 125  
 126          if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
 127              LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);
 128          }
 129  
 130          timeOutNum ++;
 131          if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncTimeoutNumLimit()){





 132              resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));
 133          } else {
 134              resultFuture.complete(null);
 135          }
 136      }
 137  








































































































 138  
 139      protected void dealFillDataError(ResultFuture&lt;CRow&gt; resultFuture, Exception e, Object sourceData) {
 140          LOG.debug(&quot;source data {} join side table error &quot;, sourceData);
 141          LOG.debug(&quot;async buid row error..{}&quot;, e);
 142          parseErrorRecords.inc();
 143          resultFuture.complete(Collections.emptyList());
 144      }
 145  
 146      @Override
 147      public void close() throws Exception {
 148          super.close();
 149      }
 150  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            