<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>562</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    562
                    <a href="561.html">prev</a>
                    <a href="563.html">next</a>
                    <a href="562_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_fb12dc352e54b1330220f47fa746c5820e2c316c_src/com/android/launcher2/CellLayout.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;fb12dc352e54b1330220f47fa746c5820e2c316c:src/com/android/launcher2/CellLayout.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;fb12dc352e54b1330220f47fa746c5820e2c316c^1:src/com/android/launcher2/CellLayout.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;fb12dc352e54b1330220f47fa746c5820e2c316c^2:src/com/android/launcher2/CellLayout.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;47a876d443ddc65c8d9a0c95da58d892dbb1faea:src/com/android/launcher2/CellLayout.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.ObjectAnimator;
  22 import android.animation.PropertyValuesHolder;
  23 import android.animation.TimeInterpolator;
  24 import android.animation.ValueAnimator;
  25 import android.animation.ValueAnimator.AnimatorUpdateListener;
  26 import android.content.Context;
  27 import android.content.res.Resources;
  28 import android.content.res.TypedArray;
  29 import android.graphics.Bitmap;
  30 import android.graphics.Canvas;
  31 import android.graphics.Color;
  32 import android.graphics.Paint;
  33 import android.graphics.Point;
  34 import android.graphics.PointF;
  35 import android.graphics.PorterDuff;
  36 import android.graphics.PorterDuffXfermode;
  37 import android.graphics.Rect;
  38 import android.graphics.drawable.ColorDrawable;
  39 import android.graphics.drawable.Drawable;
  40 import android.graphics.drawable.NinePatchDrawable;
  41 import android.util.AttributeSet;
  42 import android.util.Log;
  43 import android.view.MotionEvent;
  44 import android.view.View;
  45 import android.view.ViewDebug;
  46 import android.view.ViewGroup;
  47 import android.view.animation.Animation;
  48 import android.view.animation.DecelerateInterpolator;
  49 import android.view.animation.LayoutAnimationController;
  50 
  51 import com.android.launcher.R;
  52 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  53 
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.HashMap;
  57 import java.util.Stack;
  58 
  59 public class CellLayout extends ViewGroup {
  60     static final String TAG = &quot;CellLayout&quot;;
  61 
  62     private int mOriginalCellWidth;
  63     private int mOriginalCellHeight;
  64     private int mCellWidth;
  65     private int mCellHeight;
  66 
  67     private int mCountX;
  68     private int mCountY;
  69 
  70     private int mOriginalWidthGap;
  71     private int mOriginalHeightGap;
  72     private int mWidthGap;
  73     private int mHeightGap;
  74     private int mMaxGap;
  75     private boolean mScrollingTransformsDirty = false;
  76 
  77     private final Rect mRect = new Rect();
  78     private final CellInfo mCellInfo = new CellInfo();
  79 
  80     // These are temporary variables to prevent having to allocate a new object just to
  81     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  82     private final int[] mTmpXY = new int[2];
  83     private final int[] mTmpPoint = new int[2];
  84     private final PointF mTmpPointF = new PointF();
  85     int[] mTempLocation = new int[2];
  86 
  87     boolean[][] mOccupied;
  88     boolean[][] mTmpOccupied;
  89     private boolean mLastDownOnOccupiedCell = false;
  90 
  91     private OnTouchListener mInterceptTouchListener;
  92 
  93     private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
  94     private int[] mFolderLeaveBehindCell = {-1, -1};
  95 
  96     private int mForegroundAlpha = 0;
  97     private float mBackgroundAlpha;
  98     private float mBackgroundAlphaMultiplier = 1.0f;
  99 
 100     private Drawable mNormalBackground;
 101     private Drawable mActiveGlowBackground;
 102     private Drawable mOverScrollForegroundDrawable;
 103     private Drawable mOverScrollLeft;
 104     private Drawable mOverScrollRight;
 105     private Rect mBackgroundRect;
 106     private Rect mForegroundRect;
 107     private int mForegroundPadding;
 108 
 109     // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 110     private boolean mIsDragOverlapping = false;
 111     private final Point mDragCenter = new Point();
 112 
 113     // These arrays are used to implement the drag visualization on x-large screens.
 114     // They are used as circular arrays, indexed by mDragOutlineCurrent.
 115     private Rect[] mDragOutlines = new Rect[4];
 116     private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 117     private InterruptibleInOutAnimator[] mDragOutlineAnims =
 118             new InterruptibleInOutAnimator[mDragOutlines.length];
 119 
 120     // Used as an index into the above 3 arrays; indicates which is the most current value.
 121     private int mDragOutlineCurrent = 0;
 122     private final Paint mDragOutlinePaint = new Paint();
 123 
 124     private BubbleTextView mPressedOrFocusedIcon;
 125 
 126     private Drawable mCrosshairsDrawable = null;
 127     private InterruptibleInOutAnimator mCrosshairsAnimator = null;
 128     private float mCrosshairsVisibility = 0.0f;
 129 
 130     private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new
 131             HashMap&lt;CellLayout.LayoutParams, Animator&gt;();
 132 
 133     // When a drag operation is in progress, holds the nearest cell to the touch point
 134     private final int[] mDragCell = new int[2];
 135 
 136     private boolean mDragging = false;
 137     private boolean mItemLocationsDirty = false;
 138 
 139     private TimeInterpolator mEaseOutInterpolator;
 140     private ShortcutAndWidgetContainer mShortcutsAndWidgets;
 141 
 142     private boolean mIsHotseat = false;
 143     private float mChildScale = 1f;
 144     private float mHotseatChildScale = 1f;
 145 
 146     public static final int MODE_DRAG_OVER = 0;
 147     public static final int MODE_ON_DROP = 1;
 148     public static final int MODE_ON_DROP_EXTERNAL = 2;
 149     public static final int MODE_ACCEPT_DROP = 3;
 150     private static final boolean DESTRUCTIVE_REORDER = true;
 151     private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 152 
 153     private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 154     private Rect mOccupiedRect = new Rect();
 155     private int[] mDirectionVector = new int[2];
 156 
 157     public CellLayout(Context context) {
 158         this(context, null);
 159     }
 160 
 161     public CellLayout(Context context, AttributeSet attrs) {
 162         this(context, attrs, 0);
 163     }
 164 
 165     public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 166         super(context, attrs, defStyle);
 167 
 168         // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 169         // the user where a dragged item will land when dropped.
 170         setWillNotDraw(false);
 171 
 172         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 173 
 174         mOriginalCellWidth =
 175             mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 176         mOriginalCellHeight =
 177             mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 178         mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 179         mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 180         mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 181         mCountX = LauncherModel.getCellCountX();
 182         mCountY = LauncherModel.getCellCountY();
 183         mOccupied = new boolean[mCountX][mCountY];
 184         mTmpOccupied = new boolean[mCountX][mCountY];
 185 
 186         a.recycle();
 187 
 188         setAlwaysDrawnWithCacheEnabled(false);
 189 
 190         final Resources res = getResources();
 191 
 192         mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 193         mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 194 
 195         mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 196         mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 197         mForegroundPadding =
 198                 res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 199 
 200         mNormalBackground.setFilterBitmap(true);
 201         mActiveGlowBackground.setFilterBitmap(true);
 202 
 203         int iconScale = res.getInteger(R.integer.app_icon_scale_percent);
 204         if (iconScale &gt;= 0) {
 205             mChildScale = iconScale / 100f;
 206         }
 207         int hotseatIconScale = res.getInteger(R.integer.app_icon_hotseat_scale_percent);
 208         if (hotseatIconScale &gt;= 0) {
 209             mHotseatChildScale = hotseatIconScale / 100f;
 210         }
 211 
 212         // Initialize the data structures used for the drag visualization.
 213 
 214         mCrosshairsDrawable = res.getDrawable(R.drawable.gardening_crosshairs);
 215         mEaseOutInterpolator = new DecelerateInterpolator(2.5f); // Quint ease out
 216 
 217         // Set up the animation for fading the crosshairs in and out
 218         int animDuration = res.getInteger(R.integer.config_crosshairsFadeInTime);
 219         mCrosshairsAnimator = new InterruptibleInOutAnimator(animDuration, 0.0f, 1.0f);
 220         mCrosshairsAnimator.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 221             public void onAnimationUpdate(ValueAnimator animation) {
 222                 mCrosshairsVisibility = ((Float) animation.getAnimatedValue()).floatValue();
 223                 invalidate();
 224             }
 225         });
 226         mCrosshairsAnimator.getAnimator().setInterpolator(mEaseOutInterpolator);
 227 
 228         mDragCell[0] = mDragCell[1] = -1;
 229         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 230             mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 231         }
 232 
 233         // When dragging things around the home screens, we show a green outline of
 234         // where the item will land. The outlines gradually fade out, leaving a trail
 235         // behind the drag path.
 236         // Set up all the animations that are used to implement this fading.
 237         final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 238         final float fromAlphaValue = 0;
 239         final float toAlphaValue = (float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
 240 
 241         Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 242 
 243         for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
 244             final InterruptibleInOutAnimator anim =
 245                 new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);
 246             anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 247             final int thisIndex = i;
 248             anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 249                 public void onAnimationUpdate(ValueAnimator animation) {
 250                     final Bitmap outline = (Bitmap)anim.getTag();
 251 
 252                     // If an animation is started and then stopped very quickly, we can still
 253                     // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 254                     if (outline == null) {
 255                         if (false) {
 256                             Object val = animation.getAnimatedValue();
 257                             Log.d(TAG, &quot;anim &quot; + thisIndex + &quot; update: &quot; + val +
 258                                      &quot;, isStopped &quot; + anim.isStopped());
 259                         }
 260                         // Try to prevent it from continuing to run
 261                         animation.cancel();
 262                     } else {
 263                         mDragOutlineAlphas[thisIndex] = (Float) animation.getAnimatedValue();
 264                         CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 265                     }
 266                 }
 267             });
 268             // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 269             // running. This way the bitmap can be GCed when the animations are complete.
 270             anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 271                 @Override
 272                 public void onAnimationEnd(Animator animation) {
 273                     if ((Float) ((ValueAnimator) animation).getAnimatedValue() == 0f) {
 274                         anim.setTag(null);
 275                     }
 276                 }
 277             });
 278             mDragOutlineAnims[i] = anim;
 279         }
 280 
 281         mBackgroundRect = new Rect();
 282         mForegroundRect = new Rect();
 283 
 284         mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);
 285         mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 286         addView(mShortcutsAndWidgets);
 287     }
 288 
 289     static int widthInPortrait(Resources r, int numCells) {
 290         // We use this method from Workspace to figure out how many rows/columns Launcher should
 291         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 292         // the padding extends outside the visible screen size, but it looked fine anyway.
 293         int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 294         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 295                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 296 
 297         return  minGap * (numCells - 1) + cellWidth * numCells;
 298     }
 299 
 300     static int heightInLandscape(Resources r, int numCells) {
 301         // We use this method from Workspace to figure out how many rows/columns Launcher should
 302         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 303         // the padding extends outside the visible screen size, but it looked fine anyway.
 304         int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 305         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 306                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 307 
 308         return minGap * (numCells - 1) + cellHeight * numCells;
 309     }
 310 
 311     public void enableHardwareLayers() {
 312         mShortcutsAndWidgets.enableHardwareLayers();
 313     }
 314 
 315     public void setGridSize(int x, int y) {
 316         mCountX = x;
 317         mCountY = y;
 318         mOccupied = new boolean[mCountX][mCountY];
 319         mTmpOccupied = new boolean[mCountX][mCountY];
 320         requestLayout();
 321     }
 322 
 323     private void invalidateBubbleTextView(BubbleTextView icon) {
 324         final int padding = icon.getPressedOrFocusedBackgroundPadding();
 325         invalidate(icon.getLeft() + getPaddingLeft() - padding,
 326                 icon.getTop() + getPaddingTop() - padding,
 327                 icon.getRight() + getPaddingLeft() + padding,
 328                 icon.getBottom() + getPaddingTop() + padding);
 329     }
 330 
 331     void setOverScrollAmount(float r, boolean left) {
 332         if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 333             mOverScrollForegroundDrawable = mOverScrollLeft;
 334         } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 335             mOverScrollForegroundDrawable = mOverScrollRight;
 336         }
 337 
 338         mForegroundAlpha = (int) Math.round((r * 255));
 339         mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 340         invalidate();
 341     }
 342 
 343     void setPressedOrFocusedIcon(BubbleTextView icon) {
 344         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 345         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 346         BubbleTextView oldIcon = mPressedOrFocusedIcon;
 347         mPressedOrFocusedIcon = icon;
 348         if (oldIcon != null) {
 349             invalidateBubbleTextView(oldIcon);
 350         }
 351         if (mPressedOrFocusedIcon != null) {
 352             invalidateBubbleTextView(mPressedOrFocusedIcon);
 353         }
 354     }
 355 
 356     void setIsDragOverlapping(boolean isDragOverlapping) {
 357         if (mIsDragOverlapping != isDragOverlapping) {
 358             mIsDragOverlapping = isDragOverlapping;
 359             invalidate();
 360         }
 361     }
 362 
 363     boolean getIsDragOverlapping() {
 364         return mIsDragOverlapping;
 365     }
 366 
 367     protected void setOverscrollTransformsDirty(boolean dirty) {
 368         mScrollingTransformsDirty = dirty;
 369     }
 370 
 371     protected void resetOverscrollTransforms() {
 372         if (mScrollingTransformsDirty) {
 373             setOverscrollTransformsDirty(false);
 374             setTranslationX(0);
 375             setRotationY(0);
 376             // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 377             // pass 0, which results in the overscroll drawable not being drawn any more.
 378             setOverScrollAmount(0, false);
 379             setPivotX(getMeasuredWidth() / 2);
 380             setPivotY(getMeasuredHeight() / 2);
 381         }
 382     }
 383 
 384     @Override
 385     protected void onDraw(Canvas canvas) {
 386         // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 387         // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 388         // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 389         // a drag). However, we also drag the mini hover background *over* one of those two
 390         // backgrounds
 391         if (mBackgroundAlpha &gt; 0.0f) {
 392             Drawable bg;
 393 
 394             if (mIsDragOverlapping) {
 395                 // In the mini case, we draw the active_glow bg *over* the active background
 396                 bg = mActiveGlowBackground;
 397             } else {
 398                 bg = mNormalBackground;
 399             }
 400 
 401             bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 402             bg.setBounds(mBackgroundRect);
 403             bg.draw(canvas);
 404         }
 405 
 406         if (mCrosshairsVisibility &gt; 0.0f) {
 407             final int countX = mCountX;
 408             final int countY = mCountY;
 409 
 410             final float MAX_ALPHA = 0.4f;
 411             final int MAX_VISIBLE_DISTANCE = 600;
 412             final float DISTANCE_MULTIPLIER = 0.002f;
 413 
 414             final Drawable d = mCrosshairsDrawable;
 415             final int width = d.getIntrinsicWidth();
 416             final int height = d.getIntrinsicHeight();
 417 
 418             int x = getPaddingLeft() - (mWidthGap / 2) - (width / 2);
 419             for (int col = 0; col &lt;= countX; col++) {
 420                 int y = getPaddingTop() - (mHeightGap / 2) - (height / 2);
 421                 for (int row = 0; row &lt;= countY; row++) {
 422                     mTmpPointF.set(x - mDragCenter.x, y - mDragCenter.y);
 423                     float dist = mTmpPointF.length();
 424                     // Crosshairs further from the drag point are more faint
 425                     float alpha = Math.min(MAX_ALPHA,
 426                             DISTANCE_MULTIPLIER * (MAX_VISIBLE_DISTANCE - dist));
 427                     if (alpha &gt; 0.0f) {
 428                         d.setBounds(x, y, x + width, y + height);
 429                         d.setAlpha((int) (alpha * 255 * mCrosshairsVisibility));
 430                         d.draw(canvas);
 431                     }
 432                     y += mCellHeight + mHeightGap;
 433                 }
 434                 x += mCellWidth + mWidthGap;
 435             }
 436         }
 437 
 438         final Paint paint = mDragOutlinePaint;
 439         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 440             final float alpha = mDragOutlineAlphas[i];
 441             if (alpha &gt; 0) {
 442                 final Rect r = mDragOutlines[i];
 443                 final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 444                 paint.setAlpha((int)(alpha + .5f));
 445                 canvas.drawBitmap(b, null, r, paint);
 446             }
 447         }
 448 
 449         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 450         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 451         if (mPressedOrFocusedIcon != null) {
 452             final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 453             final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 454             if (b != null) {
 455                 canvas.drawBitmap(b,
 456                         mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 457                         mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 458                         null);
 459             }
 460         }
 461 
 462         if (DEBUG_VISUALIZE_OCCUPIED) {
 463             int[] pt = new int[2];
 464             ColorDrawable cd = new ColorDrawable(Color.RED);
 465             cd.setBounds(0, 0, 80, 80);
 466             for (int i = 0; i &lt; mCountX; i++) {
 467                 for (int j = 0; j &lt; mCountY; j++) {
 468                     if (mOccupied[i][j]) {
 469                         cellToPoint(i, j, pt);
 470                         canvas.save();
 471                         canvas.translate(pt[0], pt[1]);
 472                         cd.draw(canvas);
 473                         canvas.restore();
 474                     }
 475                 }
 476             }
 477         }
 478 
 479         // The folder outer / inner ring image(s)
 480         for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 481             FolderRingAnimator fra = mFolderOuterRings.get(i);
 482 
 483             // Draw outer ring
 484             Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 485             int width = (int) fra.getOuterRingSize();
 486             int height = width;
 487             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 488 
 489             int centerX = mTempLocation[0] + mCellWidth / 2;
 490             int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 491 
 492             canvas.save();
 493             canvas.translate(centerX - width / 2, centerY - height / 2);
 494             d.setBounds(0, 0, width, height);
 495             d.draw(canvas);
 496             canvas.restore();
 497 
 498             // Draw inner ring
 499             d = FolderRingAnimator.sSharedInnerRingDrawable;
 500             width = (int) fra.getInnerRingSize();
 501             height = width;
 502             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 503 
 504             centerX = mTempLocation[0] + mCellWidth / 2;
 505             centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 506             canvas.save();
 507             canvas.translate(centerX - width / 2, centerY - width / 2);
 508             d.setBounds(0, 0, width, height);
 509             d.draw(canvas);
 510             canvas.restore();
 511         }
 512 
 513         if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 514             Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 515             int width = d.getIntrinsicWidth();
 516             int height = d.getIntrinsicHeight();
 517 
 518             cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 519             int centerX = mTempLocation[0] + mCellWidth / 2;
 520             int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 521 
 522             canvas.save();
 523             canvas.translate(centerX - width / 2, centerY - width / 2);
 524             d.setBounds(0, 0, width, height);
 525             d.draw(canvas);
 526             canvas.restore();
 527         }
 528     }
 529 
 530     @Override
 531     protected void dispatchDraw(Canvas canvas) {
 532         super.dispatchDraw(canvas);
 533         if (mForegroundAlpha &gt; 0) {
 534             mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 535             Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 536             p.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));
 537             mOverScrollForegroundDrawable.draw(canvas);
 538             p.setXfermode(null);
 539         }
 540     }
 541 
 542     public void showFolderAccept(FolderRingAnimator fra) {
 543         mFolderOuterRings.add(fra);
 544     }
 545 
 546     public void hideFolderAccept(FolderRingAnimator fra) {
 547         if (mFolderOuterRings.contains(fra)) {
 548             mFolderOuterRings.remove(fra);
 549         }
 550         invalidate();
 551     }
 552 
 553     public void setFolderLeaveBehindCell(int x, int y) {
 554         mFolderLeaveBehindCell[0] = x;
 555         mFolderLeaveBehindCell[1] = y;
 556         invalidate();
 557     }
 558 
 559     public void clearFolderLeaveBehind() {
 560         mFolderLeaveBehindCell[0] = -1;
 561         mFolderLeaveBehindCell[1] = -1;
 562         invalidate();
 563     }
 564 
 565     @Override
 566     public boolean shouldDelayChildPressedState() {
 567         return false;
 568     }
 569 
 570     @Override
 571     public void cancelLongPress() {
 572         super.cancelLongPress();
 573 
 574         // Cancel long press for all children
 575         final int count = getChildCount();
 576         for (int i = 0; i &lt; count; i++) {
 577             final View child = getChildAt(i);
 578             child.cancelLongPress();
 579         }
 580     }
 581 
 582     public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 583         mInterceptTouchListener = listener;
 584     }
 585 
 586     int getCountX() {
 587         return mCountX;
 588     }
 589 
 590     int getCountY() {
 591         return mCountY;
 592     }
 593 
 594     public void setIsHotseat(boolean isHotseat) {
 595         mIsHotseat = isHotseat;
 596     }
 597 
 598     public float getChildrenScale() {
 599         return mIsHotseat ? mHotseatChildScale : mChildScale;
 600     }
 601 
 602     public boolean addViewToCellLayout(
 603             View child, int index, int childId, LayoutParams params, boolean markCells) {
 604         return addViewToCellLayout(child, index, childId, params, markCells, false);
 605     }
 606 
 607     private void scaleChild(BubbleTextView bubbleChild, float pivot, float scale) {
 608         // If we haven&#x27;t measured the child yet, do it now
 609         // (this happens if we&#x27;re being dropped from all-apps
 610         if (bubbleChild.getLayoutParams() instanceof LayoutParams &amp;&amp;
 611                 (bubbleChild.getMeasuredWidth() | bubbleChild.getMeasuredHeight()) == 0) {
 612             getShortcutsAndWidgets().measureChild(bubbleChild);
 613         }
 614         int measuredWidth = bubbleChild.getMeasuredWidth();
 615         int measuredHeight = bubbleChild.getMeasuredHeight();
 616 
 617         bubbleChild.setScaleX(scale);
 618         bubbleChild.setScaleY(scale);
 619     }
 620 
 621     private void resetChild(BubbleTextView bubbleChild) {
 622         bubbleChild.setScaleX(1f);
 623         bubbleChild.setScaleY(1f);
 624 
 625         bubbleChild.setTextColor(getResources().getColor(R.color.workspace_icon_text_color));
 626     }
 627 
 628     public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 629             boolean markCells, boolean allApps) {
 630         final LayoutParams lp = params;
 631 
 632         // Hotseat icons - scale down and remove text
 633         // Don&#x27;t scale the all apps button
 634         // scale percent set to -1 means do not scale
 635         // Only scale BubbleTextViews
 636         if (child instanceof BubbleTextView) {
 637             BubbleTextView bubbleChild = (BubbleTextView) child;
 638 
 639             // Start the child with 100% scale and visible text
 640             resetChild(bubbleChild);
 641 
 642             if (mIsHotseat &amp;&amp; !allApps &amp;&amp; mHotseatChildScale &gt;= 0) {
 643                 // Scale/make transparent for a hotseat
 644                 scaleChild(bubbleChild, 0f, mHotseatChildScale);
 645 
 646                 bubbleChild.setTextColor(getResources().getColor(android.R.color.transparent));
 647             } else if (mChildScale &gt;= 0) {
 648                 // Else possibly still scale it if we need to for smaller icons
 649                 scaleChild(bubbleChild, 0f, mChildScale);
 650             }
 651         }
 652 
 653         // Generate an id for each view, this assumes we have at most 256x256 cells
 654         // per workspace screen
 655         if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 656             // If the horizontal or vertical span is set to -1, it is taken to
 657             // mean that it spans the extent of the CellLayout
 658             if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 659             if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 660 
 661             child.setId(childId);
 662 
 663             mShortcutsAndWidgets.addView(child, index, lp);
 664 
 665             if (markCells) markCellsAsOccupiedForView(child);
 666 
 667             return true;
 668         }
 669         return false;
 670     }
 671 
 672     @Override
 673     public void removeAllViews() {
 674         clearOccupiedCells();
 675         mShortcutsAndWidgets.removeAllViews();
 676     }
 677 
 678     @Override
 679     public void removeAllViewsInLayout() {
 680         if (mShortcutsAndWidgets.getChildCount() &gt; 0) {
 681             clearOccupiedCells();
 682             mShortcutsAndWidgets.removeAllViewsInLayout();
 683         }
 684     }
 685 
 686     public void removeViewWithoutMarkingCells(View view) {
 687         mShortcutsAndWidgets.removeView(view);
 688     }
 689 
 690     @Override
 691     public void removeView(View view) {
 692         markCellsAsUnoccupiedForView(view);
 693         mShortcutsAndWidgets.removeView(view);
 694     }
 695 
 696     @Override
 697     public void removeViewAt(int index) {
 698         markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
 699         mShortcutsAndWidgets.removeViewAt(index);
 700     }
 701 
 702     @Override
 703     public void removeViewInLayout(View view) {
 704         markCellsAsUnoccupiedForView(view);
 705         mShortcutsAndWidgets.removeViewInLayout(view);
 706     }
 707 
 708     @Override
 709     public void removeViews(int start, int count) {
 710         for (int i = start; i &lt; start + count; i++) {
 711             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 712         }
 713         mShortcutsAndWidgets.removeViews(start, count);
 714     }
 715 
 716     @Override
 717     public void removeViewsInLayout(int start, int count) {
 718         for (int i = start; i &lt; start + count; i++) {
 719             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 720         }
 721         mShortcutsAndWidgets.removeViewsInLayout(start, count);
 722     }
 723 
 724     @Override
 725     protected void onAttachedToWindow() {
 726         super.onAttachedToWindow();
 727         mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 728     }
 729 
 730     public void setTagToCellInfoForPoint(int touchX, int touchY) {
 731         final CellInfo cellInfo = mCellInfo;
 732         Rect frame = mRect;
 733         final int x = touchX + mScrollX;
 734         final int y = touchY + mScrollY;
 735         final int count = mShortcutsAndWidgets.getChildCount();
 736 
 737         boolean found = false;
 738         for (int i = count - 1; i &gt;= 0; i--) {
 739             final View child = mShortcutsAndWidgets.getChildAt(i);
 740             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 741 
 742             if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 743                     lp.isLockedToGrid) {
 744                 child.getHitRect(frame);
 745 
 746                 float scale = child.getScaleX();
 747                 frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 748                         child.getBottom());
 749                 // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 750                 // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 751                 // to this view.
 752                 frame.offset(mPaddingLeft, mPaddingTop);
 753                 frame.inset((int) (frame.width() * (1f - scale) / 2),
 754                         (int) (frame.height() * (1f - scale) / 2));
 755 
 756                 if (frame.contains(x, y)) {
 757                     cellInfo.cell = child;
 758                     cellInfo.cellX = lp.cellX;
 759                     cellInfo.cellY = lp.cellY;
 760                     cellInfo.spanX = lp.cellHSpan;
 761                     cellInfo.spanY = lp.cellVSpan;
 762                     found = true;
 763                     break;
 764                 }
 765             }
 766         }
 767 
 768         mLastDownOnOccupiedCell = found;
 769 
 770         if (!found) {
 771             final int cellXY[] = mTmpXY;
 772             pointToCellExact(x, y, cellXY);
 773 
 774             cellInfo.cell = null;
 775             cellInfo.cellX = cellXY[0];
 776             cellInfo.cellY = cellXY[1];
 777             cellInfo.spanX = 1;
 778             cellInfo.spanY = 1;
 779         }
 780         setTag(cellInfo);
 781     }
 782 
 783     @Override
 784     public boolean onInterceptTouchEvent(MotionEvent ev) {
 785         // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 786         // even in the case where we return early. Not clearing here was causing bugs whereby on
 787         // long-press we&#x27;d end up picking up an item from a previous drag operation.
 788         final int action = ev.getAction();
 789 
 790         if (action == MotionEvent.ACTION_DOWN) {
 791             clearTagCellInfo();
 792         }
 793 
 794         if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 795             return true;
 796         }
 797 
 798         if (action == MotionEvent.ACTION_DOWN) {
 799             setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 800         }
 801 
 802         return false;
 803     }
 804 
 805     private void clearTagCellInfo() {
 806         final CellInfo cellInfo = mCellInfo;
 807         cellInfo.cell = null;
 808         cellInfo.cellX = -1;
 809         cellInfo.cellY = -1;
 810         cellInfo.spanX = 0;
 811         cellInfo.spanY = 0;
 812         setTag(cellInfo);
 813     }
 814 
 815     public CellInfo getTag() {
 816         return (CellInfo) super.getTag();
 817     }
 818 
 819     /**
 820      * Given a point, return the cell that strictly encloses that point
 821      * @param x X coordinate of the point
 822      * @param y Y coordinate of the point
 823      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 824      */
 825     void pointToCellExact(int x, int y, int[] result) {
 826         final int hStartPadding = getPaddingLeft();
 827         final int vStartPadding = getPaddingTop();
 828 
 829         result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 830         result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 831 
 832         final int xAxis = mCountX;
 833         final int yAxis = mCountY;
 834 
 835         if (result[0] &lt; 0) result[0] = 0;
 836         if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 837         if (result[1] &lt; 0) result[1] = 0;
 838         if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 839     }
 840 
 841     /**
 842      * Given a point, return the cell that most closely encloses that point
 843      * @param x X coordinate of the point
 844      * @param y Y coordinate of the point
 845      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 846      */
 847     void pointToCellRounded(int x, int y, int[] result) {
 848         pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 849     }
 850 
 851     /**
 852      * Given a cell coordinate, return the point that represents the upper left corner of that cell
 853      *
 854      * @param cellX X coordinate of the cell
 855      * @param cellY Y coordinate of the cell
 856      *
 857      * @param result Array of 2 ints to hold the x and y coordinate of the point
 858      */
 859     void cellToPoint(int cellX, int cellY, int[] result) {
 860         final int hStartPadding = getPaddingLeft();
 861         final int vStartPadding = getPaddingTop();
 862 
 863         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 864         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 865     }
 866 
 867     /**
 868      * Given a cell coordinate, return the point that represents the center of the cell
 869      *
 870      * @param cellX X coordinate of the cell
 871      * @param cellY Y coordinate of the cell
 872      *
 873      * @param result Array of 2 ints to hold the x and y coordinate of the point
 874      */
 875     void cellToCenterPoint(int cellX, int cellY, int[] result) {
 876         final int hStartPadding = getPaddingLeft();
 877         final int vStartPadding = getPaddingTop();
 878 
 879         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) + mCellWidth / 2;
 880         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) + mCellHeight / 2;
 881     }
 882 
 883     public float getDistanceFromCell(float x, float y, int[] cell) {
 884         cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 885         float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 886                 Math.pow(y - mTmpPoint[1], 2));
 887         return distance;
 888     }
 889 
 890     int getCellWidth() {
 891         return mCellWidth;
 892     }
 893 
 894     int getCellHeight() {
 895         return mCellHeight;
 896     }
 897 
 898     int getWidthGap() {
 899         return mWidthGap;
 900     }
 901 
 902     int getHeightGap() {
 903         return mHeightGap;
 904     }
 905 
 906     Rect getContentRect(Rect r) {
 907         if (r == null) {
 908             r = new Rect();
 909         }
 910         int left = getPaddingLeft();
 911         int top = getPaddingTop();
 912         int right = left + getWidth() - mPaddingLeft - mPaddingRight;
 913         int bottom = top + getHeight() - mPaddingTop - mPaddingBottom;
 914         r.set(left, top, right, bottom);
 915         return r;
 916     }
 917 
 918     @Override
 919     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 920         // TODO: currently ignoring padding
 921 
 922         int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 923         int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 924 
 925         int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 926         int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 927 
 928         if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 929             throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 930         }
 931 
 932         int numWidthGaps = mCountX - 1;
 933         int numHeightGaps = mCountY - 1;
 934 
 935         if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 936             int hSpace = widthSpecSize - mPaddingLeft - mPaddingRight;
 937             int vSpace = heightSpecSize - mPaddingTop - mPaddingBottom;
 938             int hFreeSpace = hSpace - (mCountX * mOriginalCellWidth);
 939             int vFreeSpace = vSpace - (mCountY * mOriginalCellHeight);
 940             mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 941             mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 942             mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 943         } else {
 944             mWidthGap = mOriginalWidthGap;
 945             mHeightGap = mOriginalHeightGap;
 946         }
 947 
 948         // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 949         int newWidth = widthSpecSize;
 950         int newHeight = heightSpecSize;
 951         if (widthSpecMode == MeasureSpec.AT_MOST) {
 952             newWidth = mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
 953                 ((mCountX - 1) * mWidthGap);
 954             newHeight = mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
 955                 ((mCountY - 1) * mHeightGap);
 956             setMeasuredDimension(newWidth, newHeight);
 957         }
 958 
 959         int count = getChildCount();
 960         for (int i = 0; i &lt; count; i++) {
 961             View child = getChildAt(i);
 962             int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - mPaddingLeft -
 963                     mPaddingRight, MeasureSpec.EXACTLY);
 964             int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - mPaddingTop -
 965                     mPaddingBottom, MeasureSpec.EXACTLY);
 966             child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 967         }
 968         setMeasuredDimension(newWidth, newHeight);
 969     }
 970 
 971     @Override
 972     protected void onLayout(boolean changed, int l, int t, int r, int b) {
 973         int count = getChildCount();
 974         for (int i = 0; i &lt; count; i++) {
 975             View child = getChildAt(i);
 976             child.layout(mPaddingLeft, mPaddingTop,
 977                     r - l - mPaddingRight, b - t - mPaddingBottom);
 978         }
 979     }
 980 
 981     @Override
 982     protected void onSizeChanged(int w, int h, int oldw, int oldh) {
 983         super.onSizeChanged(w, h, oldw, oldh);
 984         mBackgroundRect.set(0, 0, w, h);
 985         mForegroundRect.set(mForegroundPadding, mForegroundPadding,
 986                 w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
 987     }
 988 
 989     @Override
 990     protected void setChildrenDrawingCacheEnabled(boolean enabled) {
 991         mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
 992     }
 993 
 994     @Override
 995     protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
 996         mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
 997     }
 998 
 999     public float getBackgroundAlpha() {
1000         return mBackgroundAlpha;
1001     }
1002 
1003     public void setBackgroundAlphaMultiplier(float multiplier) {
1004         mBackgroundAlphaMultiplier = multiplier;
1005     }
1006 
1007     public float getBackgroundAlphaMultiplier() {
1008         return mBackgroundAlphaMultiplier;
1009     }
1010 
1011     public void setBackgroundAlpha(float alpha) {
1012         if (mBackgroundAlpha != alpha) {
1013             mBackgroundAlpha = alpha;
1014             invalidate();
1015         }
1016     }
1017 
1018     public void setShortcutAndWidgetAlpha(float alpha) {
1019         final int childCount = getChildCount();
1020         for (int i = 0; i &lt; childCount; i++) {
1021             getChildAt(i).setAlpha(alpha);
1022         }
1023     }
1024 
1025     public ShortcutAndWidgetContainer getShortcutsAndWidgets() {
1026         if (getChildCount() &gt; 0) {
1027             return (ShortcutAndWidgetContainer) getChildAt(0);
1028         }
1029         return null;
1030     }
1031 
1032     public View getChildAt(int x, int y) {
1033         return mShortcutsAndWidgets.getChildAt(x, y);
1034     }
1035 
1036     public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration,
1037             int delay, boolean permanent, boolean adjustOccupied) {
1038         ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();
1039         boolean[][] occupied = mOccupied;
1040         if (!permanent) {
1041             occupied = mTmpOccupied;
1042         }
1043 
1044         if (clc.indexOfChild(child) != -1 &amp;&amp; !occupied[cellX][cellY]) {
1045             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
1046             final ItemInfo info = (ItemInfo) child.getTag();
1047 
1048             // We cancel any existing animations
1049             if (mReorderAnimators.containsKey(lp)) {
1050                 mReorderAnimators.get(lp).cancel();
1051                 mReorderAnimators.remove(lp);
1052             }
1053 
1054             final int oldX = lp.x;
1055             final int oldY = lp.y;
1056             if (adjustOccupied) {
1057                 occupied[lp.cellX][lp.cellY] = false;
1058                 occupied[cellX][cellY] = true;
1059             }
1060             lp.isLockedToGrid = true;
1061             if (permanent) {
1062                 lp.cellX = info.cellX = cellX;
1063                 lp.cellY = info.cellY = cellY;
1064             } else {
1065                 lp.tmpCellX = cellX;
1066                 lp.tmpCellY = cellY;
1067             }
1068             clc.setupLp(lp);
1069             lp.isLockedToGrid = false;
1070             final int newX = lp.x;
1071             final int newY = lp.y;
1072 
1073             lp.x = oldX;
1074             lp.y = oldY;
1075 
1076             // Exit early if we&#x27;re not actually moving the view
1077             if (oldX == newX &amp;&amp; oldY == newY) {
1078                 lp.isLockedToGrid = true;
1079                 return true;
1080             }
1081 
1082             ValueAnimator va = ValueAnimator.ofFloat(0f, 1f);
1083             va.setDuration(duration);
1084             mReorderAnimators.put(lp, va);
1085 
1086             va.addUpdateListener(new AnimatorUpdateListener() {
1087                 @Override
1088                 public void onAnimationUpdate(ValueAnimator animation) {
1089                     float r = ((Float) animation.getAnimatedValue()).floatValue();
1090                     child.setTranslationX(r * (newX - oldX));
1091                     child.setTranslationY(r * (newY - oldY));
1092                 }
1093             });
1094             va.addListener(new AnimatorListenerAdapter() {
1095                 boolean cancelled = false;
1096                 public void onAnimationEnd(Animator animation) {
1097                     // If the animation was cancelled, it means that another animation
1098                     // has interrupted this one, and we don&#x27;t want to lock the item into
1099                     // place just yet.
1100                     if (!cancelled) {
1101                         child.setTranslationX(0);
1102                         child.setTranslationY(0);
1103                         lp.isLockedToGrid = true;
1104                         child.requestLayout();
1105                     }
1106                     if (mReorderAnimators.containsKey(lp)) {
1107                         mReorderAnimators.remove(lp);
1108                     }
1109                 }
1110                 public void onAnimationCancel(Animator animation) {
1111                     cancelled = true;
1112                 }
1113             });
1114             va.setStartDelay(delay);
1115             va.start();
1116             return true;
1117         }
1118         return false;
1119     }
1120 
1121     /**
1122      * Estimate where the top left cell of the dragged item will land if it is dropped.
1123      *
1124      * @param originX The X value of the top left corner of the item
1125      * @param originY The Y value of the top left corner of the item
1126      * @param spanX The number of horizontal cells that the item spans
1127      * @param spanY The number of vertical cells that the item spans
1128      * @param result The estimated drop cell X and Y.
1129      */
1130     void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1131         final int countX = mCountX;
1132         final int countY = mCountY;
1133 
1134         // pointToCellRounded takes the top left of a cell but will pad that with
1135         // cellWidth/2 and cellHeight/2 when finding the matching cell
1136         pointToCellRounded(originX, originY, result);
1137 
1138         // If the item isn&#x27;t fully on this screen, snap to the edges
1139         int rightOverhang = result[0] + spanX - countX;
1140         if (rightOverhang &gt; 0) {
1141             result[0] -= rightOverhang; // Snap to right
1142         }
1143         result[0] = Math.max(0, result[0]); // Snap to left
1144         int bottomOverhang = result[1] + spanY - countY;
1145         if (bottomOverhang &gt; 0) {
1146             result[1] -= bottomOverhang; // Snap to bottom
1147         }
1148         result[1] = Math.max(0, result[1]); // Snap to top
1149     }
1150 
1151     void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1152             int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1153         final int oldDragCellX = mDragCell[0];
1154         final int oldDragCellY = mDragCell[1];
1155 
1156         if (v != null &amp;&amp; dragOffset == null) {
1157             mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1158         } else {
1159             mDragCenter.set(originX, originY);
1160         }
1161 
1162         if (dragOutline == null &amp;&amp; v == null) {
1163             if (mCrosshairsDrawable != null) {
1164                 invalidate();
1165             }
1166             return;
1167         }
1168 
1169         if (cellX != oldDragCellX || cellY != oldDragCellY) {
1170             mDragCell[0] = cellX;
1171             mDragCell[1] = cellY;
1172             // Find the top left corner of the rect the object will occupy
1173             final int[] topLeft = mTmpPoint;
1174             cellToPoint(cellX, cellY, topLeft);
1175 
1176             int left = topLeft[0];
1177             int top = topLeft[1];
1178 
1179             if (v != null &amp;&amp; dragOffset == null) {
1180                 // When drawing the drag outline, it did not account for margin offsets
1181                 // added by the view&#x27;s parent.
1182                 MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1183                 left += lp.leftMargin;
1184                 top += lp.topMargin;
1185 
1186                 // Offsets due to the size difference between the View and the dragOutline.
1187                 // There is a size difference to account for the outer blur, which may lie
1188                 // outside the bounds of the view.
1189                 top += (v.getHeight() - dragOutline.getHeight()) / 2;
1190                 // We center about the x axis
1191                 left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1192                         - dragOutline.getWidth()) / 2;
1193             } else {
1194                 if (dragOffset != null &amp;&amp; dragRegion != null) {
1195                     // Center the drag region *horizontally* in the cell and apply a drag
1196                     // outline offset
1197                     left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1198                              - dragRegion.width()) / 2;
1199                     top += dragOffset.y;
1200                 } else {
1201                     // Center the drag outline in the cell
1202                     left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1203                             - dragOutline.getWidth()) / 2;
1204                     top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1205                             - dragOutline.getHeight()) / 2;
1206                 }
1207             }
1208             final int oldIndex = mDragOutlineCurrent;
1209             mDragOutlineAnims[oldIndex].animateOut();
1210             mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1211             Rect r = mDragOutlines[mDragOutlineCurrent];
1212             r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1213             if (resize) {
1214                 cellToRect(cellX, cellY, spanX, spanY, r);
1215             }
1216 
1217             mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1218             mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1219         }
1220 
1221         // If we are drawing crosshairs, the entire CellLayout needs to be invalidated
1222         if (mCrosshairsDrawable != null) {
1223             invalidate();
1224         }
1225     }
1226 
1227     public void clearDragOutlines() {
1228         final int oldIndex = mDragOutlineCurrent;
1229         mDragOutlineAnims[oldIndex].animateOut();
1230         mDragCell[0] = mDragCell[1] = -1;
1231     }
1232 
1233     /**
1234      * Find a vacant area that will fit the given bounds nearest the requested
1235      * cell location. Uses Euclidean distance to score multiple vacant areas.
1236      *
1237      * @param pixelX The X location at which you want to search for a vacant area.
1238      * @param pixelY The Y location at which you want to search for a vacant area.
1239      * @param spanX Horizontal span of the object.
1240      * @param spanY Vertical span of the object.
1241      * @param result Array in which to place the result, or null (in which case a new array will
1242      *        be allocated)
1243      * @return The X, Y cell of a vacant area that can contain this object,
1244      *         nearest the requested location.
1245      */
1246     int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1247             int[] result) {
1248         return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1249     }
1250 
1251     /**
1252      * Find a vacant area that will fit the given bounds nearest the requested
1253      * cell location. Uses Euclidean distance to score multiple vacant areas.
1254      *
1255      * @param pixelX The X location at which you want to search for a vacant area.
1256      * @param pixelY The Y location at which you want to search for a vacant area.
1257      * @param minSpanX The minimum horizontal span required
1258      * @param minSpanY The minimum vertical span required
1259      * @param spanX Horizontal span of the object.
1260      * @param spanY Vertical span of the object.
1261      * @param result Array in which to place the result, or null (in which case a new array will
1262      *        be allocated)
1263      * @return The X, Y cell of a vacant area that can contain this object,
1264      *         nearest the requested location.
1265      */
1266     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1267             int spanY, int[] result, int[] resultSpan) {
1268         return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1269                 result, resultSpan);
1270     }
1271 
1272     /**
1273      * Find a vacant area that will fit the given bounds nearest the requested
1274      * cell location. Uses Euclidean distance to score multiple vacant areas.
1275      *
1276      * @param pixelX The X location at which you want to search for a vacant area.
1277      * @param pixelY The Y location at which you want to search for a vacant area.
1278      * @param spanX Horizontal span of the object.
1279      * @param spanY Vertical span of the object.
1280      * @param ignoreOccupied If true, the result can be an occupied cell
1281      * @param result Array in which to place the result, or null (in which case a new array will
1282      *        be allocated)
1283      * @return The X, Y cell of a vacant area that can contain this object,
1284      *         nearest the requested location.
1285      */
1286     int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1287             boolean ignoreOccupied, int[] result) {
1288         return findNearestArea(pixelX, pixelY, spanX, spanY,
1289                 spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1290     }
1291 
1292     private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1293     private void lazyInitTempRectStack() {
1294         if (mTempRectStack.isEmpty()) {
1295             for (int i = 0; i &lt; mCountX * mCountY; i++) {
1296                 mTempRectStack.push(new Rect());
1297             }
1298         }
1299     }
1300 
1301     private void recycleTempRects(Stack&lt;Rect&gt; used) {
1302         while (!used.isEmpty()) {
1303             mTempRectStack.push(used.pop());
1304         }
1305     }
1306 
1307     /**
1308      * Find a vacant area that will fit the given bounds nearest the requested
1309      * cell location. Uses Euclidean distance to score multiple vacant areas.
1310      *
1311      * @param pixelX The X location at which you want to search for a vacant area.
1312      * @param pixelY The Y location at which you want to search for a vacant area.
1313      * @param minSpanX The minimum horizontal span required
1314      * @param minSpanY The minimum vertical span required
1315      * @param spanX Horizontal span of the object.
1316      * @param spanY Vertical span of the object.
1317      * @param ignoreOccupied If true, the result can be an occupied cell
1318      * @param result Array in which to place the result, or null (in which case a new array will
1319      *        be allocated)
1320      * @return The X, Y cell of a vacant area that can contain this object,
1321      *         nearest the requested location.
1322      */
1323     int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1324             View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1325             boolean[][] occupied) {
1326         lazyInitTempRectStack();
1327         // mark space take by ignoreView as available (method checks if ignoreView is null)
1328         markCellsAsUnoccupiedForView(ignoreView, occupied);
1329 
1330         // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1331         // to the center of the item, but we are searching based on the top-left cell, so
1332         // we translate the point over to correspond to the top-left.
1333         pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1334         pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1335 
1336         // Keep track of best-scoring drop area
1337         final int[] bestXY = result != null ? result : new int[2];
1338         double bestDistance = Double.MAX_VALUE;
1339         final Rect bestRect = new Rect(-1, -1, -1, -1);
1340         final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1341 
1342         final int countX = mCountX;
1343         final int countY = mCountY;
1344 
1345         if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1346                 spanX &lt; minSpanX || spanY &lt; minSpanY) {
1347             return bestXY;
1348         }
1349 
1350         for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1351             inner:
1352             for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1353                 int ySize = -1;
1354                 int xSize = -1;
1355                 if (ignoreOccupied) {
1356                     // First, let&#x27;s see if this thing fits anywhere
1357                     for (int i = 0; i &lt; minSpanX; i++) {
1358                         for (int j = 0; j &lt; minSpanY; j++) {
1359                             if (occupied[x + i][y + j]) {
1360                                 continue inner;
1361                             }
1362                         }
1363                     }
1364                     xSize = minSpanX;
1365                     ySize = minSpanY;
1366 
1367                     // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1368                     // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1369                     // until we hit a limit.
1370                     boolean incX = true;
1371                     boolean hitMaxX = xSize &gt;= spanX;
1372                     boolean hitMaxY = ySize &gt;= spanY;
1373                     while (!(hitMaxX &amp;&amp; hitMaxY)) {
1374                         if (incX &amp;&amp; !hitMaxX) {
1375                             for (int j = 0; j &lt; ySize; j++) {
1376                                 if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1377                                     // We can&#x27;t move out horizontally
1378                                     hitMaxX = true;
1379                                 }
1380                             }
1381                             if (!hitMaxX) {
1382                                 xSize++;
1383                             }
1384                         } else if (!hitMaxY) {
1385                             for (int i = 0; i &lt; xSize; i++) {
1386                                 if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1387                                     // We can&#x27;t move out vertically
1388                                     hitMaxY = true;
1389                                 }
1390                             }
1391                             if (!hitMaxY) {
1392                                 ySize++;
1393                             }
1394                         }
1395                         hitMaxX |= xSize &gt;= spanX;
1396                         hitMaxY |= ySize &gt;= spanY;
1397                         incX = !incX;
1398                     }
1399                     incX = true;
1400                     hitMaxX = xSize &gt;= spanX;
1401                     hitMaxY = ySize &gt;= spanY;
1402                 }
1403                 final int[] cellXY = mTmpXY;
1404                 cellToCenterPoint(x, y, cellXY);
1405 
1406                 // We verify that the current rect is not a sub-rect of any of our previous
1407                 // candidates. In this case, the current rect is disqualified in favour of the
1408                 // containing rect.
1409                 Rect currentRect = mTempRectStack.pop();
1410                 currentRect.set(x, y, x + xSize, y + ySize);
1411                 boolean contained = false;
1412                 for (Rect r : validRegions) {
1413                     if (r.contains(currentRect)) {
1414                         contained = true;
1415                         break;
1416                     }
1417                 }
1418                 validRegions.push(currentRect);
1419                 double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1420                         + Math.pow(cellXY[1] - pixelY, 2));
1421 
1422                 if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1423                         currentRect.contains(bestRect)) {
1424                     bestDistance = distance;
1425                     bestXY[0] = x;
1426                     bestXY[1] = y;
1427                     if (resultSpan != null) {
1428                         resultSpan[0] = xSize;
1429                         resultSpan[1] = ySize;
1430                     }
1431                     bestRect.set(currentRect);
1432                 }
1433             }
1434         }
1435         // re-mark space taken by ignoreView as occupied
1436         markCellsAsOccupiedForView(ignoreView, occupied);
1437 
1438         // Return -1, -1 if no suitable location found
1439         if (bestDistance == Double.MAX_VALUE) {
1440             bestXY[0] = -1;
1441             bestXY[1] = -1;
1442         }
1443         recycleTempRects(validRegions);
1444         return bestXY;
1445     }
1446 
1447      /**
1448      * Find a vacant area that will fit the given bounds nearest the requested
1449      * cell location, and will also weigh in a suggested direction vector of the
1450      * desired location. This method computers distance based on unit grid distances,
1451      * not pixel distances.
1452      *
1453      * @param pixelX The X location at which you want to search for a vacant area.
1454      * @param pixelY The Y location at which you want to search for a vacant area.
1455      * @param minSpanX The minimum horizontal span required
1456      * @param minSpanY The minimum vertical span required
1457      * @param spanX Horizontal span of the object.
1458      * @param spanY Vertical span of the object.
1459      * @param ignoreOccupied If true, the result can be an occupied cell
1460      * @param result Array in which to place the result, or null (in which case a new array will
1461      *        be allocated)
1462      * @return The X, Y cell of a vacant area that can contain this object,
1463      *         nearest the requested location.
1464      */
1465     private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
1466             boolean[][] occupied, int[] result) {
1467         // Keep track of best-scoring drop area
1468         final int[] bestXY = result != null ? result : new int[2];
1469         float bestDistance = Float.MAX_VALUE;
1470         int bestDirectionScore = Integer.MIN_VALUE;
1471 
1472         final int countX = mCountX;
1473         final int countY = mCountY;
1474 
1475         for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1476             inner:
1477             for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1478                 // First, let&#x27;s see if this thing fits anywhere
1479                 for (int i = 0; i &lt; spanX; i++) {
1480                     for (int j = 0; j &lt; spanY; j++) {
1481                         if (occupied[x + i][y + j]) {
1482                             continue inner;
1483                         }
1484                     }
1485                 }
1486 
1487                 float distance = (float)
1488                         Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1489                 int[] curDirection = mTmpPoint;
1490                 computeDirectionVector(cellX, cellY, x, y, curDirection);
1491                 int curDirectionScore = direction[0] * curDirection[0] +
1492                         direction[1] * curDirection[1];
1493 
1494                 if (Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,
1495                         bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1496                     bestDistance = distance;
1497                     bestDirectionScore = curDirectionScore;
1498                     bestXY[0] = x;
1499                     bestXY[1] = y;
1500                 }
1501             }
1502         }
1503 
1504         // Return -1, -1 if no suitable location found
1505         if (bestDistance == Float.MAX_VALUE) {
1506             bestXY[0] = -1;
1507             bestXY[1] = -1;
1508         }
1509         return bestXY;
1510     }
1511 
1512     private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1513             int[] direction) {
1514         LayoutParams lp = (LayoutParams) v.getLayoutParams();
1515         boolean success = false;
1516         markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1517                 lp.cellVSpan, mTmpOccupied, false);
1518         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1519 
1520         findNearestArea(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,
1521                 direction, mTmpOccupied, mTempLocation);
1522 
1523         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1524             lp.tmpCellX = mTempLocation[0];
1525             lp.tmpCellY = mTempLocation[1];
1526             success = true;
1527 
1528         }
1529         markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1530                 lp.cellVSpan, mTmpOccupied, true);
1531         return success;
1532     }
1533 
1534 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1535     // This method looks in the specified direction to see if there is an additional view</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1536     // immediately adjecent in that direction</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1537     private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1538             boolean[][] occupied) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1539         boolean found = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1540 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1541         int childCount = mShortcutsAndWidgets.getChildCount();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1542         Rect r0 = new Rect(boundingRect);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1543         Rect r1 = new Rect();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1544 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1545         int deltaX = 0;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1546         int deltaY = 0;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1547         if (direction[1] &lt; 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1548             r0.set(r0.left, r0.top - 1, r0.right, r0.bottom);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1549             deltaY = -1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1550         } else if (direction[1] &gt; 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1551             r0.set(r0.left, r0.top, r0.right, r0.bottom + 1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1552             deltaY = 1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1553         } else if (direction[0] &lt; 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1554             r0.set(r0.left - 1, r0.top, r0.right, r0.bottom);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1555             deltaX = -1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1556         } else if (direction[0] &gt; 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1557             r0.set(r0.left, r0.top, r0.right + 1, r0.bottom);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1558             deltaX = 1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1559         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1560 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1561         for (int i = 0; i &lt; childCount; i++) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1562             View child = mShortcutsAndWidgets.getChildAt(i);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1563             if (views.contains(child)) continue;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1564             LayoutParams lp = (LayoutParams) child.getLayoutParams();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1565 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1566             r1.set(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1567             if (Rect.intersects(r0, r1)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1568                 if (!lp.canReorder) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1569                     return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1570                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1571                 boolean pushed = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1572                 for (int x = lp.tmpCellX; x &lt; lp.tmpCellX + lp.cellHSpan; x++) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1573                     for (int y = lp.tmpCellY; y &lt; lp.tmpCellY + lp.cellVSpan; y++) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1574                         boolean inBounds = x - deltaX &gt;= 0 &amp;&amp; x -deltaX &lt; mCountX</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1575                                 &amp;&amp; y - deltaY &gt;= 0 &amp;&amp; y - deltaY &lt; mCountY;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1576                         if (inBounds &amp;&amp; occupied[x - deltaX][y - deltaY]) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1577                             pushed = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1578                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1579                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1580                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1581                 if (pushed) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1582                     views.add(child);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1583                     boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1584                             lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1585                     found = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1586                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1587             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1588         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1589         return found;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1590     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1591 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1592     private boolean pushViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1593             int[] direction) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1594         if (views.size() == 0) return true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1595 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1596 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1597         boolean success = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1598 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1599         // We construct a rect which represents the entire group of views</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1600         Rect boundingRect = null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1601         for (View v: views) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1602             LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1603             if (boundingRect == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1604                 boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1605                         lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1606             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1607                 boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1608                         lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1609             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1610         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1611 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1612         ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) views.clone();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1613         while (addViewInDirection(dup, boundingRect, direction, mTmpOccupied)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1614         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1615         for (View v: dup) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1616             LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1617             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1618                     lp.cellVSpan, mTmpOccupied, false); </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1619         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1620 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1621         boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1622         int top = boundingRect.top;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1623         int left = boundingRect.left;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1624         for (View v: dup) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1625             LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1626             markCellsForView(lp.tmpCellX - left, lp.tmpCellY - top, lp.cellHSpan,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1627                     lp.cellVSpan, blockOccupied, true); </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1628         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1629 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1630         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1631 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1632         findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(),</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1633                 boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1634 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1635         int deltaX = mTempLocation[0] - boundingRect.left;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1636         int deltaY = mTempLocation[1] - boundingRect.top;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1637         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1638             for (View v: dup) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1639                 LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1640                 lp.tmpCellX += deltaX;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1641                 lp.tmpCellY += deltaY;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1642             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1643             success = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1644         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1645         for (View v: dup) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1646             LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1647             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1648                     lp.cellVSpan, mTmpOccupied, true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1649         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1650         return success;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1651     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1652 </span>
1653 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1654     private int[] findNearestAreaInDirection(int cellX, int cellY, int spanX, int spanY, </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1655             int[] direction,boolean[][] occupied,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1656             boolean blockOccupied[][], int[] result) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1657         // Keep track of best-scoring drop area</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1658         final int[] bestXY = result != null ? result : new int[2];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1659         bestXY[0] = -1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1660         bestXY[1] = -1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1661         float bestDistance = Float.MAX_VALUE;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1662 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1663         // We use this to march in a single direction</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1664         if (direction[0] != 0 &amp;&amp; direction[1] != 0) { </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1665             return bestXY;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1666         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1667 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1668         // This will only incrememnet one of x or y based on the assertion above</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1669         int x = cellX + direction[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1670         int y = cellY + direction[1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1671         while (x &gt;= 0 &amp;&amp; x + spanX &lt;= mCountX &amp;&amp; y &gt;= 0 &amp;&amp; y + spanY &lt;= mCountY) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1672 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1673             boolean fail = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1674             for (int i = 0; i &lt; spanX; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1675                 for (int j = 0; j &lt; spanY; j++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1676                     if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1677                         fail = true;                    </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1678                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1679                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1680             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1681             if (!fail) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1682                 float distance = (float)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1683                         Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1684                 if (Float.compare(distance,  bestDistance) &lt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1685                     bestDistance = distance;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1686                     bestXY[0] = x;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1687                     bestXY[1] = y;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1688                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1689             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1690             x += direction[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1691             y += direction[1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1692         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1693         return bestXY;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1694     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1695 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1696     private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1697             int[] direction) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1698         LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1699         boolean success = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1700         markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1701                 lp.cellVSpan, mTmpOccupied, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1702         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1703 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1704         findNearestArea(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1705                 direction, mTmpOccupied, null, mTempLocation);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1706 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1707         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1708             lp.tmpCellX = mTempLocation[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1709             lp.tmpCellY = mTempLocation[1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1710             success = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1711 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1712         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1713         markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1714                 lp.cellVSpan, mTmpOccupied, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1715         return success;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1716     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1717 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1718     // This method looks in the specified direction to see if there is an additional view</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1719     // immediately adjecent in that direction</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1720     private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1721             boolean[][] occupied) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1722         boolean found = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1723 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1724         int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1725         Rect r0 = new Rect(boundingRect);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1726         Rect r1 = new Rect();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1727 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1728         int deltaX = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1729         int deltaY = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1730         if (direction[1] &lt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1731             r0.set(r0.left, r0.top - 1, r0.right, r0.bottom);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1732             deltaY = -1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1733         } else if (direction[1] &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1734             r0.set(r0.left, r0.top, r0.right, r0.bottom + 1);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1735             deltaY = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1736         } else if (direction[0] &lt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1737             r0.set(r0.left - 1, r0.top, r0.right, r0.bottom);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1738             deltaX = -1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1739         } else if (direction[0] &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1740             r0.set(r0.left, r0.top, r0.right + 1, r0.bottom);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1741             deltaX = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1742         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1743 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1744         for (int i = 0; i &lt; childCount; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1745             View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1746             if (views.contains(child)) continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1747             LayoutParams lp = (LayoutParams) child.getLayoutParams();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1748 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1749             r1.set(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1750             if (Rect.intersects(r0, r1)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1751                 if (!lp.canReorder) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1752                     return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1753                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1754                 boolean pushed = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1755                 for (int x = lp.tmpCellX; x &lt; lp.tmpCellX + lp.cellHSpan; x++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1756                     for (int y = lp.tmpCellY; y &lt; lp.tmpCellY + lp.cellVSpan; y++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1757                         boolean inBounds = x - deltaX &gt;= 0 &amp;&amp; x -deltaX &lt; mCountX</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1758                                 &amp;&amp; y - deltaY &gt;= 0 &amp;&amp; y - deltaY &lt; mCountY;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1759                         if (inBounds &amp;&amp; occupied[x - deltaX][y - deltaY]) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1760                             pushed = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1761                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1762                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1763                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1764                 if (pushed) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1765                     views.add(child);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1766                     boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1767                             lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1768                     found = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1769                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1770             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1771         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1772         return found;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1773     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1774 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1775     private boolean pushViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1776             int[] direction) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1777         if (views.size() == 0) return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1778 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1779 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1780         boolean success = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1781 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1782         // We construct a rect which represents the entire group of views</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1783         Rect boundingRect = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1784         for (View v: views) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1785             LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1786             if (boundingRect == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1787                 boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1788                         lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1789             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1790                 boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1791                         lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1792             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1793         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1794 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1795         ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) views.clone();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1796         while (addViewInDirection(dup, boundingRect, direction, mTmpOccupied)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1797         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1798         for (View v: dup) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1799             LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1800             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1801                     lp.cellVSpan, mTmpOccupied, false); </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1802         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1803 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1804         boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1805         int top = boundingRect.top;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1806         int left = boundingRect.left;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1807         for (View v: dup) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1808             LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1809             markCellsForView(lp.tmpCellX - left, lp.tmpCellY - top, lp.cellHSpan,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1810                     lp.cellVSpan, blockOccupied, true); </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1811         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1812 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1813         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);</span>
1814 =======
1815 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1816     private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1817             int[] direction) {
1818         if (views.size() == 0) return true;
1819         boolean success = false;
1820 
1821         // We construct a rect which represents the entire group of views
1822         Rect boundingRect = null;
1823         for (View v: views) {
1824             LayoutParams lp = (LayoutParams) v.getLayoutParams();
1825             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1826                     lp.cellVSpan, mTmpOccupied, false);
1827             if (boundingRect == null) {
1828                 boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1829                         lp.tmpCellY + lp.cellVSpan);
1830             } else {
1831                 boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1832                         lp.tmpCellY + lp.cellVSpan);
1833             }
1834         }
1835         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1836 
1837         // TODO: this bounding rect may not be completely filled, lets be more precise about this
1838         // check.
1839         findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(), boundingRect.height(),
1840                 direction, mTmpOccupied, mTempLocation);
1841 
1842         int deltaX = mTempLocation[0] - boundingRect.left;
1843         int deltaY = mTempLocation[1] - boundingRect.top;
1844         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1845             for (View v: views) {
1846                 LayoutParams lp = (LayoutParams) v.getLayoutParams();
1847                 lp.tmpCellX += deltaX;
1848                 lp.tmpCellY += deltaY;
1849             }
1850             success = true;
1851         }
1852         for (View v: views) {
1853             LayoutParams lp = (LayoutParams) v.getLayoutParams();
1854             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1855                     lp.cellVSpan, mTmpOccupied, true);
1856         }
1857         return success;
1858     }
1859 
1860     private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1861         markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1862     }
1863 
1864     private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1865             View ignoreView) {
1866         mIntersectingViews.clear();
1867 
1868         mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
1869         markCellsForRect(mOccupiedRect, mTmpOccupied, true);
1870 
1871         if (ignoreView != null) {
1872             LayoutParams lp = (LayoutParams) ignoreView.getLayoutParams();
1873             lp.tmpCellX = cellX;
1874             lp.tmpCellY = cellY;
1875         }
1876 
1877         int childCount = mShortcutsAndWidgets.getChildCount();
1878         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1879         Rect r1 = new Rect();
1880         for (int i = 0; i &lt; childCount; i++) {
1881             View child = mShortcutsAndWidgets.getChildAt(i);
1882             if (child == ignoreView) continue;
1883             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1884             r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
1885             if (Rect.intersects(r0, r1)) {
1886                 if (!lp.canReorder) {
1887                     return false;
1888                 }
1889                 mIntersectingViews.add(child);
1890             }
1891         }
1892         // First we try moving the views as a block
1893         if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {
1894             return true;
1895         }
1896         // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1897         for (View v : mIntersectingViews) {
1898             if (!addViewToTempLocation(v, mOccupiedRect, direction)) {
1899                 return false;
1900             }
1901         }
1902         return true;
1903     }
1904 
1905     /*
1906      * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1907      * the provided point and the provided cell
1908      */
1909     private void computeDirectionVector(int x0, int y0, int x1, int y1, int[] result) {
1910         int deltaX = x1 - x0;
1911         int deltaY = y1 - y0;
1912 
1913         double angle = Math.atan(((float) deltaY) / deltaX);
1914 
1915         result[0] = 0;
1916         result[1] = 0;
1917         if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1918             result[0] = (int) Math.signum(deltaX);
1919         }
1920         if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1921             result[1] = (int) Math.signum(deltaY);
1922         }
1923     }
1924 
1925     ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1926             int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1927         // This creates a copy of the current occupied array, omitting the current view being
1928         // dragged
1929         resetTempLayoutToCurrent(dragView);
1930 
1931         // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1932         // nothing in its way.
1933         int result[] = new int[2];
1934         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1935 
1936         boolean success = false;
1937         // First we try the exact nearest position of the item being dragged,
1938         // we will then want to try to move this around to other neighbouring positions
1939         success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView);
1940 
1941         if (!success) {
1942             // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1943             // x, then 1 in y etc.
1944             if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1945                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1946                         dragView, false, solution);
1947             } else if (spanY &gt; minSpanY) {
1948                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1949                         dragView, true, solution);
1950             }
1951             solution.isSolution = false;
1952         } else {
1953             solution.isSolution = true;
1954             solution.dragViewX = result[0];
1955             solution.dragViewY = result[1];
1956             solution.dragViewSpanX = spanX;
1957             solution.dragViewSpanY = spanY;
1958             copyCurrentStateToSolution(solution, true);
1959         }
1960         return solution;
1961     }
1962 
1963     private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1964         int childCount = mShortcutsAndWidgets.getChildCount();
1965         for (int i = 0; i &lt; childCount; i++) {
1966             View child = mShortcutsAndWidgets.getChildAt(i);
1967             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1968             Point p;
1969             if (temp) {
1970                 p = new Point(lp.tmpCellX, lp.tmpCellY);
1971             } else {
1972                 p = new Point(lp.cellX, lp.cellY);
1973             }
1974             solution.map.put(child, p);
1975         }
1976     }
1977 
1978     private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1979         for (int i = 0; i &lt; mCountX; i++) {
1980             for (int j = 0; j &lt; mCountY; j++) {
1981                 mTmpOccupied[i][j] = false;
1982             }
1983         }
1984 
1985         int childCount = mShortcutsAndWidgets.getChildCount();
1986         for (int i = 0; i &lt; childCount; i++) {
1987             View child = mShortcutsAndWidgets.getChildAt(i);
1988             if (child == dragView) continue;
1989             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1990             Point p = solution.map.get(child);
1991             if (p != null) {
1992                 lp.tmpCellX = p.x;
1993                 lp.tmpCellY = p.y;
1994                 markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,
1995                         mTmpOccupied, true);
1996             }
1997         }
1998         markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1999                 solution.dragViewSpanY, mTmpOccupied, true);
2000     }
2001 
2002     private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
2003             commitDragView) {
2004 
2005         boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
2006         for (int i = 0; i &lt; mCountX; i++) {
2007             for (int j = 0; j &lt; mCountY; j++) {
2008                 occupied[i][j] = false;
2009             }
2010         }
2011 
2012         int childCount = mShortcutsAndWidgets.getChildCount();
2013         for (int i = 0; i &lt; childCount; i++) {
2014             View child = mShortcutsAndWidgets.getChildAt(i);
2015             if (child == dragView) continue;
2016             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2017             Point p = solution.map.get(child);
2018             if (p != null) {
2019                 if (lp.cellX != p.x || lp.cellY != p.y) {
2020                     animateChildToPosition(child, p.x, p.y, 150, 0, DESTRUCTIVE_REORDER, false);
2021                 }
2022                 markCellsForView(p.x, p.y, lp.cellHSpan, lp.cellVSpan, occupied, true);
2023             }
2024         }
2025         if (commitDragView) {
2026             markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
2027                     solution.dragViewSpanY, occupied, true);
2028         }
2029     }
2030 
2031     private void commitTempPlacement() {
2032         for (int i = 0; i &lt; mCountX; i++) {
2033             for (int j = 0; j &lt; mCountY; j++) {
2034                 mOccupied[i][j] = mTmpOccupied[i][j];
2035             }
2036         }
2037         int childCount = mShortcutsAndWidgets.getChildCount();
2038         for (int i = 0; i &lt; childCount; i++) {
2039             LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
2040             lp.cellX = lp.tmpCellX;
2041             lp.cellY = lp.tmpCellY;
2042         }
2043     }
2044 
2045     public void setUseTempCoords(boolean useTempCoords) {
2046         int childCount = mShortcutsAndWidgets.getChildCount();
2047         for (int i = 0; i &lt; childCount; i++) {
2048             LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
2049             lp.useTmpCoords = useTempCoords;
2050         }
2051     }
2052 
2053     private void resetTempLayoutToCurrent(View ignoreView) {
2054         for (int i = 0; i &lt; mCountX; i++) {
2055             for (int j = 0; j &lt; mCountY; j++) {
2056                 mTmpOccupied[i][j] = mOccupied[i][j];
2057             }
2058         }
2059         int childCount = mShortcutsAndWidgets.getChildCount();
2060         for (int i = 0; i &lt; childCount; i++) {
2061             View child = mShortcutsAndWidgets.getChildAt(i);
2062             if (child == ignoreView) continue;
2063             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2064             lp.tmpCellX = lp.cellX;
2065             lp.tmpCellY = lp.cellY;
2066         }
2067     }
2068 
2069     ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
2070             int spanX, int spanY, View dragView, ItemConfiguration solution) {
2071         int[] result = new int[2];
2072         int[] resultSpan = new int[2];
2073         findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
2074                 resultSpan);
2075         if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
2076             copyCurrentStateToSolution(solution, false);
2077             solution.dragViewX = result[0];
2078             solution.dragViewY = result[1];
2079             solution.dragViewSpanX = resultSpan[0];
2080             solution.dragViewSpanY = resultSpan[1];
2081             solution.isSolution = true;
2082         } else {
2083             solution.isSolution = false;
2084         }
2085         return solution;
2086     }
2087 
2088     public void prepareChildForDrag(View child) {
2089         markCellsAsUnoccupiedForView(child);
2090         LayoutParams lp = (LayoutParams) child.getLayoutParams();
2091         lp.cellX = -1;
2092         lp.cellY = -1;
2093 
2094     }
2095 
2096     int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
2097             View dragView, int[] result, int resultSpan[], int mode) {
2098 
2099         // First we determine if things have moved enough to cause a different layout
2100         result = findNearestArea(pixelX, pixelY, 1, 1, result);
2101 
2102         if (resultSpan == null) {
2103             resultSpan = new int[2];
2104         }
2105 
2106         // We attempt the first algorithm
2107         cellToCenterPoint(result[0], result[1], mTmpPoint);
2108         computeDirectionVector(pixelX, pixelY, mTmpPoint[0], mTmpPoint[1], mDirectionVector);
2109         ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
2110                  spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
2111 
2112         // We attempt the approach which doesn&#x27;t shuffle views at all
2113         ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
2114                 minSpanY, spanX, spanY, dragView, new ItemConfiguration());
2115 
2116         ItemConfiguration finalSolution = null;
2117         if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
2118             finalSolution = swapSolution;
2119         } else if (noShuffleSolution.isSolution) {
2120             finalSolution = noShuffleSolution;
2121         }
2122 
2123         boolean foundSolution = true;
2124         if (!DESTRUCTIVE_REORDER) {
2125             setUseTempCoords(true);
2126         }
2127 
2128         if (finalSolution != null) {
2129             result[0] = finalSolution.dragViewX;
2130             result[1] = finalSolution.dragViewY;
2131             resultSpan[0] = finalSolution.dragViewSpanX;
2132             resultSpan[1] = finalSolution.dragViewSpanY;
2133 
2134             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2135             // committing anything or animating anything as we just want to determine if a solution
2136             // exists
2137             if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2138                 if (!DESTRUCTIVE_REORDER) {
2139                     copySolutionToTempState(finalSolution, dragView);
2140                 }
2141                 setItemPlacementDirty(true);
2142                 animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
2143 
2144                 if (!DESTRUCTIVE_REORDER &amp;&amp; mode == MODE_ON_DROP) {
2145                     commitTempPlacement();
2146                 }
2147             }
2148         } else {
2149             foundSolution = false;
2150             result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
2151         }
2152 
2153         if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
2154             setUseTempCoords(false);
2155         }
2156         boolean[][] occupied = mOccupied;
2157 
2158         mShortcutsAndWidgets.requestLayout();
2159         return result;
2160     }
2161 
2162     public boolean isItemPlacementDirty() {
2163         return mItemLocationsDirty;
2164     }
2165 
2166     public void setItemPlacementDirty(boolean dirty) {
2167         mItemLocationsDirty = dirty;
2168     }
2169 
2170     private class ItemConfiguration {
2171         HashMap&lt;View, Point&gt; map = new HashMap&lt;View, Point&gt;();
2172         boolean isSolution = false;
2173         int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
2174 
2175         int area() {
2176             return dragViewSpanX * dragViewSpanY;
2177         }
2178         void clear() {
2179             map.clear();
2180             isSolution = false;
2181         }
2182     }
2183 
2184     /**
2185      * Find a vacant area that will fit the given bounds nearest the requested
2186      * cell location. Uses Euclidean distance to score multiple vacant areas.
2187      *
2188      * @param pixelX The X location at which you want to search for a vacant area.
2189      * @param pixelY The Y location at which you want to search for a vacant area.
2190      * @param spanX Horizontal span of the object.
2191      * @param spanY Vertical span of the object.
2192      * @param ignoreView Considers space occupied by this view as unoccupied
2193      * @param result Previously returned value to possibly recycle.
2194      * @return The X, Y cell of a vacant area that can contain this object,
2195      *         nearest the requested location.
2196      */
2197     int[] findNearestVacantArea(
2198             int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
2199         return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
2200     }
2201 
2202     /**
2203      * Find a vacant area that will fit the given bounds nearest the requested
2204      * cell location. Uses Euclidean distance to score multiple vacant areas.
2205      *
2206      * @param pixelX The X location at which you want to search for a vacant area.
2207      * @param pixelY The Y location at which you want to search for a vacant area.
2208      * @param minSpanX The minimum horizontal span required
2209      * @param minSpanY The minimum vertical span required
2210      * @param spanX Horizontal span of the object.
2211      * @param spanY Vertical span of the object.
2212      * @param ignoreView Considers space occupied by this view as unoccupied
2213      * @param result Previously returned value to possibly recycle.
2214      * @return The X, Y cell of a vacant area that can contain this object,
2215      *         nearest the requested location.
2216      */
2217     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2218             int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2219         return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2220                 result, resultSpan, mOccupied);
2221     }
2222 
2223     /**
2224      * Find a starting cell position that will fit the given bounds nearest the requested
2225      * cell location. Uses Euclidean distance to score multiple vacant areas.
2226      *
2227      * @param pixelX The X location at which you want to search for a vacant area.
2228      * @param pixelY The Y location at which you want to search for a vacant area.
2229      * @param spanX Horizontal span of the object.
2230      * @param spanY Vertical span of the object.
2231      * @param ignoreView Considers space occupied by this view as unoccupied
2232      * @param result Previously returned value to possibly recycle.
2233      * @return The X, Y cell of a vacant area that can contain this object,
2234      *         nearest the requested location.
2235      */
2236     int[] findNearestArea(
2237             int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2238         return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2239     }
2240 
2241     boolean existsEmptyCell() {
2242         return findCellForSpan(null, 1, 1);
2243     }
2244 
2245     /**
2246      * Finds the upper-left coordinate of the first rectangle in the grid that can
2247      * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2248      * then this method will only return coordinates for rectangles that contain the cell
2249      * (intersectX, intersectY)
2250      *
2251      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2252      *               can be found.
2253      * @param spanX The horizontal span of the cell we want to find.
2254      * @param spanY The vertical span of the cell we want to find.
2255      *
2256      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2257      */
2258     boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2259         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2260     }
2261 
2262     /**
2263      * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2264      *
2265      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2266      *               can be found.
2267      * @param spanX The horizontal span of the cell we want to find.
2268      * @param spanY The vertical span of the cell we want to find.
2269      * @param ignoreView The home screen item we should treat as not occupying any space
2270      * @return
2271      */
2272     boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2273         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2274                 ignoreView, mOccupied);
2275     }
2276 
2277     /**
2278      * Like above, but if intersectX and intersectY are not -1, then this method will try to
2279      * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2280      *
2281      * @param spanX The horizontal span of the cell we want to find.
2282      * @param spanY The vertical span of the cell we want to find.
2283      * @param ignoreView The home screen item we should treat as not occupying any space
2284      * @param intersectX The X coordinate of the cell that we should try to overlap
2285      * @param intersectX The Y coordinate of the cell that we should try to overlap
2286      *
2287      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2288      */
2289     boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2290             int intersectX, int intersectY) {
2291         return findCellForSpanThatIntersectsIgnoring(
2292                 cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2293     }
2294 
2295     /**
2296      * The superset of the above two methods
2297      */
2298     boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2299             int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2300         // mark space take by ignoreView as available (method checks if ignoreView is null)
2301         markCellsAsUnoccupiedForView(ignoreView, occupied);
2302 
2303         boolean foundCell = false;
2304         while (true) {
2305             int startX = 0;
2306             if (intersectX &gt;= 0) {
2307                 startX = Math.max(startX, intersectX - (spanX - 1));
2308             }
2309             int endX = mCountX - (spanX - 1);
2310             if (intersectX &gt;= 0) {
2311                 endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2312             }
2313             int startY = 0;
2314             if (intersectY &gt;= 0) {
2315                 startY = Math.max(startY, intersectY - (spanY - 1));
2316             }
2317             int endY = mCountY - (spanY - 1);
2318             if (intersectY &gt;= 0) {
2319                 endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2320             }
2321 
2322             for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2323                 inner:
2324                 for (int x = startX; x &lt; endX; x++) {
2325                     for (int i = 0; i &lt; spanX; i++) {
2326                         for (int j = 0; j &lt; spanY; j++) {
2327                             if (occupied[x + i][y + j]) {
2328                                 // small optimization: we can skip to after the column we just found
2329                                 // an occupied cell
2330                                 x += i;
2331                                 continue inner;
2332                             }
2333                         }
2334                     }
2335                     if (cellXY != null) {
2336                         cellXY[0] = x;
2337                         cellXY[1] = y;
2338                     }
2339                     foundCell = true;
2340                     break;
2341                 }
2342             }
2343             if (intersectX == -1 &amp;&amp; intersectY == -1) {
2344                 break;
2345             } else {
2346                 // if we failed to find anything, try again but without any requirements of
2347                 // intersecting
2348                 intersectX = -1;
2349                 intersectY = -1;
2350                 continue;
2351             }
2352         }
2353 
2354         // re-mark space taken by ignoreView as occupied
2355         markCellsAsOccupiedForView(ignoreView, occupied);
2356         return foundCell;
2357     }
2358 
2359     /**
2360      * A drag event has begun over this layout.
2361      * It may have begun over this layout (in which case onDragChild is called first),
2362      * or it may have begun on another layout.
2363      */
2364     void onDragEnter() {
2365         if (!mDragging) {
2366             // Fade in the drag indicators
2367             if (mCrosshairsAnimator != null) {
2368                 mCrosshairsAnimator.animateIn();
2369             }
2370         }
2371         mDragging = true;
2372     }
2373 
2374     /**
2375      * Called when drag has left this CellLayout or has been completed (successfully or not)
2376      */
2377     void onDragExit() {
2378         // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2379         // item to this layout via the customize drawer.
2380         // Guard against that case.
2381         if (mDragging) {
2382             mDragging = false;
2383 
2384             // Fade out the drag indicators
2385             if (mCrosshairsAnimator != null) {
2386                 mCrosshairsAnimator.animateOut();
2387             }
2388         }
2389 
2390         // Invalidate the drag data
2391         mDragCell[0] = mDragCell[1] = -1;
2392         mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2393         mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2394 
2395         setIsDragOverlapping(false);
2396     }
2397 
2398     /**
2399      * Mark a child as having been dropped.
2400      * At the beginning of the drag operation, the child may have been on another
2401      * screen, but it is re-parented before this method is called.
2402      *
2403      * @param child The child that is being dropped
2404      */
2405     void onDropChild(View child) {
2406         if (child != null) {
2407             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2408             lp.dropped = true;
2409             child.requestLayout();
2410         }
2411     }
2412 
2413     /**
2414      * Computes a bounding rectangle for a range of cells
2415      *
2416      * @param cellX X coordinate of upper left corner expressed as a cell position
2417      * @param cellY Y coordinate of upper left corner expressed as a cell position
2418      * @param cellHSpan Width in cells
2419      * @param cellVSpan Height in cells
2420      * @param resultRect Rect into which to put the results
2421      */
2422     public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2423         final int cellWidth = mCellWidth;
2424         final int cellHeight = mCellHeight;
2425         final int widthGap = mWidthGap;
2426         final int heightGap = mHeightGap;
2427 
2428         final int hStartPadding = getPaddingLeft();
2429         final int vStartPadding = getPaddingTop();
2430 
2431         int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2432         int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2433 
2434         int x = hStartPadding + cellX * (cellWidth + widthGap);
2435         int y = vStartPadding + cellY * (cellHeight + heightGap);
2436 
2437         resultRect.set(x, y, x + width, y + height);
2438     }
2439 
2440     /**
2441      * Computes the required horizontal and vertical cell spans to always
2442      * fit the given rectangle.
2443      *
2444      * @param width Width in pixels
2445      * @param height Height in pixels
2446      * @param result An array of length 2 in which to store the result (may be null).
2447      */
2448     public int[] rectToCell(int width, int height, int[] result) {
2449         return rectToCell(getResources(), width, height, result);
2450     }
2451 
2452     public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2453         // Always assume we&#x27;re working with the smallest span to make sure we
2454         // reserve enough space in both orientations.
2455         int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2456         int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2457         int smallerSize = Math.min(actualWidth, actualHeight);
2458 
2459         // Always round up to next largest cell
2460         int spanX = (int) Math.ceil(width / (float) smallerSize);
2461         int spanY = (int) Math.ceil(height / (float) smallerSize);
2462 
2463         if (result == null) {
2464             return new int[] { spanX, spanY };
2465         }
2466         result[0] = spanX;
2467         result[1] = spanY;
2468         return result;
2469     }
2470 
2471     public int[] cellSpansToSize(int hSpans, int vSpans) {
2472         int[] size = new int[2];
2473         size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2474         size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2475         return size;
2476     }
2477 
2478     /**
2479      * Calculate the grid spans needed to fit given item
2480      */
2481     public void calculateSpans(ItemInfo info) {
2482         final int minWidth;
2483         final int minHeight;
2484 
2485         if (info instanceof LauncherAppWidgetInfo) {
2486             minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2487             minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2488         } else if (info instanceof PendingAddWidgetInfo) {
2489             minWidth = ((PendingAddWidgetInfo) info).minWidth;
2490             minHeight = ((PendingAddWidgetInfo) info).minHeight;
2491         } else {
2492             // It&#x27;s not a widget, so it must be 1x1
2493             info.spanX = info.spanY = 1;
2494             return;
2495         }
2496         int[] spans = rectToCell(minWidth, minHeight, null);
2497         info.spanX = spans[0];
2498         info.spanY = spans[1];
2499     }
2500 
2501     /**
2502      * Find the first vacant cell, if there is one.
2503      *
2504      * @param vacant Holds the x and y coordinate of the vacant cell
2505      * @param spanX Horizontal cell span.
2506      * @param spanY Vertical cell span.
2507      *
2508      * @return True if a vacant cell was found
2509      */
2510     public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2511 
2512         return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2513     }
2514 
2515     static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2516             int xCount, int yCount, boolean[][] occupied) {
2517 
2518         for (int y = 0; y &lt; yCount; y++) {
2519             for (int x = 0; x &lt; xCount; x++) {
2520                 boolean available = !occupied[x][y];
2521 out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2522                     for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2523                         available = available &amp;&amp; !occupied[i][j];
2524                         if (!available) break out;
2525                     }
2526                 }
2527 
2528                 if (available) {
2529                     vacant[0] = x;
2530                     vacant[1] = y;
2531                     return true;
2532                 }
2533             }
2534         }
2535 
2536         return false;
2537     }
2538 
2539     private void clearOccupiedCells() {
2540         for (int x = 0; x &lt; mCountX; x++) {
2541             for (int y = 0; y &lt; mCountY; y++) {
2542                 mOccupied[x][y] = false;
2543             }
2544         }
2545     }
2546 
2547     /**
2548      * Given a view, determines how much that view can be expanded in all directions, in terms of
2549      * whether or not there are other items occupying adjacent cells. Used by the
2550      * AppWidgetResizeFrame to determine how the widget can be resized.
2551      */
2552     public void getExpandabilityArrayForView(View view, int[] expandability) {
2553         final LayoutParams lp = (LayoutParams) view.getLayoutParams();
2554         boolean flag;
2555 
2556         expandability[AppWidgetResizeFrame.LEFT] = 0;
2557         for (int x = lp.cellX - 1; x &gt;= 0; x--) {
2558             flag = false;
2559             for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2560                 if (mOccupied[x][y]) flag = true;
2561             }
2562             if (flag) break;
2563             expandability[AppWidgetResizeFrame.LEFT]++;
2564         }
2565 
2566         expandability[AppWidgetResizeFrame.TOP] = 0;
2567         for (int y = lp.cellY - 1; y &gt;= 0; y--) {
2568             flag = false;
2569             for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2570                 if (mOccupied[x][y]) flag = true;
2571             }
2572             if (flag) break;
2573             expandability[AppWidgetResizeFrame.TOP]++;
2574         }
2575 
2576         expandability[AppWidgetResizeFrame.RIGHT] = 0;
2577         for (int x = lp.cellX + lp.cellHSpan; x &lt; mCountX; x++) {
2578             flag = false;
2579             for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2580                 if (mOccupied[x][y]) flag = true;
2581             }
2582             if (flag) break;
2583             expandability[AppWidgetResizeFrame.RIGHT]++;
2584         }
2585 
2586         expandability[AppWidgetResizeFrame.BOTTOM] = 0;
2587         for (int y = lp.cellY + lp.cellVSpan; y &lt; mCountY; y++) {
2588             flag = false;
2589             for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2590                 if (mOccupied[x][y]) flag = true;
2591             }
2592             if (flag) break;
2593             expandability[AppWidgetResizeFrame.BOTTOM]++;
2594         }
2595     }
2596 
2597     public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2598         markCellsAsUnoccupiedForView(view);
2599         markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2600     }
2601 
2602     public void markCellsAsOccupiedForView(View view) {
2603         markCellsAsOccupiedForView(view, mOccupied);
2604     }
2605     public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2606         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2607         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2608         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2609     }
2610 
2611     public void markCellsAsUnoccupiedForView(View view) {
2612         markCellsAsUnoccupiedForView(view, mOccupied);
2613     }
2614     public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
2615         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2616         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2617         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2618     }
2619 
2620     private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2621             boolean value) {
2622         if (cellX &lt; 0 || cellY &lt; 0) return;
2623         for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2624             for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2625                 occupied[x][y] = value;
2626             }
2627         }
2628     }
2629 
2630     public int getDesiredWidth() {
2631         return mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
2632                 (Math.max((mCountX - 1), 0) * mWidthGap);
2633     }
2634 
2635     public int getDesiredHeight()  {
2636         return mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
2637                 (Math.max((mCountY - 1), 0) * mHeightGap);
2638     }
2639 
2640     public boolean isOccupied(int x, int y) {
2641         if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2642             return mOccupied[x][y];
2643         } else {
2644             throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2645         }
2646     }
2647 
2648     @Override
2649     public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2650         return new CellLayout.LayoutParams(getContext(), attrs);
2651     }
2652 
2653     @Override
2654     protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2655         return p instanceof CellLayout.LayoutParams;
2656     }
2657 
2658     @Override
2659     protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2660         return new CellLayout.LayoutParams(p);
2661     }
2662 
2663     public static class CellLayoutAnimationController extends LayoutAnimationController {
2664         public CellLayoutAnimationController(Animation animation, float delay) {
2665             super(animation, delay);
2666         }
2667 
2668         @Override
2669         protected long getDelayForView(View view) {
2670             return (int) (Math.random() * 150);
2671         }
2672     }
2673 
2674     public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2675         /**
2676          * Horizontal location of the item in the grid.
2677          */
2678         @ViewDebug.ExportedProperty
2679         public int cellX;
2680 
2681         /**
2682          * Vertical location of the item in the grid.
2683          */
2684         @ViewDebug.ExportedProperty
2685         public int cellY;
2686 
2687         /**
2688          * Temporary horizontal location of the item in the grid during reorder
2689          */
2690         public int tmpCellX;
2691 
2692         /**
2693          * Temporary vertical location of the item in the grid during reorder
2694          */
2695         public int tmpCellY;
2696 
2697         /**
2698          * Indicates that the temporary coordinates should be used to layout the items
2699          */
2700         public boolean useTmpCoords;
2701 
2702         /**
2703          * Number of cells spanned horizontally by the item.
2704          */
2705         @ViewDebug.ExportedProperty
2706         public int cellHSpan;
2707 
2708         /**
2709          * Number of cells spanned vertically by the item.
2710          */
2711         @ViewDebug.ExportedProperty
2712         public int cellVSpan;
2713 
2714         /**
2715          * Indicates whether the item will set its x, y, width and height parameters freely,
2716          * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2717          */
2718         public boolean isLockedToGrid = true;
2719 
2720         /**
2721          * Indicates whether this item can be reordered. Always true except in the case of the
2722          * the AllApps button.
2723          */
2724         public boolean canReorder = true;
2725 
2726         // X coordinate of the view in the layout.
2727         @ViewDebug.ExportedProperty
2728         int x;
2729         // Y coordinate of the view in the layout.
2730         @ViewDebug.ExportedProperty
2731         int y;
2732 
2733         boolean dropped;
2734 
2735         public LayoutParams(Context c, AttributeSet attrs) {
2736             super(c, attrs);
2737             cellHSpan = 1;
2738             cellVSpan = 1;
2739         }
2740 
2741         public LayoutParams(ViewGroup.LayoutParams source) {
2742             super(source);
2743             cellHSpan = 1;
2744             cellVSpan = 1;
2745         }
2746 
2747         public LayoutParams(LayoutParams source) {
2748             super(source);
2749             this.cellX = source.cellX;
2750             this.cellY = source.cellY;
2751             this.cellHSpan = source.cellHSpan;
2752             this.cellVSpan = source.cellVSpan;
2753         }
2754 
2755         public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2756             super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
2757             this.cellX = cellX;
2758             this.cellY = cellY;
2759             this.cellHSpan = cellHSpan;
2760             this.cellVSpan = cellVSpan;
2761         }
2762 
2763         public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2764             if (isLockedToGrid) {
2765                 final int myCellHSpan = cellHSpan;
2766                 final int myCellVSpan = cellVSpan;
2767                 final int myCellX = useTmpCoords ? tmpCellX : cellX;
2768                 final int myCellY = useTmpCoords ? tmpCellY : cellY;
2769 
2770                 width = myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) -
2771                         leftMargin - rightMargin;
2772                 height = myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) -
2773                         topMargin - bottomMargin;
2774                 x = (int) (myCellX * (cellWidth + widthGap) + leftMargin);
2775                 y = (int) (myCellY * (cellHeight + heightGap) + topMargin);
2776             }
2777         }
2778 
2779         public String toString() {
2780             return &quot;(&quot; + this.cellX + &quot;, &quot; + this.cellY + &quot;)&quot;;
2781         }
2782 
2783         public void setWidth(int width) {
2784             this.width = width;
2785         }
2786 
2787         public int getWidth() {
2788             return width;
2789         }
2790 
2791         public void setHeight(int height) {
2792             this.height = height;
2793         }
2794 
2795         public int getHeight() {
2796             return height;
2797         }
2798 
2799         public void setX(int x) {
2800             this.x = x;
2801         }
2802 
2803         public int getX() {
2804             return x;
2805         }
2806 
2807         public void setY(int y) {
2808             this.y = y;
2809         }
2810 
2811         public int getY() {
2812             return y;
2813         }
2814     }
2815 
2816     // This class stores info for two purposes:
2817     // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
2818     //    its spanX, spanY, and the screen it is on
2819     // 2. When long clicking on an empty cell in a CellLayout, we save information about the
2820     //    cellX and cellY coordinates and which page was clicked. We then set this as a tag on
2821     //    the CellLayout that was long clicked
2822     static final class CellInfo {
2823         View cell;
2824         int cellX = -1;
2825         int cellY = -1;
2826         int spanX;
2827         int spanY;
2828         int screen;
2829         long container;
2830 
2831         @Override
2832         public String toString() {
2833             return &quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())
2834                     + &quot;, x=&quot; + cellX + &quot;, y=&quot; + cellY + &quot;]&quot;;
2835         }
2836     }
2837 
2838     public boolean lastDownOnOccupiedCell() {
2839         return mLastDownOnOccupiedCell;
2840     }
2841 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.ObjectAnimator;
  22 import android.animation.PropertyValuesHolder;
  23 import android.animation.TimeInterpolator;
  24 import android.animation.ValueAnimator;
  25 import android.animation.ValueAnimator.AnimatorUpdateListener;
  26 import android.content.Context;
  27 import android.content.res.Resources;
  28 import android.content.res.TypedArray;
  29 import android.graphics.Bitmap;
  30 import android.graphics.Canvas;
  31 import android.graphics.Color;
  32 import android.graphics.Paint;
  33 import android.graphics.Point;
  34 import android.graphics.PointF;
  35 import android.graphics.PorterDuff;
  36 import android.graphics.PorterDuffXfermode;
  37 import android.graphics.Rect;
  38 import android.graphics.drawable.ColorDrawable;
  39 import android.graphics.drawable.Drawable;
  40 import android.graphics.drawable.NinePatchDrawable;
  41 import android.util.AttributeSet;
  42 import android.util.Log;
  43 import android.view.MotionEvent;
  44 import android.view.View;
  45 import android.view.ViewDebug;
  46 import android.view.ViewGroup;
  47 import android.view.animation.Animation;
  48 import android.view.animation.DecelerateInterpolator;
  49 import android.view.animation.LayoutAnimationController;
  50 
  51 import com.android.launcher.R;
  52 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  53 
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.HashMap;
  57 import java.util.Stack;
  58 
  59 public class CellLayout extends ViewGroup {
  60     static final String TAG = &quot;CellLayout&quot;;
  61 
  62     private int mOriginalCellWidth;
  63     private int mOriginalCellHeight;
  64     private int mCellWidth;
  65     private int mCellHeight;
  66 
  67     private int mCountX;
  68     private int mCountY;
  69 
  70     private int mOriginalWidthGap;
  71     private int mOriginalHeightGap;
  72     private int mWidthGap;
  73     private int mHeightGap;
  74     private int mMaxGap;
  75     private boolean mScrollingTransformsDirty = false;
  76 
  77     private final Rect mRect = new Rect();
  78     private final CellInfo mCellInfo = new CellInfo();
  79 
  80     // These are temporary variables to prevent having to allocate a new object just to
  81     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  82     private final int[] mTmpXY = new int[2];
  83     private final int[] mTmpPoint = new int[2];
  84     private final PointF mTmpPointF = new PointF();
  85     int[] mTempLocation = new int[2];
  86 
  87     boolean[][] mOccupied;
  88     boolean[][] mTmpOccupied;
  89     private boolean mLastDownOnOccupiedCell = false;
  90 
  91     private OnTouchListener mInterceptTouchListener;
  92 
  93     private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
  94     private int[] mFolderLeaveBehindCell = {-1, -1};
  95 
  96     private int mForegroundAlpha = 0;
  97     private float mBackgroundAlpha;
  98     private float mBackgroundAlphaMultiplier = 1.0f;
  99 
 100     private Drawable mNormalBackground;
 101     private Drawable mActiveGlowBackground;
 102     private Drawable mOverScrollForegroundDrawable;
 103     private Drawable mOverScrollLeft;
 104     private Drawable mOverScrollRight;
 105     private Rect mBackgroundRect;
 106     private Rect mForegroundRect;
 107     private int mForegroundPadding;
 108 
 109     // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 110     private boolean mIsDragOverlapping = false;
 111     private final Point mDragCenter = new Point();
 112 
 113     // These arrays are used to implement the drag visualization on x-large screens.
 114     // They are used as circular arrays, indexed by mDragOutlineCurrent.
 115     private Rect[] mDragOutlines = new Rect[4];
 116     private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 117     private InterruptibleInOutAnimator[] mDragOutlineAnims =
 118             new InterruptibleInOutAnimator[mDragOutlines.length];
 119 
 120     // Used as an index into the above 3 arrays; indicates which is the most current value.
 121     private int mDragOutlineCurrent = 0;
 122     private final Paint mDragOutlinePaint = new Paint();
 123 
 124     private BubbleTextView mPressedOrFocusedIcon;
 125 
 126     private Drawable mCrosshairsDrawable = null;
 127     private InterruptibleInOutAnimator mCrosshairsAnimator = null;
 128     private float mCrosshairsVisibility = 0.0f;
 129 
 130     private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new
 131             HashMap&lt;CellLayout.LayoutParams, Animator&gt;();
 132 
 133     // When a drag operation is in progress, holds the nearest cell to the touch point
 134     private final int[] mDragCell = new int[2];
 135 
 136     private boolean mDragging = false;
 137     private boolean mItemLocationsDirty = false;
 138 
 139     private TimeInterpolator mEaseOutInterpolator;
 140     private ShortcutAndWidgetContainer mShortcutsAndWidgets;
 141 
 142     private boolean mIsHotseat = false;
 143     private float mChildScale = 1f;
 144     private float mHotseatChildScale = 1f;
 145 
 146     public static final int MODE_DRAG_OVER = 0;
 147     public static final int MODE_ON_DROP = 1;
 148     public static final int MODE_ON_DROP_EXTERNAL = 2;
 149     public static final int MODE_ACCEPT_DROP = 3;
 150     private static final boolean DESTRUCTIVE_REORDER = true;
 151     private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 152 
 153     private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 154     private Rect mOccupiedRect = new Rect();
 155     private int[] mDirectionVector = new int[2];
 156 
 157     public CellLayout(Context context) {
 158         this(context, null);
 159     }
 160 
 161     public CellLayout(Context context, AttributeSet attrs) {
 162         this(context, attrs, 0);
 163     }
 164 
 165     public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 166         super(context, attrs, defStyle);
 167 
 168         // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 169         // the user where a dragged item will land when dropped.
 170         setWillNotDraw(false);
 171 
 172         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 173 
 174         mOriginalCellWidth =
 175             mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 176         mOriginalCellHeight =
 177             mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 178         mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 179         mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 180         mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 181         mCountX = LauncherModel.getCellCountX();
 182         mCountY = LauncherModel.getCellCountY();
 183         mOccupied = new boolean[mCountX][mCountY];
 184         mTmpOccupied = new boolean[mCountX][mCountY];
 185 
 186         a.recycle();
 187 
 188         setAlwaysDrawnWithCacheEnabled(false);
 189 
 190         final Resources res = getResources();
 191 
 192         mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 193         mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 194 
 195         mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 196         mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 197         mForegroundPadding =
 198                 res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 199 
 200         mNormalBackground.setFilterBitmap(true);
 201         mActiveGlowBackground.setFilterBitmap(true);
 202 
 203         int iconScale = res.getInteger(R.integer.app_icon_scale_percent);
 204         if (iconScale &gt;= 0) {
 205             mChildScale = iconScale / 100f;
 206         }
 207         int hotseatIconScale = res.getInteger(R.integer.app_icon_hotseat_scale_percent);
 208         if (hotseatIconScale &gt;= 0) {
 209             mHotseatChildScale = hotseatIconScale / 100f;
 210         }
 211 
 212         // Initialize the data structures used for the drag visualization.
 213 
 214         mCrosshairsDrawable = res.getDrawable(R.drawable.gardening_crosshairs);
 215         mEaseOutInterpolator = new DecelerateInterpolator(2.5f); // Quint ease out
 216 
 217         // Set up the animation for fading the crosshairs in and out
 218         int animDuration = res.getInteger(R.integer.config_crosshairsFadeInTime);
 219         mCrosshairsAnimator = new InterruptibleInOutAnimator(animDuration, 0.0f, 1.0f);
 220         mCrosshairsAnimator.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 221             public void onAnimationUpdate(ValueAnimator animation) {
 222                 mCrosshairsVisibility = ((Float) animation.getAnimatedValue()).floatValue();
 223                 invalidate();
 224             }
 225         });
 226         mCrosshairsAnimator.getAnimator().setInterpolator(mEaseOutInterpolator);
 227 
 228         mDragCell[0] = mDragCell[1] = -1;
 229         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 230             mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 231         }
 232 
 233         // When dragging things around the home screens, we show a green outline of
 234         // where the item will land. The outlines gradually fade out, leaving a trail
 235         // behind the drag path.
 236         // Set up all the animations that are used to implement this fading.
 237         final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 238         final float fromAlphaValue = 0;
 239         final float toAlphaValue = (float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
 240 
 241         Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 242 
 243         for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
 244             final InterruptibleInOutAnimator anim =
 245                 new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);
 246             anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 247             final int thisIndex = i;
 248             anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 249                 public void onAnimationUpdate(ValueAnimator animation) {
 250                     final Bitmap outline = (Bitmap)anim.getTag();
 251 
 252                     // If an animation is started and then stopped very quickly, we can still
 253                     // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 254                     if (outline == null) {
 255                         if (false) {
 256                             Object val = animation.getAnimatedValue();
 257                             Log.d(TAG, &quot;anim &quot; + thisIndex + &quot; update: &quot; + val +
 258                                      &quot;, isStopped &quot; + anim.isStopped());
 259                         }
 260                         // Try to prevent it from continuing to run
 261                         animation.cancel();
 262                     } else {
 263                         mDragOutlineAlphas[thisIndex] = (Float) animation.getAnimatedValue();
 264                         CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 265                     }
 266                 }
 267             });
 268             // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 269             // running. This way the bitmap can be GCed when the animations are complete.
 270             anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 271                 @Override
 272                 public void onAnimationEnd(Animator animation) {
 273                     if ((Float) ((ValueAnimator) animation).getAnimatedValue() == 0f) {
 274                         anim.setTag(null);
 275                     }
 276                 }
 277             });
 278             mDragOutlineAnims[i] = anim;
 279         }
 280 
 281         mBackgroundRect = new Rect();
 282         mForegroundRect = new Rect();
 283 
 284         mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);
 285         mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 286         addView(mShortcutsAndWidgets);
 287     }
 288 
 289     static int widthInPortrait(Resources r, int numCells) {
 290         // We use this method from Workspace to figure out how many rows/columns Launcher should
 291         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 292         // the padding extends outside the visible screen size, but it looked fine anyway.
 293         int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 294         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 295                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 296 
 297         return  minGap * (numCells - 1) + cellWidth * numCells;
 298     }
 299 
 300     static int heightInLandscape(Resources r, int numCells) {
 301         // We use this method from Workspace to figure out how many rows/columns Launcher should
 302         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 303         // the padding extends outside the visible screen size, but it looked fine anyway.
 304         int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 305         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 306                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 307 
 308         return minGap * (numCells - 1) + cellHeight * numCells;
 309     }
 310 
 311     public void enableHardwareLayers() {
 312         mShortcutsAndWidgets.enableHardwareLayers();
 313     }
 314 
 315     public void setGridSize(int x, int y) {
 316         mCountX = x;
 317         mCountY = y;
 318         mOccupied = new boolean[mCountX][mCountY];
 319         mTmpOccupied = new boolean[mCountX][mCountY];
 320         requestLayout();
 321     }
 322 
 323     private void invalidateBubbleTextView(BubbleTextView icon) {
 324         final int padding = icon.getPressedOrFocusedBackgroundPadding();
 325         invalidate(icon.getLeft() + getPaddingLeft() - padding,
 326                 icon.getTop() + getPaddingTop() - padding,
 327                 icon.getRight() + getPaddingLeft() + padding,
 328                 icon.getBottom() + getPaddingTop() + padding);
 329     }
 330 
 331     void setOverScrollAmount(float r, boolean left) {
 332         if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 333             mOverScrollForegroundDrawable = mOverScrollLeft;
 334         } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 335             mOverScrollForegroundDrawable = mOverScrollRight;
 336         }
 337 
 338         mForegroundAlpha = (int) Math.round((r * 255));
 339         mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 340         invalidate();
 341     }
 342 
 343     void setPressedOrFocusedIcon(BubbleTextView icon) {
 344         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 345         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 346         BubbleTextView oldIcon = mPressedOrFocusedIcon;
 347         mPressedOrFocusedIcon = icon;
 348         if (oldIcon != null) {
 349             invalidateBubbleTextView(oldIcon);
 350         }
 351         if (mPressedOrFocusedIcon != null) {
 352             invalidateBubbleTextView(mPressedOrFocusedIcon);
 353         }
 354     }
 355 
 356     void setIsDragOverlapping(boolean isDragOverlapping) {
 357         if (mIsDragOverlapping != isDragOverlapping) {
 358             mIsDragOverlapping = isDragOverlapping;
 359             invalidate();
 360         }
 361     }
 362 
 363     boolean getIsDragOverlapping() {
 364         return mIsDragOverlapping;
 365     }
 366 
 367     protected void setOverscrollTransformsDirty(boolean dirty) {
 368         mScrollingTransformsDirty = dirty;
 369     }
 370 
 371     protected void resetOverscrollTransforms() {
 372         if (mScrollingTransformsDirty) {
 373             setOverscrollTransformsDirty(false);
 374             setTranslationX(0);
 375             setRotationY(0);
 376             // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 377             // pass 0, which results in the overscroll drawable not being drawn any more.
 378             setOverScrollAmount(0, false);
 379             setPivotX(getMeasuredWidth() / 2);
 380             setPivotY(getMeasuredHeight() / 2);
 381         }
 382     }
 383 
 384     @Override
 385     protected void onDraw(Canvas canvas) {
 386         // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 387         // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 388         // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 389         // a drag). However, we also drag the mini hover background *over* one of those two
 390         // backgrounds
 391         if (mBackgroundAlpha &gt; 0.0f) {
 392             Drawable bg;
 393 
 394             if (mIsDragOverlapping) {
 395                 // In the mini case, we draw the active_glow bg *over* the active background
 396                 bg = mActiveGlowBackground;
 397             } else {
 398                 bg = mNormalBackground;
 399             }
 400 
 401             bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 402             bg.setBounds(mBackgroundRect);
 403             bg.draw(canvas);
 404         }
 405 
 406         if (mCrosshairsVisibility &gt; 0.0f) {
 407             final int countX = mCountX;
 408             final int countY = mCountY;
 409 
 410             final float MAX_ALPHA = 0.4f;
 411             final int MAX_VISIBLE_DISTANCE = 600;
 412             final float DISTANCE_MULTIPLIER = 0.002f;
 413 
 414             final Drawable d = mCrosshairsDrawable;
 415             final int width = d.getIntrinsicWidth();
 416             final int height = d.getIntrinsicHeight();
 417 
 418             int x = getPaddingLeft() - (mWidthGap / 2) - (width / 2);
 419             for (int col = 0; col &lt;= countX; col++) {
 420                 int y = getPaddingTop() - (mHeightGap / 2) - (height / 2);
 421                 for (int row = 0; row &lt;= countY; row++) {
 422                     mTmpPointF.set(x - mDragCenter.x, y - mDragCenter.y);
 423                     float dist = mTmpPointF.length();
 424                     // Crosshairs further from the drag point are more faint
 425                     float alpha = Math.min(MAX_ALPHA,
 426                             DISTANCE_MULTIPLIER * (MAX_VISIBLE_DISTANCE - dist));
 427                     if (alpha &gt; 0.0f) {
 428                         d.setBounds(x, y, x + width, y + height);
 429                         d.setAlpha((int) (alpha * 255 * mCrosshairsVisibility));
 430                         d.draw(canvas);
 431                     }
 432                     y += mCellHeight + mHeightGap;
 433                 }
 434                 x += mCellWidth + mWidthGap;
 435             }
 436         }
 437 
 438         final Paint paint = mDragOutlinePaint;
 439         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 440             final float alpha = mDragOutlineAlphas[i];
 441             if (alpha &gt; 0) {
 442                 final Rect r = mDragOutlines[i];
 443                 final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 444                 paint.setAlpha((int)(alpha + .5f));
 445                 canvas.drawBitmap(b, null, r, paint);
 446             }
 447         }
 448 
 449         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 450         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 451         if (mPressedOrFocusedIcon != null) {
 452             final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 453             final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 454             if (b != null) {
 455                 canvas.drawBitmap(b,
 456                         mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 457                         mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 458                         null);
 459             }
 460         }
 461 
 462         if (DEBUG_VISUALIZE_OCCUPIED) {
 463             int[] pt = new int[2];
 464             ColorDrawable cd = new ColorDrawable(Color.RED);
 465             cd.setBounds(0, 0, 80, 80);
 466             for (int i = 0; i &lt; mCountX; i++) {
 467                 for (int j = 0; j &lt; mCountY; j++) {
 468                     if (mOccupied[i][j]) {
 469                         cellToPoint(i, j, pt);
 470                         canvas.save();
 471                         canvas.translate(pt[0], pt[1]);
 472                         cd.draw(canvas);
 473                         canvas.restore();
 474                     }
 475                 }
 476             }
 477         }
 478 
 479         // The folder outer / inner ring image(s)
 480         for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 481             FolderRingAnimator fra = mFolderOuterRings.get(i);
 482 
 483             // Draw outer ring
 484             Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 485             int width = (int) fra.getOuterRingSize();
 486             int height = width;
 487             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 488 
 489             int centerX = mTempLocation[0] + mCellWidth / 2;
 490             int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 491 
 492             canvas.save();
 493             canvas.translate(centerX - width / 2, centerY - height / 2);
 494             d.setBounds(0, 0, width, height);
 495             d.draw(canvas);
 496             canvas.restore();
 497 
 498             // Draw inner ring
 499             d = FolderRingAnimator.sSharedInnerRingDrawable;
 500             width = (int) fra.getInnerRingSize();
 501             height = width;
 502             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 503 
 504             centerX = mTempLocation[0] + mCellWidth / 2;
 505             centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 506             canvas.save();
 507             canvas.translate(centerX - width / 2, centerY - width / 2);
 508             d.setBounds(0, 0, width, height);
 509             d.draw(canvas);
 510             canvas.restore();
 511         }
 512 
 513         if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 514             Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 515             int width = d.getIntrinsicWidth();
 516             int height = d.getIntrinsicHeight();
 517 
 518             cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 519             int centerX = mTempLocation[0] + mCellWidth / 2;
 520             int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 521 
 522             canvas.save();
 523             canvas.translate(centerX - width / 2, centerY - width / 2);
 524             d.setBounds(0, 0, width, height);
 525             d.draw(canvas);
 526             canvas.restore();
 527         }
 528     }
 529 
 530     @Override
 531     protected void dispatchDraw(Canvas canvas) {
 532         super.dispatchDraw(canvas);
 533         if (mForegroundAlpha &gt; 0) {
 534             mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 535             Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 536             p.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));
 537             mOverScrollForegroundDrawable.draw(canvas);
 538             p.setXfermode(null);
 539         }
 540     }
 541 
 542     public void showFolderAccept(FolderRingAnimator fra) {
 543         mFolderOuterRings.add(fra);
 544     }
 545 
 546     public void hideFolderAccept(FolderRingAnimator fra) {
 547         if (mFolderOuterRings.contains(fra)) {
 548             mFolderOuterRings.remove(fra);
 549         }
 550         invalidate();
 551     }
 552 
 553     public void setFolderLeaveBehindCell(int x, int y) {
 554         mFolderLeaveBehindCell[0] = x;
 555         mFolderLeaveBehindCell[1] = y;
 556         invalidate();
 557     }
 558 
 559     public void clearFolderLeaveBehind() {
 560         mFolderLeaveBehindCell[0] = -1;
 561         mFolderLeaveBehindCell[1] = -1;
 562         invalidate();
 563     }
 564 
 565     @Override
 566     public void cancelLongPress() {
 567         super.cancelLongPress();
 568 
 569         // Cancel long press for all children
 570         final int count = getChildCount();
 571         for (int i = 0; i &lt; count; i++) {
 572             final View child = getChildAt(i);
 573             child.cancelLongPress();
 574         }
 575     }
 576 
 577     public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 578         mInterceptTouchListener = listener;
 579     }
 580 
 581     int getCountX() {
 582         return mCountX;
 583     }
 584 
 585     int getCountY() {
 586         return mCountY;
 587     }
 588 
 589     public void setIsHotseat(boolean isHotseat) {
 590         mIsHotseat = isHotseat;
 591     }
 592 
 593     public float getChildrenScale() {
 594         return mIsHotseat ? mHotseatChildScale : mChildScale;
 595     }
 596 
 597     public boolean addViewToCellLayout(
 598             View child, int index, int childId, LayoutParams params, boolean markCells) {
 599         return addViewToCellLayout(child, index, childId, params, markCells, false);
 600     }
 601 
 602     private void scaleChild(BubbleTextView bubbleChild, float pivot, float scale) {
 603         // If we haven&#x27;t measured the child yet, do it now
 604         // (this happens if we&#x27;re being dropped from all-apps
 605         if (bubbleChild.getLayoutParams() instanceof LayoutParams &amp;&amp;
 606                 (bubbleChild.getMeasuredWidth() | bubbleChild.getMeasuredHeight()) == 0) {
 607             getShortcutsAndWidgets().measureChild(bubbleChild);
 608         }
 609         int measuredWidth = bubbleChild.getMeasuredWidth();
 610         int measuredHeight = bubbleChild.getMeasuredHeight();
 611 
 612         bubbleChild.setScaleX(scale);
 613         bubbleChild.setScaleY(scale);
 614     }
 615 
 616     private void resetChild(BubbleTextView bubbleChild) {
 617         bubbleChild.setScaleX(1f);
 618         bubbleChild.setScaleY(1f);
 619 
 620         bubbleChild.setTextColor(getResources().getColor(R.color.workspace_icon_text_color));
 621     }
 622 
 623     public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 624             boolean markCells, boolean allApps) {
 625         final LayoutParams lp = params;
 626 
 627         // Hotseat icons - scale down and remove text
 628         // Don&#x27;t scale the all apps button
 629         // scale percent set to -1 means do not scale
 630         // Only scale BubbleTextViews
 631         if (child instanceof BubbleTextView) {
 632             BubbleTextView bubbleChild = (BubbleTextView) child;
 633 
 634             // Start the child with 100% scale and visible text
 635             resetChild(bubbleChild);
 636 
 637             if (mIsHotseat &amp;&amp; !allApps &amp;&amp; mHotseatChildScale &gt;= 0) {
 638                 // Scale/make transparent for a hotseat
 639                 scaleChild(bubbleChild, 0f, mHotseatChildScale);
 640 
 641                 bubbleChild.setTextColor(getResources().getColor(android.R.color.transparent));
 642             } else if (mChildScale &gt;= 0) {
 643                 // Else possibly still scale it if we need to for smaller icons
 644                 scaleChild(bubbleChild, 0f, mChildScale);
 645             }
 646         }
 647 
 648         // Generate an id for each view, this assumes we have at most 256x256 cells
 649         // per workspace screen
 650         if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 651             // If the horizontal or vertical span is set to -1, it is taken to
 652             // mean that it spans the extent of the CellLayout
 653             if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 654             if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 655 
 656             child.setId(childId);
 657 
 658             mShortcutsAndWidgets.addView(child, index, lp);
 659 
 660             if (markCells) markCellsAsOccupiedForView(child);
 661 
 662             return true;
 663         }
 664         return false;
 665     }
 666 
 667     @Override
 668     public void removeAllViews() {
 669         clearOccupiedCells();
 670         mShortcutsAndWidgets.removeAllViews();
 671     }
 672 
 673     @Override
 674     public void removeAllViewsInLayout() {
 675         if (mShortcutsAndWidgets.getChildCount() &gt; 0) {
 676             clearOccupiedCells();
 677             mShortcutsAndWidgets.removeAllViewsInLayout();
 678         }
 679     }
 680 
 681     public void removeViewWithoutMarkingCells(View view) {
 682         mShortcutsAndWidgets.removeView(view);
 683     }
 684 
 685     @Override
 686     public void removeView(View view) {
 687         markCellsAsUnoccupiedForView(view);
 688         mShortcutsAndWidgets.removeView(view);
 689     }
 690 
 691     @Override
 692     public void removeViewAt(int index) {
 693         markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
 694         mShortcutsAndWidgets.removeViewAt(index);
 695     }
 696 
 697     @Override
 698     public void removeViewInLayout(View view) {
 699         markCellsAsUnoccupiedForView(view);
 700         mShortcutsAndWidgets.removeViewInLayout(view);
 701     }
 702 
 703     @Override
 704     public void removeViews(int start, int count) {
 705         for (int i = start; i &lt; start + count; i++) {
 706             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 707         }
 708         mShortcutsAndWidgets.removeViews(start, count);
 709     }
 710 
 711     @Override
 712     public void removeViewsInLayout(int start, int count) {
 713         for (int i = start; i &lt; start + count; i++) {
 714             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 715         }
 716         mShortcutsAndWidgets.removeViewsInLayout(start, count);
 717     }
 718 
 719     @Override
 720     protected void onAttachedToWindow() {
 721         super.onAttachedToWindow();
 722         mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 723     }
 724 
 725     public void setTagToCellInfoForPoint(int touchX, int touchY) {
 726         final CellInfo cellInfo = mCellInfo;
 727         Rect frame = mRect;
 728         final int x = touchX + mScrollX;
 729         final int y = touchY + mScrollY;
 730         final int count = mShortcutsAndWidgets.getChildCount();
 731 
 732         boolean found = false;
 733         for (int i = count - 1; i &gt;= 0; i--) {
 734             final View child = mShortcutsAndWidgets.getChildAt(i);
 735             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 736 
 737             if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 738                     lp.isLockedToGrid) {
 739                 child.getHitRect(frame);
 740 
 741                 float scale = child.getScaleX();
 742                 frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 743                         child.getBottom());
 744                 // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 745                 // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 746                 // to this view.
 747                 frame.offset(mPaddingLeft, mPaddingTop);
 748                 frame.inset((int) (frame.width() * (1f - scale) / 2),
 749                         (int) (frame.height() * (1f - scale) / 2));
 750 
 751                 if (frame.contains(x, y)) {
 752                     cellInfo.cell = child;
 753                     cellInfo.cellX = lp.cellX;
 754                     cellInfo.cellY = lp.cellY;
 755                     cellInfo.spanX = lp.cellHSpan;
 756                     cellInfo.spanY = lp.cellVSpan;
 757                     found = true;
 758                     break;
 759                 }
 760             }
 761         }
 762 
 763         mLastDownOnOccupiedCell = found;
 764 
 765         if (!found) {
 766             final int cellXY[] = mTmpXY;
 767             pointToCellExact(x, y, cellXY);
 768 
 769             cellInfo.cell = null;
 770             cellInfo.cellX = cellXY[0];
 771             cellInfo.cellY = cellXY[1];
 772             cellInfo.spanX = 1;
 773             cellInfo.spanY = 1;
 774         }
 775         setTag(cellInfo);
 776     }
 777 
 778     @Override
 779     public boolean onInterceptTouchEvent(MotionEvent ev) {
 780         // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 781         // even in the case where we return early. Not clearing here was causing bugs whereby on
 782         // long-press we&#x27;d end up picking up an item from a previous drag operation.
 783         final int action = ev.getAction();
 784 
 785         if (action == MotionEvent.ACTION_DOWN) {
 786             clearTagCellInfo();
 787         }
 788 
 789         if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 790         return true;
 791     }
 792 
 793         if (action == MotionEvent.ACTION_DOWN) {
 794             setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 795         }
 796 
 797         return false;
 798     }
 799 
 800     private void clearTagCellInfo() {
 801         final CellInfo cellInfo = mCellInfo;
 802         cellInfo.cell = null;
 803         cellInfo.cellX = -1;
 804         cellInfo.cellY = -1;
 805         cellInfo.spanX = 0;
 806         cellInfo.spanY = 0;
 807         setTag(cellInfo);
 808     }
 809 
 810     public CellInfo getTag() {
 811         return (CellInfo) super.getTag();
 812     }
 813 
 814     /**
 815      * Given a point, return the cell that strictly encloses that point
 816      * @param x X coordinate of the point
 817      * @param y Y coordinate of the point
 818      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 819      */
 820     void pointToCellExact(int x, int y, int[] result) {
 821         final int hStartPadding = getPaddingLeft();
 822         final int vStartPadding = getPaddingTop();
 823 
 824         result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 825         result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 826 
 827         final int xAxis = mCountX;
 828         final int yAxis = mCountY;
 829 
 830         if (result[0] &lt; 0) result[0] = 0;
 831         if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 832         if (result[1] &lt; 0) result[1] = 0;
 833         if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 834     }
 835 
 836     /**
 837      * Given a point, return the cell that most closely encloses that point
 838      * @param x X coordinate of the point
 839      * @param y Y coordinate of the point
 840      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 841      */
 842     void pointToCellRounded(int x, int y, int[] result) {
 843         pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 844     }
 845 
 846     /**
 847      * Given a cell coordinate, return the point that represents the upper left corner of that cell
 848      *
 849      * @param cellX X coordinate of the cell
 850      * @param cellY Y coordinate of the cell
 851      *
 852      * @param result Array of 2 ints to hold the x and y coordinate of the point
 853      */
 854     void cellToPoint(int cellX, int cellY, int[] result) {
 855         final int hStartPadding = getPaddingLeft();
 856         final int vStartPadding = getPaddingTop();
 857 
 858         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 859         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 860     }
 861 
 862     /**
 863      * Given a cell coordinate, return the point that represents the center of the cell
 864      *
 865      * @param cellX X coordinate of the cell
 866      * @param cellY Y coordinate of the cell
 867      *
 868      * @param result Array of 2 ints to hold the x and y coordinate of the point
 869      */
 870     void cellToCenterPoint(int cellX, int cellY, int[] result) {
 871         final int hStartPadding = getPaddingLeft();
 872         final int vStartPadding = getPaddingTop();
 873 
 874         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) + mCellWidth / 2;
 875         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) + mCellHeight / 2;
 876     }
 877 
 878     public float getDistanceFromCell(float x, float y, int[] cell) {
 879         cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 880         float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 881                 Math.pow(y - mTmpPoint[1], 2));
 882         return distance;
 883     }
 884 
 885     int getCellWidth() {
 886         return mCellWidth;
 887     }
 888 
 889     int getCellHeight() {
 890         return mCellHeight;
 891     }
 892 
 893     int getWidthGap() {
 894         return mWidthGap;
 895     }
 896 
 897     int getHeightGap() {
 898         return mHeightGap;
 899     }
 900 
 901     Rect getContentRect(Rect r) {
 902         if (r == null) {
 903             r = new Rect();
 904         }
 905         int left = getPaddingLeft();
 906         int top = getPaddingTop();
 907         int right = left + getWidth() - mPaddingLeft - mPaddingRight;
 908         int bottom = top + getHeight() - mPaddingTop - mPaddingBottom;
 909         r.set(left, top, right, bottom);
 910         return r;
 911     }
 912 
 913     @Override
 914     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 915         // TODO: currently ignoring padding
 916 
 917         int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 918         int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 919 
 920         int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 921         int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 922 
 923         if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 924             throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 925         }
 926 
 927         int numWidthGaps = mCountX - 1;
 928         int numHeightGaps = mCountY - 1;
 929 
 930         if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 931             int hSpace = widthSpecSize - mPaddingLeft - mPaddingRight;
 932             int vSpace = heightSpecSize - mPaddingTop - mPaddingBottom;
 933             int hFreeSpace = hSpace - (mCountX * mOriginalCellWidth);
 934             int vFreeSpace = vSpace - (mCountY * mOriginalCellHeight);
 935             mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 936             mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 937             mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 938         } else {
 939             mWidthGap = mOriginalWidthGap;
 940             mHeightGap = mOriginalHeightGap;
 941         }
 942 
 943         // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 944         int newWidth = widthSpecSize;
 945         int newHeight = heightSpecSize;
 946         if (widthSpecMode == MeasureSpec.AT_MOST) {
 947             newWidth = mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
 948                 ((mCountX - 1) * mWidthGap);
 949             newHeight = mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
 950                 ((mCountY - 1) * mHeightGap);
 951             setMeasuredDimension(newWidth, newHeight);
 952         }
 953 
 954         int count = getChildCount();
 955         for (int i = 0; i &lt; count; i++) {
 956             View child = getChildAt(i);
 957             int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - mPaddingLeft -
 958                     mPaddingRight, MeasureSpec.EXACTLY);
 959             int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - mPaddingTop -
 960                     mPaddingBottom, MeasureSpec.EXACTLY);
 961             child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 962         }
 963         setMeasuredDimension(newWidth, newHeight);
 964     }
 965 
 966     @Override
 967     protected void onLayout(boolean changed, int l, int t, int r, int b) {
 968         int count = getChildCount();
 969         for (int i = 0; i &lt; count; i++) {
 970             View child = getChildAt(i);
 971             child.layout(mPaddingLeft, mPaddingTop,
 972                     r - l - mPaddingRight, b - t - mPaddingBottom);
 973         }
 974     }
 975 
 976     @Override
 977     protected void onSizeChanged(int w, int h, int oldw, int oldh) {
 978         super.onSizeChanged(w, h, oldw, oldh);
 979         mBackgroundRect.set(0, 0, w, h);
 980         mForegroundRect.set(mForegroundPadding, mForegroundPadding,
 981                 w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
 982     }
 983 
 984     @Override
 985     protected void setChildrenDrawingCacheEnabled(boolean enabled) {
 986         mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
 987     }
 988 
 989     @Override
 990     protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
 991         mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
 992     }
 993 
 994     public float getBackgroundAlpha() {
 995         return mBackgroundAlpha;
 996     }
 997 
 998     public void setBackgroundAlphaMultiplier(float multiplier) {
 999         mBackgroundAlphaMultiplier = multiplier;
1000     }
1001 
1002     public float getBackgroundAlphaMultiplier() {
1003         return mBackgroundAlphaMultiplier;
1004     }
1005 
1006     public void setBackgroundAlpha(float alpha) {
1007         if (mBackgroundAlpha != alpha) {
1008             mBackgroundAlpha = alpha;
1009             invalidate();
1010         }
1011     }
1012 
1013     public void setShortcutAndWidgetAlpha(float alpha) {
1014         final int childCount = getChildCount();
1015         for (int i = 0; i &lt; childCount; i++) {
1016             getChildAt(i).setAlpha(alpha);
1017         }
1018     }
1019 
1020     public ShortcutAndWidgetContainer getShortcutsAndWidgets() {
1021         if (getChildCount() &gt; 0) {
1022             return (ShortcutAndWidgetContainer) getChildAt(0);
1023         }
1024         return null;
1025     }
1026 
1027     public View getChildAt(int x, int y) {
1028         return mShortcutsAndWidgets.getChildAt(x, y);
1029     }
1030 
1031     public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration,
1032             int delay, boolean permanent, boolean adjustOccupied) {
1033         ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();
1034         boolean[][] occupied = mOccupied;
1035         if (!permanent) {
1036             occupied = mTmpOccupied;
1037         }
1038 
1039         if (clc.indexOfChild(child) != -1 &amp;&amp; !occupied[cellX][cellY]) {
1040             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
1041             final ItemInfo info = (ItemInfo) child.getTag();
1042 
1043             // We cancel any existing animations
1044             if (mReorderAnimators.containsKey(lp)) {
1045                 mReorderAnimators.get(lp).cancel();
1046                 mReorderAnimators.remove(lp);
1047             }
1048 
1049             final int oldX = lp.x;
1050             final int oldY = lp.y;
1051             if (adjustOccupied) {
1052                 occupied[lp.cellX][lp.cellY] = false;
1053                 occupied[cellX][cellY] = true;
1054             }
1055             lp.isLockedToGrid = true;
1056             if (permanent) {
1057                 lp.cellX = info.cellX = cellX;
1058                 lp.cellY = info.cellY = cellY;
1059             } else {
1060                 lp.tmpCellX = cellX;
1061                 lp.tmpCellY = cellY;
1062             }
1063             clc.setupLp(lp);
1064             lp.isLockedToGrid = false;
1065             final int newX = lp.x;
1066             final int newY = lp.y;
1067 
1068             lp.x = oldX;
1069             lp.y = oldY;
1070 
1071             // Exit early if we&#x27;re not actually moving the view
1072             if (oldX == newX &amp;&amp; oldY == newY) {
1073                 lp.isLockedToGrid = true;
1074                 return true;
1075             }
1076 
1077             ValueAnimator va = ValueAnimator.ofFloat(0f, 1f);
1078             va.setDuration(duration);
1079             mReorderAnimators.put(lp, va);
1080 
1081             va.addUpdateListener(new AnimatorUpdateListener() {
1082                 @Override
1083                 public void onAnimationUpdate(ValueAnimator animation) {
1084                     float r = ((Float) animation.getAnimatedValue()).floatValue();
1085                     child.setTranslationX(r * (newX - oldX));
1086                     child.setTranslationY(r * (newY - oldY));
1087                 }
1088             });
1089             va.addListener(new AnimatorListenerAdapter() {
1090                 boolean cancelled = false;
1091                 public void onAnimationEnd(Animator animation) {
1092                     // If the animation was cancelled, it means that another animation
1093                     // has interrupted this one, and we don&#x27;t want to lock the item into
1094                     // place just yet.
1095                     if (!cancelled) {
1096                         child.setTranslationX(0);
1097                         child.setTranslationY(0);
1098                         lp.isLockedToGrid = true;
1099                         child.requestLayout();
1100                     }
1101                     if (mReorderAnimators.containsKey(lp)) {
1102                         mReorderAnimators.remove(lp);
1103                     }
1104                 }
1105                 public void onAnimationCancel(Animator animation) {
1106                     cancelled = true;
1107                 }
1108             });
1109             va.setStartDelay(delay);
1110             va.start();
1111             return true;
1112         }
1113         return false;
1114     }
1115 
1116     /**
1117      * Estimate where the top left cell of the dragged item will land if it is dropped.
1118      *
1119      * @param originX The X value of the top left corner of the item
1120      * @param originY The Y value of the top left corner of the item
1121      * @param spanX The number of horizontal cells that the item spans
1122      * @param spanY The number of vertical cells that the item spans
1123      * @param result The estimated drop cell X and Y.
1124      */
1125     void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1126         final int countX = mCountX;
1127         final int countY = mCountY;
1128 
1129         // pointToCellRounded takes the top left of a cell but will pad that with
1130         // cellWidth/2 and cellHeight/2 when finding the matching cell
1131         pointToCellRounded(originX, originY, result);
1132 
1133         // If the item isn&#x27;t fully on this screen, snap to the edges
1134         int rightOverhang = result[0] + spanX - countX;
1135         if (rightOverhang &gt; 0) {
1136             result[0] -= rightOverhang; // Snap to right
1137         }
1138         result[0] = Math.max(0, result[0]); // Snap to left
1139         int bottomOverhang = result[1] + spanY - countY;
1140         if (bottomOverhang &gt; 0) {
1141             result[1] -= bottomOverhang; // Snap to bottom
1142         }
1143         result[1] = Math.max(0, result[1]); // Snap to top
1144     }
1145 
1146     void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1147             int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1148         final int oldDragCellX = mDragCell[0];
1149         final int oldDragCellY = mDragCell[1];
1150 
1151         if (v != null &amp;&amp; dragOffset == null) {
1152             mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1153         } else {
1154             mDragCenter.set(originX, originY);
1155         }
1156 
1157         if (dragOutline == null &amp;&amp; v == null) {
1158             if (mCrosshairsDrawable != null) {
1159                 invalidate();
1160             }
1161             return;
1162         }
1163 
1164         if (cellX != oldDragCellX || cellY != oldDragCellY) {
1165             mDragCell[0] = cellX;
1166             mDragCell[1] = cellY;
1167             // Find the top left corner of the rect the object will occupy
1168             final int[] topLeft = mTmpPoint;
1169             cellToPoint(cellX, cellY, topLeft);
1170 
1171             int left = topLeft[0];
1172             int top = topLeft[1];
1173 
1174             if (v != null &amp;&amp; dragOffset == null) {
1175                 // When drawing the drag outline, it did not account for margin offsets
1176                 // added by the view&#x27;s parent.
1177                 MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1178                 left += lp.leftMargin;
1179                 top += lp.topMargin;
1180 
1181                 // Offsets due to the size difference between the View and the dragOutline.
1182                 // There is a size difference to account for the outer blur, which may lie
1183                 // outside the bounds of the view.
1184                 top += (v.getHeight() - dragOutline.getHeight()) / 2;
1185                 // We center about the x axis
1186                 left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1187                         - dragOutline.getWidth()) / 2;
1188             } else {
1189                 if (dragOffset != null &amp;&amp; dragRegion != null) {
1190                     // Center the drag region *horizontally* in the cell and apply a drag
1191                     // outline offset
1192                     left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1193                              - dragRegion.width()) / 2;
1194                     top += dragOffset.y;
1195                 } else {
1196                     // Center the drag outline in the cell
1197                     left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1198                             - dragOutline.getWidth()) / 2;
1199                     top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1200                             - dragOutline.getHeight()) / 2;
1201                 }
1202             }
1203             final int oldIndex = mDragOutlineCurrent;
1204             mDragOutlineAnims[oldIndex].animateOut();
1205             mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1206             Rect r = mDragOutlines[mDragOutlineCurrent];
1207             r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1208             if (resize) {
1209                 cellToRect(cellX, cellY, spanX, spanY, r);
1210             }
1211 
1212             mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1213             mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1214         }
1215 
1216         // If we are drawing crosshairs, the entire CellLayout needs to be invalidated
1217         if (mCrosshairsDrawable != null) {
1218             invalidate();
1219         }
1220     }
1221 
1222     public void clearDragOutlines() {
1223         final int oldIndex = mDragOutlineCurrent;
1224         mDragOutlineAnims[oldIndex].animateOut();
1225         mDragCell[0] = mDragCell[1] = -1;
1226     }
1227 
1228     /**
1229      * Find a vacant area that will fit the given bounds nearest the requested
1230      * cell location. Uses Euclidean distance to score multiple vacant areas.
1231      *
1232      * @param pixelX The X location at which you want to search for a vacant area.
1233      * @param pixelY The Y location at which you want to search for a vacant area.
1234      * @param spanX Horizontal span of the object.
1235      * @param spanY Vertical span of the object.
1236      * @param result Array in which to place the result, or null (in which case a new array will
1237      *        be allocated)
1238      * @return The X, Y cell of a vacant area that can contain this object,
1239      *         nearest the requested location.
1240      */
1241     int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1242             int[] result) {
1243         return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1244     }
1245 
1246     /**
1247      * Find a vacant area that will fit the given bounds nearest the requested
1248      * cell location. Uses Euclidean distance to score multiple vacant areas.
1249      *
1250      * @param pixelX The X location at which you want to search for a vacant area.
1251      * @param pixelY The Y location at which you want to search for a vacant area.
1252      * @param minSpanX The minimum horizontal span required
1253      * @param minSpanY The minimum vertical span required
1254      * @param spanX Horizontal span of the object.
1255      * @param spanY Vertical span of the object.
1256      * @param result Array in which to place the result, or null (in which case a new array will
1257      *        be allocated)
1258      * @return The X, Y cell of a vacant area that can contain this object,
1259      *         nearest the requested location.
1260      */
1261     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1262             int spanY, int[] result, int[] resultSpan) {
1263         return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1264                 result, resultSpan);
1265     }
1266 
1267     /**
1268      * Find a vacant area that will fit the given bounds nearest the requested
1269      * cell location. Uses Euclidean distance to score multiple vacant areas.
1270      *
1271      * @param pixelX The X location at which you want to search for a vacant area.
1272      * @param pixelY The Y location at which you want to search for a vacant area.
1273      * @param spanX Horizontal span of the object.
1274      * @param spanY Vertical span of the object.
1275      * @param ignoreOccupied If true, the result can be an occupied cell
1276      * @param result Array in which to place the result, or null (in which case a new array will
1277      *        be allocated)
1278      * @return The X, Y cell of a vacant area that can contain this object,
1279      *         nearest the requested location.
1280      */
1281     int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1282             boolean ignoreOccupied, int[] result) {
1283         return findNearestArea(pixelX, pixelY, spanX, spanY,
1284                 spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1285     }
1286 
1287     private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1288     private void lazyInitTempRectStack() {
1289         if (mTempRectStack.isEmpty()) {
1290             for (int i = 0; i &lt; mCountX * mCountY; i++) {
1291                 mTempRectStack.push(new Rect());
1292             }
1293         }
1294     }
1295 
1296     private void recycleTempRects(Stack&lt;Rect&gt; used) {
1297         while (!used.isEmpty()) {
1298             mTempRectStack.push(used.pop());
1299         }
1300     }
1301 
1302     /**
1303      * Find a vacant area that will fit the given bounds nearest the requested
1304      * cell location. Uses Euclidean distance to score multiple vacant areas.
1305      *
1306      * @param pixelX The X location at which you want to search for a vacant area.
1307      * @param pixelY The Y location at which you want to search for a vacant area.
1308      * @param minSpanX The minimum horizontal span required
1309      * @param minSpanY The minimum vertical span required
1310      * @param spanX Horizontal span of the object.
1311      * @param spanY Vertical span of the object.
1312      * @param ignoreOccupied If true, the result can be an occupied cell
1313      * @param result Array in which to place the result, or null (in which case a new array will
1314      *        be allocated)
1315      * @return The X, Y cell of a vacant area that can contain this object,
1316      *         nearest the requested location.
1317      */
1318     int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1319             View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1320             boolean[][] occupied) {
1321         lazyInitTempRectStack();
1322         // mark space take by ignoreView as available (method checks if ignoreView is null)
1323         markCellsAsUnoccupiedForView(ignoreView, occupied);
1324 
1325         // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1326         // to the center of the item, but we are searching based on the top-left cell, so
1327         // we translate the point over to correspond to the top-left.
1328         pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1329         pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1330 
1331         // Keep track of best-scoring drop area
1332         final int[] bestXY = result != null ? result : new int[2];
1333         double bestDistance = Double.MAX_VALUE;
1334         final Rect bestRect = new Rect(-1, -1, -1, -1);
1335         final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1336 
1337         final int countX = mCountX;
1338         final int countY = mCountY;
1339 
1340         if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1341                 spanX &lt; minSpanX || spanY &lt; minSpanY) {
1342             return bestXY;
1343         }
1344 
1345         for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1346             inner:
1347             for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1348                 int ySize = -1;
1349                 int xSize = -1;
1350                 if (ignoreOccupied) {
1351                     // First, let&#x27;s see if this thing fits anywhere
1352                     for (int i = 0; i &lt; minSpanX; i++) {
1353                         for (int j = 0; j &lt; minSpanY; j++) {
1354                             if (occupied[x + i][y + j]) {
1355                                 continue inner;
1356                             }
1357                         }
1358                     }
1359                     xSize = minSpanX;
1360                     ySize = minSpanY;
1361 
1362                     // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1363                     // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1364                     // until we hit a limit.
1365                     boolean incX = true;
1366                     boolean hitMaxX = xSize &gt;= spanX;
1367                     boolean hitMaxY = ySize &gt;= spanY;
1368                     while (!(hitMaxX &amp;&amp; hitMaxY)) {
1369                         if (incX &amp;&amp; !hitMaxX) {
1370                             for (int j = 0; j &lt; ySize; j++) {
1371                                 if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1372                                     // We can&#x27;t move out horizontally
1373                                     hitMaxX = true;
1374                                 }
1375                             }
1376                             if (!hitMaxX) {
1377                                 xSize++;
1378                             }
1379                         } else if (!hitMaxY) {
1380                             for (int i = 0; i &lt; xSize; i++) {
1381                                 if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1382                                     // We can&#x27;t move out vertically
1383                                     hitMaxY = true;
1384                                 }
1385                             }
1386                             if (!hitMaxY) {
1387                                 ySize++;
1388                             }
1389                         }
1390                         hitMaxX |= xSize &gt;= spanX;
1391                         hitMaxY |= ySize &gt;= spanY;
1392                         incX = !incX;
1393                     }
1394                     incX = true;
1395                     hitMaxX = xSize &gt;= spanX;
1396                     hitMaxY = ySize &gt;= spanY;
1397                 }
1398                 final int[] cellXY = mTmpXY;
1399                 cellToCenterPoint(x, y, cellXY);
1400 
1401                 // We verify that the current rect is not a sub-rect of any of our previous
1402                 // candidates. In this case, the current rect is disqualified in favour of the
1403                 // containing rect.
1404                 Rect currentRect = mTempRectStack.pop();
1405                 currentRect.set(x, y, x + xSize, y + ySize);
1406                 boolean contained = false;
1407                 for (Rect r : validRegions) {
1408                     if (r.contains(currentRect)) {
1409                         contained = true;
1410                         break;
1411                     }
1412                 }
1413                 validRegions.push(currentRect);
1414                 double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1415                         + Math.pow(cellXY[1] - pixelY, 2));
1416 
1417                 if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1418                         currentRect.contains(bestRect)) {
1419                     bestDistance = distance;
1420                     bestXY[0] = x;
1421                     bestXY[1] = y;
1422                     if (resultSpan != null) {
1423                         resultSpan[0] = xSize;
1424                         resultSpan[1] = ySize;
1425                     }
1426                     bestRect.set(currentRect);
1427                 }
1428             }
1429         }
1430         // re-mark space taken by ignoreView as occupied
1431         markCellsAsOccupiedForView(ignoreView, occupied);
1432 
1433         // Return -1, -1 if no suitable location found
1434         if (bestDistance == Double.MAX_VALUE) {
1435             bestXY[0] = -1;
1436             bestXY[1] = -1;
1437         }
1438         recycleTempRects(validRegions);
1439         return bestXY;
1440     }
1441 
1442      /**
1443      * Find a vacant area that will fit the given bounds nearest the requested
1444      * cell location, and will also weigh in a suggested direction vector of the
1445      * desired location. This method computers distance based on unit grid distances,
1446      * not pixel distances.
1447      *
1448      * @param pixelX The X location at which you want to search for a vacant area.
1449      * @param pixelY The Y location at which you want to search for a vacant area.
1450      * @param minSpanX The minimum horizontal span required
1451      * @param minSpanY The minimum vertical span required
1452      * @param spanX Horizontal span of the object.
1453      * @param spanY Vertical span of the object.
1454      * @param ignoreOccupied If true, the result can be an occupied cell
1455      * @param result Array in which to place the result, or null (in which case a new array will
1456      *        be allocated)
1457      * @return The X, Y cell of a vacant area that can contain this object,
1458      *         nearest the requested location.
1459      */
1460     private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
1461             boolean[][] occupied, int[] result) {
1462         // Keep track of best-scoring drop area
1463         final int[] bestXY = result != null ? result : new int[2];
1464         float bestDistance = Float.MAX_VALUE;
1465         int bestDirectionScore = Integer.MIN_VALUE;
1466 
1467         final int countX = mCountX;
1468         final int countY = mCountY;
1469 
1470         for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1471             inner:
1472             for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1473                 // First, let&#x27;s see if this thing fits anywhere
1474                 for (int i = 0; i &lt; spanX; i++) {
1475                     for (int j = 0; j &lt; spanY; j++) {
1476                         if (occupied[x + i][y + j]) {
1477                             continue inner;
1478                         }
1479                     }
1480                 }
1481 
1482                 float distance = (float)
1483                         Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1484                 int[] curDirection = mTmpPoint;
1485                 computeDirectionVector(cellX, cellY, x, y, curDirection);
1486                 int curDirectionScore = direction[0] * curDirection[0] +
1487                         direction[1] * curDirection[1];
1488 
1489                 if (Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,
1490                         bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1491                     bestDistance = distance;
1492                     bestDirectionScore = curDirectionScore;
1493                     bestXY[0] = x;
1494                     bestXY[1] = y;
1495                 }
1496             }
1497         }
1498 
1499         // Return -1, -1 if no suitable location found
1500         if (bestDistance == Float.MAX_VALUE) {
1501             bestXY[0] = -1;
1502             bestXY[1] = -1;
1503         }
1504         return bestXY;
1505     }
1506 
1507     private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1508             int[] direction) {
1509         LayoutParams lp = (LayoutParams) v.getLayoutParams();
1510         boolean success = false;
1511         markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1512                 lp.cellVSpan, mTmpOccupied, false);
1513         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1514 
1515         findNearestArea(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,
1516                 direction, mTmpOccupied, mTempLocation);
1517 
1518         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1519             lp.tmpCellX = mTempLocation[0];
1520             lp.tmpCellY = mTempLocation[1];
1521             success = true;
1522 
1523         }
1524         markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1525                 lp.cellVSpan, mTmpOccupied, true);
1526         return success;
1527     }
1528 
1529 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1530 private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1531             boolean[][] occupied) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1532         boolean found = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1533 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1534         int childCount = mShortcutsAndWidgets.getChildCount();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1535         Rect r0 = new Rect(boundingRect);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1536         Rect r1 = new Rect();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1537 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1538         int deltaX = 0;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1539         int deltaY = 0;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1540         if (direction[1] &lt; 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1541             r0.set(r0.left, r0.top - 1, r0.right, r0.bottom);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1542             deltaY = -1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1543         } else if (direction[1] &gt; 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1544             r0.set(r0.left, r0.top, r0.right, r0.bottom + 1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1545             deltaY = 1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1546         } else if (direction[0] &lt; 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1547             r0.set(r0.left - 1, r0.top, r0.right, r0.bottom);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1548             deltaX = -1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1549         } else if (direction[0] &gt; 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1550             r0.set(r0.left, r0.top, r0.right + 1, r0.bottom);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1551             deltaX = 1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1552         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1553 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1554         for (int i = 0; i &lt; childCount; i++) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1555             View child = mShortcutsAndWidgets.getChildAt(i);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1556             if (views.contains(child)) continue;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1557             LayoutParams lp = (LayoutParams) child.getLayoutParams();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1558 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1559             r1.set(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1560             if (Rect.intersects(r0, r1)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1561                 if (!lp.canReorder) {</span>
1562 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1563 private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1564             boolean[][] occupied) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1565         boolean found = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1566 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1567         int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1568         Rect r0 = new Rect(boundingRect);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1569         Rect r1 = new Rect();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1570 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1571         int deltaX = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1572         int deltaY = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1573         if (direction[1] &lt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1574             r0.set(r0.left, r0.top - 1, r0.right, r0.bottom);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1575             deltaY = -1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1576         } else if (direction[1] &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1577             r0.set(r0.left, r0.top, r0.right, r0.bottom + 1);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1578             deltaY = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1579         } else if (direction[0] &lt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1580             r0.set(r0.left - 1, r0.top, r0.right, r0.bottom);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1581             deltaX = -1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1582         } else if (direction[0] &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1583             r0.set(r0.left, r0.top, r0.right + 1, r0.bottom);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1584             deltaX = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1585         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1586 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1587         for (int i = 0; i &lt; childCount; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1588             View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1589             if (views.contains(child)) continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1590             LayoutParams lp = (LayoutParams) child.getLayoutParams();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1591 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1592             r1.set(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1593             if (Rect.intersects(r0, r1)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1594                 if (!lp.canReorder) {</span>
1595 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1596 @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1597     public boolean shouldDelayChildPressedState() {</span>
1598 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1599                     return false;
1600                 }
1601 
1602     private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1603             int[] direction) {
1604         if (views.size() == 0) return true;
1605         boolean success = false;
1606 
1607         // We construct a rect which represents the entire group of views
1608         Rect boundingRect = null;
1609         for (View v: views) {
1610             LayoutParams lp = (LayoutParams) v.getLayoutParams();
1611             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1612                     lp.cellVSpan, mTmpOccupied, false);
1613             if (boundingRect == null) {
1614                 boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1615                         lp.tmpCellY + lp.cellVSpan);
1616             } else {
1617                 boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1618                         lp.tmpCellY + lp.cellVSpan);
1619             }
1620         }
1621         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1622 
1623         // TODO: this bounding rect may not be completely filled, lets be more precise about this
1624         // check.
1625         findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(), boundingRect.height(),
1626                 direction, mTmpOccupied, mTempLocation);
1627 
1628         int deltaX = mTempLocation[0] - boundingRect.left;
1629         int deltaY = mTempLocation[1] - boundingRect.top;
1630         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1631             for (View v: views) {
1632                 LayoutParams lp = (LayoutParams) v.getLayoutParams();
1633                 lp.tmpCellX += deltaX;
1634                 lp.tmpCellY += deltaY;
1635             }
1636             success = true;
1637         }
1638         for (View v: views) {
1639             LayoutParams lp = (LayoutParams) v.getLayoutParams();
1640             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1641                     lp.cellVSpan, mTmpOccupied, true);
1642         }
1643         return success;
1644     }
1645 
1646     private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1647         markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1648     }
1649 
1650     private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1651             View ignoreView) {
1652         mIntersectingViews.clear();
1653 
1654         mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
1655         markCellsForRect(mOccupiedRect, mTmpOccupied, true);
1656 
1657         if (ignoreView != null) {
1658             LayoutParams lp = (LayoutParams) ignoreView.getLayoutParams();
1659             lp.tmpCellX = cellX;
1660             lp.tmpCellY = cellY;
1661         }
1662 
1663         int childCount = mShortcutsAndWidgets.getChildCount();
1664         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1665         Rect r1 = new Rect();
1666         for (int i = 0; i &lt; childCount; i++) {
1667             View child = mShortcutsAndWidgets.getChildAt(i);
1668             if (child == ignoreView) continue;
1669             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1670             r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
1671             if (Rect.intersects(r0, r1)) {
1672                 if (!lp.canReorder) {
1673                     return false;
1674                 }
1675                 mIntersectingViews.add(child);
1676             }
1677         }
1678         // First we try moving the views as a block
1679         if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {
1680             return true;
1681         }
1682         // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1683         for (View v : mIntersectingViews) {
1684             if (!addViewToTempLocation(v, mOccupiedRect, direction)) {
1685                 return false;
1686             }
1687         }
1688         return true;
1689     }
1690 
1691     /*
1692      * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1693      * the provided point and the provided cell
1694      */
1695     private void computeDirectionVector(int x0, int y0, int x1, int y1, int[] result) {
1696         int deltaX = x1 - x0;
1697         int deltaY = y1 - y0;
1698 
1699         double angle = Math.atan(((float) deltaY) / deltaX);
1700 
1701         result[0] = 0;
1702         result[1] = 0;
1703         if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1704             result[0] = (int) Math.signum(deltaX);
1705         }
1706         if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1707             result[1] = (int) Math.signum(deltaY);
1708         }
1709     }
1710 
1711     ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1712             int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1713         // This creates a copy of the current occupied array, omitting the current view being
1714         // dragged
1715         resetTempLayoutToCurrent(dragView);
1716 
1717         // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1718         // nothing in its way.
1719         int result[] = new int[2];
1720         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1721 
1722         boolean success = false;
1723         // First we try the exact nearest position of the item being dragged,
1724         // we will then want to try to move this around to other neighbouring positions
1725         success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView);
1726 
1727         if (!success) {
1728             // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1729             // x, then 1 in y etc.
1730             if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1731                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1732                         dragView, false, solution);
1733             } else if (spanY &gt; minSpanY) {
1734                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1735                         dragView, true, solution);
1736             }
1737             solution.isSolution = false;
1738         } else {
1739             solution.isSolution = true;
1740             solution.dragViewX = result[0];
1741             solution.dragViewY = result[1];
1742             solution.dragViewSpanX = spanX;
1743             solution.dragViewSpanY = spanY;
1744             copyCurrentStateToSolution(solution, true);
1745         }
1746         return solution;
1747     }
1748 
1749     private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1750         int childCount = mShortcutsAndWidgets.getChildCount();
1751         for (int i = 0; i &lt; childCount; i++) {
1752             View child = mShortcutsAndWidgets.getChildAt(i);
1753             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1754             Point p;
1755             if (temp) {
1756                 p = new Point(lp.tmpCellX, lp.tmpCellY);
1757             } else {
1758                 p = new Point(lp.cellX, lp.cellY);
1759             }
1760             solution.map.put(child, p);
1761         }
1762     }
1763 
1764     private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1765         for (int i = 0; i &lt; mCountX; i++) {
1766             for (int j = 0; j &lt; mCountY; j++) {
1767                 mTmpOccupied[i][j] = false;
1768             }
1769         }
1770 
1771         int childCount = mShortcutsAndWidgets.getChildCount();
1772         for (int i = 0; i &lt; childCount; i++) {
1773             View child = mShortcutsAndWidgets.getChildAt(i);
1774             if (child == dragView) continue;
1775             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1776             Point p = solution.map.get(child);
1777             if (p != null) {
1778                 lp.tmpCellX = p.x;
1779                 lp.tmpCellY = p.y;
1780                 markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,
1781                         mTmpOccupied, true);
1782             }
1783         }
1784         markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1785                 solution.dragViewSpanY, mTmpOccupied, true);
1786     }
1787 
1788     private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
1789             commitDragView) {
1790 
1791         boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
1792         for (int i = 0; i &lt; mCountX; i++) {
1793             for (int j = 0; j &lt; mCountY; j++) {
1794                 occupied[i][j] = false;
1795             }
1796         }
1797 
1798         int childCount = mShortcutsAndWidgets.getChildCount();
1799         for (int i = 0; i &lt; childCount; i++) {
1800             View child = mShortcutsAndWidgets.getChildAt(i);
1801             if (child == dragView) continue;
1802             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1803             Point p = solution.map.get(child);
1804             if (p != null) {
1805                 if (lp.cellX != p.x || lp.cellY != p.y) {
1806                     animateChildToPosition(child, p.x, p.y, 150, 0, DESTRUCTIVE_REORDER, false);
1807                 }
1808                 markCellsForView(p.x, p.y, lp.cellHSpan, lp.cellVSpan, occupied, true);
1809             }
1810         }
1811         if (commitDragView) {
1812             markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1813                     solution.dragViewSpanY, occupied, true);
1814         }
1815     }
1816 
1817     private void commitTempPlacement() {
1818         for (int i = 0; i &lt; mCountX; i++) {
1819             for (int j = 0; j &lt; mCountY; j++) {
1820                 mOccupied[i][j] = mTmpOccupied[i][j];
1821             }
1822         }
1823         int childCount = mShortcutsAndWidgets.getChildCount();
1824         for (int i = 0; i &lt; childCount; i++) {
1825             LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
1826             lp.cellX = lp.tmpCellX;
1827             lp.cellY = lp.tmpCellY;
1828         }
1829     }
1830 
1831     public void setUseTempCoords(boolean useTempCoords) {
1832         int childCount = mShortcutsAndWidgets.getChildCount();
1833         for (int i = 0; i &lt; childCount; i++) {
1834             LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
1835             lp.useTmpCoords = useTempCoords;
1836         }
1837     }
1838 
1839     private void resetTempLayoutToCurrent(View ignoreView) {
1840         for (int i = 0; i &lt; mCountX; i++) {
1841             for (int j = 0; j &lt; mCountY; j++) {
1842                 mTmpOccupied[i][j] = mOccupied[i][j];
1843             }
1844         }
1845         int childCount = mShortcutsAndWidgets.getChildCount();
1846         for (int i = 0; i &lt; childCount; i++) {
1847             View child = mShortcutsAndWidgets.getChildAt(i);
1848             if (child == ignoreView) continue;
1849             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1850             lp.tmpCellX = lp.cellX;
1851             lp.tmpCellY = lp.cellY;
1852         }
1853     }
1854 
1855     ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
1856             int spanX, int spanY, View dragView, ItemConfiguration solution) {
1857         int[] result = new int[2];
1858         int[] resultSpan = new int[2];
1859         findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
1860                 resultSpan);
1861         if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
1862             copyCurrentStateToSolution(solution, false);
1863             solution.dragViewX = result[0];
1864             solution.dragViewY = result[1];
1865             solution.dragViewSpanX = resultSpan[0];
1866             solution.dragViewSpanY = resultSpan[1];
1867             solution.isSolution = true;
1868         } else {
1869             solution.isSolution = false;
1870         }
1871         return solution;
1872     }
1873 
1874     public void prepareChildForDrag(View child) {
1875         markCellsAsUnoccupiedForView(child);
1876         LayoutParams lp = (LayoutParams) child.getLayoutParams();
1877         lp.cellX = -1;
1878         lp.cellY = -1;
1879 
1880     }
1881 
1882     int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1883             View dragView, int[] result, int resultSpan[], int mode) {
1884 
1885         // First we determine if things have moved enough to cause a different layout
1886         result = findNearestArea(pixelX, pixelY, 1, 1, result);
1887 
1888         if (resultSpan == null) {
1889             resultSpan = new int[2];
1890         }
1891 
1892         // We attempt the first algorithm
1893         cellToCenterPoint(result[0], result[1], mTmpPoint);
1894         computeDirectionVector(pixelX, pixelY, mTmpPoint[0], mTmpPoint[1], mDirectionVector);
1895         ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
1896                  spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
1897 
1898         // We attempt the approach which doesn&#x27;t shuffle views at all
1899         ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
1900                 minSpanY, spanX, spanY, dragView, new ItemConfiguration());
1901 
1902         ItemConfiguration finalSolution = null;
1903         if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
1904             finalSolution = swapSolution;
1905         } else if (noShuffleSolution.isSolution) {
1906             finalSolution = noShuffleSolution;
1907         }
1908 
1909         boolean foundSolution = true;
1910         if (!DESTRUCTIVE_REORDER) {
1911             setUseTempCoords(true);
1912         }
1913 
1914         if (finalSolution != null) {
1915             result[0] = finalSolution.dragViewX;
1916             result[1] = finalSolution.dragViewY;
1917             resultSpan[0] = finalSolution.dragViewSpanX;
1918             resultSpan[1] = finalSolution.dragViewSpanY;
1919 
1920             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
1921             // committing anything or animating anything as we just want to determine if a solution
1922             // exists
1923             if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
1924                 if (!DESTRUCTIVE_REORDER) {
1925                     copySolutionToTempState(finalSolution, dragView);
1926                 }
1927                 setItemPlacementDirty(true);
1928                 animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
1929 
1930                 if (!DESTRUCTIVE_REORDER &amp;&amp; mode == MODE_ON_DROP) {
1931                     commitTempPlacement();
1932                 }
1933             }
1934         } else {
1935             foundSolution = false;
1936             result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
1937         }
1938 
1939         if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
1940             setUseTempCoords(false);
1941         }
1942         boolean[][] occupied = mOccupied;
1943 
1944         mShortcutsAndWidgets.requestLayout();
1945         return result;
1946     }
1947 
1948     public boolean isItemPlacementDirty() {
1949         return mItemLocationsDirty;
1950     }
1951 
1952     public void setItemPlacementDirty(boolean dirty) {
1953         mItemLocationsDirty = dirty;
1954     }
1955 
1956     private class ItemConfiguration {
1957         HashMap&lt;View, Point&gt; map = new HashMap&lt;View, Point&gt;();
1958         boolean isSolution = false;
1959         int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
1960 
1961         int area() {
1962             return dragViewSpanX * dragViewSpanY;
1963         }
1964         void clear() {
1965             map.clear();
1966             isSolution = false;
1967         }
1968     }
1969 
1970     /**
1971      * Find a vacant area that will fit the given bounds nearest the requested
1972      * cell location. Uses Euclidean distance to score multiple vacant areas.
1973      *
1974      * @param pixelX The X location at which you want to search for a vacant area.
1975      * @param pixelY The Y location at which you want to search for a vacant area.
1976      * @param spanX Horizontal span of the object.
1977      * @param spanY Vertical span of the object.
1978      * @param ignoreView Considers space occupied by this view as unoccupied
1979      * @param result Previously returned value to possibly recycle.
1980      * @return The X, Y cell of a vacant area that can contain this object,
1981      *         nearest the requested location.
1982      */
1983     int[] findNearestVacantArea(
1984             int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
1985         return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
1986     }
1987 
1988     /**
1989      * Find a vacant area that will fit the given bounds nearest the requested
1990      * cell location. Uses Euclidean distance to score multiple vacant areas.
1991      *
1992      * @param pixelX The X location at which you want to search for a vacant area.
1993      * @param pixelY The Y location at which you want to search for a vacant area.
1994      * @param minSpanX The minimum horizontal span required
1995      * @param minSpanY The minimum vertical span required
1996      * @param spanX Horizontal span of the object.
1997      * @param spanY Vertical span of the object.
1998      * @param ignoreView Considers space occupied by this view as unoccupied
1999      * @param result Previously returned value to possibly recycle.
2000      * @return The X, Y cell of a vacant area that can contain this object,
2001      *         nearest the requested location.
2002      */
2003     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2004             int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2005         return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2006                 result, resultSpan, mOccupied);
2007     }
2008 
2009     /**
2010      * Find a starting cell position that will fit the given bounds nearest the requested
2011      * cell location. Uses Euclidean distance to score multiple vacant areas.
2012      *
2013      * @param pixelX The X location at which you want to search for a vacant area.
2014      * @param pixelY The Y location at which you want to search for a vacant area.
2015      * @param spanX Horizontal span of the object.
2016      * @param spanY Vertical span of the object.
2017      * @param ignoreView Considers space occupied by this view as unoccupied
2018      * @param result Previously returned value to possibly recycle.
2019      * @return The X, Y cell of a vacant area that can contain this object,
2020      *         nearest the requested location.
2021      */
2022     int[] findNearestArea(
2023             int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2024         return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2025     }
2026 
2027     boolean existsEmptyCell() {
2028         return findCellForSpan(null, 1, 1);
2029     }
2030 
2031     /**
2032      * Finds the upper-left coordinate of the first rectangle in the grid that can
2033      * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2034      * then this method will only return coordinates for rectangles that contain the cell
2035      * (intersectX, intersectY)
2036      *
2037      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2038      *               can be found.
2039      * @param spanX The horizontal span of the cell we want to find.
2040      * @param spanY The vertical span of the cell we want to find.
2041      *
2042      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2043      */
2044     boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2045         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2046     }
2047 
2048     /**
2049      * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2050      *
2051      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2052      *               can be found.
2053      * @param spanX The horizontal span of the cell we want to find.
2054      * @param spanY The vertical span of the cell we want to find.
2055      * @param ignoreView The home screen item we should treat as not occupying any space
2056      * @return
2057      */
2058     boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2059         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2060                 ignoreView, mOccupied);
2061     }
2062 
2063     /**
2064      * Like above, but if intersectX and intersectY are not -1, then this method will try to
2065      * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2066      *
2067      * @param spanX The horizontal span of the cell we want to find.
2068      * @param spanY The vertical span of the cell we want to find.
2069      * @param ignoreView The home screen item we should treat as not occupying any space
2070      * @param intersectX The X coordinate of the cell that we should try to overlap
2071      * @param intersectX The Y coordinate of the cell that we should try to overlap
2072      *
2073      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2074      */
2075     boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2076             int intersectX, int intersectY) {
2077         return findCellForSpanThatIntersectsIgnoring(
2078                 cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2079     }
2080 
2081     /**
2082      * The superset of the above two methods
2083      */
2084     boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2085             int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2086         // mark space take by ignoreView as available (method checks if ignoreView is null)
2087         markCellsAsUnoccupiedForView(ignoreView, occupied);
2088 
2089         boolean foundCell = false;
2090         while (true) {
2091             int startX = 0;
2092             if (intersectX &gt;= 0) {
2093                 startX = Math.max(startX, intersectX - (spanX - 1));
2094             }
2095             int endX = mCountX - (spanX - 1);
2096             if (intersectX &gt;= 0) {
2097                 endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2098             }
2099             int startY = 0;
2100             if (intersectY &gt;= 0) {
2101                 startY = Math.max(startY, intersectY - (spanY - 1));
2102             }
2103             int endY = mCountY - (spanY - 1);
2104             if (intersectY &gt;= 0) {
2105                 endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2106             }
2107 
2108             for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2109                 inner:
2110                 for (int x = startX; x &lt; endX; x++) {
2111                     for (int i = 0; i &lt; spanX; i++) {
2112                         for (int j = 0; j &lt; spanY; j++) {
2113                             if (occupied[x + i][y + j]) {
2114                                 // small optimization: we can skip to after the column we just found
2115                                 // an occupied cell
2116                                 x += i;
2117                                 continue inner;
2118                             }
2119                         }
2120                     }
2121                     if (cellXY != null) {
2122                         cellXY[0] = x;
2123                         cellXY[1] = y;
2124                     }
2125                     foundCell = true;
2126                     break;
2127                 }
2128             }
2129             if (intersectX == -1 &amp;&amp; intersectY == -1) {
2130                 break;
2131             } else {
2132                 // if we failed to find anything, try again but without any requirements of
2133                 // intersecting
2134                 intersectX = -1;
2135                 intersectY = -1;
2136                 continue;
2137             }
2138         }
2139 
2140         // re-mark space taken by ignoreView as occupied
2141         markCellsAsOccupiedForView(ignoreView, occupied);
2142         return foundCell;
2143     }
2144 
2145     /**
2146      * A drag event has begun over this layout.
2147      * It may have begun over this layout (in which case onDragChild is called first),
2148      * or it may have begun on another layout.
2149      */
2150     void onDragEnter() {
2151         if (!mDragging) {
2152             // Fade in the drag indicators
2153             if (mCrosshairsAnimator != null) {
2154                 mCrosshairsAnimator.animateIn();
2155             }
2156         }
2157         mDragging = true;
2158     }
2159 
2160     /**
2161      * Called when drag has left this CellLayout or has been completed (successfully or not)
2162      */
2163     void onDragExit() {
2164         // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2165         // item to this layout via the customize drawer.
2166         // Guard against that case.
2167         if (mDragging) {
2168             mDragging = false;
2169 
2170             // Fade out the drag indicators
2171             if (mCrosshairsAnimator != null) {
2172                 mCrosshairsAnimator.animateOut();
2173             }
2174         }
2175 
2176         // Invalidate the drag data
2177         mDragCell[0] = mDragCell[1] = -1;
2178         mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2179         mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2180 
2181         setIsDragOverlapping(false);
2182     }
2183 
2184     /**
2185      * Mark a child as having been dropped.
2186      * At the beginning of the drag operation, the child may have been on another
2187      * screen, but it is re-parented before this method is called.
2188      *
2189      * @param child The child that is being dropped
2190      */
2191     void onDropChild(View child) {
2192         if (child != null) {
2193             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2194             lp.dropped = true;
2195             child.requestLayout();
2196         }
2197     }
2198 
2199     /**
2200      * Computes a bounding rectangle for a range of cells
2201      *
2202      * @param cellX X coordinate of upper left corner expressed as a cell position
2203      * @param cellY Y coordinate of upper left corner expressed as a cell position
2204      * @param cellHSpan Width in cells
2205      * @param cellVSpan Height in cells
2206      * @param resultRect Rect into which to put the results
2207      */
2208     public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2209         final int cellWidth = mCellWidth;
2210         final int cellHeight = mCellHeight;
2211         final int widthGap = mWidthGap;
2212         final int heightGap = mHeightGap;
2213 
2214         final int hStartPadding = getPaddingLeft();
2215         final int vStartPadding = getPaddingTop();
2216 
2217         int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2218         int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2219 
2220         int x = hStartPadding + cellX * (cellWidth + widthGap);
2221         int y = vStartPadding + cellY * (cellHeight + heightGap);
2222 
2223         resultRect.set(x, y, x + width, y + height);
2224     }
2225 
2226     /**
2227      * Computes the required horizontal and vertical cell spans to always
2228      * fit the given rectangle.
2229      *
2230      * @param width Width in pixels
2231      * @param height Height in pixels
2232      * @param result An array of length 2 in which to store the result (may be null).
2233      */
2234     public int[] rectToCell(int width, int height, int[] result) {
2235         return rectToCell(getResources(), width, height, result);
2236     }
2237 
2238     public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2239         // Always assume we&#x27;re working with the smallest span to make sure we
2240         // reserve enough space in both orientations.
2241         int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2242         int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2243         int smallerSize = Math.min(actualWidth, actualHeight);
2244 
2245         // Always round up to next largest cell
2246         int spanX = (int) Math.ceil(width / (float) smallerSize);
2247         int spanY = (int) Math.ceil(height / (float) smallerSize);
2248 
2249         if (result == null) {
2250             return new int[] { spanX, spanY };
2251         }
2252         result[0] = spanX;
2253         result[1] = spanY;
2254         return result;
2255     }
2256 
2257     public int[] cellSpansToSize(int hSpans, int vSpans) {
2258         int[] size = new int[2];
2259         size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2260         size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2261         return size;
2262     }
2263 
2264     /**
2265      * Calculate the grid spans needed to fit given item
2266      */
2267     public void calculateSpans(ItemInfo info) {
2268         final int minWidth;
2269         final int minHeight;
2270 
2271         if (info instanceof LauncherAppWidgetInfo) {
2272             minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2273             minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2274         } else if (info instanceof PendingAddWidgetInfo) {
2275             minWidth = ((PendingAddWidgetInfo) info).minWidth;
2276             minHeight = ((PendingAddWidgetInfo) info).minHeight;
2277         } else {
2278             // It&#x27;s not a widget, so it must be 1x1
2279             info.spanX = info.spanY = 1;
2280             return;
2281         }
2282         int[] spans = rectToCell(minWidth, minHeight, null);
2283         info.spanX = spans[0];
2284         info.spanY = spans[1];
2285     }
2286 
2287     /**
2288      * Find the first vacant cell, if there is one.
2289      *
2290      * @param vacant Holds the x and y coordinate of the vacant cell
2291      * @param spanX Horizontal cell span.
2292      * @param spanY Vertical cell span.
2293      *
2294      * @return True if a vacant cell was found
2295      */
2296     public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2297 
2298         return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2299     }
2300 
2301     static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2302             int xCount, int yCount, boolean[][] occupied) {
2303 
2304         for (int y = 0; y &lt; yCount; y++) {
2305             for (int x = 0; x &lt; xCount; x++) {
2306                 boolean available = !occupied[x][y];
2307 out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2308                     for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2309                         available = available &amp;&amp; !occupied[i][j];
2310                         if (!available) break out;
2311                     }
2312                 }
2313 
2314                 if (available) {
2315                     vacant[0] = x;
2316                     vacant[1] = y;
2317                     return true;
2318                 }
2319             }
2320         }
2321 
2322         return false;
2323     }
2324 
2325     private void clearOccupiedCells() {
2326         for (int x = 0; x &lt; mCountX; x++) {
2327             for (int y = 0; y &lt; mCountY; y++) {
2328                 mOccupied[x][y] = false;
2329             }
2330         }
2331     }
2332 
2333     /**
2334      * Given a view, determines how much that view can be expanded in all directions, in terms of
2335      * whether or not there are other items occupying adjacent cells. Used by the
2336      * AppWidgetResizeFrame to determine how the widget can be resized.
2337      */
2338     public void getExpandabilityArrayForView(View view, int[] expandability) {
2339         final LayoutParams lp = (LayoutParams) view.getLayoutParams();
2340         boolean flag;
2341 
2342         expandability[AppWidgetResizeFrame.LEFT] = 0;
2343         for (int x = lp.cellX - 1; x &gt;= 0; x--) {
2344             flag = false;
2345             for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2346                 if (mOccupied[x][y]) flag = true;
2347             }
2348             if (flag) break;
2349             expandability[AppWidgetResizeFrame.LEFT]++;
2350         }
2351 
2352         expandability[AppWidgetResizeFrame.TOP] = 0;
2353         for (int y = lp.cellY - 1; y &gt;= 0; y--) {
2354             flag = false;
2355             for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2356                 if (mOccupied[x][y]) flag = true;
2357             }
2358             if (flag) break;
2359             expandability[AppWidgetResizeFrame.TOP]++;
2360         }
2361 
2362         expandability[AppWidgetResizeFrame.RIGHT] = 0;
2363         for (int x = lp.cellX + lp.cellHSpan; x &lt; mCountX; x++) {
2364             flag = false;
2365             for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2366                 if (mOccupied[x][y]) flag = true;
2367             }
2368             if (flag) break;
2369             expandability[AppWidgetResizeFrame.RIGHT]++;
2370         }
2371 
2372         expandability[AppWidgetResizeFrame.BOTTOM] = 0;
2373         for (int y = lp.cellY + lp.cellVSpan; y &lt; mCountY; y++) {
2374             flag = false;
2375             for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2376                 if (mOccupied[x][y]) flag = true;
2377             }
2378             if (flag) break;
2379             expandability[AppWidgetResizeFrame.BOTTOM]++;
2380         }
2381     }
2382 
2383     public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2384         markCellsAsUnoccupiedForView(view);
2385         markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2386     }
2387 
2388     public void markCellsAsOccupiedForView(View view) {
2389         markCellsAsOccupiedForView(view, mOccupied);
2390     }
2391     public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2392         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2393         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2394         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2395     }
2396 
2397     public void markCellsAsUnoccupiedForView(View view) {
2398         markCellsAsUnoccupiedForView(view, mOccupied);
2399     }
2400     public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
2401         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2402         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2403         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2404     }
2405 
2406     private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2407             boolean value) {
2408         if (cellX &lt; 0 || cellY &lt; 0) return;
2409         for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2410             for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2411                 occupied[x][y] = value;
2412             }
2413         }
2414     }
2415 
2416     public int getDesiredWidth() {
2417         return mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
2418                 (Math.max((mCountX - 1), 0) * mWidthGap);
2419     }
2420 
2421     public int getDesiredHeight()  {
2422         return mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
2423                 (Math.max((mCountY - 1), 0) * mHeightGap);
2424     }
2425 
2426     public boolean isOccupied(int x, int y) {
2427         if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2428             return mOccupied[x][y];
2429         } else {
2430             throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2431         }
2432     }
2433 
2434     @Override
2435     public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2436         return new CellLayout.LayoutParams(getContext(), attrs);
2437     }
2438 
2439     @Override
2440     protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2441         return p instanceof CellLayout.LayoutParams;
2442     }
2443 
2444     @Override
2445     protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2446         return new CellLayout.LayoutParams(p);
2447     }
2448 
2449     public static class CellLayoutAnimationController extends LayoutAnimationController {
2450         public CellLayoutAnimationController(Animation animation, float delay) {
2451             super(animation, delay);
2452         }
2453 
2454         @Override
2455         protected long getDelayForView(View view) {
2456             return (int) (Math.random() * 150);
2457         }
2458     }
2459 
2460     public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2461         /**
2462          * Horizontal location of the item in the grid.
2463          */
2464         @ViewDebug.ExportedProperty
2465         public int cellX;
2466 
2467         /**
2468          * Vertical location of the item in the grid.
2469          */
2470         @ViewDebug.ExportedProperty
2471         public int cellY;
2472 
2473         /**
2474          * Temporary horizontal location of the item in the grid during reorder
2475          */
2476         public int tmpCellX;
2477 
2478         /**
2479          * Temporary vertical location of the item in the grid during reorder
2480          */
2481         public int tmpCellY;
2482 
2483         /**
2484          * Indicates that the temporary coordinates should be used to layout the items
2485          */
2486         public boolean useTmpCoords;
2487 
2488         /**
2489          * Number of cells spanned horizontally by the item.
2490          */
2491         @ViewDebug.ExportedProperty
2492         public int cellHSpan;
2493 
2494         /**
2495          * Number of cells spanned vertically by the item.
2496          */
2497         @ViewDebug.ExportedProperty
2498         public int cellVSpan;
2499 
2500         /**
2501          * Indicates whether the item will set its x, y, width and height parameters freely,
2502          * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2503          */
2504         public boolean isLockedToGrid = true;
2505 
2506         /**
2507          * Indicates whether this item can be reordered. Always true except in the case of the
2508          * the AllApps button.
2509          */
2510         public boolean canReorder = true;
2511 
2512         // X coordinate of the view in the layout.
2513         @ViewDebug.ExportedProperty
2514         int x;
2515         // Y coordinate of the view in the layout.
2516         @ViewDebug.ExportedProperty
2517         int y;
2518 
2519         boolean dropped;
2520 
2521         public LayoutParams(Context c, AttributeSet attrs) {
2522             super(c, attrs);
2523             cellHSpan = 1;
2524             cellVSpan = 1;
2525         }
2526 
2527         public LayoutParams(ViewGroup.LayoutParams source) {
2528             super(source);
2529             cellHSpan = 1;
2530             cellVSpan = 1;
2531         }
2532 
2533         public LayoutParams(LayoutParams source) {
2534             super(source);
2535             this.cellX = source.cellX;
2536             this.cellY = source.cellY;
2537             this.cellHSpan = source.cellHSpan;
2538             this.cellVSpan = source.cellVSpan;
2539         }
2540 
2541         public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2542             super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
2543             this.cellX = cellX;
2544             this.cellY = cellY;
2545             this.cellHSpan = cellHSpan;
2546             this.cellVSpan = cellVSpan;
2547         }
2548 
2549         public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2550             if (isLockedToGrid) {
2551                 final int myCellHSpan = cellHSpan;
2552                 final int myCellVSpan = cellVSpan;
2553                 final int myCellX = useTmpCoords ? tmpCellX : cellX;
2554                 final int myCellY = useTmpCoords ? tmpCellY : cellY;
2555 
2556                 width = myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) -
2557                         leftMargin - rightMargin;
2558                 height = myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) -
2559                         topMargin - bottomMargin;
2560                 x = (int) (myCellX * (cellWidth + widthGap) + leftMargin);
2561                 y = (int) (myCellY * (cellHeight + heightGap) + topMargin);
2562             }
2563         }
2564 
2565         public String toString() {
2566             return &quot;(&quot; + this.cellX + &quot;, &quot; + this.cellY + &quot;)&quot;;
2567         }
2568 
2569         public void setWidth(int width) {
2570             this.width = width;
2571         }
2572 
2573         public int getWidth() {
2574             return width;
2575         }
2576 
2577         public void setHeight(int height) {
2578             this.height = height;
2579         }
2580 
2581         public int getHeight() {
2582             return height;
2583         }
2584 
2585         public void setX(int x) {
2586             this.x = x;
2587         }
2588 
2589         public int getX() {
2590             return x;
2591         }
2592 
2593         public void setY(int y) {
2594             this.y = y;
2595         }
2596 
2597         public int getY() {
2598             return y;
2599         }
2600     }
2601 
2602     // This class stores info for two purposes:
2603     // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
2604     //    its spanX, spanY, and the screen it is on
2605     // 2. When long clicking on an empty cell in a CellLayout, we save information about the
2606     //    cellX and cellY coordinates and which page was clicked. We then set this as a tag on
2607     //    the CellLayout that was long clicked
2608     static final class CellInfo {
2609         View cell;
2610         int cellX = -1;
2611         int cellY = -1;
2612         int spanX;
2613         int spanY;
2614         int screen;
2615         long container;
2616 
2617         @Override
2618         public String toString() {
2619             return &quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())
2620                     + &quot;, x=&quot; + cellX + &quot;, y=&quot; + cellY + &quot;]&quot;;
2621         }
2622     }
2623 
2624     public boolean lastDownOnOccupiedCell() {
2625         return mLastDownOnOccupiedCell;
2626     }
2627 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher2;
  17 
  18 import android.animation.Animator;
  19 import android.animation.AnimatorListenerAdapter;
  20 import android.animation.ObjectAnimator;
  21 import android.animation.PropertyValuesHolder;
  22 import android.animation.TimeInterpolator;
  23 import android.animation.ValueAnimator.AnimatorUpdateListener;
  24 import android.animation.ValueAnimator;
  25 import android.content.Context;
  26 import android.content.res.Resources;
  27 import android.content.res.TypedArray;
  28 import android.graphics.Bitmap;
  29 import android.graphics.Canvas;
  30 import android.graphics.Color;
  31 import android.graphics.Paint;
  32 import android.graphics.Point;
  33 import android.graphics.PointF;
  34 import android.graphics.PorterDuff;
  35 import android.graphics.PorterDuffXfermode;
  36 import android.graphics.Rect;
  37 import android.graphics.drawable.ColorDrawable;
  38 import android.graphics.drawable.Drawable;
  39 import android.graphics.drawable.NinePatchDrawable;
  40 import android.util.AttributeSet;
  41 import android.util.Log;
  42 import android.view.MotionEvent;
  43 import android.view.View;
  44 import android.view.ViewDebug;
  45 import android.view.ViewGroup;
  46 import android.view.animation.Animation;
  47 import android.view.animation.DecelerateInterpolator;
  48 import android.view.animation.LayoutAnimationController;
  49 import com.android.launcher.R;
  50 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.HashMap;
  54 import java.util.Stack;
  55 
  56 
  57 public class CellLayout extends ViewGroup {
  58     static final String TAG = &quot;CellLayout&quot;;
  59 
  60     private int mOriginalCellWidth;
  61 
  62     private int mOriginalCellHeight;
  63 
  64     private int mCellWidth;
  65 
  66     private int mCellHeight;
  67 
  68     private int mCountX;
  69 
  70     private int mCountY;
  71 
  72     private int mOriginalWidthGap;
  73 
  74     private int mOriginalHeightGap;
  75 
  76     private int mWidthGap;
  77 
  78     private int mHeightGap;
  79 
  80     private int mMaxGap;
  81 
  82     private boolean mScrollingTransformsDirty = false;
  83 
  84     private final Rect mRect = new Rect();
  85 
  86     private final CellInfo mCellInfo = new CellInfo();
  87 
  88     // These are temporary variables to prevent having to allocate a new object just to
  89     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  90     private final int[] mTmpXY = new int[2];
  91 
  92     private final int[] mTmpPoint = new int[2];
  93 
  94     private final PointF mTmpPointF = new PointF();
  95 
  96     int[] mTempLocation = new int[2];
  97 
  98     boolean[][] mOccupied;
  99 
 100     boolean[][] mTmpOccupied;
 101 
 102     private boolean mLastDownOnOccupiedCell = false;
 103 
 104     private OnTouchListener mInterceptTouchListener;
 105 
 106     private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
 107 
 108     private int[] mFolderLeaveBehindCell = new int[]{ -1, -1 };
 109 
 110     private int mForegroundAlpha = 0;
 111 
 112     private float mBackgroundAlpha;
 113 
 114     private float mBackgroundAlphaMultiplier = 1.0f;
 115 
 116     private Drawable mNormalBackground;
 117 
 118     private Drawable mActiveGlowBackground;
 119 
 120     private Drawable mOverScrollForegroundDrawable;
 121 
 122     private Drawable mOverScrollLeft;
 123 
 124     private Drawable mOverScrollRight;
 125 
 126     private Rect mBackgroundRect;
 127 
 128     private Rect mForegroundRect;
 129 
 130     private int mForegroundPadding;
 131 
 132     // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 133     private boolean mIsDragOverlapping = false;
 134 
 135     private final Point mDragCenter = new Point();
 136 
 137     // These arrays are used to implement the drag visualization on x-large screens.
 138     // They are used as circular arrays, indexed by mDragOutlineCurrent.
 139     private Rect[] mDragOutlines = new Rect[4];
 140 
 141     private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 142 
 143     private InterruptibleInOutAnimator[] mDragOutlineAnims =
 144             new InterruptibleInOutAnimator[mDragOutlines.length];
 145 
 146     // Used as an index into the above 3 arrays; indicates which is the most current value.
 147     // Used as an index into the above 3 arrays; indicates which is the most current value.
 148     private int mDragOutlineCurrent = 0;
 149 
 150     private final Paint mDragOutlinePaint = new Paint();
 151 
 152     private BubbleTextView mPressedOrFocusedIcon;
 153 
 154     private Drawable mCrosshairsDrawable = null;
 155 
 156     private InterruptibleInOutAnimator mCrosshairsAnimator = null;
 157 
 158     private float mCrosshairsVisibility = 0.0f;
 159 
<abbr title=" 160     private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new HashMap&lt;CellLayout.LayoutParams, Animator&gt;();"> 160     private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new HashMap&lt;CellLayout.LayoutP🔵</abbr>
 161 
 162     // When a drag operation is in progress, holds the nearest cell to the touch point
 163     private final int[] mDragCell = new int[2];
 164 
 165     private boolean mDragging = false;
 166 
 167     private boolean mItemLocationsDirty = false;
 168 
 169     private TimeInterpolator mEaseOutInterpolator;
 170 
 171     private ShortcutAndWidgetContainer mShortcutsAndWidgets;
 172 
 173     private boolean mIsHotseat = false;
 174 
 175     private float mChildScale = 1f;
 176 
 177     private float mHotseatChildScale = 1f;
 178 
 179     public static final int MODE_DRAG_OVER = 0;
 180 
 181     public static final int MODE_ON_DROP = 1;
 182 
 183     public static final int MODE_ON_DROP_EXTERNAL = 2;
 184 
 185     public static final int MODE_ACCEPT_DROP = 3;
 186 
 187     private static final boolean DESTRUCTIVE_REORDER = true;
 188 
 189     private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 190 
 191     private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 192 
 193     private Rect mOccupiedRect = new Rect();
 194 
 195     private int[] mDirectionVector = new int[2];
 196 
 197     public CellLayout(Context context) {
 198         this(context, null);
 199     }
 200 
 201     public CellLayout(Context context, AttributeSet attrs) {
 202         this(context, attrs, 0);
 203     }
 204 
 205     public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 206         super(context, attrs, defStyle);
 207         // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 208         // the user where a dragged item will land when dropped.
 209         setWillNotDraw(false);
 210         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 211         mOriginalCellWidth = mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
<abbr title=" 212         mOriginalCellHeight = mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);"> 212         mOriginalCellHeight = mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10🔵</abbr>
 213         mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 214         mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 215         mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 216         mCountX = LauncherModel.getCellCountX();
 217         mCountY = LauncherModel.getCellCountY();
 218         mOccupied = new boolean[mCountX][mCountY];
 219         mTmpOccupied = new boolean[mCountX][mCountY];
 220         a.recycle();
 221         setAlwaysDrawnWithCacheEnabled(false);
 222         final Resources res = getResources();
 223         mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 224         mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 225         mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 226         mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 227         mForegroundPadding = res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 228         mNormalBackground.setFilterBitmap(true);
 229         mActiveGlowBackground.setFilterBitmap(true);
 230         int iconScale = res.getInteger(R.integer.app_icon_scale_percent);
 231         if (iconScale &gt;= 0) {
 232             mChildScale = iconScale / 100.0F;
 233         }
 234         int hotseatIconScale = res.getInteger(R.integer.app_icon_hotseat_scale_percent);
 235         if (hotseatIconScale &gt;= 0) {
 236             mHotseatChildScale = hotseatIconScale / 100.0F;
 237         }
 238         // Initialize the data structures used for the drag visualization.
 239         mCrosshairsDrawable = res.getDrawable(R.drawable.gardening_crosshairs);
 240         mEaseOutInterpolator = new DecelerateInterpolator(2.5F);// Quint ease out
 241 
 242         // Set up the animation for fading the crosshairs in and out
 243         int animDuration = res.getInteger(R.integer.config_crosshairsFadeInTime);
 244         mCrosshairsAnimator = new InterruptibleInOutAnimator(animDuration, 0.0F, 1.0F);
 245         mCrosshairsAnimator.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 246             public void onAnimationUpdate(ValueAnimator animation) {
 247                 mCrosshairsVisibility = ((Float) (animation.getAnimatedValue())).floatValue();
 248                 invalidate();
 249             }
 250         });
 251         mCrosshairsAnimator.getAnimator().setInterpolator(mEaseOutInterpolator);
 252         mDragCell[0] = mDragCell[1] = -1;
 253         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 254             mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 255         }
 256         // When dragging things around the home screens, we show a green outline of
 257         // where the item will land. The outlines gradually fade out, leaving a trail
 258         // behind the drag path.
 259         // Set up all the animations that are used to implement this fading.
 260         final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 261         final float fromAlphaValue = 0;
 262         final float toAlphaValue = ((float) (res.getInteger(R.integer.config_dragOutlineMaxAlpha)));
 263         Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 264         for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
<abbr title=" 265             final InterruptibleInOutAnimator anim = new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);"> 265             final InterruptibleInOutAnimator anim = new InterruptibleInOutAnimator(duration, fromAlphaVal🔵</abbr>
 266             anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 267             final int thisIndex = i;
 268             anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 269                 public void onAnimationUpdate(ValueAnimator animation) {
 270                     final Bitmap outline = ((Bitmap) (anim.getTag()));
 271                     // If an animation is started and then stopped very quickly, we can still
 272                     // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 273                     if (outline == null) {
 274                         if (false) {
 275                             Object val = animation.getAnimatedValue();
<abbr title=" 276                             Log.d(TAG, ((((&quot;anim &quot; + thisIndex) + &quot; update: &quot;) + val) + &quot;, isStopped &quot;) + anim.isStopped());"> 276                             Log.d(TAG, ((((&quot;anim &quot; + thisIndex) + &quot; update: &quot;) + val) + &quot;, isStopped &quot;) +🔵</abbr>
 277                         }
 278                         // Try to prevent it from continuing to run
 279                         animation.cancel();
 280                     } else {
 281                         mDragOutlineAlphas[thisIndex] = ((Float) (animation.getAnimatedValue()));
 282                         CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 283                     }
 284                 }
 285             });
 286             // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 287             // running. This way the bitmap can be GCed when the animations are complete.
 288             anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 289                 @Override
 290                 public void onAnimationEnd(Animator animation) {
 291                     if (((Float) (((ValueAnimator) (animation)).getAnimatedValue())) == 0.0F) {
 292                         anim.setTag(null);
 293                     }
 294                 }
 295             });
 296             mDragOutlineAnims[i] = anim;
 297         }
 298         mBackgroundRect = new Rect();
 299         mForegroundRect = new Rect();
 300         mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);
 301         mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 302         addView(mShortcutsAndWidgets);
 303     }
 304 
 305     static int widthInPortrait(Resources r, int numCells) {
 306         // We use this method from Workspace to figure out how many rows/columns Launcher should
 307         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 308         // the padding extends outside the visible screen size, but it looked fine anyway.
 309         int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 310         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 311                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 312 
 313         return  minGap * (numCells - 1) + cellWidth * numCells;
 314     }
 315 
 316     static int heightInLandscape(Resources r, int numCells) {
 317         // We use this method from Workspace to figure out how many rows/columns Launcher should
 318         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 319         // the padding extends outside the visible screen size, but it looked fine anyway.
 320         int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 321         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 322                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 323 
 324         return minGap * (numCells - 1) + cellHeight * numCells;
 325     }
 326 
 327     public void enableHardwareLayers() {
 328         mShortcutsAndWidgets.enableHardwareLayers();
 329     }
 330 
 331     public void setGridSize(int x, int y) {
 332         mCountX = x;
 333         mCountY = y;
 334         mOccupied = new boolean[mCountX][mCountY];
 335         mTmpOccupied = new boolean[mCountX][mCountY];
 336         requestLayout();
 337     }
 338 
 339     private void invalidateBubbleTextView(BubbleTextView icon) {
 340         final int padding = icon.getPressedOrFocusedBackgroundPadding();
 341         invalidate(icon.getLeft() + getPaddingLeft() - padding,
 342                 icon.getTop() + getPaddingTop() - padding,
 343                 icon.getRight() + getPaddingLeft() + padding,
 344                 icon.getBottom() + getPaddingTop() + padding);
 345     }
 346 
 347     void setOverScrollAmount(float r, boolean left) {
 348         if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 349             mOverScrollForegroundDrawable = mOverScrollLeft;
 350         } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 351             mOverScrollForegroundDrawable = mOverScrollRight;
 352         }
 353 
 354         mForegroundAlpha = (int) Math.round((r * 255));
 355         mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 356         invalidate();
 357     }
 358 
 359     void setPressedOrFocusedIcon(BubbleTextView icon) {
 360         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 361         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 362         BubbleTextView oldIcon = mPressedOrFocusedIcon;
 363         mPressedOrFocusedIcon = icon;
 364         if (oldIcon != null) {
 365             invalidateBubbleTextView(oldIcon);
 366         }
 367         if (mPressedOrFocusedIcon != null) {
 368             invalidateBubbleTextView(mPressedOrFocusedIcon);
 369         }
 370     }
 371 
 372     void setIsDragOverlapping(boolean isDragOverlapping) {
 373         if (mIsDragOverlapping != isDragOverlapping) {
 374             mIsDragOverlapping = isDragOverlapping;
 375             invalidate();
 376         }
 377     }
 378 
 379     boolean getIsDragOverlapping() {
 380         return mIsDragOverlapping;
 381     }
 382 
 383     protected void setOverscrollTransformsDirty(boolean dirty) {
 384         mScrollingTransformsDirty = dirty;
 385     }
 386 
 387     protected void resetOverscrollTransforms() {
 388         if (mScrollingTransformsDirty) {
 389             setOverscrollTransformsDirty(false);
 390             setTranslationX(0);
 391             setRotationY(0);
 392             // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 393             // pass 0, which results in the overscroll drawable not being drawn any more.
 394             setOverScrollAmount(0, false);
 395             setPivotX(getMeasuredWidth() / 2);
 396             setPivotY(getMeasuredHeight() / 2);
 397         }
 398     }
 399 
 400     @Override
 401     protected void onDraw(Canvas canvas) {
 402         // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 403         // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 404         // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 405         // a drag). However, we also drag the mini hover background *over* one of those two
 406         // backgrounds
 407         if (mBackgroundAlpha &gt; 0.0f) {
 408             Drawable bg;
 409 
 410             if (mIsDragOverlapping) {
 411                 // In the mini case, we draw the active_glow bg *over* the active background
 412                 bg = mActiveGlowBackground;
 413             } else {
 414                 bg = mNormalBackground;
 415             }
 416 
 417             bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 418             bg.setBounds(mBackgroundRect);
 419             bg.draw(canvas);
 420         }
 421 
 422         if (mCrosshairsVisibility &gt; 0.0f) {
 423             final int countX = mCountX;
 424             final int countY = mCountY;
 425 
 426             final float MAX_ALPHA = 0.4f;
 427             final int MAX_VISIBLE_DISTANCE = 600;
 428             final float DISTANCE_MULTIPLIER = 0.002f;
 429 
 430             final Drawable d = mCrosshairsDrawable;
 431             final int width = d.getIntrinsicWidth();
 432             final int height = d.getIntrinsicHeight();
 433 
 434             int x = getPaddingLeft() - (mWidthGap / 2) - (width / 2);
 435             for (int col = 0; col &lt;= countX; col++) {
 436                 int y = getPaddingTop() - (mHeightGap / 2) - (height / 2);
 437                 for (int row = 0; row &lt;= countY; row++) {
 438                     mTmpPointF.set(x - mDragCenter.x, y - mDragCenter.y);
 439                     float dist = mTmpPointF.length();
 440                     // Crosshairs further from the drag point are more faint
 441                     float alpha = Math.min(MAX_ALPHA,
 442                             DISTANCE_MULTIPLIER * (MAX_VISIBLE_DISTANCE - dist));
 443                     if (alpha &gt; 0.0f) {
 444                         d.setBounds(x, y, x + width, y + height);
 445                         d.setAlpha((int) (alpha * 255 * mCrosshairsVisibility));
 446                         d.draw(canvas);
 447                     }
 448                     y += mCellHeight + mHeightGap;
 449                 }
 450                 x += mCellWidth + mWidthGap;
 451             }
 452         }
 453 
 454         final Paint paint = mDragOutlinePaint;
 455         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 456             final float alpha = mDragOutlineAlphas[i];
 457             if (alpha &gt; 0) {
 458                 final Rect r = mDragOutlines[i];
 459                 final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 460                 paint.setAlpha((int)(alpha + .5f));
 461                 canvas.drawBitmap(b, null, r, paint);
 462             }
 463         }
 464 
 465         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 466         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 467         if (mPressedOrFocusedIcon != null) {
 468             final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 469             final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 470             if (b != null) {
 471                 canvas.drawBitmap(b,
 472                         mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 473                         mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 474                         null);
 475             }
 476         }
 477 
 478         if (DEBUG_VISUALIZE_OCCUPIED) {
 479             int[] pt = new int[2];
 480             ColorDrawable cd = new ColorDrawable(Color.RED);
 481             cd.setBounds(0, 0, 80, 80);
 482             for (int i = 0; i &lt; mCountX; i++) {
 483                 for (int j = 0; j &lt; mCountY; j++) {
 484                     if (mOccupied[i][j]) {
 485                         cellToPoint(i, j, pt);
 486                         canvas.save();
 487                         canvas.translate(pt[0], pt[1]);
 488                         cd.draw(canvas);
 489                         canvas.restore();
 490                     }
 491                 }
 492             }
 493         }
 494 
 495         // The folder outer / inner ring image(s)
 496         for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 497             FolderRingAnimator fra = mFolderOuterRings.get(i);
 498 
 499             // Draw outer ring
 500             Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 501             int width = (int) fra.getOuterRingSize();
 502             int height = width;
 503             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 504 
 505             int centerX = mTempLocation[0] + mCellWidth / 2;
 506             int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 507 
 508             canvas.save();
 509             canvas.translate(centerX - width / 2, centerY - height / 2);
 510             d.setBounds(0, 0, width, height);
 511             d.draw(canvas);
 512             canvas.restore();
 513 
 514             // Draw inner ring
 515             d = FolderRingAnimator.sSharedInnerRingDrawable;
 516             width = (int) fra.getInnerRingSize();
 517             height = width;
 518             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 519 
 520             centerX = mTempLocation[0] + mCellWidth / 2;
 521             centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 522             canvas.save();
 523             canvas.translate(centerX - width / 2, centerY - width / 2);
 524             d.setBounds(0, 0, width, height);
 525             d.draw(canvas);
 526             canvas.restore();
 527         }
 528 
 529         if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 530             Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 531             int width = d.getIntrinsicWidth();
 532             int height = d.getIntrinsicHeight();
 533 
 534             cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 535             int centerX = mTempLocation[0] + mCellWidth / 2;
 536             int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 537 
 538             canvas.save();
 539             canvas.translate(centerX - width / 2, centerY - width / 2);
 540             d.setBounds(0, 0, width, height);
 541             d.draw(canvas);
 542             canvas.restore();
 543         }
 544     }
 545 
 546     @Override
 547     protected void dispatchDraw(Canvas canvas) {
 548         super.dispatchDraw(canvas);
 549         if (mForegroundAlpha &gt; 0) {
 550             mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 551             Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 552             p.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));
 553             mOverScrollForegroundDrawable.draw(canvas);
 554             p.setXfermode(null);
 555         }
 556     }
 557 
 558     public void showFolderAccept(FolderRingAnimator fra) {
 559         mFolderOuterRings.add(fra);
 560     }
 561 
 562     public void hideFolderAccept(FolderRingAnimator fra) {
 563         if (mFolderOuterRings.contains(fra)) {
 564             mFolderOuterRings.remove(fra);
 565         }
 566         invalidate();
 567     }
 568 
 569     public void setFolderLeaveBehindCell(int x, int y) {
 570         mFolderLeaveBehindCell[0] = x;
 571         mFolderLeaveBehindCell[1] = y;
 572         invalidate();
 573     }
 574 
 575     public void clearFolderLeaveBehind() {
 576         mFolderLeaveBehindCell[0] = -1;
 577         mFolderLeaveBehindCell[1] = -1;
 578         invalidate();
 579     }
 580 
 581     @Override
 582     public boolean shouldDelayChildPressedState() {
 583         return false;
 584     }
 585 
 586     @Override
 587     public void cancelLongPress() {
 588         super.cancelLongPress();
 589 
 590         // Cancel long press for all children
 591         final int count = getChildCount();
 592         for (int i = 0; i &lt; count; i++) {
 593             final View child = getChildAt(i);
 594             child.cancelLongPress();
 595         }
 596     }
 597 
 598     public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 599         mInterceptTouchListener = listener;
 600     }
 601 
 602     int getCountX() {
 603         return mCountX;
 604     }
 605 
 606     int getCountY() {
 607         return mCountY;
 608     }
 609 
 610     public void setIsHotseat(boolean isHotseat) {
 611         mIsHotseat = isHotseat;
 612     }
 613 
 614     public float getChildrenScale() {
 615         return mIsHotseat ? mHotseatChildScale : mChildScale;
 616     }
 617 
 618     public boolean addViewToCellLayout(
 619             View child, int index, int childId, LayoutParams params, boolean markCells) {
 620         return addViewToCellLayout(child, index, childId, params, markCells, false);
 621     }
 622 
 623     private void scaleChild(BubbleTextView bubbleChild, float pivot, float scale) {
 624         // If we haven&#x27;t measured the child yet, do it now
 625         // (this happens if we&#x27;re being dropped from all-apps
<abbr title=" 626         if ((bubbleChild.getLayoutParams() instanceof LayoutParams) &amp;&amp; ((bubbleChild.getMeasuredWidth() | bubbleChild.getMeasuredHeight()) == 0)) {"> 626         if ((bubbleChild.getLayoutParams() instanceof LayoutParams) &amp;&amp; ((bubbleChild.getMeasuredWidth() |🔵</abbr>
 627             getShortcutsAndWidgets().measureChild(bubbleChild);
 628         }
 629         int measuredWidth = bubbleChild.getMeasuredWidth();
 630         int measuredHeight = bubbleChild.getMeasuredHeight();
 631         bubbleChild.setScaleX(scale);
 632         bubbleChild.setScaleY(scale);
 633     }
 634 
 635     private void resetChild(BubbleTextView bubbleChild) {
 636         bubbleChild.setScaleX(1f);
 637         bubbleChild.setScaleY(1f);
 638 
 639         bubbleChild.setTextColor(getResources().getColor(R.color.workspace_icon_text_color));
 640     }
 641 
<abbr title=" 642     public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params, boolean markCells, boolean allApps) {"> 642     public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params, boolean m🔵</abbr>
 643         final LayoutParams lp = params;
 644         // Hotseat icons - scale down and remove text
 645         // Don&#x27;t scale the all apps button
 646         // scale percent set to -1 means do not scale
 647         // Only scale BubbleTextViews
 648         if (child instanceof BubbleTextView) {
 649             BubbleTextView bubbleChild = ((BubbleTextView) (child));
 650             // Start the child with 100% scale and visible text
 651             resetChild(bubbleChild);
 652             if ((mIsHotseat &amp;&amp; (!allApps)) &amp;&amp; (mHotseatChildScale &gt;= 0)) {
 653                 // Scale/make transparent for a hotseat
 654                 scaleChild(bubbleChild, 0.0F, mHotseatChildScale);
 655                 bubbleChild.setTextColor(getResources().getColor(android.R.color.transparent));
 656             } else if (mChildScale &gt;= 0) {
 657                 // Else possibly still scale it if we need to for smaller icons
 658                 scaleChild(bubbleChild, 0.0F, mChildScale);
 659             }
 660         }
 661         // Generate an id for each view, this assumes we have at most 256x256 cells
 662         // per workspace screen
<abbr title=" 663         if ((((lp.cellX &gt;= 0) &amp;&amp; (lp.cellX &lt;= (mCountX - 1))) &amp;&amp; (lp.cellY &gt;= 0)) &amp;&amp; (lp.cellY &lt;= (mCountY - 1))) {"> 663         if ((((lp.cellX &gt;= 0) &amp;&amp; (lp.cellX &lt;= (mCountX - 1))) &amp;&amp; (lp.cellY &gt;= 0)) &amp;&amp; (lp.cellY &lt;= (mCount🔵</abbr>
 664             // If the horizontal or vertical span is set to -1, it is taken to
 665             // mean that it spans the extent of the CellLayout
 666             if (lp.cellHSpan &lt; 0) {
 667                 lp.cellHSpan = mCountX;
 668             }
 669             if (lp.cellVSpan &lt; 0) {
 670                 lp.cellVSpan = mCountY;
 671             }
 672             child.setId(childId);
 673             mShortcutsAndWidgets.addView(child, index, lp);
 674             if (markCells) {
 675                 markCellsAsOccupiedForView(child);
 676             }
 677             return true;
 678         }
 679         return false;
 680     }
 681 
 682     @Override
 683     public void removeAllViews() {
 684         clearOccupiedCells();
 685         mShortcutsAndWidgets.removeAllViews();
 686     }
 687 
 688     @Override
 689     public void removeAllViewsInLayout() {
 690         if (mShortcutsAndWidgets.getChildCount() &gt; 0) {
 691             clearOccupiedCells();
 692             mShortcutsAndWidgets.removeAllViewsInLayout();
 693         }
 694     }
 695 
 696     public void removeViewWithoutMarkingCells(View view) {
 697         mShortcutsAndWidgets.removeView(view);
 698     }
 699 
 700     @Override
 701     public void removeView(View view) {
 702         markCellsAsUnoccupiedForView(view);
 703         mShortcutsAndWidgets.removeView(view);
 704     }
 705 
 706     @Override
 707     public void removeViewAt(int index) {
 708         markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
 709         mShortcutsAndWidgets.removeViewAt(index);
 710     }
 711 
 712     @Override
 713     public void removeViewInLayout(View view) {
 714         markCellsAsUnoccupiedForView(view);
 715         mShortcutsAndWidgets.removeViewInLayout(view);
 716     }
 717 
 718     @Override
 719     public void removeViews(int start, int count) {
 720         for (int i = start; i &lt; (start + count); i++) {
 721             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 722         }
 723         mShortcutsAndWidgets.removeViews(start, count);
 724     }
 725 
 726     @Override
 727     public void removeViewsInLayout(int start, int count) {
 728         for (int i = start; i &lt; (start + count); i++) {
 729             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 730         }
 731         mShortcutsAndWidgets.removeViewsInLayout(start, count);
 732     }
 733 
 734     @Override
 735     protected void onAttachedToWindow() {
 736         super.onAttachedToWindow();
 737         mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 738     }
 739 
 740     public void setTagToCellInfoForPoint(int touchX, int touchY) {
 741         final CellInfo cellInfo = mCellInfo;
 742         Rect frame = mRect;
 743         final int x = touchX + mScrollX;
 744         final int y = touchY + mScrollY;
 745         final int count = mShortcutsAndWidgets.getChildCount();
 746         boolean found = false;
 747         for (int i = count - 1; i &gt;= 0; i--) {
 748             final View child = mShortcutsAndWidgets.getChildAt(i);
 749             final LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
<abbr title=" 750             if (((child.getVisibility() == VISIBLE) || (child.getAnimation() != null)) &amp;&amp; lp.isLockedToGrid) {"> 750             if (((child.getVisibility() == VISIBLE) || (child.getAnimation() != null)) &amp;&amp; lp.isLockedToGr🔵</abbr>
 751                 child.getHitRect(frame);
 752                 float scale = child.getScaleX();
 753                 frame = new Rect(child.getLeft(), child.getTop(), child.getRight(), child.getBottom());
 754                 // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 755                 // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 756                 // to this view.
 757                 frame.offset(mPaddingLeft, mPaddingTop);
<abbr title=" 758                 frame.inset(((int) ((frame.width() * (1.0F - scale)) / 2)), ((int) ((frame.height() * (1.0F - scale)) / 2)));"> 758                 frame.inset(((int) ((frame.width() * (1.0F - scale)) / 2)), ((int) ((frame.height() * (1.🔵</abbr>
 759                 if (frame.contains(x, y)) {
 760                     cellInfo.cell = child;
 761                     cellInfo.cellX = lp.cellX;
 762                     cellInfo.cellY = lp.cellY;
 763                     cellInfo.spanX = lp.cellHSpan;
 764                     cellInfo.spanY = lp.cellVSpan;
 765                     found = true;
 766                     break;
 767                 }
 768             }
 769         }
 770         mLastDownOnOccupiedCell = found;
 771         if (!found) {
 772             final int[] cellXY = mTmpXY;
 773             pointToCellExact(x, y, cellXY);
 774             cellInfo.cell = null;
 775             cellInfo.cellX = cellXY[0];
 776             cellInfo.cellY = cellXY[1];
 777             cellInfo.spanX = 1;
 778             cellInfo.spanY = 1;
 779         }
 780         setTag(cellInfo);
 781     }
 782 
 783     @Override
 784     public boolean onInterceptTouchEvent(MotionEvent ev) {
 785         // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 786         // even in the case where we return early. Not clearing here was causing bugs whereby on
 787         // long-press we&#x27;d end up picking up an item from a previous drag operation.
 788         final int action = ev.getAction();
 789 
 790         if (action == MotionEvent.ACTION_DOWN) {
 791             clearTagCellInfo();
 792         }
 793 
 794         if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 795             return true;
 796         }
 797 
 798         if (action == MotionEvent.ACTION_DOWN) {
 799             setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 800         }
 801 
 802         return false;
 803     }
 804 
 805     private void clearTagCellInfo() {
 806         final CellInfo cellInfo = mCellInfo;
 807         cellInfo.cell = null;
 808         cellInfo.cellX = -1;
 809         cellInfo.cellY = -1;
 810         cellInfo.spanX = 0;
 811         cellInfo.spanY = 0;
 812         setTag(cellInfo);
 813     }
 814 
 815     public CellInfo getTag() {
 816         return (CellInfo) super.getTag();
 817     }
 818 
 819     /**
 820      * Given a point, return the cell that strictly encloses that point
 821      * @param x X coordinate of the point
 822      * @param y Y coordinate of the point
 823      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 824      */
 825     void pointToCellExact(int x, int y, int[] result) {
 826         final int hStartPadding = getPaddingLeft();
 827         final int vStartPadding = getPaddingTop();
 828 
 829         result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 830         result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 831 
 832         final int xAxis = mCountX;
 833         final int yAxis = mCountY;
 834 
 835         if (result[0] &lt; 0) result[0] = 0;
 836         if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 837         if (result[1] &lt; 0) result[1] = 0;
 838         if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 839     }
 840 
 841     /**
 842      * Given a point, return the cell that most closely encloses that point
 843      * @param x X coordinate of the point
 844      * @param y Y coordinate of the point
 845      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 846      */
 847     void pointToCellRounded(int x, int y, int[] result) {
 848         pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 849     }
 850 
 851     /**
 852      * Given a cell coordinate, return the point that represents the upper left corner of that cell
 853      *
 854      * @param cellX X coordinate of the cell
 855      * @param cellY Y coordinate of the cell
 856      *
 857      * @param result Array of 2 ints to hold the x and y coordinate of the point
 858      */
 859     void cellToPoint(int cellX, int cellY, int[] result) {
 860         final int hStartPadding = getPaddingLeft();
 861         final int vStartPadding = getPaddingTop();
 862 
 863         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 864         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 865     }
 866 
 867     /**
 868      * Given a cell coordinate, return the point that represents the center of the cell
 869      *
 870      * @param cellX X coordinate of the cell
 871      * @param cellY Y coordinate of the cell
 872      *
 873      * @param result Array of 2 ints to hold the x and y coordinate of the point
 874      */
 875     void cellToCenterPoint(int cellX, int cellY, int[] result) {
 876         final int hStartPadding = getPaddingLeft();
 877         final int vStartPadding = getPaddingTop();
 878         result[0] = (hStartPadding + (cellX * (mCellWidth + mWidthGap))) + (mCellWidth / 2);
 879         result[1] = (vStartPadding + (cellY * (mCellHeight + mHeightGap))) + (mCellHeight / 2);
 880     }
 881 
 882     public float getDistanceFromCell(float x, float y, int[] cell) {
 883         cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 884         float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 885                 Math.pow(y - mTmpPoint[1], 2));
 886         return distance;
 887     }
 888 
 889     int getCellWidth() {
 890         return mCellWidth;
 891     }
 892 
 893     int getCellHeight() {
 894         return mCellHeight;
 895     }
 896 
 897     int getWidthGap() {
 898         return mWidthGap;
 899     }
 900 
 901     int getHeightGap() {
 902         return mHeightGap;
 903     }
 904 
 905     Rect getContentRect(Rect r) {
 906         if (r == null) {
 907             r = new Rect();
 908         }
 909         int left = getPaddingLeft();
 910         int top = getPaddingTop();
 911         int right = left + getWidth() - mPaddingLeft - mPaddingRight;
 912         int bottom = top + getHeight() - mPaddingTop - mPaddingBottom;
 913         r.set(left, top, right, bottom);
 914         return r;
 915     }
 916 
 917     @Override
 918     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 919         // TODO: currently ignoring padding
 920         int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 921         int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 922         int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 923         int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
 924         if ((widthSpecMode == MeasureSpec.UNSPECIFIED) || (heightSpecMode == MeasureSpec.UNSPECIFIED)) {
 925             throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 926         }
 927         int numWidthGaps = mCountX - 1;
 928         int numHeightGaps = mCountY - 1;
 929         if ((mOriginalWidthGap &lt; 0) || (mOriginalHeightGap &lt; 0)) {
 930             int hSpace = (widthSpecSize - mPaddingLeft) - mPaddingRight;
 931             int vSpace = (heightSpecSize - mPaddingTop) - mPaddingBottom;
 932             int hFreeSpace = hSpace - (mCountX * mOriginalCellWidth);
 933             int vFreeSpace = vSpace - (mCountY * mOriginalCellHeight);
 934             mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? hFreeSpace / numWidthGaps : 0);
 935             mHeightGap = Math.min(mMaxGap, numHeightGaps &gt; 0 ? vFreeSpace / numHeightGaps : 0);
 936             mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 937         } else {
 938             mWidthGap = mOriginalWidthGap;
 939             mHeightGap = mOriginalHeightGap;
 940         }
 941         // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 942         int newWidth = widthSpecSize;
 943         int newHeight = heightSpecSize;
 944         if (widthSpecMode == MeasureSpec.AT_MOST) {
<abbr title=" 945             newWidth = ((mPaddingLeft + mPaddingRight) + (mCountX * mCellWidth)) + ((mCountX - 1) * mWidthGap);"> 945             newWidth = ((mPaddingLeft + mPaddingRight) + (mCountX * mCellWidth)) + ((mCountX - 1) * mWidt🔵</abbr>
<abbr title=" 946             newHeight = ((mPaddingTop + mPaddingBottom) + (mCountY * mCellHeight)) + ((mCountY - 1) * mHeightGap);"> 946             newHeight = ((mPaddingTop + mPaddingBottom) + (mCountY * mCellHeight)) + ((mCountY - 1) * mHe🔵</abbr>
 947             setMeasuredDimension(newWidth, newHeight);
 948         }
 949         int count = getChildCount();
 950         for (int i = 0; i &lt; count; i++) {
 951             View child = getChildAt(i);
<abbr title=" 952             int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec((newWidth - mPaddingLeft) - mPaddingRight, MeasureSpec.EXACTLY);"> 952             int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec((newWidth - mPaddingLeft) - mPaddingR🔵</abbr>
<abbr title=" 953             int childheightMeasureSpec = MeasureSpec.makeMeasureSpec((newHeight - mPaddingTop) - mPaddingBottom, MeasureSpec.EXACTLY);"> 953             int childheightMeasureSpec = MeasureSpec.makeMeasureSpec((newHeight - mPaddingTop) - mPadding🔵</abbr>
 954             child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 955         }
 956         setMeasuredDimension(newWidth, newHeight);
 957     }
 958 
 959     @Override
 960     protected void onLayout(boolean changed, int l, int t, int r, int b) {
 961         int count = getChildCount();
 962         for (int i = 0; i &lt; count; i++) {
 963             View child = getChildAt(i);
 964             child.layout(mPaddingLeft, mPaddingTop,
 965                     r - l - mPaddingRight, b - t - mPaddingBottom);
 966         }
 967     }
 968 
 969     @Override
 970     protected void onSizeChanged(int w, int h, int oldw, int oldh) {
 971         super.onSizeChanged(w, h, oldw, oldh);
 972         mBackgroundRect.set(0, 0, w, h);
 973         mForegroundRect.set(mForegroundPadding, mForegroundPadding,
 974                 w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
 975     }
 976 
 977     @Override
 978     protected void setChildrenDrawingCacheEnabled(boolean enabled) {
 979         mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
 980     }
 981 
 982     @Override
 983     protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
 984         mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
 985     }
 986 
 987     public float getBackgroundAlpha() {
 988         return mBackgroundAlpha;
 989     }
 990 
 991     public void setBackgroundAlphaMultiplier(float multiplier) {
 992         mBackgroundAlphaMultiplier = multiplier;
 993     }
 994 
 995     public float getBackgroundAlphaMultiplier() {
 996         return mBackgroundAlphaMultiplier;
 997     }
 998 
 999     public void setBackgroundAlpha(float alpha) {
1000         if (mBackgroundAlpha != alpha) {
1001             mBackgroundAlpha = alpha;
1002             invalidate();
1003         }
1004     }
1005 
1006     public void setShortcutAndWidgetAlpha(float alpha) {
1007         final int childCount = getChildCount();
1008         for (int i = 0; i &lt; childCount; i++) {
1009             getChildAt(i).setAlpha(alpha);
1010         }
1011     }
1012 
1013     public ShortcutAndWidgetContainer getShortcutsAndWidgets() {
1014         if (getChildCount() &gt; 0) {
1015             return ((ShortcutAndWidgetContainer) (getChildAt(0)));
1016         }
1017         return null;
1018     }
1019 
1020     public View getChildAt(int x, int y) {
1021         return mShortcutsAndWidgets.getChildAt(x, y);
1022     }
1023 
<abbr title="1024     public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration, int delay, boolean permanent, boolean adjustOccupied) {">1024     public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration, int delay🔵</abbr>
1025         ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();
1026         boolean[][] occupied = mOccupied;
1027         if (!permanent) {
1028             occupied = mTmpOccupied;
1029         }
1030         if ((clc.indexOfChild(child) != (-1)) &amp;&amp; (!occupied[cellX][cellY])) {
1031             final LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1032             final ItemInfo info = ((ItemInfo) (child.getTag()));
1033             // We cancel any existing animations
1034             if (mReorderAnimators.containsKey(lp)) {
1035                 mReorderAnimators.get(lp).cancel();
1036                 mReorderAnimators.remove(lp);
1037             }
1038             final int oldX = lp.x;
1039             final int oldY = lp.y;
1040             if (adjustOccupied) {
1041                 occupied[lp.cellX][lp.cellY] = false;
1042                 occupied[cellX][cellY] = true;
1043             }
1044             lp.isLockedToGrid = true;
1045             if (permanent) {
1046                 lp.cellX = info.cellX = cellX;
1047                 lp.cellY = info.cellY = cellY;
1048             } else {
1049                 lp.tmpCellX = cellX;
1050                 lp.tmpCellY = cellY;
1051             }
1052             clc.setupLp(lp);
1053             lp.isLockedToGrid = false;
1054             final int newX = lp.x;
1055             final int newY = lp.y;
1056             lp.x = oldX;
1057             lp.y = oldY;
1058             // Exit early if we&#x27;re not actually moving the view
1059             if ((oldX == newX) &amp;&amp; (oldY == newY)) {
1060                 lp.isLockedToGrid = true;
1061                 return true;
1062             }
1063             ValueAnimator va = ValueAnimator.ofFloat(0.0F, 1.0F);
1064             va.setDuration(duration);
1065             mReorderAnimators.put(lp, va);
1066             va.addUpdateListener(new AnimatorUpdateListener() {
1067                 @Override
1068                 public void onAnimationUpdate(ValueAnimator animation) {
1069                     float r = ((Float) (animation.getAnimatedValue())).floatValue();
1070                     child.setTranslationX(r * (newX - oldX));
1071                     child.setTranslationY(r * (newY - oldY));
1072                 }
1073             });
1074             va.addListener(new AnimatorListenerAdapter() {
1075                 boolean cancelled = false;
1076 
1077                 public void onAnimationEnd(Animator animation) {
1078                     // If the animation was cancelled, it means that another animation
1079                     // has interrupted this one, and we don&#x27;t want to lock the item into
1080                     // place just yet.
1081                     if (!cancelled) {
1082                         child.setTranslationX(0);
1083                         child.setTranslationY(0);
1084                         lp.isLockedToGrid = true;
1085                         child.requestLayout();
1086                     }
1087                     if (mReorderAnimators.containsKey(lp)) {
1088                         mReorderAnimators.remove(lp);
1089                     }
1090                 }
1091 
1092                 public void onAnimationCancel(Animator animation) {
1093                     cancelled = true;
1094                 }
1095             });
1096             va.setStartDelay(delay);
1097             va.start();
1098             return true;
1099         }
1100         return false;
1101     }
1102 
1103     /**
1104      * Estimate where the top left cell of the dragged item will land if it is dropped.
1105      *
1106      * @param originX The X value of the top left corner of the item
1107      * @param originY The Y value of the top left corner of the item
1108      * @param spanX The number of horizontal cells that the item spans
1109      * @param spanY The number of vertical cells that the item spans
1110      * @param result The estimated drop cell X and Y.
1111      */
1112     void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1113         final int countX = mCountX;
1114         final int countY = mCountY;
1115 
1116         // pointToCellRounded takes the top left of a cell but will pad that with
1117         // cellWidth/2 and cellHeight/2 when finding the matching cell
1118         pointToCellRounded(originX, originY, result);
1119 
1120         // If the item isn&#x27;t fully on this screen, snap to the edges
1121         int rightOverhang = result[0] + spanX - countX;
1122         if (rightOverhang &gt; 0) {
1123             result[0] -= rightOverhang; // Snap to right
1124         }
1125         result[0] = Math.max(0, result[0]); // Snap to left
1126         int bottomOverhang = result[1] + spanY - countY;
1127         if (bottomOverhang &gt; 0) {
1128             result[1] -= bottomOverhang; // Snap to bottom
1129         }
1130         result[1] = Math.max(0, result[1]); // Snap to top
1131     }
1132 
1133     void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1134             int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1135         final int oldDragCellX = mDragCell[0];
1136         final int oldDragCellY = mDragCell[1];
1137 
1138         if (v != null &amp;&amp; dragOffset == null) {
1139             mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1140         } else {
1141             mDragCenter.set(originX, originY);
1142         }
1143 
1144         if (dragOutline == null &amp;&amp; v == null) {
1145             if (mCrosshairsDrawable != null) {
1146                 invalidate();
1147             }
1148             return;
1149         }
1150 
1151         if (cellX != oldDragCellX || cellY != oldDragCellY) {
1152             mDragCell[0] = cellX;
1153             mDragCell[1] = cellY;
1154             // Find the top left corner of the rect the object will occupy
1155             final int[] topLeft = mTmpPoint;
1156             cellToPoint(cellX, cellY, topLeft);
1157 
1158             int left = topLeft[0];
1159             int top = topLeft[1];
1160 
1161             if (v != null &amp;&amp; dragOffset == null) {
1162                 // When drawing the drag outline, it did not account for margin offsets
1163                 // added by the view&#x27;s parent.
1164                 MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1165                 left += lp.leftMargin;
1166                 top += lp.topMargin;
1167 
1168                 // Offsets due to the size difference between the View and the dragOutline.
1169                 // There is a size difference to account for the outer blur, which may lie
1170                 // outside the bounds of the view.
1171                 top += (v.getHeight() - dragOutline.getHeight()) / 2;
1172                 // We center about the x axis
1173                 left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1174                         - dragOutline.getWidth()) / 2;
1175             } else {
1176                 if (dragOffset != null &amp;&amp; dragRegion != null) {
1177                     // Center the drag region *horizontally* in the cell and apply a drag
1178                     // outline offset
1179                     left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1180                              - dragRegion.width()) / 2;
1181                     top += dragOffset.y;
1182                 } else {
1183                     // Center the drag outline in the cell
1184                     left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1185                             - dragOutline.getWidth()) / 2;
1186                     top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1187                             - dragOutline.getHeight()) / 2;
1188                 }
1189             }
1190             final int oldIndex = mDragOutlineCurrent;
1191             mDragOutlineAnims[oldIndex].animateOut();
1192             mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1193             Rect r = mDragOutlines[mDragOutlineCurrent];
1194             r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1195             if (resize) {
1196                 cellToRect(cellX, cellY, spanX, spanY, r);
1197             }
1198 
1199             mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1200             mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1201         }
1202 
1203         // If we are drawing crosshairs, the entire CellLayout needs to be invalidated
1204         if (mCrosshairsDrawable != null) {
1205             invalidate();
1206         }
1207     }
1208 
1209     public void clearDragOutlines() {
1210         final int oldIndex = mDragOutlineCurrent;
1211         mDragOutlineAnims[oldIndex].animateOut();
1212         mDragCell[0] = mDragCell[1] = -1;
1213     }
1214 
1215     /**
1216      * Find a vacant area that will fit the given bounds nearest the requested
1217      * cell location. Uses Euclidean distance to score multiple vacant areas.
1218      *
1219      * @param pixelX The X location at which you want to search for a vacant area.
1220      * @param pixelY The Y location at which you want to search for a vacant area.
1221      * @param spanX Horizontal span of the object.
1222      * @param spanY Vertical span of the object.
1223      * @param result Array in which to place the result, or null (in which case a new array will
1224      *        be allocated)
1225      * @return The X, Y cell of a vacant area that can contain this object,
1226      *         nearest the requested location.
1227      */
1228     int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1229             int[] result) {
1230         return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1231     }
1232 
1233     /**
1234      * Find a vacant area that will fit the given bounds nearest the requested
1235      * cell location. Uses Euclidean distance to score multiple vacant areas.
1236      *
1237      * @param pixelX The X location at which you want to search for a vacant area.
1238      * @param pixelY The Y location at which you want to search for a vacant area.
1239      * @param minSpanX The minimum horizontal span required
1240      * @param minSpanY The minimum vertical span required
1241      * @param spanX Horizontal span of the object.
1242      * @param spanY Vertical span of the object.
1243      * @param result Array in which to place the result, or null (in which case a new array will
1244      *        be allocated)
1245      * @return The X, Y cell of a vacant area that can contain this object,
1246      *         nearest the requested location.
1247      */
1248     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1249             int spanY, int[] result, int[] resultSpan) {
1250         return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1251                 result, resultSpan);
1252     }
1253 
1254     /**
1255      * Find a vacant area that will fit the given bounds nearest the requested
1256      * cell location. Uses Euclidean distance to score multiple vacant areas.
1257      *
1258      * @param pixelX The X location at which you want to search for a vacant area.
1259      * @param pixelY The Y location at which you want to search for a vacant area.
1260      * @param spanX Horizontal span of the object.
1261      * @param spanY Vertical span of the object.
1262      * @param ignoreOccupied If true, the result can be an occupied cell
1263      * @param result Array in which to place the result, or null (in which case a new array will
1264      *        be allocated)
1265      * @return The X, Y cell of a vacant area that can contain this object,
1266      *         nearest the requested location.
1267      */
1268     int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1269             boolean ignoreOccupied, int[] result) {
1270         return findNearestArea(pixelX, pixelY, spanX, spanY,
1271                 spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1272     }
1273 
1274     private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1275 
1276     private void lazyInitTempRectStack() {
1277         if (mTempRectStack.isEmpty()) {
1278             for (int i = 0; i &lt; mCountX * mCountY; i++) {
1279                 mTempRectStack.push(new Rect());
1280             }
1281         }
1282     }
1283 
1284     private void recycleTempRects(Stack&lt;Rect&gt; used) {
1285         while (!used.isEmpty()) {
1286             mTempRectStack.push(used.pop());
1287         }
1288     }
1289 
1290     /**
1291      * Find a vacant area that will fit the given bounds nearest the requested
1292      * cell location. Uses Euclidean distance to score multiple vacant areas.
1293      *
1294      * @param pixelX The X location at which you want to search for a vacant area.
1295      * @param pixelY The Y location at which you want to search for a vacant area.
1296      * @param minSpanX The minimum horizontal span required
1297      * @param minSpanY The minimum vertical span required
1298      * @param spanX Horizontal span of the object.
1299      * @param spanY Vertical span of the object.
1300      * @param ignoreOccupied If true, the result can be an occupied cell
1301      * @param result Array in which to place the result, or null (in which case a new array will
1302      *        be allocated)
1303      * @return The X, Y cell of a vacant area that can contain this object,
1304      *         nearest the requested location.
1305      */
1306     int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1307             View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1308             boolean[][] occupied) {
1309         lazyInitTempRectStack();
1310         // mark space take by ignoreView as available (method checks if ignoreView is null)
1311         markCellsAsUnoccupiedForView(ignoreView, occupied);
1312 
1313         // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1314         // to the center of the item, but we are searching based on the top-left cell, so
1315         // we translate the point over to correspond to the top-left.
1316         pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1317         pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1318 
1319         // Keep track of best-scoring drop area
1320         final int[] bestXY = result != null ? result : new int[2];
1321         double bestDistance = Double.MAX_VALUE;
1322         final Rect bestRect = new Rect(-1, -1, -1, -1);
1323         final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1324 
1325         final int countX = mCountX;
1326         final int countY = mCountY;
1327 
1328         if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1329                 spanX &lt; minSpanX || spanY &lt; minSpanY) {
1330             return bestXY;
1331         }
1332 
1333         for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1334             inner:
1335             for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1336                 int ySize = -1;
1337                 int xSize = -1;
1338                 if (ignoreOccupied) {
1339                     // First, let&#x27;s see if this thing fits anywhere
1340                     for (int i = 0; i &lt; minSpanX; i++) {
1341                         for (int j = 0; j &lt; minSpanY; j++) {
1342                             if (occupied[x + i][y + j]) {
1343                                 continue inner;
1344                             }
1345                         }
1346                     }
1347                     xSize = minSpanX;
1348                     ySize = minSpanY;
1349 
1350                     // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1351                     // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1352                     // until we hit a limit.
1353                     boolean incX = true;
1354                     boolean hitMaxX = xSize &gt;= spanX;
1355                     boolean hitMaxY = ySize &gt;= spanY;
1356                     while (!(hitMaxX &amp;&amp; hitMaxY)) {
1357                         if (incX &amp;&amp; !hitMaxX) {
1358                             for (int j = 0; j &lt; ySize; j++) {
1359                                 if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1360                                     // We can&#x27;t move out horizontally
1361                                     hitMaxX = true;
1362                                 }
1363                             }
1364                             if (!hitMaxX) {
1365                                 xSize++;
1366                             }
1367                         } else if (!hitMaxY) {
1368                             for (int i = 0; i &lt; xSize; i++) {
1369                                 if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1370                                     // We can&#x27;t move out vertically
1371                                     hitMaxY = true;
1372                                 }
1373                             }
1374                             if (!hitMaxY) {
1375                                 ySize++;
1376                             }
1377                         }
1378                         hitMaxX |= xSize &gt;= spanX;
1379                         hitMaxY |= ySize &gt;= spanY;
1380                         incX = !incX;
1381                     }
1382                     incX = true;
1383                     hitMaxX = xSize &gt;= spanX;
1384                     hitMaxY = ySize &gt;= spanY;
1385                 }
1386                 final int[] cellXY = mTmpXY;
1387                 cellToCenterPoint(x, y, cellXY);
1388 
1389                 // We verify that the current rect is not a sub-rect of any of our previous
1390                 // candidates. In this case, the current rect is disqualified in favour of the
1391                 // containing rect.
1392                 Rect currentRect = mTempRectStack.pop();
1393                 currentRect.set(x, y, x + xSize, y + ySize);
1394                 boolean contained = false;
1395                 for (Rect r : validRegions) {
1396                     if (r.contains(currentRect)) {
1397                         contained = true;
1398                         break;
1399                     }
1400                 }
1401                 validRegions.push(currentRect);
1402                 double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1403                         + Math.pow(cellXY[1] - pixelY, 2));
1404 
1405                 if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1406                         currentRect.contains(bestRect)) {
1407                     bestDistance = distance;
1408                     bestXY[0] = x;
1409                     bestXY[1] = y;
1410                     if (resultSpan != null) {
1411                         resultSpan[0] = xSize;
1412                         resultSpan[1] = ySize;
1413                     }
1414                     bestRect.set(currentRect);
1415                 }
1416             }
1417         }
1418         // re-mark space taken by ignoreView as occupied
1419         markCellsAsOccupiedForView(ignoreView, occupied);
1420 
1421         // Return -1, -1 if no suitable location found
1422         if (bestDistance == Double.MAX_VALUE) {
1423             bestXY[0] = -1;
1424             bestXY[1] = -1;
1425         }
1426         recycleTempRects(validRegions);
1427         return bestXY;
1428     }
1429 
1430     /**
1431      * Find a vacant area that will fit the given bounds nearest the requested
1432      * cell location, and will also weigh in a suggested direction vector of the
1433      * desired location. This method computers distance based on unit grid distances,
1434      * not pixel distances.
1435      *
1436      * @param cellX
1437      * 		The X cell nearest to which you want to search for a vacant area.
1438      * @param cellY
1439      * 		The Y cell nearest which you want to search for a vacant area.
1440      * @param spanX
1441      * 		Horizontal span of the object.
1442      * @param spanY
1443      * 		Vertical span of the object.
1444      * @param direction
1445      * 		The favored direction in which the views should move from x, y
1446      * @param exactDirectionOnly
1447      * 		If this parameter is true, then only solutions where the direction
1448      * 		matches exactly. Otherwise we find the best matching direction.
1449      * @param occoupied
1450      * 		The array which represents which cells in the CellLayout are occupied
1451      * @param blockOccupied
1452      * 		The array which represents which cells in the specified block (cellX,
1453      * 		cellY, spanX, spanY) are occupied. This is used when try to move a group of views.
1454      * @param result
1455      * 		Array in which to place the result, or null (in which case a new array will
1456      * 		be allocated)
1457      */
<abbr title="1458     private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction, boolean[][] occupied, int[] result) {">1458     private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction, boolean[][🔵</abbr>
1459         // Keep track of best-scoring drop area
1460         final int[] bestXY = (result != null) ? result : new int[2];
1461         float bestDistance = Float.MAX_VALUE;
1462         int bestDirectionScore = Integer.MIN_VALUE;
1463         final int countX = mCountX;
1464         final int countY = mCountY;
1465         for (int y = 0; y &lt; (countY - (spanY - 1)); y++) {
1466             inner : for (int x = 0; x &lt; (countX - (spanX - 1)); x++) {
1467                 // First, let&#x27;s see if this thing fits anywhere
1468                 for (int i = 0; i &lt; spanX; i++) {
1469                     for (int j = 0; j &lt; spanY; j++) {
1470                         if (occupied[x + i][y + j]) {
1471                             continue inner;
1472                         }
1473                     }
1474                 }
<abbr title="1475                 float distance = ((float) (Math.sqrt(((x - cellX) * (x - cellX)) + ((y - cellY) * (y - cellY)))));">1475                 float distance = ((float) (Math.sqrt(((x - cellX) * (x - cellX)) + ((y - cellY) * (y - ce🔵</abbr>
1476                 int[] curDirection = mTmpPoint;
1477                 computeDirectionVector(cellX, cellY, x, y, curDirection);
<abbr title="1478                 int curDirectionScore = (direction[0] * curDirection[0]) + (direction[1] * curDirection[1]);">1478                 int curDirectionScore = (direction[0] * curDirection[0]) + (direction[1] * curDirection[1🔵</abbr>
<abbr title="1479                 if ((Float.compare(distance, bestDistance) &lt; 0) || ((Float.compare(distance, bestDistance) == 0) &amp;&amp; (curDirectionScore &gt; bestDirectionScore))) {">1479                 if ((Float.compare(distance, bestDistance) &lt; 0) || ((Float.compare(distance, bestDistance🔵</abbr>
1480                     bestDistance = distance;
1481                     bestDirectionScore = curDirectionScore;
1482                     bestXY[0] = x;
1483                     bestXY[1] = y;
1484                 }
1485             }
1486         }
1487         // Return -1, -1 if no suitable location found
1488         if (bestDistance == Float.MAX_VALUE) {
1489             bestXY[0] = -1;
1490             bestXY[1] = -1;
1491         }
1492         return bestXY;
1493     }
1494 
1495     private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop, int[] direction) {
1496         LayoutParams lp = ((LayoutParams) (v.getLayoutParams()));
1497         boolean success = false;
1498         markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan, mTmpOccupied, false);
1499         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
<abbr title="1500         findNearestArea(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan, direction, mTmpOccupied, mTempLocation);">1500         findNearestArea(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan, direction, mTmpOccupied, mT🔵</abbr>
1501         if ((mTempLocation[0] &gt;= 0) &amp;&amp; (mTempLocation[1] &gt;= 0)) {
1502             lp.tmpCellX = mTempLocation[0];
1503             lp.tmpCellY = mTempLocation[1];
1504             success = true;
1505         }
1506         markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan, mTmpOccupied, true);
1507         return success;
1508     }
1509 
<abbr title="1510     private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop, int[] direction) {">1510     private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop, int[]🔵</abbr>
1511         if (views.size() == 0) {
1512             return true;
1513         }
1514         boolean success = false;
1515         // We construct a rect which represents the entire group of views
1516         Rect boundingRect = null;
1517         for (View v : views) {
1518             LayoutParams lp = ((LayoutParams) (v.getLayoutParams()));
1519             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan, mTmpOccupied, false);
1520             if (boundingRect == null) {
<abbr title="1521                 boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp.cellVSpan);">1521                 boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY🔵</abbr>
1522             } else {
<abbr title="1523                 boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp.cellVSpan);">1523                 boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp🔵</abbr>
1524             }
1525         }
1526         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1527         // TODO: this bounding rect may not be completely filled, lets be more precise about this
1528         // check.
<abbr title="1529         findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(), boundingRect.height(), direction, mTmpOccupied, mTempLocation);">1529         findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(), boundingRect.height(),🔵</abbr>
1530         int deltaX = mTempLocation[0] - boundingRect.left;
1531         int deltaY = mTempLocation[1] - boundingRect.top;
1532         if ((mTempLocation[0] &gt;= 0) &amp;&amp; (mTempLocation[1] &gt;= 0)) {
1533             for (View v : views) {
1534                 LayoutParams lp = ((LayoutParams) (v.getLayoutParams()));
1535                 lp.tmpCellX += deltaX;
1536                 lp.tmpCellY += deltaY;
1537             }
1538             success = true;
1539         }
1540         for (View v : views) {
1541             LayoutParams lp = ((LayoutParams) (v.getLayoutParams()));
1542             markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan, mTmpOccupied, true);
1543         }
1544         return success;
1545     }
1546 
1547     private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1548         markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1549     }
1550 
<abbr title="1551     private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction, View ignoreView) {">1551     private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction, View🔵</abbr>
1552         mIntersectingViews.clear();
1553         mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
1554         markCellsForRect(mOccupiedRect, mTmpOccupied, true);
1555         if (ignoreView != null) {
1556             LayoutParams lp = ((LayoutParams) (ignoreView.getLayoutParams()));
1557             lp.tmpCellX = cellX;
1558             lp.tmpCellY = cellY;
1559         }
1560         int childCount = mShortcutsAndWidgets.getChildCount();
1561         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1562         Rect r1 = new Rect();
1563         for (int i = 0; i &lt; childCount; i++) {
1564             View child = mShortcutsAndWidgets.getChildAt(i);
1565             if (child == ignoreView) {
1566                 continue;
1567             }
1568             LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1569             r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
1570             if (Rect.intersects(r0, r1)) {
1571                 if (!lp.canReorder) {
1572                     return false;
1573                 }
1574                 mIntersectingViews.add(child);
1575             }
1576         }
1577         // First we try moving the views as a block
1578         if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {
1579             return true;
1580         }
1581         // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1582         for (View v : mIntersectingViews) {
1583             if (!addViewToTempLocation(v, mOccupiedRect, direction)) {
1584                 return false;
1585             }
1586         }
1587         return true;
1588     }
1589 
1590     /*
1591      * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1592      * the provided point and the provided cell
1593      */
1594     private void computeDirectionVector(int x0, int y0, int x1, int y1, int[] result) {
1595         int deltaX = x1 - x0;
1596         int deltaY = y1 - y0;
1597         double angle = Math.atan(((float) (deltaY)) / deltaX);
1598         result[0] = 0;
1599         result[1] = 0;
1600         if (Math.abs(Math.cos(angle)) &gt; 0.5F) {
1601             result[0] = ((int) (Math.signum(deltaX)));
1602         }
1603         if (Math.abs(Math.sin(angle)) &gt; 0.5F) {
1604             result[1] = ((int) (Math.signum(deltaY)));
1605         }
1606     }
1607 
1608     ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1609             int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1610         // This creates a copy of the current occupied array, omitting the current view being
1611         // dragged
1612         resetTempLayoutToCurrent(dragView);
1613 
1614         // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1615         // nothing in its way.
1616         int result[] = new int[2];
1617         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1618 
1619         boolean success = false;
1620         // First we try the exact nearest position of the item being dragged,
1621         // we will then want to try to move this around to other neighbouring positions
1622         success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView);
1623 
1624         if (!success) {
1625             // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1626             // x, then 1 in y etc.
1627             if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1628                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1629                         dragView, false, solution);
1630             } else if (spanY &gt; minSpanY) {
1631                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1632                         dragView, true, solution);
1633             }
1634             solution.isSolution = false;
1635         } else {
1636             solution.isSolution = true;
1637             solution.dragViewX = result[0];
1638             solution.dragViewY = result[1];
1639             solution.dragViewSpanX = spanX;
1640             solution.dragViewSpanY = spanY;
1641             copyCurrentStateToSolution(solution, true);
1642         }
1643         return solution;
1644     }
1645 
1646     private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1647         int childCount = mShortcutsAndWidgets.getChildCount();
1648         for (int i = 0; i &lt; childCount; i++) {
1649             View child = mShortcutsAndWidgets.getChildAt(i);
1650             LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1651             Point p;
1652             if (temp) {
1653                 p = new Point(lp.tmpCellX, lp.tmpCellY);
1654             } else {
1655                 p = new Point(lp.cellX, lp.cellY);
1656             }
1657             solution.map.put(child, p);
1658         }
1659     }
1660 
1661     private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1662         for (int i = 0; i &lt; mCountX; i++) {
1663             for (int j = 0; j &lt; mCountY; j++) {
1664                 mTmpOccupied[i][j] = false;
1665             }
1666         }
1667         int childCount = mShortcutsAndWidgets.getChildCount();
1668         for (int i = 0; i &lt; childCount; i++) {
1669             View child = mShortcutsAndWidgets.getChildAt(i);
1670             if (child == dragView) {
1671                 continue;
1672             }
1673             LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1674             Point p = solution.map.get(child);
1675             if (p != null) {
1676                 lp.tmpCellX = p.x;
1677                 lp.tmpCellY = p.y;
<abbr title="1678                 markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan, mTmpOccupied, true);">1678                 markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan, mTmpOccupied, true🔵</abbr>
1679             }
1680         }
<abbr title="1681         markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX, solution.dragViewSpanY, mTmpOccupied, true);">1681         markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX, solution.dragVie🔵</abbr>
1682     }
1683 
<abbr title="1684     private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean commitDragView) {">1684     private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean commitDragView🔵</abbr>
1685         boolean[][] occupied = (DESTRUCTIVE_REORDER) ? mOccupied : mTmpOccupied;
1686         for (int i = 0; i &lt; mCountX; i++) {
1687             for (int j = 0; j &lt; mCountY; j++) {
1688                 occupied[i][j] = false;
1689             }
1690         }
1691         int childCount = mShortcutsAndWidgets.getChildCount();
1692         for (int i = 0; i &lt; childCount; i++) {
1693             View child = mShortcutsAndWidgets.getChildAt(i);
1694             if (child == dragView) {
1695                 continue;
1696             }
1697             LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1698             Point p = solution.map.get(child);
1699             if (p != null) {
1700                 if ((lp.cellX != p.x) || (lp.cellY != p.y)) {
1701                     animateChildToPosition(child, p.x, p.y, 150, 0, DESTRUCTIVE_REORDER, false);
1702                 }
1703                 markCellsForView(p.x, p.y, lp.cellHSpan, lp.cellVSpan, occupied, true);
1704             }
1705         }
1706         if (commitDragView) {
<abbr title="1707             markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX, solution.dragViewSpanY, occupied, true);">1707             markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX, solution.dra🔵</abbr>
1708         }
1709     }
1710 
1711     private void commitTempPlacement() {
1712         for (int i = 0; i &lt; mCountX; i++) {
1713             for (int j = 0; j &lt; mCountY; j++) {
1714                 mOccupied[i][j] = mTmpOccupied[i][j];
1715             }
1716         }
1717         int childCount = mShortcutsAndWidgets.getChildCount();
1718         for (int i = 0; i &lt; childCount; i++) {
1719             LayoutParams lp = ((LayoutParams) (mShortcutsAndWidgets.getChildAt(i).getLayoutParams()));
1720             lp.cellX = lp.tmpCellX;
1721             lp.cellY = lp.tmpCellY;
1722         }
1723     }
1724 
1725     public void setUseTempCoords(boolean useTempCoords) {
1726         int childCount = mShortcutsAndWidgets.getChildCount();
1727         for (int i = 0; i &lt; childCount; i++) {
1728             LayoutParams lp = ((LayoutParams) (mShortcutsAndWidgets.getChildAt(i).getLayoutParams()));
1729             lp.useTmpCoords = useTempCoords;
1730         }
1731     }
1732 
1733     private void resetTempLayoutToCurrent(View ignoreView) {
1734         for (int i = 0; i &lt; mCountX; i++) {
1735             for (int j = 0; j &lt; mCountY; j++) {
1736                 mTmpOccupied[i][j] = mOccupied[i][j];
1737             }
1738         }
1739         int childCount = mShortcutsAndWidgets.getChildCount();
1740         for (int i = 0; i &lt; childCount; i++) {
1741             View child = mShortcutsAndWidgets.getChildAt(i);
1742             if (child == ignoreView) {
1743                 continue;
1744             }
1745             LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1746             lp.tmpCellX = lp.cellX;
1747             lp.tmpCellY = lp.cellY;
1748         }
1749     }
1750 
1751     ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
1752             int spanX, int spanY, View dragView, ItemConfiguration solution) {
1753         int[] result = new int[2];
1754         int[] resultSpan = new int[2];
1755         findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
1756                 resultSpan);
1757         if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
1758             copyCurrentStateToSolution(solution, false);
1759             solution.dragViewX = result[0];
1760             solution.dragViewY = result[1];
1761             solution.dragViewSpanX = resultSpan[0];
1762             solution.dragViewSpanY = resultSpan[1];
1763             solution.isSolution = true;
1764         } else {
1765             solution.isSolution = false;
1766         }
1767         return solution;
1768     }
1769 
1770     public void prepareChildForDrag(View child) {
1771         markCellsAsUnoccupiedForView(child);
1772         LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1773         lp.cellX = -1;
1774         lp.cellY = -1;
1775     }
1776 
<abbr title="1777     int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY, View dragView, int[] result, int[] resultSpan, int mode) {">1777     int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY, View dragV🔵</abbr>
1778         // First we determine if things have moved enough to cause a different layout
1779         result = findNearestArea(pixelX, pixelY, 1, 1, result);
1780         if (resultSpan == null) {
1781             resultSpan = new int[2];
1782         }
1783         // We attempt the first algorithm
1784         cellToCenterPoint(result[0], result[1], mTmpPoint);
1785         computeDirectionVector(pixelX, pixelY, mTmpPoint[0], mTmpPoint[1], mDirectionVector);
<abbr title="1786         ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, mDirectionVector, dragView, true, new ItemConfiguration());">1786         ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, mDi🔵</abbr>
1787         // We attempt the approach which doesn&#x27;t shuffle views at all
<abbr title="1788         ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, dragView, new ItemConfiguration());">1788         ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX, minSpa🔵</abbr>
1789         ItemConfiguration finalSolution = null;
1790         if (swapSolution.isSolution &amp;&amp; (swapSolution.area() &gt;= noShuffleSolution.area())) {
1791             finalSolution = swapSolution;
1792         } else if (noShuffleSolution.isSolution) {
1793             finalSolution = noShuffleSolution;
1794         }
1795         boolean foundSolution = true;
1796         if (!DESTRUCTIVE_REORDER) {
1797             setUseTempCoords(true);
1798         }
1799         if (finalSolution != null) {
1800             result[0] = finalSolution.dragViewX;
1801             result[1] = finalSolution.dragViewY;
1802             resultSpan[0] = finalSolution.dragViewSpanX;
1803             resultSpan[1] = finalSolution.dragViewSpanY;
1804             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
1805             // committing anything or animating anything as we just want to determine if a solution
1806             // exists
<abbr title="1807             if (((mode == MODE_DRAG_OVER) || (mode == MODE_ON_DROP)) || (mode == MODE_ON_DROP_EXTERNAL)) {">1807             if (((mode == MODE_DRAG_OVER) || (mode == MODE_ON_DROP)) || (mode == MODE_ON_DROP_EXTERNAL)) 🔵</abbr>
1808                 if (!DESTRUCTIVE_REORDER) {
1809                     copySolutionToTempState(finalSolution, dragView);
1810                 }
1811                 setItemPlacementDirty(true);
1812                 animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
1813                 if ((!DESTRUCTIVE_REORDER) &amp;&amp; (mode == MODE_ON_DROP)) {
1814                     commitTempPlacement();
1815                 }
1816             }
1817         } else {
1818             foundSolution = false;
1819             result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
1820         }
1821         if (((mode == MODE_ON_DROP) || (!foundSolution)) &amp;&amp; (!DESTRUCTIVE_REORDER)) {
1822             setUseTempCoords(false);
1823         }
1824         boolean[][] occupied = mOccupied;
1825         mShortcutsAndWidgets.requestLayout();
1826         return result;
1827     }
1828 
1829     public boolean isItemPlacementDirty() {
1830         return mItemLocationsDirty;
1831     }
1832 
1833     public void setItemPlacementDirty(boolean dirty) {
1834         mItemLocationsDirty = dirty;
1835     }
1836 
1837     private class ItemConfiguration {
1838         HashMap&lt;View, Point&gt; map = new HashMap&lt;View, Point&gt;();
1839 
1840         boolean isSolution = false;
1841 
1842         int dragViewX;
1843 
1844         int dragViewY;
1845 
1846         int dragViewSpanX;
1847 
1848         int dragViewSpanY;
1849 
1850         int area() {
1851             return dragViewSpanX * dragViewSpanY;
1852         }
1853 
1854         void clear() {
1855             map.clear();
1856             isSolution = false;
1857         }
1858     }
1859 
1860     /**
1861      * Find a vacant area that will fit the given bounds nearest the requested
1862      * cell location. Uses Euclidean distance to score multiple vacant areas.
1863      *
1864      * @param pixelX The X location at which you want to search for a vacant area.
1865      * @param pixelY The Y location at which you want to search for a vacant area.
1866      * @param spanX Horizontal span of the object.
1867      * @param spanY Vertical span of the object.
1868      * @param ignoreView Considers space occupied by this view as unoccupied
1869      * @param result Previously returned value to possibly recycle.
1870      * @return The X, Y cell of a vacant area that can contain this object,
1871      *         nearest the requested location.
1872      */
1873     int[] findNearestVacantArea(
1874             int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
1875         return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
1876     }
1877 
1878     /**
1879      * Find a vacant area that will fit the given bounds nearest the requested
1880      * cell location. Uses Euclidean distance to score multiple vacant areas.
1881      *
1882      * @param pixelX The X location at which you want to search for a vacant area.
1883      * @param pixelY The Y location at which you want to search for a vacant area.
1884      * @param minSpanX The minimum horizontal span required
1885      * @param minSpanY The minimum vertical span required
1886      * @param spanX Horizontal span of the object.
1887      * @param spanY Vertical span of the object.
1888      * @param ignoreView Considers space occupied by this view as unoccupied
1889      * @param result Previously returned value to possibly recycle.
1890      * @return The X, Y cell of a vacant area that can contain this object,
1891      *         nearest the requested location.
1892      */
1893     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
1894             int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
1895         return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
1896                 result, resultSpan, mOccupied);
1897     }
1898 
1899     /**
1900      * Find a starting cell position that will fit the given bounds nearest the requested
1901      * cell location. Uses Euclidean distance to score multiple vacant areas.
1902      *
1903      * @param pixelX The X location at which you want to search for a vacant area.
1904      * @param pixelY The Y location at which you want to search for a vacant area.
1905      * @param spanX Horizontal span of the object.
1906      * @param spanY Vertical span of the object.
1907      * @param ignoreView Considers space occupied by this view as unoccupied
1908      * @param result Previously returned value to possibly recycle.
1909      * @return The X, Y cell of a vacant area that can contain this object,
1910      *         nearest the requested location.
1911      */
1912     int[] findNearestArea(
1913             int pixelX, int pixelY, int spanX, int spanY, int[] result) {
1914         return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
1915     }
1916 
1917     boolean existsEmptyCell() {
1918         return findCellForSpan(null, 1, 1);
1919     }
1920 
1921     /**
1922      * Finds the upper-left coordinate of the first rectangle in the grid that can
1923      * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
1924      * then this method will only return coordinates for rectangles that contain the cell
1925      * (intersectX, intersectY)
1926      *
1927      * @param cellXY The array that will contain the position of a vacant cell if such a cell
1928      *               can be found.
1929      * @param spanX The horizontal span of the cell we want to find.
1930      * @param spanY The vertical span of the cell we want to find.
1931      *
1932      * @return True if a vacant cell of the specified dimension was found, false otherwise.
1933      */
1934     boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
1935         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
1936     }
1937 
1938     /**
1939      * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
1940      *
1941      * @param cellXY The array that will contain the position of a vacant cell if such a cell
1942      *               can be found.
1943      * @param spanX The horizontal span of the cell we want to find.
1944      * @param spanY The vertical span of the cell we want to find.
1945      * @param ignoreView The home screen item we should treat as not occupying any space
1946      * @return
1947      */
1948     boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
1949         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
1950                 ignoreView, mOccupied);
1951     }
1952 
1953     /**
1954      * Like above, but if intersectX and intersectY are not -1, then this method will try to
1955      * return coordinates for rectangles that contain the cell [intersectX, intersectY]
1956      *
1957      * @param spanX The horizontal span of the cell we want to find.
1958      * @param spanY The vertical span of the cell we want to find.
1959      * @param ignoreView The home screen item we should treat as not occupying any space
1960      * @param intersectX The X coordinate of the cell that we should try to overlap
1961      * @param intersectX The Y coordinate of the cell that we should try to overlap
1962      *
1963      * @return True if a vacant cell of the specified dimension was found, false otherwise.
1964      */
1965     boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
1966             int intersectX, int intersectY) {
1967         return findCellForSpanThatIntersectsIgnoring(
1968                 cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
1969     }
1970 
1971     /**
1972      * The superset of the above two methods
1973      */
1974     boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
1975             int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
1976         // mark space take by ignoreView as available (method checks if ignoreView is null)
1977         markCellsAsUnoccupiedForView(ignoreView, occupied);
1978 
1979         boolean foundCell = false;
1980         while (true) {
1981             int startX = 0;
1982             if (intersectX &gt;= 0) {
1983                 startX = Math.max(startX, intersectX - (spanX - 1));
1984             }
1985             int endX = mCountX - (spanX - 1);
1986             if (intersectX &gt;= 0) {
1987                 endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
1988             }
1989             int startY = 0;
1990             if (intersectY &gt;= 0) {
1991                 startY = Math.max(startY, intersectY - (spanY - 1));
1992             }
1993             int endY = mCountY - (spanY - 1);
1994             if (intersectY &gt;= 0) {
1995                 endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
1996             }
1997 
1998             for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
1999                 inner:
2000                 for (int x = startX; x &lt; endX; x++) {
2001                     for (int i = 0; i &lt; spanX; i++) {
2002                         for (int j = 0; j &lt; spanY; j++) {
2003                             if (occupied[x + i][y + j]) {
2004                                 // small optimization: we can skip to after the column we just found
2005                                 // an occupied cell
2006                                 x += i;
2007                                 continue inner;
2008                             }
2009                         }
2010                     }
2011                     if (cellXY != null) {
2012                         cellXY[0] = x;
2013                         cellXY[1] = y;
2014                     }
2015                     foundCell = true;
2016                     break;
2017                 }
2018             }
2019             if (intersectX == -1 &amp;&amp; intersectY == -1) {
2020                 break;
2021             } else {
2022                 // if we failed to find anything, try again but without any requirements of
2023                 // intersecting
2024                 intersectX = -1;
2025                 intersectY = -1;
2026                 continue;
2027             }
2028         }
2029 
2030         // re-mark space taken by ignoreView as occupied
2031         markCellsAsOccupiedForView(ignoreView, occupied);
2032         return foundCell;
2033     }
2034 
2035     /**
2036      * A drag event has begun over this layout.
2037      * It may have begun over this layout (in which case onDragChild is called first),
2038      * or it may have begun on another layout.
2039      */
2040     void onDragEnter() {
2041         if (!mDragging) {
2042             // Fade in the drag indicators
2043             if (mCrosshairsAnimator != null) {
2044                 mCrosshairsAnimator.animateIn();
2045             }
2046         }
2047         mDragging = true;
2048     }
2049 
2050     /**
2051      * Called when drag has left this CellLayout or has been completed (successfully or not)
2052      */
2053     void onDragExit() {
2054         // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2055         // item to this layout via the customize drawer.
2056         // Guard against that case.
2057         if (mDragging) {
2058             mDragging = false;
2059 
2060             // Fade out the drag indicators
2061             if (mCrosshairsAnimator != null) {
2062                 mCrosshairsAnimator.animateOut();
2063             }
2064         }
2065 
2066         // Invalidate the drag data
2067         mDragCell[0] = mDragCell[1] = -1;
2068         mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2069         mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2070 
2071         setIsDragOverlapping(false);
2072     }
2073 
2074     /**
2075      * Mark a child as having been dropped.
2076      * At the beginning of the drag operation, the child may have been on another
2077      * screen, but it is re-parented before this method is called.
2078      *
2079      * @param child The child that is being dropped
2080      */
2081     void onDropChild(View child) {
2082         if (child != null) {
2083             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2084             lp.dropped = true;
2085             child.requestLayout();
2086         }
2087     }
2088 
2089     /**
2090      * Computes a bounding rectangle for a range of cells
2091      *
2092      * @param cellX X coordinate of upper left corner expressed as a cell position
2093      * @param cellY Y coordinate of upper left corner expressed as a cell position
2094      * @param cellHSpan Width in cells
2095      * @param cellVSpan Height in cells
2096      * @param resultRect Rect into which to put the results
2097      */
2098     public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2099         final int cellWidth = mCellWidth;
2100         final int cellHeight = mCellHeight;
2101         final int widthGap = mWidthGap;
2102         final int heightGap = mHeightGap;
2103 
2104         final int hStartPadding = getPaddingLeft();
2105         final int vStartPadding = getPaddingTop();
2106 
2107         int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2108         int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2109 
2110         int x = hStartPadding + cellX * (cellWidth + widthGap);
2111         int y = vStartPadding + cellY * (cellHeight + heightGap);
2112 
2113         resultRect.set(x, y, x + width, y + height);
2114     }
2115 
2116     /**
2117      * Computes the required horizontal and vertical cell spans to always
2118      * fit the given rectangle.
2119      *
2120      * @param width Width in pixels
2121      * @param height Height in pixels
2122      * @param result An array of length 2 in which to store the result (may be null).
2123      */
2124     public int[] rectToCell(int width, int height, int[] result) {
2125         return rectToCell(getResources(), width, height, result);
2126     }
2127 
2128     public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2129         // Always assume we&#x27;re working with the smallest span to make sure we
2130         // reserve enough space in both orientations.
2131         int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2132         int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2133         int smallerSize = Math.min(actualWidth, actualHeight);
2134 
2135         // Always round up to next largest cell
2136         int spanX = (int) Math.ceil(width / (float) smallerSize);
2137         int spanY = (int) Math.ceil(height / (float) smallerSize);
2138 
2139         if (result == null) {
2140             return new int[] { spanX, spanY };
2141         }
2142         result[0] = spanX;
2143         result[1] = spanY;
2144         return result;
2145     }
2146 
2147     public int[] cellSpansToSize(int hSpans, int vSpans) {
2148         int[] size = new int[2];
2149         size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2150         size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2151         return size;
2152     }
2153 
2154     /**
2155      * Calculate the grid spans needed to fit given item
2156      */
2157     public void calculateSpans(ItemInfo info) {
2158         final int minWidth;
2159         final int minHeight;
2160 
2161         if (info instanceof LauncherAppWidgetInfo) {
2162             minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2163             minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2164         } else if (info instanceof PendingAddWidgetInfo) {
2165             minWidth = ((PendingAddWidgetInfo) info).minWidth;
2166             minHeight = ((PendingAddWidgetInfo) info).minHeight;
2167         } else {
2168             // It&#x27;s not a widget, so it must be 1x1
2169             info.spanX = info.spanY = 1;
2170             return;
2171         }
2172         int[] spans = rectToCell(minWidth, minHeight, null);
2173         info.spanX = spans[0];
2174         info.spanY = spans[1];
2175     }
2176 
2177     /**
2178      * Find the first vacant cell, if there is one.
2179      *
2180      * @param vacant Holds the x and y coordinate of the vacant cell
2181      * @param spanX Horizontal cell span.
2182      * @param spanY Vertical cell span.
2183      *
2184      * @return True if a vacant cell was found
2185      */
2186     public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2187 
2188         return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2189     }
2190 
2191     static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2192             int xCount, int yCount, boolean[][] occupied) {
2193 
2194         for (int y = 0; y &lt; yCount; y++) {
2195             for (int x = 0; x &lt; xCount; x++) {
2196                 boolean available = !occupied[x][y];
2197     out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2198                     for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2199                         available = available &amp;&amp; !occupied[i][j];
2200                         if (!available) break out;
2201                     }
2202                 }
2203 
2204                 if (available) {
2205                     vacant[0] = x;
2206                     vacant[1] = y;
2207                     return true;
2208                 }
2209             }
2210         }
2211 
2212         return false;
2213     }
2214 
2215     private void clearOccupiedCells() {
2216         for (int x = 0; x &lt; mCountX; x++) {
2217             for (int y = 0; y &lt; mCountY; y++) {
2218                 mOccupied[x][y] = false;
2219             }
2220         }
2221     }
2222 
2223     /**
2224      * Given a view, determines how much that view can be expanded in all directions, in terms of
2225      * whether or not there are other items occupying adjacent cells. Used by the
2226      * AppWidgetResizeFrame to determine how the widget can be resized.
2227      */
2228     public void getExpandabilityArrayForView(View view, int[] expandability) {
2229         final LayoutParams lp = (LayoutParams) view.getLayoutParams();
2230         boolean flag;
2231 
2232         expandability[AppWidgetResizeFrame.LEFT] = 0;
2233         for (int x = lp.cellX - 1; x &gt;= 0; x--) {
2234             flag = false;
2235             for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2236                 if (mOccupied[x][y]) flag = true;
2237             }
2238             if (flag) break;
2239             expandability[AppWidgetResizeFrame.LEFT]++;
2240         }
2241 
2242         expandability[AppWidgetResizeFrame.TOP] = 0;
2243         for (int y = lp.cellY - 1; y &gt;= 0; y--) {
2244             flag = false;
2245             for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2246                 if (mOccupied[x][y]) flag = true;
2247             }
2248             if (flag) break;
2249             expandability[AppWidgetResizeFrame.TOP]++;
2250         }
2251 
2252         expandability[AppWidgetResizeFrame.RIGHT] = 0;
2253         for (int x = lp.cellX + lp.cellHSpan; x &lt; mCountX; x++) {
2254             flag = false;
2255             for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2256                 if (mOccupied[x][y]) flag = true;
2257             }
2258             if (flag) break;
2259             expandability[AppWidgetResizeFrame.RIGHT]++;
2260         }
2261 
2262         expandability[AppWidgetResizeFrame.BOTTOM] = 0;
2263         for (int y = lp.cellY + lp.cellVSpan; y &lt; mCountY; y++) {
2264             flag = false;
2265             for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2266                 if (mOccupied[x][y]) flag = true;
2267             }
2268             if (flag) break;
2269             expandability[AppWidgetResizeFrame.BOTTOM]++;
2270         }
2271     }
2272 
2273     public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2274         markCellsAsUnoccupiedForView(view);
2275         markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2276     }
2277 
2278     public void markCellsAsOccupiedForView(View view) {
2279         markCellsAsOccupiedForView(view, mOccupied);
2280     }
2281 
2282     public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2283         if ((view == null) || (view.getParent() != mShortcutsAndWidgets)) {
2284             return;
2285         }
2286         LayoutParams lp = ((LayoutParams) (view.getLayoutParams()));
2287         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2288     }
2289 
2290     public void markCellsAsUnoccupiedForView(View view) {
2291         markCellsAsUnoccupiedForView(view, mOccupied);
2292     }
2293 
2294     public void markCellsAsUnoccupiedForView(View view, boolean[][] occupied) {
2295         if ((view == null) || (view.getParent() != mShortcutsAndWidgets)) {
2296             return;
2297         }
2298         LayoutParams lp = ((LayoutParams) (view.getLayoutParams()));
2299         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2300     }
2301 
2302     private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2303             boolean value) {
2304         if (cellX &lt; 0 || cellY &lt; 0) return;
2305         for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2306             for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2307                 occupied[x][y] = value;
2308             }
2309         }
2310     }
2311 
2312     public int getDesiredWidth() {
2313         return mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
2314                 (Math.max((mCountX - 1), 0) * mWidthGap);
2315     }
2316 
2317     public int getDesiredHeight()  {
2318         return mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
2319                 (Math.max((mCountY - 1), 0) * mHeightGap);
2320     }
2321 
2322     public boolean isOccupied(int x, int y) {
2323         if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2324             return mOccupied[x][y];
2325         } else {
2326             throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2327         }
2328     }
2329 
2330     @Override
2331     public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2332         return new CellLayout.LayoutParams(getContext(), attrs);
2333     }
2334 
2335     @Override
2336     protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2337         return p instanceof CellLayout.LayoutParams;
2338     }
2339 
2340     @Override
2341     protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2342         return new CellLayout.LayoutParams(p);
2343     }
2344 
2345     public static class CellLayoutAnimationController extends LayoutAnimationController {
2346         public CellLayoutAnimationController(Animation animation, float delay) {
2347             super(animation, delay);
2348         }
2349 
2350         @Override
2351         protected long getDelayForView(View view) {
2352             return ((int) (Math.random() * 150));
2353         }
2354     }
2355 
2356     public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2357         /**
2358          * Horizontal location of the item in the grid.
2359          */
2360         @ViewDebug.ExportedProperty
2361         public int cellX;
2362 
2363         /**
2364          * Vertical location of the item in the grid.
2365          */
2366         @ViewDebug.ExportedProperty
2367         public int cellY;
2368 
2369         /**
2370          * Temporary horizontal location of the item in the grid during reorder
2371          */
2372         public int tmpCellX;
2373 
2374         /**
2375          * Temporary vertical location of the item in the grid during reorder
2376          */
2377         public int tmpCellY;
2378 
2379         /**
2380          * Indicates that the temporary coordinates should be used to layout the items
2381          */
2382         public boolean useTmpCoords;
2383 
2384         /**
2385          * Number of cells spanned horizontally by the item.
2386          */
2387         @ViewDebug.ExportedProperty
2388         public int cellHSpan;
2389 
2390         /**
2391          * Number of cells spanned vertically by the item.
2392          */
2393         @ViewDebug.ExportedProperty
2394         public int cellVSpan;
2395 
2396         /**
2397          * Indicates whether the item will set its x, y, width and height parameters freely,
2398          * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2399          */
2400         public boolean isLockedToGrid = true;
2401 
2402         /**
2403          * Indicates whether this item can be reordered. Always true except in the case of the
2404          * the AllApps button.
2405          */
2406         public boolean canReorder = true;
2407 
2408         // X coordinate of the view in the layout.
2409         @ViewDebug.ExportedProperty
2410         int x;
2411 
2412         // Y coordinate of the view in the layout.
2413         @ViewDebug.ExportedProperty
2414         int y;
2415 
2416         boolean dropped;
2417 
2418         public LayoutParams(Context c, AttributeSet attrs) {
2419             super(c, attrs);
2420             cellHSpan = 1;
2421             cellVSpan = 1;
2422         }
2423 
2424         public LayoutParams(ViewGroup.LayoutParams source) {
2425             super(source);
2426             cellHSpan = 1;
2427             cellVSpan = 1;
2428         }
2429 
2430         public LayoutParams(LayoutParams source) {
2431             super(source);
2432             this.cellX = source.cellX;
2433             this.cellY = source.cellY;
2434             this.cellHSpan = source.cellHSpan;
2435             this.cellVSpan = source.cellVSpan;
2436         }
2437 
2438         public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2439             super(CellLayout.LayoutParams.MATCH_PARENT, CellLayout.LayoutParams.MATCH_PARENT);
2440             this.cellX = cellX;
2441             this.cellY = cellY;
2442             this.cellHSpan = cellHSpan;
2443             this.cellVSpan = cellVSpan;
2444         }
2445 
2446         public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2447             if (isLockedToGrid) {
2448                 final int myCellHSpan = cellHSpan;
2449                 final int myCellVSpan = cellVSpan;
2450                 final int myCellX = (useTmpCoords) ? tmpCellX : cellX;
2451                 final int myCellY = (useTmpCoords) ? tmpCellY : cellY;
<abbr title="2452                 width = (((myCellHSpan * cellWidth) + ((myCellHSpan - 1) * widthGap)) - leftMargin) - rightMargin;">2452                 width = (((myCellHSpan * cellWidth) + ((myCellHSpan - 1) * widthGap)) - leftMargin) - rig🔵</abbr>
<abbr title="2453                 height = (((myCellVSpan * cellHeight) + ((myCellVSpan - 1) * heightGap)) - topMargin) - bottomMargin;">2453                 height = (((myCellVSpan * cellHeight) + ((myCellVSpan - 1) * heightGap)) - topMargin) - b🔵</abbr>
2454                 x = ((int) ((myCellX * (cellWidth + widthGap)) + leftMargin));
2455                 y = ((int) ((myCellY * (cellHeight + heightGap)) + topMargin));
2456             }
2457         }
2458 
2459         public String toString() {
2460             return (((&quot;(&quot; + this.cellX) + &quot;, &quot;) + this.cellY) + &quot;)&quot;;
2461         }
2462 
2463         public void setWidth(int width) {
2464             this.width = width;
2465         }
2466 
2467         public int getWidth() {
2468             return width;
2469         }
2470 
2471         public void setHeight(int height) {
2472             this.height = height;
2473         }
2474 
2475         public int getHeight() {
2476             return height;
2477         }
2478 
2479         public void setX(int x) {
2480             this.x = x;
2481         }
2482 
2483         public int getX() {
2484             return x;
2485         }
2486 
2487         public void setY(int y) {
2488             this.y = y;
2489         }
2490 
2491         public int getY() {
2492             return y;
2493         }
2494     }
2495 
2496     // This class stores info for two purposes:
2497     // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
2498     // its spanX, spanY, and the screen it is on
2499     // 2. When long clicking on an empty cell in a CellLayout, we save information about the
2500     // cellX and cellY coordinates and which page was clicked. We then set this as a tag on
2501     // the CellLayout that was long clicked
2502     static final class CellInfo {
2503         View cell;
2504 
2505         int cellX = -1;
2506 
2507         int cellY = -1;
2508 
2509         int spanX;
2510 
2511         int spanY;
2512 
2513         int screen;
2514 
2515         long container;
2516 
2517         @Override
2518         public String toString() {
<abbr title="2519             return (((((&quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())) + &quot;, x=&quot;) + cellX) + &quot;, y=&quot;) + cellY) + &quot;]&quot;;">2519             return (((((&quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())) + &quot;, x=&quot;) + cellX) + &quot;,🔵</abbr>
2520         }
2521     }
2522 
2523     public boolean lastDownOnOccupiedCell() {
2524         return mLastDownOnOccupiedCell;
2525     }
2526 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.Animator;
  20  import android.animation.AnimatorListenerAdapter;
  21  import android.animation.ObjectAnimator;
  22  import android.animation.PropertyValuesHolder;
  23  import android.animation.TimeInterpolator;
  24  import android.animation.ValueAnimator;
  25  import android.animation.ValueAnimator.AnimatorUpdateListener;
  26  import android.content.Context;
  27  import android.content.res.Resources;
  28  import android.content.res.TypedArray;
  29  import android.graphics.Bitmap;
  30  import android.graphics.Canvas;
  31  import android.graphics.Color;
  32  import android.graphics.Paint;
  33  import android.graphics.Point;
  34  import android.graphics.PointF;
  35  import android.graphics.PorterDuff;
  36  import android.graphics.PorterDuffXfermode;
  37  import android.graphics.Rect;
  38  import android.graphics.drawable.ColorDrawable;
  39  import android.graphics.drawable.Drawable;
  40  import android.graphics.drawable.NinePatchDrawable;
  41  import android.util.AttributeSet;
  42  import android.util.Log;
  43  import android.view.MotionEvent;
  44  import android.view.View;
  45  import android.view.ViewDebug;
  46  import android.view.ViewGroup;
  47  import android.view.animation.Animation;
  48  import android.view.animation.DecelerateInterpolator;
  49  import android.view.animation.LayoutAnimationController;
  50  
  51  import com.android.launcher.R;
  52  import com.android.launcher2.FolderIcon.FolderRingAnimator;
  53  
  54  import java.util.ArrayList;
  55  import java.util.Arrays;
  56  import java.util.HashMap;
  57  import java.util.Stack;
  58  
  59  public class CellLayout extends ViewGroup {
  60      static final String TAG = &quot;CellLayout&quot;;
  61  
  62      private int mOriginalCellWidth;
  63      private int mOriginalCellHeight;
  64      private int mCellWidth;
  65      private int mCellHeight;
  66  
  67      private int mCountX;
  68      private int mCountY;
  69  
  70      private int mOriginalWidthGap;
  71      private int mOriginalHeightGap;
  72      private int mWidthGap;
  73      private int mHeightGap;
  74      private int mMaxGap;
  75      private boolean mScrollingTransformsDirty = false;
  76  
  77      private final Rect mRect = new Rect();
  78      private final CellInfo mCellInfo = new CellInfo();
  79  
  80      // These are temporary variables to prevent having to allocate a new object just to
  81      // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  82      private final int[] mTmpXY = new int[2];
  83      private final int[] mTmpPoint = new int[2];
  84      private final PointF mTmpPointF = new PointF();
  85      int[] mTempLocation = new int[2];
  86  
  87      boolean[][] mOccupied;
  88      boolean[][] mTmpOccupied;
  89      private boolean mLastDownOnOccupiedCell = false;
  90  
  91      private OnTouchListener mInterceptTouchListener;
  92  
  93      private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
  94      private int[] mFolderLeaveBehindCell = {-1, -1};
  95  
  96      private int mForegroundAlpha = 0;
  97      private float mBackgroundAlpha;
  98      private float mBackgroundAlphaMultiplier = 1.0f;
  99  
 100      private Drawable mNormalBackground;
 101      private Drawable mActiveGlowBackground;
 102      private Drawable mOverScrollForegroundDrawable;
 103      private Drawable mOverScrollLeft;
 104      private Drawable mOverScrollRight;
 105      private Rect mBackgroundRect;
 106      private Rect mForegroundRect;
 107      private int mForegroundPadding;
 108  
 109      // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 110      private boolean mIsDragOverlapping = false;
 111      private final Point mDragCenter = new Point();
 112  
 113      // These arrays are used to implement the drag visualization on x-large screens.
 114      // They are used as circular arrays, indexed by mDragOutlineCurrent.
 115      private Rect[] mDragOutlines = new Rect[4];
 116      private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 117      private InterruptibleInOutAnimator[] mDragOutlineAnims =
 118              new InterruptibleInOutAnimator[mDragOutlines.length];
 119  
 120      // Used as an index into the above 3 arrays; indicates which is the most current value.
 121      private int mDragOutlineCurrent = 0;
 122      private final Paint mDragOutlinePaint = new Paint();
 123  
 124      private BubbleTextView mPressedOrFocusedIcon;
 125  
 126      private Drawable mCrosshairsDrawable = null;
 127      private InterruptibleInOutAnimator mCrosshairsAnimator = null;
 128      private float mCrosshairsVisibility = 0.0f;
 129  
 130      private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new
 131              HashMap&lt;CellLayout.LayoutParams, Animator&gt;();
 132  
 133      // When a drag operation is in progress, holds the nearest cell to the touch point
 134      private final int[] mDragCell = new int[2];
 135  
 136      private boolean mDragging = false;
 137      private boolean mItemLocationsDirty = false;
 138  
 139      private TimeInterpolator mEaseOutInterpolator;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -    private CellLayoutChildren mChildren;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +    private ShortcutAndWidgetContainer mShortcutsAndWidgets;</span>
 142  
 143      private boolean mIsHotseat = false;
 144      private float mChildScale = 1f;
 145      private float mHotseatChildScale = 1f;
 146  
 147      public static final int MODE_DRAG_OVER = 0;
 148      public static final int MODE_ON_DROP = 1;
 149      public static final int MODE_ON_DROP_EXTERNAL = 2;
 150      public static final int MODE_ACCEPT_DROP = 3;
 151      private static final boolean DESTRUCTIVE_REORDER = true;
 152      private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 153  
 154      private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 155      private Rect mOccupiedRect = new Rect();
 156      private int[] mDirectionVector = new int[2];
 157  
 158      public CellLayout(Context context) {
 159          this(context, null);
 160      }
 161  
 162      public CellLayout(Context context, AttributeSet attrs) {
 163          this(context, attrs, 0);
 164      }
 165  
 166      public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 167          super(context, attrs, defStyle);
 168  
 169          // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 170          // the user where a dragged item will land when dropped.
 171          setWillNotDraw(false);
 172  
 173          TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 174  
 175          mOriginalCellWidth =
 176              mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 177          mOriginalCellHeight =
 178              mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 179          mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 180          mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 181          mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 182          mCountX = LauncherModel.getCellCountX();
 183          mCountY = LauncherModel.getCellCountY();
 184          mOccupied = new boolean[mCountX][mCountY];
 185          mTmpOccupied = new boolean[mCountX][mCountY];
 186  
 187          a.recycle();
 188  
 189          setAlwaysDrawnWithCacheEnabled(false);
 190  
 191          final Resources res = getResources();
 192  
 193          mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 194          mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 195  
 196          mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 197          mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 198          mForegroundPadding =
 199                  res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 200  
 201          mNormalBackground.setFilterBitmap(true);
 202          mActiveGlowBackground.setFilterBitmap(true);
 203  
 204          int iconScale = res.getInteger(R.integer.app_icon_scale_percent);
 205          if (iconScale &gt;= 0) {
 206              mChildScale = iconScale / 100f;
 207          }
 208          int hotseatIconScale = res.getInteger(R.integer.app_icon_hotseat_scale_percent);
 209          if (hotseatIconScale &gt;= 0) {
 210              mHotseatChildScale = hotseatIconScale / 100f;
 211          }
 212  
 213          // Initialize the data structures used for the drag visualization.
 214  
 215          mCrosshairsDrawable = res.getDrawable(R.drawable.gardening_crosshairs);
 216          mEaseOutInterpolator = new DecelerateInterpolator(2.5f); // Quint ease out
 217  
 218          // Set up the animation for fading the crosshairs in and out
 219          int animDuration = res.getInteger(R.integer.config_crosshairsFadeInTime);
 220          mCrosshairsAnimator = new InterruptibleInOutAnimator(animDuration, 0.0f, 1.0f);
 221          mCrosshairsAnimator.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 222              public void onAnimationUpdate(ValueAnimator animation) {
 223                  mCrosshairsVisibility = ((Float) animation.getAnimatedValue()).floatValue();
 224                  invalidate();
 225              }
 226          });
 227          mCrosshairsAnimator.getAnimator().setInterpolator(mEaseOutInterpolator);
 228  
 229          mDragCell[0] = mDragCell[1] = -1;
 230          for (int i = 0; i &lt; mDragOutlines.length; i++) {
 231              mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 232          }
 233  
 234          // When dragging things around the home screens, we show a green outline of
 235          // where the item will land. The outlines gradually fade out, leaving a trail
 236          // behind the drag path.
 237          // Set up all the animations that are used to implement this fading.
 238          final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 239          final float fromAlphaValue = 0;
 240          final float toAlphaValue = (float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
 241  
 242          Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 243  
 244          for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
 245              final InterruptibleInOutAnimator anim =
 246                  new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);
 247              anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 248              final int thisIndex = i;
 249              anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 250                  public void onAnimationUpdate(ValueAnimator animation) {
 251                      final Bitmap outline = (Bitmap)anim.getTag();
 252  
 253                      // If an animation is started and then stopped very quickly, we can still
 254                      // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 255                      if (outline == null) {
 256                          if (false) {
 257                              Object val = animation.getAnimatedValue();
 258                              Log.d(TAG, &quot;anim &quot; + thisIndex + &quot; update: &quot; + val +
 259                                       &quot;, isStopped &quot; + anim.isStopped());
 260                          }
 261                          // Try to prevent it from continuing to run
 262                          animation.cancel();
 263                      } else {
 264                          mDragOutlineAlphas[thisIndex] = (Float) animation.getAnimatedValue();
 265                          CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 266                      }
 267                  }
 268              });
 269              // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 270              // running. This way the bitmap can be GCed when the animations are complete.
 271              anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 272                  @Override
 273                  public void onAnimationEnd(Animator animation) {
 274                      if ((Float) ((ValueAnimator) animation).getAnimatedValue() == 0f) {
 275                          anim.setTag(null);
 276                      }
 277                  }
 278              });
 279              mDragOutlineAnims[i] = anim;
 280          }
 281  
 282          mBackgroundRect = new Rect();
 283          mForegroundRect = new Rect();
 284  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 285 -        mChildren = new CellLayoutChildren(context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 286 -        mChildren.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 287 -        addView(mChildren);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +        mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +        mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +        addView(mShortcutsAndWidgets);</span>
 291      }
 292  
 293      static int widthInPortrait(Resources r, int numCells) {
 294          // We use this method from Workspace to figure out how many rows/columns Launcher should
 295          // have. We ignore the left/right padding on CellLayout because it turns out in our design
 296          // the padding extends outside the visible screen size, but it looked fine anyway.
 297          int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 298          int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 299                  r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 300  
 301          return  minGap * (numCells - 1) + cellWidth * numCells;
 302      }
 303  
 304      static int heightInLandscape(Resources r, int numCells) {
 305          // We use this method from Workspace to figure out how many rows/columns Launcher should
 306          // have. We ignore the left/right padding on CellLayout because it turns out in our design
 307          // the padding extends outside the visible screen size, but it looked fine anyway.
 308          int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 309          int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 310                  r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 311  
 312          return minGap * (numCells - 1) + cellHeight * numCells;
 313      }
 314  
 315      public void enableHardwareLayers() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 316 -        mChildren.enableHardwareLayers();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +        mShortcutsAndWidgets.enableHardwareLayers();</span>
 318      }
 319  
 320      public void setGridSize(int x, int y) {
 321          mCountX = x;
 322          mCountY = y;
 323          mOccupied = new boolean[mCountX][mCountY];
 324          mTmpOccupied = new boolean[mCountX][mCountY];
 325          requestLayout();
 326      }
 327  
 328      private void invalidateBubbleTextView(BubbleTextView icon) {
 329          final int padding = icon.getPressedOrFocusedBackgroundPadding();
 330          invalidate(icon.getLeft() + getPaddingLeft() - padding,
 331                  icon.getTop() + getPaddingTop() - padding,
 332                  icon.getRight() + getPaddingLeft() + padding,
 333                  icon.getBottom() + getPaddingTop() + padding);
 334      }
 335  
 336      void setOverScrollAmount(float r, boolean left) {
 337          if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 338              mOverScrollForegroundDrawable = mOverScrollLeft;
 339          } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 340              mOverScrollForegroundDrawable = mOverScrollRight;
 341          }
 342  
 343          mForegroundAlpha = (int) Math.round((r * 255));
 344          mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 345          invalidate();
 346      }
 347  
 348      void setPressedOrFocusedIcon(BubbleTextView icon) {
 349          // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 350          // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 351          BubbleTextView oldIcon = mPressedOrFocusedIcon;
 352          mPressedOrFocusedIcon = icon;
 353          if (oldIcon != null) {
 354              invalidateBubbleTextView(oldIcon);
 355          }
 356          if (mPressedOrFocusedIcon != null) {
 357              invalidateBubbleTextView(mPressedOrFocusedIcon);
 358          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 359 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 360 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 361 -    public CellLayoutChildren getChildrenLayout() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 362 -        if (getChildCount() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 363 -            return (CellLayoutChildren) getChildAt(0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 365 -        return null;</span>
 366      }
 367  
 368      void setIsDragOverlapping(boolean isDragOverlapping) {
 369          if (mIsDragOverlapping != isDragOverlapping) {
 370              mIsDragOverlapping = isDragOverlapping;
 371              invalidate();
 372          }
 373      }
 374  
 375      boolean getIsDragOverlapping() {
 376          return mIsDragOverlapping;
 377      }
 378  
 379      protected void setOverscrollTransformsDirty(boolean dirty) {
 380          mScrollingTransformsDirty = dirty;
 381      }
 382  
 383      protected void resetOverscrollTransforms() {
 384          if (mScrollingTransformsDirty) {
 385              setOverscrollTransformsDirty(false);
 386              setTranslationX(0);
 387              setRotationY(0);
 388              // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 389              // pass 0, which results in the overscroll drawable not being drawn any more.
 390              setOverScrollAmount(0, false);
 391              setPivotX(getMeasuredWidth() / 2);
 392              setPivotY(getMeasuredHeight() / 2);
 393          }
 394      }
 395  
 396      @Override
 397      protected void onDraw(Canvas canvas) {
 398          // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 399          // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 400          // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 401          // a drag). However, we also drag the mini hover background *over* one of those two
 402          // backgrounds
 403          if (mBackgroundAlpha &gt; 0.0f) {
 404              Drawable bg;
 405  
 406              if (mIsDragOverlapping) {
 407                  // In the mini case, we draw the active_glow bg *over* the active background
 408                  bg = mActiveGlowBackground;
 409              } else {
 410                  bg = mNormalBackground;
 411              }
 412  
 413              bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 414              bg.setBounds(mBackgroundRect);
 415              bg.draw(canvas);
 416          }
 417  
 418          if (mCrosshairsVisibility &gt; 0.0f) {
 419              final int countX = mCountX;
 420              final int countY = mCountY;
 421  
 422              final float MAX_ALPHA = 0.4f;
 423              final int MAX_VISIBLE_DISTANCE = 600;
 424              final float DISTANCE_MULTIPLIER = 0.002f;
 425  
 426              final Drawable d = mCrosshairsDrawable;
 427              final int width = d.getIntrinsicWidth();
 428              final int height = d.getIntrinsicHeight();
 429  
 430              int x = getPaddingLeft() - (mWidthGap / 2) - (width / 2);
 431              for (int col = 0; col &lt;= countX; col++) {
 432                  int y = getPaddingTop() - (mHeightGap / 2) - (height / 2);
 433                  for (int row = 0; row &lt;= countY; row++) {
 434                      mTmpPointF.set(x - mDragCenter.x, y - mDragCenter.y);
 435                      float dist = mTmpPointF.length();
 436                      // Crosshairs further from the drag point are more faint
 437                      float alpha = Math.min(MAX_ALPHA,
 438                              DISTANCE_MULTIPLIER * (MAX_VISIBLE_DISTANCE - dist));
 439                      if (alpha &gt; 0.0f) {
 440                          d.setBounds(x, y, x + width, y + height);
 441                          d.setAlpha((int) (alpha * 255 * mCrosshairsVisibility));
 442                          d.draw(canvas);
 443                      }
 444                      y += mCellHeight + mHeightGap;
 445                  }
 446                  x += mCellWidth + mWidthGap;
 447              }
 448          }
 449  
 450          final Paint paint = mDragOutlinePaint;
 451          for (int i = 0; i &lt; mDragOutlines.length; i++) {
 452              final float alpha = mDragOutlineAlphas[i];
 453              if (alpha &gt; 0) {
 454                  final Rect r = mDragOutlines[i];
 455                  final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 456                  paint.setAlpha((int)(alpha + .5f));
 457                  canvas.drawBitmap(b, null, r, paint);
 458              }
 459          }
 460  
 461          // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 462          // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 463          if (mPressedOrFocusedIcon != null) {
 464              final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 465              final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 466              if (b != null) {
 467                  canvas.drawBitmap(b,
 468                          mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 469                          mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 470                          null);
 471              }
 472          }
 473  
 474          if (DEBUG_VISUALIZE_OCCUPIED) {
 475              int[] pt = new int[2];
 476              ColorDrawable cd = new ColorDrawable(Color.RED);
 477              cd.setBounds(0, 0, 80, 80);
 478              for (int i = 0; i &lt; mCountX; i++) {
 479                  for (int j = 0; j &lt; mCountY; j++) {
 480                      if (mOccupied[i][j]) {
 481                          cellToPoint(i, j, pt);
 482                          canvas.save();
 483                          canvas.translate(pt[0], pt[1]);
 484                          cd.draw(canvas);
 485                          canvas.restore();
 486                      }
 487                  }
 488              }
 489          }
 490  
 491          // The folder outer / inner ring image(s)
 492          for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 493              FolderRingAnimator fra = mFolderOuterRings.get(i);
 494  
 495              // Draw outer ring
 496              Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 497              int width = (int) fra.getOuterRingSize();
 498              int height = width;
 499              cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 500  
 501              int centerX = mTempLocation[0] + mCellWidth / 2;
 502              int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 503  
 504              canvas.save();
 505              canvas.translate(centerX - width / 2, centerY - height / 2);
 506              d.setBounds(0, 0, width, height);
 507              d.draw(canvas);
 508              canvas.restore();
 509  
 510              // Draw inner ring
 511              d = FolderRingAnimator.sSharedInnerRingDrawable;
 512              width = (int) fra.getInnerRingSize();
 513              height = width;
 514              cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 515  
 516              centerX = mTempLocation[0] + mCellWidth / 2;
 517              centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 518              canvas.save();
 519              canvas.translate(centerX - width / 2, centerY - width / 2);
 520              d.setBounds(0, 0, width, height);
 521              d.draw(canvas);
 522              canvas.restore();
 523          }
 524  
 525          if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 526              Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 527              int width = d.getIntrinsicWidth();
 528              int height = d.getIntrinsicHeight();
 529  
 530              cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 531              int centerX = mTempLocation[0] + mCellWidth / 2;
 532              int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 533  
 534              canvas.save();
 535              canvas.translate(centerX - width / 2, centerY - width / 2);
 536              d.setBounds(0, 0, width, height);
 537              d.draw(canvas);
 538              canvas.restore();
 539          }
 540      }
 541  
 542      @Override
 543      protected void dispatchDraw(Canvas canvas) {
 544          super.dispatchDraw(canvas);
 545          if (mForegroundAlpha &gt; 0) {
 546              mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 547              Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 548              p.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));
 549              mOverScrollForegroundDrawable.draw(canvas);
 550              p.setXfermode(null);
 551          }
 552      }
 553  
 554      public void showFolderAccept(FolderRingAnimator fra) {
 555          mFolderOuterRings.add(fra);
 556      }
 557  
 558      public void hideFolderAccept(FolderRingAnimator fra) {
 559          if (mFolderOuterRings.contains(fra)) {
 560              mFolderOuterRings.remove(fra);
 561          }
 562          invalidate();
 563      }
 564  
 565      public void setFolderLeaveBehindCell(int x, int y) {
 566          mFolderLeaveBehindCell[0] = x;
 567          mFolderLeaveBehindCell[1] = y;
 568          invalidate();
 569      }
 570  
 571      public void clearFolderLeaveBehind() {
 572          mFolderLeaveBehindCell[0] = -1;
 573          mFolderLeaveBehindCell[1] = -1;
 574          invalidate();
 575      }
 576  
 577      @Override
 578      public boolean shouldDelayChildPressedState() {
 579          return false;
 580      }
 581  
 582      @Override
 583      public void cancelLongPress() {
 584          super.cancelLongPress();
 585  
 586          // Cancel long press for all children
 587          final int count = getChildCount();
 588          for (int i = 0; i &lt; count; i++) {
 589              final View child = getChildAt(i);
 590              child.cancelLongPress();
 591          }
 592      }
 593  
 594      public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 595          mInterceptTouchListener = listener;
 596      }
 597  
 598      int getCountX() {
 599          return mCountX;
 600      }
 601  
 602      int getCountY() {
 603          return mCountY;
 604      }
 605  
 606      public void setIsHotseat(boolean isHotseat) {
 607          mIsHotseat = isHotseat;
 608      }
 609  
 610      public float getChildrenScale() {
 611          return mIsHotseat ? mHotseatChildScale : mChildScale;
 612      }
 613  
 614      public boolean addViewToCellLayout(
 615              View child, int index, int childId, LayoutParams params, boolean markCells) {
 616          return addViewToCellLayout(child, index, childId, params, markCells, false);
 617      }
 618  
 619      private void scaleChild(BubbleTextView bubbleChild, float pivot, float scale) {
 620          // If we haven&#x27;t measured the child yet, do it now
 621          // (this happens if we&#x27;re being dropped from all-apps
 622          if (bubbleChild.getLayoutParams() instanceof LayoutParams &amp;&amp;
 623                  (bubbleChild.getMeasuredWidth() | bubbleChild.getMeasuredHeight()) == 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -            getChildrenLayout().measureChild(bubbleChild);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 625 +            getShortcutsAndWidgets().measureChild(bubbleChild);</span>
 626          }
 627          int measuredWidth = bubbleChild.getMeasuredWidth();
 628          int measuredHeight = bubbleChild.getMeasuredHeight();
 629  
 630          bubbleChild.setScaleX(scale);
 631          bubbleChild.setScaleY(scale);
 632      }
 633  
 634      private void resetChild(BubbleTextView bubbleChild) {
 635          bubbleChild.setScaleX(1f);
 636          bubbleChild.setScaleY(1f);
 637  
 638          bubbleChild.setTextColor(getResources().getColor(R.color.workspace_icon_text_color));
 639      }
 640  
 641      public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 642              boolean markCells, boolean allApps) {
 643          final LayoutParams lp = params;
 644  
 645          // Hotseat icons - scale down and remove text
 646          // Don&#x27;t scale the all apps button
 647          // scale percent set to -1 means do not scale
 648          // Only scale BubbleTextViews
 649          if (child instanceof BubbleTextView) {
 650              BubbleTextView bubbleChild = (BubbleTextView) child;
 651  
 652              // Start the child with 100% scale and visible text
 653              resetChild(bubbleChild);
 654  
 655              if (mIsHotseat &amp;&amp; !allApps &amp;&amp; mHotseatChildScale &gt;= 0) {
 656                  // Scale/make transparent for a hotseat
 657                  scaleChild(bubbleChild, 0f, mHotseatChildScale);
 658  
 659                  bubbleChild.setTextColor(getResources().getColor(android.R.color.transparent));
 660              } else if (mChildScale &gt;= 0) {
 661                  // Else possibly still scale it if we need to for smaller icons
 662                  scaleChild(bubbleChild, 0f, mChildScale);
 663              }
 664          }
 665  
 666          // Generate an id for each view, this assumes we have at most 256x256 cells
 667          // per workspace screen
 668          if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 669              // If the horizontal or vertical span is set to -1, it is taken to
 670              // mean that it spans the extent of the CellLayout
 671              if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 672              if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 673  
 674              child.setId(childId);
 675  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 676 -            mChildren.addView(child, index, lp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 677 +            mShortcutsAndWidgets.addView(child, index, lp);</span>
 678  
 679              if (markCells) markCellsAsOccupiedForView(child);
 680  
 681              return true;
 682          }
 683          return false;
 684      }
 685  
 686      @Override
 687      public void removeAllViews() {
 688          clearOccupiedCells();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 689 -        mChildren.removeAllViews();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 690 +        mShortcutsAndWidgets.removeAllViews();</span>
 691      }
 692  
 693      @Override
 694      public void removeAllViewsInLayout() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 695 -        if (mChildren.getChildCount() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 696 +        if (mShortcutsAndWidgets.getChildCount() &gt; 0) {</span>
 697              clearOccupiedCells();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 698 -            mChildren.removeAllViewsInLayout();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 699 +            mShortcutsAndWidgets.removeAllViewsInLayout();</span>
 700          }
 701      }
 702  
 703      public void removeViewWithoutMarkingCells(View view) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 704 -        mChildren.removeView(view);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 705 +        mShortcutsAndWidgets.removeView(view);</span>
 706      }
 707  
 708      @Override
 709      public void removeView(View view) {
 710          markCellsAsUnoccupiedForView(view);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 711 -        mChildren.removeView(view);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 712 +        mShortcutsAndWidgets.removeView(view);</span>
 713      }
 714  
 715      @Override
 716      public void removeViewAt(int index) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 717 -        markCellsAsUnoccupiedForView(mChildren.getChildAt(index));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 718 -        mChildren.removeViewAt(index);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 719 +        markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 720 +        mShortcutsAndWidgets.removeViewAt(index);</span>
 721      }
 722  
 723      @Override
 724      public void removeViewInLayout(View view) {
 725          markCellsAsUnoccupiedForView(view);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 726 -        mChildren.removeViewInLayout(view);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 727 +        mShortcutsAndWidgets.removeViewInLayout(view);</span>
 728      }
 729  
 730      @Override
 731      public void removeViews(int start, int count) {
 732          for (int i = start; i &lt; start + count; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 733 -            markCellsAsUnoccupiedForView(mChildren.getChildAt(i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 734 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 735 -        mChildren.removeViews(start, count);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 736 +            markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 737 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 738 +        mShortcutsAndWidgets.removeViews(start, count);</span>
 739      }
 740  
 741      @Override
 742      public void removeViewsInLayout(int start, int count) {
 743          for (int i = start; i &lt; start + count; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 744 -            markCellsAsUnoccupiedForView(mChildren.getChildAt(i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 745 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 746 -        mChildren.removeViewsInLayout(start, count);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 747 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 748 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 749 -    public void drawChildren(Canvas canvas) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 750 -        mChildren.draw(canvas);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 751 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 752 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 753 -    void buildChildrenLayer() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 754 -        mChildren.buildLayer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 755 +            markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 756 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 757 +        mShortcutsAndWidgets.removeViewsInLayout(start, count);</span>
 758      }
 759  
 760      @Override
 761      protected void onAttachedToWindow() {
 762          super.onAttachedToWindow();
 763          mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 764      }
 765  
 766      public void setTagToCellInfoForPoint(int touchX, int touchY) {
 767          final CellInfo cellInfo = mCellInfo;
 768          Rect frame = mRect;
 769          final int x = touchX + mScrollX;
 770          final int y = touchY + mScrollY;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 771 -        final int count = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 772 +        final int count = mShortcutsAndWidgets.getChildCount();</span>
 773  
 774          boolean found = false;
 775          for (int i = count - 1; i &gt;= 0; i--) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 776 -            final View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 777 +            final View child = mShortcutsAndWidgets.getChildAt(i);</span>
 778              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 779  
 780              if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 781                      lp.isLockedToGrid) {
 782                  child.getHitRect(frame);
 783  
 784                  float scale = child.getScaleX();
 785                  frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 786                          child.getBottom());
 787                  // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 788                  // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 789                  // to this view.
 790                  frame.offset(mPaddingLeft, mPaddingTop);
 791                  frame.inset((int) (frame.width() * (1f - scale) / 2),
 792                          (int) (frame.height() * (1f - scale) / 2));
 793  
 794                  if (frame.contains(x, y)) {
 795                      cellInfo.cell = child;
 796                      cellInfo.cellX = lp.cellX;
 797                      cellInfo.cellY = lp.cellY;
 798                      cellInfo.spanX = lp.cellHSpan;
 799                      cellInfo.spanY = lp.cellVSpan;
 800                      found = true;
 801                      break;
 802                  }
 803              }
 804          }
 805  
 806          mLastDownOnOccupiedCell = found;
 807  
 808          if (!found) {
 809              final int cellXY[] = mTmpXY;
 810              pointToCellExact(x, y, cellXY);
 811  
 812              cellInfo.cell = null;
 813              cellInfo.cellX = cellXY[0];
 814              cellInfo.cellY = cellXY[1];
 815              cellInfo.spanX = 1;
 816              cellInfo.spanY = 1;
 817          }
 818          setTag(cellInfo);
 819      }
 820  
 821      @Override
 822      public boolean onInterceptTouchEvent(MotionEvent ev) {
 823          // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 824          // even in the case where we return early. Not clearing here was causing bugs whereby on
 825          // long-press we&#x27;d end up picking up an item from a previous drag operation.
 826          final int action = ev.getAction();
 827  
 828          if (action == MotionEvent.ACTION_DOWN) {
 829              clearTagCellInfo();
 830          }
 831  
 832          if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 833              return true;
 834          }
 835  
 836          if (action == MotionEvent.ACTION_DOWN) {
 837              setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 838          }
 839  
 840          return false;
 841      }
 842  
 843      private void clearTagCellInfo() {
 844          final CellInfo cellInfo = mCellInfo;
 845          cellInfo.cell = null;
 846          cellInfo.cellX = -1;
 847          cellInfo.cellY = -1;
 848          cellInfo.spanX = 0;
 849          cellInfo.spanY = 0;
 850          setTag(cellInfo);
 851      }
 852  
 853      public CellInfo getTag() {
 854          return (CellInfo) super.getTag();
 855      }
 856  
 857      /**
 858       * Given a point, return the cell that strictly encloses that point
 859       * @param x X coordinate of the point
 860       * @param y Y coordinate of the point
 861       * @param result Array of 2 ints to hold the x and y coordinate of the cell
 862       */
 863      void pointToCellExact(int x, int y, int[] result) {
 864          final int hStartPadding = getPaddingLeft();
 865          final int vStartPadding = getPaddingTop();
 866  
 867          result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 868          result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 869  
 870          final int xAxis = mCountX;
 871          final int yAxis = mCountY;
 872  
 873          if (result[0] &lt; 0) result[0] = 0;
 874          if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 875          if (result[1] &lt; 0) result[1] = 0;
 876          if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 877      }
 878  
 879      /**
 880       * Given a point, return the cell that most closely encloses that point
 881       * @param x X coordinate of the point
 882       * @param y Y coordinate of the point
 883       * @param result Array of 2 ints to hold the x and y coordinate of the cell
 884       */
 885      void pointToCellRounded(int x, int y, int[] result) {
 886          pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 887      }
 888  
 889      /**
 890       * Given a cell coordinate, return the point that represents the upper left corner of that cell
 891       *
 892       * @param cellX X coordinate of the cell
 893       * @param cellY Y coordinate of the cell
 894       *
 895       * @param result Array of 2 ints to hold the x and y coordinate of the point
 896       */
 897      void cellToPoint(int cellX, int cellY, int[] result) {
 898          final int hStartPadding = getPaddingLeft();
 899          final int vStartPadding = getPaddingTop();
 900  
 901          result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 902          result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 903      }
 904  
 905      /**
 906       * Given a cell coordinate, return the point that represents the center of the cell
 907       *
 908       * @param cellX X coordinate of the cell
 909       * @param cellY Y coordinate of the cell
 910       *
 911       * @param result Array of 2 ints to hold the x and y coordinate of the point
 912       */
 913      void cellToCenterPoint(int cellX, int cellY, int[] result) {
 914          regionToCenterPoint(cellX, cellY, 1, 1, result);
 915      }
 916  
 917      /**
 918       * Given a cell coordinate and span return the point that represents the center of the regio
 919       *
 920       * @param cellX X coordinate of the cell
 921       * @param cellY Y coordinate of the cell
 922       *
 923       * @param result Array of 2 ints to hold the x and y coordinate of the point
 924       */
 925      void regionToCenterPoint(int cellX, int cellY, int spanX, int spanY, int[] result) {
 926          final int hStartPadding = getPaddingLeft();
 927          final int vStartPadding = getPaddingTop();
 928  
 929          result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) +
 930                  (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;
 931          result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) +
 932                  (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;


 933      }
 934  
 935      public float getDistanceFromCell(float x, float y, int[] cell) {
 936          cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 937          float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 938                  Math.pow(y - mTmpPoint[1], 2));
 939          return distance;
 940      }
 941  
 942      int getCellWidth() {
 943          return mCellWidth;
 944      }
 945  
 946      int getCellHeight() {
 947          return mCellHeight;
 948      }
 949  
 950      int getWidthGap() {
 951          return mWidthGap;
 952      }
 953  
 954      int getHeightGap() {
 955          return mHeightGap;
 956      }
 957  
 958      Rect getContentRect(Rect r) {
 959          if (r == null) {
 960              r = new Rect();
 961          }
 962          int left = getPaddingLeft();
 963          int top = getPaddingTop();
 964          int right = left + getWidth() - mPaddingLeft - mPaddingRight;
 965          int bottom = top + getHeight() - mPaddingTop - mPaddingBottom;
 966          r.set(left, top, right, bottom);
 967          return r;
 968      }
 969  
 970      @Override
 971      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 972          // TODO: currently ignoring padding
 973  
 974          int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 975          int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 976  
 977          int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 978          int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 979  
 980          if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 981              throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 982          }
 983  
 984          int numWidthGaps = mCountX - 1;
 985          int numHeightGaps = mCountY - 1;
 986  
 987          if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 988              int hSpace = widthSpecSize - mPaddingLeft - mPaddingRight;
 989              int vSpace = heightSpecSize - mPaddingTop - mPaddingBottom;
 990              int hFreeSpace = hSpace - (mCountX * mOriginalCellWidth);
 991              int vFreeSpace = vSpace - (mCountY * mOriginalCellHeight);
 992              mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 993              mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 994 -            mChildren.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 995 +            mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);</span>
 996          } else {
 997              mWidthGap = mOriginalWidthGap;
 998              mHeightGap = mOriginalHeightGap;
 999          }
1000  
1001          // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
1002          int newWidth = widthSpecSize;
1003          int newHeight = heightSpecSize;
1004          if (widthSpecMode == MeasureSpec.AT_MOST) {
1005              newWidth = mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
1006                  ((mCountX - 1) * mWidthGap);
1007              newHeight = mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
1008                  ((mCountY - 1) * mHeightGap);
1009              setMeasuredDimension(newWidth, newHeight);
1010          }
1011  
1012          int count = getChildCount();
1013          for (int i = 0; i &lt; count; i++) {
1014              View child = getChildAt(i);
1015              int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - mPaddingLeft -
1016                      mPaddingRight, MeasureSpec.EXACTLY);
1017              int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - mPaddingTop -
1018                      mPaddingBottom, MeasureSpec.EXACTLY);
1019              child.measure(childWidthMeasureSpec, childheightMeasureSpec);
1020          }
1021          setMeasuredDimension(newWidth, newHeight);
1022      }
1023  
1024      @Override
1025      protected void onLayout(boolean changed, int l, int t, int r, int b) {
1026          int count = getChildCount();
1027          for (int i = 0; i &lt; count; i++) {
1028              View child = getChildAt(i);
1029              child.layout(mPaddingLeft, mPaddingTop,
1030                      r - l - mPaddingRight, b - t - mPaddingBottom);
1031          }
1032      }
1033  
1034      @Override
1035      protected void onSizeChanged(int w, int h, int oldw, int oldh) {
1036          super.onSizeChanged(w, h, oldw, oldh);
1037          mBackgroundRect.set(0, 0, w, h);
1038          mForegroundRect.set(mForegroundPadding, mForegroundPadding,
1039                  w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
1040      }
1041  
1042      @Override
1043      protected void setChildrenDrawingCacheEnabled(boolean enabled) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1044 -        mChildren.setChildrenDrawingCacheEnabled(enabled);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1045 +        mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);</span>
1046      }
1047  
1048      @Override
1049      protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1050 -        mChildren.setChildrenDrawnWithCacheEnabled(enabled);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1051 +        mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);</span>
1052      }
1053  
1054      public float getBackgroundAlpha() {
1055          return mBackgroundAlpha;
1056      }
1057  
1058      public void setBackgroundAlphaMultiplier(float multiplier) {
1059          mBackgroundAlphaMultiplier = multiplier;
1060      }
1061  
1062      public float getBackgroundAlphaMultiplier() {
1063          return mBackgroundAlphaMultiplier;
1064      }
1065  
1066      public void setBackgroundAlpha(float alpha) {
1067          if (mBackgroundAlpha != alpha) {
1068              mBackgroundAlpha = alpha;
1069              invalidate();
1070          }
1071      }
1072  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1073 -    // Need to return true to let the view system know we know how to handle alpha-- this is</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1074 -    // because when our children have an alpha of 0.0f, they are still rendering their &quot;dimmed&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1075 -    // versions</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1076 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1077 -    protected boolean onSetAlpha(int alpha) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1078 -        return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1079 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1080 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1081 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1082 -    public void setAlpha(float alpha) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1083 -        setChildrenAlpha(alpha);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1084 -        super.setAlpha(alpha);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1085 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1086 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1087 -    private void setChildrenAlpha(float alpha) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1088 +    public void setShortcutAndWidgetAlpha(float alpha) {</span>
1089          final int childCount = getChildCount();
1090          for (int i = 0; i &lt; childCount; i++) {
1091              getChildAt(i).setAlpha(alpha);
1092          }
1093      }
1094  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1095 +    public ShortcutAndWidgetContainer getShortcutsAndWidgets() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1096 +        if (getChildCount() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1097 +            return (ShortcutAndWidgetContainer) getChildAt(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1098 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1099 +        return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1100 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1101 +</span>
1102      public View getChildAt(int x, int y) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1103 -        return mChildren.getChildAt(x, y);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1104 +        return mShortcutsAndWidgets.getChildAt(x, y);</span>
1105      }
1106  
1107      public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration,
1108              int delay, boolean permanent, boolean adjustOccupied) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1109 -        CellLayoutChildren clc = getChildrenLayout();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1110 +        ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();</span>
1111          boolean[][] occupied = mOccupied;
1112          if (!permanent) {
1113              occupied = mTmpOccupied;
1114          }
1115  
1116          if (clc.indexOfChild(child) != -1 &amp;&amp; !occupied[cellX][cellY]) {
1117              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
1118              final ItemInfo info = (ItemInfo) child.getTag();
1119  
1120              // We cancel any existing animations
1121              if (mReorderAnimators.containsKey(lp)) {
1122                  mReorderAnimators.get(lp).cancel();
1123                  mReorderAnimators.remove(lp);
1124              }
1125  
1126              final int oldX = lp.x;
1127              final int oldY = lp.y;
1128              if (adjustOccupied) {
1129                  occupied[lp.cellX][lp.cellY] = false;
1130                  occupied[cellX][cellY] = true;
1131              }
1132              lp.isLockedToGrid = true;
1133              if (permanent) {
1134                  lp.cellX = info.cellX = cellX;
1135                  lp.cellY = info.cellY = cellY;
1136              } else {
1137                  lp.tmpCellX = cellX;
1138                  lp.tmpCellY = cellY;
1139              }
1140              clc.setupLp(lp);
1141              lp.isLockedToGrid = false;
1142              final int newX = lp.x;
1143              final int newY = lp.y;
1144  
1145              lp.x = oldX;
1146              lp.y = oldY;
1147  
1148              // Exit early if we&#x27;re not actually moving the view
1149              if (oldX == newX &amp;&amp; oldY == newY) {
1150                  lp.isLockedToGrid = true;
1151                  return true;
1152              }
1153  
1154              ValueAnimator va = ValueAnimator.ofFloat(0f, 1f);
1155              va.setDuration(duration);
1156              mReorderAnimators.put(lp, va);
1157  
1158              va.addUpdateListener(new AnimatorUpdateListener() {
1159                  @Override
1160                  public void onAnimationUpdate(ValueAnimator animation) {
1161                      float r = ((Float) animation.getAnimatedValue()).floatValue();
1162                      child.setTranslationX(r * (newX - oldX));
1163                      child.setTranslationY(r * (newY - oldY));
1164                  }
1165              });
1166              va.addListener(new AnimatorListenerAdapter() {
1167                  boolean cancelled = false;
1168                  public void onAnimationEnd(Animator animation) {
1169                      // If the animation was cancelled, it means that another animation
1170                      // has interrupted this one, and we don&#x27;t want to lock the item into
1171                      // place just yet.
1172                      if (!cancelled) {
1173                          child.setTranslationX(0);
1174                          child.setTranslationY(0);
1175                          lp.isLockedToGrid = true;
1176                          child.requestLayout();
1177                      }
1178                      if (mReorderAnimators.containsKey(lp)) {
1179                          mReorderAnimators.remove(lp);
1180                      }
1181                  }
1182                  public void onAnimationCancel(Animator animation) {
1183                      cancelled = true;
1184                  }
1185              });
1186              va.setStartDelay(delay);
1187              va.start();
1188              return true;
1189          }
1190          return false;
1191      }
1192  
1193      /**
1194       * Estimate where the top left cell of the dragged item will land if it is dropped.
1195       *
1196       * @param originX The X value of the top left corner of the item
1197       * @param originY The Y value of the top left corner of the item
1198       * @param spanX The number of horizontal cells that the item spans
1199       * @param spanY The number of vertical cells that the item spans
1200       * @param result The estimated drop cell X and Y.
1201       */
1202      void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1203          final int countX = mCountX;
1204          final int countY = mCountY;
1205  
1206          // pointToCellRounded takes the top left of a cell but will pad that with
1207          // cellWidth/2 and cellHeight/2 when finding the matching cell
1208          pointToCellRounded(originX, originY, result);
1209  
1210          // If the item isn&#x27;t fully on this screen, snap to the edges
1211          int rightOverhang = result[0] + spanX - countX;
1212          if (rightOverhang &gt; 0) {
1213              result[0] -= rightOverhang; // Snap to right
1214          }
1215          result[0] = Math.max(0, result[0]); // Snap to left
1216          int bottomOverhang = result[1] + spanY - countY;
1217          if (bottomOverhang &gt; 0) {
1218              result[1] -= bottomOverhang; // Snap to bottom
1219          }
1220          result[1] = Math.max(0, result[1]); // Snap to top
1221      }
1222  
1223      void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1224              int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1225          final int oldDragCellX = mDragCell[0];
1226          final int oldDragCellY = mDragCell[1];
1227  
1228          if (v != null &amp;&amp; dragOffset == null) {
1229              mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1230          } else {
1231              mDragCenter.set(originX, originY);
1232          }
1233  
1234          if (dragOutline == null &amp;&amp; v == null) {
1235              if (mCrosshairsDrawable != null) {
1236                  invalidate();
1237              }
1238              return;
1239          }
1240  
1241          if (cellX != oldDragCellX || cellY != oldDragCellY) {
1242              mDragCell[0] = cellX;
1243              mDragCell[1] = cellY;
1244              // Find the top left corner of the rect the object will occupy
1245              final int[] topLeft = mTmpPoint;
1246              cellToPoint(cellX, cellY, topLeft);
1247  
1248              int left = topLeft[0];
1249              int top = topLeft[1];
1250  
1251              if (v != null &amp;&amp; dragOffset == null) {
1252                  // When drawing the drag outline, it did not account for margin offsets
1253                  // added by the view&#x27;s parent.
1254                  MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1255                  left += lp.leftMargin;
1256                  top += lp.topMargin;
1257  
1258                  // Offsets due to the size difference between the View and the dragOutline.
1259                  // There is a size difference to account for the outer blur, which may lie
1260                  // outside the bounds of the view.
1261                  top += (v.getHeight() - dragOutline.getHeight()) / 2;
1262                  // We center about the x axis
1263                  left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1264                          - dragOutline.getWidth()) / 2;
1265              } else {
1266                  if (dragOffset != null &amp;&amp; dragRegion != null) {
1267                      // Center the drag region *horizontally* in the cell and apply a drag
1268                      // outline offset
1269                      left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1270                               - dragRegion.width()) / 2;
1271                      top += dragOffset.y;
1272                  } else {
1273                      // Center the drag outline in the cell
1274                      left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1275                              - dragOutline.getWidth()) / 2;
1276                      top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1277                              - dragOutline.getHeight()) / 2;
1278                  }
1279              }
1280              final int oldIndex = mDragOutlineCurrent;
1281              mDragOutlineAnims[oldIndex].animateOut();
1282              mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1283              Rect r = mDragOutlines[mDragOutlineCurrent];
1284              r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1285              if (resize) {
1286                  cellToRect(cellX, cellY, spanX, spanY, r);
1287              }
1288  
1289              mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1290              mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1291          }
1292  
1293          // If we are drawing crosshairs, the entire CellLayout needs to be invalidated
1294          if (mCrosshairsDrawable != null) {
1295              invalidate();
1296          }
1297      }
1298  
1299      public void clearDragOutlines() {
1300          final int oldIndex = mDragOutlineCurrent;
1301          mDragOutlineAnims[oldIndex].animateOut();
1302          mDragCell[0] = mDragCell[1] = -1;
1303      }
1304  
1305      /**
1306       * Find a vacant area that will fit the given bounds nearest the requested
1307       * cell location. Uses Euclidean distance to score multiple vacant areas.
1308       *
1309       * @param pixelX The X location at which you want to search for a vacant area.
1310       * @param pixelY The Y location at which you want to search for a vacant area.
1311       * @param spanX Horizontal span of the object.
1312       * @param spanY Vertical span of the object.
1313       * @param result Array in which to place the result, or null (in which case a new array will
1314       *        be allocated)
1315       * @return The X, Y cell of a vacant area that can contain this object,
1316       *         nearest the requested location.
1317       */
1318      int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1319              int[] result) {
1320          return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1321      }
1322  
1323      /**
1324       * Find a vacant area that will fit the given bounds nearest the requested
1325       * cell location. Uses Euclidean distance to score multiple vacant areas.
1326       *
1327       * @param pixelX The X location at which you want to search for a vacant area.
1328       * @param pixelY The Y location at which you want to search for a vacant area.
1329       * @param minSpanX The minimum horizontal span required
1330       * @param minSpanY The minimum vertical span required
1331       * @param spanX Horizontal span of the object.
1332       * @param spanY Vertical span of the object.
1333       * @param result Array in which to place the result, or null (in which case a new array will
1334       *        be allocated)
1335       * @return The X, Y cell of a vacant area that can contain this object,
1336       *         nearest the requested location.
1337       */
1338      int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1339              int spanY, int[] result, int[] resultSpan) {
1340          return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1341                  result, resultSpan);
1342      }
1343  
1344      /**
1345       * Find a vacant area that will fit the given bounds nearest the requested
1346       * cell location. Uses Euclidean distance to score multiple vacant areas.
1347       *
1348       * @param pixelX The X location at which you want to search for a vacant area.
1349       * @param pixelY The Y location at which you want to search for a vacant area.
1350       * @param spanX Horizontal span of the object.
1351       * @param spanY Vertical span of the object.
1352       * @param ignoreOccupied If true, the result can be an occupied cell
1353       * @param result Array in which to place the result, or null (in which case a new array will
1354       *        be allocated)
1355       * @return The X, Y cell of a vacant area that can contain this object,
1356       *         nearest the requested location.
1357       */
1358      int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1359              boolean ignoreOccupied, int[] result) {
1360          return findNearestArea(pixelX, pixelY, spanX, spanY,
1361                  spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1362      }
1363  
1364      private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1365      private void lazyInitTempRectStack() {
1366          if (mTempRectStack.isEmpty()) {
1367              for (int i = 0; i &lt; mCountX * mCountY; i++) {
1368                  mTempRectStack.push(new Rect());
1369              }
1370          }
1371      }
1372  
1373      private void recycleTempRects(Stack&lt;Rect&gt; used) {
1374          while (!used.isEmpty()) {
1375              mTempRectStack.push(used.pop());
1376          }
1377      }
1378  
1379      /**
1380       * Find a vacant area that will fit the given bounds nearest the requested
1381       * cell location. Uses Euclidean distance to score multiple vacant areas.
1382       *
1383       * @param pixelX The X location at which you want to search for a vacant area.
1384       * @param pixelY The Y location at which you want to search for a vacant area.
1385       * @param minSpanX The minimum horizontal span required
1386       * @param minSpanY The minimum vertical span required
1387       * @param spanX Horizontal span of the object.
1388       * @param spanY Vertical span of the object.
1389       * @param ignoreOccupied If true, the result can be an occupied cell
1390       * @param result Array in which to place the result, or null (in which case a new array will
1391       *        be allocated)
1392       * @return The X, Y cell of a vacant area that can contain this object,
1393       *         nearest the requested location.
1394       */
1395      int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1396              View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1397              boolean[][] occupied) {
1398          lazyInitTempRectStack();
1399          // mark space take by ignoreView as available (method checks if ignoreView is null)
1400          markCellsAsUnoccupiedForView(ignoreView, occupied);
1401  
1402          // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1403          // to the center of the item, but we are searching based on the top-left cell, so
1404          // we translate the point over to correspond to the top-left.
1405          pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1406          pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1407  
1408          // Keep track of best-scoring drop area
1409          final int[] bestXY = result != null ? result : new int[2];
1410          double bestDistance = Double.MAX_VALUE;
1411          final Rect bestRect = new Rect(-1, -1, -1, -1);
1412          final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1413  
1414          final int countX = mCountX;
1415          final int countY = mCountY;
1416  
1417          if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1418                  spanX &lt; minSpanX || spanY &lt; minSpanY) {
1419              return bestXY;
1420          }
1421  
1422          for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1423              inner:
1424              for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1425                  int ySize = -1;
1426                  int xSize = -1;
1427                  if (ignoreOccupied) {
1428                      // First, let&#x27;s see if this thing fits anywhere
1429                      for (int i = 0; i &lt; minSpanX; i++) {
1430                          for (int j = 0; j &lt; minSpanY; j++) {
1431                              if (occupied[x + i][y + j]) {
1432                                  continue inner;
1433                              }
1434                          }
1435                      }
1436                      xSize = minSpanX;
1437                      ySize = minSpanY;
1438  
1439                      // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1440                      // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1441                      // until we hit a limit.
1442                      boolean incX = true;
1443                      boolean hitMaxX = xSize &gt;= spanX;
1444                      boolean hitMaxY = ySize &gt;= spanY;
1445                      while (!(hitMaxX &amp;&amp; hitMaxY)) {
1446                          if (incX &amp;&amp; !hitMaxX) {
1447                              for (int j = 0; j &lt; ySize; j++) {
1448                                  if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1449                                      // We can&#x27;t move out horizontally
1450                                      hitMaxX = true;
1451                                  }
1452                              }
1453                              if (!hitMaxX) {
1454                                  xSize++;
1455                              }
1456                          } else if (!hitMaxY) {
1457                              for (int i = 0; i &lt; xSize; i++) {
1458                                  if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1459                                      // We can&#x27;t move out vertically
1460                                      hitMaxY = true;
1461                                  }
1462                              }
1463                              if (!hitMaxY) {
1464                                  ySize++;
1465                              }
1466                          }
1467                          hitMaxX |= xSize &gt;= spanX;
1468                          hitMaxY |= ySize &gt;= spanY;
1469                          incX = !incX;
1470                      }
1471                      incX = true;
1472                      hitMaxX = xSize &gt;= spanX;
1473                      hitMaxY = ySize &gt;= spanY;
1474                  }
1475                  final int[] cellXY = mTmpXY;
1476                  cellToCenterPoint(x, y, cellXY);
1477  
1478                  // We verify that the current rect is not a sub-rect of any of our previous
1479                  // candidates. In this case, the current rect is disqualified in favour of the
1480                  // containing rect.
1481                  Rect currentRect = mTempRectStack.pop();
1482                  currentRect.set(x, y, x + xSize, y + ySize);
1483                  boolean contained = false;
1484                  for (Rect r : validRegions) {
1485                      if (r.contains(currentRect)) {
1486                          contained = true;
1487                          break;
1488                      }
1489                  }
1490                  validRegions.push(currentRect);
1491                  double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1492                          + Math.pow(cellXY[1] - pixelY, 2));
1493  
1494                  if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1495                          currentRect.contains(bestRect)) {
1496                      bestDistance = distance;
1497                      bestXY[0] = x;
1498                      bestXY[1] = y;
1499                      if (resultSpan != null) {
1500                          resultSpan[0] = xSize;
1501                          resultSpan[1] = ySize;
1502                      }
1503                      bestRect.set(currentRect);
1504                  }
1505              }
1506          }
1507          // re-mark space taken by ignoreView as occupied
1508          markCellsAsOccupiedForView(ignoreView, occupied);
1509  
1510          // Return -1, -1 if no suitable location found
1511          if (bestDistance == Double.MAX_VALUE) {
1512              bestXY[0] = -1;
1513              bestXY[1] = -1;
1514          }
1515          recycleTempRects(validRegions);
1516          return bestXY;
1517      }
1518  
1519       /**
1520       * Find a vacant area that will fit the given bounds nearest the requested
1521       * cell location, and will also weigh in a suggested direction vector of the
1522       * desired location. This method computers distance based on unit grid distances,
1523       * not pixel distances.
1524       *
1525       * @param cellX The X cell nearest to which you want to search for a vacant area.
1526       * @param cellY The Y cell nearest which you want to search for a vacant area.




1527       * @param spanX Horizontal span of the object.
1528       * @param spanY Vertical span of the object.
1529       * @param direction The favored direction in which the views should move from x, y
1530       * @param exactDirectionOnly If this parameter is true, then only solutions where the direction
1531       *        matches exactly. Otherwise we find the best matching direction.
1532       * @param occoupied The array which represents which cells in the CellLayout are occupied
1533       * @param blockOccupied The array which represents which cells in the specified block (cellX,
1534       *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views.

1535       * @param result Array in which to place the result, or null (in which case a new array will
1536       *        be allocated)
1537       * @return The X, Y cell of a vacant area that can contain this object,
1538       *         nearest the requested location.
1539       */
1540      private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
1541              boolean[][] occupied, boolean blockOccupied[][], int[] result) {

1542          // Keep track of best-scoring drop area
1543          final int[] bestXY = result != null ? result : new int[2];
1544          float bestDistance = Float.MAX_VALUE;
1545          int bestDirectionScore = Integer.MIN_VALUE;
1546  
1547          final int countX = mCountX;
1548          final int countY = mCountY;
1549  
1550          for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1551              inner:
1552              for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1553                  // First, let&#x27;s see if this thing fits anywhere
1554                  for (int i = 0; i &lt; spanX; i++) {
1555                      for (int j = 0; j &lt; spanY; j++) {
1556                          if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {

1557                              continue inner;
1558                          }
1559                      }
1560                  }
1561  
1562                  float distance = (float)
1563                          Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1564                  int[] curDirection = mTmpPoint;
1565                  computeDirectionVector(x - cellX, y - cellY, curDirection);
1566                  // The direction score is just the dot product of the two candidate direction
1567                  // and that passed in.

1568                  int curDirectionScore = direction[0] * curDirection[0] +
1569                          direction[1] * curDirection[1];
1570                  boolean exactDirectionOnly = false;
1571                  boolean directionMatches = direction[0] == curDirection[0] &amp;&amp;
1572                          direction[0] == curDirection[0];
1573                  if ((directionMatches || !exactDirectionOnly) &amp;&amp;
1574                          Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,


1575                          bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1576                      bestDistance = distance;
1577                      bestDirectionScore = curDirectionScore;
1578                      bestXY[0] = x;
1579                      bestXY[1] = y;
1580                  }
1581              }
1582          }
1583  
1584          // Return -1, -1 if no suitable location found
1585          if (bestDistance == Float.MAX_VALUE) {
1586              bestXY[0] = -1;
1587              bestXY[1] = -1;
1588          }
1589          return bestXY;
1590      }
1591  
1592      private int[] findNearestAreaInDirection(int cellX, int cellY, int spanX, int spanY,
1593              int[] direction,boolean[][] occupied,
1594              boolean blockOccupied[][], int[] result) {
1595          // Keep track of best-scoring drop area
1596          final int[] bestXY = result != null ? result : new int[2];
1597          bestXY[0] = -1;
1598          bestXY[1] = -1;
1599          float bestDistance = Float.MAX_VALUE;
1600  
1601          // We use this to march in a single direction
1602          if (direction[0] != 0 &amp;&amp; direction[1] != 0) {
1603              return bestXY;
1604          }
1605  
1606          // This will only incrememnet one of x or y based on the assertion above
1607          int x = cellX + direction[0];
1608          int y = cellY + direction[1];
1609          while (x &gt;= 0 &amp;&amp; x + spanX &lt;= mCountX &amp;&amp; y &gt;= 0 &amp;&amp; y + spanY &lt;= mCountY) {
1610  
1611              boolean fail = false;
1612              for (int i = 0; i &lt; spanX; i++) {
1613                  for (int j = 0; j &lt; spanY; j++) {
1614                      if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1615                          fail = true;
1616                      }
1617                  }
1618              }
1619              if (!fail) {
1620                  float distance = (float)
1621                          Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1622                  if (Float.compare(distance,  bestDistance) &lt; 0) {
1623                      bestDistance = distance;
1624                      bestXY[0] = x;
1625                      bestXY[1] = y;
1626                  }
1627              }
1628              x += direction[0];
1629              y += direction[1];
1630          }
1631          return bestXY;
1632      }
1633  
1634      private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1635              int[] direction) {
1636          LayoutParams lp = (LayoutParams) v.getLayoutParams();
1637          boolean success = false;
1638          markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1639                  lp.cellVSpan, mTmpOccupied, false);
1640          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1641  
1642          findNearestArea(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,
1643                  direction, mTmpOccupied, null, mTempLocation);

1644  
1645          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1646              lp.tmpCellX = mTempLocation[0];
1647              lp.tmpCellY = mTempLocation[1];
1648              success = true;
1649  
1650          }
1651          markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1652                  lp.cellVSpan, mTmpOccupied, true);
1653          return success;
1654      }
1655  
1656      // This method looks in the specified direction to see if there is an additional view
1657      // immediately adjecent in that direction
1658      private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,
1659              boolean[][] occupied) {
1660          boolean found = false;
1661  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1662 -        int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1663 +        int childCount = mShortcutsAndWidgets.getChildCount();</span>
1664          Rect r0 = new Rect(boundingRect);
1665          Rect r1 = new Rect();
1666  
1667          int deltaX = 0;
1668          int deltaY = 0;
1669          if (direction[1] &lt; 0) {
1670              r0.set(r0.left, r0.top - 1, r0.right, r0.bottom);
1671              deltaY = -1;
1672          } else if (direction[1] &gt; 0) {
1673              r0.set(r0.left, r0.top, r0.right, r0.bottom + 1);
1674              deltaY = 1;
1675          } else if (direction[0] &lt; 0) {
1676              r0.set(r0.left - 1, r0.top, r0.right, r0.bottom);
1677              deltaX = -1;
1678          } else if (direction[0] &gt; 0) {
1679              r0.set(r0.left, r0.top, r0.right + 1, r0.bottom);
1680              deltaX = 1;
1681          }
1682  
1683          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1684 -            View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1685 +            View child = mShortcutsAndWidgets.getChildAt(i);</span>
1686              if (views.contains(child)) continue;
1687              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1688  
1689              r1.set(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp.cellVSpan);
1690              if (Rect.intersects(r0, r1)) {
1691                  if (!lp.canReorder) {
1692                      return false;
1693                  }
1694                  boolean pushed = false;
1695                  for (int x = lp.tmpCellX; x &lt; lp.tmpCellX + lp.cellHSpan; x++) {
1696                      for (int y = lp.tmpCellY; y &lt; lp.tmpCellY + lp.cellVSpan; y++) {
1697                          boolean inBounds = x - deltaX &gt;= 0 &amp;&amp; x -deltaX &lt; mCountX
1698                                  &amp;&amp; y - deltaY &gt;= 0 &amp;&amp; y - deltaY &lt; mCountY;
1699                          if (inBounds &amp;&amp; occupied[x - deltaX][y - deltaY]) {
1700                              pushed = true;
1701                          }
1702                      }
1703                  }
1704                  if (pushed) {
1705                      views.add(child);
1706                      boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1707                              lp.tmpCellY + lp.cellVSpan);
1708                      found = true;
1709                  }
1710              }
1711          }
1712          return found;
1713      }
1714  
1715      private boolean pushViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1716              int[] direction) {
1717          if (views.size() == 0) return true;
1718  
1719  
1720          boolean success = false;
1721  
1722          // We construct a rect which represents the entire group of views
1723          Rect boundingRect = null;
1724          for (View v: views) {
1725              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1726              if (boundingRect == null) {
1727                  boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1728                          lp.tmpCellY + lp.cellVSpan);
1729              } else {
1730                  boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1731                          lp.tmpCellY + lp.cellVSpan);
1732              }
1733          }
1734  
1735          ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) views.clone();
1736          while (addViewInDirection(dup, boundingRect, direction, mTmpOccupied)) {
1737          }
1738          for (View v: dup) {
1739              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1740              markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1741                      lp.cellVSpan, mTmpOccupied, false);
1742          }
1743  
1744          boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];
1745          int top = boundingRect.top;
1746          int left = boundingRect.left;
1747          for (View v: dup) {
1748              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1749              markCellsForView(lp.tmpCellX - left, lp.tmpCellY - top, lp.cellHSpan,
1750                      lp.cellVSpan, blockOccupied, true);
1751          }
1752  
1753          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1754  
1755          findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(),
1756                  boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1757  
1758          int deltaX = mTempLocation[0] - boundingRect.left;
1759          int deltaY = mTempLocation[1] - boundingRect.top;
1760          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1761              for (View v: dup) {
1762                  LayoutParams lp = (LayoutParams) v.getLayoutParams();
1763                  lp.tmpCellX += deltaX;
1764                  lp.tmpCellY += deltaY;
1765              }
1766              success = true;
1767          }
1768          for (View v: dup) {
1769              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1770              markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1771                      lp.cellVSpan, mTmpOccupied, true);
1772          }
1773          return success;
1774      }
1775  
1776      private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1777              int[] direction) {
1778          if (views.size() == 0) return true;
1779          boolean success = false;
1780  
1781          // We construct a rect which represents the entire group of views
1782          Rect boundingRect = null;
1783          for (View v: views) {
1784              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1785              markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1786                      lp.cellVSpan, mTmpOccupied, false);
1787              if (boundingRect == null) {
1788                  boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1789                          lp.tmpCellY + lp.cellVSpan);
1790              } else {
1791                  boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1792                          lp.tmpCellY + lp.cellVSpan);
1793              }
1794          }
1795          boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];
1796          int top = boundingRect.top;
1797          int left = boundingRect.left;
1798          for (View v: views) {
1799              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1800              markCellsForView(lp.tmpCellX - left, lp.tmpCellY - top, lp.cellHSpan,
1801                      lp.cellVSpan, blockOccupied, true);
1802          }
1803  
1804          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1805  
1806          // TODO: this bounding rect may not be completely filled, lets be more precise about this
1807          // check.
1808          findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(),
1809                  boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);


1810  
1811          int deltaX = mTempLocation[0] - boundingRect.left;
1812          int deltaY = mTempLocation[1] - boundingRect.top;
1813          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1814              for (View v: views) {
1815                  LayoutParams lp = (LayoutParams) v.getLayoutParams();
1816                  lp.tmpCellX += deltaX;
1817                  lp.tmpCellY += deltaY;
1818              }
1819              success = true;
1820          }
1821          for (View v: views) {
1822              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1823              markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1824                      lp.cellVSpan, mTmpOccupied, true);
1825          }
1826          return success;
1827      }
1828  
1829      private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1830          markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1831      }
1832  
1833      private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1834              View ignoreView) {
1835          mIntersectingViews.clear();
1836  
1837          mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);

1838  
1839          if (ignoreView != null) {
1840              LayoutParams lp = (LayoutParams) ignoreView.getLayoutParams();
1841              lp.tmpCellX = cellX;
1842              lp.tmpCellY = cellY;
1843          }
1844  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1845 -        int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1846 +        int childCount = mShortcutsAndWidgets.getChildCount();</span>
1847          Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1848          Rect r1 = new Rect();
1849          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1850 -            View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1851 +            View child = mShortcutsAndWidgets.getChildAt(i);</span>
1852              if (child == ignoreView) continue;
1853              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1854              r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
1855              if (Rect.intersects(r0, r1)) {
1856                  if (!lp.canReorder) {
1857                      return false;
1858                  }
1859                  mIntersectingViews.add(child);
1860              }
1861          }
1862  
1863          if (pushViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {
1864              return true;
1865          }
1866          // Try the opposite direction
1867          direction[0] *= -1;
1868          direction[1] *= -1;
1869          if (pushViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {
1870              return true;
1871          }
1872          // Switch the direction back
1873          direction[0] *= -1;
1874          direction[1] *= -1;
1875  
1876          // First we try moving the views as a block
1877          if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {
1878              return true;
1879          }
1880  
1881          // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1882          for (View v : mIntersectingViews) {
1883              if (!addViewToTempLocation(v, mOccupiedRect, direction)) {
1884                  return false;
1885              }
1886          }
1887          return true;
1888      }
1889  
1890      /*
1891       * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1892       * the provided point and the provided cell
1893       */
1894      private void computeDirectionVector(float deltaX, float deltaY, int[] result) {




1895          double angle = Math.atan(((float) deltaY) / deltaX);
1896  
1897          result[0] = 0;
1898          result[1] = 0;
1899          if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1900              result[0] = (int) Math.signum(deltaX);
1901          }
1902          if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1903              result[1] = (int) Math.signum(deltaY);
1904          }
1905      }
1906  
1907      ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1908              int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1909          // This creates a copy of the current occupied array, omitting the current view being
1910          // dragged
1911          resetTempLayoutToCurrent(dragView);
1912  
1913          // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1914          // nothing in its way.
1915          int result[] = new int[2];
1916          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1917  
1918          boolean success = false;
1919          // First we try the exact nearest position of the item being dragged,
1920          // we will then want to try to move this around to other neighbouring positions
1921          success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView);
1922  
1923          if (!success) {
1924              // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1925              // x, then 1 in y etc.
1926              if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1927                  return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1928                          dragView, false, solution);
1929              } else if (spanY &gt; minSpanY) {
1930                  return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1931                          dragView, true, solution);
1932              }
1933              solution.isSolution = false;
1934          } else {
1935              solution.isSolution = true;
1936              solution.dragViewX = result[0];
1937              solution.dragViewY = result[1];
1938              solution.dragViewSpanX = spanX;
1939              solution.dragViewSpanY = spanY;
1940              copyCurrentStateToSolution(solution, true);
1941          }
1942          return solution;
1943      }
1944  
1945      private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1946 -        int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1947 +        int childCount = mShortcutsAndWidgets.getChildCount();</span>
1948          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1949 -            View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1950 +            View child = mShortcutsAndWidgets.getChildAt(i);</span>
1951              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1952              Point p;
1953              if (temp) {
1954                  p = new Point(lp.tmpCellX, lp.tmpCellY);
1955              } else {
1956                  p = new Point(lp.cellX, lp.cellY);
1957              }
1958              solution.map.put(child, p);
1959          }
1960      }
1961  
1962      private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1963          for (int i = 0; i &lt; mCountX; i++) {
1964              for (int j = 0; j &lt; mCountY; j++) {
1965                  mTmpOccupied[i][j] = false;
1966              }
1967          }
1968  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1969 -        int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1970 +        int childCount = mShortcutsAndWidgets.getChildCount();</span>
1971          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1972 -            View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1973 +            View child = mShortcutsAndWidgets.getChildAt(i);</span>
1974              if (child == dragView) continue;
1975              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1976              Point p = solution.map.get(child);
1977              if (p != null) {
1978                  lp.tmpCellX = p.x;
1979                  lp.tmpCellY = p.y;
1980                  markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,
1981                          mTmpOccupied, true);
1982              }
1983          }
1984          markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1985                  solution.dragViewSpanY, mTmpOccupied, true);
1986      }
1987  
1988      private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
1989              commitDragView) {
1990  
1991          boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
1992          for (int i = 0; i &lt; mCountX; i++) {
1993              for (int j = 0; j &lt; mCountY; j++) {
1994                  occupied[i][j] = false;
1995              }
1996          }
1997  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1998 -        int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1999 +        int childCount = mShortcutsAndWidgets.getChildCount();</span>
2000          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2001 -            View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2002 +            View child = mShortcutsAndWidgets.getChildAt(i);</span>
2003              if (child == dragView) continue;
2004              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2005              Point p = solution.map.get(child);
2006              if (p != null) {
2007                  if (lp.cellX != p.x || lp.cellY != p.y) {
2008                      animateChildToPosition(child, p.x, p.y, 150, 0, DESTRUCTIVE_REORDER, false);
2009                  }
2010                  markCellsForView(p.x, p.y, lp.cellHSpan, lp.cellVSpan, occupied, true);
2011              }
2012          }
2013          if (commitDragView) {
2014              markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
2015                      solution.dragViewSpanY, occupied, true);
2016          }
2017      }
2018  
2019      private void commitTempPlacement() {
2020          for (int i = 0; i &lt; mCountX; i++) {
2021              for (int j = 0; j &lt; mCountY; j++) {
2022                  mOccupied[i][j] = mTmpOccupied[i][j];
2023              }
2024          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2025 -        int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2026 +        int childCount = mShortcutsAndWidgets.getChildCount();</span>
2027          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2028 -            LayoutParams lp = (LayoutParams) mChildren.getChildAt(i).getLayoutParams();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2029 +            LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();</span>
2030              lp.cellX = lp.tmpCellX;
2031              lp.cellY = lp.tmpCellY;
2032          }
2033      }
2034  
2035      public void setUseTempCoords(boolean useTempCoords) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2036 -        int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2037 +        int childCount = mShortcutsAndWidgets.getChildCount();</span>
2038          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2039 -            LayoutParams lp = (LayoutParams) mChildren.getChildAt(i).getLayoutParams();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2040 +            LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();</span>
2041              lp.useTmpCoords = useTempCoords;
2042          }
2043      }
2044  
2045      private void resetTempLayoutToCurrent(View ignoreView) {
2046          for (int i = 0; i &lt; mCountX; i++) {
2047              for (int j = 0; j &lt; mCountY; j++) {
2048                  mTmpOccupied[i][j] = mOccupied[i][j];
2049              }
2050          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2051 -        int childCount = mChildren.getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2052 +        int childCount = mShortcutsAndWidgets.getChildCount();</span>
2053          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2054 -            View child = mChildren.getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2055 +            View child = mShortcutsAndWidgets.getChildAt(i);</span>
2056              if (child == ignoreView) continue;
2057              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2058              lp.tmpCellX = lp.cellX;
2059              lp.tmpCellY = lp.cellY;
2060          }
2061      }
2062  
2063      ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
2064              int spanX, int spanY, View dragView, ItemConfiguration solution) {
2065          int[] result = new int[2];
2066          int[] resultSpan = new int[2];
2067          findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
2068                  resultSpan);
2069          if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
2070              copyCurrentStateToSolution(solution, false);
2071              solution.dragViewX = result[0];
2072              solution.dragViewY = result[1];
2073              solution.dragViewSpanX = resultSpan[0];
2074              solution.dragViewSpanY = resultSpan[1];
2075              solution.isSolution = true;
2076          } else {
2077              solution.isSolution = false;
2078          }
2079          return solution;
2080      }
2081  
2082      public void prepareChildForDrag(View child) {
2083          markCellsAsUnoccupiedForView(child);




2084      }
2085  
2086      int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
2087              View dragView, int[] result, int resultSpan[], int mode) {
2088  
2089          // First we determine if things have moved enough to cause a different layout
2090          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);

2091  
2092          if (resultSpan == null) {
2093              resultSpan = new int[2];
2094          }
2095  
2096          // We attempt the first algorithm
2097          regionToCenterPoint(result[0], result[1], spanX, spanY, mTmpPoint);
2098          computeDirectionVector((mTmpPoint[0] - pixelX) / spanX, (mTmpPoint[1] - pixelY) / spanY,
2099                  mDirectionVector);


2100          ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
2101                   spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
2102  
2103          // We attempt the approach which doesn&#x27;t shuffle views at all
2104          ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
2105                  minSpanY, spanX, spanY, dragView, new ItemConfiguration());
2106  
2107          ItemConfiguration finalSolution = null;
2108          if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
2109              finalSolution = swapSolution;
2110          } else if (noShuffleSolution.isSolution) {
2111              finalSolution = noShuffleSolution;
2112          }
2113  
2114          boolean foundSolution = true;
2115          if (!DESTRUCTIVE_REORDER) {
2116              setUseTempCoords(true);
2117          }
2118  
2119          if (finalSolution != null) {
2120              result[0] = finalSolution.dragViewX;
2121              result[1] = finalSolution.dragViewY;
2122              resultSpan[0] = finalSolution.dragViewSpanX;
2123              resultSpan[1] = finalSolution.dragViewSpanY;
2124  
2125              // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2126              // committing anything or animating anything as we just want to determine if a solution
2127              // exists
2128              if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2129                  if (!DESTRUCTIVE_REORDER) {
2130                      copySolutionToTempState(finalSolution, dragView);
2131                  }
2132                  setItemPlacementDirty(true);
2133                  animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
2134  
2135                  if (!DESTRUCTIVE_REORDER &amp;&amp; mode == MODE_ON_DROP) {
2136                      commitTempPlacement();
2137                  }
2138              }
2139          } else {
2140              foundSolution = false;
2141              result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
2142          }
2143  
2144          if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
2145              setUseTempCoords(false);
2146          }
2147          boolean[][] occupied = mOccupied;
2148  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2149 -        mChildren.requestLayout();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2150 +        mShortcutsAndWidgets.requestLayout();</span>
2151          return result;
2152      }
2153  
2154      public boolean isItemPlacementDirty() {
2155          return mItemLocationsDirty;
2156      }
2157  
2158      public void setItemPlacementDirty(boolean dirty) {
2159          mItemLocationsDirty = dirty;
2160      }
2161  
2162      private class ItemConfiguration {
2163          HashMap&lt;View, Point&gt; map = new HashMap&lt;View, Point&gt;();
2164          boolean isSolution = false;
2165          int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
2166  
2167          int area() {
2168              return dragViewSpanX * dragViewSpanY;
2169          }
2170          void clear() {
2171              map.clear();
2172              isSolution = false;
2173          }
2174      }
2175  
2176      /**
2177       * Find a vacant area that will fit the given bounds nearest the requested
2178       * cell location. Uses Euclidean distance to score multiple vacant areas.
2179       *
2180       * @param pixelX The X location at which you want to search for a vacant area.
2181       * @param pixelY The Y location at which you want to search for a vacant area.
2182       * @param spanX Horizontal span of the object.
2183       * @param spanY Vertical span of the object.
2184       * @param ignoreView Considers space occupied by this view as unoccupied
2185       * @param result Previously returned value to possibly recycle.
2186       * @return The X, Y cell of a vacant area that can contain this object,
2187       *         nearest the requested location.
2188       */
2189      int[] findNearestVacantArea(
2190              int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
2191          return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
2192      }
2193  
2194      /**
2195       * Find a vacant area that will fit the given bounds nearest the requested
2196       * cell location. Uses Euclidean distance to score multiple vacant areas.
2197       *
2198       * @param pixelX The X location at which you want to search for a vacant area.
2199       * @param pixelY The Y location at which you want to search for a vacant area.
2200       * @param minSpanX The minimum horizontal span required
2201       * @param minSpanY The minimum vertical span required
2202       * @param spanX Horizontal span of the object.
2203       * @param spanY Vertical span of the object.
2204       * @param ignoreView Considers space occupied by this view as unoccupied
2205       * @param result Previously returned value to possibly recycle.
2206       * @return The X, Y cell of a vacant area that can contain this object,
2207       *         nearest the requested location.
2208       */
2209      int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2210              int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2211          return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2212                  result, resultSpan, mOccupied);
2213      }
2214  
2215      /**
2216       * Find a starting cell position that will fit the given bounds nearest the requested
2217       * cell location. Uses Euclidean distance to score multiple vacant areas.
2218       *
2219       * @param pixelX The X location at which you want to search for a vacant area.
2220       * @param pixelY The Y location at which you want to search for a vacant area.
2221       * @param spanX Horizontal span of the object.
2222       * @param spanY Vertical span of the object.
2223       * @param ignoreView Considers space occupied by this view as unoccupied
2224       * @param result Previously returned value to possibly recycle.
2225       * @return The X, Y cell of a vacant area that can contain this object,
2226       *         nearest the requested location.
2227       */
2228      int[] findNearestArea(
2229              int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2230          return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2231      }
2232  
2233      boolean existsEmptyCell() {
2234          return findCellForSpan(null, 1, 1);
2235      }
2236  
2237      /**
2238       * Finds the upper-left coordinate of the first rectangle in the grid that can
2239       * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2240       * then this method will only return coordinates for rectangles that contain the cell
2241       * (intersectX, intersectY)
2242       *
2243       * @param cellXY The array that will contain the position of a vacant cell if such a cell
2244       *               can be found.
2245       * @param spanX The horizontal span of the cell we want to find.
2246       * @param spanY The vertical span of the cell we want to find.
2247       *
2248       * @return True if a vacant cell of the specified dimension was found, false otherwise.
2249       */
2250      boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2251          return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2252      }
2253  
2254      /**
2255       * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2256       *
2257       * @param cellXY The array that will contain the position of a vacant cell if such a cell
2258       *               can be found.
2259       * @param spanX The horizontal span of the cell we want to find.
2260       * @param spanY The vertical span of the cell we want to find.
2261       * @param ignoreView The home screen item we should treat as not occupying any space
2262       * @return
2263       */
2264      boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2265          return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2266                  ignoreView, mOccupied);
2267      }
2268  
2269      /**
2270       * Like above, but if intersectX and intersectY are not -1, then this method will try to
2271       * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2272       *
2273       * @param spanX The horizontal span of the cell we want to find.
2274       * @param spanY The vertical span of the cell we want to find.
2275       * @param ignoreView The home screen item we should treat as not occupying any space
2276       * @param intersectX The X coordinate of the cell that we should try to overlap
2277       * @param intersectX The Y coordinate of the cell that we should try to overlap
2278       *
2279       * @return True if a vacant cell of the specified dimension was found, false otherwise.
2280       */
2281      boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2282              int intersectX, int intersectY) {
2283          return findCellForSpanThatIntersectsIgnoring(
2284                  cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2285      }
2286  
2287      /**
2288       * The superset of the above two methods
2289       */
2290      boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2291              int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2292          // mark space take by ignoreView as available (method checks if ignoreView is null)
2293          markCellsAsUnoccupiedForView(ignoreView, occupied);
2294  
2295          boolean foundCell = false;
2296          while (true) {
2297              int startX = 0;
2298              if (intersectX &gt;= 0) {
2299                  startX = Math.max(startX, intersectX - (spanX - 1));
2300              }
2301              int endX = mCountX - (spanX - 1);
2302              if (intersectX &gt;= 0) {
2303                  endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2304              }
2305              int startY = 0;
2306              if (intersectY &gt;= 0) {
2307                  startY = Math.max(startY, intersectY - (spanY - 1));
2308              }
2309              int endY = mCountY - (spanY - 1);
2310              if (intersectY &gt;= 0) {
2311                  endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2312              }
2313  
2314              for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2315                  inner:
2316                  for (int x = startX; x &lt; endX; x++) {
2317                      for (int i = 0; i &lt; spanX; i++) {
2318                          for (int j = 0; j &lt; spanY; j++) {
2319                              if (occupied[x + i][y + j]) {
2320                                  // small optimization: we can skip to after the column we just found
2321                                  // an occupied cell
2322                                  x += i;
2323                                  continue inner;
2324                              }
2325                          }
2326                      }
2327                      if (cellXY != null) {
2328                          cellXY[0] = x;
2329                          cellXY[1] = y;
2330                      }
2331                      foundCell = true;
2332                      break;
2333                  }
2334              }
2335              if (intersectX == -1 &amp;&amp; intersectY == -1) {
2336                  break;
2337              } else {
2338                  // if we failed to find anything, try again but without any requirements of
2339                  // intersecting
2340                  intersectX = -1;
2341                  intersectY = -1;
2342                  continue;
2343              }
2344          }
2345  
2346          // re-mark space taken by ignoreView as occupied
2347          markCellsAsOccupiedForView(ignoreView, occupied);
2348          return foundCell;
2349      }
2350  
2351      /**
2352       * A drag event has begun over this layout.
2353       * It may have begun over this layout (in which case onDragChild is called first),
2354       * or it may have begun on another layout.
2355       */
2356      void onDragEnter() {
2357          if (!mDragging) {
2358              // Fade in the drag indicators
2359              if (mCrosshairsAnimator != null) {
2360                  mCrosshairsAnimator.animateIn();
2361              }
2362          }
2363          mDragging = true;
2364      }
2365  
2366      /**
2367       * Called when drag has left this CellLayout or has been completed (successfully or not)
2368       */
2369      void onDragExit() {
2370          // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2371          // item to this layout via the customize drawer.
2372          // Guard against that case.
2373          if (mDragging) {
2374              mDragging = false;
2375  
2376              // Fade out the drag indicators
2377              if (mCrosshairsAnimator != null) {
2378                  mCrosshairsAnimator.animateOut();
2379              }
2380          }
2381  
2382          // Invalidate the drag data
2383          mDragCell[0] = mDragCell[1] = -1;
2384          mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2385          mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2386  
2387          setIsDragOverlapping(false);
2388      }
2389  
2390      /**
2391       * Mark a child as having been dropped.
2392       * At the beginning of the drag operation, the child may have been on another
2393       * screen, but it is re-parented before this method is called.
2394       *
2395       * @param child The child that is being dropped
2396       */
2397      void onDropChild(View child) {
2398          if (child != null) {
2399              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2400              lp.dropped = true;
2401              child.requestLayout();
2402          }
2403      }
2404  
2405      /**
2406       * Computes a bounding rectangle for a range of cells
2407       *
2408       * @param cellX X coordinate of upper left corner expressed as a cell position
2409       * @param cellY Y coordinate of upper left corner expressed as a cell position
2410       * @param cellHSpan Width in cells
2411       * @param cellVSpan Height in cells
2412       * @param resultRect Rect into which to put the results
2413       */
2414      public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2415          final int cellWidth = mCellWidth;
2416          final int cellHeight = mCellHeight;
2417          final int widthGap = mWidthGap;
2418          final int heightGap = mHeightGap;
2419  
2420          final int hStartPadding = getPaddingLeft();
2421          final int vStartPadding = getPaddingTop();
2422  
2423          int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2424          int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2425  
2426          int x = hStartPadding + cellX * (cellWidth + widthGap);
2427          int y = vStartPadding + cellY * (cellHeight + heightGap);
2428  
2429          resultRect.set(x, y, x + width, y + height);
2430      }
2431  
2432      /**
2433       * Computes the required horizontal and vertical cell spans to always
2434       * fit the given rectangle.
2435       *
2436       * @param width Width in pixels
2437       * @param height Height in pixels
2438       * @param result An array of length 2 in which to store the result (may be null).
2439       */
2440      public int[] rectToCell(int width, int height, int[] result) {
2441          return rectToCell(getResources(), width, height, result);
2442      }
2443  
2444      public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2445          // Always assume we&#x27;re working with the smallest span to make sure we
2446          // reserve enough space in both orientations.
2447          int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2448          int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2449          int smallerSize = Math.min(actualWidth, actualHeight);
2450  
2451          // Always round up to next largest cell
2452          int spanX = (int) Math.ceil(width / (float) smallerSize);
2453          int spanY = (int) Math.ceil(height / (float) smallerSize);
2454  
2455          if (result == null) {
2456              return new int[] { spanX, spanY };
2457          }
2458          result[0] = spanX;
2459          result[1] = spanY;
2460          return result;
2461      }
2462  
2463      public int[] cellSpansToSize(int hSpans, int vSpans) {
2464          int[] size = new int[2];
2465          size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2466          size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2467          return size;
2468      }
2469  
2470      /**
2471       * Calculate the grid spans needed to fit given item
2472       */
2473      public void calculateSpans(ItemInfo info) {
2474          final int minWidth;
2475          final int minHeight;
2476  
2477          if (info instanceof LauncherAppWidgetInfo) {
2478              minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2479              minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2480          } else if (info instanceof PendingAddWidgetInfo) {
2481              minWidth = ((PendingAddWidgetInfo) info).minWidth;
2482              minHeight = ((PendingAddWidgetInfo) info).minHeight;
2483          } else {
2484              // It&#x27;s not a widget, so it must be 1x1
2485              info.spanX = info.spanY = 1;
2486              return;
2487          }
2488          int[] spans = rectToCell(minWidth, minHeight, null);
2489          info.spanX = spans[0];
2490          info.spanY = spans[1];
2491      }
2492  
2493      /**
2494       * Find the first vacant cell, if there is one.
2495       *
2496       * @param vacant Holds the x and y coordinate of the vacant cell
2497       * @param spanX Horizontal cell span.
2498       * @param spanY Vertical cell span.
2499       *
2500       * @return True if a vacant cell was found
2501       */
2502      public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2503  
2504          return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2505      }
2506  
2507      static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2508              int xCount, int yCount, boolean[][] occupied) {
2509  
2510          for (int y = 0; y &lt; yCount; y++) {
2511              for (int x = 0; x &lt; xCount; x++) {
2512                  boolean available = !occupied[x][y];
2513  out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2514                      for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2515                          available = available &amp;&amp; !occupied[i][j];
2516                          if (!available) break out;
2517                      }
2518                  }
2519  
2520                  if (available) {
2521                      vacant[0] = x;
2522                      vacant[1] = y;
2523                      return true;
2524                  }
2525              }
2526          }
2527  
2528          return false;
2529      }
2530  
2531      private void clearOccupiedCells() {
2532          for (int x = 0; x &lt; mCountX; x++) {
2533              for (int y = 0; y &lt; mCountY; y++) {
2534                  mOccupied[x][y] = false;
2535              }
2536          }
2537      }
2538  
2539      /**
2540       * Given a view, determines how much that view can be expanded in all directions, in terms of
2541       * whether or not there are other items occupying adjacent cells. Used by the
2542       * AppWidgetResizeFrame to determine how the widget can be resized.
2543       */
2544      public void getExpandabilityArrayForView(View view, int[] expandability) {
2545          final LayoutParams lp = (LayoutParams) view.getLayoutParams();
2546          boolean flag;
2547  
2548          expandability[AppWidgetResizeFrame.LEFT] = 0;
2549          for (int x = lp.cellX - 1; x &gt;= 0; x--) {
2550              flag = false;
2551              for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2552                  if (mOccupied[x][y]) flag = true;
2553              }
2554              if (flag) break;
2555              expandability[AppWidgetResizeFrame.LEFT]++;
2556          }
2557  
2558          expandability[AppWidgetResizeFrame.TOP] = 0;
2559          for (int y = lp.cellY - 1; y &gt;= 0; y--) {
2560              flag = false;
2561              for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2562                  if (mOccupied[x][y]) flag = true;
2563              }
2564              if (flag) break;
2565              expandability[AppWidgetResizeFrame.TOP]++;
2566          }
2567  
2568          expandability[AppWidgetResizeFrame.RIGHT] = 0;
2569          for (int x = lp.cellX + lp.cellHSpan; x &lt; mCountX; x++) {
2570              flag = false;
2571              for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2572                  if (mOccupied[x][y]) flag = true;
2573              }
2574              if (flag) break;
2575              expandability[AppWidgetResizeFrame.RIGHT]++;
2576          }
2577  
2578          expandability[AppWidgetResizeFrame.BOTTOM] = 0;
2579          for (int y = lp.cellY + lp.cellVSpan; y &lt; mCountY; y++) {
2580              flag = false;
2581              for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2582                  if (mOccupied[x][y]) flag = true;
2583              }
2584              if (flag) break;
2585              expandability[AppWidgetResizeFrame.BOTTOM]++;
2586          }
2587      }
2588  
2589      public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2590          markCellsAsUnoccupiedForView(view);
2591          markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2592      }
2593  
2594      public void markCellsAsOccupiedForView(View view) {
2595          markCellsAsOccupiedForView(view, mOccupied);
2596      }
2597      public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2598 -        if (view == null || view.getParent() != mChildren) return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2599 +        if (view == null || view.getParent() != mShortcutsAndWidgets) return;</span>
2600          LayoutParams lp = (LayoutParams) view.getLayoutParams();
2601          markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2602      }
2603  
2604      public void markCellsAsUnoccupiedForView(View view) {
2605          markCellsAsUnoccupiedForView(view, mOccupied);
2606      }
2607      public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2608 -        if (view == null || view.getParent() != mChildren) return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2609 +        if (view == null || view.getParent() != mShortcutsAndWidgets) return;</span>
2610          LayoutParams lp = (LayoutParams) view.getLayoutParams();
2611          markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2612      }
2613  
2614      private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2615              boolean value) {
2616          if (cellX &lt; 0 || cellY &lt; 0) return;
2617          for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2618              for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2619                  occupied[x][y] = value;
2620              }
2621          }
2622      }
2623  
2624      public int getDesiredWidth() {
2625          return mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
2626                  (Math.max((mCountX - 1), 0) * mWidthGap);
2627      }
2628  
2629      public int getDesiredHeight()  {
2630          return mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
2631                  (Math.max((mCountY - 1), 0) * mHeightGap);
2632      }
2633  
2634      public boolean isOccupied(int x, int y) {
2635          if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2636              return mOccupied[x][y];
2637          } else {
2638              throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2639          }
2640      }
2641  
2642      @Override
2643      public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2644          return new CellLayout.LayoutParams(getContext(), attrs);
2645      }
2646  
2647      @Override
2648      protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2649          return p instanceof CellLayout.LayoutParams;
2650      }
2651  
2652      @Override
2653      protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2654          return new CellLayout.LayoutParams(p);
2655      }
2656  
2657      public static class CellLayoutAnimationController extends LayoutAnimationController {
2658          public CellLayoutAnimationController(Animation animation, float delay) {
2659              super(animation, delay);
2660          }
2661  
2662          @Override
2663          protected long getDelayForView(View view) {
2664              return (int) (Math.random() * 150);
2665          }
2666      }
2667  
2668      public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2669          /**
2670           * Horizontal location of the item in the grid.
2671           */
2672          @ViewDebug.ExportedProperty
2673          public int cellX;
2674  
2675          /**
2676           * Vertical location of the item in the grid.
2677           */
2678          @ViewDebug.ExportedProperty
2679          public int cellY;
2680  
2681          /**
2682           * Temporary horizontal location of the item in the grid during reorder
2683           */
2684          public int tmpCellX;
2685  
2686          /**
2687           * Temporary vertical location of the item in the grid during reorder
2688           */
2689          public int tmpCellY;
2690  
2691          /**
2692           * Indicates that the temporary coordinates should be used to layout the items
2693           */
2694          public boolean useTmpCoords;
2695  
2696          /**
2697           * Number of cells spanned horizontally by the item.
2698           */
2699          @ViewDebug.ExportedProperty
2700          public int cellHSpan;
2701  
2702          /**
2703           * Number of cells spanned vertically by the item.
2704           */
2705          @ViewDebug.ExportedProperty
2706          public int cellVSpan;
2707  
2708          /**
2709           * Indicates whether the item will set its x, y, width and height parameters freely,
2710           * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2711           */
2712          public boolean isLockedToGrid = true;
2713  
2714          /**
2715           * Indicates whether this item can be reordered. Always true except in the case of the
2716           * the AllApps button.
2717           */
2718          public boolean canReorder = true;
2719  
2720          // X coordinate of the view in the layout.
2721          @ViewDebug.ExportedProperty
2722          int x;
2723          // Y coordinate of the view in the layout.
2724          @ViewDebug.ExportedProperty
2725          int y;
2726  
2727          boolean dropped;
2728  
2729          public LayoutParams(Context c, AttributeSet attrs) {
2730              super(c, attrs);
2731              cellHSpan = 1;
2732              cellVSpan = 1;
2733          }
2734  
2735          public LayoutParams(ViewGroup.LayoutParams source) {
2736              super(source);
2737              cellHSpan = 1;
2738              cellVSpan = 1;
2739          }
2740  
2741          public LayoutParams(LayoutParams source) {
2742              super(source);
2743              this.cellX = source.cellX;
2744              this.cellY = source.cellY;
2745              this.cellHSpan = source.cellHSpan;
2746              this.cellVSpan = source.cellVSpan;
2747          }
2748  
2749          public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2750              super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
2751              this.cellX = cellX;
2752              this.cellY = cellY;
2753              this.cellHSpan = cellHSpan;
2754              this.cellVSpan = cellVSpan;
2755          }
2756  
2757          public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2758              if (isLockedToGrid) {
2759                  final int myCellHSpan = cellHSpan;
2760                  final int myCellVSpan = cellVSpan;
2761                  final int myCellX = useTmpCoords ? tmpCellX : cellX;
2762                  final int myCellY = useTmpCoords ? tmpCellY : cellY;
2763  
2764                  width = myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) -
2765                          leftMargin - rightMargin;
2766                  height = myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) -
2767                          topMargin - bottomMargin;
2768                  x = (int) (myCellX * (cellWidth + widthGap) + leftMargin);
2769                  y = (int) (myCellY * (cellHeight + heightGap) + topMargin);
2770              }
2771          }
2772  
2773          public String toString() {
2774              return &quot;(&quot; + this.cellX + &quot;, &quot; + this.cellY + &quot;)&quot;;
2775          }
2776  
2777          public void setWidth(int width) {
2778              this.width = width;
2779          }
2780  
2781          public int getWidth() {
2782              return width;
2783          }
2784  
2785          public void setHeight(int height) {
2786              this.height = height;
2787          }
2788  
2789          public int getHeight() {
2790              return height;
2791          }
2792  
2793          public void setX(int x) {
2794              this.x = x;
2795          }
2796  
2797          public int getX() {
2798              return x;
2799          }
2800  
2801          public void setY(int y) {
2802              this.y = y;
2803          }
2804  
2805          public int getY() {
2806              return y;
2807          }
2808      }
2809  
2810      // This class stores info for two purposes:
2811      // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
2812      //    its spanX, spanY, and the screen it is on
2813      // 2. When long clicking on an empty cell in a CellLayout, we save information about the
2814      //    cellX and cellY coordinates and which page was clicked. We then set this as a tag on
2815      //    the CellLayout that was long clicked
2816      static final class CellInfo {
2817          View cell;
2818          int cellX = -1;
2819          int cellY = -1;
2820          int spanX;
2821          int spanY;
2822          int screen;
2823          long container;
2824  
2825          @Override
2826          public String toString() {
2827              return &quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())
2828                      + &quot;, x=&quot; + cellX + &quot;, y=&quot; + cellY + &quot;]&quot;;
2829          }
2830      }
2831  
2832      public boolean lastDownOnOccupiedCell() {
2833          return mLastDownOnOccupiedCell;
2834      }
2835  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.Animator;
  20  import android.animation.AnimatorListenerAdapter;
  21  import android.animation.ObjectAnimator;
  22  import android.animation.PropertyValuesHolder;
  23  import android.animation.TimeInterpolator;
  24  import android.animation.ValueAnimator;
  25  import android.animation.ValueAnimator.AnimatorUpdateListener;
  26  import android.content.Context;
  27  import android.content.res.Resources;
  28  import android.content.res.TypedArray;
  29  import android.graphics.Bitmap;
  30  import android.graphics.Canvas;
  31  import android.graphics.Color;
  32  import android.graphics.Paint;
  33  import android.graphics.Point;
  34  import android.graphics.PointF;
  35  import android.graphics.PorterDuff;
  36  import android.graphics.PorterDuffXfermode;
  37  import android.graphics.Rect;
  38  import android.graphics.drawable.ColorDrawable;
  39  import android.graphics.drawable.Drawable;
  40  import android.graphics.drawable.NinePatchDrawable;
  41  import android.util.AttributeSet;
  42  import android.util.Log;
  43  import android.view.MotionEvent;
  44  import android.view.View;
  45  import android.view.ViewDebug;
  46  import android.view.ViewGroup;
  47  import android.view.animation.Animation;
  48  import android.view.animation.DecelerateInterpolator;
  49  import android.view.animation.LayoutAnimationController;
  50  
  51  import com.android.launcher.R;
  52  import com.android.launcher2.FolderIcon.FolderRingAnimator;
  53  
  54  import java.util.ArrayList;
  55  import java.util.Arrays;
  56  import java.util.HashMap;
  57  import java.util.Stack;
  58  
  59  public class CellLayout extends ViewGroup {
  60      static final String TAG = &quot;CellLayout&quot;;
  61  
  62      private int mOriginalCellWidth;
  63      private int mOriginalCellHeight;
  64      private int mCellWidth;
  65      private int mCellHeight;
  66  
  67      private int mCountX;
  68      private int mCountY;
  69  
  70      private int mOriginalWidthGap;
  71      private int mOriginalHeightGap;
  72      private int mWidthGap;
  73      private int mHeightGap;
  74      private int mMaxGap;
  75      private boolean mScrollingTransformsDirty = false;
  76  
  77      private final Rect mRect = new Rect();
  78      private final CellInfo mCellInfo = new CellInfo();
  79  
  80      // These are temporary variables to prevent having to allocate a new object just to
  81      // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  82      private final int[] mTmpXY = new int[2];
  83      private final int[] mTmpPoint = new int[2];
  84      private final PointF mTmpPointF = new PointF();
  85      int[] mTempLocation = new int[2];
  86  
  87      boolean[][] mOccupied;
  88      boolean[][] mTmpOccupied;
  89      private boolean mLastDownOnOccupiedCell = false;
  90  
  91      private OnTouchListener mInterceptTouchListener;
  92  
  93      private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
  94      private int[] mFolderLeaveBehindCell = {-1, -1};
  95  
  96      private int mForegroundAlpha = 0;
  97      private float mBackgroundAlpha;
  98      private float mBackgroundAlphaMultiplier = 1.0f;
  99  
 100      private Drawable mNormalBackground;
 101      private Drawable mActiveGlowBackground;
 102      private Drawable mOverScrollForegroundDrawable;
 103      private Drawable mOverScrollLeft;
 104      private Drawable mOverScrollRight;
 105      private Rect mBackgroundRect;
 106      private Rect mForegroundRect;
 107      private int mForegroundPadding;
 108  
 109      // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 110      private boolean mIsDragOverlapping = false;
 111      private final Point mDragCenter = new Point();
 112  
 113      // These arrays are used to implement the drag visualization on x-large screens.
 114      // They are used as circular arrays, indexed by mDragOutlineCurrent.
 115      private Rect[] mDragOutlines = new Rect[4];
 116      private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 117      private InterruptibleInOutAnimator[] mDragOutlineAnims =
 118              new InterruptibleInOutAnimator[mDragOutlines.length];
 119  
 120      // Used as an index into the above 3 arrays; indicates which is the most current value.
 121      private int mDragOutlineCurrent = 0;
 122      private final Paint mDragOutlinePaint = new Paint();
 123  
 124      private BubbleTextView mPressedOrFocusedIcon;
 125  
 126      private Drawable mCrosshairsDrawable = null;
 127      private InterruptibleInOutAnimator mCrosshairsAnimator = null;
 128      private float mCrosshairsVisibility = 0.0f;
 129  
 130      private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new
 131              HashMap&lt;CellLayout.LayoutParams, Animator&gt;();
 132  
 133      // When a drag operation is in progress, holds the nearest cell to the touch point
 134      private final int[] mDragCell = new int[2];
 135  
 136      private boolean mDragging = false;
 137      private boolean mItemLocationsDirty = false;
 138  
 139      private TimeInterpolator mEaseOutInterpolator;
 140      private CellLayoutChildren mChildren;

 141  
 142      private boolean mIsHotseat = false;
 143      private float mChildScale = 1f;
 144      private float mHotseatChildScale = 1f;
 145  
 146      public static final int MODE_DRAG_OVER = 0;
 147      public static final int MODE_ON_DROP = 1;
 148      public static final int MODE_ON_DROP_EXTERNAL = 2;
 149      public static final int MODE_ACCEPT_DROP = 3;
 150      private static final boolean DESTRUCTIVE_REORDER = true;
 151      private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 152  
 153      private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 154      private Rect mOccupiedRect = new Rect();
 155      private int[] mDirectionVector = new int[2];
 156  
 157      public CellLayout(Context context) {
 158          this(context, null);
 159      }
 160  
 161      public CellLayout(Context context, AttributeSet attrs) {
 162          this(context, attrs, 0);
 163      }
 164  
 165      public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 166          super(context, attrs, defStyle);
 167  
 168          // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 169          // the user where a dragged item will land when dropped.
 170          setWillNotDraw(false);
 171  
 172          TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 173  
 174          mOriginalCellWidth =
 175              mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 176          mOriginalCellHeight =
 177              mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 178          mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 179          mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 180          mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 181          mCountX = LauncherModel.getCellCountX();
 182          mCountY = LauncherModel.getCellCountY();
 183          mOccupied = new boolean[mCountX][mCountY];
 184          mTmpOccupied = new boolean[mCountX][mCountY];
 185  
 186          a.recycle();
 187  
 188          setAlwaysDrawnWithCacheEnabled(false);
 189  
 190          final Resources res = getResources();
 191  
 192          mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 193          mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 194  
 195          mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 196          mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 197          mForegroundPadding =
 198                  res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 199  
 200          mNormalBackground.setFilterBitmap(true);
 201          mActiveGlowBackground.setFilterBitmap(true);
 202  
 203          int iconScale = res.getInteger(R.integer.app_icon_scale_percent);
 204          if (iconScale &gt;= 0) {
 205              mChildScale = iconScale / 100f;
 206          }
 207          int hotseatIconScale = res.getInteger(R.integer.app_icon_hotseat_scale_percent);
 208          if (hotseatIconScale &gt;= 0) {
 209              mHotseatChildScale = hotseatIconScale / 100f;
 210          }
 211  
 212          // Initialize the data structures used for the drag visualization.
 213  
 214          mCrosshairsDrawable = res.getDrawable(R.drawable.gardening_crosshairs);
 215          mEaseOutInterpolator = new DecelerateInterpolator(2.5f); // Quint ease out
 216  
 217          // Set up the animation for fading the crosshairs in and out
 218          int animDuration = res.getInteger(R.integer.config_crosshairsFadeInTime);
 219          mCrosshairsAnimator = new InterruptibleInOutAnimator(animDuration, 0.0f, 1.0f);
 220          mCrosshairsAnimator.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 221              public void onAnimationUpdate(ValueAnimator animation) {
 222                  mCrosshairsVisibility = ((Float) animation.getAnimatedValue()).floatValue();
 223                  invalidate();
 224              }
 225          });
 226          mCrosshairsAnimator.getAnimator().setInterpolator(mEaseOutInterpolator);
 227  
 228          mDragCell[0] = mDragCell[1] = -1;
 229          for (int i = 0; i &lt; mDragOutlines.length; i++) {
 230              mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 231          }
 232  
 233          // When dragging things around the home screens, we show a green outline of
 234          // where the item will land. The outlines gradually fade out, leaving a trail
 235          // behind the drag path.
 236          // Set up all the animations that are used to implement this fading.
 237          final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 238          final float fromAlphaValue = 0;
 239          final float toAlphaValue = (float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
 240  
 241          Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 242  
 243          for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
 244              final InterruptibleInOutAnimator anim =
 245                  new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);
 246              anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 247              final int thisIndex = i;
 248              anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 249                  public void onAnimationUpdate(ValueAnimator animation) {
 250                      final Bitmap outline = (Bitmap)anim.getTag();
 251  
 252                      // If an animation is started and then stopped very quickly, we can still
 253                      // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 254                      if (outline == null) {
 255                          if (false) {
 256                              Object val = animation.getAnimatedValue();
 257                              Log.d(TAG, &quot;anim &quot; + thisIndex + &quot; update: &quot; + val +
 258                                       &quot;, isStopped &quot; + anim.isStopped());
 259                          }
 260                          // Try to prevent it from continuing to run
 261                          animation.cancel();
 262                      } else {
 263                          mDragOutlineAlphas[thisIndex] = (Float) animation.getAnimatedValue();
 264                          CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 265                      }
 266                  }
 267              });
 268              // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 269              // running. This way the bitmap can be GCed when the animations are complete.
 270              anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 271                  @Override
 272                  public void onAnimationEnd(Animator animation) {
 273                      if ((Float) ((ValueAnimator) animation).getAnimatedValue() == 0f) {
 274                          anim.setTag(null);
 275                      }
 276                  }
 277              });
 278              mDragOutlineAnims[i] = anim;
 279          }
 280  
 281          mBackgroundRect = new Rect();
 282          mForegroundRect = new Rect();
 283  
 284          mChildren = new CellLayoutChildren(context);
 285          mChildren.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 286          addView(mChildren);



 287      }
 288  
 289      static int widthInPortrait(Resources r, int numCells) {
 290          // We use this method from Workspace to figure out how many rows/columns Launcher should
 291          // have. We ignore the left/right padding on CellLayout because it turns out in our design
 292          // the padding extends outside the visible screen size, but it looked fine anyway.
 293          int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 294          int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 295                  r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 296  
 297          return  minGap * (numCells - 1) + cellWidth * numCells;
 298      }
 299  
 300      static int heightInLandscape(Resources r, int numCells) {
 301          // We use this method from Workspace to figure out how many rows/columns Launcher should
 302          // have. We ignore the left/right padding on CellLayout because it turns out in our design
 303          // the padding extends outside the visible screen size, but it looked fine anyway.
 304          int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 305          int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 306                  r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 307  
 308          return minGap * (numCells - 1) + cellHeight * numCells;
 309      }
 310  
 311      public void enableHardwareLayers() {
 312          mChildren.enableHardwareLayers();

 313      }
 314  
 315      public void setGridSize(int x, int y) {
 316          mCountX = x;
 317          mCountY = y;
 318          mOccupied = new boolean[mCountX][mCountY];
 319          mTmpOccupied = new boolean[mCountX][mCountY];
 320          requestLayout();
 321      }
 322  
 323      private void invalidateBubbleTextView(BubbleTextView icon) {
 324          final int padding = icon.getPressedOrFocusedBackgroundPadding();
 325          invalidate(icon.getLeft() + getPaddingLeft() - padding,
 326                  icon.getTop() + getPaddingTop() - padding,
 327                  icon.getRight() + getPaddingLeft() + padding,
 328                  icon.getBottom() + getPaddingTop() + padding);
 329      }
 330  
 331      void setOverScrollAmount(float r, boolean left) {
 332          if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 333              mOverScrollForegroundDrawable = mOverScrollLeft;
 334          } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 335              mOverScrollForegroundDrawable = mOverScrollRight;
 336          }
 337  
 338          mForegroundAlpha = (int) Math.round((r * 255));
 339          mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 340          invalidate();
 341      }
 342  
 343      void setPressedOrFocusedIcon(BubbleTextView icon) {
 344          // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 345          // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 346          BubbleTextView oldIcon = mPressedOrFocusedIcon;
 347          mPressedOrFocusedIcon = icon;
 348          if (oldIcon != null) {
 349              invalidateBubbleTextView(oldIcon);
 350          }
 351          if (mPressedOrFocusedIcon != null) {
 352              invalidateBubbleTextView(mPressedOrFocusedIcon);
 353          }
 354      }
 355  
 356      public CellLayoutChildren getChildrenLayout() {
 357          if (getChildCount() &gt; 0) {
 358              return (CellLayoutChildren) getChildAt(0);
 359          }
 360          return null;
 361      }
 362  
 363      void setIsDragOverlapping(boolean isDragOverlapping) {
 364          if (mIsDragOverlapping != isDragOverlapping) {
 365              mIsDragOverlapping = isDragOverlapping;
 366              invalidate();
 367          }
 368      }
 369  
 370      boolean getIsDragOverlapping() {
 371          return mIsDragOverlapping;
 372      }
 373  
 374      protected void setOverscrollTransformsDirty(boolean dirty) {
 375          mScrollingTransformsDirty = dirty;
 376      }
 377  
 378      protected void resetOverscrollTransforms() {
 379          if (mScrollingTransformsDirty) {
 380              setOverscrollTransformsDirty(false);
 381              setTranslationX(0);
 382              setRotationY(0);
 383              // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 384              // pass 0, which results in the overscroll drawable not being drawn any more.
 385              setOverScrollAmount(0, false);
 386              setPivotX(getMeasuredWidth() / 2);
 387              setPivotY(getMeasuredHeight() / 2);
 388          }
 389      }
 390  
 391      @Override
 392      protected void onDraw(Canvas canvas) {
 393          // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 394          // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 395          // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 396          // a drag). However, we also drag the mini hover background *over* one of those two
 397          // backgrounds
 398          if (mBackgroundAlpha &gt; 0.0f) {
 399              Drawable bg;
 400  
 401              if (mIsDragOverlapping) {
 402                  // In the mini case, we draw the active_glow bg *over* the active background
 403                  bg = mActiveGlowBackground;
 404              } else {
 405                  bg = mNormalBackground;
 406              }
 407  
 408              bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 409              bg.setBounds(mBackgroundRect);
 410              bg.draw(canvas);
 411          }
 412  
 413          if (mCrosshairsVisibility &gt; 0.0f) {
 414              final int countX = mCountX;
 415              final int countY = mCountY;
 416  
 417              final float MAX_ALPHA = 0.4f;
 418              final int MAX_VISIBLE_DISTANCE = 600;
 419              final float DISTANCE_MULTIPLIER = 0.002f;
 420  
 421              final Drawable d = mCrosshairsDrawable;
 422              final int width = d.getIntrinsicWidth();
 423              final int height = d.getIntrinsicHeight();
 424  
 425              int x = getPaddingLeft() - (mWidthGap / 2) - (width / 2);
 426              for (int col = 0; col &lt;= countX; col++) {
 427                  int y = getPaddingTop() - (mHeightGap / 2) - (height / 2);
 428                  for (int row = 0; row &lt;= countY; row++) {
 429                      mTmpPointF.set(x - mDragCenter.x, y - mDragCenter.y);
 430                      float dist = mTmpPointF.length();
 431                      // Crosshairs further from the drag point are more faint
 432                      float alpha = Math.min(MAX_ALPHA,
 433                              DISTANCE_MULTIPLIER * (MAX_VISIBLE_DISTANCE - dist));
 434                      if (alpha &gt; 0.0f) {
 435                          d.setBounds(x, y, x + width, y + height);
 436                          d.setAlpha((int) (alpha * 255 * mCrosshairsVisibility));
 437                          d.draw(canvas);
 438                      }
 439                      y += mCellHeight + mHeightGap;
 440                  }
 441                  x += mCellWidth + mWidthGap;
 442              }
 443          }
 444  
 445          final Paint paint = mDragOutlinePaint;
 446          for (int i = 0; i &lt; mDragOutlines.length; i++) {
 447              final float alpha = mDragOutlineAlphas[i];
 448              if (alpha &gt; 0) {
 449                  final Rect r = mDragOutlines[i];
 450                  final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 451                  paint.setAlpha((int)(alpha + .5f));
 452                  canvas.drawBitmap(b, null, r, paint);
 453              }
 454          }
 455  
 456          // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 457          // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 458          if (mPressedOrFocusedIcon != null) {
 459              final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 460              final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 461              if (b != null) {
 462                  canvas.drawBitmap(b,
 463                          mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 464                          mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 465                          null);
 466              }
 467          }
 468  
 469          if (DEBUG_VISUALIZE_OCCUPIED) {
 470              int[] pt = new int[2];
 471              ColorDrawable cd = new ColorDrawable(Color.RED);
 472              cd.setBounds(0, 0, 80, 80);
 473              for (int i = 0; i &lt; mCountX; i++) {
 474                  for (int j = 0; j &lt; mCountY; j++) {
 475                      if (mOccupied[i][j]) {
 476                          cellToPoint(i, j, pt);
 477                          canvas.save();
 478                          canvas.translate(pt[0], pt[1]);
 479                          cd.draw(canvas);
 480                          canvas.restore();
 481                      }
 482                  }
 483              }
 484          }
 485  
 486          // The folder outer / inner ring image(s)
 487          for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 488              FolderRingAnimator fra = mFolderOuterRings.get(i);
 489  
 490              // Draw outer ring
 491              Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 492              int width = (int) fra.getOuterRingSize();
 493              int height = width;
 494              cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 495  
 496              int centerX = mTempLocation[0] + mCellWidth / 2;
 497              int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 498  
 499              canvas.save();
 500              canvas.translate(centerX - width / 2, centerY - height / 2);
 501              d.setBounds(0, 0, width, height);
 502              d.draw(canvas);
 503              canvas.restore();
 504  
 505              // Draw inner ring
 506              d = FolderRingAnimator.sSharedInnerRingDrawable;
 507              width = (int) fra.getInnerRingSize();
 508              height = width;
 509              cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 510  
 511              centerX = mTempLocation[0] + mCellWidth / 2;
 512              centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 513              canvas.save();
 514              canvas.translate(centerX - width / 2, centerY - width / 2);
 515              d.setBounds(0, 0, width, height);
 516              d.draw(canvas);
 517              canvas.restore();
 518          }
 519  
 520          if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 521              Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 522              int width = d.getIntrinsicWidth();
 523              int height = d.getIntrinsicHeight();
 524  
 525              cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 526              int centerX = mTempLocation[0] + mCellWidth / 2;
 527              int centerY = mTempLocation[1] + FolderRingAnimator.sPreviewSize / 2;
 528  
 529              canvas.save();
 530              canvas.translate(centerX - width / 2, centerY - width / 2);
 531              d.setBounds(0, 0, width, height);
 532              d.draw(canvas);
 533              canvas.restore();
 534          }
 535      }
 536  
 537      @Override
 538      protected void dispatchDraw(Canvas canvas) {
 539          super.dispatchDraw(canvas);
 540          if (mForegroundAlpha &gt; 0) {
 541              mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 542              Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 543              p.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));
 544              mOverScrollForegroundDrawable.draw(canvas);
 545              p.setXfermode(null);
 546          }
 547      }
 548  
 549      public void showFolderAccept(FolderRingAnimator fra) {
 550          mFolderOuterRings.add(fra);
 551      }
 552  
 553      public void hideFolderAccept(FolderRingAnimator fra) {
 554          if (mFolderOuterRings.contains(fra)) {
 555              mFolderOuterRings.remove(fra);
 556          }
 557          invalidate();
 558      }
 559  
 560      public void setFolderLeaveBehindCell(int x, int y) {
 561          mFolderLeaveBehindCell[0] = x;
 562          mFolderLeaveBehindCell[1] = y;
 563          invalidate();
 564      }
 565  
 566      public void clearFolderLeaveBehind() {
 567          mFolderLeaveBehindCell[0] = -1;
 568          mFolderLeaveBehindCell[1] = -1;
 569          invalidate();
 570      }
 571  
 572      @Override
 573      public boolean shouldDelayChildPressedState() {
 574          return false;
 575      }
 576  
 577      @Override
 578      public void cancelLongPress() {
 579          super.cancelLongPress();
 580  
 581          // Cancel long press for all children
 582          final int count = getChildCount();
 583          for (int i = 0; i &lt; count; i++) {
 584              final View child = getChildAt(i);
 585              child.cancelLongPress();
 586          }
 587      }
 588  
 589      public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 590          mInterceptTouchListener = listener;
 591      }
 592  
 593      int getCountX() {
 594          return mCountX;
 595      }
 596  
 597      int getCountY() {
 598          return mCountY;
 599      }
 600  
 601      public void setIsHotseat(boolean isHotseat) {
 602          mIsHotseat = isHotseat;
 603      }
 604  
 605      public float getChildrenScale() {
 606          return mIsHotseat ? mHotseatChildScale : mChildScale;
 607      }
 608  
 609      public boolean addViewToCellLayout(
 610              View child, int index, int childId, LayoutParams params, boolean markCells) {
 611          return addViewToCellLayout(child, index, childId, params, markCells, false);
 612      }
 613  
 614      private void scaleChild(BubbleTextView bubbleChild, float pivot, float scale) {
 615          // If we haven&#x27;t measured the child yet, do it now
 616          // (this happens if we&#x27;re being dropped from all-apps
 617          if (bubbleChild.getLayoutParams() instanceof LayoutParams &amp;&amp;
 618                  (bubbleChild.getMeasuredWidth() | bubbleChild.getMeasuredHeight()) == 0) {
 619              getChildrenLayout().measureChild(bubbleChild);

 620          }
 621          int measuredWidth = bubbleChild.getMeasuredWidth();
 622          int measuredHeight = bubbleChild.getMeasuredHeight();
 623  
 624          bubbleChild.setScaleX(scale);
 625          bubbleChild.setScaleY(scale);
 626      }
 627  
 628      private void resetChild(BubbleTextView bubbleChild) {
 629          bubbleChild.setScaleX(1f);
 630          bubbleChild.setScaleY(1f);
 631  
 632          bubbleChild.setTextColor(getResources().getColor(R.color.workspace_icon_text_color));
 633      }
 634  
 635      public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 636              boolean markCells, boolean allApps) {
 637          final LayoutParams lp = params;
 638  
 639          // Hotseat icons - scale down and remove text
 640          // Don&#x27;t scale the all apps button
 641          // scale percent set to -1 means do not scale
 642          // Only scale BubbleTextViews
 643          if (child instanceof BubbleTextView) {
 644              BubbleTextView bubbleChild = (BubbleTextView) child;
 645  
 646              // Start the child with 100% scale and visible text
 647              resetChild(bubbleChild);
 648  
 649              if (mIsHotseat &amp;&amp; !allApps &amp;&amp; mHotseatChildScale &gt;= 0) {
 650                  // Scale/make transparent for a hotseat
 651                  scaleChild(bubbleChild, 0f, mHotseatChildScale);
 652  
 653                  bubbleChild.setTextColor(getResources().getColor(android.R.color.transparent));
 654              } else if (mChildScale &gt;= 0) {
 655                  // Else possibly still scale it if we need to for smaller icons
 656                  scaleChild(bubbleChild, 0f, mChildScale);
 657              }
 658          }
 659  
 660          // Generate an id for each view, this assumes we have at most 256x256 cells
 661          // per workspace screen
 662          if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 663              // If the horizontal or vertical span is set to -1, it is taken to
 664              // mean that it spans the extent of the CellLayout
 665              if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 666              if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 667  
 668              child.setId(childId);
 669  
 670              mChildren.addView(child, index, lp);

 671  
 672              if (markCells) markCellsAsOccupiedForView(child);
 673  
 674              return true;
 675          }
 676          return false;
 677      }
 678  
 679      @Override
 680      public void removeAllViews() {
 681          clearOccupiedCells();
 682          mChildren.removeAllViews();

 683      }
 684  
 685      @Override
 686      public void removeAllViewsInLayout() {
 687          if (mChildren.getChildCount() &gt; 0) {

 688              clearOccupiedCells();
 689              mChildren.removeAllViewsInLayout();

 690          }
 691      }
 692  
 693      public void removeViewWithoutMarkingCells(View view) {
 694          mChildren.removeView(view);

 695      }
 696  
 697      @Override
 698      public void removeView(View view) {
 699          markCellsAsUnoccupiedForView(view);
 700          mChildren.removeView(view);

 701      }
 702  
 703      @Override
 704      public void removeViewAt(int index) {
 705          markCellsAsUnoccupiedForView(mChildren.getChildAt(index));
 706          mChildren.removeViewAt(index);


 707      }
 708  
 709      @Override
 710      public void removeViewInLayout(View view) {
 711          markCellsAsUnoccupiedForView(view);
 712          mChildren.removeViewInLayout(view);

 713      }
 714  
 715      @Override
 716      public void removeViews(int start, int count) {
 717          for (int i = start; i &lt; start + count; i++) {
 718              markCellsAsUnoccupiedForView(mChildren.getChildAt(i));
 719          }
 720          mChildren.removeViews(start, count);



 721      }
 722  
 723      @Override
 724      public void removeViewsInLayout(int start, int count) {
 725          for (int i = start; i &lt; start + count; i++) {
 726              markCellsAsUnoccupiedForView(mChildren.getChildAt(i));
 727          }
 728          mChildren.removeViewsInLayout(start, count);
 729      }
 730  
 731      public void drawChildren(Canvas canvas) {
 732          mChildren.draw(canvas);
 733      }
 734  
 735      void buildChildrenLayer() {
 736          mChildren.buildLayer();



 737      }
 738  
 739      @Override
 740      protected void onAttachedToWindow() {
 741          super.onAttachedToWindow();
 742          mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 743      }
 744  
 745      public void setTagToCellInfoForPoint(int touchX, int touchY) {
 746          final CellInfo cellInfo = mCellInfo;
 747          Rect frame = mRect;
 748          final int x = touchX + mScrollX;
 749          final int y = touchY + mScrollY;
 750          final int count = mChildren.getChildCount();

 751  
 752          boolean found = false;
 753          for (int i = count - 1; i &gt;= 0; i--) {
 754              final View child = mChildren.getChildAt(i);

 755              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 756  
 757              if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 758                      lp.isLockedToGrid) {
 759                  child.getHitRect(frame);
 760  
 761                  float scale = child.getScaleX();
 762                  frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 763                          child.getBottom());
 764                  // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 765                  // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 766                  // to this view.
 767                  frame.offset(mPaddingLeft, mPaddingTop);
 768                  frame.inset((int) (frame.width() * (1f - scale) / 2),
 769                          (int) (frame.height() * (1f - scale) / 2));
 770  
 771                  if (frame.contains(x, y)) {
 772                      cellInfo.cell = child;
 773                      cellInfo.cellX = lp.cellX;
 774                      cellInfo.cellY = lp.cellY;
 775                      cellInfo.spanX = lp.cellHSpan;
 776                      cellInfo.spanY = lp.cellVSpan;
 777                      found = true;
 778                      break;
 779                  }
 780              }
 781          }
 782  
 783          mLastDownOnOccupiedCell = found;
 784  
 785          if (!found) {
 786              final int cellXY[] = mTmpXY;
 787              pointToCellExact(x, y, cellXY);
 788  
 789              cellInfo.cell = null;
 790              cellInfo.cellX = cellXY[0];
 791              cellInfo.cellY = cellXY[1];
 792              cellInfo.spanX = 1;
 793              cellInfo.spanY = 1;
 794          }
 795          setTag(cellInfo);
 796      }
 797  
 798      @Override
 799      public boolean onInterceptTouchEvent(MotionEvent ev) {
 800          // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 801          // even in the case where we return early. Not clearing here was causing bugs whereby on
 802          // long-press we&#x27;d end up picking up an item from a previous drag operation.
 803          final int action = ev.getAction();
 804  
 805          if (action == MotionEvent.ACTION_DOWN) {
 806              clearTagCellInfo();
 807          }
 808  
 809          if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 810              return true;
 811          }
 812  
 813          if (action == MotionEvent.ACTION_DOWN) {
 814              setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 815          }
 816  
 817          return false;
 818      }
 819  
 820      private void clearTagCellInfo() {
 821          final CellInfo cellInfo = mCellInfo;
 822          cellInfo.cell = null;
 823          cellInfo.cellX = -1;
 824          cellInfo.cellY = -1;
 825          cellInfo.spanX = 0;
 826          cellInfo.spanY = 0;
 827          setTag(cellInfo);
 828      }
 829  
 830      public CellInfo getTag() {
 831          return (CellInfo) super.getTag();
 832      }
 833  
 834      /**
 835       * Given a point, return the cell that strictly encloses that point
 836       * @param x X coordinate of the point
 837       * @param y Y coordinate of the point
 838       * @param result Array of 2 ints to hold the x and y coordinate of the cell
 839       */
 840      void pointToCellExact(int x, int y, int[] result) {
 841          final int hStartPadding = getPaddingLeft();
 842          final int vStartPadding = getPaddingTop();
 843  
 844          result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 845          result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 846  
 847          final int xAxis = mCountX;
 848          final int yAxis = mCountY;
 849  
 850          if (result[0] &lt; 0) result[0] = 0;
 851          if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 852          if (result[1] &lt; 0) result[1] = 0;
 853          if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 854      }
 855  
 856      /**
 857       * Given a point, return the cell that most closely encloses that point
 858       * @param x X coordinate of the point
 859       * @param y Y coordinate of the point
 860       * @param result Array of 2 ints to hold the x and y coordinate of the cell
 861       */
 862      void pointToCellRounded(int x, int y, int[] result) {
 863          pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 864      }
 865  
 866      /**
 867       * Given a cell coordinate, return the point that represents the upper left corner of that cell
 868       *
 869       * @param cellX X coordinate of the cell
 870       * @param cellY Y coordinate of the cell
 871       *
 872       * @param result Array of 2 ints to hold the x and y coordinate of the point
 873       */
 874      void cellToPoint(int cellX, int cellY, int[] result) {
 875          final int hStartPadding = getPaddingLeft();
 876          final int vStartPadding = getPaddingTop();
 877  
 878          result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 879          result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 880      }
 881  
 882      /**
 883       * Given a cell coordinate, return the point that represents the center of the cell
 884       *
 885       * @param cellX X coordinate of the cell
 886       * @param cellY Y coordinate of the cell
 887       *
 888       * @param result Array of 2 ints to hold the x and y coordinate of the point
 889       */
 890      void cellToCenterPoint(int cellX, int cellY, int[] result) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 891 -        regionToCenterPoint(cellX, cellY, 1, 1, result);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 892 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 893 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 894 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 895 -     * Given a cell coordinate and span return the point that represents the center of the regio</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 896 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 897 -     * @param cellX X coordinate of the cell</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 898 -     * @param cellY Y coordinate of the cell</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 899 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 900 -     * @param result Array of 2 ints to hold the x and y coordinate of the point</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 901 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 902 -    void regionToCenterPoint(int cellX, int cellY, int spanX, int spanY, int[] result) {</span>
 903          final int hStartPadding = getPaddingLeft();
 904          final int vStartPadding = getPaddingTop();
 905  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 906 -        result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 907 -                (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 908 -        result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 909 -                (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +        result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) + mCellWidth / 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +        result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) + mCellHeight / 2;</span>
 912      }
 913  
 914      public float getDistanceFromCell(float x, float y, int[] cell) {
 915          cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 916          float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 917                  Math.pow(y - mTmpPoint[1], 2));
 918          return distance;
 919      }
 920  
 921      int getCellWidth() {
 922          return mCellWidth;
 923      }
 924  
 925      int getCellHeight() {
 926          return mCellHeight;
 927      }
 928  
 929      int getWidthGap() {
 930          return mWidthGap;
 931      }
 932  
 933      int getHeightGap() {
 934          return mHeightGap;
 935      }
 936  
 937      Rect getContentRect(Rect r) {
 938          if (r == null) {
 939              r = new Rect();
 940          }
 941          int left = getPaddingLeft();
 942          int top = getPaddingTop();
 943          int right = left + getWidth() - mPaddingLeft - mPaddingRight;
 944          int bottom = top + getHeight() - mPaddingTop - mPaddingBottom;
 945          r.set(left, top, right, bottom);
 946          return r;
 947      }
 948  
 949      @Override
 950      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 951          // TODO: currently ignoring padding
 952  
 953          int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 954          int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 955  
 956          int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 957          int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 958  
 959          if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 960              throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 961          }
 962  
 963          int numWidthGaps = mCountX - 1;
 964          int numHeightGaps = mCountY - 1;
 965  
 966          if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 967              int hSpace = widthSpecSize - mPaddingLeft - mPaddingRight;
 968              int vSpace = heightSpecSize - mPaddingTop - mPaddingBottom;
 969              int hFreeSpace = hSpace - (mCountX * mOriginalCellWidth);
 970              int vFreeSpace = vSpace - (mCountY * mOriginalCellHeight);
 971              mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 972              mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 973              mChildren.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);

 974          } else {
 975              mWidthGap = mOriginalWidthGap;
 976              mHeightGap = mOriginalHeightGap;
 977          }
 978  
 979          // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 980          int newWidth = widthSpecSize;
 981          int newHeight = heightSpecSize;
 982          if (widthSpecMode == MeasureSpec.AT_MOST) {
 983              newWidth = mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
 984                  ((mCountX - 1) * mWidthGap);
 985              newHeight = mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
 986                  ((mCountY - 1) * mHeightGap);
 987              setMeasuredDimension(newWidth, newHeight);
 988          }
 989  
 990          int count = getChildCount();
 991          for (int i = 0; i &lt; count; i++) {
 992              View child = getChildAt(i);
 993              int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - mPaddingLeft -
 994                      mPaddingRight, MeasureSpec.EXACTLY);
 995              int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - mPaddingTop -
 996                      mPaddingBottom, MeasureSpec.EXACTLY);
 997              child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 998          }
 999          setMeasuredDimension(newWidth, newHeight);
1000      }
1001  
1002      @Override
1003      protected void onLayout(boolean changed, int l, int t, int r, int b) {
1004          int count = getChildCount();
1005          for (int i = 0; i &lt; count; i++) {
1006              View child = getChildAt(i);
1007              child.layout(mPaddingLeft, mPaddingTop,
1008                      r - l - mPaddingRight, b - t - mPaddingBottom);
1009          }
1010      }
1011  
1012      @Override
1013      protected void onSizeChanged(int w, int h, int oldw, int oldh) {
1014          super.onSizeChanged(w, h, oldw, oldh);
1015          mBackgroundRect.set(0, 0, w, h);
1016          mForegroundRect.set(mForegroundPadding, mForegroundPadding,
1017                  w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
1018      }
1019  
1020      @Override
1021      protected void setChildrenDrawingCacheEnabled(boolean enabled) {
1022          mChildren.setChildrenDrawingCacheEnabled(enabled);

1023      }
1024  
1025      @Override
1026      protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
1027          mChildren.setChildrenDrawnWithCacheEnabled(enabled);

1028      }
1029  
1030      public float getBackgroundAlpha() {
1031          return mBackgroundAlpha;
1032      }
1033  
1034      public void setBackgroundAlphaMultiplier(float multiplier) {
1035          mBackgroundAlphaMultiplier = multiplier;
1036      }
1037  
1038      public float getBackgroundAlphaMultiplier() {
1039          return mBackgroundAlphaMultiplier;
1040      }
1041  
1042      public void setBackgroundAlpha(float alpha) {
1043          if (mBackgroundAlpha != alpha) {
1044              mBackgroundAlpha = alpha;
1045              invalidate();
1046          }
1047      }
1048  
1049      // Need to return true to let the view system know we know how to handle alpha-- this is
1050      // because when our children have an alpha of 0.0f, they are still rendering their &quot;dimmed&quot;
1051      // versions
1052      @Override
1053      protected boolean onSetAlpha(int alpha) {
1054          return true;
1055      }
1056  
1057      @Override
1058      public void setAlpha(float alpha) {
1059          setChildrenAlpha(alpha);
1060          super.setAlpha(alpha);
1061      }
1062  
1063      private void setChildrenAlpha(float alpha) {

1064          final int childCount = getChildCount();
1065          for (int i = 0; i &lt; childCount; i++) {
1066              getChildAt(i).setAlpha(alpha);
1067          }
1068      }
1069  







1070      public View getChildAt(int x, int y) {
1071          return mChildren.getChildAt(x, y);

1072      }
1073  
1074      public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration,
1075              int delay, boolean permanent, boolean adjustOccupied) {
1076          CellLayoutChildren clc = getChildrenLayout();

1077          boolean[][] occupied = mOccupied;
1078          if (!permanent) {
1079              occupied = mTmpOccupied;
1080          }
1081  
1082          if (clc.indexOfChild(child) != -1 &amp;&amp; !occupied[cellX][cellY]) {
1083              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
1084              final ItemInfo info = (ItemInfo) child.getTag();
1085  
1086              // We cancel any existing animations
1087              if (mReorderAnimators.containsKey(lp)) {
1088                  mReorderAnimators.get(lp).cancel();
1089                  mReorderAnimators.remove(lp);
1090              }
1091  
1092              final int oldX = lp.x;
1093              final int oldY = lp.y;
1094              if (adjustOccupied) {
1095                  occupied[lp.cellX][lp.cellY] = false;
1096                  occupied[cellX][cellY] = true;
1097              }
1098              lp.isLockedToGrid = true;
1099              if (permanent) {
1100                  lp.cellX = info.cellX = cellX;
1101                  lp.cellY = info.cellY = cellY;
1102              } else {
1103                  lp.tmpCellX = cellX;
1104                  lp.tmpCellY = cellY;
1105              }
1106              clc.setupLp(lp);
1107              lp.isLockedToGrid = false;
1108              final int newX = lp.x;
1109              final int newY = lp.y;
1110  
1111              lp.x = oldX;
1112              lp.y = oldY;
1113  
1114              // Exit early if we&#x27;re not actually moving the view
1115              if (oldX == newX &amp;&amp; oldY == newY) {
1116                  lp.isLockedToGrid = true;
1117                  return true;
1118              }
1119  
1120              ValueAnimator va = ValueAnimator.ofFloat(0f, 1f);
1121              va.setDuration(duration);
1122              mReorderAnimators.put(lp, va);
1123  
1124              va.addUpdateListener(new AnimatorUpdateListener() {
1125                  @Override
1126                  public void onAnimationUpdate(ValueAnimator animation) {
1127                      float r = ((Float) animation.getAnimatedValue()).floatValue();
1128                      child.setTranslationX(r * (newX - oldX));
1129                      child.setTranslationY(r * (newY - oldY));
1130                  }
1131              });
1132              va.addListener(new AnimatorListenerAdapter() {
1133                  boolean cancelled = false;
1134                  public void onAnimationEnd(Animator animation) {
1135                      // If the animation was cancelled, it means that another animation
1136                      // has interrupted this one, and we don&#x27;t want to lock the item into
1137                      // place just yet.
1138                      if (!cancelled) {
1139                          child.setTranslationX(0);
1140                          child.setTranslationY(0);
1141                          lp.isLockedToGrid = true;
1142                          child.requestLayout();
1143                      }
1144                      if (mReorderAnimators.containsKey(lp)) {
1145                          mReorderAnimators.remove(lp);
1146                      }
1147                  }
1148                  public void onAnimationCancel(Animator animation) {
1149                      cancelled = true;
1150                  }
1151              });
1152              va.setStartDelay(delay);
1153              va.start();
1154              return true;
1155          }
1156          return false;
1157      }
1158  
1159      /**
1160       * Estimate where the top left cell of the dragged item will land if it is dropped.
1161       *
1162       * @param originX The X value of the top left corner of the item
1163       * @param originY The Y value of the top left corner of the item
1164       * @param spanX The number of horizontal cells that the item spans
1165       * @param spanY The number of vertical cells that the item spans
1166       * @param result The estimated drop cell X and Y.
1167       */
1168      void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1169          final int countX = mCountX;
1170          final int countY = mCountY;
1171  
1172          // pointToCellRounded takes the top left of a cell but will pad that with
1173          // cellWidth/2 and cellHeight/2 when finding the matching cell
1174          pointToCellRounded(originX, originY, result);
1175  
1176          // If the item isn&#x27;t fully on this screen, snap to the edges
1177          int rightOverhang = result[0] + spanX - countX;
1178          if (rightOverhang &gt; 0) {
1179              result[0] -= rightOverhang; // Snap to right
1180          }
1181          result[0] = Math.max(0, result[0]); // Snap to left
1182          int bottomOverhang = result[1] + spanY - countY;
1183          if (bottomOverhang &gt; 0) {
1184              result[1] -= bottomOverhang; // Snap to bottom
1185          }
1186          result[1] = Math.max(0, result[1]); // Snap to top
1187      }
1188  
1189      void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1190              int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1191          final int oldDragCellX = mDragCell[0];
1192          final int oldDragCellY = mDragCell[1];
1193  
1194          if (v != null &amp;&amp; dragOffset == null) {
1195              mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1196          } else {
1197              mDragCenter.set(originX, originY);
1198          }
1199  
1200          if (dragOutline == null &amp;&amp; v == null) {
1201              if (mCrosshairsDrawable != null) {
1202                  invalidate();
1203              }
1204              return;
1205          }
1206  
1207          if (cellX != oldDragCellX || cellY != oldDragCellY) {
1208              mDragCell[0] = cellX;
1209              mDragCell[1] = cellY;
1210              // Find the top left corner of the rect the object will occupy
1211              final int[] topLeft = mTmpPoint;
1212              cellToPoint(cellX, cellY, topLeft);
1213  
1214              int left = topLeft[0];
1215              int top = topLeft[1];
1216  
1217              if (v != null &amp;&amp; dragOffset == null) {
1218                  // When drawing the drag outline, it did not account for margin offsets
1219                  // added by the view&#x27;s parent.
1220                  MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1221                  left += lp.leftMargin;
1222                  top += lp.topMargin;
1223  
1224                  // Offsets due to the size difference between the View and the dragOutline.
1225                  // There is a size difference to account for the outer blur, which may lie
1226                  // outside the bounds of the view.
1227                  top += (v.getHeight() - dragOutline.getHeight()) / 2;
1228                  // We center about the x axis
1229                  left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1230                          - dragOutline.getWidth()) / 2;
1231              } else {
1232                  if (dragOffset != null &amp;&amp; dragRegion != null) {
1233                      // Center the drag region *horizontally* in the cell and apply a drag
1234                      // outline offset
1235                      left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1236                               - dragRegion.width()) / 2;
1237                      top += dragOffset.y;
1238                  } else {
1239                      // Center the drag outline in the cell
1240                      left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1241                              - dragOutline.getWidth()) / 2;
1242                      top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1243                              - dragOutline.getHeight()) / 2;
1244                  }
1245              }
1246              final int oldIndex = mDragOutlineCurrent;
1247              mDragOutlineAnims[oldIndex].animateOut();
1248              mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1249              Rect r = mDragOutlines[mDragOutlineCurrent];
1250              r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1251              if (resize) {
1252                  cellToRect(cellX, cellY, spanX, spanY, r);
1253              }
1254  
1255              mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1256              mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1257          }
1258  
1259          // If we are drawing crosshairs, the entire CellLayout needs to be invalidated
1260          if (mCrosshairsDrawable != null) {
1261              invalidate();
1262          }
1263      }
1264  
1265      public void clearDragOutlines() {
1266          final int oldIndex = mDragOutlineCurrent;
1267          mDragOutlineAnims[oldIndex].animateOut();
1268          mDragCell[0] = mDragCell[1] = -1;
1269      }
1270  
1271      /**
1272       * Find a vacant area that will fit the given bounds nearest the requested
1273       * cell location. Uses Euclidean distance to score multiple vacant areas.
1274       *
1275       * @param pixelX The X location at which you want to search for a vacant area.
1276       * @param pixelY The Y location at which you want to search for a vacant area.
1277       * @param spanX Horizontal span of the object.
1278       * @param spanY Vertical span of the object.
1279       * @param result Array in which to place the result, or null (in which case a new array will
1280       *        be allocated)
1281       * @return The X, Y cell of a vacant area that can contain this object,
1282       *         nearest the requested location.
1283       */
1284      int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1285              int[] result) {
1286          return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1287      }
1288  
1289      /**
1290       * Find a vacant area that will fit the given bounds nearest the requested
1291       * cell location. Uses Euclidean distance to score multiple vacant areas.
1292       *
1293       * @param pixelX The X location at which you want to search for a vacant area.
1294       * @param pixelY The Y location at which you want to search for a vacant area.
1295       * @param minSpanX The minimum horizontal span required
1296       * @param minSpanY The minimum vertical span required
1297       * @param spanX Horizontal span of the object.
1298       * @param spanY Vertical span of the object.
1299       * @param result Array in which to place the result, or null (in which case a new array will
1300       *        be allocated)
1301       * @return The X, Y cell of a vacant area that can contain this object,
1302       *         nearest the requested location.
1303       */
1304      int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1305              int spanY, int[] result, int[] resultSpan) {
1306          return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1307                  result, resultSpan);
1308      }
1309  
1310      /**
1311       * Find a vacant area that will fit the given bounds nearest the requested
1312       * cell location. Uses Euclidean distance to score multiple vacant areas.
1313       *
1314       * @param pixelX The X location at which you want to search for a vacant area.
1315       * @param pixelY The Y location at which you want to search for a vacant area.
1316       * @param spanX Horizontal span of the object.
1317       * @param spanY Vertical span of the object.
1318       * @param ignoreOccupied If true, the result can be an occupied cell
1319       * @param result Array in which to place the result, or null (in which case a new array will
1320       *        be allocated)
1321       * @return The X, Y cell of a vacant area that can contain this object,
1322       *         nearest the requested location.
1323       */
1324      int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1325              boolean ignoreOccupied, int[] result) {
1326          return findNearestArea(pixelX, pixelY, spanX, spanY,
1327                  spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1328      }
1329  
1330      private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1331      private void lazyInitTempRectStack() {
1332          if (mTempRectStack.isEmpty()) {
1333              for (int i = 0; i &lt; mCountX * mCountY; i++) {
1334                  mTempRectStack.push(new Rect());
1335              }
1336          }
1337      }
1338  
1339      private void recycleTempRects(Stack&lt;Rect&gt; used) {
1340          while (!used.isEmpty()) {
1341              mTempRectStack.push(used.pop());
1342          }
1343      }
1344  
1345      /**
1346       * Find a vacant area that will fit the given bounds nearest the requested
1347       * cell location. Uses Euclidean distance to score multiple vacant areas.
1348       *
1349       * @param pixelX The X location at which you want to search for a vacant area.
1350       * @param pixelY The Y location at which you want to search for a vacant area.
1351       * @param minSpanX The minimum horizontal span required
1352       * @param minSpanY The minimum vertical span required
1353       * @param spanX Horizontal span of the object.
1354       * @param spanY Vertical span of the object.
1355       * @param ignoreOccupied If true, the result can be an occupied cell
1356       * @param result Array in which to place the result, or null (in which case a new array will
1357       *        be allocated)
1358       * @return The X, Y cell of a vacant area that can contain this object,
1359       *         nearest the requested location.
1360       */
1361      int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1362              View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1363              boolean[][] occupied) {
1364          lazyInitTempRectStack();
1365          // mark space take by ignoreView as available (method checks if ignoreView is null)
1366          markCellsAsUnoccupiedForView(ignoreView, occupied);
1367  
1368          // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1369          // to the center of the item, but we are searching based on the top-left cell, so
1370          // we translate the point over to correspond to the top-left.
1371          pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1372          pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1373  
1374          // Keep track of best-scoring drop area
1375          final int[] bestXY = result != null ? result : new int[2];
1376          double bestDistance = Double.MAX_VALUE;
1377          final Rect bestRect = new Rect(-1, -1, -1, -1);
1378          final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1379  
1380          final int countX = mCountX;
1381          final int countY = mCountY;
1382  
1383          if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1384                  spanX &lt; minSpanX || spanY &lt; minSpanY) {
1385              return bestXY;
1386          }
1387  
1388          for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1389              inner:
1390              for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1391                  int ySize = -1;
1392                  int xSize = -1;
1393                  if (ignoreOccupied) {
1394                      // First, let&#x27;s see if this thing fits anywhere
1395                      for (int i = 0; i &lt; minSpanX; i++) {
1396                          for (int j = 0; j &lt; minSpanY; j++) {
1397                              if (occupied[x + i][y + j]) {
1398                                  continue inner;
1399                              }
1400                          }
1401                      }
1402                      xSize = minSpanX;
1403                      ySize = minSpanY;
1404  
1405                      // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1406                      // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1407                      // until we hit a limit.
1408                      boolean incX = true;
1409                      boolean hitMaxX = xSize &gt;= spanX;
1410                      boolean hitMaxY = ySize &gt;= spanY;
1411                      while (!(hitMaxX &amp;&amp; hitMaxY)) {
1412                          if (incX &amp;&amp; !hitMaxX) {
1413                              for (int j = 0; j &lt; ySize; j++) {
1414                                  if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1415                                      // We can&#x27;t move out horizontally
1416                                      hitMaxX = true;
1417                                  }
1418                              }
1419                              if (!hitMaxX) {
1420                                  xSize++;
1421                              }
1422                          } else if (!hitMaxY) {
1423                              for (int i = 0; i &lt; xSize; i++) {
1424                                  if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1425                                      // We can&#x27;t move out vertically
1426                                      hitMaxY = true;
1427                                  }
1428                              }
1429                              if (!hitMaxY) {
1430                                  ySize++;
1431                              }
1432                          }
1433                          hitMaxX |= xSize &gt;= spanX;
1434                          hitMaxY |= ySize &gt;= spanY;
1435                          incX = !incX;
1436                      }
1437                      incX = true;
1438                      hitMaxX = xSize &gt;= spanX;
1439                      hitMaxY = ySize &gt;= spanY;
1440                  }
1441                  final int[] cellXY = mTmpXY;
1442                  cellToCenterPoint(x, y, cellXY);
1443  
1444                  // We verify that the current rect is not a sub-rect of any of our previous
1445                  // candidates. In this case, the current rect is disqualified in favour of the
1446                  // containing rect.
1447                  Rect currentRect = mTempRectStack.pop();
1448                  currentRect.set(x, y, x + xSize, y + ySize);
1449                  boolean contained = false;
1450                  for (Rect r : validRegions) {
1451                      if (r.contains(currentRect)) {
1452                          contained = true;
1453                          break;
1454                      }
1455                  }
1456                  validRegions.push(currentRect);
1457                  double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1458                          + Math.pow(cellXY[1] - pixelY, 2));
1459  
1460                  if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1461                          currentRect.contains(bestRect)) {
1462                      bestDistance = distance;
1463                      bestXY[0] = x;
1464                      bestXY[1] = y;
1465                      if (resultSpan != null) {
1466                          resultSpan[0] = xSize;
1467                          resultSpan[1] = ySize;
1468                      }
1469                      bestRect.set(currentRect);
1470                  }
1471              }
1472          }
1473          // re-mark space taken by ignoreView as occupied
1474          markCellsAsOccupiedForView(ignoreView, occupied);
1475  
1476          // Return -1, -1 if no suitable location found
1477          if (bestDistance == Double.MAX_VALUE) {
1478              bestXY[0] = -1;
1479              bestXY[1] = -1;
1480          }
1481          recycleTempRects(validRegions);
1482          return bestXY;
1483      }
1484  
1485       /**
1486       * Find a vacant area that will fit the given bounds nearest the requested
1487       * cell location, and will also weigh in a suggested direction vector of the
1488       * desired location. This method computers distance based on unit grid distances,
1489       * not pixel distances.
1490       *
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1491 -     * @param cellX The X cell nearest to which you want to search for a vacant area.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1492 -     * @param cellY The Y cell nearest which you want to search for a vacant area.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1493 +     * @param pixelX The X location at which you want to search for a vacant area.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1494 +     * @param pixelY The Y location at which you want to search for a vacant area.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1495 +     * @param minSpanX The minimum horizontal span required</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1496 +     * @param minSpanY The minimum vertical span required</span>
1497       * @param spanX Horizontal span of the object.
1498       * @param spanY Vertical span of the object.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1499 -     * @param direction The favored direction in which the views should move from x, y</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1500 -     * @param exactDirectionOnly If this parameter is true, then only solutions where the direction</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1501 -     *        matches exactly. Otherwise we find the best matching direction.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1502 -     * @param occoupied The array which represents which cells in the CellLayout are occupied</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1503 -     * @param blockOccupied The array which represents which cells in the specified block (cellX,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1504 -     *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1505 +     * @param ignoreOccupied If true, the result can be an occupied cell</span>
1506       * @param result Array in which to place the result, or null (in which case a new array will
1507       *        be allocated)
1508       * @return The X, Y cell of a vacant area that can contain this object,
1509       *         nearest the requested location.
1510       */
1511      private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1512 -            boolean[][] occupied, boolean blockOccupied[][], int[] result) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1513 +            boolean[][] occupied, int[] result) {</span>
1514          // Keep track of best-scoring drop area
1515          final int[] bestXY = result != null ? result : new int[2];
1516          float bestDistance = Float.MAX_VALUE;
1517          int bestDirectionScore = Integer.MIN_VALUE;
1518  
1519          final int countX = mCountX;
1520          final int countY = mCountY;
1521  
1522          for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1523              inner:
1524              for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1525                  // First, let&#x27;s see if this thing fits anywhere
1526                  for (int i = 0; i &lt; spanX; i++) {
1527                      for (int j = 0; j &lt; spanY; j++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1528 -                        if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1529 +                        if (occupied[x + i][y + j]) {</span>
1530                              continue inner;
1531                          }
1532                      }
1533                  }
1534  
1535                  float distance = (float)
1536                          Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1537                  int[] curDirection = mTmpPoint;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1538 -                computeDirectionVector(x - cellX, y - cellY, curDirection);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1539 -                // The direction score is just the dot product of the two candidate direction</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1540 -                // and that passed in.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1541 +                computeDirectionVector(cellX, cellY, x, y, curDirection);</span>
1542                  int curDirectionScore = direction[0] * curDirection[0] +
1543                          direction[1] * curDirection[1];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1544 -                boolean exactDirectionOnly = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1545 -                boolean directionMatches = direction[0] == curDirection[0] &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1546 -                        direction[0] == curDirection[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1547 -                if ((directionMatches || !exactDirectionOnly) &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1548 -                        Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1549 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1550 +                if (Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,</span>
1551                          bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1552                      bestDistance = distance;
1553                      bestDirectionScore = curDirectionScore;
1554                      bestXY[0] = x;
1555                      bestXY[1] = y;
1556                  }
1557              }
1558          }
1559  
1560          // Return -1, -1 if no suitable location found
1561          if (bestDistance == Float.MAX_VALUE) {
1562              bestXY[0] = -1;
1563              bestXY[1] = -1;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1564 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1565 -        return bestXY;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1566 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1567 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1568 -    private int[] findNearestAreaInDirection(int cellX, int cellY, int spanX, int spanY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1569 -            int[] direction,boolean[][] occupied,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1570 -            boolean blockOccupied[][], int[] result) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1571 -        // Keep track of best-scoring drop area</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1572 -        final int[] bestXY = result != null ? result : new int[2];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1573 -        bestXY[0] = -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1574 -        bestXY[1] = -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1575 -        float bestDistance = Float.MAX_VALUE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1576 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1577 -        // We use this to march in a single direction</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1578 -        if (direction[0] != 0 &amp;&amp; direction[1] != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1579 -            return bestXY;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1580 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1581 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1582 -        // This will only incrememnet one of x or y based on the assertion above</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1583 -        int x = cellX + direction[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1584 -        int y = cellY + direction[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1585 -        while (x &gt;= 0 &amp;&amp; x + spanX &lt;= mCountX &amp;&amp; y &gt;= 0 &amp;&amp; y + spanY &lt;= mCountY) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1586 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1587 -            boolean fail = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1588 -            for (int i = 0; i &lt; spanX; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1589 -                for (int j = 0; j &lt; spanY; j++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1590 -                    if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1591 -                        fail = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1592 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1593 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1594 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1595 -            if (!fail) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1596 -                float distance = (float)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1597 -                        Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1598 -                if (Float.compare(distance,  bestDistance) &lt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1599 -                    bestDistance = distance;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1600 -                    bestXY[0] = x;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1601 -                    bestXY[1] = y;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1602 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1603 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1604 -            x += direction[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1605 -            y += direction[1];</span>
1606          }
1607          return bestXY;
1608      }
1609  
1610      private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1611              int[] direction) {
1612          LayoutParams lp = (LayoutParams) v.getLayoutParams();
1613          boolean success = false;
1614          markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1615                  lp.cellVSpan, mTmpOccupied, false);
1616          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1617  
1618          findNearestArea(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1619 -                direction, mTmpOccupied, null, mTempLocation);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1620 +                direction, mTmpOccupied, mTempLocation);</span>
1621  
1622          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1623              lp.tmpCellX = mTempLocation[0];
1624              lp.tmpCellY = mTempLocation[1];
1625              success = true;
1626  
1627          }
1628          markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1629                  lp.cellVSpan, mTmpOccupied, true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1630 -        return success;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1631 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1632 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1633 -    // This method looks in the specified direction to see if there is an additional view</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1634 -    // immediately adjecent in that direction</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1635 -    private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1636 -            boolean[][] occupied) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1637 -        boolean found = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1638 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1639 -        int childCount = mChildren.getChildCount();</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1640 -        Rect r0 = new Rect(boundingRect);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1641 -        Rect r1 = new Rect();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1642 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1643 -        int deltaX = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1644 -        int deltaY = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1645 -        if (direction[1] &lt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1646 -            r0.set(r0.left, r0.top - 1, r0.right, r0.bottom);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1647 -            deltaY = -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1648 -        } else if (direction[1] &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1649 -            r0.set(r0.left, r0.top, r0.right, r0.bottom + 1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1650 -            deltaY = 1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1651 -        } else if (direction[0] &lt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1652 -            r0.set(r0.left - 1, r0.top, r0.right, r0.bottom);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1653 -            deltaX = -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1654 -        } else if (direction[0] &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1655 -            r0.set(r0.left, r0.top, r0.right + 1, r0.bottom);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1656 -            deltaX = 1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1657 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1658 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1659 -        for (int i = 0; i &lt; childCount; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1660 -            View child = mChildren.getChildAt(i);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1661 -            if (views.contains(child)) continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1662 -            LayoutParams lp = (LayoutParams) child.getLayoutParams();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1663 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1664 -            r1.set(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1665 -            if (Rect.intersects(r0, r1)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1666 -                if (!lp.canReorder) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1667 -                    return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1668 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1669 -                boolean pushed = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1670 -                for (int x = lp.tmpCellX; x &lt; lp.tmpCellX + lp.cellHSpan; x++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1671 -                    for (int y = lp.tmpCellY; y &lt; lp.tmpCellY + lp.cellVSpan; y++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1672 -                        boolean inBounds = x - deltaX &gt;= 0 &amp;&amp; x -deltaX &lt; mCountX</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1673 -                                &amp;&amp; y - deltaY &gt;= 0 &amp;&amp; y - deltaY &lt; mCountY;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1674 -                        if (inBounds &amp;&amp; occupied[x - deltaX][y - deltaY]) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1675 -                            pushed = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1676 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1677 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1678 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1679 -                if (pushed) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1680 -                    views.add(child);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1681 -                    boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1682 -                            lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1683 -                    found = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1684 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1685 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1686 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1687 -        return found;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1688 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1689 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1690 -    private boolean pushViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1691 -            int[] direction) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1692 -        if (views.size() == 0) return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1693 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1694 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1695 -        boolean success = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1696 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1697 -        // We construct a rect which represents the entire group of views</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1698 -        Rect boundingRect = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1699 -        for (View v: views) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1700 -            LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1701 -            if (boundingRect == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1702 -                boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1703 -                        lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1704 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1705 -                boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1706 -                        lp.tmpCellY + lp.cellVSpan);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1707 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1708 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1709 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1710 -        ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) views.clone();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1711 -        while (addViewInDirection(dup, boundingRect, direction, mTmpOccupied)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1712 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1713 -        for (View v: dup) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1714 -            LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1715 -            markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1716 -                    lp.cellVSpan, mTmpOccupied, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1717 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1718 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1719 -        boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1720 -        int top = boundingRect.top;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1721 -        int left = boundingRect.left;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1722 -        for (View v: dup) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1723 -            LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1724 -            markCellsForView(lp.tmpCellX - left, lp.tmpCellY - top, lp.cellHSpan,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1725 -                    lp.cellVSpan, blockOccupied, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1726 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1727 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1728 -        markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1729 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1730 -        findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1731 -                boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1732 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1733 -        int deltaX = mTempLocation[0] - boundingRect.left;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1734 -        int deltaY = mTempLocation[1] - boundingRect.top;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1735 -        if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1736 -            for (View v: dup) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1737 -                LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1738 -                lp.tmpCellX += deltaX;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1739 -                lp.tmpCellY += deltaY;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1740 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1741 -            success = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1742 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1743 -        for (View v: dup) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1744 -            LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1745 -            markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1746 -                    lp.cellVSpan, mTmpOccupied, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1747 -        }</span>
1748          return success;
1749      }
1750  
1751      private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1752              int[] direction) {
1753          if (views.size() == 0) return true;
1754          boolean success = false;
1755  
1756          // We construct a rect which represents the entire group of views
1757          Rect boundingRect = null;
1758          for (View v: views) {
1759              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1760              markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1761                      lp.cellVSpan, mTmpOccupied, false);
1762              if (boundingRect == null) {
1763                  boundingRect = new Rect(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1764                          lp.tmpCellY + lp.cellVSpan);
1765              } else {
1766                  boundingRect.union(lp.tmpCellX, lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,
1767                          lp.tmpCellY + lp.cellVSpan);
1768              }
1769          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1770 -        boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1771 -        int top = boundingRect.top;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1772 -        int left = boundingRect.left;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1773 -        for (View v: views) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1774 -            LayoutParams lp = (LayoutParams) v.getLayoutParams();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1775 -            markCellsForView(lp.tmpCellX - left, lp.tmpCellY - top, lp.cellHSpan,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1776 -                    lp.cellVSpan, blockOccupied, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1777 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1778 -</span>
1779          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1780  
1781          // TODO: this bounding rect may not be completely filled, lets be more precise about this
1782          // check.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1783 -        findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1784 -                boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1785 +        findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(), boundingRect.height(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1786 +                direction, mTmpOccupied, mTempLocation);</span>
1787  
1788          int deltaX = mTempLocation[0] - boundingRect.left;
1789          int deltaY = mTempLocation[1] - boundingRect.top;
1790          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1791              for (View v: views) {
1792                  LayoutParams lp = (LayoutParams) v.getLayoutParams();
1793                  lp.tmpCellX += deltaX;
1794                  lp.tmpCellY += deltaY;
1795              }
1796              success = true;
1797          }
1798          for (View v: views) {
1799              LayoutParams lp = (LayoutParams) v.getLayoutParams();
1800              markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan,
1801                      lp.cellVSpan, mTmpOccupied, true);
1802          }
1803          return success;
1804      }
1805  
1806      private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1807          markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1808      }
1809  
1810      private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1811              View ignoreView) {
1812          mIntersectingViews.clear();
1813  
1814          mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1815 +        markCellsForRect(mOccupiedRect, mTmpOccupied, true);</span>
1816  
1817          if (ignoreView != null) {
1818              LayoutParams lp = (LayoutParams) ignoreView.getLayoutParams();
1819              lp.tmpCellX = cellX;
1820              lp.tmpCellY = cellY;
1821          }
1822  
1823          int childCount = mChildren.getChildCount();

1824          Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1825          Rect r1 = new Rect();
1826          for (int i = 0; i &lt; childCount; i++) {
1827              View child = mChildren.getChildAt(i);

1828              if (child == ignoreView) continue;
1829              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1830              r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
1831              if (Rect.intersects(r0, r1)) {
1832                  if (!lp.canReorder) {
1833                      return false;
1834                  }
1835                  mIntersectingViews.add(child);
1836              }
1837          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1838 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1839 -        if (pushViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1840 -            return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1841 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1842 -        // Try the opposite direction</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1843 -        direction[0] *= -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1844 -        direction[1] *= -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1845 -        if (pushViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1846 -            return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1847 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1848 -        // Switch the direction back</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1849 -        direction[0] *= -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1850 -        direction[1] *= -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1851 -</span>
1852          // First we try moving the views as a block
1853          if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction)) {
1854              return true;
1855          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1856 -</span>
1857          // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1858          for (View v : mIntersectingViews) {
1859              if (!addViewToTempLocation(v, mOccupiedRect, direction)) {
1860                  return false;
1861              }
1862          }
1863          return true;
1864      }
1865  
1866      /*
1867       * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1868       * the provided point and the provided cell
1869       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1870 -    private void computeDirectionVector(float deltaX, float deltaY, int[] result) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1871 +    private void computeDirectionVector(int x0, int y0, int x1, int y1, int[] result) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1872 +        int deltaX = x1 - x0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1873 +        int deltaY = y1 - y0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1874 +</span>
1875          double angle = Math.atan(((float) deltaY) / deltaX);
1876  
1877          result[0] = 0;
1878          result[1] = 0;
1879          if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1880              result[0] = (int) Math.signum(deltaX);
1881          }
1882          if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1883              result[1] = (int) Math.signum(deltaY);
1884          }
1885      }
1886  
1887      ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1888              int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1889          // This creates a copy of the current occupied array, omitting the current view being
1890          // dragged
1891          resetTempLayoutToCurrent(dragView);
1892  
1893          // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1894          // nothing in its way.
1895          int result[] = new int[2];
1896          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1897  
1898          boolean success = false;
1899          // First we try the exact nearest position of the item being dragged,
1900          // we will then want to try to move this around to other neighbouring positions
1901          success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView);
1902  
1903          if (!success) {
1904              // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1905              // x, then 1 in y etc.
1906              if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1907                  return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1908                          dragView, false, solution);
1909              } else if (spanY &gt; minSpanY) {
1910                  return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1911                          dragView, true, solution);
1912              }
1913              solution.isSolution = false;
1914          } else {
1915              solution.isSolution = true;
1916              solution.dragViewX = result[0];
1917              solution.dragViewY = result[1];
1918              solution.dragViewSpanX = spanX;
1919              solution.dragViewSpanY = spanY;
1920              copyCurrentStateToSolution(solution, true);
1921          }
1922          return solution;
1923      }
1924  
1925      private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1926          int childCount = mChildren.getChildCount();

1927          for (int i = 0; i &lt; childCount; i++) {
1928              View child = mChildren.getChildAt(i);

1929              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1930              Point p;
1931              if (temp) {
1932                  p = new Point(lp.tmpCellX, lp.tmpCellY);
1933              } else {
1934                  p = new Point(lp.cellX, lp.cellY);
1935              }
1936              solution.map.put(child, p);
1937          }
1938      }
1939  
1940      private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1941          for (int i = 0; i &lt; mCountX; i++) {
1942              for (int j = 0; j &lt; mCountY; j++) {
1943                  mTmpOccupied[i][j] = false;
1944              }
1945          }
1946  
1947          int childCount = mChildren.getChildCount();

1948          for (int i = 0; i &lt; childCount; i++) {
1949              View child = mChildren.getChildAt(i);

1950              if (child == dragView) continue;
1951              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1952              Point p = solution.map.get(child);
1953              if (p != null) {
1954                  lp.tmpCellX = p.x;
1955                  lp.tmpCellY = p.y;
1956                  markCellsForView(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan,
1957                          mTmpOccupied, true);
1958              }
1959          }
1960          markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1961                  solution.dragViewSpanY, mTmpOccupied, true);
1962      }
1963  
1964      private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
1965              commitDragView) {
1966  
1967          boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
1968          for (int i = 0; i &lt; mCountX; i++) {
1969              for (int j = 0; j &lt; mCountY; j++) {
1970                  occupied[i][j] = false;
1971              }
1972          }
1973  
1974          int childCount = mChildren.getChildCount();

1975          for (int i = 0; i &lt; childCount; i++) {
1976              View child = mChildren.getChildAt(i);

1977              if (child == dragView) continue;
1978              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1979              Point p = solution.map.get(child);
1980              if (p != null) {
1981                  if (lp.cellX != p.x || lp.cellY != p.y) {
1982                      animateChildToPosition(child, p.x, p.y, 150, 0, DESTRUCTIVE_REORDER, false);
1983                  }
1984                  markCellsForView(p.x, p.y, lp.cellHSpan, lp.cellVSpan, occupied, true);
1985              }
1986          }
1987          if (commitDragView) {
1988              markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1989                      solution.dragViewSpanY, occupied, true);
1990          }
1991      }
1992  
1993      private void commitTempPlacement() {
1994          for (int i = 0; i &lt; mCountX; i++) {
1995              for (int j = 0; j &lt; mCountY; j++) {
1996                  mOccupied[i][j] = mTmpOccupied[i][j];
1997              }
1998          }
1999          int childCount = mChildren.getChildCount();

2000          for (int i = 0; i &lt; childCount; i++) {
2001              LayoutParams lp = (LayoutParams) mChildren.getChildAt(i).getLayoutParams();

2002              lp.cellX = lp.tmpCellX;
2003              lp.cellY = lp.tmpCellY;
2004          }
2005      }
2006  
2007      public void setUseTempCoords(boolean useTempCoords) {
2008          int childCount = mChildren.getChildCount();

2009          for (int i = 0; i &lt; childCount; i++) {
2010              LayoutParams lp = (LayoutParams) mChildren.getChildAt(i).getLayoutParams();

2011              lp.useTmpCoords = useTempCoords;
2012          }
2013      }
2014  
2015      private void resetTempLayoutToCurrent(View ignoreView) {
2016          for (int i = 0; i &lt; mCountX; i++) {
2017              for (int j = 0; j &lt; mCountY; j++) {
2018                  mTmpOccupied[i][j] = mOccupied[i][j];
2019              }
2020          }
2021          int childCount = mChildren.getChildCount();

2022          for (int i = 0; i &lt; childCount; i++) {
2023              View child = mChildren.getChildAt(i);

2024              if (child == ignoreView) continue;
2025              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2026              lp.tmpCellX = lp.cellX;
2027              lp.tmpCellY = lp.cellY;
2028          }
2029      }
2030  
2031      ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
2032              int spanX, int spanY, View dragView, ItemConfiguration solution) {
2033          int[] result = new int[2];
2034          int[] resultSpan = new int[2];
2035          findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
2036                  resultSpan);
2037          if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
2038              copyCurrentStateToSolution(solution, false);
2039              solution.dragViewX = result[0];
2040              solution.dragViewY = result[1];
2041              solution.dragViewSpanX = resultSpan[0];
2042              solution.dragViewSpanY = resultSpan[1];
2043              solution.isSolution = true;
2044          } else {
2045              solution.isSolution = false;
2046          }
2047          return solution;
2048      }
2049  
2050      public void prepareChildForDrag(View child) {
2051          markCellsAsUnoccupiedForView(child);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2052 +        LayoutParams lp = (LayoutParams) child.getLayoutParams();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2053 +        lp.cellX = -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2054 +        lp.cellY = -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2055 +</span>
2056      }
2057  
2058      int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
2059              View dragView, int[] result, int resultSpan[], int mode) {
2060  
2061          // First we determine if things have moved enough to cause a different layout
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2062 -        result = findNearestArea(pixelX, pixelY, spanX, spanY, result);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2063 +        result = findNearestArea(pixelX, pixelY, 1, 1, result);</span>
2064  
2065          if (resultSpan == null) {
2066              resultSpan = new int[2];
2067          }
2068  
2069          // We attempt the first algorithm
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2070 -        regionToCenterPoint(result[0], result[1], spanX, spanY, mTmpPoint);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2071 -        computeDirectionVector((mTmpPoint[0] - pixelX) / spanX, (mTmpPoint[1] - pixelY) / spanY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2072 -                mDirectionVector);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2073 +        cellToCenterPoint(result[0], result[1], mTmpPoint);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2074 +        computeDirectionVector(pixelX, pixelY, mTmpPoint[0], mTmpPoint[1], mDirectionVector);</span>
2075          ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
2076                   spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
2077  
2078          // We attempt the approach which doesn&#x27;t shuffle views at all
2079          ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
2080                  minSpanY, spanX, spanY, dragView, new ItemConfiguration());
2081  
2082          ItemConfiguration finalSolution = null;
2083          if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
2084              finalSolution = swapSolution;
2085          } else if (noShuffleSolution.isSolution) {
2086              finalSolution = noShuffleSolution;
2087          }
2088  
2089          boolean foundSolution = true;
2090          if (!DESTRUCTIVE_REORDER) {
2091              setUseTempCoords(true);
2092          }
2093  
2094          if (finalSolution != null) {
2095              result[0] = finalSolution.dragViewX;
2096              result[1] = finalSolution.dragViewY;
2097              resultSpan[0] = finalSolution.dragViewSpanX;
2098              resultSpan[1] = finalSolution.dragViewSpanY;
2099  
2100              // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2101              // committing anything or animating anything as we just want to determine if a solution
2102              // exists
2103              if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2104                  if (!DESTRUCTIVE_REORDER) {
2105                      copySolutionToTempState(finalSolution, dragView);
2106                  }
2107                  setItemPlacementDirty(true);
2108                  animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
2109  
2110                  if (!DESTRUCTIVE_REORDER &amp;&amp; mode == MODE_ON_DROP) {
2111                      commitTempPlacement();
2112                  }
2113              }
2114          } else {
2115              foundSolution = false;
2116              result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
2117          }
2118  
2119          if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
2120              setUseTempCoords(false);
2121          }
2122          boolean[][] occupied = mOccupied;
2123  
2124          mChildren.requestLayout();

2125          return result;
2126      }
2127  
2128      public boolean isItemPlacementDirty() {
2129          return mItemLocationsDirty;
2130      }
2131  
2132      public void setItemPlacementDirty(boolean dirty) {
2133          mItemLocationsDirty = dirty;
2134      }
2135  
2136      private class ItemConfiguration {
2137          HashMap&lt;View, Point&gt; map = new HashMap&lt;View, Point&gt;();
2138          boolean isSolution = false;
2139          int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
2140  
2141          int area() {
2142              return dragViewSpanX * dragViewSpanY;
2143          }
2144          void clear() {
2145              map.clear();
2146              isSolution = false;
2147          }
2148      }
2149  
2150      /**
2151       * Find a vacant area that will fit the given bounds nearest the requested
2152       * cell location. Uses Euclidean distance to score multiple vacant areas.
2153       *
2154       * @param pixelX The X location at which you want to search for a vacant area.
2155       * @param pixelY The Y location at which you want to search for a vacant area.
2156       * @param spanX Horizontal span of the object.
2157       * @param spanY Vertical span of the object.
2158       * @param ignoreView Considers space occupied by this view as unoccupied
2159       * @param result Previously returned value to possibly recycle.
2160       * @return The X, Y cell of a vacant area that can contain this object,
2161       *         nearest the requested location.
2162       */
2163      int[] findNearestVacantArea(
2164              int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
2165          return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
2166      }
2167  
2168      /**
2169       * Find a vacant area that will fit the given bounds nearest the requested
2170       * cell location. Uses Euclidean distance to score multiple vacant areas.
2171       *
2172       * @param pixelX The X location at which you want to search for a vacant area.
2173       * @param pixelY The Y location at which you want to search for a vacant area.
2174       * @param minSpanX The minimum horizontal span required
2175       * @param minSpanY The minimum vertical span required
2176       * @param spanX Horizontal span of the object.
2177       * @param spanY Vertical span of the object.
2178       * @param ignoreView Considers space occupied by this view as unoccupied
2179       * @param result Previously returned value to possibly recycle.
2180       * @return The X, Y cell of a vacant area that can contain this object,
2181       *         nearest the requested location.
2182       */
2183      int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2184              int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2185          return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2186                  result, resultSpan, mOccupied);
2187      }
2188  
2189      /**
2190       * Find a starting cell position that will fit the given bounds nearest the requested
2191       * cell location. Uses Euclidean distance to score multiple vacant areas.
2192       *
2193       * @param pixelX The X location at which you want to search for a vacant area.
2194       * @param pixelY The Y location at which you want to search for a vacant area.
2195       * @param spanX Horizontal span of the object.
2196       * @param spanY Vertical span of the object.
2197       * @param ignoreView Considers space occupied by this view as unoccupied
2198       * @param result Previously returned value to possibly recycle.
2199       * @return The X, Y cell of a vacant area that can contain this object,
2200       *         nearest the requested location.
2201       */
2202      int[] findNearestArea(
2203              int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2204          return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2205      }
2206  
2207      boolean existsEmptyCell() {
2208          return findCellForSpan(null, 1, 1);
2209      }
2210  
2211      /**
2212       * Finds the upper-left coordinate of the first rectangle in the grid that can
2213       * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2214       * then this method will only return coordinates for rectangles that contain the cell
2215       * (intersectX, intersectY)
2216       *
2217       * @param cellXY The array that will contain the position of a vacant cell if such a cell
2218       *               can be found.
2219       * @param spanX The horizontal span of the cell we want to find.
2220       * @param spanY The vertical span of the cell we want to find.
2221       *
2222       * @return True if a vacant cell of the specified dimension was found, false otherwise.
2223       */
2224      boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2225          return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2226      }
2227  
2228      /**
2229       * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2230       *
2231       * @param cellXY The array that will contain the position of a vacant cell if such a cell
2232       *               can be found.
2233       * @param spanX The horizontal span of the cell we want to find.
2234       * @param spanY The vertical span of the cell we want to find.
2235       * @param ignoreView The home screen item we should treat as not occupying any space
2236       * @return
2237       */
2238      boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2239          return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2240                  ignoreView, mOccupied);
2241      }
2242  
2243      /**
2244       * Like above, but if intersectX and intersectY are not -1, then this method will try to
2245       * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2246       *
2247       * @param spanX The horizontal span of the cell we want to find.
2248       * @param spanY The vertical span of the cell we want to find.
2249       * @param ignoreView The home screen item we should treat as not occupying any space
2250       * @param intersectX The X coordinate of the cell that we should try to overlap
2251       * @param intersectX The Y coordinate of the cell that we should try to overlap
2252       *
2253       * @return True if a vacant cell of the specified dimension was found, false otherwise.
2254       */
2255      boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2256              int intersectX, int intersectY) {
2257          return findCellForSpanThatIntersectsIgnoring(
2258                  cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2259      }
2260  
2261      /**
2262       * The superset of the above two methods
2263       */
2264      boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2265              int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2266          // mark space take by ignoreView as available (method checks if ignoreView is null)
2267          markCellsAsUnoccupiedForView(ignoreView, occupied);
2268  
2269          boolean foundCell = false;
2270          while (true) {
2271              int startX = 0;
2272              if (intersectX &gt;= 0) {
2273                  startX = Math.max(startX, intersectX - (spanX - 1));
2274              }
2275              int endX = mCountX - (spanX - 1);
2276              if (intersectX &gt;= 0) {
2277                  endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2278              }
2279              int startY = 0;
2280              if (intersectY &gt;= 0) {
2281                  startY = Math.max(startY, intersectY - (spanY - 1));
2282              }
2283              int endY = mCountY - (spanY - 1);
2284              if (intersectY &gt;= 0) {
2285                  endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2286              }
2287  
2288              for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2289                  inner:
2290                  for (int x = startX; x &lt; endX; x++) {
2291                      for (int i = 0; i &lt; spanX; i++) {
2292                          for (int j = 0; j &lt; spanY; j++) {
2293                              if (occupied[x + i][y + j]) {
2294                                  // small optimization: we can skip to after the column we just found
2295                                  // an occupied cell
2296                                  x += i;
2297                                  continue inner;
2298                              }
2299                          }
2300                      }
2301                      if (cellXY != null) {
2302                          cellXY[0] = x;
2303                          cellXY[1] = y;
2304                      }
2305                      foundCell = true;
2306                      break;
2307                  }
2308              }
2309              if (intersectX == -1 &amp;&amp; intersectY == -1) {
2310                  break;
2311              } else {
2312                  // if we failed to find anything, try again but without any requirements of
2313                  // intersecting
2314                  intersectX = -1;
2315                  intersectY = -1;
2316                  continue;
2317              }
2318          }
2319  
2320          // re-mark space taken by ignoreView as occupied
2321          markCellsAsOccupiedForView(ignoreView, occupied);
2322          return foundCell;
2323      }
2324  
2325      /**
2326       * A drag event has begun over this layout.
2327       * It may have begun over this layout (in which case onDragChild is called first),
2328       * or it may have begun on another layout.
2329       */
2330      void onDragEnter() {
2331          if (!mDragging) {
2332              // Fade in the drag indicators
2333              if (mCrosshairsAnimator != null) {
2334                  mCrosshairsAnimator.animateIn();
2335              }
2336          }
2337          mDragging = true;
2338      }
2339  
2340      /**
2341       * Called when drag has left this CellLayout or has been completed (successfully or not)
2342       */
2343      void onDragExit() {
2344          // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2345          // item to this layout via the customize drawer.
2346          // Guard against that case.
2347          if (mDragging) {
2348              mDragging = false;
2349  
2350              // Fade out the drag indicators
2351              if (mCrosshairsAnimator != null) {
2352                  mCrosshairsAnimator.animateOut();
2353              }
2354          }
2355  
2356          // Invalidate the drag data
2357          mDragCell[0] = mDragCell[1] = -1;
2358          mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2359          mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2360  
2361          setIsDragOverlapping(false);
2362      }
2363  
2364      /**
2365       * Mark a child as having been dropped.
2366       * At the beginning of the drag operation, the child may have been on another
2367       * screen, but it is re-parented before this method is called.
2368       *
2369       * @param child The child that is being dropped
2370       */
2371      void onDropChild(View child) {
2372          if (child != null) {
2373              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2374              lp.dropped = true;
2375              child.requestLayout();
2376          }
2377      }
2378  
2379      /**
2380       * Computes a bounding rectangle for a range of cells
2381       *
2382       * @param cellX X coordinate of upper left corner expressed as a cell position
2383       * @param cellY Y coordinate of upper left corner expressed as a cell position
2384       * @param cellHSpan Width in cells
2385       * @param cellVSpan Height in cells
2386       * @param resultRect Rect into which to put the results
2387       */
2388      public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2389          final int cellWidth = mCellWidth;
2390          final int cellHeight = mCellHeight;
2391          final int widthGap = mWidthGap;
2392          final int heightGap = mHeightGap;
2393  
2394          final int hStartPadding = getPaddingLeft();
2395          final int vStartPadding = getPaddingTop();
2396  
2397          int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2398          int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2399  
2400          int x = hStartPadding + cellX * (cellWidth + widthGap);
2401          int y = vStartPadding + cellY * (cellHeight + heightGap);
2402  
2403          resultRect.set(x, y, x + width, y + height);
2404      }
2405  
2406      /**
2407       * Computes the required horizontal and vertical cell spans to always
2408       * fit the given rectangle.
2409       *
2410       * @param width Width in pixels
2411       * @param height Height in pixels
2412       * @param result An array of length 2 in which to store the result (may be null).
2413       */
2414      public int[] rectToCell(int width, int height, int[] result) {
2415          return rectToCell(getResources(), width, height, result);
2416      }
2417  
2418      public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2419          // Always assume we&#x27;re working with the smallest span to make sure we
2420          // reserve enough space in both orientations.
2421          int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2422          int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2423          int smallerSize = Math.min(actualWidth, actualHeight);
2424  
2425          // Always round up to next largest cell
2426          int spanX = (int) Math.ceil(width / (float) smallerSize);
2427          int spanY = (int) Math.ceil(height / (float) smallerSize);
2428  
2429          if (result == null) {
2430              return new int[] { spanX, spanY };
2431          }
2432          result[0] = spanX;
2433          result[1] = spanY;
2434          return result;
2435      }
2436  
2437      public int[] cellSpansToSize(int hSpans, int vSpans) {
2438          int[] size = new int[2];
2439          size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2440          size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2441          return size;
2442      }
2443  
2444      /**
2445       * Calculate the grid spans needed to fit given item
2446       */
2447      public void calculateSpans(ItemInfo info) {
2448          final int minWidth;
2449          final int minHeight;
2450  
2451          if (info instanceof LauncherAppWidgetInfo) {
2452              minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2453              minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2454          } else if (info instanceof PendingAddWidgetInfo) {
2455              minWidth = ((PendingAddWidgetInfo) info).minWidth;
2456              minHeight = ((PendingAddWidgetInfo) info).minHeight;
2457          } else {
2458              // It&#x27;s not a widget, so it must be 1x1
2459              info.spanX = info.spanY = 1;
2460              return;
2461          }
2462          int[] spans = rectToCell(minWidth, minHeight, null);
2463          info.spanX = spans[0];
2464          info.spanY = spans[1];
2465      }
2466  
2467      /**
2468       * Find the first vacant cell, if there is one.
2469       *
2470       * @param vacant Holds the x and y coordinate of the vacant cell
2471       * @param spanX Horizontal cell span.
2472       * @param spanY Vertical cell span.
2473       *
2474       * @return True if a vacant cell was found
2475       */
2476      public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2477  
2478          return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2479      }
2480  
2481      static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2482              int xCount, int yCount, boolean[][] occupied) {
2483  
2484          for (int y = 0; y &lt; yCount; y++) {
2485              for (int x = 0; x &lt; xCount; x++) {
2486                  boolean available = !occupied[x][y];
2487  out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2488                      for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2489                          available = available &amp;&amp; !occupied[i][j];
2490                          if (!available) break out;
2491                      }
2492                  }
2493  
2494                  if (available) {
2495                      vacant[0] = x;
2496                      vacant[1] = y;
2497                      return true;
2498                  }
2499              }
2500          }
2501  
2502          return false;
2503      }
2504  
2505      private void clearOccupiedCells() {
2506          for (int x = 0; x &lt; mCountX; x++) {
2507              for (int y = 0; y &lt; mCountY; y++) {
2508                  mOccupied[x][y] = false;
2509              }
2510          }
2511      }
2512  
2513      /**
2514       * Given a view, determines how much that view can be expanded in all directions, in terms of
2515       * whether or not there are other items occupying adjacent cells. Used by the
2516       * AppWidgetResizeFrame to determine how the widget can be resized.
2517       */
2518      public void getExpandabilityArrayForView(View view, int[] expandability) {
2519          final LayoutParams lp = (LayoutParams) view.getLayoutParams();
2520          boolean flag;
2521  
2522          expandability[AppWidgetResizeFrame.LEFT] = 0;
2523          for (int x = lp.cellX - 1; x &gt;= 0; x--) {
2524              flag = false;
2525              for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2526                  if (mOccupied[x][y]) flag = true;
2527              }
2528              if (flag) break;
2529              expandability[AppWidgetResizeFrame.LEFT]++;
2530          }
2531  
2532          expandability[AppWidgetResizeFrame.TOP] = 0;
2533          for (int y = lp.cellY - 1; y &gt;= 0; y--) {
2534              flag = false;
2535              for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2536                  if (mOccupied[x][y]) flag = true;
2537              }
2538              if (flag) break;
2539              expandability[AppWidgetResizeFrame.TOP]++;
2540          }
2541  
2542          expandability[AppWidgetResizeFrame.RIGHT] = 0;
2543          for (int x = lp.cellX + lp.cellHSpan; x &lt; mCountX; x++) {
2544              flag = false;
2545              for (int y = lp.cellY; y &lt; lp.cellY + lp.cellVSpan; y++) {
2546                  if (mOccupied[x][y]) flag = true;
2547              }
2548              if (flag) break;
2549              expandability[AppWidgetResizeFrame.RIGHT]++;
2550          }
2551  
2552          expandability[AppWidgetResizeFrame.BOTTOM] = 0;
2553          for (int y = lp.cellY + lp.cellVSpan; y &lt; mCountY; y++) {
2554              flag = false;
2555              for (int x = lp.cellX; x &lt; lp.cellX + lp.cellHSpan; x++) {
2556                  if (mOccupied[x][y]) flag = true;
2557              }
2558              if (flag) break;
2559              expandability[AppWidgetResizeFrame.BOTTOM]++;
2560          }
2561      }
2562  
2563      public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2564          markCellsAsUnoccupiedForView(view);
2565          markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2566      }
2567  
2568      public void markCellsAsOccupiedForView(View view) {
2569          markCellsAsOccupiedForView(view, mOccupied);
2570      }
2571      public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2572          if (view == null || view.getParent() != mChildren) return;

2573          LayoutParams lp = (LayoutParams) view.getLayoutParams();
2574          markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2575      }
2576  
2577      public void markCellsAsUnoccupiedForView(View view) {
2578          markCellsAsUnoccupiedForView(view, mOccupied);
2579      }
2580      public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
2581          if (view == null || view.getParent() != mChildren) return;

2582          LayoutParams lp = (LayoutParams) view.getLayoutParams();
2583          markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2584      }
2585  
2586      private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2587              boolean value) {
2588          if (cellX &lt; 0 || cellY &lt; 0) return;
2589          for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2590              for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2591                  occupied[x][y] = value;
2592              }
2593          }
2594      }
2595  
2596      public int getDesiredWidth() {
2597          return mPaddingLeft + mPaddingRight + (mCountX * mCellWidth) +
2598                  (Math.max((mCountX - 1), 0) * mWidthGap);
2599      }
2600  
2601      public int getDesiredHeight()  {
2602          return mPaddingTop + mPaddingBottom + (mCountY * mCellHeight) +
2603                  (Math.max((mCountY - 1), 0) * mHeightGap);
2604      }
2605  
2606      public boolean isOccupied(int x, int y) {
2607          if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2608              return mOccupied[x][y];
2609          } else {
2610              throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2611          }
2612      }
2613  
2614      @Override
2615      public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2616          return new CellLayout.LayoutParams(getContext(), attrs);
2617      }
2618  
2619      @Override
2620      protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2621          return p instanceof CellLayout.LayoutParams;
2622      }
2623  
2624      @Override
2625      protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2626          return new CellLayout.LayoutParams(p);
2627      }
2628  
2629      public static class CellLayoutAnimationController extends LayoutAnimationController {
2630          public CellLayoutAnimationController(Animation animation, float delay) {
2631              super(animation, delay);
2632          }
2633  
2634          @Override
2635          protected long getDelayForView(View view) {
2636              return (int) (Math.random() * 150);
2637          }
2638      }
2639  
2640      public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2641          /**
2642           * Horizontal location of the item in the grid.
2643           */
2644          @ViewDebug.ExportedProperty
2645          public int cellX;
2646  
2647          /**
2648           * Vertical location of the item in the grid.
2649           */
2650          @ViewDebug.ExportedProperty
2651          public int cellY;
2652  
2653          /**
2654           * Temporary horizontal location of the item in the grid during reorder
2655           */
2656          public int tmpCellX;
2657  
2658          /**
2659           * Temporary vertical location of the item in the grid during reorder
2660           */
2661          public int tmpCellY;
2662  
2663          /**
2664           * Indicates that the temporary coordinates should be used to layout the items
2665           */
2666          public boolean useTmpCoords;
2667  
2668          /**
2669           * Number of cells spanned horizontally by the item.
2670           */
2671          @ViewDebug.ExportedProperty
2672          public int cellHSpan;
2673  
2674          /**
2675           * Number of cells spanned vertically by the item.
2676           */
2677          @ViewDebug.ExportedProperty
2678          public int cellVSpan;
2679  
2680          /**
2681           * Indicates whether the item will set its x, y, width and height parameters freely,
2682           * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2683           */
2684          public boolean isLockedToGrid = true;
2685  
2686          /**
2687           * Indicates whether this item can be reordered. Always true except in the case of the
2688           * the AllApps button.
2689           */
2690          public boolean canReorder = true;
2691  
2692          // X coordinate of the view in the layout.
2693          @ViewDebug.ExportedProperty
2694          int x;
2695          // Y coordinate of the view in the layout.
2696          @ViewDebug.ExportedProperty
2697          int y;
2698  
2699          boolean dropped;
2700  
2701          public LayoutParams(Context c, AttributeSet attrs) {
2702              super(c, attrs);
2703              cellHSpan = 1;
2704              cellVSpan = 1;
2705          }
2706  
2707          public LayoutParams(ViewGroup.LayoutParams source) {
2708              super(source);
2709              cellHSpan = 1;
2710              cellVSpan = 1;
2711          }
2712  
2713          public LayoutParams(LayoutParams source) {
2714              super(source);
2715              this.cellX = source.cellX;
2716              this.cellY = source.cellY;
2717              this.cellHSpan = source.cellHSpan;
2718              this.cellVSpan = source.cellVSpan;
2719          }
2720  
2721          public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2722              super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
2723              this.cellX = cellX;
2724              this.cellY = cellY;
2725              this.cellHSpan = cellHSpan;
2726              this.cellVSpan = cellVSpan;
2727          }
2728  
2729          public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2730              if (isLockedToGrid) {
2731                  final int myCellHSpan = cellHSpan;
2732                  final int myCellVSpan = cellVSpan;
2733                  final int myCellX = useTmpCoords ? tmpCellX : cellX;
2734                  final int myCellY = useTmpCoords ? tmpCellY : cellY;
2735  
2736                  width = myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) -
2737                          leftMargin - rightMargin;
2738                  height = myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) -
2739                          topMargin - bottomMargin;
2740                  x = (int) (myCellX * (cellWidth + widthGap) + leftMargin);
2741                  y = (int) (myCellY * (cellHeight + heightGap) + topMargin);
2742              }
2743          }
2744  
2745          public String toString() {
2746              return &quot;(&quot; + this.cellX + &quot;, &quot; + this.cellY + &quot;)&quot;;
2747          }
2748  
2749          public void setWidth(int width) {
2750              this.width = width;
2751          }
2752  
2753          public int getWidth() {
2754              return width;
2755          }
2756  
2757          public void setHeight(int height) {
2758              this.height = height;
2759          }
2760  
2761          public int getHeight() {
2762              return height;
2763          }
2764  
2765          public void setX(int x) {
2766              this.x = x;
2767          }
2768  
2769          public int getX() {
2770              return x;
2771          }
2772  
2773          public void setY(int y) {
2774              this.y = y;
2775          }
2776  
2777          public int getY() {
2778              return y;
2779          }
2780      }
2781  
2782      // This class stores info for two purposes:
2783      // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
2784      //    its spanX, spanY, and the screen it is on
2785      // 2. When long clicking on an empty cell in a CellLayout, we save information about the
2786      //    cellX and cellY coordinates and which page was clicked. We then set this as a tag on
2787      //    the CellLayout that was long clicked
2788      static final class CellInfo {
2789          View cell;
2790          int cellX = -1;
2791          int cellY = -1;
2792          int spanX;
2793          int spanY;
2794          int screen;
2795          long container;
2796  
2797          @Override
2798          public String toString() {
2799              return &quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())
2800                      + &quot;, x=&quot; + cellX + &quot;, y=&quot; + cellY + &quot;]&quot;;
2801          }
2802      }
2803  
2804      public boolean lastDownOnOccupiedCell() {
2805          return mLastDownOnOccupiedCell;
2806      }
2807  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            