<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>60</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    60
                    <a href="59.html">prev</a>
                    <a href="61.html">next</a>
                    <a href="60_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_d5627551b8cb2c3f35852c56d01ad64d7bac1ab9_Simplenote/src/main/java/com/automattic/simplenote/widgets/SimplenoteEditText.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;d5627551b8cb2c3f35852c56d01ad64d7bac1ab9:Simplenote/src/main/java/com/automattic/simplenote/widgets/SimplenoteEditText.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;d5627551b8cb2c3f35852c56d01ad64d7bac1ab9^1:Simplenote/src/main/java/com/automattic/simplenote/widgets/SimplenoteEditText.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;d5627551b8cb2c3f35852c56d01ad64d7bac1ab9^2:Simplenote/src/main/java/com/automattic/simplenote/widgets/SimplenoteEditText.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;7bd4900c1a395918947a695f3621c2c6c01a3c87:Simplenote/src/main/java/com/automattic/simplenote/widgets/SimplenoteEditText.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[sbj]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote.widgets;
   2 
   3 import android.content.Context;
   4 import android.graphics.Rect;
   5 import android.graphics.drawable.Drawable;
   6 import android.os.Handler;
   7 import android.text.Editable;
   8 import android.text.Layout;
   9 import android.text.SpannableStringBuilder;
  10 import android.text.Spanned;
  11 import android.text.style.ImageSpan;
  12 import android.util.AttributeSet;
  13 import android.view.KeyEvent;
  14 import android.view.View;
  15 import android.widget.AdapterView;
  16 
  17 import androidx.appcompat.widget.AppCompatMultiAutoCompleteTextView;
  18 import androidx.core.content.ContextCompat;
  19 
  20 import com.automattic.simplenote.R;
  21 import com.automattic.simplenote.models.Note;
  22 import com.automattic.simplenote.utils.ChecklistUtils;
  23 import com.automattic.simplenote.utils.DisplayUtils;
  24 import com.automattic.simplenote.utils.DrawableUtils;
  25 import com.automattic.simplenote.utils.LinkTokenizer;
  26 import com.automattic.simplenote.utils.SimplenoteLinkify;
  27 import com.simperium.client.Bucket;
  28 
  29 import java.util.ArrayList;
  30 import java.util.List;
  31 import java.util.regex.Matcher;
  32 import java.util.regex.Pattern;
  33 
  34 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_ID;
  35 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  36 
<abbr title="  37 public class SimplenoteEditText extends AppCompatMultiAutoCompleteTextView implements AdapterView.OnItemClickListener {">  37 public class SimplenoteEditText extends AppCompatMultiAutoCompleteTextView implements AdapterView.OnItemCðŸ”µ</abbr>
<abbr title="  38     private static final Pattern INTERNOTE_LINK_PATTERN_EDIT = Pattern.compile(&quot;([^]]*)(]\\(&quot; + SIMPLENOTE_LINK_PREFIX + SIMPLENOTE_LINK_ID + &quot;\\))&quot;);">  38     private static final Pattern INTERNOTE_LINK_PATTERN_EDIT = Pattern.compile(&quot;([^]]*)(]\\(&quot; + SIMPLENOTðŸ”µ</abbr>
<abbr title="  39     private static final Pattern INTERNOTE_LINK_PATTERN_FULL = Pattern.compile(&quot;(?s)(.)*(\\[)&quot; + INTERNOTE_LINK_PATTERN_EDIT);">  39     private static final Pattern INTERNOTE_LINK_PATTERN_FULL = Pattern.compile(&quot;(?s)(.)*(\\[)&quot; + INTERNOTðŸ”µ</abbr>
  40     private static final int CHECKBOX_LENGTH = 2; // one ClickableSpan character + one space character
  41 
  42     private LinkTokenizer mTokenizer;
  43     private List&lt;OnSelectionChangedListener&gt; listeners;
  44     private OnCheckboxToggledListener mOnCheckboxToggledListener;
  45 
  46     @Override
  47     public boolean enoughToFilter() {
  48         String substringCursor = getText().toString().substring(getSelectionEnd());
  49         Matcher matcherEdit = INTERNOTE_LINK_PATTERN_EDIT.matcher(substringCursor);
  50 
  51         // When an internote link title is being edited, don&#x27;t show an autocomplete popup.
  52         if (matcherEdit.lookingAt()) {
  53             String substringEdit = substringCursor.substring(0, matcherEdit.end());
  54             Matcher matcherFull = INTERNOTE_LINK_PATTERN_FULL.matcher(substringEdit);
  55 
  56             if (!matcherFull.lookingAt()) {
  57                 return false;
  58             }
  59         }
  60 
  61         Editable text = getText();
  62         int end = getSelectionEnd();
  63 
  64         if (end &lt; 0) {
  65             return false;
  66         }
  67 
  68         int start = mTokenizer.findTokenStart(text, end);
  69         return start &gt; 0 &amp;&amp; end - start &gt;= 1;
  70     }
  71 
  72     public interface OnCheckboxToggledListener {
  73         void onCheckboxToggled();
  74     }
  75 
  76     public SimplenoteEditText(Context context) {
  77         super(context);
  78         listeners = new ArrayList&lt;&gt;();
  79 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  80 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  81         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  82     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  83 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  84     public SimplenoteEditText(Context context, AttributeSet attrs) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  85         super(context, attrs);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  86         listeners = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  87         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  88     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  89 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  90     public SimplenoteEditText(Context context, AttributeSet attrs, int defStyle) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  91         super(context, attrs, defStyle);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  92         listeners = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96     public void addOnSelectionChangedListener(OnSelectionChangedListener o) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97         listeners.add(o);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  98     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  99 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 100     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 101     protected void onSelectionChanged(int selStart, int selEnd) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 102         super.onSelectionChanged(selStart, selEnd);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103         if (listeners != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 104             for (OnSelectionChangedListener l : listeners)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 105                 l.onSelectionChanged(selStart, selEnd);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 106         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 107     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 109     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 110     public boolean onKeyPreIme(int keyCode, KeyEvent event) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111         if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112             clearFocus();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 114 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 115         return super.onKeyPreIme(keyCode, event);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 116     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 117 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 118     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 119     protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 120         if (focused) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121             setCursorVisible(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123 </span>
 124 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 125         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 126         setLinkTokenizer();</span>
 127 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 128     }
 129 
 130     public SimplenoteEditText(Context context, AttributeSet attrs) {
 131         super(context, attrs);
 132         listeners = new ArrayList&lt;&gt;();
 133 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 134 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135         listeners = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 138 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 139     public SimplenoteEditText(Context context, AttributeSet attrs, int defStyle) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 140         super(context, attrs, defStyle);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 141         listeners = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 142         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 143     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 144 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 145     public void addOnSelectionChangedListener(OnSelectionChangedListener o) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 146         listeners.add(o);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 147     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 148 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 149     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 150     protected void onSelectionChanged(int selStart, int selEnd) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 151         super.onSelectionChanged(selStart, selEnd);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 152         if (listeners != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 153             for (OnSelectionChangedListener l : listeners)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 154                 l.onSelectionChanged(selStart, selEnd);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 155         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 156     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 157 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 158     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 159     public boolean onKeyPreIme(int keyCode, KeyEvent event) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160         if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 161             clearFocus();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 162         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 163 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 164         return super.onKeyPreIme(keyCode, event);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 165     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 166 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168     protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169         if (focused) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 170             setCursorVisible(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 171         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 173         super.onFocusChanged(focused, direction, previouslyFocusedRect);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176     // Updates the ImageSpan drawable to the new checked state</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177     public void toggleCheckbox(final CheckableSpan checkableSpan) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178         setCursorVisible(false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 179 </span>
 180 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 181         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 182         setLinkTokenizer();</span>
 183 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 184     }
 185 
 186     public SimplenoteEditText(Context context, AttributeSet attrs, int defStyle) {
 187         super(context, attrs, defStyle);
 188         listeners = new ArrayList&lt;&gt;();
 189 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 190 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191         super(context, attrs, defStyle);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192         listeners = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196     public void addOnSelectionChangedListener(OnSelectionChangedListener o) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197         listeners.add(o);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201     protected void onSelectionChanged(int selStart, int selEnd) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202         super.onSelectionChanged(selStart, selEnd);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203         if (listeners != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204             for (OnSelectionChangedListener l : listeners)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205                 l.onSelectionChanged(selStart, selEnd);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210     public boolean onKeyPreIme(int keyCode, KeyEvent event) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211         if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212             clearFocus();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215         return super.onKeyPreIme(keyCode, event);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219     protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220         if (focused) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221             setCursorVisible(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 224         super.onFocusChanged(focused, direction, previouslyFocusedRect);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 225     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 226 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 227     // Updates the ImageSpan drawable to the new checked state</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 228     public void toggleCheckbox(final CheckableSpan checkableSpan) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 229         setCursorVisible(false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 230 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231         final Editable editable = getText();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 233         final int checkboxStart = editable.getSpanStart(checkableSpan);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234         final int checkboxEnd = editable.getSpanEnd(checkableSpan);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 235 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 236         final int selectionStart = getSelectionStart();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 237         final int selectionEnd = getSelectionEnd();</span>
 238 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 239         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 240         setLinkTokenizer();</span>
 241 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 242     }
 243 
 244     public void addOnSelectionChangedListener(OnSelectionChangedListener o) {
 245         listeners.add(o);
 246     }
 247 
 248     private void setLinkTokenizer() {
 249         mTokenizer = new LinkTokenizer();
 250         setOnItemClickListener(this);
 251         setTokenizer(mTokenizer);
 252         setThreshold(1);
 253     }
 254 
 255     @Override
 256     public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
 257         @SuppressWarnings(&quot;unchecked&quot;)
<abbr title=" 258         Bucket.ObjectCursor&lt;Note&gt; cursor = (Bucket.ObjectCursor&lt;Note&gt;) parent.getAdapter().getItem(position);"> 258         Bucket.ObjectCursor&lt;Note&gt; cursor = (Bucket.ObjectCursor&lt;Note&gt;) parent.getAdapter().getItem(positiðŸ”µ</abbr>
 259         String key = cursor.getString(cursor.getColumnIndex(Note.KEY_PROPERTY)).replace(&quot;note&quot;, &quot;&quot;);
 260         String text = SimplenoteLinkify.getNoteLink(key);
 261         int start = Math.max(getSelectionStart(), 0);
 262         int end = Math.max(getSelectionEnd(), 0);
 263         getEditableText().replace(Math.min(start, end), Math.max(start, end), text, 0, text.length());
 264     }
 265 
 266     @Override
 267     protected void onSelectionChanged(int selStart, int selEnd) {
 268         super.onSelectionChanged(selStart, selEnd);
 269         if (listeners != null) {
 270             for (OnSelectionChangedListener l : listeners)
 271                 l.onSelectionChanged(selStart, selEnd);
 272         }
 273     }
 274 
 275     @Override
 276     public boolean onKeyPreIme(int keyCode, KeyEvent event) {
 277         if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
 278             clearFocus();
 279         }
 280 
 281         return super.onKeyPreIme(keyCode, event);
 282     }
 283 
 284     @Override
 285     protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
 286         if (focused) {
 287             setCursorVisible(true);
 288         }
 289 
 290         super.onFocusChanged(focused, direction, previouslyFocusedRect);
 291     }
 292 
 293     // Updates the ImageSpan drawable to the new checked state
 294     public void toggleCheckbox(final CheckableSpan checkableSpan) {
 295         setCursorVisible(false);
 296 
 297         final Editable editable = getText();
 298 
 299         final int checkboxStart = editable.getSpanStart(checkableSpan);
 300         final int checkboxEnd = editable.getSpanEnd(checkableSpan);
 301 
 302         final int selectionStart = getSelectionStart();
 303         final int selectionEnd = getSelectionEnd();
 304 
 305         final ImageSpan[] imageSpans = editable.getSpans(checkboxStart, checkboxEnd, ImageSpan.class);
 306         if (imageSpans.length &gt; 0) {
 307             // ImageSpans are static, so we need to remove the old one and replace :|
 308             Drawable iconDrawable = ContextCompat.getDrawable(getContext(),
 309                     checkableSpan.isChecked()
 310                             ? R.drawable.ic_checkbox_checked_24px
 311                             : R.drawable.ic_checkbox_unchecked_24px);
<abbr title=" 312             iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.text_title_disabled);"> 312             iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.texðŸ”µ</abbr>
 313             int iconSize = DisplayUtils.getChecklistIconSize(getContext());
 314             iconDrawable.setBounds(0, 0, iconSize, iconSize);
 315             final CenteredImageSpan newImageSpan = new CenteredImageSpan(getContext(), iconDrawable);
 316             new Handler().post(new Runnable() {
 317                 @Override
 318                 public void run() {
<abbr title=" 319                     editable.setSpan(newImageSpan, checkboxStart, checkboxEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);"> 319                     editable.setSpan(newImageSpan, checkboxStart, checkboxEnd, Spanned.SPAN_EXCLUSIVE_EXCðŸ”µ</abbr>
 320                     editable.removeSpan(imageSpans[0]);
 321                     fixLineSpacing();
 322 
 323                     // Restore the selection
 324                     if (selectionStart &gt;= 0
 325                             &amp;&amp; selectionStart &lt;= editable.length()
 326                             &amp;&amp; selectionEnd &lt;= editable.length() &amp;&amp; hasFocus()) {
 327                         setSelection(selectionStart, selectionEnd);
 328                         setCursorVisible(true);
 329                     }
 330 
 331                     if (mOnCheckboxToggledListener != null) {
 332                         mOnCheckboxToggledListener.onCheckboxToggled();
 333                     }
 334                 }
 335             });
 336         }
 337     }
 338 
 339     // Returns the line position of the text cursor
 340     private int getCurrentCursorLine() {
 341         int selectionStart = getSelectionStart();
 342         Layout layout = getLayout();
 343 
 344         if (!(selectionStart == -1)) {
 345             return layout.getLineForOffset(selectionStart);
 346         }
 347 
 348         return 0;
 349     }
 350 
 351     public void insertChecklist() {
 352         int start, end;
 353         int lineNumber = getCurrentCursorLine();
 354         start = getLayout().getLineStart(lineNumber);
 355 
 356         if (getSelectionEnd() &gt; getSelectionStart() &amp;&amp; !selectionIsOnSameLine()) {
 357             end = getSelectionEnd();
 358         } else {
 359             end = getLayout().getLineEnd(lineNumber);
 360         }
 361 
<abbr title=" 362         SpannableStringBuilder workingString = new SpannableStringBuilder(getText().subSequence(start, end));"> 362         SpannableStringBuilder workingString = new SpannableStringBuilder(getText().subSequence(start, enðŸ”µ</abbr>
 363         Editable editable = getText();
 364         if (editable.length() &lt; start || editable.length() &lt; end) {
 365             return;
 366         }
 367 
 368         int previousSelection = getSelectionStart();
<abbr title=" 369         CheckableSpan[] checkableSpans = workingString.getSpans(0, workingString.length(), CheckableSpan.class);"> 369         CheckableSpan[] checkableSpans = workingString.getSpans(0, workingString.length(), CheckableSpan.ðŸ”µ</abbr>
 370         if (checkableSpans.length &gt; 0) {
 371             // Remove any CheckableSpans found
 372             for (CheckableSpan span: checkableSpans) {
 373                 workingString.replace(
 374                         workingString.getSpanStart(span),
 375                         workingString.getSpanEnd(span) + 1,
 376                         &quot;&quot;
 377                 );
 378                 workingString.removeSpan(span);
 379             }
 380 
 381             editable.replace(start, end, workingString);
 382 
 383             if (checkableSpans.length == 1) {
 384                 int newSelection = Math.max(previousSelection - CHECKBOX_LENGTH, 0);
 385                 if (editable.length() &gt;= newSelection) {
 386                     setSelection(newSelection);
 387                 }
 388             }
 389         } else {
 390             // Insert a checklist for each line
 391             String[] lines = workingString.toString().split(&quot;(?&lt;=\n)&quot;);
 392             StringBuilder resultString = new StringBuilder();
 393 
 394             for (String lineString: lines) {
 395                 // Preserve the spaces before the text
 396                 int leadingSpaceCount;
 397                 if (lineString.trim().length() == 0) {
 398                     // Only whitespace content, get count of spaces
 399                     leadingSpaceCount = lineString.length() - lineString.replaceAll(&quot; &quot;, &quot;&quot;).length();
 400                 } else {
 401                     // Get count of spaces up to first non-whitespace character
 402                     leadingSpaceCount = lineString.indexOf(lineString.trim());
 403                 }
 404 
 405                 if (leadingSpaceCount &gt; 0) {
 406                     resultString.append(new String(new char[leadingSpaceCount]).replace(&#x27;\0&#x27;, &#x27; &#x27;));
 407                     lineString = lineString.substring(leadingSpaceCount);
 408                 }
 409 
 410                 resultString
 411                         .append(ChecklistUtils.UNCHECKED_MARKDOWN)
 412                         .append(&quot; &quot;)
 413                         .append(lineString);
 414             }
 415 
 416             editable.replace(start, end, resultString);
 417 
 418             int newSelection = Math.max(previousSelection, 0) + (lines.length * CHECKBOX_LENGTH);
 419             if (editable.length() &gt;= newSelection) {
 420                 setSelection(newSelection);
 421             }
 422         }
 423     }
 424 
 425     // Returns true if the current editor selection is on the same line
 426     private boolean selectionIsOnSameLine() {
 427         int selectionStart = getSelectionStart();
 428         int selectionEnd = getSelectionEnd();
 429         Layout layout = getLayout();
 430 
 431         if (selectionStart &gt;= 0 &amp;&amp; selectionEnd &gt;= 0) {
 432             return layout.getLineForOffset(selectionStart) == layout.getLineForOffset(selectionEnd);
 433         }
 434 
 435         return false;
 436     }
 437 
 438     public void fixLineSpacing() {
 439         // Prevents line heights from compacting
 440         // https://issuetracker.google.com/issues/37009353
 441         float lineSpacingExtra = getLineSpacingExtra();
 442         float lineSpacingMultiplier = getLineSpacingMultiplier();
 443         setLineSpacing(0.0f, 1.0f);
 444         setLineSpacing(lineSpacingExtra, lineSpacingMultiplier);
 445     }
 446 
 447     public interface OnSelectionChangedListener {
 448         void onSelectionChanged(int selStart, int selEnd);
 449     }
 450 
 451     // Replaces any CheckableSpans with their markdown counterpart (e.g. &#x27;- [ ]&#x27;)
 452     public String getPlainTextContent() {
 453         if (getText() == null) {
 454             return &quot;&quot;;
 455         }
 456 
 457         SpannableStringBuilder content = new SpannableStringBuilder(getText());
 458         CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 459         for(CheckableSpan span: spans) {
 460             int start = content.getSpanStart(span);
 461             int end = content.getSpanEnd(span);
 462             ((Editable) content).replace(
 463                     start,
 464                     end,
<abbr title=" 465                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN : ChecklistUtils.UNCHECKED_MARKDOWN);"> 465                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN : ChecklistUtils.UNCHECKED_MARKDOWðŸ”µ</abbr>
 466         }
 467 
 468         return content.toString();
 469     }
 470 
 471     // Replaces any CheckableSpans with their markdown preview counterpart (e.g. &#x27;- [\u2a2f]&#x27;)
 472     public String getPreviewTextContent() {
 473         if (getText() == null) {
 474             return &quot;&quot;;
 475         }
 476 
 477         SpannableStringBuilder content = new SpannableStringBuilder(getText());
 478         CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 479         for(CheckableSpan span: spans) {
 480             int start = content.getSpanStart(span);
 481             int end = content.getSpanEnd(span);
 482             ((Editable) content).replace(
 483                     start,
 484                     end,
<abbr title=" 485                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKED_MARKDOWN);"> 485                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKEDðŸ”µ</abbr>
 486         }
 487 
 488         return content.toString();
 489     }
 490 
 491 
 492     public void processChecklists() {
 493         if (getText().length() == 0 || getContext() == null) {
 494             return;
 495         }
 496 
 497         try {
 498             ChecklistUtils.addChecklistSpansForRegexAndColor(
 499                     getContext(),
 500                     getText(),
 501                     ChecklistUtils.CHECKLIST_REGEX_LINES,
 502                     R.color.text_title_disabled);
 503         } catch (Exception e) {
 504             e.printStackTrace();
 505         }
 506     }
 507 
 508     public void setOnCheckboxToggledListener(OnCheckboxToggledListener listener) {
 509         mOnCheckboxToggledListener = listener;
 510     }
 511 }</pre></td>
                            <td><pre>   1 package com.automattic.simplenote.widgets;
   2 
   3 import android.content.Context;
   4 import android.graphics.Rect;
   5 import android.graphics.drawable.Drawable;
   6 import android.os.Handler;
   7 import android.text.Editable;
   8 import android.text.Layout;
   9 import android.text.SpannableStringBuilder;
  10 import android.text.Spanned;
  11 import android.text.style.ImageSpan;
  12 import android.util.AttributeSet;
  13 import android.view.KeyEvent;
  14 import android.view.View;
  15 import android.widget.AdapterView;
  16 
  17 import androidx.appcompat.widget.AppCompatMultiAutoCompleteTextView;
  18 import androidx.core.content.ContextCompat;
  19 
  20 import com.automattic.simplenote.R;
  21 import com.automattic.simplenote.models.Note;
  22 import com.automattic.simplenote.utils.ChecklistUtils;
  23 import com.automattic.simplenote.utils.DisplayUtils;
  24 import com.automattic.simplenote.utils.DrawableUtils;
  25 import com.automattic.simplenote.utils.LinkTokenizer;
  26 import com.automattic.simplenote.utils.SimplenoteLinkify;
  27 import com.simperium.client.Bucket;
  28 
  29 import java.util.ArrayList;
  30 import java.util.List;
  31 import java.util.regex.Matcher;
  32 import java.util.regex.Pattern;
  33 
  34 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_ID;
  35 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  36 
<abbr title="  37 public class SimplenoteEditText extends AppCompatMultiAutoCompleteTextView implements AdapterView.OnItemClickListener {">  37 public class SimplenoteEditText extends AppCompatMultiAutoCompleteTextView implements AdapterView.OnItemCðŸ”µ</abbr>
<abbr title="  38     private static final Pattern INTERNOTE_LINK_PATTERN_EDIT = Pattern.compile(&quot;([^]]*)(]\\(&quot; + SIMPLENOTE_LINK_PREFIX + SIMPLENOTE_LINK_ID + &quot;\\))&quot;);">  38     private static final Pattern INTERNOTE_LINK_PATTERN_EDIT = Pattern.compile(&quot;([^]]*)(]\\(&quot; + SIMPLENOTðŸ”µ</abbr>
<abbr title="  39     private static final Pattern INTERNOTE_LINK_PATTERN_FULL = Pattern.compile(&quot;(?s)(.)*(\\[)&quot; + INTERNOTE_LINK_PATTERN_EDIT);">  39     private static final Pattern INTERNOTE_LINK_PATTERN_FULL = Pattern.compile(&quot;(?s)(.)*(\\[)&quot; + INTERNOTðŸ”µ</abbr>
  40     private static final int CHECKBOX_LENGTH = 2; // one ClickableSpan character + one space character
  41 
  42     private LinkTokenizer mTokenizer;
  43     private List&lt;OnSelectionChangedListener&gt; listeners;
  44     private OnCheckboxToggledListener mOnCheckboxToggledListener;
  45 
  46     @Override
  47     public boolean enoughToFilter() {
  48         String substringCursor = getText().toString().substring(getSelectionEnd());
  49         Matcher matcherEdit = INTERNOTE_LINK_PATTERN_EDIT.matcher(substringCursor);
  50 
  51         // When an internote link title is being edited, don&#x27;t show an autocomplete popup.
  52         if (matcherEdit.lookingAt()) {
  53             String substringEdit = substringCursor.substring(0, matcherEdit.end());
  54             Matcher matcherFull = INTERNOTE_LINK_PATTERN_FULL.matcher(substringEdit);
  55 
  56             if (!matcherFull.lookingAt()) {
  57                 return false;
  58             }
  59         }
  60 
  61         Editable text = getText();
  62         int end = getSelectionEnd();
  63 
  64         if (end &lt; 0) {
  65             return false;
  66         }
  67 
  68         int start = mTokenizer.findTokenStart(text, end);
  69         return start &gt; 0 &amp;&amp; end - start &gt;= 1;
  70     }
  71 
  72     public interface OnCheckboxToggledListener {
  73         void onCheckboxToggled();
  74     }
  75 
  76     public SimplenoteEditText(Context context) {
  77         super(context);
  78         listeners = new ArrayList&lt;&gt;();
  79 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
  80 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  81         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  82     }</span>
  83 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  84         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  85         setLinkTokenizer();</span>
  86 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
  87     }
  88 
  89     public SimplenoteEditText(Context context, AttributeSet attrs) {
  90         super(context, attrs);
  91         listeners = new ArrayList&lt;&gt;();
  92 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
  93 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95     }</span>
  96 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  97         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  98         setLinkTokenizer();</span>
  99 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 100     }
 101 
 102     public SimplenoteEditText(Context context, AttributeSet attrs, int defStyle) {
 103         super(context, attrs, defStyle);
 104         listeners = new ArrayList&lt;&gt;();
 105 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 106 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 107         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108     }</span>
 109 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 110         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 111         setLinkTokenizer();</span>
 112 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 113     }
 114 
 115     public void addOnSelectionChangedListener(OnSelectionChangedListener o) {
 116         listeners.add(o);
 117     }
 118 
 119     private void setLinkTokenizer() {
 120         mTokenizer = new LinkTokenizer();
 121         setOnItemClickListener(this);
 122         setTokenizer(mTokenizer);
 123         setThreshold(1);
 124     }
 125 
 126     @Override
 127     public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
 128         @SuppressWarnings(&quot;unchecked&quot;)
<abbr title=" 129         Bucket.ObjectCursor&lt;Note&gt; cursor = (Bucket.ObjectCursor&lt;Note&gt;) parent.getAdapter().getItem(position);"> 129         Bucket.ObjectCursor&lt;Note&gt; cursor = (Bucket.ObjectCursor&lt;Note&gt;) parent.getAdapter().getItem(positiðŸ”µ</abbr>
 130         String key = cursor.getString(cursor.getColumnIndex(Note.KEY_PROPERTY)).replace(&quot;note&quot;, &quot;&quot;);
 131         String text = SimplenoteLinkify.getNoteLink(key);
 132         int start = Math.max(getSelectionStart(), 0);
 133         int end = Math.max(getSelectionEnd(), 0);
 134         getEditableText().replace(Math.min(start, end), Math.max(start, end), text, 0, text.length());
 135     }
 136 
 137     @Override
 138     protected void onSelectionChanged(int selStart, int selEnd) {
 139         super.onSelectionChanged(selStart, selEnd);
 140         if (listeners != null) {
 141             for (OnSelectionChangedListener l : listeners)
 142                 l.onSelectionChanged(selStart, selEnd);
 143         }
 144     }
 145 
 146     @Override
 147     public boolean onKeyPreIme(int keyCode, KeyEvent event) {
 148         if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
 149             clearFocus();
 150         }
 151 
 152         return super.onKeyPreIme(keyCode, event);
 153     }
 154 
 155     @Override
 156     protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
 157         if (focused) {
 158             setCursorVisible(true);
 159         }
 160 
 161         super.onFocusChanged(focused, direction, previouslyFocusedRect);
 162     }
 163 
 164     // Updates the ImageSpan drawable to the new checked state
 165     public void toggleCheckbox(final CheckableSpan checkableSpan) {
 166         setCursorVisible(false);
 167 
 168         final Editable editable = getText();
 169 
 170         final int checkboxStart = editable.getSpanStart(checkableSpan);
 171         final int checkboxEnd = editable.getSpanEnd(checkableSpan);
 172 
 173         final int selectionStart = getSelectionStart();
 174         final int selectionEnd = getSelectionEnd();
 175 
 176         final ImageSpan[] imageSpans = editable.getSpans(checkboxStart, checkboxEnd, ImageSpan.class);
 177         if (imageSpans.length &gt; 0) {
 178             // ImageSpans are static, so we need to remove the old one and replace :|
 179             Drawable iconDrawable = ContextCompat.getDrawable(getContext(),
 180                     checkableSpan.isChecked()
 181                             ? R.drawable.ic_checkbox_checked_24px
 182                             : R.drawable.ic_checkbox_unchecked_24px);
<abbr title=" 183             iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.text_title_disabled);"> 183             iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.texðŸ”µ</abbr>
 184             int iconSize = DisplayUtils.getChecklistIconSize(getContext());
 185             iconDrawable.setBounds(0, 0, iconSize, iconSize);
 186             final CenteredImageSpan newImageSpan = new CenteredImageSpan(getContext(), iconDrawable);
 187             new Handler().post(new Runnable() {
 188                 @Override
 189                 public void run() {
<abbr title=" 190                     editable.setSpan(newImageSpan, checkboxStart, checkboxEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);"> 190                     editable.setSpan(newImageSpan, checkboxStart, checkboxEnd, Spanned.SPAN_EXCLUSIVE_EXCðŸ”µ</abbr>
 191                     editable.removeSpan(imageSpans[0]);
 192                     fixLineSpacing();
 193 
 194                     // Restore the selection
 195                     if (selectionStart &gt;= 0
 196                             &amp;&amp; selectionStart &lt;= editable.length()
 197                             &amp;&amp; selectionEnd &lt;= editable.length() &amp;&amp; hasFocus()) {
 198                         setSelection(selectionStart, selectionEnd);
 199                         setCursorVisible(true);
 200                     }
 201 
 202                     if (mOnCheckboxToggledListener != null) {
 203                         mOnCheckboxToggledListener.onCheckboxToggled();
 204                     }
 205                 }
 206             });
 207         }
 208     }
 209 
 210     // Returns the line position of the text cursor
 211     private int getCurrentCursorLine() {
 212         int selectionStart = getSelectionStart();
 213         Layout layout = getLayout();
 214 
 215         if (!(selectionStart == -1)) {
 216             return layout.getLineForOffset(selectionStart);
 217         }
 218 
 219         return 0;
 220     }
 221 
 222     public void insertChecklist() {
 223         int start, end;
 224         int lineNumber = getCurrentCursorLine();
 225         start = getLayout().getLineStart(lineNumber);
 226 
 227         if (getSelectionEnd() &gt; getSelectionStart() &amp;&amp; !selectionIsOnSameLine()) {
 228             end = getSelectionEnd();
 229         } else {
 230             end = getLayout().getLineEnd(lineNumber);
 231         }
 232 
<abbr title=" 233         SpannableStringBuilder workingString = new SpannableStringBuilder(getText().subSequence(start, end));"> 233         SpannableStringBuilder workingString = new SpannableStringBuilder(getText().subSequence(start, enðŸ”µ</abbr>
 234         Editable editable = getText();
 235         if (editable.length() &lt; start || editable.length() &lt; end) {
 236             return;
 237         }
 238 
 239         int previousSelection = getSelectionStart();
<abbr title=" 240         CheckableSpan[] checkableSpans = workingString.getSpans(0, workingString.length(), CheckableSpan.class);"> 240         CheckableSpan[] checkableSpans = workingString.getSpans(0, workingString.length(), CheckableSpan.ðŸ”µ</abbr>
 241         if (checkableSpans.length &gt; 0) {
 242             // Remove any CheckableSpans found
 243             for (CheckableSpan span: checkableSpans) {
 244                 workingString.replace(
 245                         workingString.getSpanStart(span),
 246                         workingString.getSpanEnd(span) + 1,
 247                         &quot;&quot;
 248                 );
 249                 workingString.removeSpan(span);
 250             }
 251 
 252             editable.replace(start, end, workingString);
 253 
 254             if (checkableSpans.length == 1) {
 255                 int newSelection = Math.max(previousSelection - CHECKBOX_LENGTH, 0);
 256                 if (editable.length() &gt;= newSelection) {
 257                     setSelection(newSelection);
 258                 }
 259             }
 260         } else {
 261             // Insert a checklist for each line
 262             String[] lines = workingString.toString().split(&quot;(?&lt;=\n)&quot;);
 263             StringBuilder resultString = new StringBuilder();
 264 
 265             for (String lineString: lines) {
 266                 // Preserve the spaces before the text
 267                 int leadingSpaceCount;
 268                 if (lineString.trim().length() == 0) {
 269                     // Only whitespace content, get count of spaces
 270                     leadingSpaceCount = lineString.length() - lineString.replaceAll(&quot; &quot;, &quot;&quot;).length();
 271                 } else {
 272                     // Get count of spaces up to first non-whitespace character
 273                     leadingSpaceCount = lineString.indexOf(lineString.trim());
 274                 }
 275 
 276                 if (leadingSpaceCount &gt; 0) {
 277                     resultString.append(new String(new char[leadingSpaceCount]).replace(&#x27;\0&#x27;, &#x27; &#x27;));
 278                     lineString = lineString.substring(leadingSpaceCount);
 279                 }
 280 
 281                 resultString
 282                         .append(ChecklistUtils.UNCHECKED_MARKDOWN)
 283                         .append(&quot; &quot;)
 284                         .append(lineString);
 285             }
 286 
 287             editable.replace(start, end, resultString);
 288 
 289             int newSelection = Math.max(previousSelection, 0) + (lines.length * CHECKBOX_LENGTH);
 290             if (editable.length() &gt;= newSelection) {
 291                 setSelection(newSelection);
 292             }
 293         }
 294     }
 295 
 296     // Returns true if the current editor selection is on the same line
 297     private boolean selectionIsOnSameLine() {
 298         int selectionStart = getSelectionStart();
 299         int selectionEnd = getSelectionEnd();
 300         Layout layout = getLayout();
 301 
 302         if (selectionStart &gt;= 0 &amp;&amp; selectionEnd &gt;= 0) {
 303             return layout.getLineForOffset(selectionStart) == layout.getLineForOffset(selectionEnd);
 304         }
 305 
 306         return false;
 307     }
 308 
 309     public void fixLineSpacing() {
 310         // Prevents line heights from compacting
 311         // https://issuetracker.google.com/issues/37009353
 312         float lineSpacingExtra = getLineSpacingExtra();
 313         float lineSpacingMultiplier = getLineSpacingMultiplier();
 314         setLineSpacing(0.0f, 1.0f);
 315         setLineSpacing(lineSpacingExtra, lineSpacingMultiplier);
 316     }
 317 
 318     public interface OnSelectionChangedListener {
 319         void onSelectionChanged(int selStart, int selEnd);
 320     }
 321 
 322     // Replaces any CheckableSpans with their markdown counterpart (e.g. &#x27;- [ ]&#x27;)
 323     public String getPlainTextContent() {
 324         if (getText() == null) {
 325             return &quot;&quot;;
 326         }
 327 
 328         SpannableStringBuilder content = new SpannableStringBuilder(getText());
 329         CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 330         for(CheckableSpan span: spans) {
 331             int start = content.getSpanStart(span);
 332             int end = content.getSpanEnd(span);
 333             ((Editable) content).replace(
 334                     start,
 335                     end,
<abbr title=" 336                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN : ChecklistUtils.UNCHECKED_MARKDOWN);"> 336                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN : ChecklistUtils.UNCHECKED_MARKDOWðŸ”µ</abbr>
 337         }
 338 
 339         return content.toString();
 340     }
 341 
 342     // Replaces any CheckableSpans with their markdown preview counterpart (e.g. &#x27;- [\u2a2f]&#x27;)
 343     public String getPreviewTextContent() {
 344         if (getText() == null) {
 345             return &quot;&quot;;
 346         }
 347 
 348         SpannableStringBuilder content = new SpannableStringBuilder(getText());
 349         CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 350         for(CheckableSpan span: spans) {
 351             int start = content.getSpanStart(span);
 352             int end = content.getSpanEnd(span);
 353             ((Editable) content).replace(
 354                     start,
 355                     end,
<abbr title=" 356                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKED_MARKDOWN);"> 356                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKEDðŸ”µ</abbr>
 357         }
 358 
 359         return content.toString();
 360     }
 361 
 362 
 363     public void processChecklists() {
 364         if (getText().length() == 0 || getContext() == null) {
 365             return;
 366         }
 367 
 368         try {
 369             ChecklistUtils.addChecklistSpansForRegexAndColor(
 370                     getContext(),
 371                     getText(),
 372                     ChecklistUtils.CHECKLIST_REGEX_LINES,
 373                     R.color.text_title_disabled);
 374         } catch (Exception e) {
 375             e.printStackTrace();
 376         }
 377     }
 378 
 379     public void setOnCheckboxToggledListener(OnCheckboxToggledListener listener) {
 380         mOnCheckboxToggledListener = listener;
 381     }
 382 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote.widgets;
   2 
   3 import android.content.Context;
   4 import android.graphics.Rect;
   5 import android.graphics.drawable.Drawable;
   6 import android.os.Handler;
   7 import android.text.Editable;
   8 import android.text.Layout;
   9 import android.text.SpannableStringBuilder;
  10 import android.text.Spanned;
  11 import android.text.style.ImageSpan;
  12 import android.util.AttributeSet;
  13 import android.view.KeyEvent;
  14 import android.view.View;
  15 import android.widget.AdapterView;
  16 import androidx.appcompat.widget.AppCompatMultiAutoCompleteTextView;
  17 import androidx.core.content.ContextCompat;
  18 import com.automattic.simplenote.R;
  19 import com.automattic.simplenote.models.Note;
  20 import com.automattic.simplenote.utils.ChecklistUtils;
  21 import com.automattic.simplenote.utils.DisplayUtils;
  22 import com.automattic.simplenote.utils.DrawableUtils;
  23 import com.automattic.simplenote.utils.LinkTokenizer;
  24 import com.automattic.simplenote.utils.SimplenoteLinkify;
  25 import com.simperium.client.Bucket;
  26 import java.util.ArrayList;
  27 import java.util.List;
  28 import java.util.regex.Matcher;
  29 import java.util.regex.Pattern;
  30 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_ID;
  31 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  32 
  33 
<abbr title="  34 public class SimplenoteEditText extends AppCompatMultiAutoCompleteTextView implements AdapterView.OnItemClickListener {">  34 public class SimplenoteEditText extends AppCompatMultiAutoCompleteTextView implements AdapterView.OnItemCðŸ”µ</abbr>
<abbr title="  35     private static final Pattern INTERNOTE_LINK_PATTERN_EDIT = Pattern.compile(&quot;([^]]*)(]\\(&quot; + SIMPLENOTE_LINK_PREFIX + SIMPLENOTE_LINK_ID + &quot;\\))&quot;);">  35     private static final Pattern INTERNOTE_LINK_PATTERN_EDIT = Pattern.compile(&quot;([^]]*)(]\\(&quot; + SIMPLENOTðŸ”µ</abbr>
  36 
<abbr title="  37     private static final Pattern INTERNOTE_LINK_PATTERN_FULL = Pattern.compile(&quot;(?s)(.)*(\\[)&quot; + INTERNOTE_LINK_PATTERN_EDIT);">  37     private static final Pattern INTERNOTE_LINK_PATTERN_FULL = Pattern.compile(&quot;(?s)(.)*(\\[)&quot; + INTERNOTðŸ”µ</abbr>
  38 
  39     // one ClickableSpan character + one space character
  40     private static final int CHECKBOX_LENGTH = 2;
  41 
  42     private LinkTokenizer mTokenizer;
  43 
  44     private List&lt;OnSelectionChangedListener&gt; listeners;
  45 
  46     private OnCheckboxToggledListener mOnCheckboxToggledListener;
  47 
  48     @Override
  49     public boolean enoughToFilter() {
  50         String substringCursor = getText().toString().substring(getSelectionEnd());
  51         Matcher matcherEdit = INTERNOTE_LINK_PATTERN_EDIT.matcher(substringCursor);
  52 
  53         // When an internote link title is being edited, don&#x27;t show an autocomplete popup.
  54         if (matcherEdit.lookingAt()) {
  55             String substringEdit = substringCursor.substring(0, matcherEdit.end());
  56             Matcher matcherFull = INTERNOTE_LINK_PATTERN_FULL.matcher(substringEdit);
  57 
  58             if (!matcherFull.lookingAt()) {
  59                 return false;
  60             }
  61         }
  62 
  63         Editable text = getText();
  64         int end = getSelectionEnd();
  65 
  66         if (end &lt; 0) {
  67             return false;
  68         }
  69 
  70         int start = mTokenizer.findTokenStart(text, end);
  71         return start &gt; 0 &amp;&amp; end - start &gt;= 1;
  72     }
  73 
  74     public interface OnCheckboxToggledListener {
  75         public abstract void onCheckboxToggled();
  76     }
  77 
  78     public SimplenoteEditText(Context context) {
  79         super(context);
  80         listeners = new ArrayList&lt;&gt;();
  81 
  82 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  83 </span>
  84 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  85 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">  85 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
  86 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  87 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  88         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  89         setLinkTokenizer();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  90 </span>
  91 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
  92     }
  93 
  94     public SimplenoteEditText(Context context, AttributeSet attrs) {
  95         super(context, attrs);
  96         listeners = new ArrayList&lt;&gt;();
  97 
  98 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  99 </span>
 100 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 101 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 101 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 102 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 103 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 104         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 105         setLinkTokenizer();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 106 </span>
 107 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 108     }
 109 
 110     public SimplenoteEditText(Context context, AttributeSet attrs, int defStyle) {
 111         super(context, attrs, defStyle);
 112         listeners = new ArrayList&lt;&gt;();
 113 
 114 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 115 </span>
 116 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 117 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 117 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 118 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 119 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 120         setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 121         setLinkTokenizer();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 122 </span>
 123 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 124     }
 125 
 126     public void addOnSelectionChangedListener(OnSelectionChangedListener o) {
 127         listeners.add(o);
 128     }
 129 
 130     private void setLinkTokenizer() {
 131         mTokenizer = new LinkTokenizer();
 132         setOnItemClickListener(this);
 133         setTokenizer(mTokenizer);
 134         setThreshold(1);
 135     }
 136 
 137     @Override
 138     public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
 139         @SuppressWarnings(&quot;unchecked&quot;)
<abbr title=" 140         Bucket.ObjectCursor&lt;Note&gt; cursor = (Bucket.ObjectCursor&lt;Note&gt;) parent.getAdapter().getItem(position);"> 140         Bucket.ObjectCursor&lt;Note&gt; cursor = (Bucket.ObjectCursor&lt;Note&gt;) parent.getAdapter().getItem(positiðŸ”µ</abbr>
 141         String key = cursor.getString(cursor.getColumnIndex(Note.KEY_PROPERTY)).replace(&quot;note&quot;, &quot;&quot;);
 142         String text = SimplenoteLinkify.getNoteLink(key);
 143         int start = Math.max(getSelectionStart(), 0);
 144         int end = Math.max(getSelectionEnd(), 0);
 145         getEditableText().replace(Math.min(start, end), Math.max(start, end), text, 0, text.length());
 146     }
 147 
 148     @Override
 149     protected void onSelectionChanged(int selStart, int selEnd) {
 150         super.onSelectionChanged(selStart, selEnd);
 151         if (listeners != null) {
 152             for (OnSelectionChangedListener l : listeners) {
 153                 l.onSelectionChanged(selStart, selEnd);
 154             }
 155         }
 156     }
 157 
 158     @Override
 159     public boolean onKeyPreIme(int keyCode, KeyEvent event) {
 160         if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
 161             clearFocus();
 162         }
 163         return super.onKeyPreIme(keyCode, event);
 164     }
 165 
 166     @Override
 167     protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
 168         if (focused) {
 169             setCursorVisible(true);
 170         }
 171         super.onFocusChanged(focused, direction, previouslyFocusedRect);
 172     }
 173 
 174     // Updates the ImageSpan drawable to the new checked state
 175     public void toggleCheckbox(final CheckableSpan checkableSpan) {
 176         setCursorVisible(false);
 177 
 178         final Editable editable = getText();
 179 
 180         final int checkboxStart = editable.getSpanStart(checkableSpan);
 181         final int checkboxEnd = editable.getSpanEnd(checkableSpan);
 182 
 183         final int selectionStart = getSelectionStart();
 184         final int selectionEnd = getSelectionEnd();
 185 
 186         final ImageSpan[] imageSpans = editable.getSpans(checkboxStart, checkboxEnd, ImageSpan.class);
 187         if (imageSpans.length &gt; 0) {
 188             // ImageSpans are static, so we need to remove the old one and replace :|
 189             Drawable iconDrawable = ContextCompat.getDrawable(getContext(),
 190                     checkableSpan.isChecked()
 191                             ? R.drawable.ic_checkbox_checked_24px
 192                             : R.drawable.ic_checkbox_unchecked_24px);
<abbr title=" 193             iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.text_title_disabled);"> 193             iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.texðŸ”µ</abbr>
 194             int iconSize = DisplayUtils.getChecklistIconSize(getContext());
 195             iconDrawable.setBounds(0, 0, iconSize, iconSize);
 196             final CenteredImageSpan newImageSpan = new CenteredImageSpan(getContext(), iconDrawable);
 197             new Handler().post(new Runnable() {
 198                 @Override
 199                 public void run() {
<abbr title=" 200                     editable.setSpan(newImageSpan, checkboxStart, checkboxEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);"> 200                     editable.setSpan(newImageSpan, checkboxStart, checkboxEnd, Spanned.SPAN_EXCLUSIVE_EXCðŸ”µ</abbr>
 201                     editable.removeSpan(imageSpans[0]);
 202                     fixLineSpacing();
 203 
 204                     // Restore the selection
 205                     if (selectionStart &gt;= 0
 206                             &amp;&amp; selectionStart &lt;= editable.length()
 207                             &amp;&amp; selectionEnd &lt;= editable.length() &amp;&amp; hasFocus()) {
 208                         setSelection(selectionStart, selectionEnd);
 209                         setCursorVisible(true);
 210                     }
 211 
 212                     if (mOnCheckboxToggledListener != null) {
 213                         mOnCheckboxToggledListener.onCheckboxToggled();
 214                     }
 215                 }
 216             });
 217         }
 218     }
 219 
 220     // Returns the line position of the text cursor
 221     private int getCurrentCursorLine() {
 222         int selectionStart = getSelectionStart();
 223         Layout layout = getLayout();
 224 
 225         if (!(selectionStart == -1)) {
 226             return layout.getLineForOffset(selectionStart);
 227         }
 228 
 229         return 0;
 230     }
 231 
 232     public void insertChecklist() {
 233         int start;
 234         int end;
 235         int lineNumber = getCurrentCursorLine();
 236         start = getLayout().getLineStart(lineNumber);
 237         if ((getSelectionEnd() &gt; getSelectionStart()) &amp;&amp; (!selectionIsOnSameLine())) {
 238             end = getSelectionEnd();
 239         } else {
 240             end = getLayout().getLineEnd(lineNumber);
 241         }
<abbr title=" 242         SpannableStringBuilder workingString = new SpannableStringBuilder(getText().subSequence(start, end));"> 242         SpannableStringBuilder workingString = new SpannableStringBuilder(getText().subSequence(start, enðŸ”µ</abbr>
 243         Editable editable = getText();
 244         if ((editable.length() &lt; start) || (editable.length() &lt; end)) {
 245             return;
 246         }
 247         int previousSelection = getSelectionStart();
<abbr title=" 248         CheckableSpan[] checkableSpans = workingString.getSpans(0, workingString.length(), CheckableSpan.class);"> 248         CheckableSpan[] checkableSpans = workingString.getSpans(0, workingString.length(), CheckableSpan.ðŸ”µ</abbr>
 249         if (checkableSpans.length &gt; 0) {
 250             // Remove any CheckableSpans found
 251             for (CheckableSpan span : checkableSpans) {
<abbr title=" 252                 workingString.replace(workingString.getSpanStart(span), workingString.getSpanEnd(span) + 1, &quot;&quot;);"> 252                 workingString.replace(workingString.getSpanStart(span), workingString.getSpanEnd(span) + ðŸ”µ</abbr>
 253                 workingString.removeSpan(span);
 254             }
 255             editable.replace(start, end, workingString);
 256             if (checkableSpans.length == 1) {
 257                 int newSelection = Math.max(previousSelection - CHECKBOX_LENGTH, 0);
 258                 if (editable.length() &gt;= newSelection) {
 259                     setSelection(newSelection);
 260                 }
 261             }
 262         } else {
 263             // Insert a checklist for each line
 264             String[] lines = workingString.toString().split(&quot;(?&lt;=\n)&quot;);
 265             StringBuilder resultString = new StringBuilder();
 266             for (String lineString : lines) {
 267                 // Preserve the spaces before the text
 268                 int leadingSpaceCount;
 269                 if (lineString.trim().length() == 0) {
 270                     // Only whitespace content, get count of spaces
 271                     leadingSpaceCount = lineString.length() - lineString.replaceAll(&quot; &quot;, &quot;&quot;).length();
 272                 } else {
 273                     // Get count of spaces up to first non-whitespace character
 274                     leadingSpaceCount = lineString.indexOf(lineString.trim());
 275                 }
 276                 if (leadingSpaceCount &gt; 0) {
 277                     resultString.append(new String(new char[leadingSpaceCount]).replace(&#x27;\u0000&#x27;, &#x27; &#x27;));
 278                     lineString = lineString.substring(leadingSpaceCount);
 279                 }
 280                 resultString.append(ChecklistUtils.UNCHECKED_MARKDOWN).append(&quot; &quot;).append(lineString);
 281             }
 282             editable.replace(start, end, resultString);
 283             int newSelection = Math.max(previousSelection, 0) + (lines.length * CHECKBOX_LENGTH);
 284             if (editable.length() &gt;= newSelection) {
 285                 setSelection(newSelection);
 286             }
 287         }
 288     }
 289 
 290     // Returns true if the current editor selection is on the same line
 291     private boolean selectionIsOnSameLine() {
 292         int selectionStart = getSelectionStart();
 293         int selectionEnd = getSelectionEnd();
 294         Layout layout = getLayout();
 295 
 296         if (selectionStart &gt;= 0 &amp;&amp; selectionEnd &gt;= 0) {
 297             return layout.getLineForOffset(selectionStart) == layout.getLineForOffset(selectionEnd);
 298         }
 299 
 300         return false;
 301     }
 302 
 303     public void fixLineSpacing() {
 304         // Prevents line heights from compacting
 305         // https://issuetracker.google.com/issues/37009353
 306         float lineSpacingExtra = getLineSpacingExtra();
 307         float lineSpacingMultiplier = getLineSpacingMultiplier();
 308         setLineSpacing(0.0f, 1.0f);
 309         setLineSpacing(lineSpacingExtra, lineSpacingMultiplier);
 310     }
 311 
 312     public interface OnSelectionChangedListener {
 313         public abstract void onSelectionChanged(int selStart, int selEnd);
 314     }
 315 
 316     // Replaces any CheckableSpans with their markdown counterpart (e.g. &#x27;- [ ]&#x27;)
 317     public String getPlainTextContent() {
 318         if (getText() == null) {
 319             return &quot;&quot;;
 320         }
 321 
 322         SpannableStringBuilder content = new SpannableStringBuilder(getText());
 323         CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 324         for(CheckableSpan span: spans) {
 325             int start = content.getSpanStart(span);
 326             int end = content.getSpanEnd(span);
 327             ((Editable) content).replace(
 328                     start,
 329                     end,
<abbr title=" 330                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN : ChecklistUtils.UNCHECKED_MARKDOWN);"> 330                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN : ChecklistUtils.UNCHECKED_MARKDOWðŸ”µ</abbr>
 331         }
 332 
 333         return content.toString();
 334     }
 335 
 336     // Replaces any CheckableSpans with their markdown preview counterpart (e.g. &#x27;- [\u2a2f]&#x27;)
 337     public String getPreviewTextContent() {
 338         if (getText() == null) {
 339             return &quot;&quot;;
 340         }
 341 
 342         SpannableStringBuilder content = new SpannableStringBuilder(getText());
 343         CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 344         for(CheckableSpan span: spans) {
 345             int start = content.getSpanStart(span);
 346             int end = content.getSpanEnd(span);
 347             ((Editable) content).replace(
 348                     start,
 349                     end,
<abbr title=" 350                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKED_MARKDOWN);"> 350                     span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKEDðŸ”µ</abbr>
 351         }
 352 
 353         return content.toString();
 354     }
 355 
 356     public void processChecklists() {
 357         if (getText().length() == 0 || getContext() == null) {
 358             return;
 359         }
 360 
 361         try {
 362             ChecklistUtils.addChecklistSpansForRegexAndColor(
 363                     getContext(),
 364                     getText(),
 365                     ChecklistUtils.CHECKLIST_REGEX_LINES,
 366                     R.color.text_title_disabled);
 367         } catch (Exception e) {
 368             e.printStackTrace();
 369         }
 370     }
 371 
 372     public void setOnCheckboxToggledListener(OnCheckboxToggledListener listener) {
 373         mOnCheckboxToggledListener = listener;
 374     }
 375 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote.widgets;
   2  
   3  import android.content.Context;
   4  import android.graphics.Rect;
   5  import android.graphics.drawable.Drawable;
   6  import android.os.Handler;
   7  import android.text.Editable;
   8  import android.text.Layout;
   9  import android.text.SpannableStringBuilder;
  10  import android.text.Spanned;
  11  import android.text.style.ImageSpan;
  12  import android.util.AttributeSet;
  13  import android.view.KeyEvent;
  14  
  15  import androidx.appcompat.widget.AppCompatEditText;




  16  import androidx.core.content.ContextCompat;
  17  
  18  import com.automattic.simplenote.R;

  19  import com.automattic.simplenote.utils.ChecklistUtils;
  20  import com.automattic.simplenote.utils.DisplayUtils;
  21  import com.automattic.simplenote.utils.DrawableUtils;



  22  
  23  import java.util.ArrayList;
  24  import java.util.List;
  25  
  26  public class SimplenoteEditText extends AppCompatEditText {












  27      private List&lt;OnSelectionChangedListener&gt; listeners;
  28      private OnCheckboxToggledListener mOnCheckboxToggledListener;
  29      private final int CHECKBOX_LENGTH = 2; // One CheckableSpan + a space character


























  30  
  31      public interface OnCheckboxToggledListener {
  32          void onCheckboxToggled();
  33      }
  34  
  35      public SimplenoteEditText(Context context) {
  36          super(context);
  37          listeners = new ArrayList&lt;&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  38 -        setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>

  39      }
  40  
  41      public SimplenoteEditText(Context context, AttributeSet attrs) {
  42          super(context, attrs);
  43          listeners = new ArrayList&lt;&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  44 -        setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>

  45      }
  46  
  47      public SimplenoteEditText(Context context, AttributeSet attrs, int defStyle) {
  48          super(context, attrs, defStyle);
  49          listeners = new ArrayList&lt;&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -        setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));</span>

  51      }
  52  
  53      public void addOnSelectionChangedListener(OnSelectionChangedListener o) {
  54          listeners.add(o);


















  55      }
  56  
  57      @Override
  58      protected void onSelectionChanged(int selStart, int selEnd) {
  59          super.onSelectionChanged(selStart, selEnd);
  60          if (listeners != null) {
  61              for (OnSelectionChangedListener l : listeners)
  62                  l.onSelectionChanged(selStart, selEnd);
  63          }
  64      }
  65  
  66      @Override
  67      public boolean onKeyPreIme(int keyCode, KeyEvent event) {
  68          if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
  69              clearFocus();
  70          }
  71  
  72          return super.onKeyPreIme(keyCode, event);
  73      }
  74  
  75      @Override
  76      protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
  77          if (focused) {
  78              setCursorVisible(true);
  79          }
  80  
  81          super.onFocusChanged(focused, direction, previouslyFocusedRect);
  82      }
  83  
  84      // Updates the ImageSpan drawable to the new checked state
  85      public void toggleCheckbox(final CheckableSpan checkableSpan) {
  86          setCursorVisible(false);
  87  
  88          final Editable editable = getText();
  89  
  90          final int checkboxStart = editable.getSpanStart(checkableSpan);
  91          final int checkboxEnd = editable.getSpanEnd(checkableSpan);
  92  
  93          final int selectionStart = getSelectionStart();
  94          final int selectionEnd = getSelectionEnd();
  95  
  96          final ImageSpan[] imageSpans = editable.getSpans(checkboxStart, checkboxEnd, ImageSpan.class);
  97          if (imageSpans.length &gt; 0) {
  98              // ImageSpans are static, so we need to remove the old one and replace :|
  99              Drawable iconDrawable = ContextCompat.getDrawable(getContext(),
 100                      checkableSpan.isChecked()
 101                              ? R.drawable.ic_checkbox_checked_24px
 102                              : R.drawable.ic_checkbox_unchecked_24px);
<abbr title=" 103              iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.text_title_disabled);"> 103              iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.text_title_dðŸ”µ</abbr>
 104              int iconSize = DisplayUtils.getChecklistIconSize(getContext());
 105              iconDrawable.setBounds(0, 0, iconSize, iconSize);
 106              final CenteredImageSpan newImageSpan = new CenteredImageSpan(getContext(), iconDrawable);
 107              new Handler().post(new Runnable() {
 108                  @Override
 109                  public void run() {
 110                      editable.setSpan(newImageSpan, checkboxStart, checkboxEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
 111                      editable.removeSpan(imageSpans[0]);
 112                      fixLineSpacing();
 113  
 114                      // Restore the selection
 115                      if (selectionStart &gt;= 0
 116                              &amp;&amp; selectionStart &lt;= editable.length()
 117                              &amp;&amp; selectionEnd &lt;= editable.length() &amp;&amp; hasFocus()) {
 118                          setSelection(selectionStart, selectionEnd);
 119                          setCursorVisible(true);
 120                      }
 121  
 122                      if (mOnCheckboxToggledListener != null) {
 123                          mOnCheckboxToggledListener.onCheckboxToggled();
 124                      }
 125                  }
 126              });
 127          }
 128      }
 129  
 130      // Returns the line position of the text cursor
 131      private int getCurrentCursorLine() {
 132          int selectionStart = getSelectionStart();
 133          Layout layout = getLayout();
 134  
 135          if (!(selectionStart == -1)) {
 136              return layout.getLineForOffset(selectionStart);
 137          }
 138  
 139          return 0;
 140      }
 141  
 142      public void insertChecklist() {
 143          int start, end;
 144          int lineNumber = getCurrentCursorLine();
 145          start = getLayout().getLineStart(lineNumber);
 146  
 147          if (getSelectionEnd() &gt; getSelectionStart() &amp;&amp; !selectionIsOnSameLine()) {
 148              end = getSelectionEnd();
 149          } else {
 150              end = getLayout().getLineEnd(lineNumber);
 151          }
 152  
 153          SpannableStringBuilder workingString = new SpannableStringBuilder(getText().subSequence(start, end));
 154          Editable editable = getText();
 155          if (editable.length() &lt; start || editable.length() &lt; end) {
 156              return;
 157          }
 158  
 159          int previousSelection = getSelectionStart();
 160          CheckableSpan[] checkableSpans = workingString.getSpans(0, workingString.length(), CheckableSpan.class);
 161          if (checkableSpans.length &gt; 0) {
 162              // Remove any CheckableSpans found
 163              for (CheckableSpan span: checkableSpans) {
 164                  workingString.replace(
 165                          workingString.getSpanStart(span),
 166                          workingString.getSpanEnd(span) + 1,
 167                          &quot;&quot;
 168                  );
 169                  workingString.removeSpan(span);
 170              }
 171  
 172              editable.replace(start, end, workingString);
 173  
 174              if (checkableSpans.length == 1) {
 175                  int newSelection = Math.max(previousSelection - CHECKBOX_LENGTH, 0);
 176                  if (editable.length() &gt;= newSelection) {
 177                      setSelection(newSelection);
 178                  }
 179              }
 180          } else {
 181              // Insert a checklist for each line
 182              String[] lines = workingString.toString().split(&quot;(?&lt;=\n)&quot;);
 183              StringBuilder resultString = new StringBuilder();
 184  
 185              for (String lineString: lines) {
 186                  // Preserve the spaces before the text
 187                  int leadingSpaceCount;
 188                  if (lineString.trim().length() == 0) {
 189                      // Only whitespace content, get count of spaces
 190                      leadingSpaceCount = lineString.length() - lineString.replaceAll(&quot; &quot;, &quot;&quot;).length();
 191                  } else {
 192                      // Get count of spaces up to first non-whitespace character
 193                      leadingSpaceCount = lineString.indexOf(lineString.trim());
 194                  }
 195  
 196                  if (leadingSpaceCount &gt; 0) {
 197                      resultString.append(new String(new char[leadingSpaceCount]).replace(&#x27;\0&#x27;, &#x27; &#x27;));
 198                      lineString = lineString.substring(leadingSpaceCount);
 199                  }
 200  
 201                  resultString
 202                          .append(ChecklistUtils.UNCHECKED_MARKDOWN)
 203                          .append(&quot; &quot;)
 204                          .append(lineString);
 205              }
 206  
 207              editable.replace(start, end, resultString);
 208  
 209              int newSelection = Math.max(previousSelection, 0) + (lines.length * CHECKBOX_LENGTH);
 210              if (editable.length() &gt;= newSelection) {
 211                  setSelection(newSelection);
 212              }
 213          }
 214      }
 215  
 216      // Returns true if the current editor selection is on the same line
 217      private boolean selectionIsOnSameLine() {
 218          int selectionStart = getSelectionStart();
 219          int selectionEnd = getSelectionEnd();
 220          Layout layout = getLayout();
 221  
 222          if (selectionStart &gt;= 0 &amp;&amp; selectionEnd &gt;= 0) {
 223              return layout.getLineForOffset(selectionStart) == layout.getLineForOffset(selectionEnd);
 224          }
 225  
 226          return false;
 227      }
 228  
 229      public void fixLineSpacing() {
 230          // Prevents line heights from compacting
 231          // https://issuetracker.google.com/issues/37009353
 232          float lineSpacingExtra = getLineSpacingExtra();
 233          float lineSpacingMultiplier = getLineSpacingMultiplier();
 234          setLineSpacing(0.0f, 1.0f);
 235          setLineSpacing(lineSpacingExtra, lineSpacingMultiplier);
 236      }
 237  
 238      public interface OnSelectionChangedListener {
 239          void onSelectionChanged(int selStart, int selEnd);
 240      }
 241  
 242      // Replaces any CheckableSpans with their markdown counterpart (e.g. &#x27;- [ ]&#x27;)
 243      public String getPlainTextContent() {
 244          if (getText() == null) {
 245              return &quot;&quot;;
 246          }
 247  
 248          SpannableStringBuilder content = new SpannableStringBuilder(getText());
 249          CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 250          for(CheckableSpan span: spans) {
 251              int start = content.getSpanStart(span);
 252              int end = content.getSpanEnd(span);
 253              ((Editable) content).replace(
 254                      start,
 255                      end,
 256                      span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN : ChecklistUtils.UNCHECKED_MARKDOWN);
 257          }
 258  
 259          return content.toString();
 260      }
 261  
 262      // Replaces any CheckableSpans with their markdown preview counterpart (e.g. &#x27;- [\u2a2f]&#x27;)
 263      public String getPreviewTextContent() {
 264          if (getText() == null) {
 265              return &quot;&quot;;
 266          }
 267  
 268          SpannableStringBuilder content = new SpannableStringBuilder(getText());
 269          CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 270          for(CheckableSpan span: spans) {
 271              int start = content.getSpanStart(span);
 272              int end = content.getSpanEnd(span);
 273              ((Editable) content).replace(
 274                      start,
 275                      end,
<abbr title=" 276                      span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKED_MARKDOWN);"> 276                      span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKED_MARKDOWNðŸ”µ</abbr>
 277          }
 278  
 279          return content.toString();
 280      }
 281  
 282  
 283      public void processChecklists() {
 284          if (getText().length() == 0 || getContext() == null) {
 285              return;
 286          }
 287  
 288          try {
 289              ChecklistUtils.addChecklistSpansForRegexAndColor(
 290                      getContext(),
 291                      getText(),
 292                      ChecklistUtils.CHECKLIST_REGEX_LINES,
 293                      R.color.text_title_disabled);
 294          } catch (Exception e) {
 295              e.printStackTrace();
 296          }
 297      }
 298  
 299      public void setOnCheckboxToggledListener(OnCheckboxToggledListener listener) {
 300          mOnCheckboxToggledListener = listener;
 301      }
 302  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote.widgets;
   2  
   3  import android.content.Context;
   4  import android.graphics.Rect;
   5  import android.graphics.drawable.Drawable;
   6  import android.os.Handler;
   7  import android.text.Editable;
   8  import android.text.Layout;
   9  import android.text.SpannableStringBuilder;
  10  import android.text.Spanned;
  11  import android.text.style.ImageSpan;
  12  import android.util.AttributeSet;
  13  import android.view.KeyEvent;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  14 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  15 -import androidx.appcompat.widget.AppCompatEditText;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  16 +import android.view.View;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  17 +import android.widget.AdapterView;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  18 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  19 +import androidx.appcompat.widget.AppCompatMultiAutoCompleteTextView;</span>
  20  import androidx.core.content.ContextCompat;
  21  
  22  import com.automattic.simplenote.R;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import com.automattic.simplenote.models.Note;</span>
  24  import com.automattic.simplenote.utils.ChecklistUtils;
  25  import com.automattic.simplenote.utils.DisplayUtils;
  26  import com.automattic.simplenote.utils.DrawableUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import com.automattic.simplenote.utils.LinkTokenizer;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import com.automattic.simplenote.utils.SimplenoteLinkify;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import com.simperium.client.Bucket;</span>
  30  
  31  import java.util.ArrayList;
  32  import java.util.List;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -public class SimplenoteEditText extends AppCompatEditText {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import java.util.regex.Matcher;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import java.util.regex.Pattern;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_ID;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 +import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  41 +public class SimplenoteEditText extends AppCompatMultiAutoCompleteTextView implements AdapterView.OnItemClickListener {">  41 +public class SimplenoteEditText extends AppCompatMultiAutoCompleteTextView implements AdapterView.OnItemClickListeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  42 +    private static final Pattern INTERNOTE_LINK_PATTERN_EDIT = Pattern.compile(&quot;([^]]*)(]\\(&quot; + SIMPLENOTE_LINK_PREFIX + SIMPLENOTE_LINK_ID + &quot;\\))&quot;);">  42 +    private static final Pattern INTERNOTE_LINK_PATTERN_EDIT = Pattern.compile(&quot;([^]]*)(]\\(&quot; + SIMPLENOTE_LINK_PRðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  43 +    private static final Pattern INTERNOTE_LINK_PATTERN_FULL = Pattern.compile(&quot;(?s)(.)*(\\[)&quot; + INTERNOTE_LINK_PATTERN_EDIT);">  43 +    private static final Pattern INTERNOTE_LINK_PATTERN_FULL = Pattern.compile(&quot;(?s)(.)*(\\[)&quot; + INTERNOTE_LINK_PAðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +    private static final int CHECKBOX_LENGTH = 2; // one ClickableSpan character + one space character</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +    private LinkTokenizer mTokenizer;</span>
  47      private List&lt;OnSelectionChangedListener&gt; listeners;
  48      private OnCheckboxToggledListener mOnCheckboxToggledListener;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -    private final int CHECKBOX_LENGTH = 2; // One CheckableSpan + a space character</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  52 +    public boolean enoughToFilter() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +        String substringCursor = getText().toString().substring(getSelectionEnd());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +        Matcher matcherEdit = INTERNOTE_LINK_PATTERN_EDIT.matcher(substringCursor);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +        // When an internote link title is being edited, don&#x27;t show an autocomplete popup.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +        if (matcherEdit.lookingAt()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +            String substringEdit = substringCursor.substring(0, matcherEdit.end());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +            Matcher matcherFull = INTERNOTE_LINK_PATTERN_FULL.matcher(substringEdit);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +            if (!matcherFull.lookingAt()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +                return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  66 +        Editable text = getText();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +        int end = getSelectionEnd();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  68 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +        if (end &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +        int start = mTokenizer.findTokenStart(text, end);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +        return start &gt; 0 &amp;&amp; end - start &gt;= 1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +    }</span>
  76  
  77      public interface OnCheckboxToggledListener {
  78          void onCheckboxToggled();
  79      }
  80  
  81      public SimplenoteEditText(Context context) {
  82          super(context);
  83          listeners = new ArrayList&lt;&gt;();
  84          setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +        setLinkTokenizer();</span>
  86      }
  87  
  88      public SimplenoteEditText(Context context, AttributeSet attrs) {
  89          super(context, attrs);
  90          listeners = new ArrayList&lt;&gt;();
  91          setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +        setLinkTokenizer();</span>
  93      }
  94  
  95      public SimplenoteEditText(Context context, AttributeSet attrs, int defStyle) {
  96          super(context, attrs, defStyle);
  97          listeners = new ArrayList&lt;&gt;();
  98          setTypeface(TypefaceCache.getTypeface(context, TypefaceCache.TYPEFACE_NAME_ROBOTO_REGULAR));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +        setLinkTokenizer();</span>
 100      }
 101  
 102      public void addOnSelectionChangedListener(OnSelectionChangedListener o) {
 103          listeners.add(o);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +    private void setLinkTokenizer() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 107 +        mTokenizer = new LinkTokenizer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 108 +        setOnItemClickListener(this);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +        setTokenizer(mTokenizer);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +        setThreshold(1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +        @SuppressWarnings(&quot;unchecked&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +        Bucket.ObjectCursor&lt;Note&gt; cursor = (Bucket.ObjectCursor&lt;Note&gt;) parent.getAdapter().getItem(position);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +        String key = cursor.getString(cursor.getColumnIndex(Note.KEY_PROPERTY)).replace(&quot;note&quot;, &quot;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +        String text = SimplenoteLinkify.getNoteLink(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +        int start = Math.max(getSelectionStart(), 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +        int end = Math.max(getSelectionEnd(), 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +        getEditableText().replace(Math.min(start, end), Math.max(start, end), text, 0, text.length());</span>
 122      }
 123  
 124      @Override
 125      protected void onSelectionChanged(int selStart, int selEnd) {
 126          super.onSelectionChanged(selStart, selEnd);
 127          if (listeners != null) {
 128              for (OnSelectionChangedListener l : listeners)
 129                  l.onSelectionChanged(selStart, selEnd);
 130          }
 131      }
 132  
 133      @Override
 134      public boolean onKeyPreIme(int keyCode, KeyEvent event) {
 135          if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
 136              clearFocus();
 137          }
 138  
 139          return super.onKeyPreIme(keyCode, event);
 140      }
 141  
 142      @Override
 143      protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
 144          if (focused) {
 145              setCursorVisible(true);
 146          }
 147  
 148          super.onFocusChanged(focused, direction, previouslyFocusedRect);
 149      }
 150  
 151      // Updates the ImageSpan drawable to the new checked state
 152      public void toggleCheckbox(final CheckableSpan checkableSpan) {
 153          setCursorVisible(false);
 154  
 155          final Editable editable = getText();
 156  
 157          final int checkboxStart = editable.getSpanStart(checkableSpan);
 158          final int checkboxEnd = editable.getSpanEnd(checkableSpan);
 159  
 160          final int selectionStart = getSelectionStart();
 161          final int selectionEnd = getSelectionEnd();
 162  
 163          final ImageSpan[] imageSpans = editable.getSpans(checkboxStart, checkboxEnd, ImageSpan.class);
 164          if (imageSpans.length &gt; 0) {
 165              // ImageSpans are static, so we need to remove the old one and replace :|
 166              Drawable iconDrawable = ContextCompat.getDrawable(getContext(),
 167                      checkableSpan.isChecked()
 168                              ? R.drawable.ic_checkbox_checked_24px
 169                              : R.drawable.ic_checkbox_unchecked_24px);
<abbr title=" 170              iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.text_title_disabled);"> 170              iconDrawable = DrawableUtils.tintDrawableWithResource(getContext(), iconDrawable, R.color.text_title_dðŸ”µ</abbr>
 171              int iconSize = DisplayUtils.getChecklistIconSize(getContext());
 172              iconDrawable.setBounds(0, 0, iconSize, iconSize);
 173              final CenteredImageSpan newImageSpan = new CenteredImageSpan(getContext(), iconDrawable);
 174              new Handler().post(new Runnable() {
 175                  @Override
 176                  public void run() {
 177                      editable.setSpan(newImageSpan, checkboxStart, checkboxEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
 178                      editable.removeSpan(imageSpans[0]);
 179                      fixLineSpacing();
 180  
 181                      // Restore the selection
 182                      if (selectionStart &gt;= 0
 183                              &amp;&amp; selectionStart &lt;= editable.length()
 184                              &amp;&amp; selectionEnd &lt;= editable.length() &amp;&amp; hasFocus()) {
 185                          setSelection(selectionStart, selectionEnd);
 186                          setCursorVisible(true);
 187                      }
 188  
 189                      if (mOnCheckboxToggledListener != null) {
 190                          mOnCheckboxToggledListener.onCheckboxToggled();
 191                      }
 192                  }
 193              });
 194          }
 195      }
 196  
 197      // Returns the line position of the text cursor
 198      private int getCurrentCursorLine() {
 199          int selectionStart = getSelectionStart();
 200          Layout layout = getLayout();
 201  
 202          if (!(selectionStart == -1)) {
 203              return layout.getLineForOffset(selectionStart);
 204          }
 205  
 206          return 0;
 207      }
 208  
 209      public void insertChecklist() {
 210          int start, end;
 211          int lineNumber = getCurrentCursorLine();
 212          start = getLayout().getLineStart(lineNumber);
 213  
 214          if (getSelectionEnd() &gt; getSelectionStart() &amp;&amp; !selectionIsOnSameLine()) {
 215              end = getSelectionEnd();
 216          } else {
 217              end = getLayout().getLineEnd(lineNumber);
 218          }
 219  
 220          SpannableStringBuilder workingString = new SpannableStringBuilder(getText().subSequence(start, end));
 221          Editable editable = getText();
 222          if (editable.length() &lt; start || editable.length() &lt; end) {
 223              return;
 224          }
 225  
 226          int previousSelection = getSelectionStart();
 227          CheckableSpan[] checkableSpans = workingString.getSpans(0, workingString.length(), CheckableSpan.class);
 228          if (checkableSpans.length &gt; 0) {
 229              // Remove any CheckableSpans found
 230              for (CheckableSpan span: checkableSpans) {
 231                  workingString.replace(
 232                          workingString.getSpanStart(span),
 233                          workingString.getSpanEnd(span) + 1,
 234                          &quot;&quot;
 235                  );
 236                  workingString.removeSpan(span);
 237              }
 238  
 239              editable.replace(start, end, workingString);
 240  
 241              if (checkableSpans.length == 1) {
 242                  int newSelection = Math.max(previousSelection - CHECKBOX_LENGTH, 0);
 243                  if (editable.length() &gt;= newSelection) {
 244                      setSelection(newSelection);
 245                  }
 246              }
 247          } else {
 248              // Insert a checklist for each line
 249              String[] lines = workingString.toString().split(&quot;(?&lt;=\n)&quot;);
 250              StringBuilder resultString = new StringBuilder();
 251  
 252              for (String lineString: lines) {
 253                  // Preserve the spaces before the text
 254                  int leadingSpaceCount;
 255                  if (lineString.trim().length() == 0) {
 256                      // Only whitespace content, get count of spaces
 257                      leadingSpaceCount = lineString.length() - lineString.replaceAll(&quot; &quot;, &quot;&quot;).length();
 258                  } else {
 259                      // Get count of spaces up to first non-whitespace character
 260                      leadingSpaceCount = lineString.indexOf(lineString.trim());
 261                  }
 262  
 263                  if (leadingSpaceCount &gt; 0) {
 264                      resultString.append(new String(new char[leadingSpaceCount]).replace(&#x27;\0&#x27;, &#x27; &#x27;));
 265                      lineString = lineString.substring(leadingSpaceCount);
 266                  }
 267  
 268                  resultString
 269                          .append(ChecklistUtils.UNCHECKED_MARKDOWN)
 270                          .append(&quot; &quot;)
 271                          .append(lineString);
 272              }
 273  
 274              editable.replace(start, end, resultString);
 275  
 276              int newSelection = Math.max(previousSelection, 0) + (lines.length * CHECKBOX_LENGTH);
 277              if (editable.length() &gt;= newSelection) {
 278                  setSelection(newSelection);
 279              }
 280          }
 281      }
 282  
 283      // Returns true if the current editor selection is on the same line
 284      private boolean selectionIsOnSameLine() {
 285          int selectionStart = getSelectionStart();
 286          int selectionEnd = getSelectionEnd();
 287          Layout layout = getLayout();
 288  
 289          if (selectionStart &gt;= 0 &amp;&amp; selectionEnd &gt;= 0) {
 290              return layout.getLineForOffset(selectionStart) == layout.getLineForOffset(selectionEnd);
 291          }
 292  
 293          return false;
 294      }
 295  
 296      public void fixLineSpacing() {
 297          // Prevents line heights from compacting
 298          // https://issuetracker.google.com/issues/37009353
 299          float lineSpacingExtra = getLineSpacingExtra();
 300          float lineSpacingMultiplier = getLineSpacingMultiplier();
 301          setLineSpacing(0.0f, 1.0f);
 302          setLineSpacing(lineSpacingExtra, lineSpacingMultiplier);
 303      }
 304  
 305      public interface OnSelectionChangedListener {
 306          void onSelectionChanged(int selStart, int selEnd);
 307      }
 308  
 309      // Replaces any CheckableSpans with their markdown counterpart (e.g. &#x27;- [ ]&#x27;)
 310      public String getPlainTextContent() {
 311          if (getText() == null) {
 312              return &quot;&quot;;
 313          }
 314  
 315          SpannableStringBuilder content = new SpannableStringBuilder(getText());
 316          CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 317          for(CheckableSpan span: spans) {
 318              int start = content.getSpanStart(span);
 319              int end = content.getSpanEnd(span);
 320              ((Editable) content).replace(
 321                      start,
 322                      end,
 323                      span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN : ChecklistUtils.UNCHECKED_MARKDOWN);
 324          }
 325  
 326          return content.toString();
 327      }
 328  
 329      // Replaces any CheckableSpans with their markdown preview counterpart (e.g. &#x27;- [\u2a2f]&#x27;)
 330      public String getPreviewTextContent() {
 331          if (getText() == null) {
 332              return &quot;&quot;;
 333          }
 334  
 335          SpannableStringBuilder content = new SpannableStringBuilder(getText());
 336          CheckableSpan[] spans = content.getSpans(0, content.length(), CheckableSpan.class);
 337          for(CheckableSpan span: spans) {
 338              int start = content.getSpanStart(span);
 339              int end = content.getSpanEnd(span);
 340              ((Editable) content).replace(
 341                      start,
 342                      end,
<abbr title=" 343                      span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKED_MARKDOWN);"> 343                      span.isChecked() ? ChecklistUtils.CHECKED_MARKDOWN_PREVIEW : ChecklistUtils.UNCHECKED_MARKDOWNðŸ”µ</abbr>
 344          }
 345  
 346          return content.toString();
 347      }
 348  
 349  
 350      public void processChecklists() {
 351          if (getText().length() == 0 || getContext() == null) {
 352              return;
 353          }
 354  
 355          try {
 356              ChecklistUtils.addChecklistSpansForRegexAndColor(
 357                      getContext(),
 358                      getText(),
 359                      ChecklistUtils.CHECKLIST_REGEX_LINES,
 360                      R.color.text_title_disabled);
 361          } catch (Exception e) {
 362              e.printStackTrace();
 363          }
 364      }
 365  
 366      public void setOnCheckboxToggledListener(OnCheckboxToggledListener listener) {
 367          mOnCheckboxToggledListener = listener;
 368      }
 369  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            