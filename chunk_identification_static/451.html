<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>451</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    451
                    <a href="450.html">prev</a>
                    <a href="452.html">next</a>
                    <a href="451_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_5553ee5c6410a412ab4ed61d9499805adee8995a_mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a:mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a^1:mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a^2:mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e0a10435dcb243a911c0405daebc6aa667d5119d:mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.mongo;
  20 
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.FieldInfo;
  23 import com.dtstack.flink.sql.side.JoinInfo;
  24 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25 import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  26 import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
  27 import com.dtstack.flink.sql.util.RowDataComplete;
  28 import com.google.common.collect.Lists;
  29 import com.google.common.collect.Maps;
  30 import com.mongodb.BasicDBObject;
  31 import com.mongodb.MongoClient;
  32 import com.mongodb.MongoClientURI;
  33 import com.mongodb.client.FindIterable;
  34 import com.mongodb.client.MongoCollection;
  35 import com.mongodb.client.MongoCursor;
  36 import com.mongodb.client.MongoDatabase;
  37 import org.apache.calcite.sql.JoinType;
  38 import org.apache.commons.collections.CollectionUtils;
  39 import org.apache.commons.lang3.StringUtils;
  40 import org.apache.flink.api.java.tuple.Tuple2;
  41 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  42 import org.apache.flink.table.dataformat.BaseRow;
  43 import org.apache.flink.types.Row;
  44 import org.apache.flink.util.Collector;
  45 import org.bson.Document;
  46 import org.slf4j.Logger;
  47 import org.slf4j.LoggerFactory;
  48 
  49 import java.sql.SQLException;
  50 import java.util.Calendar;
  51 import java.util.List;
  52 import java.util.Map;
  53 import java.util.concurrent.atomic.AtomicReference;
  54 
  55 /**
  56  * Reason:
  57  * Date: 2018/11/6
  58  *
  59  * @author xuqianjin
  60  */
  61 public class MongoAllReqRow extends BaseAllReqRow {
  62 
  63     private static final long serialVersionUID = -675332795591842778L;
  64 
  65     private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  66 
  67     private static final int CONN_RETRY_NUM = 3;
  68 
  69     private static final int FETCH_SIZE = 1000;
  70 
  71     private MongoClient mongoClient;
  72 
  73     private MongoDatabase db;
  74 
  75     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  76 
<abbr title="  77     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  77     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, A🔵</abbr>
  78         super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  79     }
  80 
  81     @Override
  82     public Row fillData(Row input, Object sideInput) {
  83         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  84         Row row = new Row(sideInfo.getOutFieldInfoList().size());
  85         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  86             Object obj = input.getField(entry.getValue());
  87 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  88             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
  89 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  90             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  90             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  91 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  92             //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  92             //Type information for indicating event or processing time. However, it behaves like a regula🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94                 obj = ((Timestamp) obj).getTime();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97         }</span>
  98 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  99             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  99             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 100 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 101             //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 101             //Type information for indicating event or processing time. However, it behaves like a regula🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 102             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 103                 //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 104                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());"> 104                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime())🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 105             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 106 </span>
 107 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 108             row.setField(entry.getKey(), obj);
 109         }
 110 
 111         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
 112             if (cacheInfo == null) {
 113                 row.setField(entry.getKey(), null);
 114             } else {
 115                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 116             }
 117         }
 118 
 119         return row;
 120     }
 121 
 122     @Override
 123     protected void initCache() throws SQLException {
 124         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 125         cacheRef.set(newCache);
 126         loadData(newCache);
 127     }
 128 
 129     @Override
 130     protected void reloadCache() {
 131         //reload cacheRef and replace to old cacheRef
 132         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 133         try {
 134             loadData(newCache);
 135         } catch (SQLException e) {
 136             LOG.error(&quot;&quot;, e);
 137         }
 138 
 139         cacheRef.set(newCache);
 140         LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 141     }
 142 
 143     @Override
 144     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
 145         List&lt;Object&gt; inputParams = Lists.newArrayList();
 146         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 147             Object equalObj = input.getField(conValIndex);
 148             if (equalObj == null) {
 149                 if (sideInfo.getJoinType() == JoinType.LEFT) {
 150                     Row data = fillData(input, null);
 151                     RowDataComplete.collectRow(out, data);
 152                 }
 153                 return;
 154             }
 155             inputParams.add(equalObj);
 156         }
 157 
 158         String key = buildKey(inputParams);
 159         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 160         if (CollectionUtils.isEmpty(cacheList)) {
 161             if (sideInfo.getJoinType() == JoinType.LEFT) {
 162                 Row row = fillData(input, null);
 163                 RowDataComplete.collectRow(out, row);
 164             } else {
 165                 return;
 166             }
 167 
 168             return;
 169         }
 170 
 171         for (Map&lt;String, Object&gt; one : cacheList) {
 172             Row row = fillData(input, one);
 173             RowDataComplete.collectRow(out, row);
 174         }
 175     }
 176 
 177     private String buildKey(List&lt;Object&gt; equalValList) {
 178         StringBuilder sb = new StringBuilder(&quot;&quot;);
 179         for (Object equalVal : equalValList) {
 180             sb.append(equalVal).append(&quot;_&quot;);
 181         }
 182 
 183         return sb.toString();
 184     }
 185 
 186     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 187         StringBuilder sb = new StringBuilder(&quot;&quot;);
 188         for (String equalField : equalFieldList) {
 189             sb.append(val.get(equalField)).append(&quot;_&quot;);
 190         }
 191 
 192         return sb.toString();
 193     }
 194 
<abbr title=" 195     private MongoCollection getConn(String host, String userName, String password, String database, String tableName) {"> 195     private MongoCollection getConn(String host, String userName, String password, String database, Strin🔵</abbr>
 196 
 197         MongoCollection dbCollection;
 198         mongoClient = new MongoClient(new MongoClientURI(getConnectionUrl(host, userName, password)));
 199         db = mongoClient.getDatabase(database);
 200         dbCollection = db.getCollection(tableName, Document.class);
 201         return dbCollection;
 202 
 203     }
 204 
 205     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 206         MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 207         MongoCollection dbCollection = null;
 208 
 209         try {
 210             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 211                 try {
<abbr title=" 212                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.getPassword(),"> 212                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.get🔵</abbr>
 213                             tableInfo.getDatabase(), tableInfo.getTableName());
 214                     break;
 215                 } catch (Exception e) {
 216                     if (i == CONN_RETRY_NUM - 1) {
 217                         throw new RuntimeException(&quot;&quot;, e);
 218                     }
 219 
 220                     try {
<abbr title=" 221                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 221                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getU🔵</abbr>
 222                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 223                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 224                     } catch (InterruptedException e1) {
 225                         LOG.error(&quot;&quot;, e1);
 226                     }
 227                 }
 228             }
 229 
 230             //load data from table
 231             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 232             BasicDBObject basicDBObject = new BasicDBObject();
 233             for (String selectField : sideFieldNames) {
 234                 basicDBObject.append(selectField, 1);
 235             }
 236             BasicDBObject filterObject = new BasicDBObject();
 237             try {
 238                 // 填充谓词
 239                 sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 240                     BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 241                     if (null != filterCondition) {
 242                         filterObject.append(info.getFieldName(), filterCondition);
 243                     }
 244                     return info;
 245                 }).count();
 246             } catch (Exception e) {
 247                 LOG.info(&quot;add predicate infoes error &quot;, e);
 248             }
 249 
 250 
<abbr title=" 251             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 251             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObjec🔵</abbr>
 252             MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 253             while (mongoCursor.hasNext()) {
 254                 Document doc = mongoCursor.next();
 255                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 256                 for (String fieldName : sideFieldNames) {
 257                     oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 258                 }
 259                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 260                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 260                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArray🔵</abbr>
 261                 list.add(oneRow);
 262             }
 263         } catch (Exception e) {
 264             LOG.error(&quot;&quot;, e);
 265         } finally {
 266             if (mongoClient != null) {
 267                 mongoClient.close();
 268             }
 269         }
 270     }
 271     private String getConnectionUrl(String address, String userName, String password){
 272         if(address.startsWith(&quot;mongodb://&quot;) || address.startsWith(&quot;mongodb+srv://&quot;)){
 273             return  address;
 274         }
 275         if (StringUtils.isNotBlank(userName) &amp;&amp; StringUtils.isNotBlank(password)) {
 276             return String.format(&quot;mongodb://%s:%s@%s&quot;, userName, password, address);
 277         }
 278         return String.format(&quot;mongodb://%s&quot;, address);
 279     }
 280 
 281 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.mongo;
  20 
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.FieldInfo;
  23 import com.dtstack.flink.sql.side.JoinInfo;
  24 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25 import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  26 import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
  27 import com.dtstack.flink.sql.util.RowDataComplete;
  28 import com.google.common.collect.Lists;
  29 import com.google.common.collect.Maps;
  30 import com.mongodb.BasicDBObject;
  31 import com.mongodb.MongoClient;
  32 import com.mongodb.MongoClientURI;
  33 import com.mongodb.client.FindIterable;
  34 import com.mongodb.client.MongoCollection;
  35 import com.mongodb.client.MongoCursor;
  36 import com.mongodb.client.MongoDatabase;
  37 import org.apache.calcite.sql.JoinType;
  38 import org.apache.commons.collections.CollectionUtils;
  39 import org.apache.commons.lang3.StringUtils;
  40 import org.apache.flink.api.java.tuple.Tuple2;
  41 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  42 import org.apache.flink.table.dataformat.BaseRow;
  43 import org.apache.flink.types.Row;
  44 import org.apache.flink.util.Collector;
  45 import org.bson.Document;
  46 import org.slf4j.Logger;
  47 import org.slf4j.LoggerFactory;
  48 
  49 import java.sql.SQLException;
  50 import java.util.Calendar;
  51 import java.util.List;
  52 import java.util.Map;
  53 import java.util.concurrent.atomic.AtomicReference;
  54 
  55 /**
  56  * Reason:
  57  * Date: 2018/11/6
  58  *
  59  * @author xuqianjin
  60  */
  61 public class MongoAllReqRow extends BaseAllReqRow {
  62 
  63     private static final long serialVersionUID = -675332795591842778L;
  64 
  65     private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  66 
  67     private static final int CONN_RETRY_NUM = 3;
  68 
  69     private static final int FETCH_SIZE = 1000;
  70 
  71     private MongoClient mongoClient;
  72 
  73     private MongoDatabase db;
  74 
  75     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  76 
<abbr title="  77     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  77     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, A🔵</abbr>
  78         super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  79     }
  80 
  81     @Override
  82     public Row fillData(Row input, Object sideInput) {
  83         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  84         Row row = new Row(sideInfo.getOutFieldInfoList().size());
  85         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  86             Object obj = input.getField(entry.getValue());
  87 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  88             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
  89 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  90             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  90             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  91 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  92             //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  92             //Type information for indicating event or processing time. However, it behaves like a regula🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94                 obj = ((Timestamp) obj).getTime();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97         }</span>
  98 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  99             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  99             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 100 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 101             //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 101             //Type information for indicating event or processing time. However, it behaves like a regula🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 102             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 103                 //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 104                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());"> 104                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime())🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 105             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 106 </span>
 107 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 108             row.setField(entry.getKey(), obj);
 109         }
 110 
 111         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
 112             if (cacheInfo == null) {
 113                 row.setField(entry.getKey(), null);
 114             } else {
 115                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 116             }
 117         }
 118 
 119         return row;
 120     }
 121 
 122     @Override
 123     protected void initCache() throws SQLException {
 124         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 125         cacheRef.set(newCache);
 126         loadData(newCache);
 127     }
 128 
 129     @Override
 130     protected void reloadCache() {
 131         //reload cacheRef and replace to old cacheRef
 132         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 133         try {
 134             loadData(newCache);
 135         } catch (SQLException e) {
 136             LOG.error(&quot;&quot;, e);
 137         }
 138 
 139         cacheRef.set(newCache);
 140         LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 141     }
 142 
 143     @Override
 144     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
 145         List&lt;Object&gt; inputParams = Lists.newArrayList();
 146         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 147             Object equalObj = input.getField(conValIndex);
 148             if (equalObj == null) {
 149                 if(sideInfo.getJoinType() == JoinType.LEFT){
 150                     Row data = fillData(input, null);
 151                     RowDataComplete.collectRow(out, data);
 152                 }
 153                 return;
 154             }
 155             inputParams.add(equalObj);
 156         }
 157 
 158         String key = buildKey(inputParams);
 159         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 160         if (CollectionUtils.isEmpty(cacheList)) {
 161             if (sideInfo.getJoinType() == JoinType.LEFT) {
 162                 Row row = fillData(input, null);
 163                 RowDataComplete.collectRow(out, row);
 164             } else {
 165                 return;
 166             }
 167 
 168             return;
 169         }
 170 
 171         for (Map&lt;String, Object&gt; one : cacheList) {
 172             Row row = fillData(input, one);
 173             RowDataComplete.collectRow(out, row);
 174         }
 175     }
 176 
 177     private String buildKey(List&lt;Object&gt; equalValList) {
 178         StringBuilder sb = new StringBuilder(&quot;&quot;);
 179         for (Object equalVal : equalValList) {
 180             sb.append(equalVal).append(&quot;_&quot;);
 181         }
 182 
 183         return sb.toString();
 184     }
 185 
 186     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 187         StringBuilder sb = new StringBuilder(&quot;&quot;);
 188         for (String equalField : equalFieldList) {
 189             sb.append(val.get(equalField)).append(&quot;_&quot;);
 190         }
 191 
 192         return sb.toString();
 193     }
 194 
<abbr title=" 195     private MongoCollection getConn(String host, String userName, String password, String database, String tableName) {"> 195     private MongoCollection getConn(String host, String userName, String password, String database, Strin🔵</abbr>
 196 
 197         MongoCollection dbCollection;
 198         mongoClient = new MongoClient(new MongoClientURI(getConnectionUrl(host, userName, password)));
 199         db = mongoClient.getDatabase(database);
 200         dbCollection = db.getCollection(tableName, Document.class);
 201         return dbCollection;
 202 
 203     }
 204 
 205     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 206         MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 207         MongoCollection dbCollection = null;
 208 
 209         try {
 210             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 211                 try {
<abbr title=" 212                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.getPassword(),"> 212                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.get🔵</abbr>
 213                             tableInfo.getDatabase(), tableInfo.getTableName());
 214                     break;
 215                 } catch (Exception e) {
 216                     if (i == CONN_RETRY_NUM - 1) {
 217                         throw new RuntimeException(&quot;&quot;, e);
 218                     }
 219 
 220                     try {
<abbr title=" 221                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 221                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getU🔵</abbr>
 222                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 223                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 224                     } catch (InterruptedException e1) {
 225                         LOG.error(&quot;&quot;, e1);
 226                     }
 227                 }
 228             }
 229 
 230             //load data from table
 231             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 232             BasicDBObject basicDBObject = new BasicDBObject();
 233             for (String selectField : sideFieldNames) {
 234                 basicDBObject.append(selectField, 1);
 235             }
 236             BasicDBObject filterObject = new BasicDBObject();
 237             try {
 238                 // 填充谓词
 239                 sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 240                     BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 241                     if (null != filterCondition) {
 242                         filterObject.append(info.getFieldName(), filterCondition);
 243                     }
 244                     return info;
 245                 }).count();
 246             } catch (Exception e) {
 247                 LOG.info(&quot;add predicate infoes error &quot;, e);
 248             }
 249 
 250 
<abbr title=" 251             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 251             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObjec🔵</abbr>
 252             MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 253             while (mongoCursor.hasNext()) {
 254                 Document doc = mongoCursor.next();
 255                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 256                 for (String fieldName : sideFieldNames) {
 257                     oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 258                 }
 259                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 260                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 260                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArray🔵</abbr>
 261                 list.add(oneRow);
 262             }
 263         } catch (Exception e) {
 264             LOG.error(&quot;&quot;, e);
 265         } finally {
 266             if (mongoClient != null) {
 267                 mongoClient.close();
 268             }
 269         }
 270     }
 271     private String getConnectionUrl(String address, String userName, String password){
 272         if(address.startsWith(&quot;mongodb://&quot;) || address.startsWith(&quot;mongodb+srv://&quot;)){
 273             return  address;
 274         }
 275         if (StringUtils.isNotBlank(userName) &amp;&amp; StringUtils.isNotBlank(password)) {
 276             return String.format(&quot;mongodb://%s:%s@%s&quot;, userName, password, address);
 277         }
 278         return String.format(&quot;mongodb://%s&quot;, address);
 279     }
 280 
 281 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.mongo;
  19 
  20 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.FieldInfo;
  23 import com.dtstack.flink.sql.side.JoinInfo;
  24 import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  25 import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
  26 import com.dtstack.flink.sql.util.RowDataComplete;
  27 import com.google.common.collect.Lists;
  28 import com.google.common.collect.Maps;
  29 import com.mongodb.BasicDBObject;
  30 import com.mongodb.MongoClient;
  31 import com.mongodb.MongoClientURI;
  32 import com.mongodb.client.FindIterable;
  33 import com.mongodb.client.MongoCollection;
  34 import com.mongodb.client.MongoCursor;
  35 import com.mongodb.client.MongoDatabase;
  36 import java.sql.SQLException;
  37 import java.util.Calendar;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.concurrent.atomic.AtomicReference;
  41 import org.apache.calcite.sql.JoinType;
  42 import org.apache.commons.collections.CollectionUtils;
  43 import org.apache.commons.lang3.StringUtils;
  44 import org.apache.flink.api.java.tuple.Tuple2;
  45 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  46 import org.apache.flink.table.dataformat.BaseRow;
  47 import org.apache.flink.types.Row;
  48 import org.apache.flink.util.Collector;
  49 import org.bson.Document;
  50 import org.slf4j.Logger;
  51 import org.slf4j.LoggerFactory;
  52 
  53 
  54 /**
  55  * Reason:
  56  * Date: 2018/11/6
  57  *
  58  * @author xuqianjin
  59  */
  60 public class MongoAllReqRow extends BaseAllReqRow {
  61     private static final long serialVersionUID = -675332795591842778L;
  62 
  63     private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  64 
  65     private static final int CONN_RETRY_NUM = 3;
  66 
  67     private static final int FETCH_SIZE = 1000;
  68 
  69     private MongoClient mongoClient;
  70 
  71     private MongoDatabase db;
  72 
  73     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  74 
<abbr title="  75     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  75     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, A🔵</abbr>
  76         super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  77     }
  78 
  79     @Override
  80     public Row fillData(Row input, Object sideInput) {
  81         Map&lt;String, Object&gt; cacheInfo = ((Map&lt;String, Object&gt;) (sideInput));
  82         Row row = new Row(sideInfo.getOutFieldInfoList().size());
  83         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  84             Object obj = input.getField(entry.getValue());
  85             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
  86             row.setField(entry.getKey(), obj);
  87         }
  88         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
  89             if (cacheInfo == null) {
  90                 row.setField(entry.getKey(), null);
  91             } else {
  92                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
  93             }
  94         }
  95         return row;
  96     }
  97 
  98     @Override
  99     protected void initCache() throws SQLException {
 100         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 101         cacheRef.set(newCache);
 102         loadData(newCache);
 103     }
 104 
 105     @Override
 106     protected void reloadCache() {
 107         //reload cacheRef and replace to old cacheRef
 108         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 109         try {
 110             loadData(newCache);
 111         } catch (SQLException e) {
 112             LOG.error(&quot;&quot;, e);
 113         }
 114 
 115         cacheRef.set(newCache);
 116         LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 117     }
 118 
 119     @Override
 120     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
 121         List&lt;Object&gt; inputParams = Lists.newArrayList();
 122         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 123             Object equalObj = input.getField(conValIndex);
 124             if (equalObj == null) {
 125                 if (sideInfo.getJoinType() == JoinType.LEFT) {
 126                     Row data = fillData(input, null);
 127                     RowDataComplete.collectRow(out, data);
 128                 }
 129                 return;
 130             }
 131             inputParams.add(equalObj);
 132         }
 133         String key = buildKey(inputParams);
 134         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 135         if (CollectionUtils.isEmpty(cacheList)) {
 136             if (sideInfo.getJoinType() == JoinType.LEFT) {
 137                 Row row = fillData(input, null);
 138                 RowDataComplete.collectRow(out, row);
 139             } else {
 140                 return;
 141             }
 142             return;
 143         }
 144         for (Map&lt;String, Object&gt; one : cacheList) {
 145             Row row = fillData(input, one);
 146             RowDataComplete.collectRow(out, row);
 147         }
 148     }
 149 
 150     private String buildKey(List&lt;Object&gt; equalValList) {
 151         StringBuilder sb = new StringBuilder(&quot;&quot;);
 152         for (Object equalVal : equalValList) {
 153             sb.append(equalVal).append(&quot;_&quot;);
 154         }
 155 
 156         return sb.toString();
 157     }
 158 
 159     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 160         StringBuilder sb = new StringBuilder(&quot;&quot;);
 161         for (String equalField : equalFieldList) {
 162             sb.append(val.get(equalField)).append(&quot;_&quot;);
 163         }
 164 
 165         return sb.toString();
 166     }
 167 
<abbr title=" 168     private MongoCollection getConn(String host, String userName, String password, String database, String tableName) {"> 168     private MongoCollection getConn(String host, String userName, String password, String database, Strin🔵</abbr>
 169 
 170         MongoCollection dbCollection;
 171         mongoClient = new MongoClient(new MongoClientURI(getConnectionUrl(host, userName, password)));
 172         db = mongoClient.getDatabase(database);
 173         dbCollection = db.getCollection(tableName, Document.class);
 174         return dbCollection;
 175 
 176     }
 177 
 178     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 179         MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 180         MongoCollection dbCollection = null;
 181 
 182         try {
 183             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 184                 try {
<abbr title=" 185                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.getPassword(),"> 185                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.get🔵</abbr>
 186                             tableInfo.getDatabase(), tableInfo.getTableName());
 187                     break;
 188                 } catch (Exception e) {
 189                     if (i == CONN_RETRY_NUM - 1) {
 190                         throw new RuntimeException(&quot;&quot;, e);
 191                     }
 192 
 193                     try {
<abbr title=" 194                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 194                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getU🔵</abbr>
 195                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 196                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 197                     } catch (InterruptedException e1) {
 198                         LOG.error(&quot;&quot;, e1);
 199                     }
 200                 }
 201             }
 202 
 203             //load data from table
 204             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 205             BasicDBObject basicDBObject = new BasicDBObject();
 206             for (String selectField : sideFieldNames) {
 207                 basicDBObject.append(selectField, 1);
 208             }
 209             BasicDBObject filterObject = new BasicDBObject();
 210             try {
 211                 // 填充谓词
 212                 sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 213                     BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 214                     if (null != filterCondition) {
 215                         filterObject.append(info.getFieldName(), filterCondition);
 216                     }
 217                     return info;
 218                 }).count();
 219             } catch (Exception e) {
 220                 LOG.info(&quot;add predicate infoes error &quot;, e);
 221             }
 222 
 223 
<abbr title=" 224             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 224             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObjec🔵</abbr>
 225             MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 226             while (mongoCursor.hasNext()) {
 227                 Document doc = mongoCursor.next();
 228                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 229                 for (String fieldName : sideFieldNames) {
 230                     oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 231                 }
 232                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 233                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 233                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArray🔵</abbr>
 234                 list.add(oneRow);
 235             }
 236         } catch (Exception e) {
 237             LOG.error(&quot;&quot;, e);
 238         } finally {
 239             if (mongoClient != null) {
 240                 mongoClient.close();
 241             }
 242         }
 243     }
 244 
 245     private String getConnectionUrl(String address, String userName, String password){
 246         if(address.startsWith(&quot;mongodb://&quot;) || address.startsWith(&quot;mongodb+srv://&quot;)){
 247             return  address;
 248         }
 249         if (StringUtils.isNotBlank(userName) &amp;&amp; StringUtils.isNotBlank(password)) {
 250             return String.format(&quot;mongodb://%s:%s@%s&quot;, userName, password, address);
 251         }
 252         return String.format(&quot;mongodb://%s&quot;, address);
 253     }
 254 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.mongo;
  20  
  21  import com.dtstack.flink.sql.side.BaseAllReqRow;
  22  import com.dtstack.flink.sql.side.FieldInfo;
  23  import com.dtstack.flink.sql.side.JoinInfo;
  24  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25  import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  26  import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import com.dtstack.flink.sql.util.RowDataComplete;</span>
  28  import com.google.common.collect.Lists;
  29  import com.google.common.collect.Maps;
  30  import com.mongodb.BasicDBObject;
  31  import com.mongodb.MongoClient;
  32  import com.mongodb.MongoClientURI;
  33  import com.mongodb.client.FindIterable;
  34  import com.mongodb.client.MongoCollection;
  35  import com.mongodb.client.MongoCursor;
  36  import com.mongodb.client.MongoDatabase;
  37  import org.apache.calcite.sql.JoinType;
  38  import org.apache.commons.collections.CollectionUtils;
  39  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import org.apache.flink.api.java.tuple.Tuple2;</span>
  41  import org.apache.flink.api.java.typeutils.RowTypeInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  42 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  43 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +import org.apache.flink.table.dataformat.BaseRow;</span>
  45  import org.apache.flink.types.Row;
  46  import org.apache.flink.util.Collector;
  47  import org.bson.Document;
  48  import org.slf4j.Logger;
  49  import org.slf4j.LoggerFactory;
  50  
  51  import java.sql.SQLException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import java.sql.Timestamp;</span>
  53  import java.util.Calendar;
  54  import java.util.List;
  55  import java.util.Map;
  56  import java.util.concurrent.atomic.AtomicReference;
  57  
  58  /**
  59   * Reason:
  60   * Date: 2018/11/6
  61   *
  62   * @author xuqianjin
  63   */
  64  public class MongoAllReqRow extends BaseAllReqRow {
  65  
  66      private static final long serialVersionUID = -675332795591842778L;
  67  
  68      private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  69  
  70      private static final int CONN_RETRY_NUM = 3;
  71  
  72      private static final int FETCH_SIZE = 1000;
  73  
  74      private MongoClient mongoClient;
  75  
  76      private MongoDatabase db;
  77  
  78      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  79  
<abbr title="  80      public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  80      public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSi🔵</abbr>
  81          super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  82      }
  83  
  84      @Override
  85      public Row fillData(Row input, Object sideInput) {
  86          Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  87          Row row = new Row(sideInfo.getOutFieldInfoList().size());
  88          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  89              Object obj = input.getField(entry.getValue());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  90 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  90 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  92 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  92 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL tim🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -            if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -                obj = ((Timestamp) obj).getTime();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +            obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>



  97              row.setField(entry.getKey(), obj);
  98          }
  99  
 100          for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
 101              if (cacheInfo == null) {
 102                  row.setField(entry.getKey(), null);
 103              } else {
 104                  row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 105              }
 106          }
 107  
 108          return row;
 109      }
 110  
 111      @Override
 112      protected void initCache() throws SQLException {
 113          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 114          cacheRef.set(newCache);
 115          loadData(newCache);
 116      }
 117  
 118      @Override
 119      protected void reloadCache() {
 120          //reload cacheRef and replace to old cacheRef
 121          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 122          try {
 123              loadData(newCache);
 124          } catch (SQLException e) {
 125              LOG.error(&quot;&quot;, e);
 126          }
 127  
 128          cacheRef.set(newCache);
 129          LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 130      }
 131  
 132      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -    public void flatMap(CRow input, Collector&lt;CRow&gt; out) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +    public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {</span>
 135          List&lt;Object&gt; inputParams = Lists.newArrayList();
 136          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -            Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +            Object equalObj = input.getField(conValIndex);</span>
 139              if (equalObj == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -                if(sideInfo.getJoinType() == JoinType.LEFT){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -                    Row data = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -                    out.collect(new CRow(data, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +                if (sideInfo.getJoinType() == JoinType.LEFT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +                    Row data = fillData(input, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +                    RowDataComplete.collectRow(out, data);</span>
 146                  }
 147                  return;
 148              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -</span>
 150              inputParams.add(equalObj);
 151          }
 152  
 153          String key = buildKey(inputParams);
 154          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 155          if (CollectionUtils.isEmpty(cacheList)) {
 156              if (sideInfo.getJoinType() == JoinType.LEFT) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -                Row row = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -                out.collect(new CRow(row, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +                Row row = fillData(input, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +                RowDataComplete.collectRow(out, row);</span>
 161              } else {
 162                  return;
 163              }
 164  
 165              return;
 166          }
 167  
 168          for (Map&lt;String, Object&gt; one : cacheList) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -            out.collect(new CRow(fillData(input.row(), one), input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +            Row row = fillData(input, one);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +            RowDataComplete.collectRow(out, row);</span>
 172          }
 173      }
 174  
 175      private String buildKey(List&lt;Object&gt; equalValList) {
 176          StringBuilder sb = new StringBuilder(&quot;&quot;);
 177          for (Object equalVal : equalValList) {
 178              sb.append(equalVal).append(&quot;_&quot;);
 179          }
 180  
 181          return sb.toString();
 182      }
 183  
 184      private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 185          StringBuilder sb = new StringBuilder(&quot;&quot;);
 186          for (String equalField : equalFieldList) {
 187              sb.append(val.get(equalField)).append(&quot;_&quot;);
 188          }
 189  
 190          return sb.toString();
 191      }
 192  
<abbr title=" 193      private MongoCollection getConn(String host, String userName, String password, String database, String tableName) {"> 193      private MongoCollection getConn(String host, String userName, String password, String database, String tableNa🔵</abbr>
 194  
 195          MongoCollection dbCollection;
 196          mongoClient = new MongoClient(new MongoClientURI(getConnectionUrl(host, userName, password)));
 197          db = mongoClient.getDatabase(database);
 198          dbCollection = db.getCollection(tableName, Document.class);
 199          return dbCollection;
 200  
 201      }
 202  
 203      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 204          MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 205          MongoCollection dbCollection = null;
 206  
 207          try {
 208              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 209                  try {
<abbr title=" 210                      dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.getPassword(),"> 210                      dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.getPassword(🔵</abbr>
 211                              tableInfo.getDatabase(), tableInfo.getTableName());
 212                      break;
 213                  } catch (Exception e) {
 214                      if (i == CONN_RETRY_NUM - 1) {
 215                          throw new RuntimeException(&quot;&quot;, e);
 216                      }
 217  
 218                      try {
<abbr title=" 219                          String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 219                          String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName()🔵</abbr>
 220                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 221                          Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 222                      } catch (InterruptedException e1) {
 223                          LOG.error(&quot;&quot;, e1);
 224                      }
 225                  }
 226              }
 227  
 228              //load data from table
 229              String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 230              BasicDBObject basicDBObject = new BasicDBObject();
 231              for (String selectField : sideFieldNames) {
 232                  basicDBObject.append(selectField, 1);
 233              }
 234              BasicDBObject filterObject = new BasicDBObject();
 235              try {
 236                  // 填充谓词
 237                  sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 238                      BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 239                      if (null != filterCondition) {
 240                          filterObject.append(info.getFieldName(), filterCondition);
 241                      }
 242                      return info;
 243                  }).count();
 244              } catch (Exception e) {
 245                  LOG.info(&quot;add predicate infoes error &quot;, e);
 246              }
 247  
 248  
<abbr title=" 249              FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 249              FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(🔵</abbr>
 250              MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 251              while (mongoCursor.hasNext()) {
 252                  Document doc = mongoCursor.next();
 253                  Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 254                  for (String fieldName : sideFieldNames) {
 255                      oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 256                  }
 257                  String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
 258                  List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());
 259                  list.add(oneRow);
 260              }
 261          } catch (Exception e) {
 262              LOG.error(&quot;&quot;, e);
 263          } finally {
 264              if (mongoClient != null) {
 265                  mongoClient.close();
 266              }
 267          }
 268      }
 269      private String getConnectionUrl(String address, String userName, String password){
 270          if(address.startsWith(&quot;mongodb://&quot;) || address.startsWith(&quot;mongodb+srv://&quot;)){
 271              return  address;
 272          }
 273          if (StringUtils.isNotBlank(userName) &amp;&amp; StringUtils.isNotBlank(password)) {
 274              return String.format(&quot;mongodb://%s:%s@%s&quot;, userName, password, address);
 275          }
 276          return String.format(&quot;mongodb://%s&quot;, address);
 277      }
 278  
 279  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.mongo;
  20  
  21  import com.dtstack.flink.sql.side.BaseAllReqRow;
  22  import com.dtstack.flink.sql.side.FieldInfo;
  23  import com.dtstack.flink.sql.side.JoinInfo;
  24  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25  import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  26  import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;

  27  import com.google.common.collect.Lists;
  28  import com.google.common.collect.Maps;
  29  import com.mongodb.BasicDBObject;
  30  import com.mongodb.MongoClient;
  31  import com.mongodb.MongoClientURI;
  32  import com.mongodb.client.FindIterable;
  33  import com.mongodb.client.MongoCollection;
  34  import com.mongodb.client.MongoCursor;
  35  import com.mongodb.client.MongoDatabase;
  36  import org.apache.calcite.sql.JoinType;
  37  import org.apache.commons.collections.CollectionUtils;
  38  import org.apache.commons.lang3.StringUtils;

  39  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  40  import org.apache.flink.table.runtime.types.CRow;
  41  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;

  42  import org.apache.flink.types.Row;
  43  import org.apache.flink.util.Collector;
  44  import org.bson.Document;
  45  import org.slf4j.Logger;
  46  import org.slf4j.LoggerFactory;
  47  
  48  import java.sql.SQLException;
  49  import java.sql.Timestamp;
  50  import java.util.Calendar;
  51  import java.util.List;
  52  import java.util.Map;
  53  import java.util.concurrent.atomic.AtomicReference;
  54  
  55  /**
  56   * Reason:
  57   * Date: 2018/11/6
  58   *
  59   * @author xuqianjin
  60   */
  61  public class MongoAllReqRow extends BaseAllReqRow {
  62  
  63      private static final long serialVersionUID = -675332795591842778L;
  64  
  65      private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  66  
  67      private static final int CONN_RETRY_NUM = 3;
  68  
  69      private static final int FETCH_SIZE = 1000;
  70  
  71      private MongoClient mongoClient;
  72  
  73      private MongoDatabase db;
  74  
  75      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  76  
<abbr title="  77      public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  77      public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSi🔵</abbr>
  78          super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  79      }
  80  
  81      @Override
  82      public Row fillData(Row input, Object sideInput) {
  83          Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  84          Row row = new Row(sideInfo.getOutFieldInfoList().size());
  85          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  86              Object obj = input.getField(entry.getValue());
<abbr title="  87              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  87              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr>
  88  
<abbr title="  89              //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  89              //Type information for indicating event or processing time. However, it behaves like a regular SQL tim🔵</abbr>
  90              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -                obj = ((Timestamp) obj).getTime();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +                //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +                obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +</span>
  97              row.setField(entry.getKey(), obj);
  98          }
  99  
 100          for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
 101              if (cacheInfo == null) {
 102                  row.setField(entry.getKey(), null);
 103              } else {
 104                  row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 105              }
 106          }
 107  
 108          return row;
 109      }
 110  
 111      @Override
 112      protected void initCache() throws SQLException {
 113          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 114          cacheRef.set(newCache);
 115          loadData(newCache);
 116      }
 117  
 118      @Override
 119      protected void reloadCache() {
 120          //reload cacheRef and replace to old cacheRef
 121          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 122          try {
 123              loadData(newCache);
 124          } catch (SQLException e) {
 125              LOG.error(&quot;&quot;, e);
 126          }
 127  
 128          cacheRef.set(newCache);
 129          LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 130      }
 131  
 132      @Override
 133      public void flatMap(CRow input, Collector&lt;CRow&gt; out) throws Exception {

 134          List&lt;Object&gt; inputParams = Lists.newArrayList();
 135          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 136              Object equalObj = input.row().getField(conValIndex);

 137              if (equalObj == null) {
 138                  if(sideInfo.getJoinType() == JoinType.LEFT){
 139                      Row data = fillData(input.row(), null);
 140                      out.collect(new CRow(data, input.change()));



 141                  }
 142                  return;
 143              }
 144  
 145              inputParams.add(equalObj);
 146          }
 147  
 148          String key = buildKey(inputParams);
 149          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 150          if (CollectionUtils.isEmpty(cacheList)) {
 151              if (sideInfo.getJoinType() == JoinType.LEFT) {
 152                  Row row = fillData(input.row(), null);
 153                  out.collect(new CRow(row, input.change()));


 154              } else {
 155                  return;
 156              }
 157  
 158              return;
 159          }
 160  
 161          for (Map&lt;String, Object&gt; one : cacheList) {
 162              out.collect(new CRow(fillData(input.row(), one), input.change()));


 163          }
 164      }
 165  
 166      private String buildKey(List&lt;Object&gt; equalValList) {
 167          StringBuilder sb = new StringBuilder(&quot;&quot;);
 168          for (Object equalVal : equalValList) {
 169              sb.append(equalVal).append(&quot;_&quot;);
 170          }
 171  
 172          return sb.toString();
 173      }
 174  
 175      private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 176          StringBuilder sb = new StringBuilder(&quot;&quot;);
 177          for (String equalField : equalFieldList) {
 178              sb.append(val.get(equalField)).append(&quot;_&quot;);
 179          }
 180  
 181          return sb.toString();
 182      }
 183  
<abbr title=" 184      private MongoCollection getConn(String host, String userName, String password, String database, String tableName) {"> 184      private MongoCollection getConn(String host, String userName, String password, String database, String tableNa🔵</abbr>
 185  
 186          MongoCollection dbCollection;
 187          mongoClient = new MongoClient(new MongoClientURI(getConnectionUrl(host, userName, password)));
 188          db = mongoClient.getDatabase(database);
 189          dbCollection = db.getCollection(tableName, Document.class);
 190          return dbCollection;
 191  
 192      }
 193  
 194      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 195          MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 196          MongoCollection dbCollection = null;
 197  
 198          try {
 199              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 200                  try {
<abbr title=" 201                      dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.getPassword(),"> 201                      dbCollection = getConn(tableInfo.getAddress(), tableInfo.getUserName(), tableInfo.getPassword(🔵</abbr>
 202                              tableInfo.getDatabase(), tableInfo.getTableName());
 203                      break;
 204                  } catch (Exception e) {
 205                      if (i == CONN_RETRY_NUM - 1) {
 206                          throw new RuntimeException(&quot;&quot;, e);
 207                      }
 208  
 209                      try {
<abbr title=" 210                          String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 210                          String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName()🔵</abbr>
 211                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 212                          Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 213                      } catch (InterruptedException e1) {
 214                          LOG.error(&quot;&quot;, e1);
 215                      }
 216                  }
 217              }
 218  
 219              //load data from table
 220              String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 221              BasicDBObject basicDBObject = new BasicDBObject();
 222              for (String selectField : sideFieldNames) {
 223                  basicDBObject.append(selectField, 1);
 224              }
 225              BasicDBObject filterObject = new BasicDBObject();
 226              try {
 227                  // 填充谓词
 228                  sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 229                      BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 230                      if (null != filterCondition) {
 231                          filterObject.append(info.getFieldName(), filterCondition);
 232                      }
 233                      return info;
 234                  }).count();
 235              } catch (Exception e) {
 236                  LOG.info(&quot;add predicate infoes error &quot;, e);
 237              }
 238  
 239  
<abbr title=" 240              FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 240              FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(🔵</abbr>
 241              MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 242              while (mongoCursor.hasNext()) {
 243                  Document doc = mongoCursor.next();
 244                  Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 245                  for (String fieldName : sideFieldNames) {
 246                      oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 247                  }
 248                  String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
 249                  List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());
 250                  list.add(oneRow);
 251              }
 252          } catch (Exception e) {
 253              LOG.error(&quot;&quot;, e);
 254          } finally {
 255              if (mongoClient != null) {
 256                  mongoClient.close();
 257              }
 258          }
 259      }
 260      private String getConnectionUrl(String address, String userName, String password){
 261          if(address.startsWith(&quot;mongodb://&quot;) || address.startsWith(&quot;mongodb+srv://&quot;)){
 262              return  address;
 263          }
 264          if (StringUtils.isNotBlank(userName) &amp;&amp; StringUtils.isNotBlank(password)) {
 265              return String.format(&quot;mongodb://%s:%s@%s&quot;, userName, password, address);
 266          }
 267          return String.format(&quot;mongodb://%s&quot;, address);
 268      }
 269  
 270  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            