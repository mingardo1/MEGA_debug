<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>597 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.ClassUtil;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                         &#x27;import com.google.common.base.Preconditions;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.regex.Matcher;\n&#x27;
                         &#x27;import java.util.regex.Pattern;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/7/4\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AbsTableParser {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String PRIMARY_KEY = &#x27;
                         &#x27;&quot;primaryKey&quot;;\n&#x27;
                         &#x27;    private static final String NEST_JSON_FIELD_KEY &#x27;
                         &#x27;= &quot;nestFieldKey&quot;;\n&#x27;
                         &#x27;    private static final String CHAR_TYPE_NO_LENGTH &#x27;
                         &#x27;= &quot;CHAR&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static Pattern primaryKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)PRIMARY\\\\s+KEY\\\\s*\\\\((.*)\\\\)&quot;);\n&#x27;
                         &#x27;    private static Pattern nestJsonFieldKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)((@*\\\\S+\\\\.)*\\\\S+)\\\\s+(\\\\w+)\\\\s+AS\\\\s+(\\\\w+)(\\\\s+NOT\\\\s+NULL)?$&quot;);\n&#x27;
                         &#x27;    private static Pattern physicalFieldFunPattern = &#x27;
                         &#x27;Pattern.compile(&quot;\\\\w+\\\\((\\\\w+)\\\\)$&quot;);\n&#x27;
                         &#x27;    private static Pattern charTypePattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)CHAR\\\\((\\\\d*)\\\\)$&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, Pattern&gt; patternMap = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, ITableFieldDealHandler&gt; &#x27;
                         &#x27;handlerMap = Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AbsTableParser() {\n&#x27;
                         &#x27;        addParserHandler(PRIMARY_KEY, &#x27;
                         &#x27;primaryKeyPattern, this::dealPrimaryKey);\n&#x27;
                         &#x27;        addParserHandler(NEST_JSON_FIELD_KEY, &#x27;
                         &#x27;nestJsonFieldKeyPattern, this::dealNestField);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean fieldNameNeedsUpperCase() {\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract TableInfo getTableInfo(String &#x27;
                         &#x27;tableName, String fieldsInfo, Map&lt;String, Object&gt; &#x27;
                         &#x27;props) throws Exception;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public boolean dealKeyPattern(String fieldRow, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        for(Map.Entry&lt;String, Pattern&gt; keyPattern : &#x27;
                         &#x27;patternMap.entrySet()){\n&#x27;
                         &#x27;            Pattern pattern = &#x27;
                         &#x27;keyPattern.getValue();\n&#x27;
                         &#x27;            String key = keyPattern.getKey();\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;pattern.matcher(fieldRow);\n&#x27;
                         &#x27;            if(matcher.find()){\n&#x27;
                         &#x27;                ITableFieldDealHandler handler = &#x27;
                         &#x27;handlerMap.get(key);\n&#x27;
                         &#x27;                if(handler == null){\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] &#x27;
                         &#x27;error.&quot;);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                handler.dealPrimaryKey(matcher, &#x27;
                         &#x27;tableInfo);\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void parseFieldsInfo(String fieldsInfo, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fieldRows = &#x27;
                         &quot;DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);\n&quot;
                         &#x27;        for(String fieldRow : fieldRows){\n&#x27;
                         &#x27;            fieldRow = fieldRow.trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if(StringUtils.isBlank(fieldRow)){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s],exists &#x27;
                         &#x27;field empty.&quot;, tableInfo.getName()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            String[] filedInfoArr = &#x27;
                         &#x27;fieldRow.split(&quot;\\\\s+&quot;);\n&#x27;
                         &#x27;            if(filedInfoArr.length &lt; 2 ){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s] field &#x27;
                         &#x27;[%s] format error.&quot;, tableInfo.getName(), &#x27;
                         &#x27;fieldRow));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            boolean isMatcherKey = &#x27;
                         &#x27;dealKeyPattern(fieldRow, tableInfo);\n&#x27;
                         &#x27;            if(isMatcherKey){\n&#x27;
                         &#x27;                continue;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //Compatible situation may arise in &#x27;
                         &#x27;space in the fieldName\n&#x27;
                         &#x27;            String[] filedNameArr = new &#x27;
                         &#x27;String[filedInfoArr.length - 1];\n&#x27;
                         &#x27;            System.arraycopy(filedInfoArr, 0, &#x27;
                         &#x27;filedNameArr, 0, filedInfoArr.length - 1);\n&#x27;
                         &#x27;            String fieldName = String.join(&quot; &quot;, &#x27;
                         &#x27;filedNameArr);\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;filedInfoArr[filedInfoArr.length - 1 ].trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Class fieldClass = null;\n&#x27;
                         &#x27;            TableInfo.FieldExtraInfo fieldExtraInfo &#x27;
                         &#x27;= null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;charTypePattern.matcher(fieldType);\n&#x27;
                         &#x27;            if (matcher.find()) {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);\n&#x27;
                         &#x27;                fieldExtraInfo = new &#x27;
                         &#x27;TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;                &#x27;
                         &#x27;fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addPhysicalMappings(filedInfoArr[0],filedInfoArr[0]);\n&#x27;
                         &#x27;            tableInfo.addField(fieldName);\n&#x27;
                         &#x27;            tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;            tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.finish();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void dealPrimaryKey(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        String primaryFields = &#x27;
                         &#x27;matcher.group(1).trim();\n&#x27;
                         &#x27;        String[] splitArry = &#x27;
                         &#x27;primaryFields.split(&quot;,&quot;);\n&#x27;
                         &#x27;        List&lt;String&gt; primaryKes = &#x27;
                         &#x27;Lists.newArrayList(splitArry);\n&#x27;
                         &#x27;        tableInfo.setPrimaryKeys(primaryKes);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * add parser for alias field\n&#x27;
                         &#x27;     * @param matcher\n&#x27;
                         &#x27;     * @param tableInfo\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void dealNestField(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo) {\n&#x27;
                         &#x27;        String physicalField = matcher.group(1);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),\n&#x27;
                         &#x27;                &quot;No need to add data types when &#x27;
                         &#x27;using functions, The correct way is : strLen(name) &#x27;
                         &#x27;as nameSize, &quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String fieldType = matcher.group(3);\n&#x27;
                         &#x27;        String mappingField = matcher.group(4);\n&#x27;
                         &#x27;        Class fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;        boolean notNull = matcher.group(5) != null;\n&#x27;
                         &#x27;        TableInfo.FieldExtraInfo fieldExtraInfo = &#x27;
                         &#x27;new TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;        fieldExtraInfo.setNotNull(notNull);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.addPhysicalMappings(mappingField, &#x27;
                         &#x27;physicalField);\n&#x27;
                         &#x27;        tableInfo.addField(mappingField);\n&#x27;
                         &#x27;        tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;        tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public Class dbTypeConvertToJavaType(String &#x27;
                         &#x27;fieldType) {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;ClassUtil.stringConvertClass(fieldType);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void addParserHandler(String &#x27;
                         &#x27;parserName, Pattern pattern, ITableFieldDealHandler &#x27;
                         &#x27;handler) {\n&#x27;
                         &#x27;        patternMap.put(parserName, pattern);\n&#x27;
                         &#x27;        handlerMap.put(parserName, handler);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.ClassUtil;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                         &#x27;import com.google.common.base.Preconditions;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.regex.Matcher;\n&#x27;
                         &#x27;import java.util.regex.Pattern;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/7/4\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AbsTableParser {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String PRIMARY_KEY = &#x27;
                         &#x27;&quot;primaryKey&quot;;\n&#x27;
                         &#x27;    private static final String NEST_JSON_FIELD_KEY &#x27;
                         &#x27;= &quot;nestFieldKey&quot;;\n&#x27;
                         &#x27;    private static final String CHAR_TYPE_NO_LENGTH &#x27;
                         &#x27;= &quot;CHAR&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static Pattern primaryKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)PRIMARY\\\\s+KEY\\\\s*\\\\((.*)\\\\)&quot;);\n&#x27;
                         &#x27;    private static Pattern nestJsonFieldKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)((@*\\\\S+\\\\.)*\\\\S+)\\\\s+(\\\\w+)\\\\s+AS\\\\s+(\\\\w+)(\\\\s+NOT\\\\s+NULL)?$&quot;);\n&#x27;
                         &#x27;    private static Pattern physicalFieldFunPattern = &#x27;
                         &#x27;Pattern.compile(&quot;\\\\w+\\\\((\\\\w+)\\\\)$&quot;);\n&#x27;
                         &#x27;    private static Pattern charTypePattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)CHAR\\\\((\\\\d*)\\\\)$&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, Pattern&gt; patternMap = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, ITableFieldDealHandler&gt; &#x27;
                         &#x27;handlerMap = Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AbsTableParser() {\n&#x27;
                         &#x27;        addParserHandler(PRIMARY_KEY, &#x27;
                         &#x27;primaryKeyPattern, this::dealPrimaryKey);\n&#x27;
                         &#x27;        addParserHandler(NEST_JSON_FIELD_KEY, &#x27;
                         &#x27;nestJsonFieldKeyPattern, this::dealNestField);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean fieldNameNeedsUpperCase() {\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract TableInfo getTableInfo(String &#x27;
                         &#x27;tableName, String fieldsInfo, Map&lt;String, Object&gt; &#x27;
                         &#x27;props) throws Exception;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public boolean dealKeyPattern(String fieldRow, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        for(Map.Entry&lt;String, Pattern&gt; keyPattern : &#x27;
                         &#x27;patternMap.entrySet()){\n&#x27;
                         &#x27;            Pattern pattern = &#x27;
                         &#x27;keyPattern.getValue();\n&#x27;
                         &#x27;            String key = keyPattern.getKey();\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;pattern.matcher(fieldRow);\n&#x27;
                         &#x27;            if(matcher.find()){\n&#x27;
                         &#x27;                ITableFieldDealHandler handler = &#x27;
                         &#x27;handlerMap.get(key);\n&#x27;
                         &#x27;                if(handler == null){\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] &#x27;
                         &#x27;error.&quot;);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                handler.dealPrimaryKey(matcher, &#x27;
                         &#x27;tableInfo);\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void parseFieldsInfo(String fieldsInfo, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fieldRows = &#x27;
                         &quot;DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);\n&quot;
                         &#x27;        for(String fieldRow : fieldRows){\n&#x27;
                         &#x27;            fieldRow = fieldRow.trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if(StringUtils.isBlank(fieldRow)){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s],exists &#x27;
                         &#x27;field empty.&quot;, tableInfo.getName()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            String[] filedInfoArr = &#x27;
                         &#x27;fieldRow.split(&quot;\\\\s+&quot;);\n&#x27;
                         &#x27;            if(filedInfoArr.length &lt; 2 ){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s] field &#x27;
                         &#x27;[%s] format error.&quot;, tableInfo.getName(), &#x27;
                         &#x27;fieldRow));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            boolean isMatcherKey = &#x27;
                         &#x27;dealKeyPattern(fieldRow, tableInfo);\n&#x27;
                         &#x27;            if(isMatcherKey){\n&#x27;
                         &#x27;                continue;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //Compatible situation may arise in &#x27;
                         &#x27;space in the fieldName\n&#x27;
                         &#x27;            String[] filedNameArr = new &#x27;
                         &#x27;String[filedInfoArr.length - 1];\n&#x27;
                         &#x27;            System.arraycopy(filedInfoArr, 0, &#x27;
                         &#x27;filedNameArr, 0, filedInfoArr.length - 1);\n&#x27;
                         &#x27;            String fieldName = String.join(&quot; &quot;, &#x27;
                         &#x27;filedNameArr);\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;filedInfoArr[filedInfoArr.length - 1 ].trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Class fieldClass = null;\n&#x27;
                         &#x27;            TableInfo.FieldExtraInfo fieldExtraInfo &#x27;
                         &#x27;= null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;charTypePattern.matcher(fieldType);\n&#x27;
                         &#x27;            if (matcher.find()) {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);\n&#x27;
                         &#x27;                fieldExtraInfo = new &#x27;
                         &#x27;TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;                &#x27;
                         &#x27;fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addPhysicalMappings(filedInfoArr[0],filedInfoArr[0]);\n&#x27;
                         &#x27;            tableInfo.addField(fieldName);\n&#x27;
                         &#x27;            tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;            tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.finish();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void dealPrimaryKey(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        String primaryFields = &#x27;
                         &#x27;matcher.group(1).trim();\n&#x27;
                         &#x27;        String[] splitArry = &#x27;
                         &#x27;primaryFields.split(&quot;,&quot;);\n&#x27;
                         &#x27;        List&lt;String&gt; primaryKes = &#x27;
                         &#x27;Lists.newArrayList(splitArry);\n&#x27;
                         &#x27;        tableInfo.setPrimaryKeys(primaryKes);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * add parser for alias field\n&#x27;
                         &#x27;     * @param matcher\n&#x27;
                         &#x27;     * @param tableInfo\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void dealNestField(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo) {\n&#x27;
                         &#x27;        String physicalField = matcher.group(1);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),\n&#x27;
                         &#x27;                &quot;No need to add data types when &#x27;
                         &#x27;using functions, The correct way is : strLen(name) &#x27;
                         &#x27;as nameSize, &quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String fieldType = matcher.group(3);\n&#x27;
                         &#x27;        String mappingField = matcher.group(4);\n&#x27;
                         &#x27;        Class fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;        boolean notNull = matcher.group(5) != null;\n&#x27;
                         &#x27;        TableInfo.FieldExtraInfo fieldExtraInfo = &#x27;
                         &#x27;new TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;        fieldExtraInfo.setNotNull(notNull);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.addPhysicalMappings(mappingField, &#x27;
                         &#x27;physicalField);\n&#x27;
                         &#x27;        tableInfo.addField(mappingField);\n&#x27;
                         &#x27;        tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;        tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public Class dbTypeConvertToJavaType(String &#x27;
                         &#x27;fieldType) {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;ClassUtil.stringConvertClass(fieldType);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void addParserHandler(String &#x27;
                         &#x27;parserName, Pattern pattern, ITableFieldDealHandler &#x27;
                         &#x27;handler) {\n&#x27;
                         &#x27;        patternMap.put(parserName, pattern);\n&#x27;
                         &#x27;        handlerMap.put(parserName, handler);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.ClassUtil;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                         &#x27;import com.google.common.base.Preconditions;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.regex.Matcher;\n&#x27;
                         &#x27;import java.util.regex.Pattern;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/7/4\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AbsTableParser {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String PRIMARY_KEY = &#x27;
                         &#x27;&quot;primaryKey&quot;;\n&#x27;
                         &#x27;    private static final String NEST_JSON_FIELD_KEY &#x27;
                         &#x27;= &quot;nestFieldKey&quot;;\n&#x27;
                         &#x27;    private static final String CHAR_TYPE_NO_LENGTH &#x27;
                         &#x27;= &quot;CHAR&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static Pattern primaryKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)PRIMARY\\\\s+KEY\\\\s*\\\\((.*)\\\\)&quot;);\n&#x27;
                         &#x27;    private static Pattern nestJsonFieldKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)((@*\\\\S+\\\\.)*\\\\S+)\\\\s+(\\\\w+)\\\\s+AS\\\\s+(\\\\w+)(\\\\s+NOT\\\\s+NULL)?$&quot;);\n&#x27;
                         &#x27;    private static Pattern physicalFieldFunPattern = &#x27;
                         &#x27;Pattern.compile(&quot;\\\\w+\\\\((\\\\w+)\\\\)$&quot;);\n&#x27;
                         &#x27;    private static Pattern charTypePattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)CHAR\\\\((\\\\d*)\\\\)$&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, Pattern&gt; patternMap = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, ITableFieldDealHandler&gt; &#x27;
                         &#x27;handlerMap = Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AbsTableParser() {\n&#x27;
                         &#x27;        addParserHandler(PRIMARY_KEY, &#x27;
                         &#x27;primaryKeyPattern, this::dealPrimaryKey);\n&#x27;
                         &#x27;        addParserHandler(NEST_JSON_FIELD_KEY, &#x27;
                         &#x27;nestJsonFieldKeyPattern, this::dealNestField);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean fieldNameNeedsUpperCase() {\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract TableInfo getTableInfo(String &#x27;
                         &#x27;tableName, String fieldsInfo, Map&lt;String, Object&gt; &#x27;
                         &#x27;props) throws Exception;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public boolean dealKeyPattern(String fieldRow, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        for(Map.Entry&lt;String, Pattern&gt; keyPattern : &#x27;
                         &#x27;patternMap.entrySet()){\n&#x27;
                         &#x27;            Pattern pattern = &#x27;
                         &#x27;keyPattern.getValue();\n&#x27;
                         &#x27;            String key = keyPattern.getKey();\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;pattern.matcher(fieldRow);\n&#x27;
                         &#x27;            if(matcher.find()){\n&#x27;
                         &#x27;                ITableFieldDealHandler handler = &#x27;
                         &#x27;handlerMap.get(key);\n&#x27;
                         &#x27;                if(handler == null){\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] &#x27;
                         &#x27;error.&quot;);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                handler.dealPrimaryKey(matcher, &#x27;
                         &#x27;tableInfo);\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void parseFieldsInfo(String fieldsInfo, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fieldRows = &#x27;
                         &quot;DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);\n&quot;
                         &#x27;        for(String fieldRow : fieldRows){\n&#x27;
                         &#x27;            fieldRow = fieldRow.trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if(StringUtils.isBlank(fieldRow)){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s],exists &#x27;
                         &#x27;field empty.&quot;, tableInfo.getName()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            String[] filedInfoArr = &#x27;
                         &#x27;fieldRow.split(&quot;\\\\s+&quot;);\n&#x27;
                         &#x27;            if(filedInfoArr.length &lt; 2 ){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s] field &#x27;
                         &#x27;[%s] format error.&quot;, tableInfo.getName(), &#x27;
                         &#x27;fieldRow));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            boolean isMatcherKey = &#x27;
                         &#x27;dealKeyPattern(fieldRow, tableInfo);\n&#x27;
                         &#x27;            if(isMatcherKey){\n&#x27;
                         &#x27;                continue;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //Compatible situation may arise in &#x27;
                         &#x27;space in the fieldName\n&#x27;
                         &#x27;            String[] filedNameArr = new &#x27;
                         &#x27;String[filedInfoArr.length - 1];\n&#x27;
                         &#x27;            System.arraycopy(filedInfoArr, 0, &#x27;
                         &#x27;filedNameArr, 0, filedInfoArr.length - 1);\n&#x27;
                         &#x27;            String fieldName = String.join(&quot; &quot;, &#x27;
                         &#x27;filedNameArr);\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;filedInfoArr[filedInfoArr.length - 1 ].trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Class fieldClass = null;\n&#x27;
                         &#x27;            TableInfo.FieldExtraInfo fieldExtraInfo &#x27;
                         &#x27;= null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;charTypePattern.matcher(fieldType);\n&#x27;
                         &#x27;            if (matcher.find()) {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);\n&#x27;
                         &#x27;                fieldExtraInfo = new &#x27;
                         &#x27;TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;                &#x27;
                         &#x27;fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addPhysicalMappings(filedInfoArr[0],filedInfoArr[0]);\n&#x27;
                         &#x27;            tableInfo.addField(fieldName);\n&#x27;
                         &#x27;            tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;            tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.finish();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void dealPrimaryKey(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        String primaryFields = &#x27;
                         &#x27;matcher.group(1).trim();\n&#x27;
                         &#x27;        String[] splitArry = &#x27;
                         &#x27;primaryFields.split(&quot;,&quot;);\n&#x27;
                         &#x27;        List&lt;String&gt; primaryKes = &#x27;
                         &#x27;Lists.newArrayList(splitArry);\n&#x27;
                         &#x27;        tableInfo.setPrimaryKeys(primaryKes);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * add parser for alias field\n&#x27;
                         &#x27;     * @param matcher\n&#x27;
                         &#x27;     * @param tableInfo\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void dealNestField(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo) {\n&#x27;
                         &#x27;        String physicalField = matcher.group(1);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),\n&#x27;
                         &#x27;                &quot;No need to add data types when &#x27;
                         &#x27;using functions, The correct way is : strLen(name) &#x27;
                         &#x27;as nameSize, &quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String fieldType = matcher.group(3);\n&#x27;
                         &#x27;        String mappingField = matcher.group(4);\n&#x27;
                         &#x27;        Class fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;        boolean notNull = matcher.group(5) != null;\n&#x27;
                         &#x27;        TableInfo.FieldExtraInfo fieldExtraInfo = &#x27;
                         &#x27;new TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;        fieldExtraInfo.setNotNull(notNull);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.addPhysicalMappings(mappingField, &#x27;
                         &#x27;physicalField);\n&#x27;
                         &#x27;        tableInfo.addField(mappingField);\n&#x27;
                         &#x27;        tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;        tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public Class dbTypeConvertToJavaType(String &#x27;
                         &#x27;fieldType) {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;ClassUtil.stringConvertClass(fieldType);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void addParserHandler(String &#x27;
                         &#x27;parserName, Pattern pattern, ITableFieldDealHandler &#x27;
                         &#x27;handler) {\n&#x27;
                         &#x27;        patternMap.put(parserName, pattern);\n&#x27;
                         &#x27;        handlerMap.put(parserName, handler);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.ClassUtil;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                         &#x27;import com.google.common.base.Preconditions;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.regex.Matcher;\n&#x27;
                         &#x27;import java.util.regex.Pattern;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/7/4\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AbsTableParser {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String PRIMARY_KEY = &#x27;
                         &#x27;&quot;primaryKey&quot;;\n&#x27;
                         &#x27;    private static final String NEST_JSON_FIELD_KEY &#x27;
                         &#x27;= &quot;nestFieldKey&quot;;\n&#x27;
                         &#x27;    private static final String CHAR_TYPE_NO_LENGTH &#x27;
                         &#x27;= &quot;CHAR&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static Pattern primaryKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)PRIMARY\\\\s+KEY\\\\s*\\\\((.*)\\\\)&quot;);\n&#x27;
                         &#x27;    private static Pattern nestJsonFieldKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)((@*\\\\S+\\\\.)*\\\\S+)\\\\s+(\\\\w+)\\\\s+AS\\\\s+(\\\\w+)(\\\\s+NOT\\\\s+NULL)?$&quot;);\n&#x27;
                         &#x27;    private static Pattern physicalFieldFunPattern = &#x27;
                         &#x27;Pattern.compile(&quot;\\\\w+\\\\((\\\\w+)\\\\)$&quot;);\n&#x27;
                         &#x27;    private static Pattern charTypePattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)CHAR\\\\((\\\\d*)\\\\)$&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, Pattern&gt; patternMap = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, ITableFieldDealHandler&gt; &#x27;
                         &#x27;handlerMap = Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AbsTableParser() {\n&#x27;
                         &#x27;        addParserHandler(PRIMARY_KEY, &#x27;
                         &#x27;primaryKeyPattern, this::dealPrimaryKey);\n&#x27;
                         &#x27;        addParserHandler(NEST_JSON_FIELD_KEY, &#x27;
                         &#x27;nestJsonFieldKeyPattern, this::dealNestField);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean fieldNameNeedsUpperCase() {\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract TableInfo getTableInfo(String &#x27;
                         &#x27;tableName, String fieldsInfo, Map&lt;String, Object&gt; &#x27;
                         &#x27;props) throws Exception;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public boolean dealKeyPattern(String fieldRow, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        for(Map.Entry&lt;String, Pattern&gt; keyPattern : &#x27;
                         &#x27;patternMap.entrySet()){\n&#x27;
                         &#x27;            Pattern pattern = &#x27;
                         &#x27;keyPattern.getValue();\n&#x27;
                         &#x27;            String key = keyPattern.getKey();\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;pattern.matcher(fieldRow);\n&#x27;
                         &#x27;            if(matcher.find()){\n&#x27;
                         &#x27;                ITableFieldDealHandler handler = &#x27;
                         &#x27;handlerMap.get(key);\n&#x27;
                         &#x27;                if(handler == null){\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] &#x27;
                         &#x27;error.&quot;);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                handler.dealPrimaryKey(matcher, &#x27;
                         &#x27;tableInfo);\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void parseFieldsInfo(String fieldsInfo, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fieldRows = &#x27;
                         &quot;DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);\n&quot;
                         &#x27;        for(String fieldRow : fieldRows){\n&#x27;
                         &#x27;            fieldRow = fieldRow.trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if(StringUtils.isBlank(fieldRow)){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s],exists &#x27;
                         &#x27;field empty.&quot;, tableInfo.getName()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            String[] filedInfoArr = &#x27;
                         &#x27;fieldRow.split(&quot;\\\\s+&quot;);\n&#x27;
                         &#x27;            if(filedInfoArr.length &lt; 2 ){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s] field &#x27;
                         &#x27;[%s] format error.&quot;, tableInfo.getName(), &#x27;
                         &#x27;fieldRow));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            boolean isMatcherKey = &#x27;
                         &#x27;dealKeyPattern(fieldRow, tableInfo);\n&#x27;
                         &#x27;            if(isMatcherKey){\n&#x27;
                         &#x27;                continue;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //Compatible situation may arise in &#x27;
                         &#x27;space in the fieldName\n&#x27;
                         &#x27;            String[] filedNameArr = new &#x27;
                         &#x27;String[filedInfoArr.length - 1];\n&#x27;
                         &#x27;            System.arraycopy(filedInfoArr, 0, &#x27;
                         &#x27;filedNameArr, 0, filedInfoArr.length - 1);\n&#x27;
                         &#x27;            String fieldName = String.join(&quot; &quot;, &#x27;
                         &#x27;filedNameArr);\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;filedInfoArr[filedInfoArr.length - 1 ].trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Class fieldClass = null;\n&#x27;
                         &#x27;            TableInfo.FieldExtraInfo fieldExtraInfo &#x27;
                         &#x27;= null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;charTypePattern.matcher(fieldType);\n&#x27;
                         &#x27;            if (matcher.find()) {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);\n&#x27;
                         &#x27;                fieldExtraInfo = new &#x27;
                         &#x27;TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;                &#x27;
                         &#x27;fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addPhysicalMappings(filedInfoArr[0],filedInfoArr[0]);\n&#x27;
                         &#x27;            tableInfo.addField(fieldName);\n&#x27;
                         &#x27;            tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;            tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.finish();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void dealPrimaryKey(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        String primaryFields = &#x27;
                         &#x27;matcher.group(1).trim();\n&#x27;
                         &#x27;        String[] splitArry = &#x27;
                         &#x27;primaryFields.split(&quot;,&quot;);\n&#x27;
                         &#x27;        List&lt;String&gt; primaryKes = &#x27;
                         &#x27;Lists.newArrayList(splitArry);\n&#x27;
                         &#x27;        tableInfo.setPrimaryKeys(primaryKes);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * add parser for alias field\n&#x27;
                         &#x27;     * @param matcher\n&#x27;
                         &#x27;     * @param tableInfo\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void dealNestField(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo) {\n&#x27;
                         &#x27;        String physicalField = matcher.group(1);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),\n&#x27;
                         &#x27;                &quot;No need to add data types when &#x27;
                         &#x27;using functions, The correct way is : strLen(name) &#x27;
                         &#x27;as nameSize, &quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String fieldType = matcher.group(3);\n&#x27;
                         &#x27;        String mappingField = matcher.group(4);\n&#x27;
                         &#x27;        Class fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;        boolean notNull = matcher.group(5) != null;\n&#x27;
                         &#x27;        TableInfo.FieldExtraInfo fieldExtraInfo = &#x27;
                         &#x27;new TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;        fieldExtraInfo.setNotNull(notNull);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.addPhysicalMappings(mappingField, &#x27;
                         &#x27;physicalField);\n&#x27;
                         &#x27;        tableInfo.addField(mappingField);\n&#x27;
                         &#x27;        tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;        tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public Class dbTypeConvertToJavaType(String &#x27;
                         &#x27;fieldType) {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;ClassUtil.stringConvertClass(fieldType);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void addParserHandler(String &#x27;
                         &#x27;parserName, Pattern pattern, ITableFieldDealHandler &#x27;
                         &#x27;handler) {\n&#x27;
                         &#x27;        patternMap.put(parserName, pattern);\n&#x27;
                         &#x27;        handlerMap.put(parserName, handler);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.ClassUtil;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                         &#x27;import com.google.common.base.Preconditions;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.regex.Matcher;\n&#x27;
                         &#x27;import java.util.regex.Pattern;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/7/4\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AbsTableParser {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String PRIMARY_KEY = &#x27;
                         &#x27;&quot;primaryKey&quot;;\n&#x27;
                         &#x27;    private static final String NEST_JSON_FIELD_KEY &#x27;
                         &#x27;= &quot;nestFieldKey&quot;;\n&#x27;
                         &#x27;    private static final String CHAR_TYPE_NO_LENGTH &#x27;
                         &#x27;= &quot;CHAR&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static Pattern primaryKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)PRIMARY\\\\s+KEY\\\\s*\\\\((.*)\\\\)&quot;);\n&#x27;
                         &#x27;    private static Pattern nestJsonFieldKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)((@*\\\\S+\\\\.)*\\\\S+)\\\\s+(\\\\w+)\\\\s+AS\\\\s+(\\\\w+)(\\\\s+NOT\\\\s+NULL)?$&quot;);\n&#x27;
                         &#x27;    private static Pattern physicalFieldFunPattern = &#x27;
                         &#x27;Pattern.compile(&quot;\\\\w+\\\\((\\\\w+)\\\\)$&quot;);\n&#x27;
                         &#x27;    private static Pattern charTypePattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)CHAR\\\\((\\\\d*)\\\\)$&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, Pattern&gt; patternMap = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, ITableFieldDealHandler&gt; &#x27;
                         &#x27;handlerMap = Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AbsTableParser() {\n&#x27;
                         &#x27;        addParserHandler(PRIMARY_KEY, &#x27;
                         &#x27;primaryKeyPattern, this::dealPrimaryKey);\n&#x27;
                         &#x27;        addParserHandler(NEST_JSON_FIELD_KEY, &#x27;
                         &#x27;nestJsonFieldKeyPattern, this::dealNestField);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean fieldNameNeedsUpperCase() {\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract TableInfo getTableInfo(String &#x27;
                         &#x27;tableName, String fieldsInfo, Map&lt;String, Object&gt; &#x27;
                         &#x27;props) throws Exception;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public boolean dealKeyPattern(String fieldRow, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        for(Map.Entry&lt;String, Pattern&gt; keyPattern : &#x27;
                         &#x27;patternMap.entrySet()){\n&#x27;
                         &#x27;            Pattern pattern = &#x27;
                         &#x27;keyPattern.getValue();\n&#x27;
                         &#x27;            String key = keyPattern.getKey();\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;pattern.matcher(fieldRow);\n&#x27;
                         &#x27;            if(matcher.find()){\n&#x27;
                         &#x27;                ITableFieldDealHandler handler = &#x27;
                         &#x27;handlerMap.get(key);\n&#x27;
                         &#x27;                if(handler == null){\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] &#x27;
                         &#x27;error.&quot;);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                handler.dealPrimaryKey(matcher, &#x27;
                         &#x27;tableInfo);\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void parseFieldsInfo(String fieldsInfo, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fieldRows = &#x27;
                         &quot;DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);\n&quot;
                         &#x27;        for(String fieldRow : fieldRows){\n&#x27;
                         &#x27;            fieldRow = fieldRow.trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if(StringUtils.isBlank(fieldRow)){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s],exists &#x27;
                         &#x27;field empty.&quot;, tableInfo.getName()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            String[] filedInfoArr = &#x27;
                         &#x27;fieldRow.split(&quot;\\\\s+&quot;);\n&#x27;
                         &#x27;            if(filedInfoArr.length &lt; 2 ){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s] field &#x27;
                         &#x27;[%s] format error.&quot;, tableInfo.getName(), &#x27;
                         &#x27;fieldRow));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            boolean isMatcherKey = &#x27;
                         &#x27;dealKeyPattern(fieldRow, tableInfo);\n&#x27;
                         &#x27;            if(isMatcherKey){\n&#x27;
                         &#x27;                continue;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //Compatible situation may arise in &#x27;
                         &#x27;space in the fieldName\n&#x27;
                         &#x27;            String[] filedNameArr = new &#x27;
                         &#x27;String[filedInfoArr.length - 1];\n&#x27;
                         &#x27;            System.arraycopy(filedInfoArr, 0, &#x27;
                         &#x27;filedNameArr, 0, filedInfoArr.length - 1);\n&#x27;
                         &#x27;            String fieldName = String.join(&quot; &quot;, &#x27;
                         &#x27;filedNameArr);\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;filedInfoArr[filedInfoArr.length - 1 ].trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Class fieldClass = null;\n&#x27;
                         &#x27;            TableInfo.FieldExtraInfo fieldExtraInfo &#x27;
                         &#x27;= null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;charTypePattern.matcher(fieldType);\n&#x27;
                         &#x27;            if (matcher.find()) {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);\n&#x27;
                         &#x27;                fieldExtraInfo = new &#x27;
                         &#x27;TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;                &#x27;
                         &#x27;fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addPhysicalMappings(filedInfoArr[0],filedInfoArr[0]);\n&#x27;
                         &#x27;            tableInfo.addField(fieldName);\n&#x27;
                         &#x27;            tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;            tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.finish();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void dealPrimaryKey(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        String primaryFields = &#x27;
                         &#x27;matcher.group(1).trim();\n&#x27;
                         &#x27;        String[] splitArry = &#x27;
                         &#x27;primaryFields.split(&quot;,&quot;);\n&#x27;
                         &#x27;        List&lt;String&gt; primaryKes = &#x27;
                         &#x27;Lists.newArrayList(splitArry);\n&#x27;
                         &#x27;        tableInfo.setPrimaryKeys(primaryKes);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * add parser for alias field\n&#x27;
                         &#x27;     * @param matcher\n&#x27;
                         &#x27;     * @param tableInfo\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void dealNestField(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo) {\n&#x27;
                         &#x27;        String physicalField = matcher.group(1);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),\n&#x27;
                         &#x27;                &quot;No need to add data types when &#x27;
                         &#x27;using functions, The correct way is : strLen(name) &#x27;
                         &#x27;as nameSize, &quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String fieldType = matcher.group(3);\n&#x27;
                         &#x27;        String mappingField = matcher.group(4);\n&#x27;
                         &#x27;        Class fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;        boolean notNull = matcher.group(5) != null;\n&#x27;
                         &#x27;        TableInfo.FieldExtraInfo fieldExtraInfo = &#x27;
                         &#x27;new TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;        fieldExtraInfo.setNotNull(notNull);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.addPhysicalMappings(mappingField, &#x27;
                         &#x27;physicalField);\n&#x27;
                         &#x27;        tableInfo.addField(mappingField);\n&#x27;
                         &#x27;        tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;        tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public Class dbTypeConvertToJavaType(String &#x27;
                         &#x27;fieldType) {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;ClassUtil.stringConvertClass(fieldType);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void addParserHandler(String &#x27;
                         &#x27;parserName, Pattern pattern, ITableFieldDealHandler &#x27;
                         &#x27;handler) {\n&#x27;
                         &#x27;        patternMap.put(parserName, pattern);\n&#x27;
                         &#x27;        handlerMap.put(parserName, handler);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.ClassUtil;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                         &#x27;import com.google.common.base.Preconditions;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.regex.Matcher;\n&#x27;
                         &#x27;import java.util.regex.Pattern;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/7/4\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AbsTableParser {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String PRIMARY_KEY = &#x27;
                         &#x27;&quot;primaryKey&quot;;\n&#x27;
                         &#x27;    private static final String NEST_JSON_FIELD_KEY &#x27;
                         &#x27;= &quot;nestFieldKey&quot;;\n&#x27;
                         &#x27;    private static final String CHAR_TYPE_NO_LENGTH &#x27;
                         &#x27;= &quot;CHAR&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static Pattern primaryKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)PRIMARY\\\\s+KEY\\\\s*\\\\((.*)\\\\)&quot;);\n&#x27;
                         &#x27;    private static Pattern nestJsonFieldKeyPattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)((@*\\\\S+\\\\.)*\\\\S+)\\\\s+(\\\\w+)\\\\s+AS\\\\s+(\\\\w+)(\\\\s+NOT\\\\s+NULL)?$&quot;);\n&#x27;
                         &#x27;    private static Pattern physicalFieldFunPattern = &#x27;
                         &#x27;Pattern.compile(&quot;\\\\w+\\\\((\\\\w+)\\\\)$&quot;);\n&#x27;
                         &#x27;    private static Pattern charTypePattern = &#x27;
                         &#x27;Pattern.compile(&quot;(?i)CHAR\\\\((\\\\d*)\\\\)$&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, Pattern&gt; patternMap = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Map&lt;String, ITableFieldDealHandler&gt; &#x27;
                         &#x27;handlerMap = Maps.newHashMap();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AbsTableParser() {\n&#x27;
                         &#x27;        addParserHandler(PRIMARY_KEY, &#x27;
                         &#x27;primaryKeyPattern, this::dealPrimaryKey);\n&#x27;
                         &#x27;        addParserHandler(NEST_JSON_FIELD_KEY, &#x27;
                         &#x27;nestJsonFieldKeyPattern, this::dealNestField);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean fieldNameNeedsUpperCase() {\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract TableInfo getTableInfo(String &#x27;
                         &#x27;tableName, String fieldsInfo, Map&lt;String, Object&gt; &#x27;
                         &#x27;props) throws Exception;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public boolean dealKeyPattern(String fieldRow, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        for(Map.Entry&lt;String, Pattern&gt; keyPattern : &#x27;
                         &#x27;patternMap.entrySet()){\n&#x27;
                         &#x27;            Pattern pattern = &#x27;
                         &#x27;keyPattern.getValue();\n&#x27;
                         &#x27;            String key = keyPattern.getKey();\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;pattern.matcher(fieldRow);\n&#x27;
                         &#x27;            if(matcher.find()){\n&#x27;
                         &#x27;                ITableFieldDealHandler handler = &#x27;
                         &#x27;handlerMap.get(key);\n&#x27;
                         &#x27;                if(handler == null){\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] &#x27;
                         &#x27;error.&quot;);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                handler.dealPrimaryKey(matcher, &#x27;
                         &#x27;tableInfo);\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void parseFieldsInfo(String fieldsInfo, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fieldRows = &#x27;
                         &quot;DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);\n&quot;
                         &#x27;        for(String fieldRow : fieldRows){\n&#x27;
                         &#x27;            fieldRow = fieldRow.trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if(StringUtils.isBlank(fieldRow)){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s],exists &#x27;
                         &#x27;field empty.&quot;, tableInfo.getName()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            String[] filedInfoArr = &#x27;
                         &#x27;fieldRow.split(&quot;\\\\s+&quot;);\n&#x27;
                         &#x27;            if(filedInfoArr.length &lt; 2 ){\n&#x27;
                         &#x27;                throw new &#x27;
                         &#x27;RuntimeException(String.format(&quot;table [%s] field &#x27;
                         &#x27;[%s] format error.&quot;, tableInfo.getName(), &#x27;
                         &#x27;fieldRow));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            boolean isMatcherKey = &#x27;
                         &#x27;dealKeyPattern(fieldRow, tableInfo);\n&#x27;
                         &#x27;            if(isMatcherKey){\n&#x27;
                         &#x27;                continue;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //Compatible situation may arise in &#x27;
                         &#x27;space in the fieldName\n&#x27;
                         &#x27;            String[] filedNameArr = new &#x27;
                         &#x27;String[filedInfoArr.length - 1];\n&#x27;
                         &#x27;            System.arraycopy(filedInfoArr, 0, &#x27;
                         &#x27;filedNameArr, 0, filedInfoArr.length - 1);\n&#x27;
                         &#x27;            String fieldName = String.join(&quot; &quot;, &#x27;
                         &#x27;filedNameArr);\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;filedInfoArr[filedInfoArr.length - 1 ].trim();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Class fieldClass = null;\n&#x27;
                         &#x27;            TableInfo.FieldExtraInfo fieldExtraInfo &#x27;
                         &#x27;= null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            Matcher matcher = &#x27;
                         &#x27;charTypePattern.matcher(fieldType);\n&#x27;
                         &#x27;            if (matcher.find()) {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);\n&#x27;
                         &#x27;                fieldExtraInfo = new &#x27;
                         &#x27;TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;                &#x27;
                         &#x27;fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addPhysicalMappings(filedInfoArr[0],filedInfoArr[0]);\n&#x27;
                         &#x27;            tableInfo.addField(fieldName);\n&#x27;
                         &#x27;            tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;            tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.finish();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void dealPrimaryKey(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo){\n&#x27;
                         &#x27;        String primaryFields = &#x27;
                         &#x27;matcher.group(1).trim();\n&#x27;
                         &#x27;        String[] splitArry = &#x27;
                         &#x27;primaryFields.split(&quot;,&quot;);\n&#x27;
                         &#x27;        List&lt;String&gt; primaryKes = &#x27;
                         &#x27;Lists.newArrayList(splitArry);\n&#x27;
                         &#x27;        tableInfo.setPrimaryKeys(primaryKes);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * add parser for alias field\n&#x27;
                         &#x27;     * @param matcher\n&#x27;
                         &#x27;     * @param tableInfo\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void dealNestField(Matcher matcher, &#x27;
                         &#x27;TableInfo tableInfo) {\n&#x27;
                         &#x27;        String physicalField = matcher.group(1);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),\n&#x27;
                         &#x27;                &quot;No need to add data types when &#x27;
                         &#x27;using functions, The correct way is : strLen(name) &#x27;
                         &#x27;as nameSize, &quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String fieldType = matcher.group(3);\n&#x27;
                         &#x27;        String mappingField = matcher.group(4);\n&#x27;
                         &#x27;        Class fieldClass = &#x27;
                         &#x27;dbTypeConvertToJavaType(fieldType);\n&#x27;
                         &#x27;        boolean notNull = matcher.group(5) != null;\n&#x27;
                         &#x27;        TableInfo.FieldExtraInfo fieldExtraInfo = &#x27;
                         &#x27;new TableInfo.FieldExtraInfo();\n&#x27;
                         &#x27;        fieldExtraInfo.setNotNull(notNull);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        tableInfo.addPhysicalMappings(mappingField, &#x27;
                         &#x27;physicalField);\n&#x27;
                         &#x27;        tableInfo.addField(mappingField);\n&#x27;
                         &#x27;        tableInfo.addFieldClass(fieldClass);\n&#x27;
                         &#x27;        tableInfo.addFieldType(fieldType);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;tableInfo.addFieldExtraInfo(fieldExtraInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public Class dbTypeConvertToJavaType(String &#x27;
                         &#x27;fieldType) {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;ClassUtil.stringConvertClass(fieldType);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void addParserHandler(String &#x27;
                         &#x27;parserName, Pattern pattern, ITableFieldDealHandler &#x27;
                         &#x27;handler) {\n&#x27;
                         &#x27;        patternMap.put(parserName, pattern);\n&#x27;
                         &#x27;        handlerMap.put(parserName, handler);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        