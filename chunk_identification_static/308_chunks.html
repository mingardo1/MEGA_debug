<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>308 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.impala;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.impala.table.ImpalaTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.dialect.JDBCDialect;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Objects;\n&#x27;
                         &#x27;import java.util.Optional;\n&#x27;
                         &#x27;import java.util.stream.Collectors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Date: 2020/1/17\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class ImpalaDialect implements JDBCDialect {\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;1L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD = &quot;partition&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String storeType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public ImpalaDialect(TypeInformation[] &#x27;
                         &#x27;fieldTypes,\n&#x27;
                         &#x27;                         List&lt;String&gt; primaryKeys,\n&#x27;
                         &#x27;                         String storeType) {\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        this.primaryKeys = primaryKeys;\n&#x27;
                         &#x27;        this.storeType = storeType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public boolean canHandle(String url) {\n&#x27;
                         &#x27;        return url.startsWith(&quot;jdbc:impala:&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Optional&lt;String&gt; defaultDriverName() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;Optional.of(&quot;com.cloudera.impala.jdbc41.Driver&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String quoteIdentifier(String identifier) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return identifier;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getUpdateStatement(String &#x27;
                         &#x27;tableName, String[] fieldNames, String[] &#x27;
                         &#x27;conditionFields) {\n&#x27;
                         &#x27;        //跳过primary key字段\n&#x27;
                         &#x27;        String setClause = &#x27;
                         &#x27;Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!CollectionUtils.isNotEmpty(primaryKeys) || &#x27;
                         &#x27;!primaryKeys.contains(f))\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String conditionClause = &#x27;
                         &#x27;Arrays.stream(conditionFields)\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot; AND &#x27;
                         &#x27;&quot;));\n&#x27;
                         &#x27;        return &quot;UPDATE &quot; + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot; SET &quot; + setClause +\n&#x27;
                         &#x27;                &quot; WHERE &quot; + conditionClause;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getInsertIntoStatement(String &#x27;
                         &#x27;schema, String tableName, String[] fieldNames, &#x27;
                         &#x27;String[] partitionFields) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String schemaInfo = &#x27;
                         &#x27;StringUtils.isEmpty(schema) ? &quot;&quot; : &#x27;
                         &#x27;quoteIdentifier(schema) + &quot;.&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; partitionFieldsList = &#x27;
                         &#x27;Objects.isNull(partitionFields) ? &#x27;
                         &#x27;Lists.newArrayList() : &#x27;
                         &#x27;Arrays.asList(partitionFields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(storeType.equalsIgnoreCase(ImpalaTableInfo.KUDU_TYPE)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            return buildKuduInsertSql(schemaInfo, &#x27;
                         &#x27;tableName, fieldNames, fieldTypes);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!partitionFieldsList.contains(f))\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionFieldStr = &#x27;
                         &#x27;partitionFieldsList.stream()\n&#x27;
                         &#x27;                .map(field -&gt; &#x27;
                         &#x27;field.replaceAll(&quot;\\&quot;&quot;, &quot;\&#x27;&quot;))\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionStatement = &#x27;
                         &#x27;StringUtils.isEmpty(partitionFieldStr) ? &quot;&quot; : &quot; &quot; + &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD + &quot;(&quot; + partitionFieldStr + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &#x27;
                         &#x27;partitionStatement + &quot; VALUES (&quot; + placeholders + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKuduInsertSql(String &#x27;
                         &#x27;schemaInfo, String tableName, String[] fieldNames, &#x27;
                         &#x27;TypeInformation[] fieldTypes) {  // kudu表的Insert语句\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &quot; VALUES (&quot; + &#x27;
                         &#x27;placeholders + &quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.impala;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.impala.table.ImpalaTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.dialect.JDBCDialect;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Objects;\n&#x27;
                         &#x27;import java.util.Optional;\n&#x27;
                         &#x27;import java.util.stream.Collectors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Date: 2020/1/17\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class ImpalaDialect implements JDBCDialect {\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;1L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD = &quot;partition&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String storeType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public ImpalaDialect(TypeInformation[] &#x27;
                         &#x27;fieldTypes,\n&#x27;
                         &#x27;                         List&lt;String&gt; primaryKeys,\n&#x27;
                         &#x27;                         String storeType) {\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        this.primaryKeys = primaryKeys;\n&#x27;
                         &#x27;        this.storeType = storeType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public boolean canHandle(String url) {\n&#x27;
                         &#x27;        return url.startsWith(&quot;jdbc:impala:&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Optional&lt;String&gt; defaultDriverName() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;Optional.of(&quot;com.cloudera.impala.jdbc41.Driver&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String quoteIdentifier(String identifier) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return identifier;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getUpdateStatement(String &#x27;
                         &#x27;tableName, String[] fieldNames, String[] &#x27;
                         &#x27;conditionFields) {\n&#x27;
                         &#x27;        //跳过primary key字段\n&#x27;
                         &#x27;        String setClause = &#x27;
                         &#x27;Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!CollectionUtils.isNotEmpty(primaryKeys) || &#x27;
                         &#x27;!primaryKeys.contains(f))\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String conditionClause = &#x27;
                         &#x27;Arrays.stream(conditionFields)\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot; AND &#x27;
                         &#x27;&quot;));\n&#x27;
                         &#x27;        return &quot;UPDATE &quot; + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot; SET &quot; + setClause +\n&#x27;
                         &#x27;                &quot; WHERE &quot; + conditionClause;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getInsertIntoStatement(String &#x27;
                         &#x27;schema, String tableName, String[] fieldNames, &#x27;
                         &#x27;String[] partitionFields) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String schemaInfo = &#x27;
                         &#x27;StringUtils.isEmpty(schema) ? &quot;&quot; : &#x27;
                         &#x27;quoteIdentifier(schema) + &quot;.&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; partitionFieldsList = &#x27;
                         &#x27;Objects.isNull(partitionFields) ? &#x27;
                         &#x27;Lists.newArrayList() : &#x27;
                         &#x27;Arrays.asList(partitionFields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(storeType.equalsIgnoreCase(ImpalaTableInfo.KUDU_TYPE)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            return buildKuduInsertSql(schemaInfo, &#x27;
                         &#x27;tableName, fieldNames, fieldTypes);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!partitionFieldsList.contains(f))\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionFieldStr = &#x27;
                         &#x27;partitionFieldsList.stream()\n&#x27;
                         &#x27;                .map(field -&gt; &#x27;
                         &#x27;field.replaceAll(&quot;\\&quot;&quot;, &quot;\&#x27;&quot;))\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionStatement = &#x27;
                         &#x27;StringUtils.isEmpty(partitionFieldStr) ? &quot;&quot; : &quot; &quot; + &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD + &quot;(&quot; + partitionFieldStr + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &#x27;
                         &#x27;partitionStatement + &quot; VALUES (&quot; + placeholders + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKuduInsertSql(String &#x27;
                         &#x27;schemaInfo, String tableName, String[] fieldNames, &#x27;
                         &#x27;TypeInformation[] fieldTypes) {  // kudu表的Insert语句\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &quot; VALUES (&quot; + &#x27;
                         &#x27;placeholders + &quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.impala;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.impala.table.ImpalaTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.dialect.JDBCDialect;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Objects;\n&#x27;
                         &#x27;import java.util.Optional;\n&#x27;
                         &#x27;import java.util.stream.Collectors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Date: 2020/1/17\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class ImpalaDialect implements JDBCDialect {\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;1L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD = &quot;partition&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String storeType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public ImpalaDialect(TypeInformation[] &#x27;
                         &#x27;fieldTypes,\n&#x27;
                         &#x27;                         List&lt;String&gt; primaryKeys,\n&#x27;
                         &#x27;                         String storeType) {\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        this.primaryKeys = primaryKeys;\n&#x27;
                         &#x27;        this.storeType = storeType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public boolean canHandle(String url) {\n&#x27;
                         &#x27;        return url.startsWith(&quot;jdbc:impala:&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Optional&lt;String&gt; defaultDriverName() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;Optional.of(&quot;com.cloudera.impala.jdbc41.Driver&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String quoteIdentifier(String identifier) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return identifier;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getUpdateStatement(String &#x27;
                         &#x27;tableName, String[] fieldNames, String[] &#x27;
                         &#x27;conditionFields) {\n&#x27;
                         &#x27;        //跳过primary key字段\n&#x27;
                         &#x27;        String setClause = &#x27;
                         &#x27;Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!CollectionUtils.isNotEmpty(primaryKeys) || &#x27;
                         &#x27;!primaryKeys.contains(f))\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String conditionClause = &#x27;
                         &#x27;Arrays.stream(conditionFields)\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot; AND &#x27;
                         &#x27;&quot;));\n&#x27;
                         &#x27;        return &quot;UPDATE &quot; + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot; SET &quot; + setClause +\n&#x27;
                         &#x27;                &quot; WHERE &quot; + conditionClause;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getInsertIntoStatement(String &#x27;
                         &#x27;schema, String tableName, String[] fieldNames, &#x27;
                         &#x27;String[] partitionFields) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String schemaInfo = &#x27;
                         &#x27;StringUtils.isEmpty(schema) ? &quot;&quot; : &#x27;
                         &#x27;quoteIdentifier(schema) + &quot;.&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; partitionFieldsList = &#x27;
                         &#x27;Objects.isNull(partitionFields) ? &#x27;
                         &#x27;Lists.newArrayList() : &#x27;
                         &#x27;Arrays.asList(partitionFields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(storeType.equalsIgnoreCase(ImpalaTableInfo.KUDU_TYPE)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            return buildKuduInsertSql(schemaInfo, &#x27;
                         &#x27;tableName, fieldNames, fieldTypes);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!partitionFieldsList.contains(f))\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionFieldStr = &#x27;
                         &#x27;partitionFieldsList.stream()\n&#x27;
                         &#x27;                .map(field -&gt; &#x27;
                         &#x27;field.replaceAll(&quot;\\&quot;&quot;, &quot;\&#x27;&quot;))\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionStatement = &#x27;
                         &#x27;StringUtils.isEmpty(partitionFieldStr) ? &quot;&quot; : &quot; &quot; + &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD + &quot;(&quot; + partitionFieldStr + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &#x27;
                         &#x27;partitionStatement + &quot; VALUES (&quot; + placeholders + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKuduInsertSql(String &#x27;
                         &#x27;schemaInfo, String tableName, String[] fieldNames, &#x27;
                         &#x27;TypeInformation[] fieldTypes) {  // kudu表的Insert语句\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &quot; VALUES (&quot; + &#x27;
                         &#x27;placeholders + &quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.impala;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.impala.table.ImpalaTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.dialect.JDBCDialect;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Objects;\n&#x27;
                         &#x27;import java.util.Optional;\n&#x27;
                         &#x27;import java.util.stream.Collectors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Date: 2020/1/17\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class ImpalaDialect implements JDBCDialect {\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;1L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD = &quot;partition&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String storeType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public ImpalaDialect(TypeInformation[] &#x27;
                         &#x27;fieldTypes,\n&#x27;
                         &#x27;                         List&lt;String&gt; primaryKeys,\n&#x27;
                         &#x27;                         String storeType) {\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        this.primaryKeys = primaryKeys;\n&#x27;
                         &#x27;        this.storeType = storeType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public boolean canHandle(String url) {\n&#x27;
                         &#x27;        return url.startsWith(&quot;jdbc:impala:&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Optional&lt;String&gt; defaultDriverName() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;Optional.of(&quot;com.cloudera.impala.jdbc41.Driver&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String quoteIdentifier(String identifier) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return identifier;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getUpdateStatement(String &#x27;
                         &#x27;tableName, String[] fieldNames, String[] &#x27;
                         &#x27;conditionFields) {\n&#x27;
                         &#x27;        //跳过primary key字段\n&#x27;
                         &#x27;        String setClause = &#x27;
                         &#x27;Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!CollectionUtils.isNotEmpty(primaryKeys) || &#x27;
                         &#x27;!primaryKeys.contains(f))\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String conditionClause = &#x27;
                         &#x27;Arrays.stream(conditionFields)\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot; AND &#x27;
                         &#x27;&quot;));\n&#x27;
                         &#x27;        return &quot;UPDATE &quot; + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot; SET &quot; + setClause +\n&#x27;
                         &#x27;                &quot; WHERE &quot; + conditionClause;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getInsertIntoStatement(String &#x27;
                         &#x27;schema, String tableName, String[] fieldNames, &#x27;
                         &#x27;String[] partitionFields) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String schemaInfo = &#x27;
                         &#x27;StringUtils.isEmpty(schema) ? &quot;&quot; : &#x27;
                         &#x27;quoteIdentifier(schema) + &quot;.&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; partitionFieldsList = &#x27;
                         &#x27;Objects.isNull(partitionFields) ? &#x27;
                         &#x27;Lists.newArrayList() : &#x27;
                         &#x27;Arrays.asList(partitionFields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(storeType.equalsIgnoreCase(ImpalaTableInfo.KUDU_TYPE)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            return buildKuduInsertSql(schemaInfo, &#x27;
                         &#x27;tableName, fieldNames, fieldTypes);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!partitionFieldsList.contains(f))\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionFieldStr = &#x27;
                         &#x27;partitionFieldsList.stream()\n&#x27;
                         &#x27;                .map(field -&gt; &#x27;
                         &#x27;field.replaceAll(&quot;\\&quot;&quot;, &quot;\&#x27;&quot;))\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionStatement = &#x27;
                         &#x27;StringUtils.isEmpty(partitionFieldStr) ? &quot;&quot; : &quot; &quot; + &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD + &quot;(&quot; + partitionFieldStr + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &#x27;
                         &#x27;partitionStatement + &quot; VALUES (&quot; + placeholders + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKuduInsertSql(String &#x27;
                         &#x27;schemaInfo, String tableName, String[] fieldNames, &#x27;
                         &#x27;TypeInformation[] fieldTypes) {  // kudu表的Insert语句\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &quot; VALUES (&quot; + &#x27;
                         &#x27;placeholders + &quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.impala;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.impala.table.ImpalaTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.dialect.JDBCDialect;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Objects;\n&#x27;
                         &#x27;import java.util.Optional;\n&#x27;
                         &#x27;import java.util.stream.Collectors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Date: 2020/1/17\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class ImpalaDialect implements JDBCDialect {\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;1L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD = &quot;partition&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String storeType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public ImpalaDialect(TypeInformation[] &#x27;
                         &#x27;fieldTypes,\n&#x27;
                         &#x27;                         List&lt;String&gt; primaryKeys,\n&#x27;
                         &#x27;                         String storeType) {\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        this.primaryKeys = primaryKeys;\n&#x27;
                         &#x27;        this.storeType = storeType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public boolean canHandle(String url) {\n&#x27;
                         &#x27;        return url.startsWith(&quot;jdbc:impala:&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Optional&lt;String&gt; defaultDriverName() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;Optional.of(&quot;com.cloudera.impala.jdbc41.Driver&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String quoteIdentifier(String identifier) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return identifier;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getUpdateStatement(String &#x27;
                         &#x27;tableName, String[] fieldNames, String[] &#x27;
                         &#x27;conditionFields) {\n&#x27;
                         &#x27;        //跳过primary key字段\n&#x27;
                         &#x27;        String setClause = &#x27;
                         &#x27;Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!CollectionUtils.isNotEmpty(primaryKeys) || &#x27;
                         &#x27;!primaryKeys.contains(f))\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String conditionClause = &#x27;
                         &#x27;Arrays.stream(conditionFields)\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot; AND &#x27;
                         &#x27;&quot;));\n&#x27;
                         &#x27;        return &quot;UPDATE &quot; + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot; SET &quot; + setClause +\n&#x27;
                         &#x27;                &quot; WHERE &quot; + conditionClause;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getInsertIntoStatement(String &#x27;
                         &#x27;schema, String tableName, String[] fieldNames, &#x27;
                         &#x27;String[] partitionFields) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String schemaInfo = &#x27;
                         &#x27;StringUtils.isEmpty(schema) ? &quot;&quot; : &#x27;
                         &#x27;quoteIdentifier(schema) + &quot;.&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; partitionFieldsList = &#x27;
                         &#x27;Objects.isNull(partitionFields) ? &#x27;
                         &#x27;Lists.newArrayList() : &#x27;
                         &#x27;Arrays.asList(partitionFields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(storeType.equalsIgnoreCase(ImpalaTableInfo.KUDU_TYPE)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            return buildKuduInsertSql(schemaInfo, &#x27;
                         &#x27;tableName, fieldNames, fieldTypes);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!partitionFieldsList.contains(f))\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionFieldStr = &#x27;
                         &#x27;partitionFieldsList.stream()\n&#x27;
                         &#x27;                .map(field -&gt; &#x27;
                         &#x27;field.replaceAll(&quot;\\&quot;&quot;, &quot;\&#x27;&quot;))\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionStatement = &#x27;
                         &#x27;StringUtils.isEmpty(partitionFieldStr) ? &quot;&quot; : &quot; &quot; + &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD + &quot;(&quot; + partitionFieldStr + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &#x27;
                         &#x27;partitionStatement + &quot; VALUES (&quot; + placeholders + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKuduInsertSql(String &#x27;
                         &#x27;schemaInfo, String tableName, String[] fieldNames, &#x27;
                         &#x27;TypeInformation[] fieldTypes) {  // kudu表的Insert语句\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &quot; VALUES (&quot; + &#x27;
                         &#x27;placeholders + &quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.impala;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.impala.table.ImpalaTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.dialect.JDBCDialect;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Objects;\n&#x27;
                         &#x27;import java.util.Optional;\n&#x27;
                         &#x27;import java.util.stream.Collectors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Date: 2020/1/17\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class ImpalaDialect implements JDBCDialect {\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;1L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final String &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD = &quot;partition&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String storeType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public ImpalaDialect(TypeInformation[] &#x27;
                         &#x27;fieldTypes,\n&#x27;
                         &#x27;                         List&lt;String&gt; primaryKeys,\n&#x27;
                         &#x27;                         String storeType) {\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        this.primaryKeys = primaryKeys;\n&#x27;
                         &#x27;        this.storeType = storeType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public boolean canHandle(String url) {\n&#x27;
                         &#x27;        return url.startsWith(&quot;jdbc:impala:&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Optional&lt;String&gt; defaultDriverName() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;Optional.of(&quot;com.cloudera.impala.jdbc41.Driver&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String quoteIdentifier(String identifier) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return identifier;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getUpdateStatement(String &#x27;
                         &#x27;tableName, String[] fieldNames, String[] &#x27;
                         &#x27;conditionFields) {\n&#x27;
                         &#x27;        //跳过primary key字段\n&#x27;
                         &#x27;        String setClause = &#x27;
                         &#x27;Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!CollectionUtils.isNotEmpty(primaryKeys) || &#x27;
                         &#x27;!primaryKeys.contains(f))\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String conditionClause = &#x27;
                         &#x27;Arrays.stream(conditionFields)\n&#x27;
                         &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                         &#x27;&quot;=?&quot;)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot; AND &#x27;
                         &#x27;&quot;));\n&#x27;
                         &#x27;        return &quot;UPDATE &quot; + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot; SET &quot; + setClause +\n&#x27;
                         &#x27;                &quot; WHERE &quot; + conditionClause;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String getInsertIntoStatement(String &#x27;
                         &#x27;schema, String tableName, String[] fieldNames, &#x27;
                         &#x27;String[] partitionFields) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String schemaInfo = &#x27;
                         &#x27;StringUtils.isEmpty(schema) ? &quot;&quot; : &#x27;
                         &#x27;quoteIdentifier(schema) + &quot;.&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; partitionFieldsList = &#x27;
                         &#x27;Objects.isNull(partitionFields) ? &#x27;
                         &#x27;Lists.newArrayList() : &#x27;
                         &#x27;Arrays.asList(partitionFields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(storeType.equalsIgnoreCase(ImpalaTableInfo.KUDU_TYPE)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            return buildKuduInsertSql(schemaInfo, &#x27;
                         &#x27;tableName, fieldNames, fieldTypes);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .filter(f -&gt; &#x27;
                         &#x27;!partitionFieldsList.contains(f))\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionFieldStr = &#x27;
                         &#x27;partitionFieldsList.stream()\n&#x27;
                         &#x27;                .map(field -&gt; &#x27;
                         &#x27;field.replaceAll(&quot;\\&quot;&quot;, &quot;\&#x27;&quot;))\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String partitionStatement = &#x27;
                         &#x27;StringUtils.isEmpty(partitionFieldStr) ? &quot;&quot; : &quot; &quot; + &#x27;
                         &#x27;IMPALA_PARTITION_KEYWORD + &quot;(&quot; + partitionFieldStr + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &#x27;
                         &#x27;partitionStatement + &quot; VALUES (&quot; + placeholders + &#x27;
                         &#x27;&quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKuduInsertSql(String &#x27;
                         &#x27;schemaInfo, String tableName, String[] fieldNames, &#x27;
                         &#x27;TypeInformation[] fieldTypes) {  // kudu表的Insert语句\n&#x27;
                         &#x27;        String columns = Arrays.stream(fieldNames)\n&#x27;
                         &#x27;                .map(this::quoteIdentifier)\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        String placeholders = &#x27;
                         &#x27;Arrays.stream(fieldTypes)\n&#x27;
                         &#x27;                .map(f -&gt; {\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(String.class.getName().equals(f.getTypeClass().getName())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        return &quot;cast( ? as &#x27;
                         &#x27;string)&quot;;\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    return &quot;?&quot;;\n&#x27;
                         &#x27;                })\n&#x27;
                         &#x27;                .collect(Collectors.joining(&quot;, &quot;));\n&#x27;
                         &#x27;        return &quot;INSERT INTO &quot; + schemaInfo + &#x27;
                         &#x27;quoteIdentifier(tableName) +\n&#x27;
                         &#x27;                &quot;(&quot; + columns + &quot;)&quot; + &quot; VALUES (&quot; + &#x27;
                         &#x27;placeholders + &quot;)&quot;;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        