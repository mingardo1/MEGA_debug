<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>591 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27; \n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ETableType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTableParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.side.StreamSideFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.MathUtil;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.regex.Matcher;\n&#x27;
                           &#x27;import java.util.regex.Pattern;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Create table statement parsing table structure &#x27;
                           &#x27;to obtain specific information\n&#x27;
                           &#x27; * Date: 2018/6/25\n&#x27;
                           &#x27; * Company: www.dtstack.com\n&#x27;
                           &#x27; * @author xuchao\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class TableInfoParser {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String TYPE_KEY = &#x27;
                           &#x27;&quot;type&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String SIDE_TABLE_SIGN = &#x27;
                           &#x27;&quot;(?i)^PERIOD\\\\s+FOR\\\\s+SYSTEM_TIME$&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static Pattern SIDE_PATTERN = &#x27;
                           &#x27;Pattern.compile(SIDE_TABLE_SIGN);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sourceTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;targetTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sideTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //Parsing loaded plugin\n&#x27;
                           &#x27;    public TableInfo parseWithTableType(int &#x27;
                           &#x27;tableType, CreateTableParser.SqlParserResult &#x27;
                           &#x27;parserResult,\n&#x27;
                           &#x27;                                               &#x27;
                           &#x27;String localPluginRoot) throws Exception {\n&#x27;
                           &#x27;        AbsTableParser absTableParser = null;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; props = &#x27;
                           &#x27;parserResult.getPropMap();\n&#x27;
                           &#x27;        String type = &#x27;
                           &#x27;MathUtil.getString(props.get(TYPE_KEY));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(Strings.isNullOrEmpty(type)){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;create &#x27;
                           &#x27;table statement requires property of type&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(tableType == &#x27;
                           &#x27;ETableType.SOURCE.getType()){\n&#x27;
                           &#x27;            boolean isSideTable = &#x27;
                           &#x27;checkIsSideTable(parserResult.getFieldsInfoStr());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(!isSideTable){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sourceTableInfoMap.get(type);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSourceFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                    sourceTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }else{\n&#x27;
                           &#x27;                String cacheType = &#x27;
                           &#x27;MathUtil.getString(props.get(SideTableInfo.CACHE_KEY));\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sideTableInfoMap.get(type + cacheType);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSideFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot, cacheType);\n&#x27;
                           &#x27;                    sideTableInfoMap.put(type + &#x27;
                           &#x27;cacheType, absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        }else if(tableType == &#x27;
                           &#x27;ETableType.SINK.getType()){\n&#x27;
                           &#x27;            absTableParser = &#x27;
                           &#x27;targetTableInfoMap.get(type);\n&#x27;
                           &#x27;            if(absTableParser == null){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;StreamSinkFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                targetTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(absTableParser == null){\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support %s &#x27;
                           &#x27;type of table&quot;, type));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; prop = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Shield case\n&#x27;
                           &#x27;        &#x27;
                           &#x27;parserResult.getPropMap().forEach((key,val) -&gt; &#x27;
                           &#x27;prop.put(key.toLowerCase(), val));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;absTableParser.getTableInfo(parserResult.getTableName(), &#x27;
                           &#x27;parserResult.getFieldsInfoStr(), prop);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * judge dim table of PERIOD FOR SYSTEM_TIME\n&#x27;
                           &#x27;     * @param tableField\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static boolean checkIsSideTable(String &#x27;
                           &#x27;tableField){\n&#x27;
                           &#x27;        String[] fieldInfos = &#x27;
                           &#x27;StringUtils.split(tableField, &quot;,&quot;);\n&#x27;
                           &#x27;        for(String field : fieldInfos){\n&#x27;
                           &#x27;            Matcher matcher = &#x27;
                           &#x27;SIDE_PATTERN.matcher(field.trim());\n&#x27;
                           &#x27;            if(matcher.find()){\n&#x27;
                           &#x27;                return true;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ETableType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTableParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.side.StreamSideFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.MathUtil;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.regex.Matcher;\n&#x27;
                           &#x27;import java.util.regex.Pattern;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Create table statement parsing table structure &#x27;
                           &#x27;to obtain specific information\n&#x27;
                           &#x27; * Date: 2018/6/25\n&#x27;
                           &#x27; * Company: www.dtstack.com\n&#x27;
                           &#x27; * @author xuchao\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class TableInfoParser {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String TYPE_KEY = &#x27;
                           &#x27;&quot;type&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String SIDE_TABLE_SIGN = &#x27;
                           &#x27;&quot;(?i)^PERIOD\\\\s+FOR\\\\s+SYSTEM_TIME$&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static Pattern SIDE_PATTERN = &#x27;
                           &#x27;Pattern.compile(SIDE_TABLE_SIGN);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sourceTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;targetTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sideTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //Parsing loaded plugin\n&#x27;
                           &#x27;    public TableInfo parseWithTableType(int &#x27;
                           &#x27;tableType, CreateTableParser.SqlParserResult &#x27;
                           &#x27;parserResult,\n&#x27;
                           &#x27;                                               &#x27;
                           &#x27;String localPluginRoot) throws Exception {\n&#x27;
                           &#x27;        AbsTableParser absTableParser = null;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; props = &#x27;
                           &#x27;parserResult.getPropMap();\n&#x27;
                           &#x27;        String type = &#x27;
                           &#x27;MathUtil.getString(props.get(TYPE_KEY));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(Strings.isNullOrEmpty(type)){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;create &#x27;
                           &#x27;table statement requires property of type&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(tableType == &#x27;
                           &#x27;ETableType.SOURCE.getType()){\n&#x27;
                           &#x27;            boolean isSideTable = &#x27;
                           &#x27;checkIsSideTable(parserResult.getFieldsInfoStr());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(!isSideTable){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sourceTableInfoMap.get(type);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSourceFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                    sourceTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }else{\n&#x27;
                           &#x27;                String cacheType = &#x27;
                           &#x27;MathUtil.getString(props.get(SideTableInfo.CACHE_KEY));\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sideTableInfoMap.get(type + cacheType);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSideFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot, cacheType);\n&#x27;
                           &#x27;                    sideTableInfoMap.put(type + &#x27;
                           &#x27;cacheType, absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        }else if(tableType == &#x27;
                           &#x27;ETableType.SINK.getType()){\n&#x27;
                           &#x27;            absTableParser = &#x27;
                           &#x27;targetTableInfoMap.get(type);\n&#x27;
                           &#x27;            if(absTableParser == null){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;StreamSinkFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                targetTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(absTableParser == null){\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support %s &#x27;
                           &#x27;type of table&quot;, type));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; prop = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Shield case\n&#x27;
                           &#x27;        &#x27;
                           &#x27;parserResult.getPropMap().forEach((key,val) -&gt; &#x27;
                           &#x27;prop.put(key.toLowerCase(), val));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;absTableParser.getTableInfo(parserResult.getTableName(), &#x27;
                           &#x27;parserResult.getFieldsInfoStr(), prop);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * judge dim table of PERIOD FOR SYSTEM_TIME\n&#x27;
                           &#x27;     * @param tableField\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static boolean checkIsSideTable(String &#x27;
                           &#x27;tableField){\n&#x27;
                           &#x27;        String[] fieldInfos = &#x27;
                           &#x27;StringUtils.split(tableField, &quot;,&quot;);\n&#x27;
                           &#x27;        for(String field : fieldInfos){\n&#x27;
                           &#x27;            Matcher matcher = &#x27;
                           &#x27;SIDE_PATTERN.matcher(field.trim());\n&#x27;
                           &#x27;            if(matcher.find()){\n&#x27;
                           &#x27;                return true;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ETableType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTableParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.side.StreamSideFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.MathUtil;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.regex.Matcher;\n&#x27;
                           &#x27;import java.util.regex.Pattern;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Create table statement parsing table structure &#x27;
                           &#x27;to obtain specific information\n&#x27;
                           &#x27; * Date: 2018/6/25\n&#x27;
                           &#x27; * Company: www.dtstack.com\n&#x27;
                           &#x27; * @author xuchao\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class TableInfoParser {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String TYPE_KEY = &#x27;
                           &#x27;&quot;type&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String SIDE_TABLE_SIGN = &#x27;
                           &#x27;&quot;(?i)^PERIOD\\\\s+FOR\\\\s+SYSTEM_TIME$&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static Pattern SIDE_PATTERN = &#x27;
                           &#x27;Pattern.compile(SIDE_TABLE_SIGN);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sourceTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;targetTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sideTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //Parsing loaded plugin\n&#x27;
                           &#x27;    public TableInfo parseWithTableType(int &#x27;
                           &#x27;tableType, CreateTableParser.SqlParserResult &#x27;
                           &#x27;parserResult,\n&#x27;
                           &#x27;                                               &#x27;
                           &#x27;String localPluginRoot) throws Exception {\n&#x27;
                           &#x27;        AbsTableParser absTableParser = null;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; props = &#x27;
                           &#x27;parserResult.getPropMap();\n&#x27;
                           &#x27;        String type = &#x27;
                           &#x27;MathUtil.getString(props.get(TYPE_KEY));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(Strings.isNullOrEmpty(type)){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;create &#x27;
                           &#x27;table statement requires property of type&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(tableType == &#x27;
                           &#x27;ETableType.SOURCE.getType()){\n&#x27;
                           &#x27;            boolean isSideTable = &#x27;
                           &#x27;checkIsSideTable(parserResult.getFieldsInfoStr());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(!isSideTable){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sourceTableInfoMap.get(type);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSourceFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                    sourceTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }else{\n&#x27;
                           &#x27;                String cacheType = &#x27;
                           &#x27;MathUtil.getString(props.get(SideTableInfo.CACHE_KEY));\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sideTableInfoMap.get(type + cacheType);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSideFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot, cacheType);\n&#x27;
                           &#x27;                    sideTableInfoMap.put(type + &#x27;
                           &#x27;cacheType, absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        }else if(tableType == &#x27;
                           &#x27;ETableType.SINK.getType()){\n&#x27;
                           &#x27;            absTableParser = &#x27;
                           &#x27;targetTableInfoMap.get(type);\n&#x27;
                           &#x27;            if(absTableParser == null){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;StreamSinkFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                targetTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(absTableParser == null){\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support %s &#x27;
                           &#x27;type of table&quot;, type));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; prop = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Shield case\n&#x27;
                           &#x27;        &#x27;
                           &#x27;parserResult.getPropMap().forEach((key,val) -&gt; &#x27;
                           &#x27;prop.put(key.toLowerCase(), val));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;absTableParser.getTableInfo(parserResult.getTableName(), &#x27;
                           &#x27;parserResult.getFieldsInfoStr(), prop);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * judge dim table of PERIOD FOR SYSTEM_TIME\n&#x27;
                           &#x27;     * @param tableField\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static boolean checkIsSideTable(String &#x27;
                           &#x27;tableField){\n&#x27;
                           &#x27;        String[] fieldInfos = &#x27;
                           &#x27;StringUtils.split(tableField, &quot;,&quot;);\n&#x27;
                           &#x27;        for(String field : fieldInfos){\n&#x27;
                           &#x27;            Matcher matcher = &#x27;
                           &#x27;SIDE_PATTERN.matcher(field.trim());\n&#x27;
                           &#x27;            if(matcher.find()){\n&#x27;
                           &#x27;                return true;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27; \n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ETableType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTableParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.side.StreamSideFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.MathUtil;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.regex.Matcher;\n&#x27;
                           &#x27;import java.util.regex.Pattern;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Create table statement parsing table structure &#x27;
                           &#x27;to obtain specific information\n&#x27;
                           &#x27; * Date: 2018/6/25\n&#x27;
                           &#x27; * Company: www.dtstack.com\n&#x27;
                           &#x27; * @author xuchao\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class TableInfoParser {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String TYPE_KEY = &#x27;
                           &#x27;&quot;type&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String SIDE_TABLE_SIGN = &#x27;
                           &#x27;&quot;(?i)^PERIOD\\\\s+FOR\\\\s+SYSTEM_TIME$&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static Pattern SIDE_PATTERN = &#x27;
                           &#x27;Pattern.compile(SIDE_TABLE_SIGN);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sourceTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;targetTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sideTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //Parsing loaded plugin\n&#x27;
                           &#x27;    public TableInfo parseWithTableType(int &#x27;
                           &#x27;tableType, CreateTableParser.SqlParserResult &#x27;
                           &#x27;parserResult,\n&#x27;
                           &#x27;                                               &#x27;
                           &#x27;String localPluginRoot) throws Exception {\n&#x27;
                           &#x27;        AbsTableParser absTableParser = null;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; props = &#x27;
                           &#x27;parserResult.getPropMap();\n&#x27;
                           &#x27;        String type = &#x27;
                           &#x27;MathUtil.getString(props.get(TYPE_KEY));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(Strings.isNullOrEmpty(type)){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;create &#x27;
                           &#x27;table statement requires property of type&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(tableType == &#x27;
                           &#x27;ETableType.SOURCE.getType()){\n&#x27;
                           &#x27;            boolean isSideTable = &#x27;
                           &#x27;checkIsSideTable(parserResult.getFieldsInfoStr());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(!isSideTable){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sourceTableInfoMap.get(type);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSourceFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                    sourceTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }else{\n&#x27;
                           &#x27;                String cacheType = &#x27;
                           &#x27;MathUtil.getString(props.get(SideTableInfo.CACHE_KEY));\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sideTableInfoMap.get(type + cacheType);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSideFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot, cacheType);\n&#x27;
                           &#x27;                    sideTableInfoMap.put(type + &#x27;
                           &#x27;cacheType, absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        }else if(tableType == &#x27;
                           &#x27;ETableType.SINK.getType()){\n&#x27;
                           &#x27;            absTableParser = &#x27;
                           &#x27;targetTableInfoMap.get(type);\n&#x27;
                           &#x27;            if(absTableParser == null){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;StreamSinkFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                targetTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(absTableParser == null){\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support %s &#x27;
                           &#x27;type of table&quot;, type));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; prop = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Shield case\n&#x27;
                           &#x27;        &#x27;
                           &#x27;parserResult.getPropMap().forEach((key,val) -&gt; &#x27;
                           &#x27;prop.put(key.toLowerCase(), val));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;absTableParser.getTableInfo(parserResult.getTableName(), &#x27;
                           &#x27;parserResult.getFieldsInfoStr(), prop);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * judge dim table of PERIOD FOR SYSTEM_TIME\n&#x27;
                           &#x27;     * @param tableField\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static boolean checkIsSideTable(String &#x27;
                           &#x27;tableField){\n&#x27;
                           &#x27;        String[] fieldInfos = &#x27;
                           &#x27;StringUtils.split(tableField, &quot;,&quot;);\n&#x27;
                           &#x27;        for(String field : fieldInfos){\n&#x27;
                           &#x27;            Matcher matcher = &#x27;
                           &#x27;SIDE_PATTERN.matcher(field.trim());\n&#x27;
                           &#x27;            if(matcher.find()){\n&#x27;
                           &#x27;                return true;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ETableType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTableParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.side.StreamSideFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.MathUtil;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.regex.Matcher;\n&#x27;
                           &#x27;import java.util.regex.Pattern;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Create table statement parsing table structure &#x27;
                           &#x27;to obtain specific information\n&#x27;
                           &#x27; * Date: 2018/6/25\n&#x27;
                           &#x27; * Company: www.dtstack.com\n&#x27;
                           &#x27; * @author xuchao\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class TableInfoParser {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String TYPE_KEY = &#x27;
                           &#x27;&quot;type&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String SIDE_TABLE_SIGN = &#x27;
                           &#x27;&quot;(?i)^PERIOD\\\\s+FOR\\\\s+SYSTEM_TIME$&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static Pattern SIDE_PATTERN = &#x27;
                           &#x27;Pattern.compile(SIDE_TABLE_SIGN);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sourceTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;targetTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sideTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //Parsing loaded plugin\n&#x27;
                           &#x27;    public TableInfo parseWithTableType(int &#x27;
                           &#x27;tableType, CreateTableParser.SqlParserResult &#x27;
                           &#x27;parserResult,\n&#x27;
                           &#x27;                                               &#x27;
                           &#x27;String localPluginRoot) throws Exception {\n&#x27;
                           &#x27;        AbsTableParser absTableParser = null;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; props = &#x27;
                           &#x27;parserResult.getPropMap();\n&#x27;
                           &#x27;        String type = &#x27;
                           &#x27;MathUtil.getString(props.get(TYPE_KEY));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(Strings.isNullOrEmpty(type)){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;create &#x27;
                           &#x27;table statement requires property of type&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(tableType == &#x27;
                           &#x27;ETableType.SOURCE.getType()){\n&#x27;
                           &#x27;            boolean isSideTable = &#x27;
                           &#x27;checkIsSideTable(parserResult.getFieldsInfoStr());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(!isSideTable){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sourceTableInfoMap.get(type);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSourceFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                    sourceTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }else{\n&#x27;
                           &#x27;                String cacheType = &#x27;
                           &#x27;MathUtil.getString(props.get(SideTableInfo.CACHE_KEY));\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sideTableInfoMap.get(type + cacheType);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSideFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot, cacheType);\n&#x27;
                           &#x27;                    sideTableInfoMap.put(type + &#x27;
                           &#x27;cacheType, absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        }else if(tableType == &#x27;
                           &#x27;ETableType.SINK.getType()){\n&#x27;
                           &#x27;            absTableParser = &#x27;
                           &#x27;targetTableInfoMap.get(type);\n&#x27;
                           &#x27;            if(absTableParser == null){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;StreamSinkFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                targetTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(absTableParser == null){\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support %s &#x27;
                           &#x27;type of table&quot;, type));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; prop = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Shield case\n&#x27;
                           &#x27;        &#x27;
                           &#x27;parserResult.getPropMap().forEach((key,val) -&gt; &#x27;
                           &#x27;prop.put(key.toLowerCase(), val));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;absTableParser.getTableInfo(parserResult.getTableName(), &#x27;
                           &#x27;parserResult.getFieldsInfoStr(), prop);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * judge dim table of PERIOD FOR SYSTEM_TIME\n&#x27;
                           &#x27;     * @param tableField\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static boolean checkIsSideTable(String &#x27;
                           &#x27;tableField){\n&#x27;
                           &#x27;        String[] fieldInfos = &#x27;
                           &#x27;StringUtils.split(tableField, &quot;,&quot;);\n&#x27;
                           &#x27;        for(String field : fieldInfos){\n&#x27;
                           &#x27;            Matcher matcher = &#x27;
                           &#x27;SIDE_PATTERN.matcher(field.trim());\n&#x27;
                           &#x27;            if(matcher.find()){\n&#x27;
                           &#x27;                return true;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one\n&#x27;
                           &#x27; * or more contributor license agreements.  See &#x27;
                           &#x27;the NOTICE file\n&#x27;
                           &#x27; * distributed with this work for additional &#x27;
                           &#x27;information\n&#x27;
                           &#x27; * regarding copyright ownership.  The ASF &#x27;
                           &#x27;licenses this file\n&#x27;
                           &#x27; * to you under the Apache License, Version 2.0 &#x27;
                           &#x27;(the\n&#x27;
                           &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                           &#x27;compliance\n&#x27;
                           &#x27; * with the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package com.dtstack.flink.sql.table;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ETableType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTableParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.side.StreamSideFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.MathUtil;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.regex.Matcher;\n&#x27;
                           &#x27;import java.util.regex.Pattern;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * Create table statement parsing table structure &#x27;
                           &#x27;to obtain specific information\n&#x27;
                           &#x27; * Date: 2018/6/25\n&#x27;
                           &#x27; * Company: www.dtstack.com\n&#x27;
                           &#x27; * @author xuchao\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public class TableInfoParser {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String TYPE_KEY = &#x27;
                           &#x27;&quot;type&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static String SIDE_TABLE_SIGN = &#x27;
                           &#x27;&quot;(?i)^PERIOD\\\\s+FOR\\\\s+SYSTEM_TIME$&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final static Pattern SIDE_PATTERN = &#x27;
                           &#x27;Pattern.compile(SIDE_TABLE_SIGN);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sourceTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;targetTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private  Map&lt;String, AbsTableParser&gt; &#x27;
                           &#x27;sideTableInfoMap = Maps.newConcurrentMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    //Parsing loaded plugin\n&#x27;
                           &#x27;    public TableInfo parseWithTableType(int &#x27;
                           &#x27;tableType, CreateTableParser.SqlParserResult &#x27;
                           &#x27;parserResult,\n&#x27;
                           &#x27;                                               &#x27;
                           &#x27;String localPluginRoot) throws Exception {\n&#x27;
                           &#x27;        AbsTableParser absTableParser = null;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; props = &#x27;
                           &#x27;parserResult.getPropMap();\n&#x27;
                           &#x27;        String type = &#x27;
                           &#x27;MathUtil.getString(props.get(TYPE_KEY));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(Strings.isNullOrEmpty(type)){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;create &#x27;
                           &#x27;table statement requires property of type&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(tableType == &#x27;
                           &#x27;ETableType.SOURCE.getType()){\n&#x27;
                           &#x27;            boolean isSideTable = &#x27;
                           &#x27;checkIsSideTable(parserResult.getFieldsInfoStr());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(!isSideTable){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sourceTableInfoMap.get(type);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSourceFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                    sourceTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }else{\n&#x27;
                           &#x27;                String cacheType = &#x27;
                           &#x27;MathUtil.getString(props.get(SideTableInfo.CACHE_KEY));\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;sideTableInfoMap.get(type + cacheType);\n&#x27;
                           &#x27;                if(absTableParser == null){\n&#x27;
                           &#x27;                    absTableParser = &#x27;
                           &#x27;StreamSideFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot, cacheType);\n&#x27;
                           &#x27;                    sideTableInfoMap.put(type + &#x27;
                           &#x27;cacheType, absTableParser);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        }else if(tableType == &#x27;
                           &#x27;ETableType.SINK.getType()){\n&#x27;
                           &#x27;            absTableParser = &#x27;
                           &#x27;targetTableInfoMap.get(type);\n&#x27;
                           &#x27;            if(absTableParser == null){\n&#x27;
                           &#x27;                absTableParser = &#x27;
                           &#x27;StreamSinkFactory.getSqlParser(type, &#x27;
                           &#x27;localPluginRoot);\n&#x27;
                           &#x27;                targetTableInfoMap.put(type, &#x27;
                           &#x27;absTableParser);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(absTableParser == null){\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support %s &#x27;
                           &#x27;type of table&quot;, type));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, Object&gt; prop = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Shield case\n&#x27;
                           &#x27;        &#x27;
                           &#x27;parserResult.getPropMap().forEach((key,val) -&gt; &#x27;
                           &#x27;prop.put(key.toLowerCase(), val));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;absTableParser.getTableInfo(parserResult.getTableName(), &#x27;
                           &#x27;parserResult.getFieldsInfoStr(), prop);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * judge dim table of PERIOD FOR SYSTEM_TIME\n&#x27;
                           &#x27;     * @param tableField\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static boolean checkIsSideTable(String &#x27;
                           &#x27;tableField){\n&#x27;
                           &#x27;        String[] fieldInfos = &#x27;
                           &#x27;StringUtils.split(tableField, &quot;,&quot;);\n&#x27;
                           &#x27;        for(String field : fieldInfos){\n&#x27;
                           &#x27;            Matcher matcher = &#x27;
                           &#x27;SIDE_PATTERN.matcher(field.trim());\n&#x27;
                           &#x27;            if(matcher.find()){\n&#x27;
                           &#x27;                return true;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        