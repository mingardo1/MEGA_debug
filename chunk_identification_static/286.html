<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>286</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    286
                    <a href="285.html">prev</a>
                    <a href="287.html">next</a>
                    <a href="286_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_2dba13ed70429d82aeb4928f597d6e8fc622bed6_admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;2dba13ed70429d82aeb4928f597d6e8fc622bed6:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;2dba13ed70429d82aeb4928f597d6e8fc622bed6^1:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;2dba13ed70429d82aeb4928f597d6e8fc622bed6^2:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;60e51975ae7406b8fe23dc528c233868e977b595:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bs]], subset: [[bs]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.security.service;
  19 
  20 import org.apache.commons.collections4.CollectionUtils;
  21 import org.apache.commons.lang3.BooleanUtils;
  22 import org.apache.commons.lang3.StringUtils;
  23 import org.apache.commons.logging.Log;
  24 import org.apache.commons.logging.LogFactory;
  25 import org.broadleafcommerce.common.email.service.EmailService;
  26 import org.broadleafcommerce.common.email.service.info.EmailInfo;
  27 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  28 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  29 import org.broadleafcommerce.common.security.util.PasswordChange;
  30 import org.broadleafcommerce.common.security.util.PasswordUtils;
  31 import org.broadleafcommerce.common.service.GenericResponse;
  32 import org.broadleafcommerce.common.time.SystemTime;
  33 import org.broadleafcommerce.common.util.BLCSystemProperty;
  34 import org.broadleafcommerce.common.util.StringUtil;
  35 import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  36 import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  37 import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  38 import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  39 import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  40 import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  41 import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  42 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  43 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
  44 import org.broadleafcommerce.openadmin.server.security.extension.AdminSecurityServiceExtensionManager;
  45 import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
  46 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  47 import org.springframework.security.core.Authentication;
  48 import org.springframework.security.core.context.SecurityContextHolder;
  49 import org.springframework.security.crypto.password.PasswordEncoder;
  50 import org.springframework.stereotype.Service;
  51 import org.springframework.transaction.annotation.Transactional;
  52 
  53 import java.util.ArrayList;
  54 import java.util.Date;
  55 import java.util.HashMap;
  56 import java.util.List;
  57 
  58 import javax.annotation.Resource;
  59 
  60 import net.sf.ehcache.Cache;
  61 import net.sf.ehcache.CacheManager;
  62 import net.sf.ehcache.Element;
  63 
  64 /**
  65  *
  66  * @author jfischer
  67  *
  68  */
  69 @Service(&quot;blAdminSecurityService&quot;)
  70 public class AdminSecurityServiceImpl implements AdminSecurityService {
  71 
  72     private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  73 
  74     private static int TEMP_PASSWORD_LENGTH = 12;
  75     private static final int FULL_PASSWORD_LENGTH = 16;
  76 
  77     @Resource(name = &quot;blAdminRoleDao&quot;)
  78     protected AdminRoleDao adminRoleDao;
  79 
  80     @Resource(name = &quot;blAdminUserDao&quot;)
  81     protected AdminUserDao adminUserDao;
  82 
  83     @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
  84     protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
  85 
  86     @Resource(name = &quot;blAdminPermissionDao&quot;)
  87     protected AdminPermissionDao adminPermissionDao;
  88 
  89     protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
  90     protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
  91     protected Cache cache = CacheManager.getInstance().getCache(CACHE_NAME);
  92 
  93     /**
<abbr title="  94      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the">  94      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;rðŸ”µ</abbr>
<abbr title="  95      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}">  95      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.eðŸ”µ</abbr>
  96      */
  97     @Resource(name=&quot;blAdminPasswordEncoder&quot;)
  98     protected PasswordEncoder passwordEncoderBean;
  99 
 100     @Resource(name=&quot;blEmailService&quot;)
 101     protected EmailService emailService;
 102 
 103     @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 104     protected EmailInfo resetPasswordEmailInfo;
 105 
 106     @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 107     protected EmailInfo sendUsernameEmailInfo;
 108 
 109 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 110 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111     protected static String CACHE_NAME = &quot;blSecurityElements&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112     protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113     protected Cache cache = CacheManager.getInstance().getCache(CACHE_NAME);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 114 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 115     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 116      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the"> 116      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;rðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 117      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}"> 117      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.eðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 118      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 119     @Resource(name=&quot;blAdminPasswordEncoder&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 120     protected Object passwordEncoderBean;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123      * Optional password salt to be used with the passwordEncoder</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 125      * @deprecated use {@link #saltSource} instead, this will be removed in 4.2</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 126      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 127     @Deprecated</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 128     protected String salt;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 129     </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 130     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 131      * Use a Salt Source ONLY if there&#x27;s one configured</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 132      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 133      * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2"> 133      * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 134      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135     @Deprecated</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136     @Autowired(required=false)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137     @Qualifier(&quot;blAdminSaltSource&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 138     protected SaltSource saltSource;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 139     </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 140     @Resource(name=&quot;blEmailService&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 141     protected EmailService emailService;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 142 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 143     @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 144     protected EmailInfo resetPasswordEmailInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 145 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 146     @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 147     protected EmailInfo sendUsernameEmailInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 148 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 149     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 150      * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passwordEncoderBean}"> 150      * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@linkðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 151      * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} bean."> 151      * in order to provide bean configuration backwards compatibility with the deprecated {@link org.spriðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 152      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 153      * &lt;p&gt;{@link #passwordEncoderBean} is set by the bean defined as &quot;blPasswordEncoder&quot;.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 154      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 155      * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not null."> 155      * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which isðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 156      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 157      * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either PasswordEncoder"> 157      * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance oðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 158      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 159     @PostConstruct</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160     protected void setupPasswordEncoder() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 161         passwordEncoderNew = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 162         passwordEncoder = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 163         if (passwordEncoderBean instanceof PasswordEncoder) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 164             passwordEncoderNew = (PasswordEncoder) passwordEncoderBean;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 165         } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncoder) {"> 165         } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 166             passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncoderBean;"> 166             passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168             throw new NoSuchBeanDefinitionException(&quot;No PasswordEncoder bean is defined&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 170     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 171 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172     protected int getTokenExpiredMinutes() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 173         return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174     }    </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176     protected String getResetPasswordURL() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177         return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);</span>
 178 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 179     @Resource(name = &quot;blAdminSecurityServiceExtensionManager&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 180     protected AdminSecurityServiceExtensionManager extensionManager;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 181 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 182     /**</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 183      * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passwordEncoderBean}"> 183      * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@linkðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 184      * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} bean."> 184      * in order to provide bean configuration backwards compatibility with the deprecated {@link org.spriðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 185      *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 186      * &lt;p&gt;{@link #passwordEncoderBean} is set by the bean defined as &quot;blPasswordEncoder&quot;.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 187      *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 188      * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not null."> 188      * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which isðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 189      *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 190      * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either PasswordEncoder"> 190      * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance oðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 191      */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 192     @PostConstruct</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 193     protected void setupPasswordEncoder() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 194         passwordEncoderNew = null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 195         passwordEncoder = null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 196         if (passwordEncoderBean instanceof PasswordEncoder) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 197             passwordEncoderNew = (PasswordEncoder) passwordEncoderBean;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 198         } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncoder) {"> 198         } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 199             passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncoderBean;"> 199             passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 200         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 201             throw new NoSuchBeanDefinitionException(&quot;No PasswordEncoder bean is defined&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 202         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 203     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 204 </span>
 205 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 206     protected int getTokenExpiredMinutes() {
 207         return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 208     }
 209 
 210     protected String getResetPasswordURL() {
 211         return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 212     }
 213 
 214     @Override
 215     @Transactional(&quot;blTransactionManager&quot;)
 216     public void deleteAdminPermission(AdminPermission permission) {
 217         adminPermissionDao.deleteAdminPermission(permission);
 218         clearAdminSecurityCache();
 219     }
 220 
 221     @Override
 222     @Transactional(&quot;blTransactionManager&quot;)
 223     public void deleteAdminRole(AdminRole role) {
 224         adminRoleDao.deleteAdminRole(role);
 225         clearAdminSecurityCache();
 226     }
 227 
 228     @Override
 229     @Transactional(&quot;blTransactionManager&quot;)
 230     public void deleteAdminUser(AdminUser user) {
 231         adminUserDao.deleteAdminUser(user);
 232         clearAdminSecurityCache();
 233     }
 234 
 235     @Override
 236     public AdminPermission readAdminPermissionById(Long id) {
 237         return adminPermissionDao.readAdminPermissionById(id);
 238     }
 239 
 240     @Override
 241     public AdminRole readAdminRoleById(Long id) {
 242         return adminRoleDao.readAdminRoleById(id);
 243     }
 244 
 245     @Override
 246     public AdminUser readAdminUserById(Long id) {
 247         return adminUserDao.readAdminUserById(id);
 248     }
 249 
 250     @Override
 251     @Transactional(&quot;blTransactionManager&quot;)
 252     public AdminPermission saveAdminPermission(AdminPermission permission) {
 253         permission = adminPermissionDao.saveAdminPermission(permission);
 254         clearAdminSecurityCache();
 255         return permission;
 256     }
 257 
 258     @Override
 259     @Transactional(&quot;blTransactionManager&quot;)
 260     public AdminRole saveAdminRole(AdminRole role) {
 261         role = adminRoleDao.saveAdminRole(role);
 262         clearAdminSecurityCache();
 263         return role;
 264     }
 265 
 266     @Override
 267     @Transactional(&quot;blTransactionManager&quot;)
 268     public AdminUser saveAdminUser(AdminUser user) {
 269         boolean encodePasswordNeeded = false;
 270         String unencodedPassword = user.getUnencodedPassword();
 271 
 272         if (user.getUnencodedPassword() != null) {
 273             encodePasswordNeeded = true;
 274             user.setPassword(unencodedPassword);
 275         }
 276 
 277         // If no password is set, default to a secure password.
 278         if (user.getPassword() == null) {
 279             user.setPassword(generateSecurePassword());
 280         }
 281 
 282         AdminUser returnUser = adminUserDao.saveAdminUser(user);
 283 
 284         if (encodePasswordNeeded) {
 285             returnUser.setPassword(encodePassword(unencodedPassword));
 286         }
 287 
 288         returnUser = adminUserDao.saveAdminUser(returnUser);
 289         clearAdminSecurityCache();
 290         return returnUser;
 291     }
 292 
 293     @Override
 294     public void clearAdminSecurityCache() {
 295         if (LOG.isTraceEnabled()) {
 296             LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 297         }
 298         cache.removeAll();
 299     }
 300 
 301     protected String generateSecurePassword() {
 302         return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 303     }
 304 
 305     @Override
 306     @Transactional(&quot;blTransactionManager&quot;)
 307     public AdminUser changePassword(PasswordChange passwordChange) {
 308         AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 309         user.setUnencodedPassword(passwordChange.getNewPassword());
 310         user = saveAdminUser(user);
 311         Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 312         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 312         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passworðŸ”µ</abbr>
 313         SecurityContextHolder.getContext().setAuthentication(authRequest);
 314         auth.setAuthenticated(false);
 315         return user;
 316     }
 317 
 318     @Override
<abbr title=" 319     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 319     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissðŸ”µ</abbr>
 320         Boolean response = null;
 321         String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 322         Element cacheElement = cache.get(cacheKey);
 323 
 324         if (cacheElement != null) {
 325             response = (Boolean) cacheElement.getObjectValue();
 326 
 327             if (LOG.isTraceEnabled()) {
 328                 LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 329             }
 330         }
 331 
 332         if (response == null) {
 333             if (extensionManager != null) {
 334                 ExtensionResultHolder&lt;Boolean&gt; result = new ExtensionResultHolder&lt;Boolean&gt;();
<abbr title=" 335                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperation(adminUser, permissionType, result);"> 335                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForðŸ”µ</abbr>
 336                 if (ExtensionResultStatusType.HANDLED == resultStatusType) {
 337                     response = result.getResult();
 338                 }
 339             }
 340 
 341             if (response == null || !response) {
<abbr title=" 342                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 342                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permiðŸ”µ</abbr>
 343 
 344                 if (!response) {
<abbr title=" 345                     response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 345                     response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPerðŸ”µ</abbr>
 346                 }
 347             }
 348 
 349             cacheElement = new Element(cacheKey, response);
 350             cache.put(cacheElement);
 351 
 352             if (LOG.isTraceEnabled()) {
 353                 LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 354             }
 355         }
 356 
 357         return response;
 358     }
 359 
<abbr title=" 360     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 360     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntiðŸ”µ</abbr>
 361         return CACHE_KEY_PREFIX
 362                + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 363                + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 364                + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 365     }
 366 
 367     @Override
<abbr title=" 368     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 368     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityðŸ”µ</abbr>
<abbr title=" 369         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 369         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQuðŸ”µ</abbr>
 370     }
 371 
 372     @Override
 373     public AdminUser readAdminUserByUserName(String userName) {
 374         return adminUserDao.readAdminUserByUserName(userName);
 375     }
 376 
 377     @Override
 378     public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 379         return adminUserDao.readAdminUserByEmail(email);
 380     }
 381 
 382     @Override
 383     public List&lt;AdminUser&gt; readAllAdminUsers() {
 384         return adminUserDao.readAllAdminUsers();
 385     }
 386 
 387     @Override
 388     public List&lt;AdminRole&gt; readAllAdminRoles() {
 389         return adminRoleDao.readAllAdminRoles();
 390     }
 391 
 392     @Override
 393     public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 394         return adminPermissionDao.readAllAdminPermissions();
 395     }
 396 
 397     @Override
 398     @Transactional(&quot;blTransactionManager&quot;)
 399     public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 400         GenericResponse response = new GenericResponse();
 401         List&lt;AdminUser&gt; users = null;
 402         if (emailAddress != null) {
 403             users = adminUserDao.readAdminUserByEmail(emailAddress);
 404         }
 405         if (CollectionUtils.isEmpty(users)) {
 406             response.addErrorCode(&quot;notFound&quot;);
 407         } else {
 408             List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 409             for (AdminUser user : users) {
 410                 if (user.getActiveStatusFlag()) {
 411                     activeUsernames.add(user.getLogin());
 412                 }
 413             }
 414 
 415             if (activeUsernames.size() &gt; 0) {
 416                 HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 417                 vars.put(&quot;accountNames&quot;, activeUsernames);
 418                 emailService.sendTemplateEmail(emailAddress, getSendUsernameEmailInfo(), vars);
 419             } else {
 420                 // send inactive username found email.
 421                 response.addErrorCode(&quot;inactiveUser&quot;);
 422             }
 423         }
 424         return response;
 425     }
 426 
 427     @Override
 428     @Transactional(&quot;blTransactionManager&quot;)
 429     public GenericResponse sendResetPasswordNotification(String username) {
 430         GenericResponse response = new GenericResponse();
 431         AdminUser user = null;
 432 
 433         if (username != null) {
 434             user = adminUserDao.readAdminUserByUserName(username);
 435         }
 436 
 437         checkUser(user,response);
 438 
 439         if (! response.getHasErrors()) {
 440             String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 441             token = token.toLowerCase();
 442 
 443             ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 444             fpst.setAdminUserId(user.getId());
 445             fpst.setToken(encodePassword(token));
 446             fpst.setCreateDate(SystemTime.asDate());
 447             forgotPasswordSecurityTokenDao.saveToken(fpst);
 448 
 449             HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 450             vars.put(&quot;token&quot;, token);
 451             String resetPasswordUrl = getResetPasswordURL();
 452             if (!StringUtils.isEmpty(resetPasswordUrl)) {
 453                 if (resetPasswordUrl.contains(&quot;?&quot;)) {
 454                     resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 455                 } else {
 456                     resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 457                 }
 458             }
 459             vars.put(&quot;resetPasswordUrl&quot;, resetPasswordUrl);
 460             emailService.sendTemplateEmail(user.getEmail(), getResetPasswordEmailInfo(), vars);
 461 
 462         }
 463         return response;
 464     }
 465 
 466     @Override
 467     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 468     public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 468     public GenericResponse resetPasswordUsingToken(String username, String token, String password, StringðŸ”µ</abbr>
 469         GenericResponse response = new GenericResponse();
 470         AdminUser user = null;
 471         if (username != null) {
 472             user = adminUserDao.readAdminUserByUserName(username);
 473         }
 474         checkUser(user, response);
 475         checkPassword(password, confirmPassword, response);
 476         if (StringUtils.isBlank(token)) {
 477             response.addErrorCode(&quot;invalidToken&quot;);
 478         }
 479 
 480         ForgotPasswordSecurityToken fpst = null;
 481         if (! response.getHasErrors()) {
 482             token = token.toLowerCase();
<abbr title=" 483             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 483             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByðŸ”µ</abbr>
 484             for (ForgotPasswordSecurityToken fpstok : fpstoks) {
 485                 if (isPasswordValid(fpstok.getToken(), token)) {
 486                     fpst = fpstok;
 487                     break;
 488                 }
 489             }
 490             if (fpst == null) {
 491                 response.addErrorCode(&quot;invalidToken&quot;);
 492             } else if (fpst.isTokenUsedFlag()) {
 493                 response.addErrorCode(&quot;tokenUsed&quot;);
 494             } else if (isTokenExpired(fpst)) {
 495                 response.addErrorCode(&quot;tokenExpired&quot;);
 496             }
 497         }
 498 
 499         if (! response.getHasErrors()) {
 500             if (! user.getId().equals(fpst.getAdminUserId())) {
 501                 if (LOG.isWarnEnabled()) {
<abbr title=" 502                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 502                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId(ðŸ”µ</abbr>
 503                 }
 504                 response.addErrorCode(&quot;invalidToken&quot;);
 505             }
 506         }
 507 
 508         if (! response.getHasErrors()) {
 509             user.setUnencodedPassword(password);
 510             saveAdminUser(user);
 511             invalidateAllTokensForAdminUser(user);
 512         }
 513 
 514         return response;
 515     }
 516 
 517     protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 518         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 518         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminðŸ”µ</abbr>
 519         for (ForgotPasswordSecurityToken token : tokens) {
 520             token.setTokenUsedFlag(true);
 521             forgotPasswordSecurityTokenDao.saveToken(token);
 522         }
 523     }
 524 
 525     protected void checkUser(AdminUser user, GenericResponse response) {
 526         if (user == null) {
 527             response.addErrorCode(&quot;invalidUser&quot;);
 528         } else if (StringUtils.isBlank(user.getEmail())) {
 529             response.addErrorCode(&quot;emailNotFound&quot;);
 530         } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 531             response.addErrorCode(&quot;inactiveUser&quot;);
 532         }
 533     }
 534 
 535     protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 536         if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 537             response.addErrorCode(&quot;invalidPassword&quot;);
 538         } else if (! password.equals(confirmPassword)) {
 539             response.addErrorCode(&quot;passwordMismatch&quot;);
 540         }
 541     }
 542 
<abbr title=" 543     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {"> 543     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse responðŸ”µ</abbr>
 544         if (!isPasswordValid(user.getPassword(), unencodedPassword)) {
 545             response.addErrorCode(&quot;invalidPassword&quot;);
 546         }
 547     }
 548 
 549     protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 550         Date now = SystemTime.asDate();
 551         long currentTimeInMillis = now.getTime();
 552         long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 553         long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 554         return minutesSinceSave &gt; getTokenExpiredMinutes();
 555     }
 556 
 557     public static int getPASSWORD_TOKEN_LENGTH() {
 558         return TEMP_PASSWORD_LENGTH;
 559     }
 560 
 561     public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 562         AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 563     }
 564 
 565     public EmailInfo getSendUsernameEmailInfo() {
 566         return sendUsernameEmailInfo;
 567     }
 568 
 569     public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 570         this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 571     }
 572 
 573     public EmailInfo getResetPasswordEmailInfo() {
 574         return resetPasswordEmailInfo;
 575     }
 576 
 577     public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 578         this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 579     }
 580 
 581     @Override
 582     @Transactional(&quot;blTransactionManager&quot;)
 583     public GenericResponse changePassword(String username,
 584             String oldPassword, String password, String confirmPassword) {
 585         GenericResponse response = new GenericResponse();
 586         AdminUser user = null;
 587         if (username != null) {
 588             user = adminUserDao.readAdminUserByUserName(username);
 589         }
 590         checkUser(user, response);
 591         checkPassword(password, confirmPassword, response);
 592 
 593         if (!response.getHasErrors()) {
 594             checkExistingPassword(oldPassword, user, response);
 595         }
 596 
 597         if (!response.getHasErrors()) {
 598             user.setUnencodedPassword(password);
 599             saveAdminUser(user);
 600 
 601         }
 602 
 603         return response;
 604 
 605     }
 606 
 607     /**
<abbr title=" 608      * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 608      * Determines if a password is valid by comparing it to the encoded string, salting is handled internðŸ”µ</abbr>
 609      * &lt;p&gt;
<abbr title=" 610      * This method must always be called to verify if a password is valid after the original encoded password is generated"> 610      * This method must always be called to verify if a password is valid after the original encoded passðŸ”µ</abbr>
<abbr title=" 611      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 611      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resuðŸ”µ</abbr>
 612      *
 613      * @param encodedPassword the encoded password
 614      * @param rawPassword the raw password to check against the encoded password
 615      * @return true if rawPassword matches the encodedPassword, false otherwise
 616      */
 617     protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
 618         return passwordEncoderBean.matches(rawPassword, encodedPassword);
 619     }
 620 
 621     /**
 622      * Generate an encoded password from a raw password
 623      * &lt;p&gt;
<abbr title=" 624      * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 624      * This method can only be called once per password. The salt is randomly generated internally in theðŸ”µ</abbr>
<abbr title=" 625      * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 625      * and appended to the hash to provide the resulting encoded password. Once this has been called on aðŸ”µ</abbr>
<abbr title=" 626      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 626      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)}ðŸ”µ</abbr>
 627      * same password twice will result in different encoded passwords.
 628      *
 629      * @param rawPassword the unencoded password to encode
 630      * @return the encoded password
 631      */
 632     protected String encodePassword(String rawPassword) {
 633         return passwordEncoderBean.encode(rawPassword);
 634     }
 635 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.security.service;
  19 
  20 import net.sf.ehcache.Cache;
  21 import net.sf.ehcache.CacheManager;
  22 import net.sf.ehcache.Element;
  23 
  24 import org.apache.commons.collections4.CollectionUtils;
  25 import org.apache.commons.lang3.BooleanUtils;
  26 import org.apache.commons.lang3.StringUtils;
  27 import org.apache.commons.logging.Log;
  28 import org.apache.commons.logging.LogFactory;
  29 import org.broadleafcommerce.common.email.service.EmailService;
  30 import org.broadleafcommerce.common.email.service.info.EmailInfo;
  31 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  32 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  33 import org.broadleafcommerce.common.security.util.PasswordChange;
  34 import org.broadleafcommerce.common.security.util.PasswordUtils;
  35 import org.broadleafcommerce.common.service.GenericResponse;
  36 import org.broadleafcommerce.common.time.SystemTime;
  37 import org.broadleafcommerce.common.util.BLCSystemProperty;
  38 import org.broadleafcommerce.common.util.StringUtil;
  39 import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  40 import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  41 import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  42 import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  43 import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  44 import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  45 import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  46 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  47 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
  48 import org.broadleafcommerce.openadmin.server.security.extension.AdminSecurityServiceExtensionManager;
  49 import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
  50 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  51 import org.springframework.security.core.Authentication;
  52 import org.springframework.security.core.context.SecurityContextHolder;
  53 import org.springframework.security.crypto.password.PasswordEncoder;
  54 import org.springframework.stereotype.Service;
  55 import org.springframework.transaction.annotation.Transactional;
  56 
  57 import java.util.ArrayList;
  58 import java.util.Date;
  59 import java.util.HashMap;
  60 import java.util.List;
  61 
  62 import javax.annotation.Resource;
  63 
  64 /**
  65  *
  66  * @author jfischer
  67  *
  68  */
  69 @Service(&quot;blAdminSecurityService&quot;)
  70 public class AdminSecurityServiceImpl implements AdminSecurityService {
  71 
  72     private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  73 
  74     private static int TEMP_PASSWORD_LENGTH = 12;
  75     private static final int FULL_PASSWORD_LENGTH = 16;
  76 
  77     @Resource(name = &quot;blAdminRoleDao&quot;)
  78     protected AdminRoleDao adminRoleDao;
  79 
  80     @Resource(name = &quot;blAdminUserDao&quot;)
  81     protected AdminUserDao adminUserDao;
  82 
  83     @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
  84     protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
  85 
  86     @Resource(name = &quot;blAdminPermissionDao&quot;)
  87     protected AdminPermissionDao adminPermissionDao;
  88 
  89     protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
  90     protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
  91     protected Cache cache = CacheManager.getInstance().getCache(CACHE_NAME);
  92 
  93     /**
<abbr title="  94      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the">  94      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;rðŸ”µ</abbr>
<abbr title="  95      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}">  95      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.eðŸ”µ</abbr>
  96      */
  97     @Resource(name=&quot;blAdminPasswordEncoder&quot;)
  98     protected PasswordEncoder passwordEncoderBean;
  99 
 100     @Resource(name=&quot;blEmailService&quot;)
 101     protected EmailService emailService;
 102 
 103     @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 104     protected EmailInfo resetPasswordEmailInfo;
 105 
 106     @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 107     protected EmailInfo sendUsernameEmailInfo;
 108 
 109     @Resource(name = &quot;blAdminSecurityServiceExtensionManager&quot;)
 110     protected AdminSecurityServiceExtensionManager extensionManager;
 111 
 112     protected int getTokenExpiredMinutes() {
 113         return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 114     }
 115 
 116     protected String getResetPasswordURL() {
 117         return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 118     }
 119 
 120     @Override
 121     @Transactional(&quot;blTransactionManager&quot;)
 122     public void deleteAdminPermission(AdminPermission permission) {
 123         adminPermissionDao.deleteAdminPermission(permission);
 124         clearAdminSecurityCache();
 125     }
 126 
 127     @Override
 128     @Transactional(&quot;blTransactionManager&quot;)
 129     public void deleteAdminRole(AdminRole role) {
 130         adminRoleDao.deleteAdminRole(role);
 131         clearAdminSecurityCache();
 132     }
 133 
 134     @Override
 135     @Transactional(&quot;blTransactionManager&quot;)
 136     public void deleteAdminUser(AdminUser user) {
 137         adminUserDao.deleteAdminUser(user);
 138         clearAdminSecurityCache();
 139     }
 140 
 141     @Override
 142     public AdminPermission readAdminPermissionById(Long id) {
 143         return adminPermissionDao.readAdminPermissionById(id);
 144     }
 145 
 146     @Override
 147     public AdminRole readAdminRoleById(Long id) {
 148         return adminRoleDao.readAdminRoleById(id);
 149     }
 150 
 151     @Override
 152     public AdminUser readAdminUserById(Long id) {
 153         return adminUserDao.readAdminUserById(id);
 154     }
 155 
 156     @Override
 157     @Transactional(&quot;blTransactionManager&quot;)
 158     public AdminPermission saveAdminPermission(AdminPermission permission) {
 159         permission = adminPermissionDao.saveAdminPermission(permission);
 160         clearAdminSecurityCache();
 161         return permission;
 162     }
 163 
 164     @Override
 165     @Transactional(&quot;blTransactionManager&quot;)
 166     public AdminRole saveAdminRole(AdminRole role) {
 167         role = adminRoleDao.saveAdminRole(role);
 168         clearAdminSecurityCache();
 169         return role;
 170     }
 171 
 172     @Override
 173     @Transactional(&quot;blTransactionManager&quot;)
 174     public AdminUser saveAdminUser(AdminUser user) {
 175         boolean encodePasswordNeeded = false;
 176         String unencodedPassword = user.getUnencodedPassword();
 177 
 178         if (user.getUnencodedPassword() != null) {
 179             encodePasswordNeeded = true;
 180             user.setPassword(unencodedPassword);
 181         }
 182 
 183         // If no password is set, default to a secure password.
 184         if (user.getPassword() == null) {
 185             user.setPassword(generateSecurePassword());
 186         }
 187 
 188         AdminUser returnUser = adminUserDao.saveAdminUser(user);
 189 
 190         if (encodePasswordNeeded) {
 191             returnUser.setPassword(encodePassword(unencodedPassword));
 192         }
 193 
 194         returnUser = adminUserDao.saveAdminUser(returnUser);
 195         clearAdminSecurityCache();
 196         return returnUser;
 197     }
 198 
 199     @Override
 200     public void clearAdminSecurityCache() {
 201         if (LOG.isTraceEnabled()) {
 202             LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 203         }
 204         cache.removeAll();
 205     }
 206 
 207     protected String generateSecurePassword() {
 208         return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 209     }
 210 
 211     @Override
 212     @Transactional(&quot;blTransactionManager&quot;)
 213     public AdminUser changePassword(PasswordChange passwordChange) {
 214         AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 215         user.setUnencodedPassword(passwordChange.getNewPassword());
 216         user = saveAdminUser(user);
 217         Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 218         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 218         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passworðŸ”µ</abbr>
 219         SecurityContextHolder.getContext().setAuthentication(authRequest);
 220         auth.setAuthenticated(false);
 221         return user;
 222     }
 223 
 224     @Override
<abbr title=" 225     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 225     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissðŸ”µ</abbr>
 226         Boolean response = null;
 227         String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 228         Element cacheElement = cache.get(cacheKey);
 229 
 230         if (cacheElement != null) {
 231             response = (Boolean) cacheElement.getObjectValue();
 232 
 233             if (LOG.isTraceEnabled()) {
 234                 LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 235             }
 236         }
 237 
 238         if (response == null) {
 239             if (extensionManager != null) {
 240                 ExtensionResultHolder&lt;Boolean&gt; result = new ExtensionResultHolder&lt;Boolean&gt;();
<abbr title=" 241                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperation(adminUser, permissionType, result);"> 241                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForðŸ”µ</abbr>
 242                 if (ExtensionResultStatusType.HANDLED == resultStatusType) {
 243                     response = result.getResult();
 244                 }
 245             }
 246 
 247             if (response == null || !response) {
<abbr title=" 248             response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 248             response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissioðŸ”µ</abbr>
 249 
 250             if (!response) {
<abbr title=" 251                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 251                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissðŸ”µ</abbr>
 252             }
 253             }
 254 
 255             cacheElement = new Element(cacheKey, response);
 256             cache.put(cacheElement);
 257 
 258             if (LOG.isTraceEnabled()) {
 259                 LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 260             }
 261         }
 262 
 263         return response;
 264     }
 265 
<abbr title=" 266     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 266     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntiðŸ”µ</abbr>
 267         return CACHE_KEY_PREFIX
 268                + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 269                + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 270                + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 271     }
 272 
 273     @Override
<abbr title=" 274     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 274     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityðŸ”µ</abbr>
<abbr title=" 275         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 275         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQuðŸ”µ</abbr>
 276     }
 277 
 278     @Override
 279     public AdminUser readAdminUserByUserName(String userName) {
 280         return adminUserDao.readAdminUserByUserName(userName);
 281     }
 282 
 283     @Override
 284     public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 285         return adminUserDao.readAdminUserByEmail(email);
 286     }
 287 
 288     @Override
 289     public List&lt;AdminUser&gt; readAllAdminUsers() {
 290         return adminUserDao.readAllAdminUsers();
 291     }
 292 
 293     @Override
 294     public List&lt;AdminRole&gt; readAllAdminRoles() {
 295         return adminRoleDao.readAllAdminRoles();
 296     }
 297 
 298     @Override
 299     public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 300         return adminPermissionDao.readAllAdminPermissions();
 301     }
 302 
 303     @Override
 304     @Transactional(&quot;blTransactionManager&quot;)
 305     public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 306         GenericResponse response = new GenericResponse();
 307         List&lt;AdminUser&gt; users = null;
 308         if (emailAddress != null) {
 309             users = adminUserDao.readAdminUserByEmail(emailAddress);
 310         }
 311         if (CollectionUtils.isEmpty(users)) {
 312             response.addErrorCode(&quot;notFound&quot;);
 313         } else {
 314             List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 315             for (AdminUser user : users) {
 316                 if (user.getActiveStatusFlag()) {
 317                     activeUsernames.add(user.getLogin());
 318                 }
 319             }
 320 
 321             if (activeUsernames.size() &gt; 0) {
 322                 HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 323                 vars.put(&quot;accountNames&quot;, activeUsernames);
 324                 emailService.sendTemplateEmail(emailAddress, getSendUsernameEmailInfo(), vars);
 325             } else {
 326                 // send inactive username found email.
 327                 response.addErrorCode(&quot;inactiveUser&quot;);
 328             }
 329         }
 330         return response;
 331     }
 332 
 333     @Override
 334     @Transactional(&quot;blTransactionManager&quot;)
 335     public GenericResponse sendResetPasswordNotification(String username) {
 336         GenericResponse response = new GenericResponse();
 337         AdminUser user = null;
 338 
 339         if (username != null) {
 340             user = adminUserDao.readAdminUserByUserName(username);
 341         }
 342 
 343         checkUser(user,response);
 344 
 345         if (! response.getHasErrors()) {
 346             String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 347             token = token.toLowerCase();
 348 
 349             ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 350             fpst.setAdminUserId(user.getId());
 351             fpst.setToken(encodePassword(token));
 352             fpst.setCreateDate(SystemTime.asDate());
 353             forgotPasswordSecurityTokenDao.saveToken(fpst);
 354 
 355             HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 356             vars.put(&quot;token&quot;, token);
 357             String resetPasswordUrl = getResetPasswordURL();
 358             if (!StringUtils.isEmpty(resetPasswordUrl)) {
 359                 if (resetPasswordUrl.contains(&quot;?&quot;)) {
 360                     resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 361                 } else {
 362                     resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 363                 }
 364             }
 365             vars.put(&quot;resetPasswordUrl&quot;, resetPasswordUrl);
 366             emailService.sendTemplateEmail(user.getEmail(), getResetPasswordEmailInfo(), vars);
 367 
 368         }
 369         return response;
 370     }
 371 
 372     @Override
 373     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 374     public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 374     public GenericResponse resetPasswordUsingToken(String username, String token, String password, StringðŸ”µ</abbr>
 375         GenericResponse response = new GenericResponse();
 376         AdminUser user = null;
 377         if (username != null) {
 378             user = adminUserDao.readAdminUserByUserName(username);
 379         }
 380         checkUser(user, response);
 381         checkPassword(password, confirmPassword, response);
 382         if (StringUtils.isBlank(token)) {
 383             response.addErrorCode(&quot;invalidToken&quot;);
 384         }
 385 
 386         ForgotPasswordSecurityToken fpst = null;
 387         if (! response.getHasErrors()) {
 388             token = token.toLowerCase();
<abbr title=" 389             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 389             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByðŸ”µ</abbr>
 390             for (ForgotPasswordSecurityToken fpstok : fpstoks) {
 391                 if (isPasswordValid(fpstok.getToken(), token)) {
 392                     fpst = fpstok;
 393                     break;
 394                 }
 395             }
 396             if (fpst == null) {
 397                 response.addErrorCode(&quot;invalidToken&quot;);
 398             } else if (fpst.isTokenUsedFlag()) {
 399                 response.addErrorCode(&quot;tokenUsed&quot;);
 400             } else if (isTokenExpired(fpst)) {
 401                 response.addErrorCode(&quot;tokenExpired&quot;);
 402             }
 403         }
 404 
 405         if (! response.getHasErrors()) {
 406             if (! user.getId().equals(fpst.getAdminUserId())) {
 407                 if (LOG.isWarnEnabled()) {
<abbr title=" 408                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 408                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId(ðŸ”µ</abbr>
 409                 }
 410                 response.addErrorCode(&quot;invalidToken&quot;);
 411             }
 412         }
 413 
 414         if (! response.getHasErrors()) {
 415             user.setUnencodedPassword(password);
 416             saveAdminUser(user);
 417             invalidateAllTokensForAdminUser(user);
 418         }
 419 
 420         return response;
 421     }
 422 
 423     protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 424         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 424         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminðŸ”µ</abbr>
 425         for (ForgotPasswordSecurityToken token : tokens) {
 426             token.setTokenUsedFlag(true);
 427             forgotPasswordSecurityTokenDao.saveToken(token);
 428         }
 429     }
 430 
 431     protected void checkUser(AdminUser user, GenericResponse response) {
 432         if (user == null) {
 433             response.addErrorCode(&quot;invalidUser&quot;);
 434         } else if (StringUtils.isBlank(user.getEmail())) {
 435             response.addErrorCode(&quot;emailNotFound&quot;);
 436         } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 437             response.addErrorCode(&quot;inactiveUser&quot;);
 438         }
 439     }
 440 
 441     protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 442         if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 443             response.addErrorCode(&quot;invalidPassword&quot;);
 444         } else if (! password.equals(confirmPassword)) {
 445             response.addErrorCode(&quot;passwordMismatch&quot;);
 446         }
 447     }
 448 
<abbr title=" 449     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {"> 449     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse responðŸ”µ</abbr>
 450         if (!isPasswordValid(user.getPassword(), unencodedPassword)) {
 451             response.addErrorCode(&quot;invalidPassword&quot;);
 452         }
 453     }
 454 
 455     protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 456         Date now = SystemTime.asDate();
 457         long currentTimeInMillis = now.getTime();
 458         long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 459         long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 460         return minutesSinceSave &gt; getTokenExpiredMinutes();
 461     }
 462 
 463     public static int getPASSWORD_TOKEN_LENGTH() {
 464         return TEMP_PASSWORD_LENGTH;
 465     }
 466 
 467     public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 468         AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 469     }
 470 
 471     public EmailInfo getSendUsernameEmailInfo() {
 472         return sendUsernameEmailInfo;
 473     }
 474 
 475     public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 476         this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 477     }
 478 
 479     public EmailInfo getResetPasswordEmailInfo() {
 480         return resetPasswordEmailInfo;
 481     }
 482 
 483     public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 484         this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 485     }
 486 
 487     @Override
 488     @Transactional(&quot;blTransactionManager&quot;)
 489     public GenericResponse changePassword(String username,
 490             String oldPassword, String password, String confirmPassword) {
 491         GenericResponse response = new GenericResponse();
 492         AdminUser user = null;
 493         if (username != null) {
 494             user = adminUserDao.readAdminUserByUserName(username);
 495         }
 496         checkUser(user, response);
 497         checkPassword(password, confirmPassword, response);
 498 
 499         if (!response.getHasErrors()) {
 500             checkExistingPassword(oldPassword, user, response);
 501         }
 502 
 503         if (!response.getHasErrors()) {
 504             user.setUnencodedPassword(password);
 505             saveAdminUser(user);
 506 
 507         }
 508 
 509         return response;
 510 
 511     }
 512 
 513     /**
<abbr title=" 514      * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 514      * Determines if a password is valid by comparing it to the encoded string, salting is handled internðŸ”µ</abbr>
 515      * &lt;p&gt;
<abbr title=" 516      * This method must always be called to verify if a password is valid after the original encoded password is generated"> 516      * This method must always be called to verify if a password is valid after the original encoded passðŸ”µ</abbr>
<abbr title=" 517      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 517      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resuðŸ”µ</abbr>
 518      *
 519      * @param encodedPassword the encoded password
 520      * @param rawPassword the raw password to check against the encoded password
 521      * @return true if rawPassword matches the encodedPassword, false otherwise
 522      */
 523     protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
 524         return passwordEncoderBean.matches(rawPassword, encodedPassword);
 525     }
 526 
 527     /**
 528      * Generate an encoded password from a raw password
 529      * &lt;p&gt;
<abbr title=" 530      * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 530      * This method can only be called once per password. The salt is randomly generated internally in theðŸ”µ</abbr>
<abbr title=" 531      * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 531      * and appended to the hash to provide the resulting encoded password. Once this has been called on aðŸ”µ</abbr>
<abbr title=" 532      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 532      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)}ðŸ”µ</abbr>
 533      * same password twice will result in different encoded passwords.
 534      *
 535      * @param rawPassword the unencoded password to encode
 536      * @return the encoded password
 537      */
 538     protected String encodePassword(String rawPassword) {
 539         return passwordEncoderBean.encode(rawPassword);
 540     }
 541 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.security.service;
  19 
  20 import java.util.ArrayList;
  21 import java.util.Date;
  22 import java.util.HashMap;
  23 import java.util.List;
  24 import javax.annotation.Resource;
  25 import net.sf.ehcache.Cache;
  26 import net.sf.ehcache.CacheManager;
  27 import net.sf.ehcache.Element;
  28 import org.apache.commons.collections4.CollectionUtils;
  29 import org.apache.commons.lang3.BooleanUtils;
  30 import org.apache.commons.lang3.StringUtils;
  31 import org.apache.commons.logging.Log;
  32 import org.apache.commons.logging.LogFactory;
  33 import org.broadleafcommerce.common.email.service.EmailService;
  34 import org.broadleafcommerce.common.email.service.info.EmailInfo;
  35 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  36 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  37 import org.broadleafcommerce.common.security.util.PasswordChange;
  38 import org.broadleafcommerce.common.security.util.PasswordUtils;
  39 import org.broadleafcommerce.common.service.GenericResponse;
  40 import org.broadleafcommerce.common.time.SystemTime;
  41 import org.broadleafcommerce.common.util.BLCSystemProperty;
  42 import org.broadleafcommerce.common.util.StringUtil;
  43 import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  44 import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  45 import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  46 import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  47 import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  48 import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  49 import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  50 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  51 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
  52 import org.broadleafcommerce.openadmin.server.security.extension.AdminSecurityServiceExtensionManager;
  53 import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
  54 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  55 import org.springframework.security.core.Authentication;
  56 import org.springframework.security.core.context.SecurityContextHolder;
  57 import org.springframework.security.crypto.password.PasswordEncoder;
  58 import org.springframework.stereotype.Service;
  59 import org.springframework.transaction.annotation.Transactional;
  60 
  61 
  62 /**
  63  *
  64  * @author jfischer
  65  *
  66  */
  67 @Service(&quot;blAdminSecurityService&quot;)
  68 public class AdminSecurityServiceImpl implements AdminSecurityService {
  69 
  70     private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  71 
  72     private static int TEMP_PASSWORD_LENGTH = 12;
  73     private static final int FULL_PASSWORD_LENGTH = 16;
  74 
  75     @Resource(name = &quot;blAdminRoleDao&quot;)
  76     protected AdminRoleDao adminRoleDao;
  77 
  78     @Resource(name = &quot;blAdminUserDao&quot;)
  79     protected AdminUserDao adminUserDao;
  80 
  81     @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
  82     protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
  83 
  84     @Resource(name = &quot;blAdminPermissionDao&quot;)
  85     protected AdminPermissionDao adminPermissionDao;
  86 
  87     protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
  88     protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
  89     protected Cache cache = CacheManager.getInstance().getCache(CACHE_NAME);
  90 
  91     /**
<abbr title="  92      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the">  92      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;rðŸ”µ</abbr>
<abbr title="  93      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}">  93      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.eðŸ”µ</abbr>
  94      */
  95     @Resource(name=&quot;blAdminPasswordEncoder&quot;)
  96     protected PasswordEncoder passwordEncoderBean;
  97 
  98     @Resource(name=&quot;blEmailService&quot;)
  99     protected EmailService emailService;
 100 
 101     @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 102     protected EmailInfo resetPasswordEmailInfo;
 103 
 104     @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 105     protected EmailInfo sendUsernameEmailInfo;
 106 
 107 
 108 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 109 </span>
 110 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 111 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 111 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 112 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 113 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 114     @Resource(name = &quot;blAdminSecurityServiceExtensionManager&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 115     protected AdminSecurityServiceExtensionManager extensionManager;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 116 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 117     /**</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 118      * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passwordEncoderBean}"> 118      * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@linkðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 119      * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} bean."> 119      * in order to provide bean configuration backwards compatibility with the deprecated {@link org.spriðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 120      *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 121      * &lt;p&gt;{@link #passwordEncoderBean} is set by the bean defined as &quot;blPasswordEncoder&quot;.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 122      *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 123      * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not null."> 123      * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which isðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 124      *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 125      * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either PasswordEncoder"> 125      * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance oðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 126      */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 127     @PostConstruct</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 128     protected void setupPasswordEncoder() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 129         passwordEncoderNew = null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 130         passwordEncoder = null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 131         if (passwordEncoderBean instanceof PasswordEncoder) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 132             passwordEncoderNew = (PasswordEncoder) passwordEncoderBean;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 133         } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncoder) {"> 133         } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 134             passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncoderBean;"> 134             passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 135         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 136             throw new NoSuchBeanDefinitionException(&quot;No PasswordEncoder bean is defined&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 137         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 138     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 139 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 140 </span>
 141 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 142     protected int getTokenExpiredMinutes() {
 143         return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 144     }
 145 
 146     protected String getResetPasswordURL() {
 147         return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 148     }
 149 
 150     @Override
 151     @Transactional(&quot;blTransactionManager&quot;)
 152     public void deleteAdminPermission(AdminPermission permission) {
 153         adminPermissionDao.deleteAdminPermission(permission);
 154         clearAdminSecurityCache();
 155     }
 156 
 157     @Override
 158     @Transactional(&quot;blTransactionManager&quot;)
 159     public void deleteAdminRole(AdminRole role) {
 160         adminRoleDao.deleteAdminRole(role);
 161         clearAdminSecurityCache();
 162     }
 163 
 164     @Override
 165     @Transactional(&quot;blTransactionManager&quot;)
 166     public void deleteAdminUser(AdminUser user) {
 167         adminUserDao.deleteAdminUser(user);
 168         clearAdminSecurityCache();
 169     }
 170 
 171     @Override
 172     public AdminPermission readAdminPermissionById(Long id) {
 173         return adminPermissionDao.readAdminPermissionById(id);
 174     }
 175 
 176     @Override
 177     public AdminRole readAdminRoleById(Long id) {
 178         return adminRoleDao.readAdminRoleById(id);
 179     }
 180 
 181     @Override
 182     public AdminUser readAdminUserById(Long id) {
 183         return adminUserDao.readAdminUserById(id);
 184     }
 185 
 186     @Override
 187     @Transactional(&quot;blTransactionManager&quot;)
 188     public AdminPermission saveAdminPermission(AdminPermission permission) {
 189         permission = adminPermissionDao.saveAdminPermission(permission);
 190         clearAdminSecurityCache();
 191         return permission;
 192     }
 193 
 194     @Override
 195     @Transactional(&quot;blTransactionManager&quot;)
 196     public AdminRole saveAdminRole(AdminRole role) {
 197         role = adminRoleDao.saveAdminRole(role);
 198         clearAdminSecurityCache();
 199         return role;
 200     }
 201 
 202     @Override
 203     @Transactional(&quot;blTransactionManager&quot;)
 204     public AdminUser saveAdminUser(AdminUser user) {
 205         boolean encodePasswordNeeded = false;
 206         String unencodedPassword = user.getUnencodedPassword();
 207 
 208         if (user.getUnencodedPassword() != null) {
 209             encodePasswordNeeded = true;
 210             user.setPassword(unencodedPassword);
 211         }
 212 
 213         // If no password is set, default to a secure password.
 214         if (user.getPassword() == null) {
 215             user.setPassword(generateSecurePassword());
 216         }
 217 
 218         AdminUser returnUser = adminUserDao.saveAdminUser(user);
 219 
 220         if (encodePasswordNeeded) {
 221             returnUser.setPassword(encodePassword(unencodedPassword));
 222         }
 223 
 224         returnUser = adminUserDao.saveAdminUser(returnUser);
 225         clearAdminSecurityCache();
 226         return returnUser;
 227     }
 228 
 229     @Override
 230     public void clearAdminSecurityCache() {
 231         if (LOG.isTraceEnabled()) {
 232             LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 233         }
 234         cache.removeAll();
 235     }
 236 
 237     protected String generateSecurePassword() {
 238         return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 239     }
 240 
 241     @Override
 242     @Transactional(&quot;blTransactionManager&quot;)
 243     public AdminUser changePassword(PasswordChange passwordChange) {
 244         AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 245         user.setUnencodedPassword(passwordChange.getNewPassword());
 246         user = saveAdminUser(user);
 247         Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 248         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 248         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passworðŸ”µ</abbr>
 249         SecurityContextHolder.getContext().setAuthentication(authRequest);
 250         auth.setAuthenticated(false);
 251         return user;
 252     }
 253 
 254     @Override
<abbr title=" 255     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 255     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissðŸ”µ</abbr>
 256         Boolean response = null;
 257         String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 258         Element cacheElement = cache.get(cacheKey);
 259 
 260         if (cacheElement != null) {
 261             response = (Boolean) cacheElement.getObjectValue();
 262 
 263             if (LOG.isTraceEnabled()) {
 264                 LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 265             }
 266         }
 267 
 268         if (response == null) {
 269             if (extensionManager != null) {
 270                 ExtensionResultHolder&lt;Boolean&gt; result = new ExtensionResultHolder&lt;Boolean&gt;();
<abbr title=" 271                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperation(adminUser, permissionType, result);"> 271                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForðŸ”µ</abbr>
 272                 if (ExtensionResultStatusType.HANDLED == resultStatusType) {
 273                     response = result.getResult();
 274                 }
 275             }
 276 
 277             if (response == null || !response) {
<abbr title=" 278                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 278                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permiðŸ”µ</abbr>
 279 
 280                 if (!response) {
<abbr title=" 281                     response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 281                     response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPerðŸ”µ</abbr>
 282                 }
 283             }
 284 
 285             cacheElement = new Element(cacheKey, response);
 286             cache.put(cacheElement);
 287 
 288             if (LOG.isTraceEnabled()) {
 289                 LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 290             }
 291         }
 292 
 293         return response;
 294     }
 295 
<abbr title=" 296     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 296     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntiðŸ”µ</abbr>
 297         return CACHE_KEY_PREFIX
 298                + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 299                + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 300                + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 301     }
 302 
 303     @Override
<abbr title=" 304     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 304     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityðŸ”µ</abbr>
<abbr title=" 305         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 305         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQuðŸ”µ</abbr>
 306     }
 307 
 308     @Override
 309     public AdminUser readAdminUserByUserName(String userName) {
 310         return adminUserDao.readAdminUserByUserName(userName);
 311     }
 312 
 313     @Override
 314     public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 315         return adminUserDao.readAdminUserByEmail(email);
 316     }
 317 
 318     @Override
 319     public List&lt;AdminUser&gt; readAllAdminUsers() {
 320         return adminUserDao.readAllAdminUsers();
 321     }
 322 
 323     @Override
 324     public List&lt;AdminRole&gt; readAllAdminRoles() {
 325         return adminRoleDao.readAllAdminRoles();
 326     }
 327 
 328     @Override
 329     public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 330         return adminPermissionDao.readAllAdminPermissions();
 331     }
 332 
 333     @Override
 334     @Transactional(&quot;blTransactionManager&quot;)
 335     public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 336         GenericResponse response = new GenericResponse();
 337         List&lt;AdminUser&gt; users = null;
 338         if (emailAddress != null) {
 339             users = adminUserDao.readAdminUserByEmail(emailAddress);
 340         }
 341         if (CollectionUtils.isEmpty(users)) {
 342             response.addErrorCode(&quot;notFound&quot;);
 343         } else {
 344             List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 345             for (AdminUser user : users) {
 346                 if (user.getActiveStatusFlag()) {
 347                     activeUsernames.add(user.getLogin());
 348                 }
 349             }
 350 
 351             if (activeUsernames.size() &gt; 0) {
 352                 HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 353                 vars.put(&quot;accountNames&quot;, activeUsernames);
 354                 emailService.sendTemplateEmail(emailAddress, getSendUsernameEmailInfo(), vars);
 355             } else {
 356                 // send inactive username found email.
 357                 response.addErrorCode(&quot;inactiveUser&quot;);
 358             }
 359         }
 360         return response;
 361     }
 362 
 363     @Override
 364     @Transactional(&quot;blTransactionManager&quot;)
 365     public GenericResponse sendResetPasswordNotification(String username) {
 366         GenericResponse response = new GenericResponse();
 367         AdminUser user = null;
 368 
 369         if (username != null) {
 370             user = adminUserDao.readAdminUserByUserName(username);
 371         }
 372 
 373         checkUser(user,response);
 374 
 375         if (! response.getHasErrors()) {
 376             String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 377             token = token.toLowerCase();
 378 
 379             ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 380             fpst.setAdminUserId(user.getId());
 381             fpst.setToken(encodePassword(token));
 382             fpst.setCreateDate(SystemTime.asDate());
 383             forgotPasswordSecurityTokenDao.saveToken(fpst);
 384 
 385             HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 386             vars.put(&quot;token&quot;, token);
 387             String resetPasswordUrl = getResetPasswordURL();
 388             if (!StringUtils.isEmpty(resetPasswordUrl)) {
 389                 if (resetPasswordUrl.contains(&quot;?&quot;)) {
 390                     resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 391                 } else {
 392                     resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 393                 }
 394             }
 395             vars.put(&quot;resetPasswordUrl&quot;, resetPasswordUrl);
 396             emailService.sendTemplateEmail(user.getEmail(), getResetPasswordEmailInfo(), vars);
 397 
 398         }
 399         return response;
 400     }
 401 
 402     @Override
 403     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 404     public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 404     public GenericResponse resetPasswordUsingToken(String username, String token, String password, StringðŸ”µ</abbr>
 405         GenericResponse response = new GenericResponse();
 406         AdminUser user = null;
 407         if (username != null) {
 408             user = adminUserDao.readAdminUserByUserName(username);
 409         }
 410         checkUser(user, response);
 411         checkPassword(password, confirmPassword, response);
 412         if (StringUtils.isBlank(token)) {
 413             response.addErrorCode(&quot;invalidToken&quot;);
 414         }
 415 
 416         ForgotPasswordSecurityToken fpst = null;
 417         if (! response.getHasErrors()) {
 418             token = token.toLowerCase();
<abbr title=" 419             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 419             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByðŸ”µ</abbr>
 420             for (ForgotPasswordSecurityToken fpstok : fpstoks) {
 421                 if (isPasswordValid(fpstok.getToken(), token)) {
 422                     fpst = fpstok;
 423                     break;
 424                 }
 425             }
 426             if (fpst == null) {
 427                 response.addErrorCode(&quot;invalidToken&quot;);
 428             } else if (fpst.isTokenUsedFlag()) {
 429                 response.addErrorCode(&quot;tokenUsed&quot;);
 430             } else if (isTokenExpired(fpst)) {
 431                 response.addErrorCode(&quot;tokenExpired&quot;);
 432             }
 433         }
 434 
 435         if (! response.getHasErrors()) {
 436             if (! user.getId().equals(fpst.getAdminUserId())) {
 437                 if (LOG.isWarnEnabled()) {
<abbr title=" 438                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 438                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId(ðŸ”µ</abbr>
 439                 }
 440                 response.addErrorCode(&quot;invalidToken&quot;);
 441             }
 442         }
 443 
 444         if (! response.getHasErrors()) {
 445             user.setUnencodedPassword(password);
 446             saveAdminUser(user);
 447             invalidateAllTokensForAdminUser(user);
 448         }
 449 
 450         return response;
 451     }
 452 
 453     protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 454         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 454         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminðŸ”µ</abbr>
 455         for (ForgotPasswordSecurityToken token : tokens) {
 456             token.setTokenUsedFlag(true);
 457             forgotPasswordSecurityTokenDao.saveToken(token);
 458         }
 459     }
 460 
 461     protected void checkUser(AdminUser user, GenericResponse response) {
 462         if (user == null) {
 463             response.addErrorCode(&quot;invalidUser&quot;);
 464         } else if (StringUtils.isBlank(user.getEmail())) {
 465             response.addErrorCode(&quot;emailNotFound&quot;);
 466         } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 467             response.addErrorCode(&quot;inactiveUser&quot;);
 468         }
 469     }
 470 
 471     protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 472         if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 473             response.addErrorCode(&quot;invalidPassword&quot;);
 474         } else if (! password.equals(confirmPassword)) {
 475             response.addErrorCode(&quot;passwordMismatch&quot;);
 476         }
 477     }
 478 
<abbr title=" 479     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {"> 479     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse responðŸ”µ</abbr>
 480         if (!isPasswordValid(user.getPassword(), unencodedPassword)) {
 481             response.addErrorCode(&quot;invalidPassword&quot;);
 482         }
 483     }
 484 
 485     protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 486         Date now = SystemTime.asDate();
 487         long currentTimeInMillis = now.getTime();
 488         long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 489         long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 490         return minutesSinceSave &gt; getTokenExpiredMinutes();
 491     }
 492 
 493     public static int getPASSWORD_TOKEN_LENGTH() {
 494         return TEMP_PASSWORD_LENGTH;
 495     }
 496 
 497     public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 498         AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 499     }
 500 
 501     public EmailInfo getSendUsernameEmailInfo() {
 502         return sendUsernameEmailInfo;
 503     }
 504 
 505     public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 506         this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 507     }
 508 
 509     public EmailInfo getResetPasswordEmailInfo() {
 510         return resetPasswordEmailInfo;
 511     }
 512 
 513     public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 514         this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 515     }
 516 
 517     @Override
 518     @Transactional(&quot;blTransactionManager&quot;)
 519     public GenericResponse changePassword(String username,
 520             String oldPassword, String password, String confirmPassword) {
 521         GenericResponse response = new GenericResponse();
 522         AdminUser user = null;
 523         if (username != null) {
 524             user = adminUserDao.readAdminUserByUserName(username);
 525         }
 526         checkUser(user, response);
 527         checkPassword(password, confirmPassword, response);
 528 
 529         if (!response.getHasErrors()) {
 530             checkExistingPassword(oldPassword, user, response);
 531         }
 532 
 533         if (!response.getHasErrors()) {
 534             user.setUnencodedPassword(password);
 535             saveAdminUser(user);
 536 
 537         }
 538 
 539         return response;
 540 
 541     }
 542 
 543     /**
<abbr title=" 544      * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 544      * Determines if a password is valid by comparing it to the encoded string, salting is handled internðŸ”µ</abbr>
 545      * &lt;p&gt;
<abbr title=" 546      * This method must always be called to verify if a password is valid after the original encoded password is generated"> 546      * This method must always be called to verify if a password is valid after the original encoded passðŸ”µ</abbr>
<abbr title=" 547      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 547      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resuðŸ”µ</abbr>
 548      *
 549      * @param encodedPassword the encoded password
 550      * @param rawPassword the raw password to check against the encoded password
 551      * @return true if rawPassword matches the encodedPassword, false otherwise
 552      */
 553     protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
 554         return passwordEncoderBean.matches(rawPassword, encodedPassword);
 555     }
 556 
 557     /**
 558      * Generate an encoded password from a raw password
 559      * &lt;p&gt;
<abbr title=" 560      * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 560      * This method can only be called once per password. The salt is randomly generated internally in theðŸ”µ</abbr>
<abbr title=" 561      * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 561      * and appended to the hash to provide the resulting encoded password. Once this has been called on aðŸ”µ</abbr>
<abbr title=" 562      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 562      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)}ðŸ”µ</abbr>
 563      * same password twice will result in different encoded passwords.
 564      *
 565      * @param rawPassword the unencoded password to encode
 566      * @return the encoded password
 567      */
 568     protected String encodePassword(String rawPassword) {
 569         return passwordEncoderBean.encode(rawPassword);
 570     }
 571 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.openadmin.server.security.service;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  19 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -import net.sf.ehcache.Cache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import net.sf.ehcache.CacheManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import net.sf.ehcache.Element;</span>
  23  
  24  import org.apache.commons.collections4.CollectionUtils;
  25  import org.apache.commons.lang3.BooleanUtils;
  26  import org.apache.commons.lang3.StringUtils;
  27  import org.apache.commons.logging.Log;
  28  import org.apache.commons.logging.LogFactory;
  29  import org.broadleafcommerce.common.email.service.EmailService;
  30  import org.broadleafcommerce.common.email.service.info.EmailInfo;


  31  import org.broadleafcommerce.common.security.util.PasswordChange;
  32  import org.broadleafcommerce.common.security.util.PasswordUtils;
  33  import org.broadleafcommerce.common.service.GenericResponse;
  34  import org.broadleafcommerce.common.time.SystemTime;
  35  import org.broadleafcommerce.common.util.BLCSystemProperty;
  36  import org.broadleafcommerce.common.util.StringUtil;
  37  import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  38  import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  39  import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  40  import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  41  import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  42  import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  43  import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  44  import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  45  import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;

  46  import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  47 -import org.broadleafcommerce.openadmin.server.security.service.user.AdminUserDetails;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import org.springframework.beans.factory.NoSuchBeanDefinitionException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import org.springframework.beans.factory.annotation.Autowired;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import org.springframework.beans.factory.annotation.Qualifier;</span>
  51  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.springframework.security.authentication.dao.SaltSource;</span>
  53  import org.springframework.security.core.Authentication;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import org.springframework.security.core.GrantedAuthority;</span>
  55  import org.springframework.security.core.context.SecurityContextHolder;
  56  import org.springframework.security.crypto.password.PasswordEncoder;
  57  import org.springframework.stereotype.Service;
  58  import org.springframework.transaction.annotation.Transactional;
  59  
  60  import java.util.ArrayList;
  61  import java.util.Date;
  62  import java.util.HashMap;
  63  import java.util.List;
  64  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  65 -import javax.annotation.PostConstruct;</span>
  66  import javax.annotation.Resource;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  68 +import net.sf.ehcache.Cache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +import net.sf.ehcache.CacheManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +import net.sf.ehcache.Element;</span>
  71  
  72  /**
  73   *
  74   * @author jfischer
  75   *
  76   */
  77  @Service(&quot;blAdminSecurityService&quot;)
  78  public class AdminSecurityServiceImpl implements AdminSecurityService {
  79  
  80      private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  81  
  82      private static int TEMP_PASSWORD_LENGTH = 12;
  83      private static final int FULL_PASSWORD_LENGTH = 16;
  84  
  85      @Resource(name = &quot;blAdminRoleDao&quot;)
  86      protected AdminRoleDao adminRoleDao;
  87  
  88      @Resource(name = &quot;blAdminUserDao&quot;)
  89      protected AdminUserDao adminUserDao;
  90  
  91      @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
  92      protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
  93  
  94      @Resource(name = &quot;blAdminPermissionDao&quot;)
  95      protected AdminPermissionDao adminPermissionDao;
  96  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -     * &lt;p&gt;Set by {@link #setupPasswordEncoder()} if the blPasswordEncoder bean provided is the deprecated version.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -     * @deprecated Spring Security has deprecated this encoder interface, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -    protected org.springframework.security.authentication.encoding.PasswordEncoder passwordEncoder;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -     * &lt;p&gt;Set by {@link #setupPasswordEncoder()} if the blPasswordEncoder bean provided is the new version.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -    protected PasswordEncoder passwordEncoderNew;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -</span>
 110      protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
 111      protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
 112      protected Cache cache = CacheManager.getInstance().getCache(CACHE_NAME);
 113  
 114      /**
<abbr title=" 115       * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the"> 115       * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using tðŸ”µ</abbr>
<abbr title=" 116       * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}"> 116       * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PðŸ”µ</abbr>
 117       */
 118      @Resource(name=&quot;blAdminPasswordEncoder&quot;)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -    protected Object passwordEncoderBean;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 121 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -     * Optional password salt to be used with the passwordEncoder</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 123 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -     * @deprecated use {@link #saltSource} instead, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -    protected String salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -     * Use a Salt Source ONLY if there&#x27;s one configured</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -    @Autowired(required=false)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -    @Qualifier(&quot;blAdminSaltSource&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -    protected SaltSource saltSource;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +    protected PasswordEncoder passwordEncoderBean;</span>
 139  
 140      @Resource(name=&quot;blEmailService&quot;)
 141      protected EmailService emailService;
 142  
 143      @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 144      protected EmailInfo resetPasswordEmailInfo;
 145  
 146      @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 147      protected EmailInfo sendUsernameEmailInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -</span>



<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 150 -     * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passwordEncoderBean}"> 150 -     * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passworðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 151 -     * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} bean."> 151 -     * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframewoðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -     * &lt;p&gt;{@link #passwordEncoderBean} is set by the bean defined as &quot;blPasswordEncoder&quot;.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 155 -     * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not null."> 155 -     * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not nullðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 157 -     * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either PasswordEncoder"> 157 -     * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -    @PostConstruct</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -    protected void setupPasswordEncoder() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -        passwordEncoderNew = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -        passwordEncoder = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -        if (passwordEncoderBean instanceof PasswordEncoder) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -            passwordEncoderNew = (PasswordEncoder) passwordEncoderBean;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 165 -        } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncoder) {"> 165 -        } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 166 -            passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncoderBean;"> 166 -            passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncodðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -            throw new NoSuchBeanDefinitionException(&quot;No PasswordEncoder bean is defined&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -    }</span>
 171  
 172      protected int getTokenExpiredMinutes() {
 173          return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 174      }
 175  
 176      protected String getResetPasswordURL() {
 177          return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 178      }
 179  
 180      @Override
 181      @Transactional(&quot;blTransactionManager&quot;)
 182      public void deleteAdminPermission(AdminPermission permission) {
 183          adminPermissionDao.deleteAdminPermission(permission);
 184          clearAdminSecurityCache();
 185      }
 186  
 187      @Override
 188      @Transactional(&quot;blTransactionManager&quot;)
 189      public void deleteAdminRole(AdminRole role) {
 190          adminRoleDao.deleteAdminRole(role);
 191          clearAdminSecurityCache();
 192      }
 193  
 194      @Override
 195      @Transactional(&quot;blTransactionManager&quot;)
 196      public void deleteAdminUser(AdminUser user) {
 197          adminUserDao.deleteAdminUser(user);
 198          clearAdminSecurityCache();
 199      }
 200  
 201      @Override
 202      public AdminPermission readAdminPermissionById(Long id) {
 203          return adminPermissionDao.readAdminPermissionById(id);
 204      }
 205  
 206      @Override
 207      public AdminRole readAdminRoleById(Long id) {
 208          return adminRoleDao.readAdminRoleById(id);
 209      }
 210  
 211      @Override
 212      public AdminUser readAdminUserById(Long id) {
 213          return adminUserDao.readAdminUserById(id);
 214      }
 215  
 216      @Override
 217      @Transactional(&quot;blTransactionManager&quot;)
 218      public AdminPermission saveAdminPermission(AdminPermission permission) {
 219          permission = adminPermissionDao.saveAdminPermission(permission);
 220          clearAdminSecurityCache();
 221          return permission;
 222      }
 223  
 224      @Override
 225      @Transactional(&quot;blTransactionManager&quot;)
 226      public AdminRole saveAdminRole(AdminRole role) {
 227          role = adminRoleDao.saveAdminRole(role);
 228          clearAdminSecurityCache();
 229          return role;
 230      }
 231  
 232      @Override
 233      @Transactional(&quot;blTransactionManager&quot;)
 234      public AdminUser saveAdminUser(AdminUser user) {
 235          boolean encodePasswordNeeded = false;
 236          String unencodedPassword = user.getUnencodedPassword();
 237  
 238          if (user.getUnencodedPassword() != null) {
 239              encodePasswordNeeded = true;
 240              user.setPassword(unencodedPassword);
 241          }
 242  
 243          // If no password is set, default to a secure password.
 244          if (user.getPassword() == null) {
 245              user.setPassword(generateSecurePassword());
 246          }
 247  
 248          AdminUser returnUser = adminUserDao.saveAdminUser(user);
 249  
 250          if (encodePasswordNeeded) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -            returnUser.setPassword(encodePassword(unencodedPassword, getSalt(returnUser, unencodedPassword)));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +            returnUser.setPassword(encodePassword(unencodedPassword));</span>
 253          }
 254  
 255          returnUser = adminUserDao.saveAdminUser(returnUser);
 256          clearAdminSecurityCache();
 257          return returnUser;
 258      }
 259  
 260      @Override
 261      public void clearAdminSecurityCache() {
 262          if (LOG.isTraceEnabled()) {
 263              LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 264          }
 265          cache.removeAll();
 266      }
 267  
 268      protected String generateSecurePassword() {
 269          return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 270      }
 271  
 272      @Override
 273      @Transactional(&quot;blTransactionManager&quot;)
 274      public AdminUser changePassword(PasswordChange passwordChange) {
 275          AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 276          user.setUnencodedPassword(passwordChange.getNewPassword());
 277          user = saveAdminUser(user);
 278          Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 279          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 279          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.gðŸ”µ</abbr>
 280          SecurityContextHolder.getContext().setAuthentication(authRequest);
 281          auth.setAuthenticated(false);
 282          return user;
 283      }
 284  
 285      @Override
<abbr title=" 286      public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 286      public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, ðŸ”µ</abbr>
 287          Boolean response = null;
 288          String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 289          Element cacheElement = cache.get(cacheKey);
 290  
 291          if (cacheElement != null) {
 292              response = (Boolean) cacheElement.getObjectValue();
 293  
 294              if (LOG.isTraceEnabled()) {
 295                  LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 296              }
 297          }
 298  
 299          if (response == null) {
<abbr title=" 300              response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 300              response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceðŸ”µ</abbr>
 301  
 302              if (!response) {
<abbr title=" 303                  response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 303                  response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilðŸ”µ</abbr>














 304              }
 305  
 306              cacheElement = new Element(cacheKey, response);
 307              cache.put(cacheElement);
 308  
 309              if (LOG.isTraceEnabled()) {
 310                  LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 311              }
 312          }
 313  
 314          return response;
 315      }
 316  
<abbr title=" 317      protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 317      protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQuðŸ”µ</abbr>
 318          return CACHE_KEY_PREFIX
 319                 + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 320                 + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 321                 + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 322      }
 323  
 324      @Override
<abbr title=" 325      public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 325      public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualðŸ”µ</abbr>
<abbr title=" 326          return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 326          return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedNaðŸ”µ</abbr>
 327      }
 328  
 329      @Override
 330      public AdminUser readAdminUserByUserName(String userName) {
 331          return adminUserDao.readAdminUserByUserName(userName);
 332      }
 333  
 334      @Override
 335      public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 336          return adminUserDao.readAdminUserByEmail(email);
 337      }
 338  
 339      @Override
 340      public List&lt;AdminUser&gt; readAllAdminUsers() {
 341          return adminUserDao.readAllAdminUsers();
 342      }
 343  
 344      @Override
 345      public List&lt;AdminRole&gt; readAllAdminRoles() {
 346          return adminRoleDao.readAllAdminRoles();
 347      }
 348  
 349      @Override
 350      public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 351          return adminPermissionDao.readAllAdminPermissions();
 352      }
 353  
 354      @Override
 355      @Transactional(&quot;blTransactionManager&quot;)
 356      public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 357          GenericResponse response = new GenericResponse();
 358          List&lt;AdminUser&gt; users = null;
 359          if (emailAddress != null) {
 360              users = adminUserDao.readAdminUserByEmail(emailAddress);
 361          }
 362          if (CollectionUtils.isEmpty(users)) {
 363              response.addErrorCode(&quot;notFound&quot;);
 364          } else {
 365              List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 366              for (AdminUser user : users) {
 367                  if (user.getActiveStatusFlag()) {
 368                      activeUsernames.add(user.getLogin());
 369                  }
 370              }
 371  
 372              if (activeUsernames.size() &gt; 0) {
 373                  HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 374                  vars.put(&quot;accountNames&quot;, activeUsernames);
 375                  emailService.sendTemplateEmail(emailAddress, getSendUsernameEmailInfo(), vars);
 376              } else {
 377                  // send inactive username found email.
 378                  response.addErrorCode(&quot;inactiveUser&quot;);
 379              }
 380          }
 381          return response;
 382      }
 383  
 384      @Override
 385      @Transactional(&quot;blTransactionManager&quot;)
 386      public GenericResponse sendResetPasswordNotification(String username) {
 387          GenericResponse response = new GenericResponse();
 388          AdminUser user = null;
 389  
 390          if (username != null) {
 391              user = adminUserDao.readAdminUserByUserName(username);
 392          }
 393  
 394          checkUser(user,response);
 395  
 396          if (! response.getHasErrors()) {
 397              String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 398              token = token.toLowerCase();
 399  
 400              ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 401              fpst.setAdminUserId(user.getId());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 402 -            fpst.setToken(encodePassword(token, null));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 403 +            fpst.setToken(encodePassword(token));</span>
 404              fpst.setCreateDate(SystemTime.asDate());
 405              forgotPasswordSecurityTokenDao.saveToken(fpst);
 406  
 407              HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 408              vars.put(&quot;token&quot;, token);
 409              String resetPasswordUrl = getResetPasswordURL();
 410              if (!StringUtils.isEmpty(resetPasswordUrl)) {
 411                  if (resetPasswordUrl.contains(&quot;?&quot;)) {
 412                      resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 413                  } else {
 414                      resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 415                  }
 416              }
 417              vars.put(&quot;resetPasswordUrl&quot;, resetPasswordUrl);
 418              emailService.sendTemplateEmail(user.getEmail(), getResetPasswordEmailInfo(), vars);
 419  
 420          }
 421          return response;
 422      }
 423  
 424      @Override
 425      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 426      public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 426      public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPðŸ”µ</abbr>
 427          GenericResponse response = new GenericResponse();
 428          AdminUser user = null;
 429          if (username != null) {
 430              user = adminUserDao.readAdminUserByUserName(username);
 431          }
 432          checkUser(user, response);
 433          checkPassword(password, confirmPassword, response);
 434          if (StringUtils.isBlank(token)) {
 435              response.addErrorCode(&quot;invalidToken&quot;);
 436          }
 437  
 438          ForgotPasswordSecurityToken fpst = null;
 439          if (! response.getHasErrors()) {
 440              token = token.toLowerCase();
<abbr title=" 441              List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 441              List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserðŸ”µ</abbr>
 442              for (ForgotPasswordSecurityToken fpstok : fpstoks) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 443 -                if (isPasswordValid(fpstok.getToken(), token, null)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 444 +                if (isPasswordValid(fpstok.getToken(), token)) {</span>
 445                      fpst = fpstok;
 446                      break;
 447                  }
 448              }
 449              if (fpst == null) {
 450                  response.addErrorCode(&quot;invalidToken&quot;);
 451              } else if (fpst.isTokenUsedFlag()) {
 452                  response.addErrorCode(&quot;tokenUsed&quot;);
 453              } else if (isTokenExpired(fpst)) {
 454                  response.addErrorCode(&quot;tokenExpired&quot;);
 455              }
 456          }
 457  
 458          if (! response.getHasErrors()) {
 459              if (! user.getId().equals(fpst.getAdminUserId())) {
 460                  if (LOG.isWarnEnabled()) {
<abbr title=" 461                      LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 461                      LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; ðŸ”µ</abbr>
 462                  }
 463                  response.addErrorCode(&quot;invalidToken&quot;);
 464              }
 465          }
 466  
 467          if (! response.getHasErrors()) {
 468              user.setUnencodedPassword(password);
 469              saveAdminUser(user);
 470              invalidateAllTokensForAdminUser(user);
 471          }
 472  
 473          return response;
 474      }
 475  
 476      protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 477          List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 477          List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(usðŸ”µ</abbr>
 478          for (ForgotPasswordSecurityToken token : tokens) {
 479              token.setTokenUsedFlag(true);
 480              forgotPasswordSecurityTokenDao.saveToken(token);
 481          }
 482      }
 483  
 484      protected void checkUser(AdminUser user, GenericResponse response) {
 485          if (user == null) {
 486              response.addErrorCode(&quot;invalidUser&quot;);
 487          } else if (StringUtils.isBlank(user.getEmail())) {
 488              response.addErrorCode(&quot;emailNotFound&quot;);
 489          } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 490              response.addErrorCode(&quot;inactiveUser&quot;);
 491          }
 492      }
 493  
 494      protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 495          if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 496              response.addErrorCode(&quot;invalidPassword&quot;);
 497          } else if (! password.equals(confirmPassword)) {
 498              response.addErrorCode(&quot;passwordMismatch&quot;);
 499          }
 500      }
 501  
 502      protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 503 -        if (!isPasswordValid(user.getPassword(), unencodedPassword, getSalt(user, unencodedPassword))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 504 +        if (!isPasswordValid(user.getPassword(), unencodedPassword)) {</span>
 505              response.addErrorCode(&quot;invalidPassword&quot;);
 506          }
 507      }
 508  
 509      protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 510          Date now = SystemTime.asDate();
 511          long currentTimeInMillis = now.getTime();
 512          long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 513          long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 514          return minutesSinceSave &gt; getTokenExpiredMinutes();
 515      }
 516  
 517      public static int getPASSWORD_TOKEN_LENGTH() {
 518          return TEMP_PASSWORD_LENGTH;
 519      }
 520  
 521      public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 522          AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 523      }
 524  
 525      public EmailInfo getSendUsernameEmailInfo() {
 526          return sendUsernameEmailInfo;
 527      }
 528  
 529      public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 530          this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 531      }
 532  
 533      public EmailInfo getResetPasswordEmailInfo() {
 534          return resetPasswordEmailInfo;
 535      }
 536  
 537      public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 538          this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 539      }
 540  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 541 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 542 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 543 -    public Object getSalt(AdminUser user, String unencodedPassword) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 544 -        Object salt = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 545 -        if (saltSource != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 546 -            salt = saltSource.getSalt(new AdminUserDetails(user.getId(), user.getLogin(), unencodedPassword, new ArrayList&lt;GrantedAuthority&gt;()));"> 546 -            salt = saltSource.getSalt(new AdminUserDetails(user.getId(), user.getLogin(), unencodedPassword, new AðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 547 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 548 -        return salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 549 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 550 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 551 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 552 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 553 -    public String getSalt() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 554 -        return salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -    public void setSalt(String salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -        this.salt = salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -    public SaltSource getSaltSource() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -        return saltSource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -    public void setSaltSource(SaltSource saltSource) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -        this.saltSource = saltSource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -</span>
 575      @Override
 576      @Transactional(&quot;blTransactionManager&quot;)
 577      public GenericResponse changePassword(String username,
 578              String oldPassword, String password, String confirmPassword) {
 579          GenericResponse response = new GenericResponse();
 580          AdminUser user = null;
 581          if (username != null) {
 582              user = adminUserDao.readAdminUserByUserName(username);
 583          }
 584          checkUser(user, response);
 585          checkPassword(password, confirmPassword, response);
 586  
 587          if (!response.getHasErrors()) {
 588              checkExistingPassword(oldPassword, user, response);
 589          }
 590  
 591          if (!response.getHasErrors()) {
 592              user.setUnencodedPassword(password);
 593              saveAdminUser(user);
 594  
 595          }
 596  
 597          return response;
 598  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 599 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 600 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 601 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 602 -     * Determines if a password is valid by comparing it to the encoded string, optionally using a salt.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 603 -     * &lt;p&gt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 604 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} support is"> 604 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 605 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing algorithms such as bcrypt."> 605 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing aðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 606 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect against rainbow table attacks"> 606 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect agaiðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 607 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed passwords."> 607 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed pðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 608 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependencies such as {@link SaltSource}."> 608 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependenðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 609 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 610 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 611 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 612 -     * @param encodedPassword the encoded password</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 613 -     * @param rawPassword the unencoded password</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 614 -     * @param salt the optional salt</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 615 -     * @return true if rawPassword matches the encodedPassword, false otherwise</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -    protected boolean isPasswordValid(String encodedPassword, String rawPassword, Object salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -        if (usingDeprecatedPasswordEncoder()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -            return passwordEncoder.isPasswordValid(encodedPassword, rawPassword, salt);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -            return isPasswordValid(encodedPassword, rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -        }</span>
 624      }
 625  
 626      /**
<abbr title=" 627       * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 627       * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to tðŸ”µ</abbr>
 628       * &lt;p&gt;
<abbr title=" 629       * This method must always be called to verify if a password is valid after the original encoded password is generated"> 629       * This method must always be called to verify if a password is valid after the original encoded password is gðŸ”µ</abbr>
<abbr title=" 630       * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 630       * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hasðŸ”µ</abbr>
 631       *
 632       * @param encodedPassword the encoded password
 633       * @param rawPassword the raw password to check against the encoded password
 634       * @return true if rawPassword matches the encodedPassword, false otherwise
 635       */
 636      protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -        return passwordEncoderNew.matches(rawPassword, encodedPassword);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 638 +        return passwordEncoderBean.matches(rawPassword, encodedPassword);</span>
 639      }
 640  
 641      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -     * Generate an encoded password from a raw password, optionally using a salt.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -     * &lt;p&gt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 644 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} support is"> 644 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 645 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing algorithms such as bcrypt."> 645 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing aðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 646 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect against rainbow table attacks"> 646 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect agaiðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 647 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed passwords."> 647 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed pðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 648 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependencies such as {@link SaltSource}."> 648 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependenðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -     * @param rawPassword</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -     * @param salt</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -     * @return</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -    protected String encodePassword(String rawPassword, Object salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -        if (usingDeprecatedPasswordEncoder()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -            return passwordEncoder.encodePassword(rawPassword, salt);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 660 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 661 -            return encodePassword(rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 663 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 664 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 665 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 666 -     * Generate an encoded password from a raw password, salting is handled internally to the {@link PasswordEncoder}."> 666 -     * Generate an encoded password from a raw password, salting is handled internally to the {@link PasswordEncodðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +     * Generate an encoded password from a raw password</span>
 668       * &lt;p&gt;
<abbr title=" 669       * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 669       * This method can only be called once per password. The salt is randomly generated internally in the {@link PðŸ”µ</abbr>
<abbr title=" 670       * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 670       * and appended to the hash to provide the resulting encoded password. Once this has been called on a passwordðŸ”µ</abbr>
<abbr title=" 671       * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 671       * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encodðŸ”µ</abbr>
 672       * same password twice will result in different encoded passwords.
 673       *
 674       * @param rawPassword the unencoded password to encode
 675       * @return the encoded password
 676       */
 677      protected String encodePassword(String rawPassword) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -        return passwordEncoderNew.encode(rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -    protected boolean usingDeprecatedPasswordEncoder() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -        return passwordEncoder != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 684 +        return passwordEncoderBean.encode(rawPassword);</span>
 685      }
 686  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.openadmin.server.security.service;
  19  
  20  import net.sf.ehcache.Cache;
  21  import net.sf.ehcache.CacheManager;
  22  import net.sf.ehcache.Element;
  23  
  24  import org.apache.commons.collections4.CollectionUtils;
  25  import org.apache.commons.lang3.BooleanUtils;
  26  import org.apache.commons.lang3.StringUtils;
  27  import org.apache.commons.logging.Log;
  28  import org.apache.commons.logging.LogFactory;
  29  import org.broadleafcommerce.common.email.service.EmailService;
  30  import org.broadleafcommerce.common.email.service.info.EmailInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import org.broadleafcommerce.common.extension.ExtensionResultHolder;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import org.broadleafcommerce.common.extension.ExtensionResultStatusType;</span>
  33  import org.broadleafcommerce.common.security.util.PasswordChange;
  34  import org.broadleafcommerce.common.security.util.PasswordUtils;
  35  import org.broadleafcommerce.common.service.GenericResponse;
  36  import org.broadleafcommerce.common.time.SystemTime;
  37  import org.broadleafcommerce.common.util.BLCSystemProperty;
  38  import org.broadleafcommerce.common.util.StringUtil;
  39  import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  40  import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  41  import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  42  import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  43  import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  44  import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  45  import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  46  import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  47  import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import org.broadleafcommerce.openadmin.server.security.extension.AdminSecurityServiceExtensionManager;</span>
  49  import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
  50  import org.broadleafcommerce.openadmin.server.security.service.user.AdminUserDetails;
  51  import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  52  import org.springframework.beans.factory.annotation.Autowired;
  53  import org.springframework.beans.factory.annotation.Qualifier;
  54  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  55  import org.springframework.security.authentication.dao.SaltSource;
  56  import org.springframework.security.core.Authentication;
  57  import org.springframework.security.core.GrantedAuthority;
  58  import org.springframework.security.core.context.SecurityContextHolder;
  59  import org.springframework.security.crypto.password.PasswordEncoder;
  60  import org.springframework.stereotype.Service;
  61  import org.springframework.transaction.annotation.Transactional;
  62  
  63  import java.util.ArrayList;
  64  import java.util.Date;
  65  import java.util.HashMap;
  66  import java.util.List;
  67  
  68  import javax.annotation.PostConstruct;
  69  import javax.annotation.Resource;




  70  
  71  /**
  72   *
  73   * @author jfischer
  74   *
  75   */
  76  @Service(&quot;blAdminSecurityService&quot;)
  77  public class AdminSecurityServiceImpl implements AdminSecurityService {
  78  
  79      private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  80  
  81      private static int TEMP_PASSWORD_LENGTH = 12;
  82      private static final int FULL_PASSWORD_LENGTH = 16;
  83  
  84      @Resource(name = &quot;blAdminRoleDao&quot;)
  85      protected AdminRoleDao adminRoleDao;
  86  
  87      @Resource(name = &quot;blAdminUserDao&quot;)
  88      protected AdminUserDao adminUserDao;
  89  
  90      @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
  91      protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
  92  
  93      @Resource(name = &quot;blAdminPermissionDao&quot;)
  94      protected AdminPermissionDao adminPermissionDao;
  95  
  96      /**
  97       * &lt;p&gt;Set by {@link #setupPasswordEncoder()} if the blPasswordEncoder bean provided is the deprecated version.
  98       *
  99       * @deprecated Spring Security has deprecated this encoder interface, this will be removed in 4.2
 100       */
 101      @Deprecated
 102      protected org.springframework.security.authentication.encoding.PasswordEncoder passwordEncoder;
 103  
 104      /**
 105       * &lt;p&gt;Set by {@link #setupPasswordEncoder()} if the blPasswordEncoder bean provided is the new version.
 106       */
 107      protected PasswordEncoder passwordEncoderNew;
 108  
 109      protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
 110      protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
 111      protected Cache cache = CacheManager.getInstance().getCache(CACHE_NAME);
 112  
 113      /**
<abbr title=" 114       * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the"> 114       * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using tðŸ”µ</abbr>
<abbr title=" 115       * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}"> 115       * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PðŸ”µ</abbr>
 116       */
 117      @Resource(name=&quot;blAdminPasswordEncoder&quot;)
 118      protected Object passwordEncoderBean;
 119  
 120      /**
 121       * Optional password salt to be used with the passwordEncoder
 122       *
 123       * @deprecated use {@link #saltSource} instead, this will be removed in 4.2
 124       */
 125      @Deprecated
 126      protected String salt;
 127  
 128      /**
 129       * Use a Salt Source ONLY if there&#x27;s one configured
 130       *
 131       * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2
 132       */
 133      @Deprecated
 134      @Autowired(required=false)
 135      @Qualifier(&quot;blAdminSaltSource&quot;)
 136      protected SaltSource saltSource;

 137  
 138      @Resource(name=&quot;blEmailService&quot;)
 139      protected EmailService emailService;
 140  
 141      @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 142      protected EmailInfo resetPasswordEmailInfo;
 143  
 144      @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 145      protected EmailInfo sendUsernameEmailInfo;
 146  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +    @Resource(name = &quot;blAdminSecurityServiceExtensionManager&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +    protected AdminSecurityServiceExtensionManager extensionManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +</span>
 150      /**
<abbr title=" 151       * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passwordEncoderBean}"> 151       * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passworðŸ”µ</abbr>
<abbr title=" 152       * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} bean."> 152       * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframewoðŸ”µ</abbr>
 153       *
 154       * &lt;p&gt;{@link #passwordEncoderBean} is set by the bean defined as &quot;blPasswordEncoder&quot;.
 155       *
<abbr title=" 156       * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not null."> 156       * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not nullðŸ”µ</abbr>
 157       *
<abbr title=" 158       * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either PasswordEncoder"> 158       * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either ðŸ”µ</abbr>
 159       */
 160      @PostConstruct
 161      protected void setupPasswordEncoder() {
 162          passwordEncoderNew = null;
 163          passwordEncoder = null;
 164          if (passwordEncoderBean instanceof PasswordEncoder) {
 165              passwordEncoderNew = (PasswordEncoder) passwordEncoderBean;
<abbr title=" 166          } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncoder) {"> 166          } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncðŸ”µ</abbr>
<abbr title=" 167              passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncoderBean;"> 167              passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncodðŸ”µ</abbr>
 168          } else {
 169              throw new NoSuchBeanDefinitionException(&quot;No PasswordEncoder bean is defined&quot;);
 170          }
 171      }
 172  
 173      protected int getTokenExpiredMinutes() {
 174          return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 175      }
 176  
 177      protected String getResetPasswordURL() {
 178          return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 179      }
 180  
 181      @Override
 182      @Transactional(&quot;blTransactionManager&quot;)
 183      public void deleteAdminPermission(AdminPermission permission) {
 184          adminPermissionDao.deleteAdminPermission(permission);
 185          clearAdminSecurityCache();
 186      }
 187  
 188      @Override
 189      @Transactional(&quot;blTransactionManager&quot;)
 190      public void deleteAdminRole(AdminRole role) {
 191          adminRoleDao.deleteAdminRole(role);
 192          clearAdminSecurityCache();
 193      }
 194  
 195      @Override
 196      @Transactional(&quot;blTransactionManager&quot;)
 197      public void deleteAdminUser(AdminUser user) {
 198          adminUserDao.deleteAdminUser(user);
 199          clearAdminSecurityCache();
 200      }
 201  
 202      @Override
 203      public AdminPermission readAdminPermissionById(Long id) {
 204          return adminPermissionDao.readAdminPermissionById(id);
 205      }
 206  
 207      @Override
 208      public AdminRole readAdminRoleById(Long id) {
 209          return adminRoleDao.readAdminRoleById(id);
 210      }
 211  
 212      @Override
 213      public AdminUser readAdminUserById(Long id) {
 214          return adminUserDao.readAdminUserById(id);
 215      }
 216  
 217      @Override
 218      @Transactional(&quot;blTransactionManager&quot;)
 219      public AdminPermission saveAdminPermission(AdminPermission permission) {
 220          permission = adminPermissionDao.saveAdminPermission(permission);
 221          clearAdminSecurityCache();
 222          return permission;
 223      }
 224  
 225      @Override
 226      @Transactional(&quot;blTransactionManager&quot;)
 227      public AdminRole saveAdminRole(AdminRole role) {
 228          role = adminRoleDao.saveAdminRole(role);
 229          clearAdminSecurityCache();
 230          return role;
 231      }
 232  
 233      @Override
 234      @Transactional(&quot;blTransactionManager&quot;)
 235      public AdminUser saveAdminUser(AdminUser user) {
 236          boolean encodePasswordNeeded = false;
 237          String unencodedPassword = user.getUnencodedPassword();
 238  
 239          if (user.getUnencodedPassword() != null) {
 240              encodePasswordNeeded = true;
 241              user.setPassword(unencodedPassword);
 242          }
 243  
 244          // If no password is set, default to a secure password.
 245          if (user.getPassword() == null) {
 246              user.setPassword(generateSecurePassword());
 247          }
 248  
 249          AdminUser returnUser = adminUserDao.saveAdminUser(user);
 250  
 251          if (encodePasswordNeeded) {
 252              returnUser.setPassword(encodePassword(unencodedPassword, getSalt(returnUser, unencodedPassword)));

 253          }
 254  
 255          returnUser = adminUserDao.saveAdminUser(returnUser);
 256          clearAdminSecurityCache();
 257          return returnUser;
 258      }
 259  
 260      @Override
 261      public void clearAdminSecurityCache() {
 262          if (LOG.isTraceEnabled()) {
 263              LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 264          }
 265          cache.removeAll();
 266      }
 267  
 268      protected String generateSecurePassword() {
 269          return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 270      }
 271  
 272      @Override
 273      @Transactional(&quot;blTransactionManager&quot;)
 274      public AdminUser changePassword(PasswordChange passwordChange) {
 275          AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 276          user.setUnencodedPassword(passwordChange.getNewPassword());
 277          user = saveAdminUser(user);
 278          Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 279          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 279          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.gðŸ”µ</abbr>
 280          SecurityContextHolder.getContext().setAuthentication(authRequest);
 281          auth.setAuthenticated(false);
 282          return user;
 283      }
 284  
 285      @Override
<abbr title=" 286      public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 286      public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, ðŸ”µ</abbr>
 287          Boolean response = null;
 288          String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 289          Element cacheElement = cache.get(cacheKey);
 290  
 291          if (cacheElement != null) {
 292              response = (Boolean) cacheElement.getObjectValue();
 293  
 294              if (LOG.isTraceEnabled()) {
 295                  LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 296              }
 297          }
 298  
 299          if (response == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 300 -            response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 300 -            response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -            if (!response) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 303 -                response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 303 -                response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +            if (extensionManager != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +                ExtensionResultHolder&lt;Boolean&gt; result = new ExtensionResultHolder&lt;Boolean&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 306 +                ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperation(adminUser, permissionType, result);"> 306 +                ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperationðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +                if (ExtensionResultStatusType.HANDLED == resultStatusType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +                    response = result.getResult();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +            if (response == null || !response) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 313 +                response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 313 +                response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionTypeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +                if (!response) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 316 +                    response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 316 +                    response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +                }</span>
 318              }
 319  
 320              cacheElement = new Element(cacheKey, response);
 321              cache.put(cacheElement);
 322  
 323              if (LOG.isTraceEnabled()) {
 324                  LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 325              }
 326          }
 327  
 328          return response;
 329      }
 330  
<abbr title=" 331      protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 331      protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQuðŸ”µ</abbr>
 332          return CACHE_KEY_PREFIX
 333                 + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 334                 + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 335                 + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 336      }
 337  
 338      @Override
<abbr title=" 339      public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 339      public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualðŸ”µ</abbr>
<abbr title=" 340          return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 340          return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedNaðŸ”µ</abbr>
 341      }
 342  
 343      @Override
 344      public AdminUser readAdminUserByUserName(String userName) {
 345          return adminUserDao.readAdminUserByUserName(userName);
 346      }
 347  
 348      @Override
 349      public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 350          return adminUserDao.readAdminUserByEmail(email);
 351      }
 352  
 353      @Override
 354      public List&lt;AdminUser&gt; readAllAdminUsers() {
 355          return adminUserDao.readAllAdminUsers();
 356      }
 357  
 358      @Override
 359      public List&lt;AdminRole&gt; readAllAdminRoles() {
 360          return adminRoleDao.readAllAdminRoles();
 361      }
 362  
 363      @Override
 364      public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 365          return adminPermissionDao.readAllAdminPermissions();
 366      }
 367  
 368      @Override
 369      @Transactional(&quot;blTransactionManager&quot;)
 370      public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 371          GenericResponse response = new GenericResponse();
 372          List&lt;AdminUser&gt; users = null;
 373          if (emailAddress != null) {
 374              users = adminUserDao.readAdminUserByEmail(emailAddress);
 375          }
 376          if (CollectionUtils.isEmpty(users)) {
 377              response.addErrorCode(&quot;notFound&quot;);
 378          } else {
 379              List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 380              for (AdminUser user : users) {
 381                  if (user.getActiveStatusFlag()) {
 382                      activeUsernames.add(user.getLogin());
 383                  }
 384              }
 385  
 386              if (activeUsernames.size() &gt; 0) {
 387                  HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 388                  vars.put(&quot;accountNames&quot;, activeUsernames);
 389                  emailService.sendTemplateEmail(emailAddress, getSendUsernameEmailInfo(), vars);
 390              } else {
 391                  // send inactive username found email.
 392                  response.addErrorCode(&quot;inactiveUser&quot;);
 393              }
 394          }
 395          return response;
 396      }
 397  
 398      @Override
 399      @Transactional(&quot;blTransactionManager&quot;)
 400      public GenericResponse sendResetPasswordNotification(String username) {
 401          GenericResponse response = new GenericResponse();
 402          AdminUser user = null;
 403  
 404          if (username != null) {
 405              user = adminUserDao.readAdminUserByUserName(username);
 406          }
 407  
 408          checkUser(user,response);
 409  
 410          if (! response.getHasErrors()) {
 411              String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 412              token = token.toLowerCase();
 413  
 414              ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 415              fpst.setAdminUserId(user.getId());
 416              fpst.setToken(encodePassword(token, null));

 417              fpst.setCreateDate(SystemTime.asDate());
 418              forgotPasswordSecurityTokenDao.saveToken(fpst);
 419  
 420              HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 421              vars.put(&quot;token&quot;, token);
 422              String resetPasswordUrl = getResetPasswordURL();
 423              if (!StringUtils.isEmpty(resetPasswordUrl)) {
 424                  if (resetPasswordUrl.contains(&quot;?&quot;)) {
 425                      resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 426                  } else {
 427                      resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 428                  }
 429              }
 430              vars.put(&quot;resetPasswordUrl&quot;, resetPasswordUrl);
 431              emailService.sendTemplateEmail(user.getEmail(), getResetPasswordEmailInfo(), vars);
 432  
 433          }
 434          return response;
 435      }
 436  
 437      @Override
 438      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 439      public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 439      public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPðŸ”µ</abbr>
 440          GenericResponse response = new GenericResponse();
 441          AdminUser user = null;
 442          if (username != null) {
 443              user = adminUserDao.readAdminUserByUserName(username);
 444          }
 445          checkUser(user, response);
 446          checkPassword(password, confirmPassword, response);
 447          if (StringUtils.isBlank(token)) {
 448              response.addErrorCode(&quot;invalidToken&quot;);
 449          }
 450  
 451          ForgotPasswordSecurityToken fpst = null;
 452          if (! response.getHasErrors()) {
 453              token = token.toLowerCase();
<abbr title=" 454              List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 454              List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserðŸ”µ</abbr>
 455              for (ForgotPasswordSecurityToken fpstok : fpstoks) {
 456                  if (isPasswordValid(fpstok.getToken(), token, null)) {

 457                      fpst = fpstok;
 458                      break;
 459                  }
 460              }
 461              if (fpst == null) {
 462                  response.addErrorCode(&quot;invalidToken&quot;);
 463              } else if (fpst.isTokenUsedFlag()) {
 464                  response.addErrorCode(&quot;tokenUsed&quot;);
 465              } else if (isTokenExpired(fpst)) {
 466                  response.addErrorCode(&quot;tokenExpired&quot;);
 467              }
 468          }
 469  
 470          if (! response.getHasErrors()) {
 471              if (! user.getId().equals(fpst.getAdminUserId())) {
 472                  if (LOG.isWarnEnabled()) {
<abbr title=" 473                      LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 473                      LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; ðŸ”µ</abbr>
 474                  }
 475                  response.addErrorCode(&quot;invalidToken&quot;);
 476              }
 477          }
 478  
 479          if (! response.getHasErrors()) {
 480              user.setUnencodedPassword(password);
 481              saveAdminUser(user);
 482              invalidateAllTokensForAdminUser(user);
 483          }
 484  
 485          return response;
 486      }
 487  
 488      protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 489          List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 489          List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(usðŸ”µ</abbr>
 490          for (ForgotPasswordSecurityToken token : tokens) {
 491              token.setTokenUsedFlag(true);
 492              forgotPasswordSecurityTokenDao.saveToken(token);
 493          }
 494      }
 495  
 496      protected void checkUser(AdminUser user, GenericResponse response) {
 497          if (user == null) {
 498              response.addErrorCode(&quot;invalidUser&quot;);
 499          } else if (StringUtils.isBlank(user.getEmail())) {
 500              response.addErrorCode(&quot;emailNotFound&quot;);
 501          } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 502              response.addErrorCode(&quot;inactiveUser&quot;);
 503          }
 504      }
 505  
 506      protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 507          if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 508              response.addErrorCode(&quot;invalidPassword&quot;);
 509          } else if (! password.equals(confirmPassword)) {
 510              response.addErrorCode(&quot;passwordMismatch&quot;);
 511          }
 512      }
 513  
 514      protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {
 515          if (!isPasswordValid(user.getPassword(), unencodedPassword, getSalt(user, unencodedPassword))) {

 516              response.addErrorCode(&quot;invalidPassword&quot;);
 517          }
 518      }
 519  
 520      protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 521          Date now = SystemTime.asDate();
 522          long currentTimeInMillis = now.getTime();
 523          long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 524          long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 525          return minutesSinceSave &gt; getTokenExpiredMinutes();
 526      }
 527  
 528      public static int getPASSWORD_TOKEN_LENGTH() {
 529          return TEMP_PASSWORD_LENGTH;
 530      }
 531  
 532      public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 533          AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 534      }
 535  
 536      public EmailInfo getSendUsernameEmailInfo() {
 537          return sendUsernameEmailInfo;
 538      }
 539  
 540      public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 541          this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 542      }
 543  
 544      public EmailInfo getResetPasswordEmailInfo() {
 545          return resetPasswordEmailInfo;
 546      }
 547  
 548      public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 549          this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 550      }
 551  
 552      @Deprecated
 553      @Override
 554      public Object getSalt(AdminUser user, String unencodedPassword) {
 555          Object salt = null;
 556          if (saltSource != null) {
<abbr title=" 557              salt = saltSource.getSalt(new AdminUserDetails(user.getId(), user.getLogin(), unencodedPassword, new ArrayList&lt;GrantedAuthority&gt;()));"> 557              salt = saltSource.getSalt(new AdminUserDetails(user.getId(), user.getLogin(), unencodedPassword, new AðŸ”µ</abbr>
 558          }
 559          return salt;
 560      }
 561  
 562      @Deprecated
 563      @Override
 564      public String getSalt() {
 565          return salt;
 566      }
 567  
 568      @Deprecated
 569      @Override
 570      public void setSalt(String salt) {
 571          this.salt = salt;
 572      }
 573  
 574      @Deprecated
 575      @Override
 576      public SaltSource getSaltSource() {
 577          return saltSource;
 578      }
 579  
 580      @Deprecated
 581      @Override
 582      public void setSaltSource(SaltSource saltSource) {
 583          this.saltSource = saltSource;
 584      }
 585  
 586      @Override
 587      @Transactional(&quot;blTransactionManager&quot;)
 588      public GenericResponse changePassword(String username,
 589              String oldPassword, String password, String confirmPassword) {
 590          GenericResponse response = new GenericResponse();
 591          AdminUser user = null;
 592          if (username != null) {
 593              user = adminUserDao.readAdminUserByUserName(username);
 594          }
 595          checkUser(user, response);
 596          checkPassword(password, confirmPassword, response);
 597  
 598          if (!response.getHasErrors()) {
 599              checkExistingPassword(oldPassword, user, response);
 600          }
 601  
 602          if (!response.getHasErrors()) {
 603              user.setUnencodedPassword(password);
 604              saveAdminUser(user);
 605  
 606          }
 607  
 608          return response;
 609  
 610      }
 611  
 612      /**
 613       * Determines if a password is valid by comparing it to the encoded string, optionally using a salt.
 614       * &lt;p&gt;
<abbr title=" 615       * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} support is"> 615       * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEðŸ”µ</abbr>
<abbr title=" 616       * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing algorithms such as bcrypt."> 616       * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing aðŸ”µ</abbr>
<abbr title=" 617       * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect against rainbow table attacks"> 617       * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect agaiðŸ”µ</abbr>
<abbr title=" 618       * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed passwords."> 618       * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed pðŸ”µ</abbr>
<abbr title=" 619       * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependencies such as {@link SaltSource}."> 619       * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependenðŸ”µ</abbr>
 620       *
 621       * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2
 622       *
 623       * @param encodedPassword the encoded password
 624       * @param rawPassword the unencoded password
 625       * @param salt the optional salt
 626       * @return true if rawPassword matches the encodedPassword, false otherwise
 627       */
 628      @Deprecated
 629      protected boolean isPasswordValid(String encodedPassword, String rawPassword, Object salt) {
 630          if (usingDeprecatedPasswordEncoder()) {
 631              return passwordEncoder.isPasswordValid(encodedPassword, rawPassword, salt);
 632          } else {
 633              return isPasswordValid(encodedPassword, rawPassword);
 634          }
 635      }
 636  
 637      /**
<abbr title=" 638       * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 638       * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to tðŸ”µ</abbr>
 639       * &lt;p&gt;
<abbr title=" 640       * This method must always be called to verify if a password is valid after the original encoded password is generated"> 640       * This method must always be called to verify if a password is valid after the original encoded password is gðŸ”µ</abbr>
<abbr title=" 641       * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 641       * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hasðŸ”µ</abbr>
 642       *
 643       * @param encodedPassword the encoded password
 644       * @param rawPassword the raw password to check against the encoded password
 645       * @return true if rawPassword matches the encodedPassword, false otherwise
 646       */
 647      protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
 648          return passwordEncoderNew.matches(rawPassword, encodedPassword);

 649      }
 650  
 651      /**
 652       * Generate an encoded password from a raw password, optionally using a salt.
 653       * &lt;p&gt;
<abbr title=" 654       * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} support is"> 654       * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEðŸ”µ</abbr>
<abbr title=" 655       * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing algorithms such as bcrypt."> 655       * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing aðŸ”µ</abbr>
<abbr title=" 656       * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect against rainbow table attacks"> 656       * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect agaiðŸ”µ</abbr>
<abbr title=" 657       * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed passwords."> 657       * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed pðŸ”µ</abbr>
<abbr title=" 658       * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependencies such as {@link SaltSource}."> 658       * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependenðŸ”µ</abbr>
 659       *
 660       * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2
 661       *
 662       * @param rawPassword
 663       * @param salt
 664       * @return
 665       */
 666      @Deprecated
 667      protected String encodePassword(String rawPassword, Object salt) {
 668          if (usingDeprecatedPasswordEncoder()) {
 669              return passwordEncoder.encodePassword(rawPassword, salt);
 670          } else {
 671              return encodePassword(rawPassword);
 672          }
 673      }
 674  
 675      /**
<abbr title=" 676       * Generate an encoded password from a raw password, salting is handled internally to the {@link PasswordEncoder}."> 676       * Generate an encoded password from a raw password, salting is handled internally to the {@link PasswordEncodðŸ”µ</abbr>

 677       * &lt;p&gt;
<abbr title=" 678       * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 678       * This method can only be called once per password. The salt is randomly generated internally in the {@link PðŸ”µ</abbr>
<abbr title=" 679       * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 679       * and appended to the hash to provide the resulting encoded password. Once this has been called on a passwordðŸ”µ</abbr>
<abbr title=" 680       * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 680       * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encodðŸ”µ</abbr>
 681       * same password twice will result in different encoded passwords.
 682       *
 683       * @param rawPassword the unencoded password to encode
 684       * @return the encoded password
 685       */
 686      protected String encodePassword(String rawPassword) {
 687          return passwordEncoderNew.encode(rawPassword);
 688      }
 689  
 690      @Deprecated
 691      protected boolean usingDeprecatedPasswordEncoder() {
 692          return passwordEncoder != null;

 693      }
 694  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            