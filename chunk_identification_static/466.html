<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>466</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    466
                    <a href="465.html">prev</a>
                    <a href="467.html">next</a>
                    <a href="466_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_9c114bb76edd1fe6bb0cc94b9e413495b7962887_src/com/android/launcher3/LauncherBackupHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;9c114bb76edd1fe6bb0cc94b9e413495b7962887:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;9c114bb76edd1fe6bb0cc94b9e413495b7962887^1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;9c114bb76edd1fe6bb0cc94b9e413495b7962887^2:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;78d8510a20be87fb4236e93e1a1c4163047151fc:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [bj], [s], [s]], subset: [[sbj], [sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 
  32 import android.app.backup.BackupDataInputStream;
  33 import android.app.backup.BackupDataOutput;
  34 import android.app.backup.BackupHelper;
  35 import android.app.backup.BackupManager;
  36 import android.appwidget.AppWidgetManager;
  37 import android.appwidget.AppWidgetProviderInfo;
  38 import android.content.ComponentName;
  39 import android.content.ContentResolver;
  40 import android.content.ContentValues;
  41 import android.content.Context;
  42 import android.content.Intent;
  43 import android.database.Cursor;
  44 import android.graphics.Bitmap;
  45 import android.graphics.BitmapFactory;
  46 import android.graphics.drawable.Drawable;
  47 import android.os.ParcelFileDescriptor;
  48 import android.text.TextUtils;
  49 import android.util.Base64;
  50 import android.util.Log;
  51 
  52 import java.io.ByteArrayOutputStream;
  53 import java.io.FileInputStream;
  54 import java.io.FileOutputStream;
  55 import java.io.IOException;
  56 import java.net.URISyntaxException;
  57 import java.util.ArrayList;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.List;
  61 import java.util.Set;
  62 import java.util.zip.CRC32;
  63 
  64 /**
  65  * Persist the launcher home state across calamities.
  66  */
  67 public class LauncherBackupHelper implements BackupHelper {
  68 
  69     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /** icons are large, dribble them out */
  77     private static final int MAX_ICONS_PER_PASS = 10;
  78 
  79     /** widgets contain previews, which are very large, dribble them out */
  80     private static final int MAX_WIDGETS_PER_PASS = 5;
  81 
  82     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83 
  84     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85 
  86     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87 
  88     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89             android.graphics.Bitmap.CompressFormat.PNG;
  90 
  91     private static BackupManager sBackupManager;
  92 
  93     private static final String[] FAVORITE_PROJECTION = {
  94             Favorites._ID,                     // 0
  95             Favorites.MODIFIED,                // 1
  96             Favorites.INTENT,                  // 2
  97             Favorites.APPWIDGET_PROVIDER,      // 3
  98             Favorites.APPWIDGET_ID,            // 4
  99             Favorites.CELLX,                   // 5
 100             Favorites.CELLY,                   // 6
 101             Favorites.CONTAINER,               // 7
 102             Favorites.ICON,                    // 8
 103             Favorites.ICON_PACKAGE,            // 9
 104             Favorites.ICON_RESOURCE,           // 10
 105             Favorites.ICON_TYPE,               // 11
 106             Favorites.ITEM_TYPE,               // 12
 107             Favorites.SCREEN,                  // 13
 108             Favorites.SPANX,                   // 14
 109             Favorites.SPANY,                   // 15
 110             Favorites.TITLE,                   // 16
 111     };
 112 
 113     private static final int ID_INDEX = 0;
 114     private static final int ID_MODIFIED = 1;
 115     private static final int INTENT_INDEX = 2;
 116     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117     private static final int APPWIDGET_ID_INDEX = 4;
 118     private static final int CELLX_INDEX = 5;
 119     private static final int CELLY_INDEX = 6;
 120     private static final int CONTAINER_INDEX = 7;
 121     private static final int ICON_INDEX = 8;
 122     private static final int ICON_PACKAGE_INDEX = 9;
 123     private static final int ICON_RESOURCE_INDEX = 10;
 124     private static final int ICON_TYPE_INDEX = 11;
 125     private static final int ITEM_TYPE_INDEX = 12;
 126     private static final int SCREEN_INDEX = 13;
 127     private static final int SPANX_INDEX = 14;
 128     private static final int SPANY_INDEX = 15;
 129     private static final int TITLE_INDEX = 16;
 130 
 131     private static final String[] SCREEN_PROJECTION = {
 132             WorkspaceScreens._ID,              // 0
 133             WorkspaceScreens.MODIFIED,         // 1
 134             WorkspaceScreens.SCREEN_RANK       // 2
 135     };
 136 
 137     private static final int SCREEN_RANK_INDEX = 2;
 138 
 139     private final Context mContext;
 140 
 141     private final boolean mRestoreEnabled;
 142 
 143     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 144 
 145     private ArrayList&lt;Key&gt; mKeys;
 146 
 147     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 148         mContext = context;
 149         mRestoreEnabled = restoreEnabled;
 150     }
 151 
 152     private void dataChanged() {
 153         if (sBackupManager == null) {
 154             sBackupManager = new BackupManager(mContext);
 155         }
 156         sBackupManager.dataChanged();
 157     }
 158 
 159     /**
 160      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 161      *
 162      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 163      *
 164      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 165      *
 166      * @param oldState notes from the last backup
 167      * @param data incremental key/value pairs to persist off-device
 168      * @param newState notes for the next backup
 169      * @throws IOException
 170      */
 171     @Override
 172     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 173             ParcelFileDescriptor newState) {
 174         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 175 
 176         Journal in = readJournal(oldState);
 177         Journal out = new Journal();
 178 
 179         long lastBackupTime = in.t;
 180         out.t = System.currentTimeMillis();
 181         out.rows = 0;
 182         out.bytes = 0;
 183 
 184         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 185 
 186         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 187         try {
 188             backupFavorites(in, data, out, keys);
 189             backupScreens(in, data, out, keys);
 190             backupIcons(in, data, out, keys);
 191             backupWidgets(in, data, out, keys);
 192         } catch (IOException e) {
 193             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 194         }
 195 
 196 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 197         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 198 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199         out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
 200 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 201         out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
 202 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 203         writeJournal(newState, out);
 204         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 205     }
 206 
 207     /**
 208      * Restore launcher configuration from the restored data stream.
 209      *
 210      * &lt;P&gt;Keys may arrive in any order.
 211      *
 212      * @param data the key/value pair from the server
 213      */
 214     @Override
 215     public void restoreEntity(BackupDataInputStream data) {
 216         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 217         if (mKeys == null) {
 218             mKeys = new ArrayList&lt;Key&gt;();
 219         }
 220         byte[] buffer = new byte[512];
 221             String backupKey = data.getKey();
 222             int dataSize = data.size();
 223             if (buffer.length &lt; dataSize) {
 224                 buffer = new byte[dataSize];
 225             }
 226             Key key = null;
 227         int bytesRead = 0;
 228         try {
 229             bytesRead = data.read(buffer, 0, dataSize);
 230             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 231         } catch (IOException e) {
 232             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 233         }
 234         try {
 235             key = backupKeyToKey(backupKey);
 236             mKeys.add(key);
 237             switch (key.type) {
 238                 case Key.FAVORITE:
 239                     restoreFavorite(key, buffer, dataSize, mKeys);
 240                     break;
 241 
 242                 case Key.SCREEN:
 243                     restoreScreen(key, buffer, dataSize, mKeys);
 244                     break;
 245 
 246                 case Key.ICON:
 247                     restoreIcon(key, buffer, dataSize, mKeys);
 248                     break;
 249 
 250                 case Key.WIDGET:
 251                     restoreWidget(key, buffer, dataSize, mKeys);
 252                     break;
 253 
 254                 default:
 255                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 256                     break;
 257             }
 258         } catch (KeyParsingException e) {
 259             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 260         }
 261 
 262     }
 263 
 264     /**
 265      * Record the restore state for the next backup.
 266      *
 267      * @param newState notes about the backup state after restore.
 268      */
 269     @Override
 270     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 271         // clear the output journal time, to force a full backup to
 272         // will catch any changes the restore process might have made
 273         Journal out = new Journal();
 274         out.t = 0;
 275 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 276         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 277 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 278         out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
 279 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 280         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 281 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 282         writeJournal(newState, out);
 283         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 284         mKeys.clear();
 285     }
 286 
 287     /**
 288      * Write all modified favorites to the data stream.
 289      *
 290      *
 291      * @param in notes from last backup
 292      * @param data output stream for key/value pairs
 293      * @param out notes about this backup
 294      * @param keys keys to mark as clean in the notes for next backup
 295      * @throws IOException
 296      */
 297     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 298             ArrayList&lt;Key&gt; keys)
 299             throws IOException {
 300         // read the old ID set
 301         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 302         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 303 
 304         // persist things that have changed since the last backup
 305         ContentResolver cr = mContext.getContentResolver();
 306         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 307                 null, null, null);
 308         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 309         try {
 310             cursor.moveToPosition(-1);
 311             while(cursor.moveToNext()) {
 312                 final long id = cursor.getLong(ID_INDEX);
 313                 final long updateTime = cursor.getLong(ID_MODIFIED);
 314                 Key key = getKey(Key.FAVORITE, id);
 315                 keys.add(key);
 316                 final String backupKey = keyToBackupKey(key);
 317                 currentIds.add(backupKey);
 318                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 319                     byte[] blob = packFavorite(cursor);
 320                     writeRowToBackup(key, blob, out, data);
 321                 } else {
 322                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 323                 }
 324             }
 325         } finally {
 326             cursor.close();
 327         }
 328         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 329 
 330         // these IDs must have been deleted
 331         savedIds.removeAll(currentIds);
 332         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 333     }
 334 
 335     /**
 336      * Read a favorite from the stream.
 337      *
 338      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 339      *
 340      * @param key identifier for the row
 341      * @param buffer the serialized proto from the stream, may be larger than dataSize
 342      * @param dataSize the size of the proto from the stream
 343      * @param keys keys to mark as clean in the notes for next backup
 344      */
 345     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 346         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 347         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 348                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 349 
 350         if (!mRestoreEnabled) {
 351             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 352             return;
 353         }
 354 
 355         try {
 356             ContentResolver cr = mContext.getContentResolver();
 357             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 358             cr.insert(Favorites.CONTENT_URI, values);
 359         } catch (InvalidProtocolBufferNanoException e) {
 360             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 361         }
 362     }
 363 
 364     /**
 365      * Write all modified screens to the data stream.
 366      *
 367      *
 368      * @param in notes from last backup
 369      * @param data output stream for key/value pairs
 370      * @param out notes about this backup
 371      * @param keys keys to mark as clean in the notes for next backup
 372      * @throws IOException
 373      */
 374     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 375             ArrayList&lt;Key&gt; keys)
 376             throws IOException {
 377         // read the old ID set
 378         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 379         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 380 
 381         // persist things that have changed since the last backup
 382         ContentResolver cr = mContext.getContentResolver();
 383         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 384                 null, null, null);
 385         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 386         try {
 387             cursor.moveToPosition(-1);
 388             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 389             while(cursor.moveToNext()) {
 390                 final long id = cursor.getLong(ID_INDEX);
 391                 final long updateTime = cursor.getLong(ID_MODIFIED);
 392                 Key key = getKey(Key.SCREEN, id);
 393                 keys.add(key);
 394                 final String backupKey = keyToBackupKey(key);
 395                 currentIds.add(backupKey);
 396                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 397                     byte[] blob = packScreen(cursor);
 398                     writeRowToBackup(key, blob, out, data);
 399                 } else {
 400                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 401                 }
 402             }
 403         } finally {
 404             cursor.close();
 405         }
 406         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 407 
 408         // these IDs must have been deleted
 409         savedIds.removeAll(currentIds);
 410         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 411     }
 412 
 413     /**
 414      * Read a screen from the stream.
 415      *
 416      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 417      *
 418      * @param key identifier for the row
 419      * @param buffer the serialized proto from the stream, may be larger than dataSize
 420      * @param dataSize the size of the proto from the stream
 421      * @param keys keys to mark as clean in the notes for next backup
 422      */
 423     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 424         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 425         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 426                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 427 
 428         if (!mRestoreEnabled) {
 429             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 430             return;
 431         }
 432 
 433         try {
 434             ContentResolver cr = mContext.getContentResolver();
 435             ContentValues values = unpackScreen(buffer, 0, dataSize);
 436             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 437 
 438         } catch (InvalidProtocolBufferNanoException e) {
 439             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 440         }
 441     }
 442 
 443     /**
 444      * Write all the static icon resources we need to render placeholders
 445      * for a package that is not installed.
 446      *
 447      * @param in notes from last backup
 448      * @param data output stream for key/value pairs
 449      * @param out notes about this backup
 450      * @param keys keys to mark as clean in the notes for next backup
 451      * @throws IOException
 452      */
 453     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 454             ArrayList&lt;Key&gt; keys) throws IOException {
 455         // persist icons that haven&#x27;t been persisted yet
 456         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 457         if (appState == null) {
 458             dataChanged(); // try again later
 459             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 460             return;
 461         }
 462         final ContentResolver cr = mContext.getContentResolver();
 463         final IconCache iconCache = appState.getIconCache();
 464         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 465 
 466         // read the old ID set
 467         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 468         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 469 
 470         int startRows = out.rows;
 471         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 472         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 473         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 474                 where, null, null);
 475         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 476         try {
 477             cursor.moveToPosition(-1);
 478             while(cursor.moveToNext()) {
 479                 final long id = cursor.getLong(ID_INDEX);
 480                 final String intentDescription = cursor.getString(INTENT_INDEX);
 481                 try {
 482                     Intent intent = Intent.parseUri(intentDescription, 0);
 483                     ComponentName cn = intent.getComponent();
 484                     Key key = null;
 485                     String backupKey = null;
 486                     if (cn != null) {
 487                         key = getKey(Key.ICON, cn.flattenToShortString());
 488                         backupKey = keyToBackupKey(key);
 489                         currentIds.add(backupKey);
 490                     } else {
 491                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 492                     }
 493                     if (savedIds.contains(backupKey)) {
 494                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 495 
 496                         // remember that we already backed this up previously
 497                         keys.add(key);
 498                     } else if (backupKey != null) {
 499                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 500                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 501                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 502                             Bitmap icon = iconCache.getIcon(intent);
 503                             keys.add(key);
 504                             if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {
 505                                 byte[] blob = packIcon(dpi, icon);
 506                                 writeRowToBackup(key, blob, out, data);
 507                             }
 508                         } else {
 509                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 510                             // too many icons for this pass, request another.
 511                             dataChanged();
 512                         }
 513                     }
 514                 } catch (URISyntaxException e) {
 515                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 516                 } catch (IOException e) {
 517                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 518                 }
 519 
 520             }
 521         } finally {
 522             cursor.close();
 523         }
 524         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 525 
 526         // these IDs must have been deleted
 527         savedIds.removeAll(currentIds);
 528         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 529     }
 530 
 531     /**
 532      * Read an icon from the stream.
 533      *
 534      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 535      *
 536      * @param key identifier for the row
 537      * @param buffer the serialized proto from the stream, may be larger than dataSize
 538      * @param dataSize the size of the proto from the stream
 539      * @param keys keys to mark as clean in the notes for next backup
 540      */
 541     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 542         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 543         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 544                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 545         try {
 546             Resource res = unpackIcon(buffer, 0, dataSize);
 547             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 548             if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +
 549                     Base64.encodeToString(res.data, 0, res.data.length,
 550                             Base64.NO_WRAP));
 551             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 552             if (icon == null) {
 553                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 554             }
 555 
 556             if (!mRestoreEnabled) {
 557                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 558                 return;
 559             } else {
 560                 // future site of icon cache mutation
 561             }
 562         } catch (InvalidProtocolBufferNanoException e) {
 563             Log.e(TAG, &quot;failed to decode icon&quot;, e);
 564         }
 565     }
 566 
 567     /**
 568      * Write all the static widget resources we need to render placeholders
 569      * for a package that is not installed.
 570      *
 571      * @param in notes from last backup
 572      * @param data output stream for key/value pairs
 573      * @param out notes about this backup
 574      * @param keys keys to mark as clean in the notes for next backup
 575      * @throws IOException
 576      */
 577     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 578             ArrayList&lt;Key&gt; keys) throws IOException {
 579         // persist static widget info that hasn&#x27;t been persisted yet
 580         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 581         if (appState == null) {
 582             dataChanged(); // try again later
 583             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);
 584             return;
 585         }
 586         final ContentResolver cr = mContext.getContentResolver();
 587         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 588         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 589         final IconCache iconCache = appState.getIconCache();
 590         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 591         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 592         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 593 
 594         // read the old ID set
 595         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 596         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 597 
 598         int startRows = out.rows;
 599         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 600         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 601         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 602                 where, null, null);
 603         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 604         try {
 605             cursor.moveToPosition(-1);
 606             while(cursor.moveToNext()) {
 607                 final long id = cursor.getLong(ID_INDEX);
 608                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 609                 final int spanX = cursor.getInt(SPANX_INDEX);
 610                 final int spanY = cursor.getInt(SPANY_INDEX);
 611                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 612                 Key key = null;
 613                 String backupKey = null;
 614                 if (provider != null) {
 615                     key = getKey(Key.WIDGET, providerName);
 616                     backupKey = keyToBackupKey(key);
 617                     currentIds.add(backupKey);
 618                 } else {
 619                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 620                 }
 621                 if (savedIds.contains(backupKey)) {
 622                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 623 
 624                     // remember that we already backed this up previously
 625                     keys.add(key);
 626                 } else if (backupKey != null) {
 627                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 628                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 629                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 630                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 631                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 632                         byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);
 633                         keys.add(key);
 634                         writeRowToBackup(key, blob, out, data);
 635 
 636                     } else {
 637                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 638                         // too many widgets for this pass, request another.
 639                         dataChanged();
 640                     }
 641                 }
 642             }
 643         } finally {
 644             cursor.close();
 645         }
 646         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 647 
 648         // these IDs must have been deleted
 649         savedIds.removeAll(currentIds);
 650         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 651     }
 652 
 653     /**
 654      * Read a widget from the stream.
 655      *
 656      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 657      *
 658      * @param key identifier for the row
 659      * @param buffer the serialized proto from the stream, may be larger than dataSize
 660      * @param dataSize the size of the proto from the stream
 661      * @param keys keys to mark as clean in the notes for next backup
 662      */
 663     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 664         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 665         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 666                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 667         try {
 668             Widget widget = unpackWidget(buffer, 0, dataSize);
 669             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 670             if (widget.icon.data != null)  {
 671                 Bitmap icon = BitmapFactory
 672                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 673                 if (icon == null) {
 674                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 675                 }
 676             }
 677 
 678             if (!mRestoreEnabled) {
 679                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 680                 return;
 681             } else {
 682                 // future site of widget table mutation
 683             }
 684         } catch (InvalidProtocolBufferNanoException e) {
 685             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 686         }
 687     }
 688 
 689     /** create a new key, with an integer ID.
 690      *
 691      * &lt;P&gt; Keys contain their own checksum instead of using
 692      * the heavy-weight CheckedMessage wrapper.
 693      */
 694     private Key getKey(int type, long id) {
 695         Key key = new Key();
 696         key.type = type;
 697         key.id = id;
 698         key.checksum = checkKey(key);
 699         return key;
 700     }
 701 
 702     /** create a new key for a named object.
 703      *
 704      * &lt;P&gt; Keys contain their own checksum instead of using
 705      * the heavy-weight CheckedMessage wrapper.
 706      */
 707     private Key getKey(int type, String name) {
 708         Key key = new Key();
 709         key.type = type;
 710         key.name = name;
 711         key.checksum = checkKey(key);
 712         return key;
 713     }
 714 
 715     /** keys need to be strings, serialize and encode. */
 716     private String keyToBackupKey(Key key) {
 717         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 718     }
 719 
 720     /** keys need to be strings, decode and parse. */
 721     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 722         try {
 723             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 724             if (key.checksum != checkKey(key)) {
 725                 key = null;
 726                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 727             }
 728             return key;
 729         } catch (InvalidProtocolBufferNanoException e) {
 730             throw new KeyParsingException(e);
 731         } catch (IllegalArgumentException e) {
 732             throw new KeyParsingException(e);
 733         }
 734     }
 735 
 736     private String getKeyName(Key key) {
 737         if (TextUtils.isEmpty(key.name)) {
 738             return Long.toString(key.id);
 739         } else {
 740             return key.name;
 741         }
 742 
 743     }
 744 
 745     private String geKeyType(Key key) {
 746         switch (key.type) {
 747             case Key.FAVORITE:
 748                 return &quot;favorite&quot;;
 749             case Key.SCREEN:
 750                 return &quot;screen&quot;;
 751             case Key.ICON:
 752                 return &quot;icon&quot;;
 753             case Key.WIDGET:
 754                 return &quot;widget&quot;;
 755             default:
 756                 return &quot;anonymous&quot;;
 757         }
 758     }
 759 
 760     /** Compute the checksum over the important bits of a key. */
 761     private long checkKey(Key key) {
 762         CRC32 checksum = new CRC32();
 763         checksum.update(key.type);
 764         checksum.update((int) (key.id &amp; 0xffff));
 765         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 766         if (!TextUtils.isEmpty(key.name)) {
 767             checksum.update(key.name.getBytes());
 768         }
 769         return checksum.getValue();
 770     }
 771 
 772     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 773     private byte[] packFavorite(Cursor c) {
 774         Favorite favorite = new Favorite();
 775         favorite.id = c.getLong(ID_INDEX);
 776         favorite.screen = c.getInt(SCREEN_INDEX);
 777         favorite.container = c.getInt(CONTAINER_INDEX);
 778         favorite.cellX = c.getInt(CELLX_INDEX);
 779         favorite.cellY = c.getInt(CELLY_INDEX);
 780         favorite.spanX = c.getInt(SPANX_INDEX);
 781         favorite.spanY = c.getInt(SPANY_INDEX);
 782         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 783         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 784             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 785             if (!TextUtils.isEmpty(iconPackage)) {
 786                 favorite.iconPackage = iconPackage;
 787             }
 788             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 789             if (!TextUtils.isEmpty(iconResource)) {
 790                 favorite.iconResource = iconResource;
 791             }
 792         }
 793         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 794             byte[] blob = c.getBlob(ICON_INDEX);
 795             if (blob != null &amp;&amp; blob.length &gt; 0) {
 796                 favorite.icon = blob;
 797             }
 798         }
 799         String title = c.getString(TITLE_INDEX);
 800         if (!TextUtils.isEmpty(title)) {
 801             favorite.title = title;
 802         }
 803         String intent = c.getString(INTENT_INDEX);
 804         if (!TextUtils.isEmpty(intent)) {
 805             favorite.intent = intent;
 806         }
 807         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 808         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 809             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 810             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 811             if (!TextUtils.isEmpty(appWidgetProvider)) {
 812                 favorite.appWidgetProvider = appWidgetProvider;
 813             }
 814         }
 815 
 816         return writeCheckedBytes(favorite);
 817     }
 818 
 819     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 820     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 821             throws InvalidProtocolBufferNanoException {
 822         Favorite favorite = new Favorite();
 823         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 824         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 825                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 826         ContentValues values = new ContentValues();
 827         values.put(Favorites._ID, favorite.id);
 828         values.put(Favorites.SCREEN, favorite.screen);
 829         values.put(Favorites.CONTAINER, favorite.container);
 830         values.put(Favorites.CELLX, favorite.cellX);
 831         values.put(Favorites.CELLY, favorite.cellY);
 832         values.put(Favorites.SPANX, favorite.spanX);
 833         values.put(Favorites.SPANY, favorite.spanY);
 834         values.put(Favorites.ICON_TYPE, favorite.iconType);
 835         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 836             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 837             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 838         }
 839         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 840             values.put(Favorites.ICON, favorite.icon);
 841         }
 842         if (!TextUtils.isEmpty(favorite.title)) {
 843             values.put(Favorites.TITLE, favorite.title);
 844         } else {
 845             values.put(Favorites.TITLE, &quot;&quot;);
 846         }
 847         if (!TextUtils.isEmpty(favorite.intent)) {
 848             values.put(Favorites.INTENT, favorite.intent);
 849         }
 850         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 851         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 852             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 853                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 854             }
 855             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 856         }
 857 
 858         // Let LauncherModel know we&#x27;ve been here.
 859         values.put(LauncherSettings.Favorites.RESTORED, 1);
 860 
 861         return values;
 862     }
 863 
 864     /** Serialize a Screen for persistence, including a checksum wrapper. */
 865     private byte[] packScreen(Cursor c) {
 866         Screen screen = new Screen();
 867         screen.id = c.getLong(ID_INDEX);
 868         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 869 
 870         return writeCheckedBytes(screen);
 871     }
 872 
 873     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 874     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 875             throws InvalidProtocolBufferNanoException {
 876         Screen screen = new Screen();
 877         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 878         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 879         ContentValues values = new ContentValues();
 880         values.put(WorkspaceScreens._ID, screen.id);
 881         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 882         return values;
 883     }
 884 
 885     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 886     private byte[] packIcon(int dpi, Bitmap icon) {
 887         Resource res = new Resource();
 888         res.dpi = dpi;
 889         ByteArrayOutputStream os = new ByteArrayOutputStream();
 890         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 891             res.data = os.toByteArray();
 892         }
 893         return writeCheckedBytes(res);
 894     }
 895 
 896     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 897     private Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 898             throws InvalidProtocolBufferNanoException {
 899         Resource res = new Resource();
 900         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 901         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 902         return res;
 903     }
 904 
 905     /** Serialize a widget for persistence, including a checksum wrapper. */
 906     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 907             ComponentName provider) {
 908         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 909         Widget widget = new Widget();
 910         widget.provider = provider.flattenToShortString();
 911         widget.label = info.label;
 912         widget.configure = info.configure != null;
 913         if (info.icon != 0) {
 914             widget.icon = new Resource();
 915             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 916             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 917             ByteArrayOutputStream os = new ByteArrayOutputStream();
 918             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 919                 widget.icon.data = os.toByteArray();
 920                 widget.icon.dpi = dpi;
 921             }
 922         }
 923         if (info.previewImage != 0) {
 924             widget.preview = new Resource();
 925             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 926             ByteArrayOutputStream os = new ByteArrayOutputStream();
 927             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 928                 widget.preview.data = os.toByteArray();
 929                 widget.preview.dpi = dpi;
 930             }
 931         }
 932         return writeCheckedBytes(widget);
 933     }
 934 
 935     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 936     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 937             throws InvalidProtocolBufferNanoException {
 938         Widget widget = new Widget();
 939         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 940         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 941         return widget;
 942     }
 943 
 944     /**
 945      * Read the old journal from the input file.
 946      *
 947      * In the event of any error, just pretend we didn&#x27;t have a journal,
 948      * in that case, do a full backup.
 949      *
 950      * @param oldState the read-0only file descriptor pointing to the old journal
 951      * @return a Journal protocol buffer
 952      */
 953     private Journal readJournal(ParcelFileDescriptor oldState) {
 954         Journal journal = new Journal();
 955         if (oldState == null) {
 956             return journal;
 957         }
 958         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 959         try {
 960             int availableBytes = inStream.available();
 961             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 962             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 963                 byte[] buffer = new byte[availableBytes];
 964                 int bytesRead = 0;
 965                 boolean valid = false;
 966                 InvalidProtocolBufferNanoException lastProtoException = null;
 967                 while (availableBytes &gt; 0) {
 968                     try {
 969                         // OMG what are you doing? This is crazy inefficient!
 970                         // If we read a byte that is not ours, we will cause trouble: b/12491813
 971                         // However, we don&#x27;t know how many bytes to expect (oops).
 972                         // So we have to step through *slowly*, watching for the end.
 973                         int result = inStream.read(buffer, bytesRead, 1);
 974                         if (result &gt; 0) {
 975                             availableBytes -= result;
 976                             bytesRead += result;
 977                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 978                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 979                             }
 980                         } else {
 981                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 982                             // stop reading and see what there is to parse
 983                             availableBytes = 0;
 984                         }
 985                     } catch (IOException e) {
 986                         buffer = null;
 987                         availableBytes = 0;
 988                     }
 989 
 990                     // check the buffer to see if we have a valid journal
 991                     try {
 992                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
 993                         // if we are here, then we have read a valid, checksum-verified journal
 994                         valid = true;
 995                         availableBytes = 0;
 996                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
 997                     } catch (InvalidProtocolBufferNanoException e) {
 998                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
 999                         lastProtoException = e;
1000                         journal.clear();
1001                     }
1002                 }
1003                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1004                 if (!valid) {
1005                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1006                 }
1007             }
1008         } catch (IOException e) {
1009             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1010         } finally {
1011             try {
1012                 inStream.close();
1013             } catch (IOException e) {
1014                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1015             }
1016         }
1017         return journal;
1018     }
1019 
1020     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1021             BackupDataOutput data) throws IOException {
1022         String backupKey = keyToBackupKey(key);
1023         data.writeEntityHeader(backupKey, blob.length);
1024         data.writeEntityData(blob, blob.length);
1025         out.rows++;
1026         out.bytes += blob.length;
1027         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1028                 getKeyName(key) + &quot;/&quot; + blob.length);
1029         if(DEBUG_PAYLOAD) {
1030             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1031             final int chunkSize = 1024;
1032             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1033                 int end = offset + chunkSize;
1034                 end = Math.min(end, encoded.length());
1035                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1036             }
1037         }
1038     }
1039 
1040     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1041         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1042         for(int i = 0; i &lt; in.key.length; i++) {
1043             Key key = in.key[i];
1044             if (key.type == type) {
1045                 savedIds.add(keyToBackupKey(key));
1046             }
1047         }
1048         return savedIds;
1049     }
1050 
1051     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1052             throws IOException {
1053         int rows = 0;
1054         for(String deleted: deletedIds) {
1055             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1056             data.writeEntityHeader(deleted, -1);
1057             rows++;
1058         }
1059         return rows;
1060     }
1061 
1062     /**
1063      * Write the new journal to the output file.
1064      *
1065      * In the event of any error, just pretend we didn&#x27;t have a journal,
1066      * in that case, do a full backup.
1067 
1068      * @param newState the write-only file descriptor pointing to the new journal
1069      * @param journal a Journal protocol buffer
1070      */
1071     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1072         FileOutputStream outStream = null;
1073         try {
1074             outStream = new FileOutputStream(newState.getFileDescriptor());
1075             final byte[] journalBytes = writeCheckedBytes(journal);
1076             outStream.write(journalBytes);
1077             outStream.close();
1078             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1079         } catch (IOException e) {
1080             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1081         }
1082     }
1083 
1084     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1085     private byte[] writeCheckedBytes(MessageNano proto) {
1086         CheckedMessage wrapper = new CheckedMessage();
1087         wrapper.payload = MessageNano.toByteArray(proto);
1088         CRC32 checksum = new CRC32();
1089         checksum.update(wrapper.payload);
1090         wrapper.checksum = checksum.getValue();
1091         return MessageNano.toByteArray(wrapper);
1092     }
1093 
1094     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1095     private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1096             throws InvalidProtocolBufferNanoException {
1097         CheckedMessage wrapper = new CheckedMessage();
1098         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1099         CRC32 checksum = new CRC32();
1100         checksum.update(wrapper.payload);
1101         if (wrapper.checksum != checksum.getValue()) {
1102             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1103         }
1104         return wrapper.payload;
1105     }
1106 
1107     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1108         if (mWidgetMap == null) {
1109             List&lt;AppWidgetProviderInfo&gt; widgets =
1110                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1111             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1112             for (AppWidgetProviderInfo info : widgets) {
1113                 mWidgetMap.put(info.provider, info);
1114             }
1115         }
1116         return mWidgetMap.get(component);
1117     }
1118 
1119     private class KeyParsingException extends Throwable {
1120         private KeyParsingException(Throwable cause) {
1121             super(cause);
1122         }
1123 
1124         public KeyParsingException(String reason) {
1125             super(reason);
1126         }
1127     }
1128 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 
  32 import android.app.backup.BackupDataInputStream;
  33 import android.app.backup.BackupDataOutput;
  34 import android.app.backup.BackupHelper;
  35 import android.app.backup.BackupManager;
  36 import android.appwidget.AppWidgetManager;
  37 import android.appwidget.AppWidgetProviderInfo;
  38 import android.content.ComponentName;
  39 import android.content.ContentResolver;
  40 import android.content.ContentValues;
  41 import android.content.Context;
  42 import android.content.Intent;
  43 import android.database.Cursor;
  44 import android.graphics.Bitmap;
  45 import android.graphics.BitmapFactory;
  46 import android.graphics.drawable.Drawable;
  47 import android.os.ParcelFileDescriptor;
  48 import android.text.TextUtils;
  49 import android.util.Base64;
  50 import android.util.Log;
  51 
  52 import java.io.ByteArrayOutputStream;
  53 import java.io.FileInputStream;
  54 import java.io.FileOutputStream;
  55 import java.io.IOException;
  56 import java.net.URISyntaxException;
  57 import java.util.ArrayList;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.List;
  61 import java.util.Set;
  62 import java.util.zip.CRC32;
  63 
  64 /**
  65  * Persist the launcher home state across calamities.
  66  */
  67 public class LauncherBackupHelper implements BackupHelper {
  68 
  69     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /** icons are large, dribble them out */
  77     private static final int MAX_ICONS_PER_PASS = 10;
  78 
  79     /** widgets contain previews, which are very large, dribble them out */
  80     private static final int MAX_WIDGETS_PER_PASS = 5;
  81 
  82     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83 
  84     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85 
  86     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87 
  88     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89             android.graphics.Bitmap.CompressFormat.PNG;
  90 
  91     private static BackupManager sBackupManager;
  92 
  93     private static final String[] FAVORITE_PROJECTION = {
  94             Favorites._ID,                     // 0
  95             Favorites.MODIFIED,                // 1
  96             Favorites.INTENT,                  // 2
  97             Favorites.APPWIDGET_PROVIDER,      // 3
  98             Favorites.APPWIDGET_ID,            // 4
  99             Favorites.CELLX,                   // 5
 100             Favorites.CELLY,                   // 6
 101             Favorites.CONTAINER,               // 7
 102             Favorites.ICON,                    // 8
 103             Favorites.ICON_PACKAGE,            // 9
 104             Favorites.ICON_RESOURCE,           // 10
 105             Favorites.ICON_TYPE,               // 11
 106             Favorites.ITEM_TYPE,               // 12
 107             Favorites.SCREEN,                  // 13
 108             Favorites.SPANX,                   // 14
 109             Favorites.SPANY,                   // 15
 110             Favorites.TITLE,                   // 16
 111     };
 112 
 113     private static final int ID_INDEX = 0;
 114     private static final int ID_MODIFIED = 1;
 115     private static final int INTENT_INDEX = 2;
 116     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117     private static final int APPWIDGET_ID_INDEX = 4;
 118     private static final int CELLX_INDEX = 5;
 119     private static final int CELLY_INDEX = 6;
 120     private static final int CONTAINER_INDEX = 7;
 121     private static final int ICON_INDEX = 8;
 122     private static final int ICON_PACKAGE_INDEX = 9;
 123     private static final int ICON_RESOURCE_INDEX = 10;
 124     private static final int ICON_TYPE_INDEX = 11;
 125     private static final int ITEM_TYPE_INDEX = 12;
 126     private static final int SCREEN_INDEX = 13;
 127     private static final int SPANX_INDEX = 14;
 128     private static final int SPANY_INDEX = 15;
 129     private static final int TITLE_INDEX = 16;
 130 
 131     private static final String[] SCREEN_PROJECTION = {
 132             WorkspaceScreens._ID,              // 0
 133             WorkspaceScreens.MODIFIED,         // 1
 134             WorkspaceScreens.SCREEN_RANK       // 2
 135     };
 136 
 137     private static final int SCREEN_RANK_INDEX = 2;
 138 
 139     private final Context mContext;
 140 
 141     private final boolean mRestoreEnabled;
 142 
 143     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 144 
 145     private ArrayList&lt;Key&gt; mKeys;
 146 
 147     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 148         mContext = context;
 149         mRestoreEnabled = restoreEnabled;
 150     }
 151 
 152     private void dataChanged() {
 153         if (sBackupManager == null) {
 154             sBackupManager = new BackupManager(mContext);
 155         }
 156         sBackupManager.dataChanged();
 157     }
 158 
 159     /**
 160      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 161      *
 162      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 163      *
 164      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 165      *
 166      * @param oldState notes from the last backup
 167      * @param data incremental key/value pairs to persist off-device
 168      * @param newState notes for the next backup
 169      * @throws IOException
 170      */
 171     @Override
 172     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 173             ParcelFileDescriptor newState) {
 174         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 175 
 176         Journal in = readJournal(oldState);
 177         Journal out = new Journal();
 178 
 179         long lastBackupTime = in.t;
 180         out.t = System.currentTimeMillis();
 181         out.rows = 0;
 182         out.bytes = 0;
 183 
 184         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 185 
 186         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 187         try {
 188             backupFavorites(in, data, out, keys);
 189             backupScreens(in, data, out, keys);
 190             backupIcons(in, data, out, keys);
 191             backupWidgets(in, data, out, keys);
 192         } catch (IOException e) {
 193             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 194         }
 195 
 196 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 197         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 198 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199         out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
 200 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 201         out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
 202 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 203         writeJournal(newState, out);
 204         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 205     }
 206 
 207     /**
 208      * Restore launcher configuration from the restored data stream.
 209      *
 210      * &lt;P&gt;Keys may arrive in any order.
 211      *
 212      * @param data the key/value pair from the server
 213      */
 214     @Override
 215     public void restoreEntity(BackupDataInputStream data) {
 216         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 217         if (mKeys == null) {
 218             mKeys = new ArrayList&lt;Key&gt;();
 219         }
 220         byte[] buffer = new byte[512];
 221             String backupKey = data.getKey();
 222             int dataSize = data.size();
 223             if (buffer.length &lt; dataSize) {
 224                 buffer = new byte[dataSize];
 225             }
 226             Key key = null;
 227         int bytesRead = 0;
 228         try {
 229             bytesRead = data.read(buffer, 0, dataSize);
 230             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 231         } catch (IOException e) {
 232             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 233         }
 234         try {
 235             key = backupKeyToKey(backupKey);
 236             mKeys.add(key);
 237             switch (key.type) {
 238                 case Key.FAVORITE:
 239                     restoreFavorite(key, buffer, dataSize, mKeys);
 240                     break;
 241 
 242                 case Key.SCREEN:
 243                     restoreScreen(key, buffer, dataSize, mKeys);
 244                     break;
 245 
 246                 case Key.ICON:
 247                     restoreIcon(key, buffer, dataSize, mKeys);
 248                     break;
 249 
 250                 case Key.WIDGET:
 251                     restoreWidget(key, buffer, dataSize, mKeys);
 252                     break;
 253 
 254                 default:
 255                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 256                     break;
 257             }
 258         } catch (KeyParsingException e) {
 259             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 260         }
 261 
 262     }
 263 
 264     /**
 265      * Record the restore state for the next backup.
 266      *
 267      * @param newState notes about the backup state after restore.
 268      */
 269     @Override
 270     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 271         // clear the output journal time, to force a full backup to
 272         // will catch any changes the restore process might have made
 273         Journal out = new Journal();
 274         out.t = 0;
 275 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 276         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 277 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 278         out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
 279 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 280         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 281 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 282         writeJournal(newState, out);
 283         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 284         mKeys.clear();
 285     }
 286 
 287     /**
 288      * Write all modified favorites to the data stream.
 289      *
 290      *
 291      * @param in notes from last backup
 292      * @param data output stream for key/value pairs
 293      * @param out notes about this backup
 294      * @param keys keys to mark as clean in the notes for next backup
 295      * @throws IOException
 296      */
 297     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 298             ArrayList&lt;Key&gt; keys)
 299             throws IOException {
 300         // read the old ID set
 301         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 302         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 303 
 304         // persist things that have changed since the last backup
 305         ContentResolver cr = mContext.getContentResolver();
 306         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 307                 null, null, null);
 308         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 309         try {
 310             cursor.moveToPosition(-1);
 311             while(cursor.moveToNext()) {
 312                 final long id = cursor.getLong(ID_INDEX);
 313                 final long updateTime = cursor.getLong(ID_MODIFIED);
 314                 Key key = getKey(Key.FAVORITE, id);
 315                 keys.add(key);
 316                 final String backupKey = keyToBackupKey(key);
 317                 currentIds.add(backupKey);
 318                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 319                     byte[] blob = packFavorite(cursor);
 320                     writeRowToBackup(key, blob, out, data);
 321                 } else {
 322                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 323                 }
 324             }
 325         } finally {
 326             cursor.close();
 327         }
 328         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 329 
 330         // these IDs must have been deleted
 331         savedIds.removeAll(currentIds);
 332         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 333     }
 334 
 335     /**
 336      * Read a favorite from the stream.
 337      *
 338      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 339      *
 340      * @param key identifier for the row
 341      * @param buffer the serialized proto from the stream, may be larger than dataSize
 342      * @param dataSize the size of the proto from the stream
 343      * @param keys keys to mark as clean in the notes for next backup
 344      */
 345     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 346         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 347         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 348                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 349 
 350         if (!mRestoreEnabled) {
 351             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 352             return;
 353         }
 354 
 355         try {
 356             ContentResolver cr = mContext.getContentResolver();
 357             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 358             cr.insert(Favorites.CONTENT_URI, values);
 359         } catch (InvalidProtocolBufferNanoException e) {
 360             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 361         }
 362     }
 363 
 364     /**
 365      * Write all modified screens to the data stream.
 366      *
 367      *
 368      * @param in notes from last backup
 369      * @param data output stream for key/value pairs
 370      * @param out notes about this backup
 371      * @param keys keys to mark as clean in the notes for next backup
 372      * @throws IOException
 373      */
 374     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 375             ArrayList&lt;Key&gt; keys)
 376             throws IOException {
 377         // read the old ID set
 378         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 379         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 380 
 381         // persist things that have changed since the last backup
 382         ContentResolver cr = mContext.getContentResolver();
 383         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 384                 null, null, null);
 385         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 386         try {
 387             cursor.moveToPosition(-1);
 388             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 389             while(cursor.moveToNext()) {
 390                 final long id = cursor.getLong(ID_INDEX);
 391                 final long updateTime = cursor.getLong(ID_MODIFIED);
 392                 Key key = getKey(Key.SCREEN, id);
 393                 keys.add(key);
 394                 final String backupKey = keyToBackupKey(key);
 395                 currentIds.add(backupKey);
 396                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 397                     byte[] blob = packScreen(cursor);
 398                     writeRowToBackup(key, blob, out, data);
 399                 } else {
 400                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 401                 }
 402             }
 403         } finally {
 404             cursor.close();
 405         }
 406         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 407 
 408         // these IDs must have been deleted
 409         savedIds.removeAll(currentIds);
 410         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 411     }
 412 
 413     /**
 414      * Read a screen from the stream.
 415      *
 416      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 417      *
 418      * @param key identifier for the row
 419      * @param buffer the serialized proto from the stream, may be larger than dataSize
 420      * @param dataSize the size of the proto from the stream
 421      * @param keys keys to mark as clean in the notes for next backup
 422      */
 423     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 424         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 425         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 426                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 427 
 428         if (!mRestoreEnabled) {
 429             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 430             return;
 431         }
 432 
 433         try {
 434             ContentResolver cr = mContext.getContentResolver();
 435             ContentValues values = unpackScreen(buffer, 0, dataSize);
 436             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 437 
 438         } catch (InvalidProtocolBufferNanoException e) {
 439             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 440         }
 441     }
 442 
 443     /**
 444      * Write all the static icon resources we need to render placeholders
 445      * for a package that is not installed.
 446      *
 447      * @param in notes from last backup
 448      * @param data output stream for key/value pairs
 449      * @param out notes about this backup
 450      * @param keys keys to mark as clean in the notes for next backup
 451      * @throws IOException
 452      */
 453     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 454             ArrayList&lt;Key&gt; keys) throws IOException {
 455         // persist icons that haven&#x27;t been persisted yet
 456         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 457         if (appState == null) {
 458             dataChanged(); // try again later
 459             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 460             return;
 461         }
 462         final ContentResolver cr = mContext.getContentResolver();
 463         final IconCache iconCache = appState.getIconCache();
 464         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 465 
 466         // read the old ID set
 467         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 468         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 469 
 470         int startRows = out.rows;
 471         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 472         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 473         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 474                 where, null, null);
 475         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 476         try {
 477             cursor.moveToPosition(-1);
 478             while(cursor.moveToNext()) {
 479                 final long id = cursor.getLong(ID_INDEX);
 480                 final String intentDescription = cursor.getString(INTENT_INDEX);
 481                 try {
 482                     Intent intent = Intent.parseUri(intentDescription, 0);
 483                     ComponentName cn = intent.getComponent();
 484                     Key key = null;
 485                     String backupKey = null;
 486                     if (cn != null) {
 487                         key = getKey(Key.ICON, cn.flattenToShortString());
 488                         backupKey = keyToBackupKey(key);
 489                         currentIds.add(backupKey);
 490                     } else {
 491                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 492                     }
 493                     if (savedIds.contains(backupKey)) {
 494                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 495 
 496                         // remember that we already backed this up previously
 497                         keys.add(key);
 498                     } else if (backupKey != null) {
 499                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 500                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 501                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 502                             Bitmap icon = iconCache.getIcon(intent);
 503                             keys.add(key);
 504                             if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {
 505                                 byte[] blob = packIcon(dpi, icon);
 506                                 writeRowToBackup(key, blob, out, data);
 507                             }
 508                         } else {
 509                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 510                             // too many icons for this pass, request another.
 511                             dataChanged();
 512                         }
 513                     }
 514                 } catch (URISyntaxException e) {
 515                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 516                 } catch (IOException e) {
 517                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 518                 }
 519 
 520             }
 521         } finally {
 522             cursor.close();
 523         }
 524         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 525 
 526         // these IDs must have been deleted
 527         savedIds.removeAll(currentIds);
 528         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 529     }
 530 
 531     /**
 532      * Read an icon from the stream.
 533      *
 534      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 535      *
 536      * @param key identifier for the row
 537      * @param buffer the serialized proto from the stream, may be larger than dataSize
 538      * @param dataSize the size of the proto from the stream
 539      * @param keys keys to mark as clean in the notes for next backup
 540      */
 541     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 542         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 543         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 544                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 545         try {
 546             Resource res = unpackIcon(buffer, 0, dataSize);
 547             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 548             if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +
 549                     Base64.encodeToString(res.data, 0, res.data.length,
 550                             Base64.NO_WRAP));
 551             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 552             if (icon == null) {
 553                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 554             }
 555 
 556             if (!mRestoreEnabled) {
 557                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 558                 return;
 559             } else {
 560                 // future site of icon cache mutation
 561             }
 562         } catch (InvalidProtocolBufferNanoException e) {
 563             Log.e(TAG, &quot;failed to decode icon&quot;, e);
 564         }
 565     }
 566 
 567     /**
 568      * Write all the static widget resources we need to render placeholders
 569      * for a package that is not installed.
 570      *
 571      * @param in notes from last backup
 572      * @param data output stream for key/value pairs
 573      * @param out notes about this backup
 574      * @param keys keys to mark as clean in the notes for next backup
 575      * @throws IOException
 576      */
 577     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 578             ArrayList&lt;Key&gt; keys) throws IOException {
 579         // persist static widget info that hasn&#x27;t been persisted yet
 580         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 581         if (appState == null) {
 582             dataChanged(); // try again later
 583             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);
 584             return;
 585         }
 586         final ContentResolver cr = mContext.getContentResolver();
 587         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 588         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 589         final IconCache iconCache = appState.getIconCache();
 590         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 591         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 592         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 593 
 594         // read the old ID set
 595         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 596         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 597 
 598         int startRows = out.rows;
 599         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 600         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 601         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 602                 where, null, null);
 603         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 604         try {
 605             cursor.moveToPosition(-1);
 606             while(cursor.moveToNext()) {
 607                 final long id = cursor.getLong(ID_INDEX);
 608                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 609                 final int spanX = cursor.getInt(SPANX_INDEX);
 610                 final int spanY = cursor.getInt(SPANY_INDEX);
 611                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 612                 Key key = null;
 613                 String backupKey = null;
 614                 if (provider != null) {
 615                     key = getKey(Key.WIDGET, providerName);
 616                     backupKey = keyToBackupKey(key);
 617                     currentIds.add(backupKey);
 618                 } else {
 619                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 620                 }
 621                 if (savedIds.contains(backupKey)) {
 622                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 623 
 624                     // remember that we already backed this up previously
 625                     keys.add(key);
 626                 } else if (backupKey != null) {
 627                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 628                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 629                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 630                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 631                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 632                         byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);
 633                         keys.add(key);
 634                         writeRowToBackup(key, blob, out, data);
 635 
 636                     } else {
 637                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 638                         // too many widgets for this pass, request another.
 639                         dataChanged();
 640                     }
 641                 }
 642             }
 643         } finally {
 644             cursor.close();
 645         }
 646         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 647 
 648         // these IDs must have been deleted
 649         savedIds.removeAll(currentIds);
 650         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 651     }
 652 
 653     /**
 654      * Read a widget from the stream.
 655      *
 656      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 657      *
 658      * @param key identifier for the row
 659      * @param buffer the serialized proto from the stream, may be larger than dataSize
 660      * @param dataSize the size of the proto from the stream
 661      * @param keys keys to mark as clean in the notes for next backup
 662      */
 663     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 664         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 665         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 666                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 667         try {
 668             Widget widget = unpackWidget(buffer, 0, dataSize);
 669             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 670             if (widget.icon.data != null)  {
 671                 Bitmap icon = BitmapFactory
 672                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 673                 if (icon == null) {
 674                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 675                 }
 676             }
 677 
 678             if (!mRestoreEnabled) {
 679                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 680                 return;
 681             } else {
 682                 // future site of widget table mutation
 683             }
 684         } catch (InvalidProtocolBufferNanoException e) {
 685             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 686         }
 687     }
 688 
 689     /** create a new key, with an integer ID.
 690      *
 691      * &lt;P&gt; Keys contain their own checksum instead of using
 692      * the heavy-weight CheckedMessage wrapper.
 693      */
 694     private Key getKey(int type, long id) {
 695         Key key = new Key();
 696         key.type = type;
 697         key.id = id;
 698         key.checksum = checkKey(key);
 699         return key;
 700     }
 701 
 702     /** create a new key for a named object.
 703      *
 704      * &lt;P&gt; Keys contain their own checksum instead of using
 705      * the heavy-weight CheckedMessage wrapper.
 706      */
 707     private Key getKey(int type, String name) {
 708         Key key = new Key();
 709         key.type = type;
 710         key.name = name;
 711         key.checksum = checkKey(key);
 712         return key;
 713     }
 714 
 715     /** keys need to be strings, serialize and encode. */
 716     private String keyToBackupKey(Key key) {
 717         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 718     }
 719 
 720     /** keys need to be strings, decode and parse. */
 721     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 722         try {
 723             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 724             if (key.checksum != checkKey(key)) {
 725                 key = null;
 726                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 727             }
 728             return key;
 729         } catch (InvalidProtocolBufferNanoException e) {
 730             throw new KeyParsingException(e);
 731         } catch (IllegalArgumentException e) {
 732             throw new KeyParsingException(e);
 733         }
 734     }
 735 
 736     private String getKeyName(Key key) {
 737         if (TextUtils.isEmpty(key.name)) {
 738             return Long.toString(key.id);
 739         } else {
 740             return key.name;
 741         }
 742 
 743     }
 744 
 745     private String geKeyType(Key key) {
 746         switch (key.type) {
 747             case Key.FAVORITE:
 748                 return &quot;favorite&quot;;
 749             case Key.SCREEN:
 750                 return &quot;screen&quot;;
 751             case Key.ICON:
 752                 return &quot;icon&quot;;
 753             case Key.WIDGET:
 754                 return &quot;widget&quot;;
 755             default:
 756                 return &quot;anonymous&quot;;
 757         }
 758     }
 759 
 760     /** Compute the checksum over the important bits of a key. */
 761     private long checkKey(Key key) {
 762         CRC32 checksum = new CRC32();
 763         checksum.update(key.type);
 764         checksum.update((int) (key.id &amp; 0xffff));
 765         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 766         if (!TextUtils.isEmpty(key.name)) {
 767             checksum.update(key.name.getBytes());
 768         }
 769         return checksum.getValue();
 770     }
 771 
 772     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 773     private byte[] packFavorite(Cursor c) {
 774         Favorite favorite = new Favorite();
 775         favorite.id = c.getLong(ID_INDEX);
 776         favorite.screen = c.getInt(SCREEN_INDEX);
 777         favorite.container = c.getInt(CONTAINER_INDEX);
 778         favorite.cellX = c.getInt(CELLX_INDEX);
 779         favorite.cellY = c.getInt(CELLY_INDEX);
 780         favorite.spanX = c.getInt(SPANX_INDEX);
 781         favorite.spanY = c.getInt(SPANY_INDEX);
 782         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 783         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 784             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 785             if (!TextUtils.isEmpty(iconPackage)) {
 786                 favorite.iconPackage = iconPackage;
 787             }
 788             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 789             if (!TextUtils.isEmpty(iconResource)) {
 790                 favorite.iconResource = iconResource;
 791             }
 792         }
 793         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 794             byte[] blob = c.getBlob(ICON_INDEX);
 795             if (blob != null &amp;&amp; blob.length &gt; 0) {
 796                 favorite.icon = blob;
 797             }
 798         }
 799         String title = c.getString(TITLE_INDEX);
 800         if (!TextUtils.isEmpty(title)) {
 801             favorite.title = title;
 802         }
 803         String intent = c.getString(INTENT_INDEX);
 804         if (!TextUtils.isEmpty(intent)) {
 805             favorite.intent = intent;
 806         }
 807         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 808         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 809             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 810             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 811             if (!TextUtils.isEmpty(appWidgetProvider)) {
 812                 favorite.appWidgetProvider = appWidgetProvider;
 813             }
 814         }
 815 
 816         return writeCheckedBytes(favorite);
 817     }
 818 
 819     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 820     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 821             throws InvalidProtocolBufferNanoException {
 822         Favorite favorite = new Favorite();
 823         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 824         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 825                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 826         ContentValues values = new ContentValues();
 827         values.put(Favorites._ID, favorite.id);
 828         values.put(Favorites.SCREEN, favorite.screen);
 829         values.put(Favorites.CONTAINER, favorite.container);
 830         values.put(Favorites.CELLX, favorite.cellX);
 831         values.put(Favorites.CELLY, favorite.cellY);
 832         values.put(Favorites.SPANX, favorite.spanX);
 833         values.put(Favorites.SPANY, favorite.spanY);
 834         values.put(Favorites.ICON_TYPE, favorite.iconType);
 835         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 836             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 837             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 838         }
 839         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 840             values.put(Favorites.ICON, favorite.icon);
 841         }
 842         if (!TextUtils.isEmpty(favorite.title)) {
 843             values.put(Favorites.TITLE, favorite.title);
 844         } else {
 845             values.put(Favorites.TITLE, &quot;&quot;);
 846         }
 847         if (!TextUtils.isEmpty(favorite.intent)) {
 848             values.put(Favorites.INTENT, favorite.intent);
 849         }
 850         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 851         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 852             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 853                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 854             }
 855             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 856         }
 857 
 858         // Let LauncherModel know we&#x27;ve been here.
 859         values.put(LauncherSettings.Favorites.RESTORED, 1);
 860 
 861         return values;
 862     }
 863 
 864     /** Serialize a Screen for persistence, including a checksum wrapper. */
 865     private byte[] packScreen(Cursor c) {
 866         Screen screen = new Screen();
 867         screen.id = c.getLong(ID_INDEX);
 868         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 869 
 870         return writeCheckedBytes(screen);
 871     }
 872 
 873     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 874     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 875             throws InvalidProtocolBufferNanoException {
 876         Screen screen = new Screen();
 877         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 878         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 879         ContentValues values = new ContentValues();
 880         values.put(WorkspaceScreens._ID, screen.id);
 881         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 882         return values;
 883     }
 884 
 885     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 886     private byte[] packIcon(int dpi, Bitmap icon) {
 887         Resource res = new Resource();
 888         res.dpi = dpi;
 889         ByteArrayOutputStream os = new ByteArrayOutputStream();
 890         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 891             res.data = os.toByteArray();
 892         }
 893         return writeCheckedBytes(res);
 894     }
 895 
 896     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 897     private Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 898             throws InvalidProtocolBufferNanoException {
 899         Resource res = new Resource();
 900         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 901         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 902         return res;
 903     }
 904 
 905     /** Serialize a widget for persistence, including a checksum wrapper. */
 906     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 907             ComponentName provider) {
 908         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 909         Widget widget = new Widget();
 910         widget.provider = provider.flattenToShortString();
 911         widget.label = info.label;
 912         widget.configure = info.configure != null;
 913         if (info.icon != 0) {
 914             widget.icon = new Resource();
 915             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 916             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 917             ByteArrayOutputStream os = new ByteArrayOutputStream();
 918             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 919                 widget.icon.data = os.toByteArray();
 920                 widget.icon.dpi = dpi;
 921             }
 922         }
 923         if (info.previewImage != 0) {
 924             widget.preview = new Resource();
 925             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 926             ByteArrayOutputStream os = new ByteArrayOutputStream();
 927             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 928                 widget.preview.data = os.toByteArray();
 929                 widget.preview.dpi = dpi;
 930             }
 931         }
 932         return writeCheckedBytes(widget);
 933     }
 934 
 935     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 936     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 937             throws InvalidProtocolBufferNanoException {
 938         Widget widget = new Widget();
 939         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 940         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 941         return widget;
 942     }
 943 
 944     /**
 945      * Read the old journal from the input file.
 946      *
 947      * In the event of any error, just pretend we didn&#x27;t have a journal,
 948      * in that case, do a full backup.
 949      *
 950      * @param oldState the read-0only file descriptor pointing to the old journal
 951      * @return a Journal protocol buffer
 952      */
 953     private Journal readJournal(ParcelFileDescriptor oldState) {
 954         Journal journal = new Journal();
 955         if (oldState == null) {
 956             return journal;
 957         }
 958         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 959         try {
 960             int availableBytes = inStream.available();
 961             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 962             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 963                 byte[] buffer = new byte[availableBytes];
 964                 int bytesRead = 0;
 965                 boolean valid = false;
 966                 InvalidProtocolBufferNanoException lastProtoException = null;
 967                 while (availableBytes &gt; 0) {
 968                     try {
 969                         // OMG what are you doing? This is crazy inefficient!
 970                         // If we read a byte that is not ours, we will cause trouble: b/12491813
 971                         // However, we don&#x27;t know how many bytes to expect (oops).
 972                         // So we have to step through *slowly*, watching for the end.
 973                         int result = inStream.read(buffer, bytesRead, 1);
 974                         if (result &gt; 0) {
 975                             availableBytes -= result;
 976                             bytesRead += result;
 977                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 978                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 979                             }
 980                         } else {
 981                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 982                             // stop reading and see what there is to parse
 983                             availableBytes = 0;
 984                         }
 985                     } catch (IOException e) {
 986                         buffer = null;
 987                         availableBytes = 0;
 988                     }
 989 
 990                     // check the buffer to see if we have a valid journal
 991                     try {
 992                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
 993                         // if we are here, then we have read a valid, checksum-verified journal
 994                         valid = true;
 995                         availableBytes = 0;
 996                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
 997                     } catch (InvalidProtocolBufferNanoException e) {
 998                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
 999                         lastProtoException = e;
1000                         journal.clear();
1001                     }
1002                 }
1003                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1004                 if (!valid) {
1005                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1006                 }
1007             }
1008         } catch (IOException e) {
1009             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1010         } finally {
1011             try {
1012                 inStream.close();
1013             } catch (IOException e) {
1014                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1015             }
1016         }
1017         return journal;
1018     }
1019 
1020     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1021             BackupDataOutput data) throws IOException {
1022         String backupKey = keyToBackupKey(key);
1023         data.writeEntityHeader(backupKey, blob.length);
1024         data.writeEntityData(blob, blob.length);
1025         out.rows++;
1026         out.bytes += blob.length;
1027         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1028                 getKeyName(key) + &quot;/&quot; + blob.length);
1029         if(DEBUG_PAYLOAD) {
1030             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1031             final int chunkSize = 1024;
1032             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1033                 int end = offset + chunkSize;
1034                 end = Math.min(end, encoded.length());
1035                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1036             }
1037         }
1038     }
1039 
1040     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1041         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1042         for(int i = 0; i &lt; in.key.length; i++) {
1043             Key key = in.key[i];
1044             if (key.type == type) {
1045                 savedIds.add(keyToBackupKey(key));
1046             }
1047         }
1048         return savedIds;
1049     }
1050 
1051     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1052             throws IOException {
1053         int rows = 0;
1054         for(String deleted: deletedIds) {
1055             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1056             data.writeEntityHeader(deleted, -1);
1057             rows++;
1058         }
1059         return rows;
1060     }
1061 
1062     /**
1063      * Write the new journal to the output file.
1064      *
1065      * In the event of any error, just pretend we didn&#x27;t have a journal,
1066      * in that case, do a full backup.
1067 
1068      * @param newState the write-only file descriptor pointing to the new journal
1069      * @param journal a Journal protocol buffer
1070      */
1071     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1072         FileOutputStream outStream = null;
1073         try {
1074             outStream = new FileOutputStream(newState.getFileDescriptor());
1075             final byte[] journalBytes = writeCheckedBytes(journal);
1076             outStream.write(journalBytes);
1077             outStream.close();
1078             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1079         } catch (IOException e) {
1080             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1081         }
1082     }
1083 
1084     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1085     private byte[] writeCheckedBytes(MessageNano proto) {
1086         CheckedMessage wrapper = new CheckedMessage();
1087         wrapper.payload = MessageNano.toByteArray(proto);
1088         CRC32 checksum = new CRC32();
1089         checksum.update(wrapper.payload);
1090         wrapper.checksum = checksum.getValue();
1091         return MessageNano.toByteArray(wrapper);
1092     }
1093 
1094     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1095     private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1096             throws InvalidProtocolBufferNanoException {
1097         CheckedMessage wrapper = new CheckedMessage();
1098         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1099         CRC32 checksum = new CRC32();
1100         checksum.update(wrapper.payload);
1101         if (wrapper.checksum != checksum.getValue()) {
1102             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1103         }
1104         return wrapper.payload;
1105     }
1106 
1107     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1108         if (mWidgetMap == null) {
1109             List&lt;AppWidgetProviderInfo&gt; widgets =
1110                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1111             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1112             for (AppWidgetProviderInfo info : widgets) {
1113                 mWidgetMap.put(info.provider, info);
1114             }
1115         }
1116         return mWidgetMap.get(component);
1117     }
1118 
1119     private class KeyParsingException extends Throwable {
1120         private KeyParsingException(Throwable cause) {
1121             super(cause);
1122         }
1123 
1124         public KeyParsingException(String reason) {
1125             super(reason);
1126         }
1127     }
1128 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ComponentName;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.database.Cursor;
  30 import android.graphics.Bitmap;
  31 import android.graphics.BitmapFactory;
  32 import android.graphics.drawable.Drawable;
  33 import android.os.ParcelFileDescriptor;
  34 import android.text.TextUtils;
  35 import android.util.Base64;
  36 import android.util.Log;
  37 import com.android.launcher3.LauncherSettings.Favorites;
  38 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  39 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  40 import com.android.launcher3.backup.BackupProtos.Favorite;
  41 import com.android.launcher3.backup.BackupProtos.Journal;
  42 import com.android.launcher3.backup.BackupProtos.Key;
  43 import com.android.launcher3.backup.BackupProtos.Resource;
  44 import com.android.launcher3.backup.BackupProtos.Screen;
  45 import com.android.launcher3.backup.BackupProtos.Widget;
  46 import com.android.launcher3.backup.BackupProtos;
  47 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  48 import com.google.protobuf.nano.MessageNano;
  49 import java.io.ByteArrayOutputStream;
  50 import java.io.FileInputStream;
  51 import java.io.FileOutputStream;
  52 import java.io.IOException;
  53 import java.net.URISyntaxException;
  54 import java.util.ArrayList;
  55 import java.util.HashMap;
  56 import java.util.HashSet;
  57 import java.util.List;
  58 import java.util.Set;
  59 import java.util.zip.CRC32;
  60 
  61 
  62 /**
  63  * Persist the launcher home state across calamities.
  64  */
  65 public class LauncherBackupHelper implements BackupHelper {
  66     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  67 
  68     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  69 
  70     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  71 
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /**
  77      * icons are large, dribble them out
  78      */
  79     private static final int MAX_ICONS_PER_PASS = 10;
  80 
  81     /**
  82      * widgets contain previews, which are very large, dribble them out
  83      */
  84     private static final int MAX_WIDGETS_PER_PASS = 5;
  85 
  86     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  87 
  88     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  89 
  90     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  91 
  92     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  93             android.graphics.Bitmap.CompressFormat.PNG;
  94 
  95     private static BackupManager sBackupManager;
  96 
  97     private static final String[] FAVORITE_PROJECTION = new java.lang.String[]{ Favorites._ID, // 0
  98     Favorites.MODIFIED, // 1
  99     Favorites.INTENT, // 2
 100     Favorites.APPWIDGET_PROVIDER// 3
 101     , Favorites.APPWIDGET_ID// 4
 102     , Favorites.CELLX, // 5
 103     Favorites.CELLY, // 6
 104     Favorites.CONTAINER, // 7
 105     Favorites.ICON, // 8
 106     Favorites.ICON_PACKAGE// 9
 107     , Favorites.ICON_RESOURCE// 10
 108     , Favorites.ICON_TYPE, // 11
 109     Favorites.ITEM_TYPE, // 12
 110     Favorites.SCREEN, // 13
 111     Favorites.SPANX, // 14
 112     Favorites.SPANY, // 15
 113     Favorites.TITLE// 16
 114      };
 115 
 116     private static final int ID_INDEX = 0;
 117 
 118     private static final int ID_MODIFIED = 1;
 119 
 120     private static final int INTENT_INDEX = 2;
 121 
 122     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 123 
 124     private static final int APPWIDGET_ID_INDEX = 4;
 125 
 126     private static final int CELLX_INDEX = 5;
 127 
 128     private static final int CELLY_INDEX = 6;
 129 
 130     private static final int CONTAINER_INDEX = 7;
 131 
 132     private static final int ICON_INDEX = 8;
 133 
 134     private static final int ICON_PACKAGE_INDEX = 9;
 135 
 136     private static final int ICON_RESOURCE_INDEX = 10;
 137 
 138     private static final int ICON_TYPE_INDEX = 11;
 139 
 140     private static final int ITEM_TYPE_INDEX = 12;
 141 
 142     private static final int SCREEN_INDEX = 13;
 143 
 144     private static final int SPANX_INDEX = 14;
 145 
 146     private static final int SPANY_INDEX = 15;
 147 
 148     private static final int TITLE_INDEX = 16;
 149 
 150     private static final String[] SCREEN_PROJECTION = new java.lang.String[]{ WorkspaceScreens._ID, // 0
 151     WorkspaceScreens.MODIFIED// 1
 152     , WorkspaceScreens.SCREEN_RANK// 2
 153      };
 154 
 155     private static final int SCREEN_RANK_INDEX = 2;
 156 
 157     private final Context mContext;
 158 
 159     private final boolean mRestoreEnabled;
 160 
 161     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 162 
 163     private ArrayList&lt;Key&gt; mKeys;
 164 
 165     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 166         mContext = context;
 167         mRestoreEnabled = restoreEnabled;
 168     }
 169 
 170     private void dataChanged() {
 171         if (sBackupManager == null) {
 172             sBackupManager = new BackupManager(mContext);
 173         }
 174         sBackupManager.dataChanged();
 175     }
 176 
 177     /**
 178      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 179      *
 180      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 181      *
 182      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 183      *
 184      * @param oldState notes from the last backup
 185      * @param data incremental key/value pairs to persist off-device
 186      * @param newState notes for the next backup
 187      * @throws IOException
 188      */
 189     @Override
<abbr title=" 190     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) {"> 190     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor 🔵</abbr>
 191         if (VERBOSE) {
 192             Log.v(TAG, &quot;onBackup&quot;);
 193         }
 194         Journal in = readJournal(oldState);
 195         Journal out = new Journal();
 196         long lastBackupTime = in.t;
 197         out.t = System.currentTimeMillis();
 198         out.rows = 0;
 199         out.bytes = 0;
 200         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 201         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 202         try {
 203             backupFavorites(in, data, out, keys);
 204             backupScreens(in, data, out, keys);
 205             backupIcons(in, data, out, keys);
 206             backupWidgets(in, data, out, keys);
 207         } catch (IOException e) {
 208             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 209         }
 210         out.key = keys.toArray(
 211 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 212 BackupProtos.Key.emptyArray()</span>
 213 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 214 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 214 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 215 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 216 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 217 new BackupProtos.Key[keys.size()]</span>
 218 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 219         );
 220         writeJournal(newState, out);
 221         Log.v(TAG, (((&quot;onBackup: wrote &quot; + out.bytes) + &quot;b in &quot;) + out.rows) + &quot; rows.&quot;);
 222     }
 223 
 224     /**
 225      * Restore launcher configuration from the restored data stream.
 226      *
 227      * &lt;P&gt;Keys may arrive in any order.
 228      *
 229      * @param data the key/value pair from the server
 230      */
 231     @Override
 232     public void restoreEntity(BackupDataInputStream data) {
 233         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 234         if (mKeys == null) {
 235             mKeys = new ArrayList&lt;Key&gt;();
 236         }
 237         byte[] buffer = new byte[512];
 238             String backupKey = data.getKey();
 239             int dataSize = data.size();
 240             if (buffer.length &lt; dataSize) {
 241                 buffer = new byte[dataSize];
 242             }
 243             Key key = null;
 244         int bytesRead = 0;
 245         try {
 246             bytesRead = data.read(buffer, 0, dataSize);
 247             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 248         } catch (IOException e) {
 249             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 250         }
 251         try {
 252             key = backupKeyToKey(backupKey);
 253             mKeys.add(key);
 254             switch (key.type) {
 255                 case Key.FAVORITE:
 256                     restoreFavorite(key, buffer, dataSize, mKeys);
 257                     break;
 258 
 259                 case Key.SCREEN:
 260                     restoreScreen(key, buffer, dataSize, mKeys);
 261                     break;
 262 
 263                 case Key.ICON:
 264                     restoreIcon(key, buffer, dataSize, mKeys);
 265                     break;
 266 
 267                 case Key.WIDGET:
 268                     restoreWidget(key, buffer, dataSize, mKeys);
 269                     break;
 270 
 271                 default:
 272                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 273                     break;
 274             }
 275         } catch (KeyParsingException e) {
 276             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 277         }
 278 
 279     }
 280 
 281     /**
 282      * Record the restore state for the next backup.
 283      *
 284      * @param newState notes about the backup state after restore.
 285      */
 286     @Override
 287     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 288         // clear the output journal time, to force a full backup to
 289         // will catch any changes the restore process might have made
 290         Journal out = new Journal();
 291         out.t = 0;
 292         out.key = mKeys.toArray(
 293 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 294 BackupProtos.Key.emptyArray()</span>
 295 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 296 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 296 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 297 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 298 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 299 new BackupProtos.Key[mKeys.size()]</span>
 300 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 301         );
 302         writeJournal(newState, out);
 303         Log.v(TAG, (&quot;onRestore: read &quot; + mKeys.size()) + &quot; rows&quot;);
 304         mKeys.clear();
 305     }
 306 
 307     /**
 308      * Write all modified favorites to the data stream.
 309      *
 310      *
 311      * @param in notes from last backup
 312      * @param data output stream for key/value pairs
 313      * @param out notes about this backup
 314      * @param keys keys to mark as clean in the notes for next backup
 315      * @throws IOException
 316      */
 317     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 318             ArrayList&lt;Key&gt; keys)
 319             throws IOException {
 320         // read the old ID set
 321         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 322         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 323 
 324         // persist things that have changed since the last backup
 325         ContentResolver cr = mContext.getContentResolver();
 326         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 327                 null, null, null);
 328         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 329         try {
 330             cursor.moveToPosition(-1);
 331             while(cursor.moveToNext()) {
 332                 final long id = cursor.getLong(ID_INDEX);
 333                 final long updateTime = cursor.getLong(ID_MODIFIED);
 334                 Key key = getKey(Key.FAVORITE, id);
 335                 keys.add(key);
 336                 final String backupKey = keyToBackupKey(key);
 337                 currentIds.add(backupKey);
 338                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 339                     byte[] blob = packFavorite(cursor);
 340                     writeRowToBackup(key, blob, out, data);
 341                 } else {
 342                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 343                 }
 344             }
 345         } finally {
 346             cursor.close();
 347         }
 348         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 349 
 350         // these IDs must have been deleted
 351         savedIds.removeAll(currentIds);
 352         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 353     }
 354 
 355     /**
 356      * Read a favorite from the stream.
 357      *
 358      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 359      *
 360      * @param key identifier for the row
 361      * @param buffer the serialized proto from the stream, may be larger than dataSize
 362      * @param dataSize the size of the proto from the stream
 363      * @param keys keys to mark as clean in the notes for next backup
 364      */
 365     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 366         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 367         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 368                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 369 
 370         if (!mRestoreEnabled) {
 371             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 372             return;
 373         }
 374 
 375         try {
 376             ContentResolver cr = mContext.getContentResolver();
 377             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 378             cr.insert(Favorites.CONTENT_URI, values);
 379         } catch (InvalidProtocolBufferNanoException e) {
 380             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 381         }
 382     }
 383 
 384     /**
 385      * Write all modified screens to the data stream.
 386      *
 387      *
 388      * @param in notes from last backup
 389      * @param data output stream for key/value pairs
 390      * @param out notes about this backup
 391      * @param keys keys to mark as clean in the notes for next backup
 392      * @throws IOException
 393      */
 394     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 395             ArrayList&lt;Key&gt; keys)
 396             throws IOException {
 397         // read the old ID set
 398         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 399         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 400 
 401         // persist things that have changed since the last backup
 402         ContentResolver cr = mContext.getContentResolver();
 403         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 404                 null, null, null);
 405         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 406         try {
 407             cursor.moveToPosition(-1);
 408             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 409             while(cursor.moveToNext()) {
 410                 final long id = cursor.getLong(ID_INDEX);
 411                 final long updateTime = cursor.getLong(ID_MODIFIED);
 412                 Key key = getKey(Key.SCREEN, id);
 413                 keys.add(key);
 414                 final String backupKey = keyToBackupKey(key);
 415                 currentIds.add(backupKey);
 416                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 417                     byte[] blob = packScreen(cursor);
 418                     writeRowToBackup(key, blob, out, data);
 419                 } else {
 420                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 421                 }
 422             }
 423         } finally {
 424             cursor.close();
 425         }
 426         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 427 
 428         // these IDs must have been deleted
 429         savedIds.removeAll(currentIds);
 430         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 431     }
 432 
 433     /**
 434      * Read a screen from the stream.
 435      *
 436      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 437      *
 438      * @param key identifier for the row
 439      * @param buffer the serialized proto from the stream, may be larger than dataSize
 440      * @param dataSize the size of the proto from the stream
 441      * @param keys keys to mark as clean in the notes for next backup
 442      */
 443     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 444         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 445         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 446                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 447 
 448         if (!mRestoreEnabled) {
 449             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 450             return;
 451         }
 452 
 453         try {
 454             ContentResolver cr = mContext.getContentResolver();
 455             ContentValues values = unpackScreen(buffer, 0, dataSize);
 456             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 457 
 458         } catch (InvalidProtocolBufferNanoException e) {
 459             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 460         }
 461     }
 462 
 463     /**
 464      * Write all the static icon resources we need to render placeholders
 465      * for a package that is not installed.
 466      *
 467      * @param in notes from last backup
 468      * @param data output stream for key/value pairs
 469      * @param out notes about this backup
 470      * @param keys keys to mark as clean in the notes for next backup
 471      * @throws IOException
 472      */
 473     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 474             ArrayList&lt;Key&gt; keys) throws IOException {
 475         // persist icons that haven&#x27;t been persisted yet
 476         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 477         if (appState == null) {
 478             dataChanged(); // try again later
 479             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 480             return;
 481         }
 482         final ContentResolver cr = mContext.getContentResolver();
 483         final IconCache iconCache = appState.getIconCache();
 484         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 485 
 486         // read the old ID set
 487         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 488         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 489 
 490         int startRows = out.rows;
 491         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 492         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 493         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 494                 where, null, null);
 495         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 496         try {
 497             cursor.moveToPosition(-1);
 498             while(cursor.moveToNext()) {
 499                 final long id = cursor.getLong(ID_INDEX);
 500                 final String intentDescription = cursor.getString(INTENT_INDEX);
 501                 try {
 502                     Intent intent = Intent.parseUri(intentDescription, 0);
 503                     ComponentName cn = intent.getComponent();
 504                     Key key = null;
 505                     String backupKey = null;
 506                     if (cn != null) {
 507                         key = getKey(Key.ICON, cn.flattenToShortString());
 508                         backupKey = keyToBackupKey(key);
 509                         currentIds.add(backupKey);
 510                     } else {
 511                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 512                     }
 513                     if (savedIds.contains(backupKey)) {
 514                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 515 
 516                         // remember that we already backed this up previously
 517                         keys.add(key);
 518                     } else if (backupKey != null) {
 519                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 520                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 521                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 522                             Bitmap icon = iconCache.getIcon(intent);
 523                             keys.add(key);
 524                             if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {
 525                                 byte[] blob = packIcon(dpi, icon);
 526                                 writeRowToBackup(key, blob, out, data);
 527                             }
 528                         } else {
 529                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 530                             // too many icons for this pass, request another.
 531                             dataChanged();
 532                         }
 533                     }
 534                 } catch (URISyntaxException e) {
 535                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 536                 } catch (IOException e) {
 537                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 538                 }
 539 
 540             }
 541         } finally {
 542             cursor.close();
 543         }
 544         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 545 
 546         // these IDs must have been deleted
 547         savedIds.removeAll(currentIds);
 548         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 549     }
 550 
 551     /**
 552      * Read an icon from the stream.
 553      *
 554      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 555      *
 556      * @param key identifier for the row
 557      * @param buffer the serialized proto from the stream, may be larger than dataSize
 558      * @param dataSize the size of the proto from the stream
 559      * @param keys keys to mark as clean in the notes for next backup
 560      */
 561     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 562         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 563         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 564                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 565         try {
 566             Resource res = unpackIcon(buffer, 0, dataSize);
 567             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 568             if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +
 569                     Base64.encodeToString(res.data, 0, res.data.length,
 570                             Base64.NO_WRAP));
 571             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 572             if (icon == null) {
 573                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 574             }
 575 
 576             if (!mRestoreEnabled) {
 577                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 578                 return;
 579             } else {
 580                 // future site of icon cache mutation
 581             }
 582         } catch (InvalidProtocolBufferNanoException e) {
 583             Log.e(TAG, &quot;failed to decode icon&quot;, e);
 584         }
 585     }
 586 
 587     /**
 588      * Write all the static widget resources we need to render placeholders
 589      * for a package that is not installed.
 590      *
 591      * @param in notes from last backup
 592      * @param data output stream for key/value pairs
 593      * @param out notes about this backup
 594      * @param keys keys to mark as clean in the notes for next backup
 595      * @throws IOException
 596      */
 597     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 598             ArrayList&lt;Key&gt; keys) throws IOException {
 599         // persist static widget info that hasn&#x27;t been persisted yet
 600         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 601         if (appState == null) {
 602             dataChanged(); // try again later
 603             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);
 604             return;
 605         }
 606         final ContentResolver cr = mContext.getContentResolver();
 607         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 608         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 609         final IconCache iconCache = appState.getIconCache();
 610         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 611         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 612         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 613 
 614         // read the old ID set
 615         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 616         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 617 
 618         int startRows = out.rows;
 619         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 620         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 621         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 622                 where, null, null);
 623         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 624         try {
 625             cursor.moveToPosition(-1);
 626             while(cursor.moveToNext()) {
 627                 final long id = cursor.getLong(ID_INDEX);
 628                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 629                 final int spanX = cursor.getInt(SPANX_INDEX);
 630                 final int spanY = cursor.getInt(SPANY_INDEX);
 631                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 632                 Key key = null;
 633                 String backupKey = null;
 634                 if (provider != null) {
 635                     key = getKey(Key.WIDGET, providerName);
 636                     backupKey = keyToBackupKey(key);
 637                     currentIds.add(backupKey);
 638                 } else {
 639                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 640                 }
 641                 if (savedIds.contains(backupKey)) {
 642                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 643 
 644                     // remember that we already backed this up previously
 645                     keys.add(key);
 646                 } else if (backupKey != null) {
 647                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 648                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 649                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 650                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 651                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 652                         byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);
 653                         keys.add(key);
 654                         writeRowToBackup(key, blob, out, data);
 655 
 656                     } else {
 657                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 658                         // too many widgets for this pass, request another.
 659                         dataChanged();
 660                     }
 661                 }
 662             }
 663         } finally {
 664             cursor.close();
 665         }
 666         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 667 
 668         // these IDs must have been deleted
 669         savedIds.removeAll(currentIds);
 670         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 671     }
 672 
 673     /**
 674      * Read a widget from the stream.
 675      *
 676      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 677      *
 678      * @param key identifier for the row
 679      * @param buffer the serialized proto from the stream, may be larger than dataSize
 680      * @param dataSize the size of the proto from the stream
 681      * @param keys keys to mark as clean in the notes for next backup
 682      */
 683     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 684         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 685         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 686                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 687         try {
 688             Widget widget = unpackWidget(buffer, 0, dataSize);
 689             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 690             if (widget.icon.data != null)  {
 691                 Bitmap icon = BitmapFactory
 692                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 693                 if (icon == null) {
 694                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 695                 }
 696             }
 697 
 698             if (!mRestoreEnabled) {
 699                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 700                 return;
 701             } else {
 702                 // future site of widget table mutation
 703             }
 704         } catch (InvalidProtocolBufferNanoException e) {
 705             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 706         }
 707     }
 708 
 709     /** create a new key, with an integer ID.
 710      *
 711      * &lt;P&gt; Keys contain their own checksum instead of using
 712      * the heavy-weight CheckedMessage wrapper.
 713      */
 714     private Key getKey(int type, long id) {
 715         Key key = new Key();
 716         key.type = type;
 717         key.id = id;
 718         key.checksum = checkKey(key);
 719         return key;
 720     }
 721 
 722     /** create a new key for a named object.
 723      *
 724      * &lt;P&gt; Keys contain their own checksum instead of using
 725      * the heavy-weight CheckedMessage wrapper.
 726      */
 727     private Key getKey(int type, String name) {
 728         Key key = new Key();
 729         key.type = type;
 730         key.name = name;
 731         key.checksum = checkKey(key);
 732         return key;
 733     }
 734 
 735     /** keys need to be strings, serialize and encode. */
 736     private String keyToBackupKey(Key key) {
 737         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 738     }
 739 
 740     /** keys need to be strings, decode and parse. */
 741     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 742         try {
 743             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 744             if (key.checksum != checkKey(key)) {
 745                 key = null;
 746                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 747             }
 748             return key;
 749         } catch (InvalidProtocolBufferNanoException e) {
 750             throw new KeyParsingException(e);
 751         } catch (IllegalArgumentException e) {
 752             throw new KeyParsingException(e);
 753         }
 754     }
 755 
 756     private String getKeyName(Key key) {
 757         if (TextUtils.isEmpty(key.name)) {
 758             return Long.toString(key.id);
 759         } else {
 760             return key.name;
 761         }
 762 
 763     }
 764 
 765     private String geKeyType(Key key) {
 766         switch (key.type) {
 767             case Key.FAVORITE:
 768                 return &quot;favorite&quot;;
 769             case Key.SCREEN:
 770                 return &quot;screen&quot;;
 771             case Key.ICON:
 772                 return &quot;icon&quot;;
 773             case Key.WIDGET:
 774                 return &quot;widget&quot;;
 775             default:
 776                 return &quot;anonymous&quot;;
 777         }
 778     }
 779 
 780     /** Compute the checksum over the important bits of a key. */
 781     private long checkKey(Key key) {
 782         CRC32 checksum = new CRC32();
 783         checksum.update(key.type);
 784         checksum.update((int) (key.id &amp; 0xffff));
 785         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 786         if (!TextUtils.isEmpty(key.name)) {
 787             checksum.update(key.name.getBytes());
 788         }
 789         return checksum.getValue();
 790     }
 791 
 792     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 793     private byte[] packFavorite(Cursor c) {
 794         Favorite favorite = new Favorite();
 795         favorite.id = c.getLong(ID_INDEX);
 796         favorite.screen = c.getInt(SCREEN_INDEX);
 797         favorite.container = c.getInt(CONTAINER_INDEX);
 798         favorite.cellX = c.getInt(CELLX_INDEX);
 799         favorite.cellY = c.getInt(CELLY_INDEX);
 800         favorite.spanX = c.getInt(SPANX_INDEX);
 801         favorite.spanY = c.getInt(SPANY_INDEX);
 802         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 803         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 804             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 805             if (!TextUtils.isEmpty(iconPackage)) {
 806                 favorite.iconPackage = iconPackage;
 807             }
 808             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 809             if (!TextUtils.isEmpty(iconResource)) {
 810                 favorite.iconResource = iconResource;
 811             }
 812         }
 813         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 814             byte[] blob = c.getBlob(ICON_INDEX);
 815             if (blob != null &amp;&amp; blob.length &gt; 0) {
 816                 favorite.icon = blob;
 817             }
 818         }
 819         String title = c.getString(TITLE_INDEX);
 820         if (!TextUtils.isEmpty(title)) {
 821             favorite.title = title;
 822         }
 823         String intent = c.getString(INTENT_INDEX);
 824         if (!TextUtils.isEmpty(intent)) {
 825             favorite.intent = intent;
 826         }
 827         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 828         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 829             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 830             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 831             if (!TextUtils.isEmpty(appWidgetProvider)) {
 832                 favorite.appWidgetProvider = appWidgetProvider;
 833             }
 834         }
 835 
 836         return writeCheckedBytes(favorite);
 837     }
 838 
 839     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 840     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 841             throws InvalidProtocolBufferNanoException {
 842         Favorite favorite = new Favorite();
 843         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 844         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 845                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 846         ContentValues values = new ContentValues();
 847         values.put(Favorites._ID, favorite.id);
 848         values.put(Favorites.SCREEN, favorite.screen);
 849         values.put(Favorites.CONTAINER, favorite.container);
 850         values.put(Favorites.CELLX, favorite.cellX);
 851         values.put(Favorites.CELLY, favorite.cellY);
 852         values.put(Favorites.SPANX, favorite.spanX);
 853         values.put(Favorites.SPANY, favorite.spanY);
 854         values.put(Favorites.ICON_TYPE, favorite.iconType);
 855         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 856             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 857             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 858         }
 859         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 860             values.put(Favorites.ICON, favorite.icon);
 861         }
 862         if (!TextUtils.isEmpty(favorite.title)) {
 863             values.put(Favorites.TITLE, favorite.title);
 864         } else {
 865             values.put(Favorites.TITLE, &quot;&quot;);
 866         }
 867         if (!TextUtils.isEmpty(favorite.intent)) {
 868             values.put(Favorites.INTENT, favorite.intent);
 869         }
 870         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 871         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 872             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 873                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 874             }
 875             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 876         }
 877 
 878         // Let LauncherModel know we&#x27;ve been here.
 879         values.put(LauncherSettings.Favorites.RESTORED, 1);
 880 
 881         return values;
 882     }
 883 
 884     /** Serialize a Screen for persistence, including a checksum wrapper. */
 885     private byte[] packScreen(Cursor c) {
 886         Screen screen = new Screen();
 887         screen.id = c.getLong(ID_INDEX);
 888         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 889 
 890         return writeCheckedBytes(screen);
 891     }
 892 
 893     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 894     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 895             throws InvalidProtocolBufferNanoException {
 896         Screen screen = new Screen();
 897         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 898         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 899         ContentValues values = new ContentValues();
 900         values.put(WorkspaceScreens._ID, screen.id);
 901         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 902         return values;
 903     }
 904 
 905     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 906     private byte[] packIcon(int dpi, Bitmap icon) {
 907         Resource res = new Resource();
 908         res.dpi = dpi;
 909         ByteArrayOutputStream os = new ByteArrayOutputStream();
 910         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 911             res.data = os.toByteArray();
 912         }
 913         return writeCheckedBytes(res);
 914     }
 915 
 916     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 917     private Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 918             throws InvalidProtocolBufferNanoException {
 919         Resource res = new Resource();
 920         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 921         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 922         return res;
 923     }
 924 
 925     /** Serialize a widget for persistence, including a checksum wrapper. */
 926     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 927             ComponentName provider) {
 928         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 929         Widget widget = new Widget();
 930         widget.provider = provider.flattenToShortString();
 931         widget.label = info.label;
 932         widget.configure = info.configure != null;
 933         if (info.icon != 0) {
 934             widget.icon = new Resource();
 935             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 936             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 937             ByteArrayOutputStream os = new ByteArrayOutputStream();
 938             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 939                 widget.icon.data = os.toByteArray();
 940                 widget.icon.dpi = dpi;
 941             }
 942         }
 943         if (info.previewImage != 0) {
 944             widget.preview = new Resource();
 945             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 946             ByteArrayOutputStream os = new ByteArrayOutputStream();
 947             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 948                 widget.preview.data = os.toByteArray();
 949                 widget.preview.dpi = dpi;
 950             }
 951         }
 952         return writeCheckedBytes(widget);
 953     }
 954 
 955     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 956     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 957             throws InvalidProtocolBufferNanoException {
 958         Widget widget = new Widget();
 959         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 960         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 961         return widget;
 962     }
 963 
 964     /**
 965      * Read the old journal from the input file.
 966      *
 967      * In the event of any error, just pretend we didn&#x27;t have a journal,
 968      * in that case, do a full backup.
 969      *
 970      * @param oldState the read-0only file descriptor pointing to the old journal
 971      * @return a Journal protocol buffer
 972      */
 973     private Journal readJournal(ParcelFileDescriptor oldState) {
 974         Journal journal = new Journal();
 975         if (oldState == null) {
 976             return journal;
 977         }
 978         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 979         try {
 980             int availableBytes = inStream.available();
 981             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 982             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 983                 byte[] buffer = new byte[availableBytes];
 984                 int bytesRead = 0;
 985                 boolean valid = false;
 986                 InvalidProtocolBufferNanoException lastProtoException = null;
 987                 while (availableBytes &gt; 0) {
 988                     try {
 989                         // OMG what are you doing? This is crazy inefficient!
 990                         // If we read a byte that is not ours, we will cause trouble: b/12491813
 991                         // However, we don&#x27;t know how many bytes to expect (oops).
 992                         // So we have to step through *slowly*, watching for the end.
 993                         int result = inStream.read(buffer, bytesRead, 1);
 994                         if (result &gt; 0) {
 995                             availableBytes -= result;
 996                             bytesRead += result;
 997                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 998                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 999                             }
1000                         } else {
1001                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1002                             // stop reading and see what there is to parse
1003                             availableBytes = 0;
1004                         }
1005                     } catch (IOException e) {
1006                         buffer = null;
1007                         availableBytes = 0;
1008                     }
1009 
1010                     // check the buffer to see if we have a valid journal
1011                     try {
1012                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1013                         // if we are here, then we have read a valid, checksum-verified journal
1014                         valid = true;
1015                         availableBytes = 0;
1016                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1017                     } catch (InvalidProtocolBufferNanoException e) {
1018                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1019                         lastProtoException = e;
1020                         journal.clear();
1021                     }
1022                 }
1023                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1024                 if (!valid) {
1025                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1026                 }
1027             }
1028         } catch (IOException e) {
1029             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1030         } finally {
1031             try {
1032                 inStream.close();
1033             } catch (IOException e) {
1034                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1035             }
1036         }
1037         return journal;
1038     }
1039 
1040     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1041             BackupDataOutput data) throws IOException {
1042         String backupKey = keyToBackupKey(key);
1043         data.writeEntityHeader(backupKey, blob.length);
1044         data.writeEntityData(blob, blob.length);
1045         out.rows++;
1046         out.bytes += blob.length;
1047         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1048                 getKeyName(key) + &quot;/&quot; + blob.length);
1049         if(DEBUG_PAYLOAD) {
1050             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1051             final int chunkSize = 1024;
1052             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1053                 int end = offset + chunkSize;
1054                 end = Math.min(end, encoded.length());
1055                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1056             }
1057         }
1058     }
1059 
1060     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1061         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1062         for(int i = 0; i &lt; in.key.length; i++) {
1063             Key key = in.key[i];
1064             if (key.type == type) {
1065                 savedIds.add(keyToBackupKey(key));
1066             }
1067         }
1068         return savedIds;
1069     }
1070 
1071     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1072             throws IOException {
1073         int rows = 0;
1074         for(String deleted: deletedIds) {
1075             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1076             data.writeEntityHeader(deleted, -1);
1077             rows++;
1078         }
1079         return rows;
1080     }
1081 
1082     /**
1083      * Write the new journal to the output file.
1084      *
1085      * In the event of any error, just pretend we didn&#x27;t have a journal,
1086      * in that case, do a full backup.
1087 
1088      * @param newState the write-only file descriptor pointing to the new journal
1089      * @param journal a Journal protocol buffer
1090      */
1091     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1092         FileOutputStream outStream = null;
1093         try {
1094             outStream = new FileOutputStream(newState.getFileDescriptor());
1095             final byte[] journalBytes = writeCheckedBytes(journal);
1096             outStream.write(journalBytes);
1097             outStream.close();
1098             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1099         } catch (IOException e) {
1100             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1101         }
1102     }
1103 
1104     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1105     private byte[] writeCheckedBytes(MessageNano proto) {
1106         CheckedMessage wrapper = new CheckedMessage();
1107         wrapper.payload = MessageNano.toByteArray(proto);
1108         CRC32 checksum = new CRC32();
1109         checksum.update(wrapper.payload);
1110         wrapper.checksum = checksum.getValue();
1111         return MessageNano.toByteArray(wrapper);
1112     }
1113 
1114     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1115     private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1116             throws InvalidProtocolBufferNanoException {
1117         CheckedMessage wrapper = new CheckedMessage();
1118         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1119         CRC32 checksum = new CRC32();
1120         checksum.update(wrapper.payload);
1121         if (wrapper.checksum != checksum.getValue()) {
1122             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1123         }
1124         return wrapper.payload;
1125     }
1126 
1127     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1128         if (mWidgetMap == null) {
1129             List&lt;AppWidgetProviderInfo&gt; widgets =
1130                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1131             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1132             for (AppWidgetProviderInfo info : widgets) {
1133                 mWidgetMap.put(info.provider, info);
1134             }
1135         }
1136         return mWidgetMap.get(component);
1137     }
1138 
1139     private class KeyParsingException extends Throwable {
1140         private KeyParsingException(Throwable cause) {
1141             super(cause);
1142         }
1143 
1144         public KeyParsingException(String reason) {
1145             super(reason);
1146         }
1147     }
1148 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19  import com.google.protobuf.nano.MessageNano;
  20  
  21  import com.android.launcher3.LauncherSettings.Favorites;
  22  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23  import com.android.launcher3.backup.BackupProtos;
  24  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25  import com.android.launcher3.backup.BackupProtos.Favorite;
  26  import com.android.launcher3.backup.BackupProtos.Journal;
  27  import com.android.launcher3.backup.BackupProtos.Key;
  28  import com.android.launcher3.backup.BackupProtos.Resource;
  29  import com.android.launcher3.backup.BackupProtos.Screen;
  30  import com.android.launcher3.backup.BackupProtos.Widget;
  31  
  32  import android.app.backup.BackupDataInputStream;
  33  import android.app.backup.BackupDataOutput;
  34  import android.app.backup.BackupHelper;
  35  import android.app.backup.BackupManager;
  36  import android.appwidget.AppWidgetManager;
  37  import android.appwidget.AppWidgetProviderInfo;
  38  import android.content.ComponentName;
  39  import android.content.ContentResolver;
  40  import android.content.ContentValues;
  41  import android.content.Context;
  42  import android.content.Intent;
  43  import android.database.Cursor;
  44  import android.graphics.Bitmap;
  45  import android.graphics.BitmapFactory;
  46  import android.graphics.drawable.Drawable;
  47  import android.os.ParcelFileDescriptor;
  48  import android.text.TextUtils;
  49  import android.util.Base64;
  50  import android.util.Log;
  51  
  52  import java.io.ByteArrayOutputStream;
  53  import java.io.FileInputStream;
  54  import java.io.FileOutputStream;
  55  import java.io.IOException;
  56  import java.net.URISyntaxException;
  57  import java.util.ArrayList;
  58  import java.util.HashMap;
  59  import java.util.HashSet;
  60  import java.util.List;
  61  import java.util.Set;
  62  import java.util.zip.CRC32;
  63  
  64  /**
  65   * Persist the launcher home state across calamities.
  66   */
  67  public class LauncherBackupHelper implements BackupHelper {
  68  
  69      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72      private static final boolean DEBUG_PAYLOAD = false;
  73  
  74      private static final int MAX_JOURNAL_SIZE = 1000000;
  75  
  76      /** icons are large, dribble them out */
  77      private static final int MAX_ICONS_PER_PASS = 10;
  78  
  79      /** widgets contain previews, which are very large, dribble them out */
  80      private static final int MAX_WIDGETS_PER_PASS = 5;
  81  
  82      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83  
  84      public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85  
  86      public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87  
  88      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89              android.graphics.Bitmap.CompressFormat.PNG;
  90  
  91      private static BackupManager sBackupManager;
  92  
  93      private static final String[] FAVORITE_PROJECTION = {
  94              Favorites._ID,                     // 0
  95              Favorites.MODIFIED,                // 1
  96              Favorites.INTENT,                  // 2
  97              Favorites.APPWIDGET_PROVIDER,      // 3
  98              Favorites.APPWIDGET_ID,            // 4
  99              Favorites.CELLX,                   // 5
 100              Favorites.CELLY,                   // 6
 101              Favorites.CONTAINER,               // 7
 102              Favorites.ICON,                    // 8
 103              Favorites.ICON_PACKAGE,            // 9
 104              Favorites.ICON_RESOURCE,           // 10
 105              Favorites.ICON_TYPE,               // 11
 106              Favorites.ITEM_TYPE,               // 12
 107              Favorites.SCREEN,                  // 13
 108              Favorites.SPANX,                   // 14
 109              Favorites.SPANY,                   // 15
 110              Favorites.TITLE,                   // 16
 111      };
 112  
 113      private static final int ID_INDEX = 0;
 114      private static final int ID_MODIFIED = 1;
 115      private static final int INTENT_INDEX = 2;
 116      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117      private static final int APPWIDGET_ID_INDEX = 4;
 118      private static final int CELLX_INDEX = 5;
 119      private static final int CELLY_INDEX = 6;
 120      private static final int CONTAINER_INDEX = 7;
 121      private static final int ICON_INDEX = 8;
 122      private static final int ICON_PACKAGE_INDEX = 9;
 123      private static final int ICON_RESOURCE_INDEX = 10;
 124      private static final int ICON_TYPE_INDEX = 11;
 125      private static final int ITEM_TYPE_INDEX = 12;
 126      private static final int SCREEN_INDEX = 13;
 127      private static final int SPANX_INDEX = 14;
 128      private static final int SPANY_INDEX = 15;
 129      private static final int TITLE_INDEX = 16;
 130  
 131      private static final String[] SCREEN_PROJECTION = {
 132              WorkspaceScreens._ID,              // 0
 133              WorkspaceScreens.MODIFIED,         // 1
 134              WorkspaceScreens.SCREEN_RANK       // 2
 135      };
 136  
 137      private static final int SCREEN_RANK_INDEX = 2;
 138  
 139      private final Context mContext;
 140  
 141      private final boolean mRestoreEnabled;
 142  
 143      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 144  
 145      private ArrayList&lt;Key&gt; mKeys;
 146  
 147      public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 148          mContext = context;
 149          mRestoreEnabled = restoreEnabled;
 150      }
 151  
 152      private void dataChanged() {
 153          if (sBackupManager == null) {
 154              sBackupManager = new BackupManager(mContext);
 155          }
 156          sBackupManager.dataChanged();
 157      }
 158  
 159      /**
 160       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 161       *
 162       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 163       *
 164       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 165       *
 166       * @param oldState notes from the last backup
 167       * @param data incremental key/value pairs to persist off-device
 168       * @param newState notes for the next backup
 169       * @throws IOException
 170       */
 171      @Override
 172      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 173              ParcelFileDescriptor newState) {
 174          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 175  
 176          Journal in = readJournal(oldState);
 177          Journal out = new Journal();
 178  
 179          long lastBackupTime = in.t;
 180          out.t = System.currentTimeMillis();
 181          out.rows = 0;
 182          out.bytes = 0;
 183  
 184          Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 185  
 186          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 187          try {
 188              backupFavorites(in, data, out, keys);
 189              backupScreens(in, data, out, keys);
 190              backupIcons(in, data, out, keys);
 191              backupWidgets(in, data, out, keys);
 192          } catch (IOException e) {
 193              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 194          }
 195  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -        out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +        out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 198          writeJournal(newState, out);
 199          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 200      }
 201  
 202      /**
 203       * Restore launcher configuration from the restored data stream.
 204       *
 205       * &lt;P&gt;Keys may arrive in any order.
 206       *
 207       * @param data the key/value pair from the server
 208       */
 209      @Override
 210      public void restoreEntity(BackupDataInputStream data) {
 211          if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 212          if (mKeys == null) {
 213              mKeys = new ArrayList&lt;Key&gt;();
 214          }
 215          byte[] buffer = new byte[512];
 216              String backupKey = data.getKey();
 217              int dataSize = data.size();
 218              if (buffer.length &lt; dataSize) {
 219                  buffer = new byte[dataSize];
 220              }
 221              Key key = null;
 222          int bytesRead = 0;
 223          try {
 224              bytesRead = data.read(buffer, 0, dataSize);
 225              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 226          } catch (IOException e) {
 227              Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 228          }
 229          try {
 230              key = backupKeyToKey(backupKey);
 231              mKeys.add(key);
 232              switch (key.type) {
 233                  case Key.FAVORITE:
 234                      restoreFavorite(key, buffer, dataSize, mKeys);
 235                      break;
 236  
 237                  case Key.SCREEN:
 238                      restoreScreen(key, buffer, dataSize, mKeys);
 239                      break;
 240  
 241                  case Key.ICON:
 242                      restoreIcon(key, buffer, dataSize, mKeys);
 243                      break;
 244  
 245                  case Key.WIDGET:
 246                      restoreWidget(key, buffer, dataSize, mKeys);
 247                      break;
 248  
 249                  default:
 250                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 251                      break;
 252              }
 253          } catch (KeyParsingException e) {
 254              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 255          }
 256  
 257      }
 258  
 259      /**
 260       * Record the restore state for the next backup.
 261       *
 262       * @param newState notes about the backup state after restore.
 263       */
 264      @Override
 265      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 266          // clear the output journal time, to force a full backup to
 267          // will catch any changes the restore process might have made
 268          Journal out = new Journal();
 269          out.t = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 270 -        out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +        out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 272          writeJournal(newState, out);
 273          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 274          mKeys.clear();
 275      }
 276  
 277      /**
 278       * Write all modified favorites to the data stream.
 279       *
 280       *
 281       * @param in notes from last backup
 282       * @param data output stream for key/value pairs
 283       * @param out notes about this backup
 284       * @param keys keys to mark as clean in the notes for next backup
 285       * @throws IOException
 286       */
 287      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 288              ArrayList&lt;Key&gt; keys)
 289              throws IOException {
 290          // read the old ID set
 291          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 292          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 293  
 294          // persist things that have changed since the last backup
 295          ContentResolver cr = mContext.getContentResolver();
 296          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 297                  null, null, null);
 298          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 299          try {
 300              cursor.moveToPosition(-1);
 301              while(cursor.moveToNext()) {
 302                  final long id = cursor.getLong(ID_INDEX);
 303                  final long updateTime = cursor.getLong(ID_MODIFIED);
 304                  Key key = getKey(Key.FAVORITE, id);
 305                  keys.add(key);
 306                  final String backupKey = keyToBackupKey(key);
 307                  currentIds.add(backupKey);
 308                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 309                      byte[] blob = packFavorite(cursor);
 310                      writeRowToBackup(key, blob, out, data);
 311                  } else {
 312                      if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 313                  }
 314              }
 315          } finally {
 316              cursor.close();
 317          }
 318          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 319  
 320          // these IDs must have been deleted
 321          savedIds.removeAll(currentIds);
 322          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 323      }
 324  
 325      /**
 326       * Read a favorite from the stream.
 327       *
 328       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 329       *
 330       * @param key identifier for the row
 331       * @param buffer the serialized proto from the stream, may be larger than dataSize
 332       * @param dataSize the size of the proto from the stream
 333       * @param keys keys to mark as clean in the notes for next backup
 334       */
 335      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 336          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 337          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 338                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 339  
 340          if (!mRestoreEnabled) {
 341              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 342              return;
 343          }
 344  
 345          try {
 346              ContentResolver cr = mContext.getContentResolver();
 347              ContentValues values = unpackFavorite(buffer, 0, dataSize);
 348              cr.insert(Favorites.CONTENT_URI, values);
 349          } catch (InvalidProtocolBufferNanoException e) {
 350              Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 351          }
 352      }
 353  
 354      /**
 355       * Write all modified screens to the data stream.
 356       *
 357       *
 358       * @param in notes from last backup
 359       * @param data output stream for key/value pairs
 360       * @param out notes about this backup
 361       * @param keys keys to mark as clean in the notes for next backup
 362       * @throws IOException
 363       */
 364      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 365              ArrayList&lt;Key&gt; keys)
 366              throws IOException {
 367          // read the old ID set
 368          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 369          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 370  
 371          // persist things that have changed since the last backup
 372          ContentResolver cr = mContext.getContentResolver();
 373          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 374                  null, null, null);
 375          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 376          try {
 377              cursor.moveToPosition(-1);
 378              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 379              while(cursor.moveToNext()) {
 380                  final long id = cursor.getLong(ID_INDEX);
 381                  final long updateTime = cursor.getLong(ID_MODIFIED);
 382                  Key key = getKey(Key.SCREEN, id);
 383                  keys.add(key);
 384                  final String backupKey = keyToBackupKey(key);
 385                  currentIds.add(backupKey);
 386                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 387                      byte[] blob = packScreen(cursor);
 388                      writeRowToBackup(key, blob, out, data);
 389                  } else {
 390                      if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 391                  }
 392              }
 393          } finally {
 394              cursor.close();
 395          }
 396          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 397  
 398          // these IDs must have been deleted
 399          savedIds.removeAll(currentIds);
 400          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 401      }
 402  
 403      /**
 404       * Read a screen from the stream.
 405       *
 406       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 407       *
 408       * @param key identifier for the row
 409       * @param buffer the serialized proto from the stream, may be larger than dataSize
 410       * @param dataSize the size of the proto from the stream
 411       * @param keys keys to mark as clean in the notes for next backup
 412       */
 413      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 414          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 415          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 416                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 417  
 418          if (!mRestoreEnabled) {
 419              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 420              return;
 421          }
 422  
 423          try {
 424              ContentResolver cr = mContext.getContentResolver();
 425              ContentValues values = unpackScreen(buffer, 0, dataSize);
 426              cr.insert(WorkspaceScreens.CONTENT_URI, values);
 427  
 428          } catch (InvalidProtocolBufferNanoException e) {
 429              Log.e(TAG, &quot;failed to decode screen&quot;, e);
 430          }
 431      }
 432  
 433      /**
 434       * Write all the static icon resources we need to render placeholders
 435       * for a package that is not installed.
 436       *
 437       * @param in notes from last backup
 438       * @param data output stream for key/value pairs
 439       * @param out notes about this backup
 440       * @param keys keys to mark as clean in the notes for next backup
 441       * @throws IOException
 442       */
 443      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 444              ArrayList&lt;Key&gt; keys) throws IOException {
 445          // persist icons that haven&#x27;t been persisted yet
 446          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 447          if (appState == null) {
 448              dataChanged(); // try again later
 449              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 450              return;
 451          }
 452          final ContentResolver cr = mContext.getContentResolver();
 453          final IconCache iconCache = appState.getIconCache();
 454          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 455  
 456          // read the old ID set
 457          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 458          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 459  
 460          int startRows = out.rows;
 461          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 462          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 463          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 464                  where, null, null);
 465          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 466          try {
 467              cursor.moveToPosition(-1);
 468              while(cursor.moveToNext()) {
 469                  final long id = cursor.getLong(ID_INDEX);
 470                  final String intentDescription = cursor.getString(INTENT_INDEX);
 471                  try {
 472                      Intent intent = Intent.parseUri(intentDescription, 0);
 473                      ComponentName cn = intent.getComponent();
 474                      Key key = null;
 475                      String backupKey = null;
 476                      if (cn != null) {
 477                          key = getKey(Key.ICON, cn.flattenToShortString());
 478                          backupKey = keyToBackupKey(key);
 479                          currentIds.add(backupKey);
 480                      } else {
 481                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 482                      }
 483                      if (savedIds.contains(backupKey)) {
 484                          if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 485  
 486                          // remember that we already backed this up previously
 487                          keys.add(key);
 488                      } else if (backupKey != null) {
 489                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 490                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 491                              if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 492                              Bitmap icon = iconCache.getIcon(intent);
 493                              keys.add(key);
 494                              if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {
 495                                  byte[] blob = packIcon(dpi, icon);
 496                                  writeRowToBackup(key, blob, out, data);
 497                              }
 498                          } else {
 499                              if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 500                              // too many icons for this pass, request another.
 501                              dataChanged();
 502                          }
 503                      }
 504                  } catch (URISyntaxException e) {
 505                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 506                  } catch (IOException e) {
 507                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 508                  }
 509  
 510              }
 511          } finally {
 512              cursor.close();
 513          }
 514          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 515  
 516          // these IDs must have been deleted
 517          savedIds.removeAll(currentIds);
 518          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 519      }
 520  
 521      /**
 522       * Read an icon from the stream.
 523       *
 524       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 525       *
 526       * @param key identifier for the row
 527       * @param buffer the serialized proto from the stream, may be larger than dataSize
 528       * @param dataSize the size of the proto from the stream
 529       * @param keys keys to mark as clean in the notes for next backup
 530       */
 531      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 532          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 533          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 534                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 535          try {
 536              Resource res = unpackIcon(buffer, 0, dataSize);
 537              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 538              if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +
 539                      Base64.encodeToString(res.data, 0, res.data.length,
 540                              Base64.NO_WRAP));
 541              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 542              if (icon == null) {
 543                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 544              }
 545  
 546              if (!mRestoreEnabled) {
 547                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 548                  return;
 549              } else {
 550                  // future site of icon cache mutation
 551              }
 552          } catch (InvalidProtocolBufferNanoException e) {
 553              Log.e(TAG, &quot;failed to decode icon&quot;, e);
 554          }
 555      }
 556  
 557      /**
 558       * Write all the static widget resources we need to render placeholders
 559       * for a package that is not installed.
 560       *
 561       * @param in notes from last backup
 562       * @param data output stream for key/value pairs
 563       * @param out notes about this backup
 564       * @param keys keys to mark as clean in the notes for next backup
 565       * @throws IOException
 566       */
 567      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 568              ArrayList&lt;Key&gt; keys) throws IOException {
 569          // persist static widget info that hasn&#x27;t been persisted yet
 570          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 571          if (appState == null) {
 572              dataChanged(); // try again later
 573              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);
 574              return;
 575          }
 576          final ContentResolver cr = mContext.getContentResolver();
 577          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 578          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 579          final IconCache iconCache = appState.getIconCache();
 580          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 581          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 582          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 583  
 584          // read the old ID set
 585          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 586          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 587  
 588          int startRows = out.rows;
 589          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 590          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 591          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 592                  where, null, null);
 593          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 594          try {
 595              cursor.moveToPosition(-1);
 596              while(cursor.moveToNext()) {
 597                  final long id = cursor.getLong(ID_INDEX);
 598                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 599                  final int spanX = cursor.getInt(SPANX_INDEX);
 600                  final int spanY = cursor.getInt(SPANY_INDEX);
 601                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 602                  Key key = null;
 603                  String backupKey = null;
 604                  if (provider != null) {
 605                      key = getKey(Key.WIDGET, providerName);
 606                      backupKey = keyToBackupKey(key);
 607                      currentIds.add(backupKey);
 608                  } else {
 609                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 610                  }
 611                  if (savedIds.contains(backupKey)) {
 612                      if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 613  
 614                      // remember that we already backed this up previously
 615                      keys.add(key);
 616                  } else if (backupKey != null) {
 617                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 618                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 619                          if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 620                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 621                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
 622                          byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);
 623                          keys.add(key);
 624                          writeRowToBackup(key, blob, out, data);
 625  
 626                      } else {
 627                          if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 628                          // too many widgets for this pass, request another.
 629                          dataChanged();
 630                      }
 631                  }
 632              }
 633          } finally {
 634              cursor.close();
 635          }
 636          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 637  
 638          // these IDs must have been deleted
 639          savedIds.removeAll(currentIds);
 640          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 641      }
 642  
 643      /**
 644       * Read a widget from the stream.
 645       *
 646       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 647       *
 648       * @param key identifier for the row
 649       * @param buffer the serialized proto from the stream, may be larger than dataSize
 650       * @param dataSize the size of the proto from the stream
 651       * @param keys keys to mark as clean in the notes for next backup
 652       */
 653      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 654          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 655          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 656                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 657          try {
 658              Widget widget = unpackWidget(buffer, 0, dataSize);
 659              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 660              if (widget.icon.data != null)  {
 661                  Bitmap icon = BitmapFactory
 662                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 663                  if (icon == null) {
 664                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 665                  }
 666              }
 667  
 668              if (!mRestoreEnabled) {
 669                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 670                  return;
 671              } else {
 672                  // future site of widget table mutation
 673              }
 674          } catch (InvalidProtocolBufferNanoException e) {
 675              Log.e(TAG, &quot;failed to decode widget&quot;, e);
 676          }
 677      }
 678  
 679      /** create a new key, with an integer ID.
 680       *
 681       * &lt;P&gt; Keys contain their own checksum instead of using
 682       * the heavy-weight CheckedMessage wrapper.
 683       */
 684      private Key getKey(int type, long id) {
 685          Key key = new Key();
 686          key.type = type;
 687          key.id = id;
 688          key.checksum = checkKey(key);
 689          return key;
 690      }
 691  
 692      /** create a new key for a named object.
 693       *
 694       * &lt;P&gt; Keys contain their own checksum instead of using
 695       * the heavy-weight CheckedMessage wrapper.
 696       */
 697      private Key getKey(int type, String name) {
 698          Key key = new Key();
 699          key.type = type;
 700          key.name = name;
 701          key.checksum = checkKey(key);
 702          return key;
 703      }
 704  
 705      /** keys need to be strings, serialize and encode. */
 706      private String keyToBackupKey(Key key) {
 707          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 708      }
 709  
 710      /** keys need to be strings, decode and parse. */
 711      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 712          try {
 713              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 714              if (key.checksum != checkKey(key)) {
 715                  key = null;
 716                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 717              }
 718              return key;
 719          } catch (InvalidProtocolBufferNanoException e) {
 720              throw new KeyParsingException(e);
 721          } catch (IllegalArgumentException e) {
 722              throw new KeyParsingException(e);
 723          }
 724      }
 725  
 726      private String getKeyName(Key key) {
 727          if (TextUtils.isEmpty(key.name)) {
 728              return Long.toString(key.id);
 729          } else {
 730              return key.name;
 731          }
 732  
 733      }
 734  
 735      private String geKeyType(Key key) {
 736          switch (key.type) {
 737              case Key.FAVORITE:
 738                  return &quot;favorite&quot;;
 739              case Key.SCREEN:
 740                  return &quot;screen&quot;;
 741              case Key.ICON:
 742                  return &quot;icon&quot;;
 743              case Key.WIDGET:
 744                  return &quot;widget&quot;;
 745              default:
 746                  return &quot;anonymous&quot;;
 747          }
 748      }
 749  
 750      /** Compute the checksum over the important bits of a key. */
 751      private long checkKey(Key key) {
 752          CRC32 checksum = new CRC32();
 753          checksum.update(key.type);
 754          checksum.update((int) (key.id &amp; 0xffff));
 755          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 756          if (!TextUtils.isEmpty(key.name)) {
 757              checksum.update(key.name.getBytes());
 758          }
 759          return checksum.getValue();
 760      }
 761  
 762      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 763      private byte[] packFavorite(Cursor c) {
 764          Favorite favorite = new Favorite();
 765          favorite.id = c.getLong(ID_INDEX);
 766          favorite.screen = c.getInt(SCREEN_INDEX);
 767          favorite.container = c.getInt(CONTAINER_INDEX);
 768          favorite.cellX = c.getInt(CELLX_INDEX);
 769          favorite.cellY = c.getInt(CELLY_INDEX);
 770          favorite.spanX = c.getInt(SPANX_INDEX);
 771          favorite.spanY = c.getInt(SPANY_INDEX);
 772          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 773          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 774              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 775              if (!TextUtils.isEmpty(iconPackage)) {
 776                  favorite.iconPackage = iconPackage;
 777              }
 778              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 779              if (!TextUtils.isEmpty(iconResource)) {
 780                  favorite.iconResource = iconResource;
 781              }
 782          }
 783          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 784              byte[] blob = c.getBlob(ICON_INDEX);
 785              if (blob != null &amp;&amp; blob.length &gt; 0) {
 786                  favorite.icon = blob;
 787              }
 788          }
 789          String title = c.getString(TITLE_INDEX);
 790          if (!TextUtils.isEmpty(title)) {
 791              favorite.title = title;
 792          }
 793          String intent = c.getString(INTENT_INDEX);
 794          if (!TextUtils.isEmpty(intent)) {
 795              favorite.intent = intent;
 796          }
 797          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 798          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 799              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 800              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 801              if (!TextUtils.isEmpty(appWidgetProvider)) {
 802                  favorite.appWidgetProvider = appWidgetProvider;
 803              }
 804          }
 805  
 806          return writeCheckedBytes(favorite);
 807      }
 808  
 809      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 810      private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 811              throws InvalidProtocolBufferNanoException {
 812          Favorite favorite = new Favorite();
 813          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 814          if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 815                  (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 816          ContentValues values = new ContentValues();
 817          values.put(Favorites._ID, favorite.id);
 818          values.put(Favorites.SCREEN, favorite.screen);
 819          values.put(Favorites.CONTAINER, favorite.container);
 820          values.put(Favorites.CELLX, favorite.cellX);
 821          values.put(Favorites.CELLY, favorite.cellY);
 822          values.put(Favorites.SPANX, favorite.spanX);
 823          values.put(Favorites.SPANY, favorite.spanY);
 824          values.put(Favorites.ICON_TYPE, favorite.iconType);
 825          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 826              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 827              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 828          }
 829          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 830              values.put(Favorites.ICON, favorite.icon);
 831          }
 832          if (!TextUtils.isEmpty(favorite.title)) {
 833              values.put(Favorites.TITLE, favorite.title);
 834          } else {
 835              values.put(Favorites.TITLE, &quot;&quot;);
 836          }
 837          if (!TextUtils.isEmpty(favorite.intent)) {
 838              values.put(Favorites.INTENT, favorite.intent);
 839          }
 840          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 841          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 842              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 843                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 844              }
 845              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 846          }
 847  
 848          // Let LauncherModel know we&#x27;ve been here.
 849          values.put(LauncherSettings.Favorites.RESTORED, 1);
 850  
 851          return values;
 852      }
 853  
 854      /** Serialize a Screen for persistence, including a checksum wrapper. */
 855      private byte[] packScreen(Cursor c) {
 856          Screen screen = new Screen();
 857          screen.id = c.getLong(ID_INDEX);
 858          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 859  
 860          return writeCheckedBytes(screen);
 861      }
 862  
 863      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 864      private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 865              throws InvalidProtocolBufferNanoException {
 866          Screen screen = new Screen();
 867          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 868          if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 869          ContentValues values = new ContentValues();
 870          values.put(WorkspaceScreens._ID, screen.id);
 871          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 872          return values;
 873      }
 874  
 875      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 876      private byte[] packIcon(int dpi, Bitmap icon) {
 877          Resource res = new Resource();
 878          res.dpi = dpi;
 879          ByteArrayOutputStream os = new ByteArrayOutputStream();
 880          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 881              res.data = os.toByteArray();
 882          }
 883          return writeCheckedBytes(res);
 884      }
 885  
 886      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 887      private Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 888              throws InvalidProtocolBufferNanoException {
 889          Resource res = new Resource();
 890          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 891          if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 892          return res;
 893      }
 894  
 895      /** Serialize a widget for persistence, including a checksum wrapper. */
 896      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 897              ComponentName provider) {
 898          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 899          Widget widget = new Widget();
 900          widget.provider = provider.flattenToShortString();
 901          widget.label = info.label;
 902          widget.configure = info.configure != null;
 903          if (info.icon != 0) {
 904              widget.icon = new Resource();
 905              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 906              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 907              ByteArrayOutputStream os = new ByteArrayOutputStream();
 908              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 909                  widget.icon.data = os.toByteArray();
 910                  widget.icon.dpi = dpi;
 911              }
 912          }
 913          if (info.previewImage != 0) {
 914              widget.preview = new Resource();
 915              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 916              ByteArrayOutputStream os = new ByteArrayOutputStream();
 917              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 918                  widget.preview.data = os.toByteArray();
 919                  widget.preview.dpi = dpi;
 920              }
 921          }
 922          return writeCheckedBytes(widget);
 923      }
 924  
 925      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 926      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 927              throws InvalidProtocolBufferNanoException {
 928          Widget widget = new Widget();
 929          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 930          if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 931          return widget;
 932      }
 933  
 934      /**
 935       * Read the old journal from the input file.
 936       *
 937       * In the event of any error, just pretend we didn&#x27;t have a journal,
 938       * in that case, do a full backup.
 939       *
 940       * @param oldState the read-0only file descriptor pointing to the old journal
 941       * @return a Journal protocol buffer
 942       */
 943      private Journal readJournal(ParcelFileDescriptor oldState) {
 944          Journal journal = new Journal();
 945          if (oldState == null) {
 946              return journal;
 947          }
 948          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 949          try {
 950              int availableBytes = inStream.available();
 951              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 952              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 953                  byte[] buffer = new byte[availableBytes];
 954                  int bytesRead = 0;
 955                  boolean valid = false;
 956                  InvalidProtocolBufferNanoException lastProtoException = null;
 957                  while (availableBytes &gt; 0) {
 958                      try {
 959                          // OMG what are you doing? This is crazy inefficient!
 960                          // If we read a byte that is not ours, we will cause trouble: b/12491813
 961                          // However, we don&#x27;t know how many bytes to expect (oops).
 962                          // So we have to step through *slowly*, watching for the end.
 963                          int result = inStream.read(buffer, bytesRead, 1);
 964                          if (result &gt; 0) {
 965                              availableBytes -= result;
 966                              bytesRead += result;
 967                              if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 968                                  Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 969                              }
 970                          } else {
 971                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 972                              // stop reading and see what there is to parse
 973                              availableBytes = 0;
 974                          }
 975                      } catch (IOException e) {
 976                          buffer = null;
 977                          availableBytes = 0;
 978                      }
 979  
 980                      // check the buffer to see if we have a valid journal
 981                      try {
 982                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
 983                          // if we are here, then we have read a valid, checksum-verified journal
 984                          valid = true;
 985                          availableBytes = 0;
 986                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
 987                      } catch (InvalidProtocolBufferNanoException e) {
 988                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
 989                          lastProtoException = e;
 990                          journal.clear();
 991                      }
 992                  }
 993                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
 994                  if (!valid) {
 995                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
 996                  }
 997              }
 998          } catch (IOException e) {
 999              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1000          } finally {
1001              try {
1002                  inStream.close();
1003              } catch (IOException e) {
1004                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1005              }
1006          }
1007          return journal;
1008      }
1009  
1010      private void writeRowToBackup(Key key, byte[] blob, Journal out,
1011              BackupDataOutput data) throws IOException {
1012          String backupKey = keyToBackupKey(key);
1013          data.writeEntityHeader(backupKey, blob.length);
1014          data.writeEntityData(blob, blob.length);
1015          out.rows++;
1016          out.bytes += blob.length;
1017          if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1018                  getKeyName(key) + &quot;/&quot; + blob.length);
1019          if(DEBUG_PAYLOAD) {
1020              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1021              final int chunkSize = 1024;
1022              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1023                  int end = offset + chunkSize;
1024                  end = Math.min(end, encoded.length());
1025                  Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1026              }
1027          }
1028      }
1029  
1030      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1031          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1032          for(int i = 0; i &lt; in.key.length; i++) {
1033              Key key = in.key[i];
1034              if (key.type == type) {
1035                  savedIds.add(keyToBackupKey(key));
1036              }
1037          }
1038          return savedIds;
1039      }
1040  
1041      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1042              throws IOException {
1043          int rows = 0;
1044          for(String deleted: deletedIds) {
1045              if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1046              data.writeEntityHeader(deleted, -1);
1047              rows++;
1048          }
1049          return rows;
1050      }
1051  
1052      /**
1053       * Write the new journal to the output file.
1054       *
1055       * In the event of any error, just pretend we didn&#x27;t have a journal,
1056       * in that case, do a full backup.
1057  
1058       * @param newState the write-only file descriptor pointing to the new journal
1059       * @param journal a Journal protocol buffer
1060       */
1061      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1062          FileOutputStream outStream = null;
1063          try {
1064              outStream = new FileOutputStream(newState.getFileDescriptor());
1065              final byte[] journalBytes = writeCheckedBytes(journal);
1066              outStream.write(journalBytes);
1067              outStream.close();
1068              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1069          } catch (IOException e) {
1070              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1071          }
1072      }
1073  
1074      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1075      private byte[] writeCheckedBytes(MessageNano proto) {
1076          CheckedMessage wrapper = new CheckedMessage();
1077          wrapper.payload = MessageNano.toByteArray(proto);
1078          CRC32 checksum = new CRC32();
1079          checksum.update(wrapper.payload);
1080          wrapper.checksum = checksum.getValue();
1081          return MessageNano.toByteArray(wrapper);
1082      }
1083  
1084      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1085      private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1086              throws InvalidProtocolBufferNanoException {
1087          CheckedMessage wrapper = new CheckedMessage();
1088          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1089          CRC32 checksum = new CRC32();
1090          checksum.update(wrapper.payload);
1091          if (wrapper.checksum != checksum.getValue()) {
1092              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1093          }
1094          return wrapper.payload;
1095      }
1096  
1097      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1098          if (mWidgetMap == null) {
1099              List&lt;AppWidgetProviderInfo&gt; widgets =
1100                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1101              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1102              for (AppWidgetProviderInfo info : widgets) {
1103                  mWidgetMap.put(info.provider, info);
1104              }
1105          }
1106          return mWidgetMap.get(component);
1107      }
1108  
1109      private class KeyParsingException extends Throwable {
1110          private KeyParsingException(Throwable cause) {
1111              super(cause);
1112          }
1113  
1114          public KeyParsingException(String reason) {
1115              super(reason);
1116          }
1117      }
1118  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19  import com.google.protobuf.nano.MessageNano;
  20  
  21  import com.android.launcher3.LauncherSettings.Favorites;
  22  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23  import com.android.launcher3.backup.BackupProtos;
  24  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25  import com.android.launcher3.backup.BackupProtos.Favorite;
  26  import com.android.launcher3.backup.BackupProtos.Journal;
  27  import com.android.launcher3.backup.BackupProtos.Key;
  28  import com.android.launcher3.backup.BackupProtos.Resource;
  29  import com.android.launcher3.backup.BackupProtos.Screen;
  30  import com.android.launcher3.backup.BackupProtos.Widget;
  31  
  32  import android.app.backup.BackupDataInputStream;
  33  import android.app.backup.BackupDataOutput;
  34  import android.app.backup.BackupHelper;
  35  import android.app.backup.BackupManager;
  36  import android.appwidget.AppWidgetManager;
  37  import android.appwidget.AppWidgetProviderInfo;
  38  import android.content.ComponentName;
  39  import android.content.ContentResolver;
  40  import android.content.ContentValues;
  41  import android.content.Context;
  42  import android.content.Intent;
  43  import android.database.Cursor;
  44  import android.graphics.Bitmap;
  45  import android.graphics.BitmapFactory;
  46  import android.graphics.drawable.Drawable;
  47  import android.os.ParcelFileDescriptor;
  48  import android.text.TextUtils;
  49  import android.util.Base64;
  50  import android.util.Log;
  51  
  52  import java.io.ByteArrayOutputStream;
  53  import java.io.FileInputStream;
  54  import java.io.FileOutputStream;
  55  import java.io.IOException;
  56  import java.net.URISyntaxException;
  57  import java.util.ArrayList;
  58  import java.util.HashMap;
  59  import java.util.HashSet;
  60  import java.util.List;
  61  import java.util.Set;
  62  import java.util.zip.CRC32;
  63  
  64  /**
  65   * Persist the launcher home state across calamities.
  66   */
  67  public class LauncherBackupHelper implements BackupHelper {
  68  
  69      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72      private static final boolean DEBUG_PAYLOAD = false;
  73  
  74      private static final int MAX_JOURNAL_SIZE = 1000000;
  75  
  76      /** icons are large, dribble them out */
  77      private static final int MAX_ICONS_PER_PASS = 10;
  78  
  79      /** widgets contain previews, which are very large, dribble them out */
  80      private static final int MAX_WIDGETS_PER_PASS = 5;
  81  
  82      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83  
  84      public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85  
  86      public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87  
  88      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89              android.graphics.Bitmap.CompressFormat.PNG;
  90  
  91      private static BackupManager sBackupManager;
  92  
  93      private static final String[] FAVORITE_PROJECTION = {
  94              Favorites._ID,                     // 0
  95              Favorites.MODIFIED,                // 1
  96              Favorites.INTENT,                  // 2
  97              Favorites.APPWIDGET_PROVIDER,      // 3
  98              Favorites.APPWIDGET_ID,            // 4
  99              Favorites.CELLX,                   // 5
 100              Favorites.CELLY,                   // 6
 101              Favorites.CONTAINER,               // 7
 102              Favorites.ICON,                    // 8
 103              Favorites.ICON_PACKAGE,            // 9
 104              Favorites.ICON_RESOURCE,           // 10
 105              Favorites.ICON_TYPE,               // 11
 106              Favorites.ITEM_TYPE,               // 12
 107              Favorites.SCREEN,                  // 13
 108              Favorites.SPANX,                   // 14
 109              Favorites.SPANY,                   // 15
 110              Favorites.TITLE,                   // 16
 111      };
 112  
 113      private static final int ID_INDEX = 0;
 114      private static final int ID_MODIFIED = 1;
 115      private static final int INTENT_INDEX = 2;
 116      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117      private static final int APPWIDGET_ID_INDEX = 4;
 118      private static final int CELLX_INDEX = 5;
 119      private static final int CELLY_INDEX = 6;
 120      private static final int CONTAINER_INDEX = 7;
 121      private static final int ICON_INDEX = 8;
 122      private static final int ICON_PACKAGE_INDEX = 9;
 123      private static final int ICON_RESOURCE_INDEX = 10;
 124      private static final int ICON_TYPE_INDEX = 11;
 125      private static final int ITEM_TYPE_INDEX = 12;
 126      private static final int SCREEN_INDEX = 13;
 127      private static final int SPANX_INDEX = 14;
 128      private static final int SPANY_INDEX = 15;
 129      private static final int TITLE_INDEX = 16;
 130  
 131      private static final String[] SCREEN_PROJECTION = {
 132              WorkspaceScreens._ID,              // 0
 133              WorkspaceScreens.MODIFIED,         // 1
 134              WorkspaceScreens.SCREEN_RANK       // 2
 135      };
 136  
 137      private static final int SCREEN_RANK_INDEX = 2;
 138  
 139      private final Context mContext;
 140  
 141      private final boolean mRestoreEnabled;
 142  
 143      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 144  
 145      private ArrayList&lt;Key&gt; mKeys;
 146  
 147      public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 148          mContext = context;
 149          mRestoreEnabled = restoreEnabled;
 150      }
 151  
 152      private void dataChanged() {
 153          if (sBackupManager == null) {
 154              sBackupManager = new BackupManager(mContext);
 155          }
 156          sBackupManager.dataChanged();
 157      }
 158  
 159      /**
 160       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 161       *
 162       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 163       *
 164       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 165       *
 166       * @param oldState notes from the last backup
 167       * @param data incremental key/value pairs to persist off-device
 168       * @param newState notes for the next backup
 169       * @throws IOException
 170       */
 171      @Override
 172      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 173              ParcelFileDescriptor newState) {
 174          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 175  
 176          Journal in = readJournal(oldState);
 177          Journal out = new Journal();
 178  
 179          long lastBackupTime = in.t;
 180          out.t = System.currentTimeMillis();
 181          out.rows = 0;
 182          out.bytes = 0;
 183  
 184          Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 185  
 186          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 187          try {
 188              backupFavorites(in, data, out, keys);
 189              backupScreens(in, data, out, keys);
 190              backupIcons(in, data, out, keys);
 191              backupWidgets(in, data, out, keys);
 192          } catch (IOException e) {
 193              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 194          }
 195  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -        out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +        out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
 198          writeJournal(newState, out);
 199          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 200      }
 201  
 202      /**
 203       * Restore launcher configuration from the restored data stream.
 204       *
 205       * &lt;P&gt;Keys may arrive in any order.
 206       *
 207       * @param data the key/value pair from the server
 208       */
 209      @Override
 210      public void restoreEntity(BackupDataInputStream data) {
 211          if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 212          if (mKeys == null) {
 213              mKeys = new ArrayList&lt;Key&gt;();
 214          }
 215          byte[] buffer = new byte[512];
 216              String backupKey = data.getKey();
 217              int dataSize = data.size();
 218              if (buffer.length &lt; dataSize) {
 219                  buffer = new byte[dataSize];
 220              }
 221              Key key = null;
 222          int bytesRead = 0;
 223          try {
 224              bytesRead = data.read(buffer, 0, dataSize);
 225              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 226          } catch (IOException e) {
 227              Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 228          }
 229          try {
 230              key = backupKeyToKey(backupKey);
 231              mKeys.add(key);
 232              switch (key.type) {
 233                  case Key.FAVORITE:
 234                      restoreFavorite(key, buffer, dataSize, mKeys);
 235                      break;
 236  
 237                  case Key.SCREEN:
 238                      restoreScreen(key, buffer, dataSize, mKeys);
 239                      break;
 240  
 241                  case Key.ICON:
 242                      restoreIcon(key, buffer, dataSize, mKeys);
 243                      break;
 244  
 245                  case Key.WIDGET:
 246                      restoreWidget(key, buffer, dataSize, mKeys);
 247                      break;
 248  
 249                  default:
 250                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 251                      break;
 252              }
 253          } catch (KeyParsingException e) {
 254              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 255          }
 256  
 257      }
 258  
 259      /**
 260       * Record the restore state for the next backup.
 261       *
 262       * @param newState notes about the backup state after restore.
 263       */
 264      @Override
 265      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 266          // clear the output journal time, to force a full backup to
 267          // will catch any changes the restore process might have made
 268          Journal out = new Journal();
 269          out.t = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 270 -        out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +        out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 272          writeJournal(newState, out);
 273          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 274          mKeys.clear();
 275      }
 276  
 277      /**
 278       * Write all modified favorites to the data stream.
 279       *
 280       *
 281       * @param in notes from last backup
 282       * @param data output stream for key/value pairs
 283       * @param out notes about this backup
 284       * @param keys keys to mark as clean in the notes for next backup
 285       * @throws IOException
 286       */
 287      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 288              ArrayList&lt;Key&gt; keys)
 289              throws IOException {
 290          // read the old ID set
 291          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 292          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 293  
 294          // persist things that have changed since the last backup
 295          ContentResolver cr = mContext.getContentResolver();
 296          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 297                  null, null, null);
 298          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 299          try {
 300              cursor.moveToPosition(-1);
 301              while(cursor.moveToNext()) {
 302                  final long id = cursor.getLong(ID_INDEX);
 303                  final long updateTime = cursor.getLong(ID_MODIFIED);
 304                  Key key = getKey(Key.FAVORITE, id);
 305                  keys.add(key);
 306                  final String backupKey = keyToBackupKey(key);
 307                  currentIds.add(backupKey);
 308                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 309                      byte[] blob = packFavorite(cursor);
 310                      writeRowToBackup(key, blob, out, data);
 311                  } else {
 312                      if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 313                  }
 314              }
 315          } finally {
 316              cursor.close();
 317          }
 318          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 319  
 320          // these IDs must have been deleted
 321          savedIds.removeAll(currentIds);
 322          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 323      }
 324  
 325      /**
 326       * Read a favorite from the stream.
 327       *
 328       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 329       *
 330       * @param key identifier for the row
 331       * @param buffer the serialized proto from the stream, may be larger than dataSize
 332       * @param dataSize the size of the proto from the stream
 333       * @param keys keys to mark as clean in the notes for next backup
 334       */
 335      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 336          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 337          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 338                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 339  
 340          if (!mRestoreEnabled) {
 341              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 342              return;
 343          }
 344  
 345          try {
 346              ContentResolver cr = mContext.getContentResolver();
 347              ContentValues values = unpackFavorite(buffer, 0, dataSize);
 348              cr.insert(Favorites.CONTENT_URI, values);
 349          } catch (InvalidProtocolBufferNanoException e) {
 350              Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 351          }
 352      }
 353  
 354      /**
 355       * Write all modified screens to the data stream.
 356       *
 357       *
 358       * @param in notes from last backup
 359       * @param data output stream for key/value pairs
 360       * @param out notes about this backup
 361       * @param keys keys to mark as clean in the notes for next backup
 362       * @throws IOException
 363       */
 364      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 365              ArrayList&lt;Key&gt; keys)
 366              throws IOException {
 367          // read the old ID set
 368          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 369          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 370  
 371          // persist things that have changed since the last backup
 372          ContentResolver cr = mContext.getContentResolver();
 373          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 374                  null, null, null);
 375          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 376          try {
 377              cursor.moveToPosition(-1);
 378              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 379              while(cursor.moveToNext()) {
 380                  final long id = cursor.getLong(ID_INDEX);
 381                  final long updateTime = cursor.getLong(ID_MODIFIED);
 382                  Key key = getKey(Key.SCREEN, id);
 383                  keys.add(key);
 384                  final String backupKey = keyToBackupKey(key);
 385                  currentIds.add(backupKey);
 386                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 387                      byte[] blob = packScreen(cursor);
 388                      writeRowToBackup(key, blob, out, data);
 389                  } else {
 390                      if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 391                  }
 392              }
 393          } finally {
 394              cursor.close();
 395          }
 396          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 397  
 398          // these IDs must have been deleted
 399          savedIds.removeAll(currentIds);
 400          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 401      }
 402  
 403      /**
 404       * Read a screen from the stream.
 405       *
 406       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 407       *
 408       * @param key identifier for the row
 409       * @param buffer the serialized proto from the stream, may be larger than dataSize
 410       * @param dataSize the size of the proto from the stream
 411       * @param keys keys to mark as clean in the notes for next backup
 412       */
 413      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 414          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 415          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 416                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 417  
 418          if (!mRestoreEnabled) {
 419              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 420              return;
 421          }
 422  
 423          try {
 424              ContentResolver cr = mContext.getContentResolver();
 425              ContentValues values = unpackScreen(buffer, 0, dataSize);
 426              cr.insert(WorkspaceScreens.CONTENT_URI, values);
 427  
 428          } catch (InvalidProtocolBufferNanoException e) {
 429              Log.e(TAG, &quot;failed to decode screen&quot;, e);
 430          }
 431      }
 432  
 433      /**
 434       * Write all the static icon resources we need to render placeholders
 435       * for a package that is not installed.
 436       *
 437       * @param in notes from last backup
 438       * @param data output stream for key/value pairs
 439       * @param out notes about this backup
 440       * @param keys keys to mark as clean in the notes for next backup
 441       * @throws IOException
 442       */
 443      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 444              ArrayList&lt;Key&gt; keys) throws IOException {
 445          // persist icons that haven&#x27;t been persisted yet
 446          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 447          if (appState == null) {
 448              dataChanged(); // try again later
 449              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 450              return;
 451          }
 452          final ContentResolver cr = mContext.getContentResolver();
 453          final IconCache iconCache = appState.getIconCache();
 454          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 455  
 456          // read the old ID set
 457          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 458          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 459  
 460          int startRows = out.rows;
 461          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 462          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 463          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 464                  where, null, null);
 465          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 466          try {
 467              cursor.moveToPosition(-1);
 468              while(cursor.moveToNext()) {
 469                  final long id = cursor.getLong(ID_INDEX);
 470                  final String intentDescription = cursor.getString(INTENT_INDEX);
 471                  try {
 472                      Intent intent = Intent.parseUri(intentDescription, 0);
 473                      ComponentName cn = intent.getComponent();
 474                      Key key = null;
 475                      String backupKey = null;
 476                      if (cn != null) {
 477                          key = getKey(Key.ICON, cn.flattenToShortString());
 478                          backupKey = keyToBackupKey(key);
 479                          currentIds.add(backupKey);
 480                      } else {
 481                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 482                      }
 483                      if (savedIds.contains(backupKey)) {
 484                          if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 485  
 486                          // remember that we already backed this up previously
 487                          keys.add(key);
 488                      } else if (backupKey != null) {
 489                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 490                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 491                              if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 492                              Bitmap icon = iconCache.getIcon(intent);
 493                              keys.add(key);
 494                              if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {
 495                                  byte[] blob = packIcon(dpi, icon);
 496                                  writeRowToBackup(key, blob, out, data);
 497                              }
 498                          } else {
 499                              if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 500                              // too many icons for this pass, request another.
 501                              dataChanged();
 502                          }
 503                      }
 504                  } catch (URISyntaxException e) {
 505                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 506                  } catch (IOException e) {
 507                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 508                  }
 509  
 510              }
 511          } finally {
 512              cursor.close();
 513          }
 514          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 515  
 516          // these IDs must have been deleted
 517          savedIds.removeAll(currentIds);
 518          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 519      }
 520  
 521      /**
 522       * Read an icon from the stream.
 523       *
 524       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 525       *
 526       * @param key identifier for the row
 527       * @param buffer the serialized proto from the stream, may be larger than dataSize
 528       * @param dataSize the size of the proto from the stream
 529       * @param keys keys to mark as clean in the notes for next backup
 530       */
 531      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 532          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 533          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 534                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 535          try {
 536              Resource res = unpackIcon(buffer, 0, dataSize);
 537              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 538              if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +
 539                      Base64.encodeToString(res.data, 0, res.data.length,
 540                              Base64.NO_WRAP));
 541              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 542              if (icon == null) {
 543                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 544              }
 545  
 546              if (!mRestoreEnabled) {
 547                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 548                  return;
 549              } else {
 550                  // future site of icon cache mutation
 551              }
 552          } catch (InvalidProtocolBufferNanoException e) {
 553              Log.e(TAG, &quot;failed to decode icon&quot;, e);
 554          }
 555      }
 556  
 557      /**
 558       * Write all the static widget resources we need to render placeholders
 559       * for a package that is not installed.
 560       *
 561       * @param in notes from last backup
 562       * @param data output stream for key/value pairs
 563       * @param out notes about this backup
 564       * @param keys keys to mark as clean in the notes for next backup
 565       * @throws IOException
 566       */
 567      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 568              ArrayList&lt;Key&gt; keys) throws IOException {
 569          // persist static widget info that hasn&#x27;t been persisted yet
 570          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 571          if (appState == null) {
 572              dataChanged(); // try again later
 573              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);
 574              return;
 575          }
 576          final ContentResolver cr = mContext.getContentResolver();
 577          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 578          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 579          final IconCache iconCache = appState.getIconCache();
 580          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 581          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 582          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 583  
 584          // read the old ID set
 585          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 586          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 587  
 588          int startRows = out.rows;
 589          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 590          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 591          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 592                  where, null, null);
 593          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 594          try {
 595              cursor.moveToPosition(-1);
 596              while(cursor.moveToNext()) {
 597                  final long id = cursor.getLong(ID_INDEX);
 598                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 599                  final int spanX = cursor.getInt(SPANX_INDEX);
 600                  final int spanY = cursor.getInt(SPANY_INDEX);
 601                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 602                  Key key = null;
 603                  String backupKey = null;
 604                  if (provider != null) {
 605                      key = getKey(Key.WIDGET, providerName);
 606                      backupKey = keyToBackupKey(key);
 607                      currentIds.add(backupKey);
 608                  } else {
 609                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 610                  }
 611                  if (savedIds.contains(backupKey)) {
 612                      if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 613  
 614                      // remember that we already backed this up previously
 615                      keys.add(key);
 616                  } else if (backupKey != null) {
 617                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 618                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 619                          if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 620                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 621                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
 622                          byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);
 623                          keys.add(key);
 624                          writeRowToBackup(key, blob, out, data);
 625  
 626                      } else {
 627                          if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 628                          // too many widgets for this pass, request another.
 629                          dataChanged();
 630                      }
 631                  }
 632              }
 633          } finally {
 634              cursor.close();
 635          }
 636          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 637  
 638          // these IDs must have been deleted
 639          savedIds.removeAll(currentIds);
 640          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 641      }
 642  
 643      /**
 644       * Read a widget from the stream.
 645       *
 646       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 647       *
 648       * @param key identifier for the row
 649       * @param buffer the serialized proto from the stream, may be larger than dataSize
 650       * @param dataSize the size of the proto from the stream
 651       * @param keys keys to mark as clean in the notes for next backup
 652       */
 653      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 654          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 655          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 656                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 657          try {
 658              Widget widget = unpackWidget(buffer, 0, dataSize);
 659              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 660              if (widget.icon.data != null)  {
 661                  Bitmap icon = BitmapFactory
 662                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 663                  if (icon == null) {
 664                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 665                  }
 666              }
 667  
 668              if (!mRestoreEnabled) {
 669                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 670                  return;
 671              } else {
 672                  // future site of widget table mutation
 673              }
 674          } catch (InvalidProtocolBufferNanoException e) {
 675              Log.e(TAG, &quot;failed to decode widget&quot;, e);
 676          }
 677      }
 678  
 679      /** create a new key, with an integer ID.
 680       *
 681       * &lt;P&gt; Keys contain their own checksum instead of using
 682       * the heavy-weight CheckedMessage wrapper.
 683       */
 684      private Key getKey(int type, long id) {
 685          Key key = new Key();
 686          key.type = type;
 687          key.id = id;
 688          key.checksum = checkKey(key);
 689          return key;
 690      }
 691  
 692      /** create a new key for a named object.
 693       *
 694       * &lt;P&gt; Keys contain their own checksum instead of using
 695       * the heavy-weight CheckedMessage wrapper.
 696       */
 697      private Key getKey(int type, String name) {
 698          Key key = new Key();
 699          key.type = type;
 700          key.name = name;
 701          key.checksum = checkKey(key);
 702          return key;
 703      }
 704  
 705      /** keys need to be strings, serialize and encode. */
 706      private String keyToBackupKey(Key key) {
 707          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 708      }
 709  
 710      /** keys need to be strings, decode and parse. */
 711      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 712          try {
 713              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 714              if (key.checksum != checkKey(key)) {
 715                  key = null;
 716                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 717              }
 718              return key;
 719          } catch (InvalidProtocolBufferNanoException e) {
 720              throw new KeyParsingException(e);
 721          } catch (IllegalArgumentException e) {
 722              throw new KeyParsingException(e);
 723          }
 724      }
 725  
 726      private String getKeyName(Key key) {
 727          if (TextUtils.isEmpty(key.name)) {
 728              return Long.toString(key.id);
 729          } else {
 730              return key.name;
 731          }
 732  
 733      }
 734  
 735      private String geKeyType(Key key) {
 736          switch (key.type) {
 737              case Key.FAVORITE:
 738                  return &quot;favorite&quot;;
 739              case Key.SCREEN:
 740                  return &quot;screen&quot;;
 741              case Key.ICON:
 742                  return &quot;icon&quot;;
 743              case Key.WIDGET:
 744                  return &quot;widget&quot;;
 745              default:
 746                  return &quot;anonymous&quot;;
 747          }
 748      }
 749  
 750      /** Compute the checksum over the important bits of a key. */
 751      private long checkKey(Key key) {
 752          CRC32 checksum = new CRC32();
 753          checksum.update(key.type);
 754          checksum.update((int) (key.id &amp; 0xffff));
 755          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 756          if (!TextUtils.isEmpty(key.name)) {
 757              checksum.update(key.name.getBytes());
 758          }
 759          return checksum.getValue();
 760      }
 761  
 762      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 763      private byte[] packFavorite(Cursor c) {
 764          Favorite favorite = new Favorite();
 765          favorite.id = c.getLong(ID_INDEX);
 766          favorite.screen = c.getInt(SCREEN_INDEX);
 767          favorite.container = c.getInt(CONTAINER_INDEX);
 768          favorite.cellX = c.getInt(CELLX_INDEX);
 769          favorite.cellY = c.getInt(CELLY_INDEX);
 770          favorite.spanX = c.getInt(SPANX_INDEX);
 771          favorite.spanY = c.getInt(SPANY_INDEX);
 772          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 773          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 774              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 775              if (!TextUtils.isEmpty(iconPackage)) {
 776                  favorite.iconPackage = iconPackage;
 777              }
 778              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 779              if (!TextUtils.isEmpty(iconResource)) {
 780                  favorite.iconResource = iconResource;
 781              }
 782          }
 783          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 784              byte[] blob = c.getBlob(ICON_INDEX);
 785              if (blob != null &amp;&amp; blob.length &gt; 0) {
 786                  favorite.icon = blob;
 787              }
 788          }
 789          String title = c.getString(TITLE_INDEX);
 790          if (!TextUtils.isEmpty(title)) {
 791              favorite.title = title;
 792          }
 793          String intent = c.getString(INTENT_INDEX);
 794          if (!TextUtils.isEmpty(intent)) {
 795              favorite.intent = intent;
 796          }
 797          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 798          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 799              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 800              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 801              if (!TextUtils.isEmpty(appWidgetProvider)) {
 802                  favorite.appWidgetProvider = appWidgetProvider;
 803              }
 804          }
 805  
 806          return writeCheckedBytes(favorite);
 807      }
 808  
 809      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 810      private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 811              throws InvalidProtocolBufferNanoException {
 812          Favorite favorite = new Favorite();
 813          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 814          if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 815                  (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 816          ContentValues values = new ContentValues();
 817          values.put(Favorites._ID, favorite.id);
 818          values.put(Favorites.SCREEN, favorite.screen);
 819          values.put(Favorites.CONTAINER, favorite.container);
 820          values.put(Favorites.CELLX, favorite.cellX);
 821          values.put(Favorites.CELLY, favorite.cellY);
 822          values.put(Favorites.SPANX, favorite.spanX);
 823          values.put(Favorites.SPANY, favorite.spanY);
 824          values.put(Favorites.ICON_TYPE, favorite.iconType);
 825          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 826              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 827              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 828          }
 829          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 830              values.put(Favorites.ICON, favorite.icon);
 831          }
 832          if (!TextUtils.isEmpty(favorite.title)) {
 833              values.put(Favorites.TITLE, favorite.title);
 834          } else {
 835              values.put(Favorites.TITLE, &quot;&quot;);
 836          }
 837          if (!TextUtils.isEmpty(favorite.intent)) {
 838              values.put(Favorites.INTENT, favorite.intent);
 839          }
 840          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 841          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 842              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 843                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 844              }
 845              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 846          }
 847  
 848          // Let LauncherModel know we&#x27;ve been here.
 849          values.put(LauncherSettings.Favorites.RESTORED, 1);
 850  
 851          return values;
 852      }
 853  
 854      /** Serialize a Screen for persistence, including a checksum wrapper. */
 855      private byte[] packScreen(Cursor c) {
 856          Screen screen = new Screen();
 857          screen.id = c.getLong(ID_INDEX);
 858          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 859  
 860          return writeCheckedBytes(screen);
 861      }
 862  
 863      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 864      private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 865              throws InvalidProtocolBufferNanoException {
 866          Screen screen = new Screen();
 867          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 868          if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 869          ContentValues values = new ContentValues();
 870          values.put(WorkspaceScreens._ID, screen.id);
 871          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 872          return values;
 873      }
 874  
 875      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 876      private byte[] packIcon(int dpi, Bitmap icon) {
 877          Resource res = new Resource();
 878          res.dpi = dpi;
 879          ByteArrayOutputStream os = new ByteArrayOutputStream();
 880          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 881              res.data = os.toByteArray();
 882          }
 883          return writeCheckedBytes(res);
 884      }
 885  
 886      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 887      private Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 888              throws InvalidProtocolBufferNanoException {
 889          Resource res = new Resource();
 890          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 891          if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 892          return res;
 893      }
 894  
 895      /** Serialize a widget for persistence, including a checksum wrapper. */
 896      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 897              ComponentName provider) {
 898          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 899          Widget widget = new Widget();
 900          widget.provider = provider.flattenToShortString();
 901          widget.label = info.label;
 902          widget.configure = info.configure != null;
 903          if (info.icon != 0) {
 904              widget.icon = new Resource();
 905              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 906              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 907              ByteArrayOutputStream os = new ByteArrayOutputStream();
 908              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 909                  widget.icon.data = os.toByteArray();
 910                  widget.icon.dpi = dpi;
 911              }
 912          }
 913          if (info.previewImage != 0) {
 914              widget.preview = new Resource();
 915              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 916              ByteArrayOutputStream os = new ByteArrayOutputStream();
 917              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 918                  widget.preview.data = os.toByteArray();
 919                  widget.preview.dpi = dpi;
 920              }
 921          }
 922          return writeCheckedBytes(widget);
 923      }
 924  
 925      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 926      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 927              throws InvalidProtocolBufferNanoException {
 928          Widget widget = new Widget();
 929          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 930          if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 931          return widget;
 932      }
 933  
 934      /**
 935       * Read the old journal from the input file.
 936       *
 937       * In the event of any error, just pretend we didn&#x27;t have a journal,
 938       * in that case, do a full backup.
 939       *
 940       * @param oldState the read-0only file descriptor pointing to the old journal
 941       * @return a Journal protocol buffer
 942       */
 943      private Journal readJournal(ParcelFileDescriptor oldState) {
 944          Journal journal = new Journal();
 945          if (oldState == null) {
 946              return journal;
 947          }
 948          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 949          try {
 950              int availableBytes = inStream.available();
 951              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 952              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 953                  byte[] buffer = new byte[availableBytes];
 954                  int bytesRead = 0;
 955                  boolean valid = false;
 956                  InvalidProtocolBufferNanoException lastProtoException = null;
 957                  while (availableBytes &gt; 0) {
 958                      try {
 959                          // OMG what are you doing? This is crazy inefficient!
 960                          // If we read a byte that is not ours, we will cause trouble: b/12491813
 961                          // However, we don&#x27;t know how many bytes to expect (oops).
 962                          // So we have to step through *slowly*, watching for the end.
 963                          int result = inStream.read(buffer, bytesRead, 1);
 964                          if (result &gt; 0) {
 965                              availableBytes -= result;
 966                              bytesRead += result;
 967                              if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 968                                  Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 969                              }
 970                          } else {
 971                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 972                              // stop reading and see what there is to parse
 973                              availableBytes = 0;
 974                          }
 975                      } catch (IOException e) {
 976                          buffer = null;
 977                          availableBytes = 0;
 978                      }
 979  
 980                      // check the buffer to see if we have a valid journal
 981                      try {
 982                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
 983                          // if we are here, then we have read a valid, checksum-verified journal
 984                          valid = true;
 985                          availableBytes = 0;
 986                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
 987                      } catch (InvalidProtocolBufferNanoException e) {
 988                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
 989                          lastProtoException = e;
 990                          journal.clear();
 991                      }
 992                  }
 993                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
 994                  if (!valid) {
 995                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
 996                  }
 997              }
 998          } catch (IOException e) {
 999              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1000          } finally {
1001              try {
1002                  inStream.close();
1003              } catch (IOException e) {
1004                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1005              }
1006          }
1007          return journal;
1008      }
1009  
1010      private void writeRowToBackup(Key key, byte[] blob, Journal out,
1011              BackupDataOutput data) throws IOException {
1012          String backupKey = keyToBackupKey(key);
1013          data.writeEntityHeader(backupKey, blob.length);
1014          data.writeEntityData(blob, blob.length);
1015          out.rows++;
1016          out.bytes += blob.length;
1017          if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1018                  getKeyName(key) + &quot;/&quot; + blob.length);
1019          if(DEBUG_PAYLOAD) {
1020              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1021              final int chunkSize = 1024;
1022              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1023                  int end = offset + chunkSize;
1024                  end = Math.min(end, encoded.length());
1025                  Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1026              }
1027          }
1028      }
1029  
1030      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1031          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1032          for(int i = 0; i &lt; in.key.length; i++) {
1033              Key key = in.key[i];
1034              if (key.type == type) {
1035                  savedIds.add(keyToBackupKey(key));
1036              }
1037          }
1038          return savedIds;
1039      }
1040  
1041      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1042              throws IOException {
1043          int rows = 0;
1044          for(String deleted: deletedIds) {
1045              if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1046              data.writeEntityHeader(deleted, -1);
1047              rows++;
1048          }
1049          return rows;
1050      }
1051  
1052      /**
1053       * Write the new journal to the output file.
1054       *
1055       * In the event of any error, just pretend we didn&#x27;t have a journal,
1056       * in that case, do a full backup.
1057  
1058       * @param newState the write-only file descriptor pointing to the new journal
1059       * @param journal a Journal protocol buffer
1060       */
1061      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1062          FileOutputStream outStream = null;
1063          try {
1064              outStream = new FileOutputStream(newState.getFileDescriptor());
1065              final byte[] journalBytes = writeCheckedBytes(journal);
1066              outStream.write(journalBytes);
1067              outStream.close();
1068              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1069          } catch (IOException e) {
1070              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1071          }
1072      }
1073  
1074      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1075      private byte[] writeCheckedBytes(MessageNano proto) {
1076          CheckedMessage wrapper = new CheckedMessage();
1077          wrapper.payload = MessageNano.toByteArray(proto);
1078          CRC32 checksum = new CRC32();
1079          checksum.update(wrapper.payload);
1080          wrapper.checksum = checksum.getValue();
1081          return MessageNano.toByteArray(wrapper);
1082      }
1083  
1084      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1085      private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1086              throws InvalidProtocolBufferNanoException {
1087          CheckedMessage wrapper = new CheckedMessage();
1088          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1089          CRC32 checksum = new CRC32();
1090          checksum.update(wrapper.payload);
1091          if (wrapper.checksum != checksum.getValue()) {
1092              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1093          }
1094          return wrapper.payload;
1095      }
1096  
1097      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1098          if (mWidgetMap == null) {
1099              List&lt;AppWidgetProviderInfo&gt; widgets =
1100                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1101              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1102              for (AppWidgetProviderInfo info : widgets) {
1103                  mWidgetMap.put(info.provider, info);
1104              }
1105          }
1106          return mWidgetMap.get(component);
1107      }
1108  
1109      private class KeyParsingException extends Throwable {
1110          private KeyParsingException(Throwable cause) {
1111              super(cause);
1112          }
1113  
1114          public KeyParsingException(String reason) {
1115              super(reason);
1116          }
1117      }
1118  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            