<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>398 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import android.graphics.drawable.BitmapDrawable;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import android.text.TextUtils;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;com.android.launcher3.compat.LauncherActivityInfoCompat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.android.launcher3.compat.LauncherAppsCompat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.android.launcher3.compat.UserHandleCompat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.android.launcher3.compat.UserManagerCompat;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.ByteArrayOutputStream;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.FileInputStream;\n&#x27;
                         &#x27;import java.io.FileNotFoundException;\n&#x27;
                         &#x27;import java.io.FileOutputStream;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private static final String RESOURCE_FILE_PREFIX &#x27;
                         &#x27;= &quot;icon_&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    // Empty class name is used for storing package &#x27;
                         &#x27;default entry.\n&#x27;
                         &#x27;    private static final String EMPTY_CLASS_NAME = &#x27;
                         &#x27;&quot;.&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final boolean DEBUG = false;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;     * Remove any records for the supplied package &#x27;
                         &#x27;name.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public void remove(String packageName, &#x27;
                         &#x27;UserHandleCompat user) {\n&#x27;
                         &#x27;        HashSet&lt;CacheKey&gt; forDeletion = new &#x27;
                         &#x27;HashSet&lt;CacheKey&gt;();\n&#x27;
                         &#x27;        for (CacheKey key: mCache.keySet()) {\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(key.componentName.getPackageName().equals(packageName)\n&#x27;
                         &#x27;                    &amp;&amp; key.user.equals(user)) {\n&#x27;
                         &#x27;                forDeletion.add(key);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (CacheKey condemned: forDeletion) {\n&#x27;
                         &#x27;            mCache.remove(condemned);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public Bitmap getIcon(Intent intent, &#x27;
                         &#x27;UserHandleCompat user) {\n&#x27;
                         &#x27;        return getIcon(intent, null, user, true);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Bitmap getIcon(Intent intent, String &#x27;
                         &#x27;title, UserHandleCompat user, boolean usePkgIcon) &#x27;
                         &#x27;{\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public Bitmap getIcon(Intent intent) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            // null info means not installed, but if &#x27;
                         &#x27;we have a component from the intent then\n&#x27;
                         &#x27;            // we should still look in the cache for &#x27;
                         &#x27;restored app icons.\n&#x27;
                         &#x27;            if (component == null) {\n&#x27;
                         &#x27;                return getDefaultIcon(user);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;            if (resolveInfo == null || component &#x27;
                           &#x27;== null) {\n&#x27;
                           &#x27;                return mDefaultIcon;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            LauncherActivityInfoCompat &#x27;
                         &#x27;launcherActInfo = &#x27;
                         &#x27;mLauncherApps.resolveActivity(intent, user);\n&#x27;
                         &#x27;            CacheEntry entry = &#x27;
                         &#x27;cacheLocked(component, launcherActInfo, null, user, &#x27;
                         &#x27;usePkgIcon);\n&#x27;
                         &#x27;            if (title != null) {\n&#x27;
                         &#x27;                entry.title = title;\n&#x27;
                         &#x27;                entry.contentDescription = &#x27;
                         &#x27;mUserManager.getBadgedLabelForUser(title, user);\n&#x27;
                         &#x27;            }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            CacheEntry entry = &#x27;
                           &#x27;cacheLocked(component, resolveInfo, null);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            if (info != null) {\n&#x27;
                         &#x27;                ComponentName labelKey = &#x27;
                         &#x27;info.getComponentName();\n&#x27;
                         &#x27;                if (labelCache != null &amp;&amp; &#x27;
                         &#x27;labelCache.containsKey(labelKey)) {\n&#x27;
                         &#x27;                    entry.title = &#x27;
                         &#x27;labelCache.get(labelKey).toString();\n&#x27;
                         &#x27;                } else {\n&#x27;
                         &#x27;                    entry.title = &#x27;
                         &#x27;info.getLabel().toString();\n&#x27;
                         &#x27;                    if (labelCache != null) {\n&#x27;
                         &#x27;                        labelCache.put(labelKey, &#x27;
                         &#x27;entry.title);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                entry.contentDescription = &#x27;
                         &#x27;mUserManager.getBadgedLabelForUser(entry.title, &#x27;
                         &#x27;user);\n&#x27;
                         &#x27;                entry.icon = &#x27;
                         &#x27;Utilities.createIconBitmap(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;info.getBadgedIcon(mIconDpi), mContext);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            ComponentName key = &#x27;
                           &#x27;LauncherModel.getComponentNameFromResolveInfo(info);\n&#x27;
                           &#x27;            if (labelCache != null &amp;&amp; &#x27;
                           &#x27;labelCache.containsKey(key)) {\n&#x27;
                           &#x27;                entry.title = &#x27;
                           &#x27;labelCache.get(key).toString();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                entry.title = &quot;&quot;;\n&#x27;
                         &#x27;                Bitmap preloaded = &#x27;
                         &#x27;getPreloadedIcon(componentName, user);\n&#x27;
                         &#x27;                if (preloaded != null) {\n&#x27;
                         &#x27;                    if (DEBUG) Log.d(TAG, &quot;using &#x27;
                         &#x27;preloaded icon for &quot; +\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;componentName.toShortString());\n&#x27;
                         &#x27;                    entry.icon = preloaded;\n&#x27;
                         &#x27;                } else {\n&#x27;
                         &#x27;                    if (usePackageIcon) {\n&#x27;
                         &#x27;                        CacheEntry packageEntry = &#x27;
                         &#x27;getEntryForPackage(\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;componentName.getPackageName(), user);\n&#x27;
                         &#x27;                        if (packageEntry != null) {\n&#x27;
                         &#x27;                            if (DEBUG) Log.d(TAG, &#x27;
                         &#x27;&quot;using package default icon for &quot; +\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;componentName.toShortString());\n&#x27;
                         &#x27;                            entry.icon = &#x27;
                         &#x27;packageEntry.icon;\n&#x27;
                         &#x27;                            entry.title = &#x27;
                         &#x27;packageEntry.title;\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    if (entry.icon == null) {\n&#x27;
                         &#x27;                        if (DEBUG) Log.d(TAG, &quot;using &#x27;
                         &#x27;default icon for &quot; +\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;componentName.toShortString());\n&#x27;
                         &#x27;                        entry.icon = &#x27;
                         &#x27;getDefaultIcon(user);\n&#x27;
                         &#x27;                    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                entry.title = &#x27;
                           &#x27;info.loadLabel(mPackageManager).toString();\n&#x27;
                           &#x27;                if (labelCache != null) {\n&#x27;
                           &#x27;                    labelCache.put(key, &#x27;
                           &#x27;entry.title);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Pre-load an icon into the persistent cache.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * &lt;P&gt;Queries for a component that does not &#x27;
                         &#x27;exist in the package manager\n&#x27;
                         &#x27;     * will be answered by the persistent cache.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param context application context\n&#x27;
                         &#x27;     * @param componentName the icon should be &#x27;
                         &#x27;returned for this component\n&#x27;
                         &#x27;     * @param icon the icon to be persisted\n&#x27;
                         &#x27;     * @param dpi the native density of the icon\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public static void preloadIcon(Context context, &#x27;
                         &#x27;ComponentName componentName, Bitmap icon,\n&#x27;
                         &#x27;            int dpi) {\n&#x27;
                         &#x27;        // TODO rescale to the correct native DPI\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            PackageManager packageManager = &#x27;
                         &#x27;context.getPackageManager();\n&#x27;
                         &#x27;            &#x27;
                         &#x27;packageManager.getActivityIcon(componentName);\n&#x27;
                         &#x27;            // component is present on the system &#x27;
                         &#x27;already, do nothing\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        } catch &#x27;
                         &#x27;(PackageManager.NameNotFoundException e) {\n&#x27;
                         &#x27;            // pass\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        final String key = &#x27;
                         &#x27;componentName.flattenToString();\n&#x27;
                         &#x27;        FileOutputStream resourceFile = null;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            resourceFile = &#x27;
                         &#x27;context.openFileOutput(getResourceFilename(componentName),\n&#x27;
                         &#x27;                    Context.MODE_PRIVATE);\n&#x27;
                         &#x27;            ByteArrayOutputStream os = new &#x27;
                         &#x27;ByteArrayOutputStream();\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(icon.compress(android.graphics.Bitmap.CompressFormat.PNG, &#x27;
                         &#x27;75, os)) {\n&#x27;
                         &#x27;                byte[] buffer = os.toByteArray();\n&#x27;
                         &#x27;                resourceFile.write(buffer, 0, &#x27;
                         &#x27;buffer.length);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                Log.w(TAG, &quot;failed to encode cache &#x27;
                         &#x27;for &quot; + key);\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (FileNotFoundException e) {\n&#x27;
                         &#x27;            Log.w(TAG, &quot;failed to pre-load cache for &#x27;
                         &#x27;&quot; + key, e);\n&#x27;
                         &#x27;        } catch (IOException e) {\n&#x27;
                         &#x27;            Log.w(TAG, &quot;failed to pre-load cache for &#x27;
                         &#x27;&quot; + key, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if (resourceFile != null) {\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    resourceFile.close();\n&#x27;
                         &#x27;                } catch (IOException e) {\n&#x27;
                         &#x27;                    Log.d(TAG, &quot;failed to save &#x27;
                         &#x27;restored icon for: &quot; + key, e);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Read a pre-loaded icon from the persistent &#x27;
                         &#x27;icon cache.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param componentName the component that &#x27;
                         &#x27;should own the icon\n&#x27;
                         &#x27;     * @returns a bitmap if one is cached, or null.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private Bitmap getPreloadedIcon(ComponentName &#x27;
                         &#x27;componentName, UserHandleCompat user) {\n&#x27;
                         &#x27;        final String key = &#x27;
                         &#x27;componentName.flattenToShortString();\n&#x27;
                         &#x27;\n&#x27;
                         &quot;        // We don&#x27;t keep icons for other profiles in &quot;
                         &#x27;persistent cache.\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!user.equals(UserHandleCompat.myUserHandle())) {\n&#x27;
                         &#x27;            return null;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (DEBUG) Log.v(TAG, &quot;looking for pre-load &#x27;
                         &#x27;icon for &quot; + key);\n&#x27;
                         &#x27;        Bitmap icon = null;\n&#x27;
                         &#x27;        FileInputStream resourceFile = null;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            resourceFile = &#x27;
                         &#x27;mContext.openFileInput(getResourceFilename(componentName));\n&#x27;
                         &#x27;            byte[] buffer = new byte[1024];\n&#x27;
                         &#x27;            ByteArrayOutputStream bytes = new &#x27;
                         &#x27;ByteArrayOutputStream();\n&#x27;
                         &#x27;            int bytesRead = 0;\n&#x27;
                         &#x27;            while(bytesRead &gt;= 0) {\n&#x27;
                         &#x27;                bytes.write(buffer, 0, bytesRead);\n&#x27;
                         &#x27;                bytesRead = &#x27;
                         &#x27;resourceFile.read(buffer, 0, buffer.length);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            if (DEBUG) Log.d(TAG, &quot;read &quot; + &#x27;
                         &#x27;bytes.size());\n&#x27;
                         &#x27;            icon = &#x27;
                         &#x27;BitmapFactory.decodeByteArray(bytes.toByteArray(), &#x27;
                         &#x27;0, bytes.size());\n&#x27;
                         &#x27;            if (icon == null) {\n&#x27;
                         &#x27;                Log.w(TAG, &quot;failed to decode &#x27;
                         &#x27;pre-load icon for &quot; + key);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (FileNotFoundException e) {\n&#x27;
                         &#x27;            if (DEBUG) Log.d(TAG, &quot;there is no &#x27;
                         &#x27;restored icon for: &quot; + key);\n&#x27;
                         &#x27;        } catch (IOException e) {\n&#x27;
                         &#x27;            Log.w(TAG, &quot;failed to read pre-load icon &#x27;
                         &#x27;for: &quot; + key, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if(resourceFile != null) {\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    resourceFile.close();\n&#x27;
                         &#x27;                } catch (IOException e) {\n&#x27;
                         &#x27;                    Log.d(TAG, &quot;failed to manage &#x27;
                         &#x27;pre-load icon file: &quot; + key, e);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return icon;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Remove a pre-loaded icon from the persistent &#x27;
                         &#x27;icon cache.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param componentName the component that &#x27;
                         &#x27;should own the icon\n&#x27;
                         &#x27;     * @returns true on success\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public boolean deletePreloadedIcon(ComponentName &#x27;
                         &#x27;componentName, UserHandleCompat user) {\n&#x27;
                         &quot;        // We don&#x27;t keep icons for other profiles in &quot;
                         &#x27;persistent cache.\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!user.equals(UserHandleCompat.myUserHandle())) {\n&#x27;
                         &#x27;            return false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (componentName == null) {\n&#x27;
                         &#x27;            return false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mCache.remove(componentName) != null) {\n&#x27;
                         &#x27;            if (DEBUG) Log.d(TAG, &quot;removed &#x27;
                         &#x27;pre-loaded icon from the in-memory cache&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        boolean success = &#x27;
                         &#x27;mContext.deleteFile(getResourceFilename(componentName));\n&#x27;
                         &#x27;        if (DEBUG &amp;&amp; success) Log.d(TAG, &quot;removed &#x27;
                         &#x27;pre-loaded icon from persistent cache&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return success;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static String &#x27;
                         &#x27;getResourceFilename(ComponentName component) {\n&#x27;
                         &#x27;        String resourceName = &#x27;
                         &#x27;component.flattenToShortString();\n&#x27;
                         &#x27;        String filename = &#x27;
                         &quot;resourceName.replace(File.separatorChar, &#x27;_&#x27;);\n&quot;
                         &#x27;        return RESOURCE_FILE_PREFIX + filename;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    static ComponentName getPackageComponent(String &#x27;
                         &#x27;packageName) {\n&#x27;
                         &#x27;        return new ComponentName(packageName, &#x27;
                         &#x27;EMPTY_CLASS_NAME);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import android.graphics.drawable.BitmapDrawable;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import android.text.TextUtils;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;com.android.launcher3.compat.LauncherActivityInfoCompat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.android.launcher3.compat.LauncherAppsCompat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.android.launcher3.compat.UserHandleCompat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.android.launcher3.compat.UserManagerCompat;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.ByteArrayOutputStream;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.FileInputStream;\n&#x27;
                         &#x27;import java.io.FileNotFoundException;\n&#x27;
                         &#x27;import java.io.FileOutputStream;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private static final String RESOURCE_FILE_PREFIX &#x27;
                         &#x27;= &quot;icon_&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    // Empty class name is used for storing package &#x27;
                         &#x27;default entry.\n&#x27;
                         &#x27;    private static final String EMPTY_CLASS_NAME = &#x27;
                         &#x27;&quot;.&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final boolean DEBUG = false;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;     * Remove any records for the supplied package &#x27;
                         &#x27;name.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public void remove(String packageName, &#x27;
                         &#x27;UserHandleCompat user) {\n&#x27;
                         &#x27;        HashSet&lt;CacheKey&gt; forDeletion = new &#x27;
                         &#x27;HashSet&lt;CacheKey&gt;();\n&#x27;
                         &#x27;        for (CacheKey key: mCache.keySet()) {\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(key.componentName.getPackageName().equals(packageName)\n&#x27;
                         &#x27;                    &amp;&amp; key.user.equals(user)) {\n&#x27;
                         &#x27;                forDeletion.add(key);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (CacheKey condemned: forDeletion) {\n&#x27;
                         &#x27;            mCache.remove(condemned);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public Bitmap getIcon(Intent intent, &#x27;
                         &#x27;UserHandleCompat user) {\n&#x27;
                         &#x27;        return getIcon(intent, null, user, true);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Bitmap getIcon(Intent intent, String &#x27;
                         &#x27;title, UserHandleCompat user, boolean usePkgIcon) &#x27;
                         &#x27;{\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public Bitmap getIcon(Intent intent) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            // null info means not installed, but if &#x27;
                         &#x27;we have a component from the intent then\n&#x27;
                         &#x27;            // we should still look in the cache for &#x27;
                         &#x27;restored app icons.\n&#x27;
                         &#x27;            if (component == null) {\n&#x27;
                         &#x27;                return getDefaultIcon(user);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;            if (resolveInfo == null || component &#x27;
                           &#x27;== null) {\n&#x27;
                           &#x27;                return mDefaultIcon;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            LauncherActivityInfoCompat &#x27;
                         &#x27;launcherActInfo = &#x27;
                         &#x27;mLauncherApps.resolveActivity(intent, user);\n&#x27;
                         &#x27;            CacheEntry entry = &#x27;
                         &#x27;cacheLocked(component, launcherActInfo, null, user, &#x27;
                         &#x27;usePkgIcon);\n&#x27;
                         &#x27;            if (title != null) {\n&#x27;
                         &#x27;                entry.title = title;\n&#x27;
                         &#x27;                entry.contentDescription = &#x27;
                         &#x27;mUserManager.getBadgedLabelForUser(title, user);\n&#x27;
                         &#x27;            }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            CacheEntry entry = &#x27;
                           &#x27;cacheLocked(component, resolveInfo, null);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            if (info != null) {\n&#x27;
                         &#x27;                ComponentName labelKey = &#x27;
                         &#x27;info.getComponentName();\n&#x27;
                         &#x27;                if (labelCache != null &amp;&amp; &#x27;
                         &#x27;labelCache.containsKey(labelKey)) {\n&#x27;
                         &#x27;                    entry.title = &#x27;
                         &#x27;labelCache.get(labelKey).toString();\n&#x27;
                         &#x27;                } else {\n&#x27;
                         &#x27;                    entry.title = &#x27;
                         &#x27;info.getLabel().toString();\n&#x27;
                         &#x27;                    if (labelCache != null) {\n&#x27;
                         &#x27;                        labelCache.put(labelKey, &#x27;
                         &#x27;entry.title);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                entry.contentDescription = &#x27;
                         &#x27;mUserManager.getBadgedLabelForUser(entry.title, &#x27;
                         &#x27;user);\n&#x27;
                         &#x27;                entry.icon = &#x27;
                         &#x27;Utilities.createIconBitmap(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;info.getBadgedIcon(mIconDpi), mContext);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            ComponentName key = &#x27;
                           &#x27;LauncherModel.getComponentNameFromResolveInfo(info);\n&#x27;
                           &#x27;            if (labelCache != null &amp;&amp; &#x27;
                           &#x27;labelCache.containsKey(key)) {\n&#x27;
                           &#x27;                entry.title = &#x27;
                           &#x27;labelCache.get(key).toString();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                entry.title = &quot;&quot;;\n&#x27;
                         &#x27;                Bitmap preloaded = &#x27;
                         &#x27;getPreloadedIcon(componentName, user);\n&#x27;
                         &#x27;                if (preloaded != null) {\n&#x27;
                         &#x27;                    if (DEBUG) Log.d(TAG, &quot;using &#x27;
                         &#x27;preloaded icon for &quot; +\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;componentName.toShortString());\n&#x27;
                         &#x27;                    entry.icon = preloaded;\n&#x27;
                         &#x27;                } else {\n&#x27;
                         &#x27;                    if (usePackageIcon) {\n&#x27;
                         &#x27;                        CacheEntry packageEntry = &#x27;
                         &#x27;getEntryForPackage(\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;componentName.getPackageName(), user);\n&#x27;
                         &#x27;                        if (packageEntry != null) {\n&#x27;
                         &#x27;                            if (DEBUG) Log.d(TAG, &#x27;
                         &#x27;&quot;using package default icon for &quot; +\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;componentName.toShortString());\n&#x27;
                         &#x27;                            entry.icon = &#x27;
                         &#x27;packageEntry.icon;\n&#x27;
                         &#x27;                            entry.title = &#x27;
                         &#x27;packageEntry.title;\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    if (entry.icon == null) {\n&#x27;
                         &#x27;                        if (DEBUG) Log.d(TAG, &quot;using &#x27;
                         &#x27;default icon for &quot; +\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;componentName.toShortString());\n&#x27;
                         &#x27;                        entry.icon = &#x27;
                         &#x27;getDefaultIcon(user);\n&#x27;
                         &#x27;                    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                entry.title = &#x27;
                           &#x27;info.loadLabel(mPackageManager).toString();\n&#x27;
                           &#x27;                if (labelCache != null) {\n&#x27;
                           &#x27;                    labelCache.put(key, &#x27;
                           &#x27;entry.title);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Pre-load an icon into the persistent cache.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * &lt;P&gt;Queries for a component that does not &#x27;
                         &#x27;exist in the package manager\n&#x27;
                         &#x27;     * will be answered by the persistent cache.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param context application context\n&#x27;
                         &#x27;     * @param componentName the icon should be &#x27;
                         &#x27;returned for this component\n&#x27;
                         &#x27;     * @param icon the icon to be persisted\n&#x27;
                         &#x27;     * @param dpi the native density of the icon\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public static void preloadIcon(Context context, &#x27;
                         &#x27;ComponentName componentName, Bitmap icon,\n&#x27;
                         &#x27;            int dpi) {\n&#x27;
                         &#x27;        // TODO rescale to the correct native DPI\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            PackageManager packageManager = &#x27;
                         &#x27;context.getPackageManager();\n&#x27;
                         &#x27;            &#x27;
                         &#x27;packageManager.getActivityIcon(componentName);\n&#x27;
                         &#x27;            // component is present on the system &#x27;
                         &#x27;already, do nothing\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        } catch &#x27;
                         &#x27;(PackageManager.NameNotFoundException e) {\n&#x27;
                         &#x27;            // pass\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        final String key = &#x27;
                         &#x27;componentName.flattenToString();\n&#x27;
                         &#x27;        FileOutputStream resourceFile = null;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            resourceFile = &#x27;
                         &#x27;context.openFileOutput(getResourceFilename(componentName),\n&#x27;
                         &#x27;                    Context.MODE_PRIVATE);\n&#x27;
                         &#x27;            ByteArrayOutputStream os = new &#x27;
                         &#x27;ByteArrayOutputStream();\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(icon.compress(android.graphics.Bitmap.CompressFormat.PNG, &#x27;
                         &#x27;75, os)) {\n&#x27;
                         &#x27;                byte[] buffer = os.toByteArray();\n&#x27;
                         &#x27;                resourceFile.write(buffer, 0, &#x27;
                         &#x27;buffer.length);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                Log.w(TAG, &quot;failed to encode cache &#x27;
                         &#x27;for &quot; + key);\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (FileNotFoundException e) {\n&#x27;
                         &#x27;            Log.w(TAG, &quot;failed to pre-load cache for &#x27;
                         &#x27;&quot; + key, e);\n&#x27;
                         &#x27;        } catch (IOException e) {\n&#x27;
                         &#x27;            Log.w(TAG, &quot;failed to pre-load cache for &#x27;
                         &#x27;&quot; + key, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if (resourceFile != null) {\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    resourceFile.close();\n&#x27;
                         &#x27;                } catch (IOException e) {\n&#x27;
                         &#x27;                    Log.d(TAG, &quot;failed to save &#x27;
                         &#x27;restored icon for: &quot; + key, e);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Read a pre-loaded icon from the persistent &#x27;
                         &#x27;icon cache.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param componentName the component that &#x27;
                         &#x27;should own the icon\n&#x27;
                         &#x27;     * @returns a bitmap if one is cached, or null.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private Bitmap getPreloadedIcon(ComponentName &#x27;
                         &#x27;componentName, UserHandleCompat user) {\n&#x27;
                         &#x27;        final String key = &#x27;
                         &#x27;componentName.flattenToShortString();\n&#x27;
                         &#x27;\n&#x27;
                         &quot;        // We don&#x27;t keep icons for other profiles in &quot;
                         &#x27;persistent cache.\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!user.equals(UserHandleCompat.myUserHandle())) {\n&#x27;
                         &#x27;            return null;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (DEBUG) Log.v(TAG, &quot;looking for pre-load &#x27;
                         &#x27;icon for &quot; + key);\n&#x27;
                         &#x27;        Bitmap icon = null;\n&#x27;
                         &#x27;        FileInputStream resourceFile = null;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            resourceFile = &#x27;
                         &#x27;mContext.openFileInput(getResourceFilename(componentName));\n&#x27;
                         &#x27;            byte[] buffer = new byte[1024];\n&#x27;
                         &#x27;            ByteArrayOutputStream bytes = new &#x27;
                         &#x27;ByteArrayOutputStream();\n&#x27;
                         &#x27;            int bytesRead = 0;\n&#x27;
                         &#x27;            while(bytesRead &gt;= 0) {\n&#x27;
                         &#x27;                bytes.write(buffer, 0, bytesRead);\n&#x27;
                         &#x27;                bytesRead = &#x27;
                         &#x27;resourceFile.read(buffer, 0, buffer.length);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            if (DEBUG) Log.d(TAG, &quot;read &quot; + &#x27;
                         &#x27;bytes.size());\n&#x27;
                         &#x27;            icon = &#x27;
                         &#x27;BitmapFactory.decodeByteArray(bytes.toByteArray(), &#x27;
                         &#x27;0, bytes.size());\n&#x27;
                         &#x27;            if (icon == null) {\n&#x27;
                         &#x27;                Log.w(TAG, &quot;failed to decode &#x27;
                         &#x27;pre-load icon for &quot; + key);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (FileNotFoundException e) {\n&#x27;
                         &#x27;            if (DEBUG) Log.d(TAG, &quot;there is no &#x27;
                         &#x27;restored icon for: &quot; + key);\n&#x27;
                         &#x27;        } catch (IOException e) {\n&#x27;
                         &#x27;            Log.w(TAG, &quot;failed to read pre-load icon &#x27;
                         &#x27;for: &quot; + key, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if(resourceFile != null) {\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    resourceFile.close();\n&#x27;
                         &#x27;                } catch (IOException e) {\n&#x27;
                         &#x27;                    Log.d(TAG, &quot;failed to manage &#x27;
                         &#x27;pre-load icon file: &quot; + key, e);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return icon;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Remove a pre-loaded icon from the persistent &#x27;
                         &#x27;icon cache.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param componentName the component that &#x27;
                         &#x27;should own the icon\n&#x27;
                         &#x27;     * @returns true on success\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public boolean deletePreloadedIcon(ComponentName &#x27;
                         &#x27;componentName, UserHandleCompat user) {\n&#x27;
                         &quot;        // We don&#x27;t keep icons for other profiles in &quot;
                         &#x27;persistent cache.\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!user.equals(UserHandleCompat.myUserHandle())) {\n&#x27;
                         &#x27;            return false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (componentName == null) {\n&#x27;
                         &#x27;            return false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mCache.remove(componentName) != null) {\n&#x27;
                         &#x27;            if (DEBUG) Log.d(TAG, &quot;removed &#x27;
                         &#x27;pre-loaded icon from the in-memory cache&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        boolean success = &#x27;
                         &#x27;mContext.deleteFile(getResourceFilename(componentName));\n&#x27;
                         &#x27;        if (DEBUG &amp;&amp; success) Log.d(TAG, &quot;removed &#x27;
                         &#x27;pre-loaded icon from persistent cache&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return success;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static String &#x27;
                         &#x27;getResourceFilename(ComponentName component) {\n&#x27;
                         &#x27;        String resourceName = &#x27;
                         &#x27;component.flattenToShortString();\n&#x27;
                         &#x27;        String filename = &#x27;
                         &quot;resourceName.replace(File.separatorChar, &#x27;_&#x27;);\n&quot;
                         &#x27;        return RESOURCE_FILE_PREFIX + filename;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    static ComponentName getPackageComponent(String &#x27;
                         &#x27;packageName) {\n&#x27;
                         &#x27;        return new ComponentName(packageName, &#x27;
                         &#x27;EMPTY_CLASS_NAME);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}]]</pre>
          </body>
        </html>
        