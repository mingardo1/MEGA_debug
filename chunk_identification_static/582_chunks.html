<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>582 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side.rdb.all;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.AllReqRow;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.SideInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.util.SwitchUtil;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.flink.table.api.DataTypes;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.apache.flink.util.Collector;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import javax.xml.datatype.DatatypeConstants;\n&#x27;
                         &#x27;import java.sql.Connection;\n&#x27;
                         &#x27;import java.sql.ResultSet;\n&#x27;
                         &#x27;import java.sql.SQLException;\n&#x27;
                         &#x27;import java.sql.Statement;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.time.ZoneOffset;\n&#x27;
                         &#x27;import java.util.Calendar;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.concurrent.atomic.AtomicReference;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * side operator with cache for all(period reload)\n&#x27;
                         &#x27; * Date: 2018/11/26\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class RdbAllReqRow extends AllReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635140857937718L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(RdbAllReqRow.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final int CONN_RETRY_NUM = 3;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private AtomicReference&lt;Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new &#x27;
                         &#x27;AtomicReference&lt;&gt;();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RdbAllReqRow(SideInfo sideInfo) {\n&#x27;
                         &#x27;        super(sideInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Row fillData(Row input, Object sideInput) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, &#x27;
                         &#x27;Object&gt;) sideInput;\n&#x27;
                         &#x27;        Row row = new &#x27;
                         &#x27;Row(sideInfo.getOutFieldInfoList().size());\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, Integer&gt; entry : &#x27;
                         &#x27;sideInfo.getInFieldIndex().entrySet()) {\n&#x27;
                         &#x27;            Object obj = &#x27;
                         &#x27;input.getField(entry.getValue());\n&#x27;
                         &#x27;            obj = &#x27;
                         &#x27;convertTimeIndictorTypeInfo(entry.getValue(), obj);\n&#x27;
                         &#x27;            row.setField(entry.getKey(), obj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, String&gt; entry : &#x27;
                         &#x27;sideInfo.getSideFieldNameIndex().entrySet()) {\n&#x27;
                         &#x27;            if (cacheInfo == null) {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), null);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), &#x27;
                         &#x27;cacheInfo.get(entry.getValue()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return row;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void initCache() throws SQLException &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        loadData(newCache);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void reloadCache() {\n&#x27;
                         &#x27;        //reload cacheRef and replace to old &#x27;
                         &#x27;cacheRef\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            loadData(newCache);\n&#x27;
                         &#x27;        } catch (SQLException e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        LOG.info(&quot;----- rdb all cacheRef reload &#x27;
                         &#x27;end:{}&quot;, Calendar.getInstance());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void flatMap(Row value, Collector&lt;Row&gt; &#x27;
                         &#x27;out) throws Exception {\n&#x27;
                         &#x27;        List&lt;Object&gt; inputParams = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;        for (Integer conValIndex : &#x27;
                         &#x27;sideInfo.getEqualValIndex()) {\n&#x27;
                         &#x27;            Object equalObj = &#x27;
                         &#x27;value.getField(conValIndex);\n&#x27;
                         &#x27;            if (equalObj == null) {\n&#x27;
                         &#x27;                if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                    Row row = fillData(value, &#x27;
                         &#x27;null);\n&#x27;
                         &#x27;                    out.collect(row);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            inputParams.add(equalObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String key = buildKey(inputParams);\n&#x27;
                         &#x27;        List&lt;Map&lt;String, Object&gt;&gt; cacheList = &#x27;
                         &#x27;cacheRef.get().get(key);\n&#x27;
                         &#x27;        if (CollectionUtils.isEmpty(cacheList)) {\n&#x27;
                         &#x27;            if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                Row row = fillData(value, null);\n&#x27;
                         &#x27;                out.collect(row);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map&lt;String, Object&gt; one : cacheList) {\n&#x27;
                         &#x27;            out.collect(fillData(value, one));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(List&lt;Object&gt; &#x27;
                         &#x27;equalValList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (Object equalVal : equalValList) {\n&#x27;
                         &#x27;            sb.append(equalVal).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(Map&lt;String, Object&gt; val, &#x27;
                         &#x27;List&lt;String&gt; equalFieldList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (String equalField : equalFieldList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;sb.append(val.get(equalField)).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract Connection getConn(String dbURL, &#x27;
                         &#x27;String userName, String password);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void loadData(Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws &#x27;
                         &#x27;SQLException {\n&#x27;
                         &#x27;        RdbSideTableInfo tableInfo = &#x27;
                         &#x27;(RdbSideTableInfo) sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        Connection connection = null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            for (int i = 0; i &lt; CONN_RETRY_NUM; i++) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    connection = &#x27;
                         &#x27;getConn(tableInfo.getUrl(), tableInfo.getUserName(), &#x27;
                         &#x27;tableInfo.getPassword());\n&#x27;
                         &#x27;                    break;\n&#x27;
                         &#x27;                } catch (Exception e) {\n&#x27;
                         &#x27;                    if (i == CONN_RETRY_NUM - 1) {\n&#x27;
                         &#x27;                        throw new &#x27;
                         &#x27;RuntimeException(&quot;&quot;, e);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        String connInfo = &quot;url:&quot; + &#x27;
                         &#x27;tableInfo.getUrl() + &quot;;userName:&quot; + &#x27;
                         &#x27;tableInfo.getUserName() + &quot;,pwd:&quot; + &#x27;
                         &#x27;tableInfo.getPassword();\n&#x27;
                         &#x27;                        LOG.warn(&quot;get conn fail, &#x27;
                         &#x27;wait for 5 sec and try again, connInfo:&quot; + &#x27;
                         &#x27;connInfo);\n&#x27;
                         &#x27;                        Thread.sleep(5 * 1000);\n&#x27;
                         &#x27;                    } catch (InterruptedException &#x27;
                         &#x27;e1) {\n&#x27;
                         &#x27;                        LOG.error(&quot;&quot;, e1);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //load data from table\n&#x27;
                         &#x27;            String sql = &#x27;
                         &#x27;sideInfo.getSqlCondition();\n&#x27;
                         &#x27;            Statement statement = &#x27;
                         &#x27;connection.createStatement();\n&#x27;
                         &#x27;            statement.setFetchSize(getFetchSize());\n&#x27;
                         &#x27;            ResultSet resultSet = &#x27;
                         &#x27;statement.executeQuery(sql);\n&#x27;
                         &#x27;            String[] sideFieldNames = &#x27;
                         &#x27;sideInfo.getSideSelectFields().split(&quot;,&quot;);\n&#x27;
                         &#x27;            String[] fields = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldTypes();\n&#x27;
                         &#x27;            while (resultSet.next()) {\n&#x27;
                         &#x27;                Map&lt;String, Object&gt; oneRow = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;                for (String fieldName : &#x27;
                         &#x27;sideFieldNames) {\n&#x27;
                         &#x27;                    Object object = &#x27;
                         &#x27;resultSet.getObject(fieldName.trim());\n&#x27;
                         &#x27;                    int fieldIndex = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());\n&#x27;
                         &#x27;                    object = &#x27;
                         &#x27;SwitchUtil.getTarget(object, fields[fieldIndex]);\n&#x27;
                         &#x27;                    oneRow.put(fieldName.trim(), &#x27;
                         &#x27;object);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                String cacheKey = buildKey(oneRow, &#x27;
                         &#x27;sideInfo.getEqualFieldList());\n&#x27;
                         &#x27;                List&lt;Map&lt;String, Object&gt;&gt; list = &#x27;
                         &#x27;tmpCache.computeIfAbsent(cacheKey, key -&gt; &#x27;
                         &#x27;Lists.newArrayList());\n&#x27;
                         &#x27;                list.add(oneRow);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (Exception e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if (connection != null) {\n&#x27;
                         &#x27;                connection.close();\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public int getFetchSize() {\n&#x27;
                         &#x27;        return 1000;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side.rdb.all;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.AllReqRow;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.SideInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.util.SwitchUtil;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.flink.table.api.DataTypes;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.apache.flink.util.Collector;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import javax.xml.datatype.DatatypeConstants;\n&#x27;
                         &#x27;import java.sql.Connection;\n&#x27;
                         &#x27;import java.sql.ResultSet;\n&#x27;
                         &#x27;import java.sql.SQLException;\n&#x27;
                         &#x27;import java.sql.Statement;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.time.ZoneOffset;\n&#x27;
                         &#x27;import java.util.Calendar;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.concurrent.atomic.AtomicReference;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * side operator with cache for all(period reload)\n&#x27;
                         &#x27; * Date: 2018/11/26\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class RdbAllReqRow extends AllReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635140857937718L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(RdbAllReqRow.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final int CONN_RETRY_NUM = 3;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private AtomicReference&lt;Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new &#x27;
                         &#x27;AtomicReference&lt;&gt;();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RdbAllReqRow(SideInfo sideInfo) {\n&#x27;
                         &#x27;        super(sideInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Row fillData(Row input, Object sideInput) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, &#x27;
                         &#x27;Object&gt;) sideInput;\n&#x27;
                         &#x27;        Row row = new &#x27;
                         &#x27;Row(sideInfo.getOutFieldInfoList().size());\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, Integer&gt; entry : &#x27;
                         &#x27;sideInfo.getInFieldIndex().entrySet()) {\n&#x27;
                         &#x27;            Object obj = &#x27;
                         &#x27;input.getField(entry.getValue());\n&#x27;
                         &#x27;            obj = &#x27;
                         &#x27;convertTimeIndictorTypeInfo(entry.getValue(), obj);\n&#x27;
                         &#x27;            row.setField(entry.getKey(), obj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, String&gt; entry : &#x27;
                         &#x27;sideInfo.getSideFieldNameIndex().entrySet()) {\n&#x27;
                         &#x27;            if (cacheInfo == null) {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), null);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), &#x27;
                         &#x27;cacheInfo.get(entry.getValue()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return row;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void initCache() throws SQLException &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        loadData(newCache);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void reloadCache() {\n&#x27;
                         &#x27;        //reload cacheRef and replace to old &#x27;
                         &#x27;cacheRef\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            loadData(newCache);\n&#x27;
                         &#x27;        } catch (SQLException e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        LOG.info(&quot;----- rdb all cacheRef reload &#x27;
                         &#x27;end:{}&quot;, Calendar.getInstance());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void flatMap(Row value, Collector&lt;Row&gt; &#x27;
                         &#x27;out) throws Exception {\n&#x27;
                         &#x27;        List&lt;Object&gt; inputParams = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;        for (Integer conValIndex : &#x27;
                         &#x27;sideInfo.getEqualValIndex()) {\n&#x27;
                         &#x27;            Object equalObj = &#x27;
                         &#x27;value.getField(conValIndex);\n&#x27;
                         &#x27;            if (equalObj == null) {\n&#x27;
                         &#x27;                if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                    Row row = fillData(value, &#x27;
                         &#x27;null);\n&#x27;
                         &#x27;                    out.collect(row);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            inputParams.add(equalObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String key = buildKey(inputParams);\n&#x27;
                         &#x27;        List&lt;Map&lt;String, Object&gt;&gt; cacheList = &#x27;
                         &#x27;cacheRef.get().get(key);\n&#x27;
                         &#x27;        if (CollectionUtils.isEmpty(cacheList)) {\n&#x27;
                         &#x27;            if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                Row row = fillData(value, null);\n&#x27;
                         &#x27;                out.collect(row);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map&lt;String, Object&gt; one : cacheList) {\n&#x27;
                         &#x27;            out.collect(fillData(value, one));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(List&lt;Object&gt; &#x27;
                         &#x27;equalValList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (Object equalVal : equalValList) {\n&#x27;
                         &#x27;            sb.append(equalVal).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(Map&lt;String, Object&gt; val, &#x27;
                         &#x27;List&lt;String&gt; equalFieldList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (String equalField : equalFieldList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;sb.append(val.get(equalField)).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract Connection getConn(String dbURL, &#x27;
                         &#x27;String userName, String password);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void loadData(Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws &#x27;
                         &#x27;SQLException {\n&#x27;
                         &#x27;        RdbSideTableInfo tableInfo = &#x27;
                         &#x27;(RdbSideTableInfo) sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        Connection connection = null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            for (int i = 0; i &lt; CONN_RETRY_NUM; i++) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    connection = &#x27;
                         &#x27;getConn(tableInfo.getUrl(), tableInfo.getUserName(), &#x27;
                         &#x27;tableInfo.getPassword());\n&#x27;
                         &#x27;                    break;\n&#x27;
                         &#x27;                } catch (Exception e) {\n&#x27;
                         &#x27;                    if (i == CONN_RETRY_NUM - 1) {\n&#x27;
                         &#x27;                        throw new &#x27;
                         &#x27;RuntimeException(&quot;&quot;, e);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        String connInfo = &quot;url:&quot; + &#x27;
                         &#x27;tableInfo.getUrl() + &quot;;userName:&quot; + &#x27;
                         &#x27;tableInfo.getUserName() + &quot;,pwd:&quot; + &#x27;
                         &#x27;tableInfo.getPassword();\n&#x27;
                         &#x27;                        LOG.warn(&quot;get conn fail, &#x27;
                         &#x27;wait for 5 sec and try again, connInfo:&quot; + &#x27;
                         &#x27;connInfo);\n&#x27;
                         &#x27;                        Thread.sleep(5 * 1000);\n&#x27;
                         &#x27;                    } catch (InterruptedException &#x27;
                         &#x27;e1) {\n&#x27;
                         &#x27;                        LOG.error(&quot;&quot;, e1);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //load data from table\n&#x27;
                         &#x27;            String sql = &#x27;
                         &#x27;sideInfo.getSqlCondition();\n&#x27;
                         &#x27;            Statement statement = &#x27;
                         &#x27;connection.createStatement();\n&#x27;
                         &#x27;            statement.setFetchSize(getFetchSize());\n&#x27;
                         &#x27;            ResultSet resultSet = &#x27;
                         &#x27;statement.executeQuery(sql);\n&#x27;
                         &#x27;            String[] sideFieldNames = &#x27;
                         &#x27;sideInfo.getSideSelectFields().split(&quot;,&quot;);\n&#x27;
                         &#x27;            String[] fields = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldTypes();\n&#x27;
                         &#x27;            while (resultSet.next()) {\n&#x27;
                         &#x27;                Map&lt;String, Object&gt; oneRow = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;                for (String fieldName : &#x27;
                         &#x27;sideFieldNames) {\n&#x27;
                         &#x27;                    Object object = &#x27;
                         &#x27;resultSet.getObject(fieldName.trim());\n&#x27;
                         &#x27;                    int fieldIndex = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());\n&#x27;
                         &#x27;                    object = &#x27;
                         &#x27;SwitchUtil.getTarget(object, fields[fieldIndex]);\n&#x27;
                         &#x27;                    oneRow.put(fieldName.trim(), &#x27;
                         &#x27;object);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                String cacheKey = buildKey(oneRow, &#x27;
                         &#x27;sideInfo.getEqualFieldList());\n&#x27;
                         &#x27;                List&lt;Map&lt;String, Object&gt;&gt; list = &#x27;
                         &#x27;tmpCache.computeIfAbsent(cacheKey, key -&gt; &#x27;
                         &#x27;Lists.newArrayList());\n&#x27;
                         &#x27;                list.add(oneRow);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (Exception e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if (connection != null) {\n&#x27;
                         &#x27;                connection.close();\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public int getFetchSize() {\n&#x27;
                         &#x27;        return 1000;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side.rdb.all;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.AllReqRow;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.SideInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.util.SwitchUtil;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.flink.table.api.DataTypes;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.apache.flink.util.Collector;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import javax.xml.datatype.DatatypeConstants;\n&#x27;
                         &#x27;import java.sql.Connection;\n&#x27;
                         &#x27;import java.sql.ResultSet;\n&#x27;
                         &#x27;import java.sql.SQLException;\n&#x27;
                         &#x27;import java.sql.Statement;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.time.ZoneOffset;\n&#x27;
                         &#x27;import java.util.Calendar;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.concurrent.atomic.AtomicReference;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * side operator with cache for all(period reload)\n&#x27;
                         &#x27; * Date: 2018/11/26\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class RdbAllReqRow extends AllReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635140857937718L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(RdbAllReqRow.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final int CONN_RETRY_NUM = 3;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private AtomicReference&lt;Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new &#x27;
                         &#x27;AtomicReference&lt;&gt;();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RdbAllReqRow(SideInfo sideInfo) {\n&#x27;
                         &#x27;        super(sideInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Row fillData(Row input, Object sideInput) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, &#x27;
                         &#x27;Object&gt;) sideInput;\n&#x27;
                         &#x27;        Row row = new &#x27;
                         &#x27;Row(sideInfo.getOutFieldInfoList().size());\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, Integer&gt; entry : &#x27;
                         &#x27;sideInfo.getInFieldIndex().entrySet()) {\n&#x27;
                         &#x27;            Object obj = &#x27;
                         &#x27;input.getField(entry.getValue());\n&#x27;
                         &#x27;            obj = &#x27;
                         &#x27;convertTimeIndictorTypeInfo(entry.getValue(), obj);\n&#x27;
                         &#x27;            row.setField(entry.getKey(), obj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, String&gt; entry : &#x27;
                         &#x27;sideInfo.getSideFieldNameIndex().entrySet()) {\n&#x27;
                         &#x27;            if (cacheInfo == null) {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), null);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), &#x27;
                         &#x27;cacheInfo.get(entry.getValue()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return row;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void initCache() throws SQLException &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        loadData(newCache);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void reloadCache() {\n&#x27;
                         &#x27;        //reload cacheRef and replace to old &#x27;
                         &#x27;cacheRef\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            loadData(newCache);\n&#x27;
                         &#x27;        } catch (SQLException e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        LOG.info(&quot;----- rdb all cacheRef reload &#x27;
                         &#x27;end:{}&quot;, Calendar.getInstance());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void flatMap(Row value, Collector&lt;Row&gt; &#x27;
                         &#x27;out) throws Exception {\n&#x27;
                         &#x27;        List&lt;Object&gt; inputParams = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;        for (Integer conValIndex : &#x27;
                         &#x27;sideInfo.getEqualValIndex()) {\n&#x27;
                         &#x27;            Object equalObj = &#x27;
                         &#x27;value.getField(conValIndex);\n&#x27;
                         &#x27;            if (equalObj == null) {\n&#x27;
                         &#x27;                if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                    Row row = fillData(value, &#x27;
                         &#x27;null);\n&#x27;
                         &#x27;                    out.collect(row);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            inputParams.add(equalObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String key = buildKey(inputParams);\n&#x27;
                         &#x27;        List&lt;Map&lt;String, Object&gt;&gt; cacheList = &#x27;
                         &#x27;cacheRef.get().get(key);\n&#x27;
                         &#x27;        if (CollectionUtils.isEmpty(cacheList)) {\n&#x27;
                         &#x27;            if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                Row row = fillData(value, null);\n&#x27;
                         &#x27;                out.collect(row);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map&lt;String, Object&gt; one : cacheList) {\n&#x27;
                         &#x27;            out.collect(fillData(value, one));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(List&lt;Object&gt; &#x27;
                         &#x27;equalValList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (Object equalVal : equalValList) {\n&#x27;
                         &#x27;            sb.append(equalVal).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(Map&lt;String, Object&gt; val, &#x27;
                         &#x27;List&lt;String&gt; equalFieldList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (String equalField : equalFieldList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;sb.append(val.get(equalField)).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract Connection getConn(String dbURL, &#x27;
                         &#x27;String userName, String password);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void loadData(Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws &#x27;
                         &#x27;SQLException {\n&#x27;
                         &#x27;        RdbSideTableInfo tableInfo = &#x27;
                         &#x27;(RdbSideTableInfo) sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        Connection connection = null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            for (int i = 0; i &lt; CONN_RETRY_NUM; i++) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    connection = &#x27;
                         &#x27;getConn(tableInfo.getUrl(), tableInfo.getUserName(), &#x27;
                         &#x27;tableInfo.getPassword());\n&#x27;
                         &#x27;                    break;\n&#x27;
                         &#x27;                } catch (Exception e) {\n&#x27;
                         &#x27;                    if (i == CONN_RETRY_NUM - 1) {\n&#x27;
                         &#x27;                        throw new &#x27;
                         &#x27;RuntimeException(&quot;&quot;, e);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        String connInfo = &quot;url:&quot; + &#x27;
                         &#x27;tableInfo.getUrl() + &quot;;userName:&quot; + &#x27;
                         &#x27;tableInfo.getUserName() + &quot;,pwd:&quot; + &#x27;
                         &#x27;tableInfo.getPassword();\n&#x27;
                         &#x27;                        LOG.warn(&quot;get conn fail, &#x27;
                         &#x27;wait for 5 sec and try again, connInfo:&quot; + &#x27;
                         &#x27;connInfo);\n&#x27;
                         &#x27;                        Thread.sleep(5 * 1000);\n&#x27;
                         &#x27;                    } catch (InterruptedException &#x27;
                         &#x27;e1) {\n&#x27;
                         &#x27;                        LOG.error(&quot;&quot;, e1);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //load data from table\n&#x27;
                         &#x27;            String sql = &#x27;
                         &#x27;sideInfo.getSqlCondition();\n&#x27;
                         &#x27;            Statement statement = &#x27;
                         &#x27;connection.createStatement();\n&#x27;
                         &#x27;            statement.setFetchSize(getFetchSize());\n&#x27;
                         &#x27;            ResultSet resultSet = &#x27;
                         &#x27;statement.executeQuery(sql);\n&#x27;
                         &#x27;            String[] sideFieldNames = &#x27;
                         &#x27;sideInfo.getSideSelectFields().split(&quot;,&quot;);\n&#x27;
                         &#x27;            String[] fields = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldTypes();\n&#x27;
                         &#x27;            while (resultSet.next()) {\n&#x27;
                         &#x27;                Map&lt;String, Object&gt; oneRow = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;                for (String fieldName : &#x27;
                         &#x27;sideFieldNames) {\n&#x27;
                         &#x27;                    Object object = &#x27;
                         &#x27;resultSet.getObject(fieldName.trim());\n&#x27;
                         &#x27;                    int fieldIndex = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());\n&#x27;
                         &#x27;                    object = &#x27;
                         &#x27;SwitchUtil.getTarget(object, fields[fieldIndex]);\n&#x27;
                         &#x27;                    oneRow.put(fieldName.trim(), &#x27;
                         &#x27;object);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                String cacheKey = buildKey(oneRow, &#x27;
                         &#x27;sideInfo.getEqualFieldList());\n&#x27;
                         &#x27;                List&lt;Map&lt;String, Object&gt;&gt; list = &#x27;
                         &#x27;tmpCache.computeIfAbsent(cacheKey, key -&gt; &#x27;
                         &#x27;Lists.newArrayList());\n&#x27;
                         &#x27;                list.add(oneRow);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (Exception e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if (connection != null) {\n&#x27;
                         &#x27;                connection.close();\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public int getFetchSize() {\n&#x27;
                         &#x27;        return 1000;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side.rdb.all;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.AllReqRow;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.SideInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.util.SwitchUtil;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.flink.table.api.DataTypes;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.apache.flink.util.Collector;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import javax.xml.datatype.DatatypeConstants;\n&#x27;
                         &#x27;import java.sql.Connection;\n&#x27;
                         &#x27;import java.sql.ResultSet;\n&#x27;
                         &#x27;import java.sql.SQLException;\n&#x27;
                         &#x27;import java.sql.Statement;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.time.ZoneOffset;\n&#x27;
                         &#x27;import java.util.Calendar;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.concurrent.atomic.AtomicReference;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * side operator with cache for all(period reload)\n&#x27;
                         &#x27; * Date: 2018/11/26\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class RdbAllReqRow extends AllReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635140857937718L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(RdbAllReqRow.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final int CONN_RETRY_NUM = 3;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private AtomicReference&lt;Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new &#x27;
                         &#x27;AtomicReference&lt;&gt;();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RdbAllReqRow(SideInfo sideInfo) {\n&#x27;
                         &#x27;        super(sideInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Row fillData(Row input, Object sideInput) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, &#x27;
                         &#x27;Object&gt;) sideInput;\n&#x27;
                         &#x27;        Row row = new &#x27;
                         &#x27;Row(sideInfo.getOutFieldInfoList().size());\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, Integer&gt; entry : &#x27;
                         &#x27;sideInfo.getInFieldIndex().entrySet()) {\n&#x27;
                         &#x27;            Object obj = &#x27;
                         &#x27;input.getField(entry.getValue());\n&#x27;
                         &#x27;            obj = &#x27;
                         &#x27;convertTimeIndictorTypeInfo(entry.getValue(), obj);\n&#x27;
                         &#x27;            row.setField(entry.getKey(), obj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, String&gt; entry : &#x27;
                         &#x27;sideInfo.getSideFieldNameIndex().entrySet()) {\n&#x27;
                         &#x27;            if (cacheInfo == null) {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), null);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), &#x27;
                         &#x27;cacheInfo.get(entry.getValue()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return row;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void initCache() throws SQLException &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        loadData(newCache);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void reloadCache() {\n&#x27;
                         &#x27;        //reload cacheRef and replace to old &#x27;
                         &#x27;cacheRef\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            loadData(newCache);\n&#x27;
                         &#x27;        } catch (SQLException e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        LOG.info(&quot;----- rdb all cacheRef reload &#x27;
                         &#x27;end:{}&quot;, Calendar.getInstance());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void flatMap(Row value, Collector&lt;Row&gt; &#x27;
                         &#x27;out) throws Exception {\n&#x27;
                         &#x27;        List&lt;Object&gt; inputParams = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;        for (Integer conValIndex : &#x27;
                         &#x27;sideInfo.getEqualValIndex()) {\n&#x27;
                         &#x27;            Object equalObj = &#x27;
                         &#x27;value.getField(conValIndex);\n&#x27;
                         &#x27;            if (equalObj == null) {\n&#x27;
                         &#x27;                if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                    Row row = fillData(value, &#x27;
                         &#x27;null);\n&#x27;
                         &#x27;                    out.collect(row);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            inputParams.add(equalObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String key = buildKey(inputParams);\n&#x27;
                         &#x27;        List&lt;Map&lt;String, Object&gt;&gt; cacheList = &#x27;
                         &#x27;cacheRef.get().get(key);\n&#x27;
                         &#x27;        if (CollectionUtils.isEmpty(cacheList)) {\n&#x27;
                         &#x27;            if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                Row row = fillData(value, null);\n&#x27;
                         &#x27;                out.collect(row);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map&lt;String, Object&gt; one : cacheList) {\n&#x27;
                         &#x27;            out.collect(fillData(value, one));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(List&lt;Object&gt; &#x27;
                         &#x27;equalValList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (Object equalVal : equalValList) {\n&#x27;
                         &#x27;            sb.append(equalVal).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(Map&lt;String, Object&gt; val, &#x27;
                         &#x27;List&lt;String&gt; equalFieldList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (String equalField : equalFieldList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;sb.append(val.get(equalField)).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract Connection getConn(String dbURL, &#x27;
                         &#x27;String userName, String password);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void loadData(Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws &#x27;
                         &#x27;SQLException {\n&#x27;
                         &#x27;        RdbSideTableInfo tableInfo = &#x27;
                         &#x27;(RdbSideTableInfo) sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        Connection connection = null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            for (int i = 0; i &lt; CONN_RETRY_NUM; i++) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    connection = &#x27;
                         &#x27;getConn(tableInfo.getUrl(), tableInfo.getUserName(), &#x27;
                         &#x27;tableInfo.getPassword());\n&#x27;
                         &#x27;                    break;\n&#x27;
                         &#x27;                } catch (Exception e) {\n&#x27;
                         &#x27;                    if (i == CONN_RETRY_NUM - 1) {\n&#x27;
                         &#x27;                        throw new &#x27;
                         &#x27;RuntimeException(&quot;&quot;, e);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        String connInfo = &quot;url:&quot; + &#x27;
                         &#x27;tableInfo.getUrl() + &quot;;userName:&quot; + &#x27;
                         &#x27;tableInfo.getUserName() + &quot;,pwd:&quot; + &#x27;
                         &#x27;tableInfo.getPassword();\n&#x27;
                         &#x27;                        LOG.warn(&quot;get conn fail, &#x27;
                         &#x27;wait for 5 sec and try again, connInfo:&quot; + &#x27;
                         &#x27;connInfo);\n&#x27;
                         &#x27;                        Thread.sleep(5 * 1000);\n&#x27;
                         &#x27;                    } catch (InterruptedException &#x27;
                         &#x27;e1) {\n&#x27;
                         &#x27;                        LOG.error(&quot;&quot;, e1);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //load data from table\n&#x27;
                         &#x27;            String sql = &#x27;
                         &#x27;sideInfo.getSqlCondition();\n&#x27;
                         &#x27;            Statement statement = &#x27;
                         &#x27;connection.createStatement();\n&#x27;
                         &#x27;            statement.setFetchSize(getFetchSize());\n&#x27;
                         &#x27;            ResultSet resultSet = &#x27;
                         &#x27;statement.executeQuery(sql);\n&#x27;
                         &#x27;            String[] sideFieldNames = &#x27;
                         &#x27;sideInfo.getSideSelectFields().split(&quot;,&quot;);\n&#x27;
                         &#x27;            String[] fields = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldTypes();\n&#x27;
                         &#x27;            while (resultSet.next()) {\n&#x27;
                         &#x27;                Map&lt;String, Object&gt; oneRow = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;                for (String fieldName : &#x27;
                         &#x27;sideFieldNames) {\n&#x27;
                         &#x27;                    Object object = &#x27;
                         &#x27;resultSet.getObject(fieldName.trim());\n&#x27;
                         &#x27;                    int fieldIndex = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());\n&#x27;
                         &#x27;                    object = &#x27;
                         &#x27;SwitchUtil.getTarget(object, fields[fieldIndex]);\n&#x27;
                         &#x27;                    oneRow.put(fieldName.trim(), &#x27;
                         &#x27;object);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                String cacheKey = buildKey(oneRow, &#x27;
                         &#x27;sideInfo.getEqualFieldList());\n&#x27;
                         &#x27;                List&lt;Map&lt;String, Object&gt;&gt; list = &#x27;
                         &#x27;tmpCache.computeIfAbsent(cacheKey, key -&gt; &#x27;
                         &#x27;Lists.newArrayList());\n&#x27;
                         &#x27;                list.add(oneRow);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (Exception e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if (connection != null) {\n&#x27;
                         &#x27;                connection.close();\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public int getFetchSize() {\n&#x27;
                         &#x27;        return 1000;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side.rdb.all;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.AllReqRow;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.SideInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.util.SwitchUtil;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.flink.table.api.DataTypes;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.apache.flink.util.Collector;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import javax.xml.datatype.DatatypeConstants;\n&#x27;
                         &#x27;import java.sql.Connection;\n&#x27;
                         &#x27;import java.sql.ResultSet;\n&#x27;
                         &#x27;import java.sql.SQLException;\n&#x27;
                         &#x27;import java.sql.Statement;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.time.ZoneOffset;\n&#x27;
                         &#x27;import java.util.Calendar;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.concurrent.atomic.AtomicReference;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * side operator with cache for all(period reload)\n&#x27;
                         &#x27; * Date: 2018/11/26\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class RdbAllReqRow extends AllReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635140857937718L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(RdbAllReqRow.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final int CONN_RETRY_NUM = 3;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private AtomicReference&lt;Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new &#x27;
                         &#x27;AtomicReference&lt;&gt;();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RdbAllReqRow(SideInfo sideInfo) {\n&#x27;
                         &#x27;        super(sideInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Row fillData(Row input, Object sideInput) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, &#x27;
                         &#x27;Object&gt;) sideInput;\n&#x27;
                         &#x27;        Row row = new &#x27;
                         &#x27;Row(sideInfo.getOutFieldInfoList().size());\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, Integer&gt; entry : &#x27;
                         &#x27;sideInfo.getInFieldIndex().entrySet()) {\n&#x27;
                         &#x27;            Object obj = &#x27;
                         &#x27;input.getField(entry.getValue());\n&#x27;
                         &#x27;            obj = &#x27;
                         &#x27;convertTimeIndictorTypeInfo(entry.getValue(), obj);\n&#x27;
                         &#x27;            row.setField(entry.getKey(), obj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, String&gt; entry : &#x27;
                         &#x27;sideInfo.getSideFieldNameIndex().entrySet()) {\n&#x27;
                         &#x27;            if (cacheInfo == null) {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), null);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), &#x27;
                         &#x27;cacheInfo.get(entry.getValue()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return row;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void initCache() throws SQLException &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        loadData(newCache);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void reloadCache() {\n&#x27;
                         &#x27;        //reload cacheRef and replace to old &#x27;
                         &#x27;cacheRef\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            loadData(newCache);\n&#x27;
                         &#x27;        } catch (SQLException e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        LOG.info(&quot;----- rdb all cacheRef reload &#x27;
                         &#x27;end:{}&quot;, Calendar.getInstance());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void flatMap(Row value, Collector&lt;Row&gt; &#x27;
                         &#x27;out) throws Exception {\n&#x27;
                         &#x27;        List&lt;Object&gt; inputParams = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;        for (Integer conValIndex : &#x27;
                         &#x27;sideInfo.getEqualValIndex()) {\n&#x27;
                         &#x27;            Object equalObj = &#x27;
                         &#x27;value.getField(conValIndex);\n&#x27;
                         &#x27;            if (equalObj == null) {\n&#x27;
                         &#x27;                if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                    Row row = fillData(value, &#x27;
                         &#x27;null);\n&#x27;
                         &#x27;                    out.collect(row);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            inputParams.add(equalObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String key = buildKey(inputParams);\n&#x27;
                         &#x27;        List&lt;Map&lt;String, Object&gt;&gt; cacheList = &#x27;
                         &#x27;cacheRef.get().get(key);\n&#x27;
                         &#x27;        if (CollectionUtils.isEmpty(cacheList)) {\n&#x27;
                         &#x27;            if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                Row row = fillData(value, null);\n&#x27;
                         &#x27;                out.collect(row);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map&lt;String, Object&gt; one : cacheList) {\n&#x27;
                         &#x27;            out.collect(fillData(value, one));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(List&lt;Object&gt; &#x27;
                         &#x27;equalValList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (Object equalVal : equalValList) {\n&#x27;
                         &#x27;            sb.append(equalVal).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(Map&lt;String, Object&gt; val, &#x27;
                         &#x27;List&lt;String&gt; equalFieldList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (String equalField : equalFieldList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;sb.append(val.get(equalField)).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract Connection getConn(String dbURL, &#x27;
                         &#x27;String userName, String password);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void loadData(Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws &#x27;
                         &#x27;SQLException {\n&#x27;
                         &#x27;        RdbSideTableInfo tableInfo = &#x27;
                         &#x27;(RdbSideTableInfo) sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        Connection connection = null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            for (int i = 0; i &lt; CONN_RETRY_NUM; i++) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    connection = &#x27;
                         &#x27;getConn(tableInfo.getUrl(), tableInfo.getUserName(), &#x27;
                         &#x27;tableInfo.getPassword());\n&#x27;
                         &#x27;                    break;\n&#x27;
                         &#x27;                } catch (Exception e) {\n&#x27;
                         &#x27;                    if (i == CONN_RETRY_NUM - 1) {\n&#x27;
                         &#x27;                        throw new &#x27;
                         &#x27;RuntimeException(&quot;&quot;, e);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        String connInfo = &quot;url:&quot; + &#x27;
                         &#x27;tableInfo.getUrl() + &quot;;userName:&quot; + &#x27;
                         &#x27;tableInfo.getUserName() + &quot;,pwd:&quot; + &#x27;
                         &#x27;tableInfo.getPassword();\n&#x27;
                         &#x27;                        LOG.warn(&quot;get conn fail, &#x27;
                         &#x27;wait for 5 sec and try again, connInfo:&quot; + &#x27;
                         &#x27;connInfo);\n&#x27;
                         &#x27;                        Thread.sleep(5 * 1000);\n&#x27;
                         &#x27;                    } catch (InterruptedException &#x27;
                         &#x27;e1) {\n&#x27;
                         &#x27;                        LOG.error(&quot;&quot;, e1);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //load data from table\n&#x27;
                         &#x27;            String sql = &#x27;
                         &#x27;sideInfo.getSqlCondition();\n&#x27;
                         &#x27;            Statement statement = &#x27;
                         &#x27;connection.createStatement();\n&#x27;
                         &#x27;            statement.setFetchSize(getFetchSize());\n&#x27;
                         &#x27;            ResultSet resultSet = &#x27;
                         &#x27;statement.executeQuery(sql);\n&#x27;
                         &#x27;            String[] sideFieldNames = &#x27;
                         &#x27;sideInfo.getSideSelectFields().split(&quot;,&quot;);\n&#x27;
                         &#x27;            String[] fields = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldTypes();\n&#x27;
                         &#x27;            while (resultSet.next()) {\n&#x27;
                         &#x27;                Map&lt;String, Object&gt; oneRow = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;                for (String fieldName : &#x27;
                         &#x27;sideFieldNames) {\n&#x27;
                         &#x27;                    Object object = &#x27;
                         &#x27;resultSet.getObject(fieldName.trim());\n&#x27;
                         &#x27;                    int fieldIndex = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());\n&#x27;
                         &#x27;                    object = &#x27;
                         &#x27;SwitchUtil.getTarget(object, fields[fieldIndex]);\n&#x27;
                         &#x27;                    oneRow.put(fieldName.trim(), &#x27;
                         &#x27;object);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                String cacheKey = buildKey(oneRow, &#x27;
                         &#x27;sideInfo.getEqualFieldList());\n&#x27;
                         &#x27;                List&lt;Map&lt;String, Object&gt;&gt; list = &#x27;
                         &#x27;tmpCache.computeIfAbsent(cacheKey, key -&gt; &#x27;
                         &#x27;Lists.newArrayList());\n&#x27;
                         &#x27;                list.add(oneRow);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (Exception e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if (connection != null) {\n&#x27;
                         &#x27;                connection.close();\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public int getFetchSize() {\n&#x27;
                         &#x27;        return 1000;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side.rdb.all;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.AllReqRow;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.SideInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.rdb.util.SwitchUtil;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.commons.collections.CollectionUtils;\n&#x27;
                         &#x27;import com.google.common.collect.Lists;\n&#x27;
                         &#x27;import com.google.common.collect.Maps;\n&#x27;
                         &#x27;import org.apache.flink.table.api.DataTypes;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.apache.flink.util.Collector;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import javax.xml.datatype.DatatypeConstants;\n&#x27;
                         &#x27;import java.sql.Connection;\n&#x27;
                         &#x27;import java.sql.ResultSet;\n&#x27;
                         &#x27;import java.sql.SQLException;\n&#x27;
                         &#x27;import java.sql.Statement;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.time.ZoneOffset;\n&#x27;
                         &#x27;import java.util.Calendar;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;import java.util.concurrent.atomic.AtomicReference;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * side operator with cache for all(period reload)\n&#x27;
                         &#x27; * Date: 2018/11/26\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class RdbAllReqRow extends AllReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635140857937718L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(RdbAllReqRow.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final int CONN_RETRY_NUM = 3;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private AtomicReference&lt;Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new &#x27;
                         &#x27;AtomicReference&lt;&gt;();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RdbAllReqRow(SideInfo sideInfo) {\n&#x27;
                         &#x27;        super(sideInfo);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public Row fillData(Row input, Object sideInput) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, &#x27;
                         &#x27;Object&gt;) sideInput;\n&#x27;
                         &#x27;        Row row = new &#x27;
                         &#x27;Row(sideInfo.getOutFieldInfoList().size());\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, Integer&gt; entry : &#x27;
                         &#x27;sideInfo.getInFieldIndex().entrySet()) {\n&#x27;
                         &#x27;            Object obj = &#x27;
                         &#x27;input.getField(entry.getValue());\n&#x27;
                         &#x27;            obj = &#x27;
                         &#x27;convertTimeIndictorTypeInfo(entry.getValue(), obj);\n&#x27;
                         &#x27;            row.setField(entry.getKey(), obj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map.Entry&lt;Integer, String&gt; entry : &#x27;
                         &#x27;sideInfo.getSideFieldNameIndex().entrySet()) {\n&#x27;
                         &#x27;            if (cacheInfo == null) {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), null);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                row.setField(entry.getKey(), &#x27;
                         &#x27;cacheInfo.get(entry.getValue()));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return row;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void initCache() throws SQLException &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        loadData(newCache);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    protected void reloadCache() {\n&#x27;
                         &#x27;        //reload cacheRef and replace to old &#x27;
                         &#x27;cacheRef\n&#x27;
                         &#x27;        Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; &#x27;
                         &#x27;newCache = Maps.newConcurrentMap();\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            loadData(newCache);\n&#x27;
                         &#x27;        } catch (SQLException e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        cacheRef.set(newCache);\n&#x27;
                         &#x27;        LOG.info(&quot;----- rdb all cacheRef reload &#x27;
                         &#x27;end:{}&quot;, Calendar.getInstance());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void flatMap(Row value, Collector&lt;Row&gt; &#x27;
                         &#x27;out) throws Exception {\n&#x27;
                         &#x27;        List&lt;Object&gt; inputParams = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;        for (Integer conValIndex : &#x27;
                         &#x27;sideInfo.getEqualValIndex()) {\n&#x27;
                         &#x27;            Object equalObj = &#x27;
                         &#x27;value.getField(conValIndex);\n&#x27;
                         &#x27;            if (equalObj == null) {\n&#x27;
                         &#x27;                if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                    Row row = fillData(value, &#x27;
                         &#x27;null);\n&#x27;
                         &#x27;                    out.collect(row);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            inputParams.add(equalObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String key = buildKey(inputParams);\n&#x27;
                         &#x27;        List&lt;Map&lt;String, Object&gt;&gt; cacheList = &#x27;
                         &#x27;cacheRef.get().get(key);\n&#x27;
                         &#x27;        if (CollectionUtils.isEmpty(cacheList)) {\n&#x27;
                         &#x27;            if (sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT) {\n&#x27;
                         &#x27;                Row row = fillData(value, null);\n&#x27;
                         &#x27;                out.collect(row);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                return;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (Map&lt;String, Object&gt; one : cacheList) {\n&#x27;
                         &#x27;            out.collect(fillData(value, one));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(List&lt;Object&gt; &#x27;
                         &#x27;equalValList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (Object equalVal : equalValList) {\n&#x27;
                         &#x27;            sb.append(equalVal).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String buildKey(Map&lt;String, Object&gt; val, &#x27;
                         &#x27;List&lt;String&gt; equalFieldList) {\n&#x27;
                         &#x27;        StringBuilder sb = new StringBuilder(&quot;&quot;);\n&#x27;
                         &#x27;        for (String equalField : equalFieldList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;sb.append(val.get(equalField)).append(&quot;_&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        return sb.toString();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract Connection getConn(String dbURL, &#x27;
                         &#x27;String userName, String password);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void loadData(Map&lt;String, &#x27;
                         &#x27;List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws &#x27;
                         &#x27;SQLException {\n&#x27;
                         &#x27;        RdbSideTableInfo tableInfo = &#x27;
                         &#x27;(RdbSideTableInfo) sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        Connection connection = null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            for (int i = 0; i &lt; CONN_RETRY_NUM; i++) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                try {\n&#x27;
                         &#x27;                    connection = &#x27;
                         &#x27;getConn(tableInfo.getUrl(), tableInfo.getUserName(), &#x27;
                         &#x27;tableInfo.getPassword());\n&#x27;
                         &#x27;                    break;\n&#x27;
                         &#x27;                } catch (Exception e) {\n&#x27;
                         &#x27;                    if (i == CONN_RETRY_NUM - 1) {\n&#x27;
                         &#x27;                        throw new &#x27;
                         &#x27;RuntimeException(&quot;&quot;, e);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        String connInfo = &quot;url:&quot; + &#x27;
                         &#x27;tableInfo.getUrl() + &quot;;userName:&quot; + &#x27;
                         &#x27;tableInfo.getUserName() + &quot;,pwd:&quot; + &#x27;
                         &#x27;tableInfo.getPassword();\n&#x27;
                         &#x27;                        LOG.warn(&quot;get conn fail, &#x27;
                         &#x27;wait for 5 sec and try again, connInfo:&quot; + &#x27;
                         &#x27;connInfo);\n&#x27;
                         &#x27;                        Thread.sleep(5 * 1000);\n&#x27;
                         &#x27;                    } catch (InterruptedException &#x27;
                         &#x27;e1) {\n&#x27;
                         &#x27;                        LOG.error(&quot;&quot;, e1);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            //load data from table\n&#x27;
                         &#x27;            String sql = &#x27;
                         &#x27;sideInfo.getSqlCondition();\n&#x27;
                         &#x27;            Statement statement = &#x27;
                         &#x27;connection.createStatement();\n&#x27;
                         &#x27;            statement.setFetchSize(getFetchSize());\n&#x27;
                         &#x27;            ResultSet resultSet = &#x27;
                         &#x27;statement.executeQuery(sql);\n&#x27;
                         &#x27;            String[] sideFieldNames = &#x27;
                         &#x27;sideInfo.getSideSelectFields().split(&quot;,&quot;);\n&#x27;
                         &#x27;            String[] fields = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldTypes();\n&#x27;
                         &#x27;            while (resultSet.next()) {\n&#x27;
                         &#x27;                Map&lt;String, Object&gt; oneRow = &#x27;
                         &#x27;Maps.newHashMap();\n&#x27;
                         &#x27;                for (String fieldName : &#x27;
                         &#x27;sideFieldNames) {\n&#x27;
                         &#x27;                    Object object = &#x27;
                         &#x27;resultSet.getObject(fieldName.trim());\n&#x27;
                         &#x27;                    int fieldIndex = &#x27;
                         &#x27;sideInfo.getSideTableInfo().getFieldList().indexOf(fieldName.trim());\n&#x27;
                         &#x27;                    object = &#x27;
                         &#x27;SwitchUtil.getTarget(object, fields[fieldIndex]);\n&#x27;
                         &#x27;                    oneRow.put(fieldName.trim(), &#x27;
                         &#x27;object);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                String cacheKey = buildKey(oneRow, &#x27;
                         &#x27;sideInfo.getEqualFieldList());\n&#x27;
                         &#x27;                List&lt;Map&lt;String, Object&gt;&gt; list = &#x27;
                         &#x27;tmpCache.computeIfAbsent(cacheKey, key -&gt; &#x27;
                         &#x27;Lists.newArrayList());\n&#x27;
                         &#x27;                list.add(oneRow);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        } catch (Exception e) {\n&#x27;
                         &#x27;            LOG.error(&quot;&quot;, e);\n&#x27;
                         &#x27;        } finally {\n&#x27;
                         &#x27;            if (connection != null) {\n&#x27;
                         &#x27;                connection.close();\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public int getFetchSize() {\n&#x27;
                         &#x27;        return 1000;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        