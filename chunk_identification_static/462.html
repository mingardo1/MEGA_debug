<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>462</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    462
                    <a href="461.html">prev</a>
                    <a href="463.html">next</a>
                    <a href="462_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_6cea6748431f5ba346cbee61f569812590fa8a46_src/com/android/launcher3/LauncherBackupHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;6cea6748431f5ba346cbee61f569812590fa8a46:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;6cea6748431f5ba346cbee61f569812590fa8a46^1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;6cea6748431f5ba346cbee61f569812590fa8a46^2:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;48e725bdf4c92d3faf82c1788b56aa0491b566be:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [j]], subset: [[bj], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 
  32 import android.app.backup.BackupDataInputStream;
  33 import android.app.backup.BackupDataOutput;
  34 import android.app.backup.BackupHelper;
  35 import android.app.backup.BackupManager;
  36 import android.appwidget.AppWidgetManager;
  37 import android.appwidget.AppWidgetProviderInfo;
  38 import android.content.ComponentName;
  39 import android.content.ContentResolver;
  40 import android.content.ContentValues;
  41 import android.content.Context;
  42 import android.content.Intent;
  43 import android.database.Cursor;
  44 import android.graphics.Bitmap;
  45 import android.graphics.BitmapFactory;
  46 import android.graphics.drawable.Drawable;
  47 import android.os.ParcelFileDescriptor;
  48 import android.text.TextUtils;
  49 import android.util.Base64;
  50 import android.util.Log;
  51 
  52 import java.io.ByteArrayOutputStream;
  53 import java.io.FileInputStream;
  54 import java.io.FileOutputStream;
  55 import java.io.IOException;
  56 import java.net.URISyntaxException;
  57 import java.util.ArrayList;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.List;
  61 import java.util.Set;
  62 import java.util.zip.CRC32;
  63 
  64 /**
  65  * Persist the launcher home state across calamities.
  66  */
  67 public class LauncherBackupHelper implements BackupHelper {
  68 
  69     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /** icons are large, dribble them out */
  77     private static final int MAX_ICONS_PER_PASS = 10;
  78 
  79     /** widgets contain previews, which are very large, dribble them out */
  80     private static final int MAX_WIDGETS_PER_PASS = 5;
  81 
  82     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83 
  84     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85 
  86     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87 
  88     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89             android.graphics.Bitmap.CompressFormat.PNG;
  90 
  91     private static BackupManager sBackupManager;
  92 
  93     private static final String[] FAVORITE_PROJECTION = {
  94             Favorites._ID,                     // 0
  95             Favorites.MODIFIED,                // 1
  96             Favorites.INTENT,                  // 2
  97             Favorites.APPWIDGET_PROVIDER,      // 3
  98             Favorites.APPWIDGET_ID,            // 4
  99             Favorites.CELLX,                   // 5
 100             Favorites.CELLY,                   // 6
 101             Favorites.CONTAINER,               // 7
 102             Favorites.ICON,                    // 8
 103             Favorites.ICON_PACKAGE,            // 9
 104             Favorites.ICON_RESOURCE,           // 10
 105             Favorites.ICON_TYPE,               // 11
 106             Favorites.ITEM_TYPE,               // 12
 107             Favorites.SCREEN,                  // 13
 108             Favorites.SPANX,                   // 14
 109             Favorites.SPANY,                   // 15
 110             Favorites.TITLE,                   // 16
 111     };
 112 
 113     private static final int ID_INDEX = 0;
 114     private static final int ID_MODIFIED = 1;
 115     private static final int INTENT_INDEX = 2;
 116     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117     private static final int APPWIDGET_ID_INDEX = 4;
 118     private static final int CELLX_INDEX = 5;
 119     private static final int CELLY_INDEX = 6;
 120     private static final int CONTAINER_INDEX = 7;
 121     private static final int ICON_INDEX = 8;
 122     private static final int ICON_PACKAGE_INDEX = 9;
 123     private static final int ICON_RESOURCE_INDEX = 10;
 124     private static final int ICON_TYPE_INDEX = 11;
 125     private static final int ITEM_TYPE_INDEX = 12;
 126     private static final int SCREEN_INDEX = 13;
 127     private static final int SPANX_INDEX = 14;
 128     private static final int SPANY_INDEX = 15;
 129     private static final int TITLE_INDEX = 16;
 130 
 131     private static final String[] SCREEN_PROJECTION = {
 132             WorkspaceScreens._ID,              // 0
 133             WorkspaceScreens.MODIFIED,         // 1
 134             WorkspaceScreens.SCREEN_RANK       // 2
 135     };
 136 
 137     private static final int SCREEN_RANK_INDEX = 2;
 138 
 139     private final Context mContext;
 140 
 141     private final boolean mRestoreEnabled;
 142 
 143     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 144 
 145     private ArrayList&lt;Key&gt; mKeys;
 146 
 147     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 148         mContext = context;
 149         mRestoreEnabled = restoreEnabled;
 150     }
 151 
 152     private void dataChanged() {
 153         if (sBackupManager == null) {
 154             sBackupManager = new BackupManager(mContext);
 155         }
 156         sBackupManager.dataChanged();
 157     }
 158 
 159     /**
 160      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 161      *
 162      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 163      *
 164      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 165      *
 166      * @param oldState notes from the last backup
 167      * @param data incremental key/value pairs to persist off-device
 168      * @param newState notes for the next backup
 169      * @throws IOException
 170      */
 171     @Override
 172     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 173             ParcelFileDescriptor newState) {
 174         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 175 
 176         Journal in = readJournal(oldState);
 177         Journal out = new Journal();
 178 
 179         long lastBackupTime = in.t;
 180         out.t = System.currentTimeMillis();
 181         out.rows = 0;
 182         out.bytes = 0;
 183 
 184         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 185 
 186         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 187         if (launcherIsReady()) {
 188             try {
 189                 backupFavorites(in, data, out, keys);
 190                 backupScreens(in, data, out, keys);
 191                 backupIcons(in, data, out, keys);
 192                 backupWidgets(in, data, out, keys);
 193             } catch (IOException e) {
 194                 Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 195             }
 196             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);
 197         } else {
 198             out = in;
 199         }
 200 
 201 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 202         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 203 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204         } catch (IOException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205             Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208         out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);</span>
 211 =======
 212 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 213         writeJournal(newState, out);
 214         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 215     }
 216 
 217     /**
 218      * Restore launcher configuration from the restored data stream.
 219      *
 220      * &lt;P&gt;Keys may arrive in any order.
 221      *
 222      * @param data the key/value pair from the server
 223      */
 224     @Override
 225     public void restoreEntity(BackupDataInputStream data) {
 226         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 227         if (mKeys == null) {
 228             mKeys = new ArrayList&lt;Key&gt;();
 229         }
 230         byte[] buffer = new byte[512];
 231             String backupKey = data.getKey();
 232             int dataSize = data.size();
 233             if (buffer.length &lt; dataSize) {
 234                 buffer = new byte[dataSize];
 235             }
 236             Key key = null;
 237         int bytesRead = 0;
 238         try {
 239             bytesRead = data.read(buffer, 0, dataSize);
 240             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 241         } catch (IOException e) {
 242             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 243         }
 244         try {
 245             key = backupKeyToKey(backupKey);
 246             mKeys.add(key);
 247             switch (key.type) {
 248                 case Key.FAVORITE:
 249                     restoreFavorite(key, buffer, dataSize, mKeys);
 250                     break;
 251 
 252                 case Key.SCREEN:
 253                     restoreScreen(key, buffer, dataSize, mKeys);
 254                     break;
 255 
 256                 case Key.ICON:
 257                     restoreIcon(key, buffer, dataSize, mKeys);
 258                     break;
 259 
 260                 case Key.WIDGET:
 261                     restoreWidget(key, buffer, dataSize, mKeys);
 262                     break;
 263 
 264                 default:
 265                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 266                     break;
 267             }
 268         } catch (KeyParsingException e) {
 269             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 270         }
 271 
 272     }
 273 
 274     /**
 275      * Record the restore state for the next backup.
 276      *
 277      * @param newState notes about the backup state after restore.
 278      */
 279     @Override
 280     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 281         // clear the output journal time, to force a full backup to
 282         // will catch any changes the restore process might have made
 283         Journal out = new Journal();
 284         out.t = 0;
 285         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());
 286         writeJournal(newState, out);
 287         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 288         mKeys.clear();
 289     }
 290 
 291     /**
 292      * Write all modified favorites to the data stream.
 293      *
 294      *
 295      * @param in notes from last backup
 296      * @param data output stream for key/value pairs
 297      * @param out notes about this backup
 298      * @param keys keys to mark as clean in the notes for next backup
 299      * @throws IOException
 300      */
 301     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 302             ArrayList&lt;Key&gt; keys)
 303             throws IOException {
 304         // read the old ID set
 305         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 306         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 307 
 308         // persist things that have changed since the last backup
 309         ContentResolver cr = mContext.getContentResolver();
 310         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 311                 null, null, null);
 312         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 313         try {
 314             cursor.moveToPosition(-1);
 315             while(cursor.moveToNext()) {
 316                 final long id = cursor.getLong(ID_INDEX);
 317                 final long updateTime = cursor.getLong(ID_MODIFIED);
 318                 Key key = getKey(Key.FAVORITE, id);
 319                 keys.add(key);
 320                 final String backupKey = keyToBackupKey(key);
 321                 currentIds.add(backupKey);
 322                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 323                     byte[] blob = packFavorite(cursor);
 324                     writeRowToBackup(key, blob, out, data);
 325                 } else {
 326                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 327                 }
 328             }
 329         } finally {
 330             cursor.close();
 331         }
 332         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 333 
 334         // these IDs must have been deleted
 335         savedIds.removeAll(currentIds);
 336         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 337     }
 338 
 339     /**
 340      * Read a favorite from the stream.
 341      *
 342      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 343      *
 344      * @param key identifier for the row
 345      * @param buffer the serialized proto from the stream, may be larger than dataSize
 346      * @param dataSize the size of the proto from the stream
 347      * @param keys keys to mark as clean in the notes for next backup
 348      */
 349     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 350         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 351         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 352                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 353 
 354         if (!mRestoreEnabled) {
 355             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 356             return;
 357         }
 358 
 359         try {
 360             ContentResolver cr = mContext.getContentResolver();
 361             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 362             cr.insert(Favorites.CONTENT_URI, values);
 363         } catch (InvalidProtocolBufferNanoException e) {
 364             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 365         }
 366     }
 367 
 368     /**
 369      * Write all modified screens to the data stream.
 370      *
 371      *
 372      * @param in notes from last backup
 373      * @param data output stream for key/value pairs
 374      * @param out notes about this backup
 375      * @param keys keys to mark as clean in the notes for next backup
 376      * @throws IOException
 377      */
 378     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 379             ArrayList&lt;Key&gt; keys)
 380             throws IOException {
 381         // read the old ID set
 382         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 383         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 384 
 385         // persist things that have changed since the last backup
 386         ContentResolver cr = mContext.getContentResolver();
 387         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 388                 null, null, null);
 389         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 390         try {
 391             cursor.moveToPosition(-1);
 392             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 393             while(cursor.moveToNext()) {
 394                 final long id = cursor.getLong(ID_INDEX);
 395                 final long updateTime = cursor.getLong(ID_MODIFIED);
 396                 Key key = getKey(Key.SCREEN, id);
 397                 keys.add(key);
 398                 final String backupKey = keyToBackupKey(key);
 399                 currentIds.add(backupKey);
 400                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 401                     byte[] blob = packScreen(cursor);
 402                     writeRowToBackup(key, blob, out, data);
 403                 } else {
 404                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 405                 }
 406             }
 407         } finally {
 408             cursor.close();
 409         }
 410         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 411 
 412         // these IDs must have been deleted
 413         savedIds.removeAll(currentIds);
 414         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 415     }
 416 
 417     /**
 418      * Read a screen from the stream.
 419      *
 420      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 421      *
 422      * @param key identifier for the row
 423      * @param buffer the serialized proto from the stream, may be larger than dataSize
 424      * @param dataSize the size of the proto from the stream
 425      * @param keys keys to mark as clean in the notes for next backup
 426      */
 427     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 428         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 429         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 430                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 431 
 432         if (!mRestoreEnabled) {
 433             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 434             return;
 435         }
 436 
 437         try {
 438             ContentResolver cr = mContext.getContentResolver();
 439             ContentValues values = unpackScreen(buffer, 0, dataSize);
 440             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 441 
 442         } catch (InvalidProtocolBufferNanoException e) {
 443             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 444         }
 445     }
 446 
 447     /**
 448      * Write all the static icon resources we need to render placeholders
 449      * for a package that is not installed.
 450      *
 451      * @param in notes from last backup
 452      * @param data output stream for key/value pairs
 453      * @param out notes about this backup
 454      * @param keys keys to mark as clean in the notes for next backup
 455      * @throws IOException
 456      */
 457     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 458             ArrayList&lt;Key&gt; keys) throws IOException {
 459         // persist icons that haven&#x27;t been persisted yet
 460         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 461         if (appState == null) {
 462             dataChanged(); // try again later
 463             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 464             return;
 465         }
 466         final ContentResolver cr = mContext.getContentResolver();
 467         final IconCache iconCache = appState.getIconCache();
 468         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 469 
 470         // read the old ID set
 471         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 472         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 473 
 474         int startRows = out.rows;
 475         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 476         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 477         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 478                 where, null, null);
 479         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 480         try {
 481             cursor.moveToPosition(-1);
 482             while(cursor.moveToNext()) {
 483                 final long id = cursor.getLong(ID_INDEX);
 484                 final String intentDescription = cursor.getString(INTENT_INDEX);
 485                 try {
 486                     Intent intent = Intent.parseUri(intentDescription, 0);
 487                     ComponentName cn = intent.getComponent();
 488                     Key key = null;
 489                     String backupKey = null;
 490                     if (cn != null) {
 491                         key = getKey(Key.ICON, cn.flattenToShortString());
 492                         backupKey = keyToBackupKey(key);
 493                         currentIds.add(backupKey);
 494                     } else {
 495                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 496                     }
 497                     if (savedIds.contains(backupKey)) {
 498                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 499 
 500                         // remember that we already backed this up previously
 501                         keys.add(key);
 502                     } else if (backupKey != null) {
 503                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 504                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 505                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 506                             Bitmap icon = iconCache.getIcon(intent);
 507                             keys.add(key);
 508                             if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {
 509                                 byte[] blob = packIcon(dpi, icon);
 510                                 writeRowToBackup(key, blob, out, data);
 511                             }
 512                         } else {
 513                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 514                             // too many icons for this pass, request another.
 515                             dataChanged();
 516                         }
 517                     }
 518                 } catch (URISyntaxException e) {
 519                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 520                 } catch (IOException e) {
 521                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 522                 }
 523 
 524             }
 525         } finally {
 526             cursor.close();
 527         }
 528         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 529 
 530         // these IDs must have been deleted
 531         savedIds.removeAll(currentIds);
 532         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 533     }
 534 
 535     /**
 536      * Read an icon from the stream.
 537      *
 538      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 539      *
 540      * @param key identifier for the row
 541      * @param buffer the serialized proto from the stream, may be larger than dataSize
 542      * @param dataSize the size of the proto from the stream
 543      * @param keys keys to mark as clean in the notes for next backup
 544      */
 545     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 546         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 547         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 548                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 549         try {
 550             Resource res = unpackIcon(buffer, 0, dataSize);
 551             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 552             if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +
 553                     Base64.encodeToString(res.data, 0, res.data.length,
 554                             Base64.NO_WRAP));
 555             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 556             if (icon == null) {
 557                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 558             }
 559 
 560             if (!mRestoreEnabled) {
 561                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 562                 return;
 563             } else {
 564                 // future site of icon cache mutation
 565             }
 566         } catch (InvalidProtocolBufferNanoException e) {
 567             Log.e(TAG, &quot;failed to decode icon&quot;, e);
 568         }
 569     }
 570 
 571     /**
 572      * Write all the static widget resources we need to render placeholders
 573      * for a package that is not installed.
 574      *
 575      * @param in notes from last backup
 576      * @param data output stream for key/value pairs
 577      * @param out notes about this backup
 578      * @param keys keys to mark as clean in the notes for next backup
 579      * @throws IOException
 580      */
 581     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 582             ArrayList&lt;Key&gt; keys) throws IOException {
 583         // persist static widget info that hasn&#x27;t been persisted yet
 584         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 585         if (appState == null) {
 586             dataChanged(); // try again later
 587             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);
 588             return;
 589         }
 590         final ContentResolver cr = mContext.getContentResolver();
 591         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 592         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 593         final IconCache iconCache = appState.getIconCache();
 594         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 595         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 596         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 597 
 598         // read the old ID set
 599         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 600         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 601 
 602         int startRows = out.rows;
 603         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 604         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 605         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 606                 where, null, null);
 607         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 608         try {
 609             cursor.moveToPosition(-1);
 610             while(cursor.moveToNext()) {
 611                 final long id = cursor.getLong(ID_INDEX);
 612                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 613                 final int spanX = cursor.getInt(SPANX_INDEX);
 614                 final int spanY = cursor.getInt(SPANY_INDEX);
 615                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 616                 Key key = null;
 617                 String backupKey = null;
 618                 if (provider != null) {
 619                     key = getKey(Key.WIDGET, providerName);
 620                     backupKey = keyToBackupKey(key);
 621                     currentIds.add(backupKey);
 622                 } else {
 623                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 624                 }
 625                 if (savedIds.contains(backupKey)) {
 626                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 627 
 628                     // remember that we already backed this up previously
 629                     keys.add(key);
 630                 } else if (backupKey != null) {
 631                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 632                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 633                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 634                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 635                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 636                         byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);
 637                         keys.add(key);
 638                         writeRowToBackup(key, blob, out, data);
 639 
 640                     } else {
 641                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 642                         // too many widgets for this pass, request another.
 643                         dataChanged();
 644                     }
 645                 }
 646             }
 647         } finally {
 648             cursor.close();
 649         }
 650         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 651 
 652         // these IDs must have been deleted
 653         savedIds.removeAll(currentIds);
 654         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 655     }
 656 
 657     /**
 658      * Read a widget from the stream.
 659      *
 660      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 661      *
 662      * @param key identifier for the row
 663      * @param buffer the serialized proto from the stream, may be larger than dataSize
 664      * @param dataSize the size of the proto from the stream
 665      * @param keys keys to mark as clean in the notes for next backup
 666      */
 667     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 668         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 669         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 670                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 671         try {
 672             Widget widget = unpackWidget(buffer, 0, dataSize);
 673             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 674             if (widget.icon.data != null)  {
 675                 Bitmap icon = BitmapFactory
 676                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 677                 if (icon == null) {
 678                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 679                 }
 680             }
 681 
 682             if (!mRestoreEnabled) {
 683                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 684                 return;
 685             } else {
 686                 // future site of widget table mutation
 687             }
 688         } catch (InvalidProtocolBufferNanoException e) {
 689             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 690         }
 691     }
 692 
 693     /** create a new key, with an integer ID.
 694      *
 695      * &lt;P&gt; Keys contain their own checksum instead of using
 696      * the heavy-weight CheckedMessage wrapper.
 697      */
 698     private Key getKey(int type, long id) {
 699         Key key = new Key();
 700         key.type = type;
 701         key.id = id;
 702         key.checksum = checkKey(key);
 703         return key;
 704     }
 705 
 706     /** create a new key for a named object.
 707      *
 708      * &lt;P&gt; Keys contain their own checksum instead of using
 709      * the heavy-weight CheckedMessage wrapper.
 710      */
 711     private Key getKey(int type, String name) {
 712         Key key = new Key();
 713         key.type = type;
 714         key.name = name;
 715         key.checksum = checkKey(key);
 716         return key;
 717     }
 718 
 719     /** keys need to be strings, serialize and encode. */
 720     private String keyToBackupKey(Key key) {
 721         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 722     }
 723 
 724     /** keys need to be strings, decode and parse. */
 725     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 726         try {
 727             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 728             if (key.checksum != checkKey(key)) {
 729                 key = null;
 730                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 731             }
 732             return key;
 733         } catch (InvalidProtocolBufferNanoException e) {
 734             throw new KeyParsingException(e);
 735         } catch (IllegalArgumentException e) {
 736             throw new KeyParsingException(e);
 737         }
 738     }
 739 
 740     private String getKeyName(Key key) {
 741         if (TextUtils.isEmpty(key.name)) {
 742             return Long.toString(key.id);
 743         } else {
 744             return key.name;
 745         }
 746 
 747     }
 748 
 749     private String geKeyType(Key key) {
 750         switch (key.type) {
 751             case Key.FAVORITE:
 752                 return &quot;favorite&quot;;
 753             case Key.SCREEN:
 754                 return &quot;screen&quot;;
 755             case Key.ICON:
 756                 return &quot;icon&quot;;
 757             case Key.WIDGET:
 758                 return &quot;widget&quot;;
 759             default:
 760                 return &quot;anonymous&quot;;
 761         }
 762     }
 763 
 764     /** Compute the checksum over the important bits of a key. */
 765     private long checkKey(Key key) {
 766         CRC32 checksum = new CRC32();
 767         checksum.update(key.type);
 768         checksum.update((int) (key.id &amp; 0xffff));
 769         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 770         if (!TextUtils.isEmpty(key.name)) {
 771             checksum.update(key.name.getBytes());
 772         }
 773         return checksum.getValue();
 774     }
 775 
 776     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 777     private byte[] packFavorite(Cursor c) {
 778         Favorite favorite = new Favorite();
 779         favorite.id = c.getLong(ID_INDEX);
 780         favorite.screen = c.getInt(SCREEN_INDEX);
 781         favorite.container = c.getInt(CONTAINER_INDEX);
 782         favorite.cellX = c.getInt(CELLX_INDEX);
 783         favorite.cellY = c.getInt(CELLY_INDEX);
 784         favorite.spanX = c.getInt(SPANX_INDEX);
 785         favorite.spanY = c.getInt(SPANY_INDEX);
 786         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 787         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 788             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 789             if (!TextUtils.isEmpty(iconPackage)) {
 790                 favorite.iconPackage = iconPackage;
 791             }
 792             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 793             if (!TextUtils.isEmpty(iconResource)) {
 794                 favorite.iconResource = iconResource;
 795             }
 796         }
 797         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 798             byte[] blob = c.getBlob(ICON_INDEX);
 799             if (blob != null &amp;&amp; blob.length &gt; 0) {
 800                 favorite.icon = blob;
 801             }
 802         }
 803         String title = c.getString(TITLE_INDEX);
 804         if (!TextUtils.isEmpty(title)) {
 805             favorite.title = title;
 806         }
 807         String intent = c.getString(INTENT_INDEX);
 808         if (!TextUtils.isEmpty(intent)) {
 809             favorite.intent = intent;
 810         }
 811         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 812         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 813             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 814             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 815             if (!TextUtils.isEmpty(appWidgetProvider)) {
 816                 favorite.appWidgetProvider = appWidgetProvider;
 817             }
 818         }
 819 
 820         return writeCheckedBytes(favorite);
 821     }
 822 
 823     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 824     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 825             throws InvalidProtocolBufferNanoException {
 826         Favorite favorite = new Favorite();
 827         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 828         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 829                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 830         ContentValues values = new ContentValues();
 831         values.put(Favorites._ID, favorite.id);
 832         values.put(Favorites.SCREEN, favorite.screen);
 833         values.put(Favorites.CONTAINER, favorite.container);
 834         values.put(Favorites.CELLX, favorite.cellX);
 835         values.put(Favorites.CELLY, favorite.cellY);
 836         values.put(Favorites.SPANX, favorite.spanX);
 837         values.put(Favorites.SPANY, favorite.spanY);
 838         values.put(Favorites.ICON_TYPE, favorite.iconType);
 839         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 840             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 841             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 842         }
 843         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 844             values.put(Favorites.ICON, favorite.icon);
 845         }
 846         if (!TextUtils.isEmpty(favorite.title)) {
 847             values.put(Favorites.TITLE, favorite.title);
 848         } else {
 849             values.put(Favorites.TITLE, &quot;&quot;);
 850         }
 851         if (!TextUtils.isEmpty(favorite.intent)) {
 852             values.put(Favorites.INTENT, favorite.intent);
 853         }
 854         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 855         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 856             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 857                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 858             }
 859             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 860         }
 861 
 862         // Let LauncherModel know we&#x27;ve been here.
 863         values.put(LauncherSettings.Favorites.RESTORED, 1);
 864 
 865         return values;
 866     }
 867 
 868     /** Serialize a Screen for persistence, including a checksum wrapper. */
 869     private byte[] packScreen(Cursor c) {
 870         Screen screen = new Screen();
 871         screen.id = c.getLong(ID_INDEX);
 872         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 873 
 874         return writeCheckedBytes(screen);
 875     }
 876 
 877     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 878     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 879             throws InvalidProtocolBufferNanoException {
 880         Screen screen = new Screen();
 881         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 882         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 883         ContentValues values = new ContentValues();
 884         values.put(WorkspaceScreens._ID, screen.id);
 885         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 886         return values;
 887     }
 888 
 889     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 890     private byte[] packIcon(int dpi, Bitmap icon) {
 891         Resource res = new Resource();
 892         res.dpi = dpi;
 893         ByteArrayOutputStream os = new ByteArrayOutputStream();
 894         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 895             res.data = os.toByteArray();
 896         }
 897         return writeCheckedBytes(res);
 898     }
 899 
 900     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 901     private Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 902             throws InvalidProtocolBufferNanoException {
 903         Resource res = new Resource();
 904         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 905         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 906         return res;
 907     }
 908 
 909     /** Serialize a widget for persistence, including a checksum wrapper. */
 910     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 911             ComponentName provider) {
 912         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 913         Widget widget = new Widget();
 914         widget.provider = provider.flattenToShortString();
 915         widget.label = info.label;
 916         widget.configure = info.configure != null;
 917         if (info.icon != 0) {
 918             widget.icon = new Resource();
 919             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 920             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 921             ByteArrayOutputStream os = new ByteArrayOutputStream();
 922             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 923                 widget.icon.data = os.toByteArray();
 924                 widget.icon.dpi = dpi;
 925             }
 926         }
 927         if (info.previewImage != 0) {
 928             widget.preview = new Resource();
 929             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 930             ByteArrayOutputStream os = new ByteArrayOutputStream();
 931             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 932                 widget.preview.data = os.toByteArray();
 933                 widget.preview.dpi = dpi;
 934             }
 935         }
 936         return writeCheckedBytes(widget);
 937     }
 938 
 939     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 940     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 941             throws InvalidProtocolBufferNanoException {
 942         Widget widget = new Widget();
 943         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 944         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 945         return widget;
 946     }
 947 
 948     /**
 949      * Read the old journal from the input file.
 950      *
 951      * In the event of any error, just pretend we didn&#x27;t have a journal,
 952      * in that case, do a full backup.
 953      *
 954      * @param oldState the read-0only file descriptor pointing to the old journal
 955      * @return a Journal protocol buffer
 956      */
 957     private Journal readJournal(ParcelFileDescriptor oldState) {
 958         Journal journal = new Journal();
 959         if (oldState == null) {
 960             return journal;
 961         }
 962         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 963         try {
 964             int availableBytes = inStream.available();
 965             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 966             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 967                 byte[] buffer = new byte[availableBytes];
 968                 int bytesRead = 0;
 969                 boolean valid = false;
 970                 InvalidProtocolBufferNanoException lastProtoException = null;
 971                 while (availableBytes &gt; 0) {
 972                     try {
 973                         // OMG what are you doing? This is crazy inefficient!
 974                         // If we read a byte that is not ours, we will cause trouble: b/12491813
 975                         // However, we don&#x27;t know how many bytes to expect (oops).
 976                         // So we have to step through *slowly*, watching for the end.
 977                         int result = inStream.read(buffer, bytesRead, 1);
 978                         if (result &gt; 0) {
 979                             availableBytes -= result;
 980                             bytesRead += result;
 981                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 982                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 983                             }
 984                         } else {
 985                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 986                             // stop reading and see what there is to parse
 987                             availableBytes = 0;
 988                         }
 989                     } catch (IOException e) {
 990                         buffer = null;
 991                         availableBytes = 0;
 992                     }
 993 
 994                     // check the buffer to see if we have a valid journal
 995                     try {
 996                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
 997                         // if we are here, then we have read a valid, checksum-verified journal
 998                         valid = true;
 999                         availableBytes = 0;
1000                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1001                     } catch (InvalidProtocolBufferNanoException e) {
1002                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1003                         lastProtoException = e;
1004                         journal.clear();
1005                     }
1006                 }
1007                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1008                 if (!valid) {
1009                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1010                 }
1011             }
1012         } catch (IOException e) {
1013             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1014         } finally {
1015             try {
1016                 inStream.close();
1017             } catch (IOException e) {
1018                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1019             }
1020         }
1021         return journal;
1022     }
1023 
1024     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1025             BackupDataOutput data) throws IOException {
1026         String backupKey = keyToBackupKey(key);
1027         data.writeEntityHeader(backupKey, blob.length);
1028         data.writeEntityData(blob, blob.length);
1029         out.rows++;
1030         out.bytes += blob.length;
1031         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1032                 getKeyName(key) + &quot;/&quot; + blob.length);
1033         if(DEBUG_PAYLOAD) {
1034             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1035             final int chunkSize = 1024;
1036             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1037                 int end = offset + chunkSize;
1038                 end = Math.min(end, encoded.length());
1039                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1040             }
1041         }
1042     }
1043 
1044     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1045         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1046         for(int i = 0; i &lt; in.key.length; i++) {
1047             Key key = in.key[i];
1048             if (key.type == type) {
1049                 savedIds.add(keyToBackupKey(key));
1050             }
1051         }
1052         return savedIds;
1053     }
1054 
1055     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1056             throws IOException {
1057         int rows = 0;
1058         for(String deleted: deletedIds) {
1059             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1060             data.writeEntityHeader(deleted, -1);
1061             rows++;
1062         }
1063         return rows;
1064     }
1065 
1066     /**
1067      * Write the new journal to the output file.
1068      *
1069      * In the event of any error, just pretend we didn&#x27;t have a journal,
1070      * in that case, do a full backup.
1071 
1072      * @param newState the write-only file descriptor pointing to the new journal
1073      * @param journal a Journal protocol buffer
1074      */
1075     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1076         FileOutputStream outStream = null;
1077         try {
1078             outStream = new FileOutputStream(newState.getFileDescriptor());
1079             final byte[] journalBytes = writeCheckedBytes(journal);
1080             outStream.write(journalBytes);
1081             outStream.close();
1082             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1083         } catch (IOException e) {
1084             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1085         }
1086     }
1087 
1088     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1089     private byte[] writeCheckedBytes(MessageNano proto) {
1090         CheckedMessage wrapper = new CheckedMessage();
1091         wrapper.payload = MessageNano.toByteArray(proto);
1092         CRC32 checksum = new CRC32();
1093         checksum.update(wrapper.payload);
1094         wrapper.checksum = checksum.getValue();
1095         return MessageNano.toByteArray(wrapper);
1096     }
1097 
1098     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1099     private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1100             throws InvalidProtocolBufferNanoException {
1101         CheckedMessage wrapper = new CheckedMessage();
1102         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1103         CRC32 checksum = new CRC32();
1104         checksum.update(wrapper.payload);
1105         if (wrapper.checksum != checksum.getValue()) {
1106             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1107         }
1108         return wrapper.payload;
1109     }
1110 
1111     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1112         if (mWidgetMap == null) {
1113             List&lt;AppWidgetProviderInfo&gt; widgets =
1114                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1115             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1116             for (AppWidgetProviderInfo info : widgets) {
1117                 mWidgetMap.put(info.provider, info);
1118             }
1119         }
1120         return mWidgetMap.get(component);
1121     }
1122 
1123 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
1124 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1125             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1126             for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1127                 mWidgetMap.put(info.provider, info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1128             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1129         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1130         return mWidgetMap.get(component);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1131     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1132 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1133 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1134     private boolean initializeIconCache() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1135         if (mIconCache != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1136             return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1137         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1138 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1139         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1140         if (appState == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1141             Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1142             stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1143             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1144             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1145         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1146         mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1147         return mIconCache != null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1148     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1149 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1150     private class KeyParsingException extends Throwable {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1151         private KeyParsingException(Throwable cause) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1152             super(cause);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1153         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1154 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1155         public KeyParsingException(String reason) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1156             super(reason);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1157         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1158     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1159 }</span>
1160 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1161 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1162     private boolean initializeIconCache() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1163         if (mIconCache != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1164             return true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1165         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1166 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1167         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1168         if (appState == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1169             Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1170             stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1171             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1172             return false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1173         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1174         mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1175         return mIconCache != null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1176     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1177 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1178 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1179    // check if the launcher is in a state to support backup</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1180     private boolean launcherIsReady() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1181         ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1182         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1183         if (cursor == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1184             // launcher data has been wiped, do nothing</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1185             return false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1186         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1187         cursor.close();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1188 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1189         if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1190             // launcher services are unavailable, try again later</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1191             dataChanged();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1192             return false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1193         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1194 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1195         return true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1196     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1197 </span>
1198 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1199     private class KeyParsingException extends Throwable {
1200         private KeyParsingException(Throwable cause) {
1201             super(cause);
1202         }
1203 
1204         public KeyParsingException(String reason) {
1205             super(reason);
1206         }
1207     }
1208 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 
  32 import android.app.backup.BackupDataInputStream;
  33 import android.app.backup.BackupDataOutput;
  34 import android.app.backup.BackupHelper;
  35 import android.app.backup.BackupManager;
  36 import android.appwidget.AppWidgetManager;
  37 import android.appwidget.AppWidgetProviderInfo;
  38 import android.content.ComponentName;
  39 import android.content.ContentResolver;
  40 import android.content.ContentValues;
  41 import android.content.Context;
  42 import android.content.Intent;
  43 import android.database.Cursor;
  44 import android.graphics.Bitmap;
  45 import android.graphics.BitmapFactory;
  46 import android.graphics.drawable.Drawable;
  47 import android.os.ParcelFileDescriptor;
  48 import android.text.TextUtils;
  49 import android.util.Base64;
  50 import android.util.Log;
  51 
  52 import java.io.ByteArrayOutputStream;
  53 import java.io.FileInputStream;
  54 import java.io.FileOutputStream;
  55 import java.io.IOException;
  56 import java.net.URISyntaxException;
  57 import java.util.ArrayList;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.List;
  61 import java.util.Set;
  62 import java.util.zip.CRC32;
  63 
  64 /**
  65  * Persist the launcher home state across calamities.
  66  */
  67 public class LauncherBackupHelper implements BackupHelper {
  68 
  69     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /** icons are large, dribble them out */
  77     private static final int MAX_ICONS_PER_PASS = 10;
  78 
  79     /** widgets contain previews, which are very large, dribble them out */
  80     private static final int MAX_WIDGETS_PER_PASS = 5;
  81 
  82     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83 
  84     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85 
  86     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87 
  88     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89             android.graphics.Bitmap.CompressFormat.PNG;
  90 
  91     private static BackupManager sBackupManager;
  92 
  93     private static final String[] FAVORITE_PROJECTION = {
  94             Favorites._ID,                     // 0
  95             Favorites.MODIFIED,                // 1
  96             Favorites.INTENT,                  // 2
  97             Favorites.APPWIDGET_PROVIDER,      // 3
  98             Favorites.APPWIDGET_ID,            // 4
  99             Favorites.CELLX,                   // 5
 100             Favorites.CELLY,                   // 6
 101             Favorites.CONTAINER,               // 7
 102             Favorites.ICON,                    // 8
 103             Favorites.ICON_PACKAGE,            // 9
 104             Favorites.ICON_RESOURCE,           // 10
 105             Favorites.ICON_TYPE,               // 11
 106             Favorites.ITEM_TYPE,               // 12
 107             Favorites.SCREEN,                  // 13
 108             Favorites.SPANX,                   // 14
 109             Favorites.SPANY,                   // 15
 110             Favorites.TITLE,                   // 16
 111     };
 112 
 113     private static final int ID_INDEX = 0;
 114     private static final int ID_MODIFIED = 1;
 115     private static final int INTENT_INDEX = 2;
 116     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117     private static final int APPWIDGET_ID_INDEX = 4;
 118     private static final int CELLX_INDEX = 5;
 119     private static final int CELLY_INDEX = 6;
 120     private static final int CONTAINER_INDEX = 7;
 121     private static final int ICON_INDEX = 8;
 122     private static final int ICON_PACKAGE_INDEX = 9;
 123     private static final int ICON_RESOURCE_INDEX = 10;
 124     private static final int ICON_TYPE_INDEX = 11;
 125     private static final int ITEM_TYPE_INDEX = 12;
 126     private static final int SCREEN_INDEX = 13;
 127     private static final int SPANX_INDEX = 14;
 128     private static final int SPANY_INDEX = 15;
 129     private static final int TITLE_INDEX = 16;
 130 
 131     private static final String[] SCREEN_PROJECTION = {
 132             WorkspaceScreens._ID,              // 0
 133             WorkspaceScreens.MODIFIED,         // 1
 134             WorkspaceScreens.SCREEN_RANK       // 2
 135     };
 136 
 137     private static final int SCREEN_RANK_INDEX = 2;
 138 
 139     private final Context mContext;
 140 
 141     private final boolean mRestoreEnabled;
 142 
 143     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 144 
 145     private ArrayList&lt;Key&gt; mKeys;
 146 
 147     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 148         mContext = context;
 149         mRestoreEnabled = restoreEnabled;
 150     }
 151 
 152     private void dataChanged() {
 153         if (sBackupManager == null) {
 154             sBackupManager = new BackupManager(mContext);
 155         }
 156         sBackupManager.dataChanged();
 157     }
 158 
 159     /**
 160      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 161      *
 162      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 163      *
 164      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 165      *
 166      * @param oldState notes from the last backup
 167      * @param data incremental key/value pairs to persist off-device
 168      * @param newState notes for the next backup
 169      * @throws IOException
 170      */
 171     @Override
 172     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 173             ParcelFileDescriptor newState) {
 174         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 175 
 176         Journal in = readJournal(oldState);
 177         Journal out = new Journal();
 178 
 179         long lastBackupTime = in.t;
 180         out.t = System.currentTimeMillis();
 181         out.rows = 0;
 182         out.bytes = 0;
 183 
 184         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 185 
 186         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 187         if (launcherIsReady()) {
 188         try {
 189             backupFavorites(in, data, out, keys);
 190             backupScreens(in, data, out, keys);
 191             backupIcons(in, data, out, keys);
 192             backupWidgets(in, data, out, keys);
 193         } catch (IOException e) {
 194             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 195         }
 196 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 197 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 198         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 199 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201         out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204     }</span>
 205 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 206             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 207         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 208             out = in;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 209         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 210 </span>
 211 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 212         writeJournal(newState, out);
 213         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 214     }
 215 
 216     /**
 217      * Restore launcher configuration from the restored data stream.
 218      *
 219      * &lt;P&gt;Keys may arrive in any order.
 220      *
 221      * @param data the key/value pair from the server
 222      */
 223     @Override
 224     public void restoreEntity(BackupDataInputStream data) {
 225         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 226         if (mKeys == null) {
 227             mKeys = new ArrayList&lt;Key&gt;();
 228         }
 229         byte[] buffer = new byte[512];
 230             String backupKey = data.getKey();
 231             int dataSize = data.size();
 232             if (buffer.length &lt; dataSize) {
 233                 buffer = new byte[dataSize];
 234             }
 235             Key key = null;
 236         int bytesRead = 0;
 237         try {
 238             bytesRead = data.read(buffer, 0, dataSize);
 239             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 240         } catch (IOException e) {
 241             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 242         }
 243         try {
 244             key = backupKeyToKey(backupKey);
 245             mKeys.add(key);
 246             switch (key.type) {
 247                 case Key.FAVORITE:
 248                     restoreFavorite(key, buffer, dataSize, mKeys);
 249                     break;
 250 
 251                 case Key.SCREEN:
 252                     restoreScreen(key, buffer, dataSize, mKeys);
 253                     break;
 254 
 255                 case Key.ICON:
 256                     restoreIcon(key, buffer, dataSize, mKeys);
 257                     break;
 258 
 259                 case Key.WIDGET:
 260                     restoreWidget(key, buffer, dataSize, mKeys);
 261                     break;
 262 
 263                 default:
 264                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 265                     break;
 266             }
 267         } catch (KeyParsingException e) {
 268             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 269         }
 270 
 271     }
 272 
 273     /**
 274      * Record the restore state for the next backup.
 275      *
 276      * @param newState notes about the backup state after restore.
 277      */
 278     @Override
 279     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 280         // clear the output journal time, to force a full backup to
 281         // will catch any changes the restore process might have made
 282         Journal out = new Journal();
 283         out.t = 0;
 284         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());
 285         writeJournal(newState, out);
 286         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 287         mKeys.clear();
 288     }
 289 
 290     /**
 291      * Write all modified favorites to the data stream.
 292      *
 293      *
 294      * @param in notes from last backup
 295      * @param data output stream for key/value pairs
 296      * @param out notes about this backup
 297      * @param keys keys to mark as clean in the notes for next backup
 298      * @throws IOException
 299      */
 300     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 301             ArrayList&lt;Key&gt; keys)
 302             throws IOException {
 303         // read the old ID set
 304         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 305         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 306 
 307         // persist things that have changed since the last backup
 308         ContentResolver cr = mContext.getContentResolver();
 309         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 310                 null, null, null);
 311         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 312         try {
 313             cursor.moveToPosition(-1);
 314             while(cursor.moveToNext()) {
 315                 final long id = cursor.getLong(ID_INDEX);
 316                 final long updateTime = cursor.getLong(ID_MODIFIED);
 317                 Key key = getKey(Key.FAVORITE, id);
 318                 keys.add(key);
 319                 final String backupKey = keyToBackupKey(key);
 320                 currentIds.add(backupKey);
 321                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 322                     byte[] blob = packFavorite(cursor);
 323                     writeRowToBackup(key, blob, out, data);
 324                 } else {
 325                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 326                 }
 327             }
 328         } finally {
 329             cursor.close();
 330         }
 331         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 332 
 333         // these IDs must have been deleted
 334         savedIds.removeAll(currentIds);
 335         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 336     }
 337 
 338     /**
 339      * Read a favorite from the stream.
 340      *
 341      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 342      *
 343      * @param key identifier for the row
 344      * @param buffer the serialized proto from the stream, may be larger than dataSize
 345      * @param dataSize the size of the proto from the stream
 346      * @param keys keys to mark as clean in the notes for next backup
 347      */
 348     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 349         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 350         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 351                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 352 
 353         if (!mRestoreEnabled) {
 354             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 355             return;
 356         }
 357 
 358         try {
 359             ContentResolver cr = mContext.getContentResolver();
 360             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 361             cr.insert(Favorites.CONTENT_URI, values);
 362         } catch (InvalidProtocolBufferNanoException e) {
 363             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 364         }
 365     }
 366 
 367     /**
 368      * Write all modified screens to the data stream.
 369      *
 370      *
 371      * @param in notes from last backup
 372      * @param data output stream for key/value pairs
 373      * @param out notes about this backup
 374      * @param keys keys to mark as clean in the notes for next backup
 375      * @throws IOException
 376      */
 377     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 378             ArrayList&lt;Key&gt; keys)
 379             throws IOException {
 380         // read the old ID set
 381         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 382         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 383 
 384         // persist things that have changed since the last backup
 385         ContentResolver cr = mContext.getContentResolver();
 386         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 387                 null, null, null);
 388         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 389         try {
 390             cursor.moveToPosition(-1);
 391             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 392             while(cursor.moveToNext()) {
 393                 final long id = cursor.getLong(ID_INDEX);
 394                 final long updateTime = cursor.getLong(ID_MODIFIED);
 395                 Key key = getKey(Key.SCREEN, id);
 396                 keys.add(key);
 397                 final String backupKey = keyToBackupKey(key);
 398                 currentIds.add(backupKey);
 399                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 400                     byte[] blob = packScreen(cursor);
 401                     writeRowToBackup(key, blob, out, data);
 402                 } else {
 403                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 404                 }
 405             }
 406         } finally {
 407             cursor.close();
 408         }
 409         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 410 
 411         // these IDs must have been deleted
 412         savedIds.removeAll(currentIds);
 413         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 414     }
 415 
 416     /**
 417      * Read a screen from the stream.
 418      *
 419      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 420      *
 421      * @param key identifier for the row
 422      * @param buffer the serialized proto from the stream, may be larger than dataSize
 423      * @param dataSize the size of the proto from the stream
 424      * @param keys keys to mark as clean in the notes for next backup
 425      */
 426     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 427         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 428         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 429                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 430 
 431         if (!mRestoreEnabled) {
 432             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 433             return;
 434         }
 435 
 436         try {
 437             ContentResolver cr = mContext.getContentResolver();
 438             ContentValues values = unpackScreen(buffer, 0, dataSize);
 439             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 440 
 441         } catch (InvalidProtocolBufferNanoException e) {
 442             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 443         }
 444     }
 445 
 446     /**
 447      * Write all the static icon resources we need to render placeholders
 448      * for a package that is not installed.
 449      *
 450      * @param in notes from last backup
 451      * @param data output stream for key/value pairs
 452      * @param out notes about this backup
 453      * @param keys keys to mark as clean in the notes for next backup
 454      * @throws IOException
 455      */
 456     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 457             ArrayList&lt;Key&gt; keys) throws IOException {
 458         // persist icons that haven&#x27;t been persisted yet
 459         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 460         if (appState == null) {
 461             dataChanged(); // try again later
 462             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 463             return;
 464         }
 465         final ContentResolver cr = mContext.getContentResolver();
 466         final IconCache iconCache = appState.getIconCache();
 467         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 468 
 469         // read the old ID set
 470         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 471         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 472 
 473         int startRows = out.rows;
 474         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 475         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 476         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 477                 where, null, null);
 478         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 479         try {
 480             cursor.moveToPosition(-1);
 481             while(cursor.moveToNext()) {
 482                 final long id = cursor.getLong(ID_INDEX);
 483                 final String intentDescription = cursor.getString(INTENT_INDEX);
 484                 try {
 485                     Intent intent = Intent.parseUri(intentDescription, 0);
 486                     ComponentName cn = intent.getComponent();
 487                     Key key = null;
 488                     String backupKey = null;
 489                     if (cn != null) {
 490                         key = getKey(Key.ICON, cn.flattenToShortString());
 491                         backupKey = keyToBackupKey(key);
 492                         currentIds.add(backupKey);
 493                     } else {
 494                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 495                     }
 496                     if (savedIds.contains(backupKey)) {
 497                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 498 
 499                         // remember that we already backed this up previously
 500                         keys.add(key);
 501                     } else if (backupKey != null) {
 502                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 503                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 504                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 505                             Bitmap icon = iconCache.getIcon(intent);
 506                             keys.add(key);
 507                             if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {
 508                                 byte[] blob = packIcon(dpi, icon);
 509                                 writeRowToBackup(key, blob, out, data);
 510                             }
 511                         } else {
 512                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 513                             // too many icons for this pass, request another.
 514                             dataChanged();
 515                         }
 516                     }
 517                 } catch (URISyntaxException e) {
 518                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 519                 } catch (IOException e) {
 520                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 521                 }
 522 
 523             }
 524         } finally {
 525             cursor.close();
 526         }
 527         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 528 
 529         // these IDs must have been deleted
 530         savedIds.removeAll(currentIds);
 531         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 532     }
 533 
 534     /**
 535      * Read an icon from the stream.
 536      *
 537      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 538      *
 539      * @param key identifier for the row
 540      * @param buffer the serialized proto from the stream, may be larger than dataSize
 541      * @param dataSize the size of the proto from the stream
 542      * @param keys keys to mark as clean in the notes for next backup
 543      */
 544     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 545         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 546         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 547                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 548         try {
 549             Resource res = unpackIcon(buffer, 0, dataSize);
 550             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 551             if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +
 552                         Base64.encodeToString(res.data, 0, res.data.length,
 553                                 Base64.NO_WRAP));
 554             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 555             if (icon == null) {
 556                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 557             }
 558 
 559             if (!mRestoreEnabled) {
 560                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 561                 return;
 562             } else {
 563                 // future site of icon cache mutation
 564             }
 565         } catch (InvalidProtocolBufferNanoException e) {
 566             Log.e(TAG, &quot;failed to decode icon&quot;, e);
 567         }
 568     }
 569 
 570     /**
 571      * Write all the static widget resources we need to render placeholders
 572      * for a package that is not installed.
 573      *
 574      * @param in notes from last backup
 575      * @param data output stream for key/value pairs
 576      * @param out notes about this backup
 577      * @param keys keys to mark as clean in the notes for next backup
 578      * @throws IOException
 579      */
 580     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 581             ArrayList&lt;Key&gt; keys) throws IOException {
 582         // persist static widget info that hasn&#x27;t been persisted yet
 583         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 584         if (appState == null) {
 585             dataChanged(); // try again later
 586             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);
 587             return;
 588         }
 589         final ContentResolver cr = mContext.getContentResolver();
 590         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 591         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 592         final IconCache iconCache = appState.getIconCache();
 593         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 594         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 595         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 596 
 597         // read the old ID set
 598         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 599         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 600 
 601         int startRows = out.rows;
 602         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 603         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 604         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 605                 where, null, null);
 606         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 607         try {
 608             cursor.moveToPosition(-1);
 609             while(cursor.moveToNext()) {
 610                 final long id = cursor.getLong(ID_INDEX);
 611                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 612                 final int spanX = cursor.getInt(SPANX_INDEX);
 613                 final int spanY = cursor.getInt(SPANY_INDEX);
 614                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 615                 Key key = null;
 616                 String backupKey = null;
 617                 if (provider != null) {
 618                     key = getKey(Key.WIDGET, providerName);
 619                     backupKey = keyToBackupKey(key);
 620                     currentIds.add(backupKey);
 621                 } else {
 622                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 623                 }
 624                 if (savedIds.contains(backupKey)) {
 625                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 626 
 627                     // remember that we already backed this up previously
 628                     keys.add(key);
 629                 } else if (backupKey != null) {
 630                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 631                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 632                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 633                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 634                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 635                         byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);
 636                         keys.add(key);
 637                         writeRowToBackup(key, blob, out, data);
 638 
 639                     } else {
 640                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 641                         // too many widgets for this pass, request another.
 642                         dataChanged();
 643                     }
 644                 }
 645             }
 646         } finally {
 647             cursor.close();
 648         }
 649         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 650 
 651         // these IDs must have been deleted
 652         savedIds.removeAll(currentIds);
 653         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 654     }
 655 
 656     /**
 657      * Read a widget from the stream.
 658      *
 659      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 660      *
 661      * @param key identifier for the row
 662      * @param buffer the serialized proto from the stream, may be larger than dataSize
 663      * @param dataSize the size of the proto from the stream
 664      * @param keys keys to mark as clean in the notes for next backup
 665      */
 666     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 667         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 668         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 669                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 670         try {
 671             Widget widget = unpackWidget(buffer, 0, dataSize);
 672             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 673             if (widget.icon.data != null)  {
 674                 Bitmap icon = BitmapFactory
 675                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 676                 if (icon == null) {
 677                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 678                 }
 679             }
 680 
 681             if (!mRestoreEnabled) {
 682                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 683                 return;
 684             } else {
 685                 // future site of widget table mutation
 686             }
 687         } catch (InvalidProtocolBufferNanoException e) {
 688             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 689         }
 690     }
 691 
 692     /** create a new key, with an integer ID.
 693      *
 694      * &lt;P&gt; Keys contain their own checksum instead of using
 695      * the heavy-weight CheckedMessage wrapper.
 696      */
 697     private Key getKey(int type, long id) {
 698         Key key = new Key();
 699         key.type = type;
 700         key.id = id;
 701         key.checksum = checkKey(key);
 702         return key;
 703     }
 704 
 705     /** create a new key for a named object.
 706      *
 707      * &lt;P&gt; Keys contain their own checksum instead of using
 708      * the heavy-weight CheckedMessage wrapper.
 709      */
 710     private Key getKey(int type, String name) {
 711         Key key = new Key();
 712         key.type = type;
 713         key.name = name;
 714         key.checksum = checkKey(key);
 715         return key;
 716     }
 717 
 718     /** keys need to be strings, serialize and encode. */
 719     private String keyToBackupKey(Key key) {
 720         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 721     }
 722 
 723     /** keys need to be strings, decode and parse. */
 724     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 725         try {
 726             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 727             if (key.checksum != checkKey(key)) {
 728                 key = null;
 729                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 730             }
 731             return key;
 732         } catch (InvalidProtocolBufferNanoException e) {
 733             throw new KeyParsingException(e);
 734         } catch (IllegalArgumentException e) {
 735             throw new KeyParsingException(e);
 736         }
 737     }
 738 
 739     private String getKeyName(Key key) {
 740         if (TextUtils.isEmpty(key.name)) {
 741             return Long.toString(key.id);
 742         } else {
 743             return key.name;
 744         }
 745 
 746     }
 747 
 748     private String geKeyType(Key key) {
 749         switch (key.type) {
 750             case Key.FAVORITE:
 751                 return &quot;favorite&quot;;
 752             case Key.SCREEN:
 753                 return &quot;screen&quot;;
 754             case Key.ICON:
 755                 return &quot;icon&quot;;
 756             case Key.WIDGET:
 757                 return &quot;widget&quot;;
 758             default:
 759                 return &quot;anonymous&quot;;
 760         }
 761     }
 762 
 763     /** Compute the checksum over the important bits of a key. */
 764     private long checkKey(Key key) {
 765         CRC32 checksum = new CRC32();
 766         checksum.update(key.type);
 767         checksum.update((int) (key.id &amp; 0xffff));
 768         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 769         if (!TextUtils.isEmpty(key.name)) {
 770             checksum.update(key.name.getBytes());
 771         }
 772         return checksum.getValue();
 773     }
 774 
 775     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 776     private byte[] packFavorite(Cursor c) {
 777         Favorite favorite = new Favorite();
 778         favorite.id = c.getLong(ID_INDEX);
 779         favorite.screen = c.getInt(SCREEN_INDEX);
 780         favorite.container = c.getInt(CONTAINER_INDEX);
 781         favorite.cellX = c.getInt(CELLX_INDEX);
 782         favorite.cellY = c.getInt(CELLY_INDEX);
 783         favorite.spanX = c.getInt(SPANX_INDEX);
 784         favorite.spanY = c.getInt(SPANY_INDEX);
 785         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 786         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 787             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 788             if (!TextUtils.isEmpty(iconPackage)) {
 789                 favorite.iconPackage = iconPackage;
 790             }
 791             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 792             if (!TextUtils.isEmpty(iconResource)) {
 793                 favorite.iconResource = iconResource;
 794             }
 795         }
 796         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 797             byte[] blob = c.getBlob(ICON_INDEX);
 798             if (blob != null &amp;&amp; blob.length &gt; 0) {
 799                 favorite.icon = blob;
 800             }
 801         }
 802         String title = c.getString(TITLE_INDEX);
 803         if (!TextUtils.isEmpty(title)) {
 804             favorite.title = title;
 805         }
 806         String intent = c.getString(INTENT_INDEX);
 807         if (!TextUtils.isEmpty(intent)) {
 808             favorite.intent = intent;
 809         }
 810         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 811         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 812             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 813             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 814             if (!TextUtils.isEmpty(appWidgetProvider)) {
 815                 favorite.appWidgetProvider = appWidgetProvider;
 816             }
 817         }
 818 
 819         return writeCheckedBytes(favorite);
 820     }
 821 
 822     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 823     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 824             throws InvalidProtocolBufferNanoException {
 825         Favorite favorite = new Favorite();
 826         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 827         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 828                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 829         ContentValues values = new ContentValues();
 830         values.put(Favorites._ID, favorite.id);
 831         values.put(Favorites.SCREEN, favorite.screen);
 832         values.put(Favorites.CONTAINER, favorite.container);
 833         values.put(Favorites.CELLX, favorite.cellX);
 834         values.put(Favorites.CELLY, favorite.cellY);
 835         values.put(Favorites.SPANX, favorite.spanX);
 836         values.put(Favorites.SPANY, favorite.spanY);
 837         values.put(Favorites.ICON_TYPE, favorite.iconType);
 838         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 839             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 840             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 841         }
 842         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 843             values.put(Favorites.ICON, favorite.icon);
 844         }
 845         if (!TextUtils.isEmpty(favorite.title)) {
 846             values.put(Favorites.TITLE, favorite.title);
 847         } else {
 848             values.put(Favorites.TITLE, &quot;&quot;);
 849         }
 850         if (!TextUtils.isEmpty(favorite.intent)) {
 851             values.put(Favorites.INTENT, favorite.intent);
 852         }
 853         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 854         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 855             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 856                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 857             }
 858             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 859         }
 860 
 861         // Let LauncherModel know we&#x27;ve been here.
 862         values.put(LauncherSettings.Favorites.RESTORED, 1);
 863 
 864         return values;
 865     }
 866 
 867     /** Serialize a Screen for persistence, including a checksum wrapper. */
 868     private byte[] packScreen(Cursor c) {
 869         Screen screen = new Screen();
 870         screen.id = c.getLong(ID_INDEX);
 871         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 872 
 873         return writeCheckedBytes(screen);
 874     }
 875 
 876     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 877     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 878             throws InvalidProtocolBufferNanoException {
 879         Screen screen = new Screen();
 880         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 881         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 882         ContentValues values = new ContentValues();
 883         values.put(WorkspaceScreens._ID, screen.id);
 884         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 885         return values;
 886     }
 887 
 888     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 889     private byte[] packIcon(int dpi, Bitmap icon) {
 890         Resource res = new Resource();
 891         res.dpi = dpi;
 892         ByteArrayOutputStream os = new ByteArrayOutputStream();
 893         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 894             res.data = os.toByteArray();
 895         }
 896         return writeCheckedBytes(res);
 897     }
 898 
 899     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 900     private Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 901             throws InvalidProtocolBufferNanoException {
 902         Resource res = new Resource();
 903         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 904         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 905         return res;
 906     }
 907 
 908     /** Serialize a widget for persistence, including a checksum wrapper. */
 909     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 910             ComponentName provider) {
 911         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 912         Widget widget = new Widget();
 913         widget.provider = provider.flattenToShortString();
 914         widget.label = info.label;
 915         widget.configure = info.configure != null;
 916         if (info.icon != 0) {
 917             widget.icon = new Resource();
 918             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 919             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 920             ByteArrayOutputStream os = new ByteArrayOutputStream();
 921             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 922                 widget.icon.data = os.toByteArray();
 923                 widget.icon.dpi = dpi;
 924             }
 925         }
 926         if (info.previewImage != 0) {
 927             widget.preview = new Resource();
 928             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 929             ByteArrayOutputStream os = new ByteArrayOutputStream();
 930             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 931                 widget.preview.data = os.toByteArray();
 932                 widget.preview.dpi = dpi;
 933             }
 934         }
 935         return writeCheckedBytes(widget);
 936     }
 937 
 938     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 939     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 940             throws InvalidProtocolBufferNanoException {
 941         Widget widget = new Widget();
 942         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 943         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 944         return widget;
 945     }
 946 
 947     /**
 948      * Read the old journal from the input file.
 949      *
 950      * In the event of any error, just pretend we didn&#x27;t have a journal,
 951      * in that case, do a full backup.
 952      *
 953      * @param oldState the read-0only file descriptor pointing to the old journal
 954      * @return a Journal protocol buffer
 955      */
 956     private Journal readJournal(ParcelFileDescriptor oldState) {
 957         Journal journal = new Journal();
 958         if (oldState == null) {
 959             return journal;
 960         }
 961         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 962         try {
 963             int availableBytes = inStream.available();
 964             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 965             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 966                 byte[] buffer = new byte[availableBytes];
 967                 int bytesRead = 0;
 968                 boolean valid = false;
 969                 InvalidProtocolBufferNanoException lastProtoException = null;
 970                 while (availableBytes &gt; 0) {
 971                     try {
 972                         // OMG what are you doing? This is crazy inefficient!
 973                         // If we read a byte that is not ours, we will cause trouble: b/12491813
 974                         // However, we don&#x27;t know how many bytes to expect (oops).
 975                         // So we have to step through *slowly*, watching for the end.
 976                         int result = inStream.read(buffer, bytesRead, 1);
 977                         if (result &gt; 0) {
 978                             availableBytes -= result;
 979                             bytesRead += result;
 980                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 981                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 982                             }
 983                         } else {
 984                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 985                             // stop reading and see what there is to parse
 986                             availableBytes = 0;
 987                         }
 988                     } catch (IOException e) {
 989                         buffer = null;
 990                         availableBytes = 0;
 991                     }
 992 
 993                     // check the buffer to see if we have a valid journal
 994                     try {
 995                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
 996                         // if we are here, then we have read a valid, checksum-verified journal
 997                         valid = true;
 998                         availableBytes = 0;
 999                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1000                     } catch (InvalidProtocolBufferNanoException e) {
1001                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1002                         lastProtoException = e;
1003                         journal.clear();
1004                     }
1005                 }
1006                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1007                 if (!valid) {
1008                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1009                 }
1010             }
1011         } catch (IOException e) {
1012             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1013         } finally {
1014             try {
1015                 inStream.close();
1016             } catch (IOException e) {
1017                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1018             }
1019         }
1020         return journal;
1021     }
1022 
1023     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1024             BackupDataOutput data) throws IOException {
1025         String backupKey = keyToBackupKey(key);
1026         data.writeEntityHeader(backupKey, blob.length);
1027         data.writeEntityData(blob, blob.length);
1028         out.rows++;
1029         out.bytes += blob.length;
1030         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1031                 getKeyName(key) + &quot;/&quot; + blob.length);
1032         if(DEBUG_PAYLOAD) {
1033             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1034             final int chunkSize = 1024;
1035             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1036                 int end = offset + chunkSize;
1037                 end = Math.min(end, encoded.length());
1038                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1039             }
1040         }
1041     }
1042 
1043     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1044         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1045         for(int i = 0; i &lt; in.key.length; i++) {
1046             Key key = in.key[i];
1047             if (key.type == type) {
1048                 savedIds.add(keyToBackupKey(key));
1049             }
1050         }
1051         return savedIds;
1052     }
1053 
1054     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1055             throws IOException {
1056         int rows = 0;
1057         for(String deleted: deletedIds) {
1058             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1059             data.writeEntityHeader(deleted, -1);
1060             rows++;
1061         }
1062         return rows;
1063     }
1064 
1065     /**
1066      * Write the new journal to the output file.
1067      *
1068      * In the event of any error, just pretend we didn&#x27;t have a journal,
1069      * in that case, do a full backup.
1070 
1071      * @param newState the write-only file descriptor pointing to the new journal
1072      * @param journal a Journal protocol buffer
1073      */
1074     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1075         FileOutputStream outStream = null;
1076         try {
1077             outStream = new FileOutputStream(newState.getFileDescriptor());
1078             final byte[] journalBytes = writeCheckedBytes(journal);
1079             outStream.write(journalBytes);
1080             outStream.close();
1081             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1082         } catch (IOException e) {
1083             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1084         }
1085     }
1086 
1087     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1088     private byte[] writeCheckedBytes(MessageNano proto) {
1089         CheckedMessage wrapper = new CheckedMessage();
1090         wrapper.payload = MessageNano.toByteArray(proto);
1091         CRC32 checksum = new CRC32();
1092         checksum.update(wrapper.payload);
1093         wrapper.checksum = checksum.getValue();
1094         return MessageNano.toByteArray(wrapper);
1095     }
1096 
1097     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1098     private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1099             throws InvalidProtocolBufferNanoException {
1100         CheckedMessage wrapper = new CheckedMessage();
1101         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1102         CRC32 checksum = new CRC32();
1103         checksum.update(wrapper.payload);
1104         if (wrapper.checksum != checksum.getValue()) {
1105             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1106         }
1107         return wrapper.payload;
1108     }
1109 
1110     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1111         if (mWidgetMap == null) {
1112             List&lt;AppWidgetProviderInfo&gt; widgets =
1113                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1114             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1115             for (AppWidgetProviderInfo info : widgets) {
1116                 mWidgetMap.put(info.provider, info);
1117             }
1118         }
1119         return mWidgetMap.get(component);
1120     }
1121 
1122 
1123    // check if the launcher is in a state to support backup
1124     private boolean launcherIsReady() {
1125         ContentResolver cr = mContext.getContentResolver();
1126         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1127         if (cursor == null) {
1128             // launcher data has been wiped, do nothing
1129             return false;
1130         }
1131         cursor.close();
1132 
1133         if (!initializeIconCache()) {
1134             // launcher services are unavailable, try again later
1135             dataChanged();
1136             return false;
1137         }
1138 
1139         return true;
1140     }
1141 
1142     private class KeyParsingException extends Throwable {
1143         private KeyParsingException(Throwable cause) {
1144             super(cause);
1145         }
1146 
1147         public KeyParsingException(String reason) {
1148             super(reason);
1149         }
1150     }
1151 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ComponentName;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.database.Cursor;
  30 import android.graphics.Bitmap;
  31 import android.graphics.BitmapFactory;
  32 import android.graphics.drawable.Drawable;
  33 import android.os.ParcelFileDescriptor;
  34 import android.text.TextUtils;
  35 import android.util.Base64;
  36 import android.util.Log;
  37 import com.android.launcher3.LauncherSettings.Favorites;
  38 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  39 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  40 import com.android.launcher3.backup.BackupProtos.Favorite;
  41 import com.android.launcher3.backup.BackupProtos.Journal;
  42 import com.android.launcher3.backup.BackupProtos.Key;
  43 import com.android.launcher3.backup.BackupProtos.Resource;
  44 import com.android.launcher3.backup.BackupProtos.Screen;
  45 import com.android.launcher3.backup.BackupProtos.Widget;
  46 import com.android.launcher3.backup.BackupProtos;
  47 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  48 import com.google.protobuf.nano.MessageNano;
  49 import java.io.ByteArrayOutputStream;
  50 import java.io.FileInputStream;
  51 import java.io.FileOutputStream;
  52 import java.io.IOException;
  53 import java.net.URISyntaxException;
  54 import java.util.ArrayList;
  55 import java.util.HashMap;
  56 import java.util.HashSet;
  57 import java.util.List;
  58 import java.util.Set;
  59 import java.util.zip.CRC32;
  60 
  61 
  62 /**
  63  * Persist the launcher home state across calamities.
  64  */
  65 public class LauncherBackupHelper implements BackupHelper {
  66     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  67 
  68     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  69 
  70     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  71 
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /**
  77      * icons are large, dribble them out
  78      */
  79     private static final int MAX_ICONS_PER_PASS = 10;
  80 
  81     /**
  82      * widgets contain previews, which are very large, dribble them out
  83      */
  84     private static final int MAX_WIDGETS_PER_PASS = 5;
  85 
  86     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  87 
  88     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  89 
  90     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  91 
  92     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  93             android.graphics.Bitmap.CompressFormat.PNG;
  94 
  95     private static BackupManager sBackupManager;
  96 
  97     private static final String[] FAVORITE_PROJECTION = new java.lang.String[]{ Favorites._ID, // 0
  98     Favorites.MODIFIED, // 1
  99     Favorites.INTENT, // 2
 100     Favorites.APPWIDGET_PROVIDER// 3
 101     , Favorites.APPWIDGET_ID// 4
 102     , Favorites.CELLX, // 5
 103     Favorites.CELLY, // 6
 104     Favorites.CONTAINER, // 7
 105     Favorites.ICON, // 8
 106     Favorites.ICON_PACKAGE// 9
 107     , Favorites.ICON_RESOURCE// 10
 108     , Favorites.ICON_TYPE, // 11
 109     Favorites.ITEM_TYPE, // 12
 110     Favorites.SCREEN, // 13
 111     Favorites.SPANX, // 14
 112     Favorites.SPANY, // 15
 113     Favorites.TITLE// 16
 114      };
 115 
 116     private static final int ID_INDEX = 0;
 117 
 118     private static final int ID_MODIFIED = 1;
 119 
 120     private static final int INTENT_INDEX = 2;
 121 
 122     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 123 
 124     private static final int APPWIDGET_ID_INDEX = 4;
 125 
 126     private static final int CELLX_INDEX = 5;
 127 
 128     private static final int CELLY_INDEX = 6;
 129 
 130     private static final int CONTAINER_INDEX = 7;
 131 
 132     private static final int ICON_INDEX = 8;
 133 
 134     private static final int ICON_PACKAGE_INDEX = 9;
 135 
 136     private static final int ICON_RESOURCE_INDEX = 10;
 137 
 138     private static final int ICON_TYPE_INDEX = 11;
 139 
 140     private static final int ITEM_TYPE_INDEX = 12;
 141 
 142     private static final int SCREEN_INDEX = 13;
 143 
 144     private static final int SPANX_INDEX = 14;
 145 
 146     private static final int SPANY_INDEX = 15;
 147 
 148     private static final int TITLE_INDEX = 16;
 149 
 150     private static final String[] SCREEN_PROJECTION = new java.lang.String[]{ WorkspaceScreens._ID, // 0
 151     WorkspaceScreens.MODIFIED// 1
 152     , WorkspaceScreens.SCREEN_RANK// 2
 153      };
 154 
 155     private static final int SCREEN_RANK_INDEX = 2;
 156 
 157     private final Context mContext;
 158 
 159     private final boolean mRestoreEnabled;
 160 
 161     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 162 
 163     private ArrayList&lt;Key&gt; mKeys;
 164 
 165     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 166         mContext = context;
 167         mRestoreEnabled = restoreEnabled;
 168     }
 169 
 170     private void dataChanged() {
 171         if (sBackupManager == null) {
 172             sBackupManager = new BackupManager(mContext);
 173         }
 174         sBackupManager.dataChanged();
 175     }
 176 
 177     /**
 178      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 179      *
 180      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 181      *
 182      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 183      *
 184      * @param oldState notes from the last backup
 185      * @param data incremental key/value pairs to persist off-device
 186      * @param newState notes for the next backup
 187      * @throws IOException
 188      */
 189     @Override
<abbr title=" 190     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) {"> 190     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor </abbr>
 191         if (VERBOSE) {
 192             Log.v(TAG, &quot;onBackup&quot;);
 193         }
 194         Journal in = readJournal(oldState);
 195         Journal out = new Journal();
 196         long lastBackupTime = in.t;
 197         out.t = System.currentTimeMillis();
 198         out.rows = 0;
 199         out.bytes = 0;
 200         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 201         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 202         if (launcherIsReady()) {
 203             try {
 204                 backupFavorites(in, data, out, keys);
 205                 backupScreens(in, data, out, keys);
 206                 backupIcons(in, data, out, keys);
 207                 backupWidgets(in, data, out, keys);
 208             } catch (IOException e) {
 209                 Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 210             }
 211             out.key = keys.toArray(BackupProtos.Key.emptyArray());
 212         } else {
 213             out = in;
 214         }
 215         writeJournal(newState, out);
 216         Log.v(TAG, (((&quot;onBackup: wrote &quot; + out.bytes) + &quot;b in &quot;) + out.rows) + &quot; rows.&quot;);
 217     }
 218 
 219     /**
 220      * Restore launcher configuration from the restored data stream.
 221      *
 222      * &lt;P&gt;Keys may arrive in any order.
 223      *
 224      * @param data the key/value pair from the server
 225      */
 226     @Override
 227     public void restoreEntity(BackupDataInputStream data) {
 228         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 229         if (mKeys == null) {
 230             mKeys = new ArrayList&lt;Key&gt;();
 231         }
 232         byte[] buffer = new byte[512];
 233             String backupKey = data.getKey();
 234             int dataSize = data.size();
 235             if (buffer.length &lt; dataSize) {
 236                 buffer = new byte[dataSize];
 237             }
 238             Key key = null;
 239         int bytesRead = 0;
 240         try {
 241             bytesRead = data.read(buffer, 0, dataSize);
 242             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 243         } catch (IOException e) {
 244             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 245         }
 246         try {
 247             key = backupKeyToKey(backupKey);
 248             mKeys.add(key);
 249             switch (key.type) {
 250                 case Key.FAVORITE:
 251                     restoreFavorite(key, buffer, dataSize, mKeys);
 252                     break;
 253 
 254                 case Key.SCREEN:
 255                     restoreScreen(key, buffer, dataSize, mKeys);
 256                     break;
 257 
 258                 case Key.ICON:
 259                     restoreIcon(key, buffer, dataSize, mKeys);
 260                     break;
 261 
 262                 case Key.WIDGET:
 263                     restoreWidget(key, buffer, dataSize, mKeys);
 264                     break;
 265 
 266                 default:
 267                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 268                     break;
 269             }
 270         } catch (KeyParsingException e) {
 271             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 272         }
 273 
 274     }
 275 
 276     /**
 277      * Record the restore state for the next backup.
 278      *
 279      * @param newState notes about the backup state after restore.
 280      */
 281     @Override
 282     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 283         // clear the output journal time, to force a full backup to
 284         // will catch any changes the restore process might have made
 285         Journal out = new Journal();
 286         out.t = 0;
 287         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());
 288         writeJournal(newState, out);
 289         Log.v(TAG, (&quot;onRestore: read &quot; + mKeys.size()) + &quot; rows&quot;);
 290         mKeys.clear();
 291     }
 292 
 293     /**
 294      * Write all modified favorites to the data stream.
 295      *
 296      *
 297      * @param in notes from last backup
 298      * @param data output stream for key/value pairs
 299      * @param out notes about this backup
 300      * @param keys keys to mark as clean in the notes for next backup
 301      * @throws IOException
 302      */
 303     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 304             ArrayList&lt;Key&gt; keys)
 305             throws IOException {
 306         // read the old ID set
 307         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 308         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 309 
 310         // persist things that have changed since the last backup
 311         ContentResolver cr = mContext.getContentResolver();
 312         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 313                 null, null, null);
 314         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 315         try {
 316             cursor.moveToPosition(-1);
 317             while(cursor.moveToNext()) {
 318                 final long id = cursor.getLong(ID_INDEX);
 319                 final long updateTime = cursor.getLong(ID_MODIFIED);
 320                 Key key = getKey(Key.FAVORITE, id);
 321                 keys.add(key);
 322                 final String backupKey = keyToBackupKey(key);
 323                 currentIds.add(backupKey);
 324                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 325                     byte[] blob = packFavorite(cursor);
 326                     writeRowToBackup(key, blob, out, data);
 327                 } else {
 328                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 329                 }
 330             }
 331         } finally {
 332             cursor.close();
 333         }
 334         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 335 
 336         // these IDs must have been deleted
 337         savedIds.removeAll(currentIds);
 338         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 339     }
 340 
 341     /**
 342      * Read a favorite from the stream.
 343      *
 344      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 345      *
 346      * @param key identifier for the row
 347      * @param buffer the serialized proto from the stream, may be larger than dataSize
 348      * @param dataSize the size of the proto from the stream
 349      * @param keys keys to mark as clean in the notes for next backup
 350      */
 351     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 352         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 353         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 354                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 355 
 356         if (!mRestoreEnabled) {
 357             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 358             return;
 359         }
 360 
 361         try {
 362             ContentResolver cr = mContext.getContentResolver();
 363             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 364             cr.insert(Favorites.CONTENT_URI, values);
 365         } catch (InvalidProtocolBufferNanoException e) {
 366             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 367         }
 368     }
 369 
 370     /**
 371      * Write all modified screens to the data stream.
 372      *
 373      *
 374      * @param in notes from last backup
 375      * @param data output stream for key/value pairs
 376      * @param out notes about this backup
 377      * @param keys keys to mark as clean in the notes for next backup
 378      * @throws IOException
 379      */
 380     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 381             ArrayList&lt;Key&gt; keys)
 382             throws IOException {
 383         // read the old ID set
 384         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 385         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 386 
 387         // persist things that have changed since the last backup
 388         ContentResolver cr = mContext.getContentResolver();
 389         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 390                 null, null, null);
 391         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 392         try {
 393             cursor.moveToPosition(-1);
 394             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 395             while(cursor.moveToNext()) {
 396                 final long id = cursor.getLong(ID_INDEX);
 397                 final long updateTime = cursor.getLong(ID_MODIFIED);
 398                 Key key = getKey(Key.SCREEN, id);
 399                 keys.add(key);
 400                 final String backupKey = keyToBackupKey(key);
 401                 currentIds.add(backupKey);
 402                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 403                     byte[] blob = packScreen(cursor);
 404                     writeRowToBackup(key, blob, out, data);
 405                 } else {
 406                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 407                 }
 408             }
 409         } finally {
 410             cursor.close();
 411         }
 412         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 413 
 414         // these IDs must have been deleted
 415         savedIds.removeAll(currentIds);
 416         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 417     }
 418 
 419     /**
 420      * Read a screen from the stream.
 421      *
 422      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 423      *
 424      * @param key identifier for the row
 425      * @param buffer the serialized proto from the stream, may be larger than dataSize
 426      * @param dataSize the size of the proto from the stream
 427      * @param keys keys to mark as clean in the notes for next backup
 428      */
 429     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 430         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 431         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 432                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 433 
 434         if (!mRestoreEnabled) {
 435             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 436             return;
 437         }
 438 
 439         try {
 440             ContentResolver cr = mContext.getContentResolver();
 441             ContentValues values = unpackScreen(buffer, 0, dataSize);
 442             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 443 
 444         } catch (InvalidProtocolBufferNanoException e) {
 445             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 446         }
 447     }
 448 
 449     /**
 450      * Write all the static icon resources we need to render placeholders
 451      * for a package that is not installed.
 452      *
 453      * @param in notes from last backup
 454      * @param data output stream for key/value pairs
 455      * @param out notes about this backup
 456      * @param keys keys to mark as clean in the notes for next backup
 457      * @throws IOException
 458      */
<abbr title=" 459     private void backupIcons(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 459     private void backupIcons(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws </abbr>
 460         // persist icons that haven&#x27;t been persisted yet
 461         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 462         if (appState == null) {
 463             dataChanged();// try again later
 464 
 465             if (DEBUG) {
 466                 Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 467             }
 468             return;
 469         }
 470         final ContentResolver cr = mContext.getContentResolver();
 471         final IconCache iconCache = appState.getIconCache();
 472         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 473         // read the old ID set
 474         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 475         if (DEBUG) {
 476             Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 477         }
 478         int startRows = out.rows;
 479         if (DEBUG) {
 480             Log.d(TAG, &quot;starting here: &quot; + startRows);
 481         }
 482         String where = (Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION;
 483         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 484         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 485         try {
 486             cursor.moveToPosition(-1);
 487             while (cursor.moveToNext()) {
 488                 final long id = cursor.getLong(ID_INDEX);
 489                 final String intentDescription = cursor.getString(INTENT_INDEX);
 490                 try {
 491                     Intent intent = Intent.parseUri(intentDescription, 0);
 492                     ComponentName cn = intent.getComponent();
 493                     Key key = null;
 494                     String backupKey = null;
 495                     if (cn != null) {
 496                         key = getKey(Key.ICON, cn.flattenToShortString());
 497                         backupKey = keyToBackupKey(key);
 498                         currentIds.add(backupKey);
 499                     } else {
 500                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 501                     }
 502                     if (savedIds.contains(backupKey)) {
 503                         if (VERBOSE) {
 504                             Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 505                         }
 506                         // remember that we already backed this up previously
 507                         keys.add(key);
 508                     } else if (backupKey != null) {
 509                         if (DEBUG) {
 510                             Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 511                         }
 512                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 513                             if (VERBOSE) {
 514                                 Log.v(TAG, &quot;saving icon &quot; + backupKey);
 515                             }
 516                             Bitmap icon = iconCache.getIcon(intent);
 517                             keys.add(key);
 518                             if ((icon != null) &amp;&amp; (!iconCache.isDefaultIcon(icon))) {
 519                                 byte[] blob = packIcon(dpi, icon);
 520                                 writeRowToBackup(key, blob, out, data);
 521                             }
 522                         } else {
 523                             if (VERBOSE) {
 524                                 Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 525                             }
 526                             // too many icons for this pass, request another.
 527                             dataChanged();
 528                         }
 529                     }
 530                 } catch (URISyntaxException e) {
 531                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 532                 } catch (IOException e) {
 533                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 534                 }
 535             }
 536         } finally {
 537             cursor.close();
 538         }
 539         if (DEBUG) {
 540             Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 541         }
 542         // these IDs must have been deleted
 543         savedIds.removeAll(currentIds);
 544         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 545     }
 546 
 547     /**
 548      * Read an icon from the stream.
 549      *
 550      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 551      *
 552      * @param key identifier for the row
 553      * @param buffer the serialized proto from the stream, may be larger than dataSize
 554      * @param dataSize the size of the proto from the stream
 555      * @param keys keys to mark as clean in the notes for next backup
 556      */
 557     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 558         if (VERBOSE) {
 559             Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 560         }
 561         if (DEBUG) {
<abbr title=" 562             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 562             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 563         }
 564         try {
 565             Resource res = unpackIcon(buffer, 0, dataSize);
 566             if (DEBUG) {
 567                 Log.d(TAG, (&quot;unpacked &quot; + res.dpi) + &quot; dpi icon&quot;);
 568             }
 569             if (DEBUG_PAYLOAD) {
<abbr title=" 570                 Log.d(TAG, &quot;read &quot; + Base64.encodeToString(res.data, 0, res.data.length, Base64.NO_WRAP));"> 570                 Log.d(TAG, &quot;read &quot; + Base64.encodeToString(res.data, 0, res.data.length, Base64.NO_WRAP))</abbr>
 571             }
 572             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 573             if (icon == null) {
 574                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 575             }
 576             if (!mRestoreEnabled) {
 577                 if (VERBOSE) {
 578                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 579                 }
 580                 return;
 581             } else {
 582                 // future site of icon cache mutation
 583             }
 584         } catch (InvalidProtocolBufferNanoException e) {
 585             Log.e(TAG, &quot;failed to decode icon&quot;, e);
 586         }
 587     }
 588 
 589     /**
 590      * Write all the static widget resources we need to render placeholders
 591      * for a package that is not installed.
 592      *
 593      * @param in notes from last backup
 594      * @param data output stream for key/value pairs
 595      * @param out notes about this backup
 596      * @param keys keys to mark as clean in the notes for next backup
 597      * @throws IOException
 598      */
<abbr title=" 599     private void backupWidgets(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 599     private void backupWidgets(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throw</abbr>
 600         // persist static widget info that hasn&#x27;t been persisted yet
 601         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 602         if (appState == null) {
 603             // try again later
 604             dataChanged();
 605             if (DEBUG) {
 606                 Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);
 607             }
 608             return;
 609         }
 610         final ContentResolver cr = mContext.getContentResolver();
 611         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 612         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 613         final IconCache iconCache = appState.getIconCache();
 614         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 615         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 616         if (DEBUG) {
 617             Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 618         }
 619         // read the old ID set
 620         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 621         if (DEBUG) {
 622             Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 623         }
 624         int startRows = out.rows;
 625         if (DEBUG) {
 626             Log.d(TAG, &quot;starting here: &quot; + startRows);
 627         }
 628         String where = (Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET;
 629         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 630         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 631         try {
 632             cursor.moveToPosition(-1);
 633             while (cursor.moveToNext()) {
 634                 final long id = cursor.getLong(ID_INDEX);
 635                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 636                 final int spanX = cursor.getInt(SPANX_INDEX);
 637                 final int spanY = cursor.getInt(SPANY_INDEX);
 638                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 639                 Key key = null;
 640                 String backupKey = null;
 641                 if (provider != null) {
 642                     key = getKey(Key.WIDGET, providerName);
 643                     backupKey = keyToBackupKey(key);
 644                     currentIds.add(backupKey);
 645                 } else {
 646                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 647                 }
 648                 if (savedIds.contains(backupKey)) {
 649                     if (VERBOSE) {
 650                         Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 651                     }
 652                     // remember that we already backed this up previously
 653                     keys.add(key);
 654                 } else if (backupKey != null) {
 655                     if (DEBUG) {
 656                         Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 657                     }
 658                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 659                         if (VERBOSE) {
 660                             Log.v(TAG, &quot;saving widget &quot; + backupKey);
 661                         }
<abbr title=" 662                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHeightPx, widgetSpacingLayout);"> 662                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHei</abbr>
 663                         byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);
 664                         keys.add(key);
 665                         writeRowToBackup(key, blob, out, data);
 666                     } else {
 667                         if (VERBOSE) {
 668                             Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 669                         }
 670                         // too many widgets for this pass, request another.
 671                         dataChanged();
 672                     }
 673                 }
 674             }
 675         } finally {
 676             cursor.close();
 677         }
 678         if (DEBUG) {
 679             Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 680         }
 681         // these IDs must have been deleted
 682         savedIds.removeAll(currentIds);
 683         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 684     }
 685 
 686     /**
 687      * Read a widget from the stream.
 688      *
 689      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 690      *
 691      * @param key identifier for the row
 692      * @param buffer the serialized proto from the stream, may be larger than dataSize
 693      * @param dataSize the size of the proto from the stream
 694      * @param keys keys to mark as clean in the notes for next backup
 695      */
 696     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 697         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 698         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 699                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 700         try {
 701             Widget widget = unpackWidget(buffer, 0, dataSize);
 702             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 703             if (widget.icon.data != null)  {
 704                 Bitmap icon = BitmapFactory
 705                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 706                 if (icon == null) {
 707                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 708                 }
 709             }
 710 
 711             if (!mRestoreEnabled) {
 712                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 713                 return;
 714             } else {
 715                 // future site of widget table mutation
 716             }
 717         } catch (InvalidProtocolBufferNanoException e) {
 718             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 719         }
 720     }
 721 
 722     /** create a new key, with an integer ID.
 723      *
 724      * &lt;P&gt; Keys contain their own checksum instead of using
 725      * the heavy-weight CheckedMessage wrapper.
 726      */
 727     private Key getKey(int type, long id) {
 728         Key key = new Key();
 729         key.type = type;
 730         key.id = id;
 731         key.checksum = checkKey(key);
 732         return key;
 733     }
 734 
 735     /** create a new key for a named object.
 736      *
 737      * &lt;P&gt; Keys contain their own checksum instead of using
 738      * the heavy-weight CheckedMessage wrapper.
 739      */
 740     private Key getKey(int type, String name) {
 741         Key key = new Key();
 742         key.type = type;
 743         key.name = name;
 744         key.checksum = checkKey(key);
 745         return key;
 746     }
 747 
 748     /** keys need to be strings, serialize and encode. */
 749     private String keyToBackupKey(Key key) {
 750         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 751     }
 752 
 753     /** keys need to be strings, decode and parse. */
 754     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 755         try {
 756             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 757             if (key.checksum != checkKey(key)) {
 758                 key = null;
 759                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 760             }
 761             return key;
 762         } catch (InvalidProtocolBufferNanoException e) {
 763             throw new KeyParsingException(e);
 764         } catch (IllegalArgumentException e) {
 765             throw new KeyParsingException(e);
 766         }
 767     }
 768 
 769     private String getKeyName(Key key) {
 770         if (TextUtils.isEmpty(key.name)) {
 771             return Long.toString(key.id);
 772         } else {
 773             return key.name;
 774         }
 775 
 776     }
 777 
 778     private String geKeyType(Key key) {
 779         switch (key.type) {
 780             case Key.FAVORITE:
 781                 return &quot;favorite&quot;;
 782             case Key.SCREEN:
 783                 return &quot;screen&quot;;
 784             case Key.ICON:
 785                 return &quot;icon&quot;;
 786             case Key.WIDGET:
 787                 return &quot;widget&quot;;
 788             default:
 789                 return &quot;anonymous&quot;;
 790         }
 791     }
 792 
 793     /** Compute the checksum over the important bits of a key. */
 794     private long checkKey(Key key) {
 795         CRC32 checksum = new CRC32();
 796         checksum.update(key.type);
 797         checksum.update((int) (key.id &amp; 0xffff));
 798         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 799         if (!TextUtils.isEmpty(key.name)) {
 800             checksum.update(key.name.getBytes());
 801         }
 802         return checksum.getValue();
 803     }
 804 
 805     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 806     private byte[] packFavorite(Cursor c) {
 807         Favorite favorite = new Favorite();
 808         favorite.id = c.getLong(ID_INDEX);
 809         favorite.screen = c.getInt(SCREEN_INDEX);
 810         favorite.container = c.getInt(CONTAINER_INDEX);
 811         favorite.cellX = c.getInt(CELLX_INDEX);
 812         favorite.cellY = c.getInt(CELLY_INDEX);
 813         favorite.spanX = c.getInt(SPANX_INDEX);
 814         favorite.spanY = c.getInt(SPANY_INDEX);
 815         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 816         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 817             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 818             if (!TextUtils.isEmpty(iconPackage)) {
 819                 favorite.iconPackage = iconPackage;
 820             }
 821             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 822             if (!TextUtils.isEmpty(iconResource)) {
 823                 favorite.iconResource = iconResource;
 824             }
 825         }
 826         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 827             byte[] blob = c.getBlob(ICON_INDEX);
 828             if (blob != null &amp;&amp; blob.length &gt; 0) {
 829                 favorite.icon = blob;
 830             }
 831         }
 832         String title = c.getString(TITLE_INDEX);
 833         if (!TextUtils.isEmpty(title)) {
 834             favorite.title = title;
 835         }
 836         String intent = c.getString(INTENT_INDEX);
 837         if (!TextUtils.isEmpty(intent)) {
 838             favorite.intent = intent;
 839         }
 840         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 841         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 842             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 843             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 844             if (!TextUtils.isEmpty(appWidgetProvider)) {
 845                 favorite.appWidgetProvider = appWidgetProvider;
 846             }
 847         }
 848 
 849         return writeCheckedBytes(favorite);
 850     }
 851 
 852     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
<abbr title=" 853     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 853     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize) throws InvalidProtocolB</abbr>
 854         Favorite favorite = new Favorite();
 855         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 856         if (VERBOSE) {
<abbr title=" 857             Log.v(TAG, ((&quot;unpacked favorite &quot; + favorite.itemType) + &quot;, &quot;) + (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));"> 857             Log.v(TAG, ((&quot;unpacked favorite &quot; + favorite.itemType) + &quot;, &quot;) + (TextUtils.isEmpty(favorite.</abbr>
 858         }
 859         ContentValues values = new ContentValues();
 860         values.put(Favorites._ID, favorite.id);
 861         values.put(Favorites.SCREEN, favorite.screen);
 862         values.put(Favorites.CONTAINER, favorite.container);
 863         values.put(Favorites.CELLX, favorite.cellX);
 864         values.put(Favorites.CELLY, favorite.cellY);
 865         values.put(Favorites.SPANX, favorite.spanX);
 866         values.put(Favorites.SPANY, favorite.spanY);
 867         values.put(Favorites.ICON_TYPE, favorite.iconType);
 868         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 869             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 870             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 871         }
 872         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 873             values.put(Favorites.ICON, favorite.icon);
 874         }
 875         if (!TextUtils.isEmpty(favorite.title)) {
 876             values.put(Favorites.TITLE, favorite.title);
 877         } else {
 878             values.put(Favorites.TITLE, &quot;&quot;);
 879         }
 880         if (!TextUtils.isEmpty(favorite.intent)) {
 881             values.put(Favorites.INTENT, favorite.intent);
 882         }
 883         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 884         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 885             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 886                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 887             }
 888             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 889         }
 890         // Let LauncherModel know we&#x27;ve been here.
 891         values.put(LauncherSettings.Favorites.RESTORED, 1);
 892         return values;
 893     }
 894 
 895     /** Serialize a Screen for persistence, including a checksum wrapper. */
 896     private byte[] packScreen(Cursor c) {
 897         Screen screen = new Screen();
 898         screen.id = c.getLong(ID_INDEX);
 899         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 900 
 901         return writeCheckedBytes(screen);
 902     }
 903 
 904     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
<abbr title=" 905     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 905     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBuf</abbr>
 906         Screen screen = new Screen();
 907         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 908         if (VERBOSE) {
 909             Log.v(TAG, ((&quot;unpacked screen &quot; + screen.id) + &quot;/&quot;) + screen.rank);
 910         }
 911         ContentValues values = new ContentValues();
 912         values.put(WorkspaceScreens._ID, screen.id);
 913         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 914         return values;
 915     }
 916 
 917     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 918     private byte[] packIcon(int dpi, Bitmap icon) {
 919         Resource res = new Resource();
 920         res.dpi = dpi;
 921         ByteArrayOutputStream os = new ByteArrayOutputStream();
 922         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 923             res.data = os.toByteArray();
 924         }
 925         return writeCheckedBytes(res);
 926     }
 927 
 928     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
<abbr title=" 929     private Resource unpackIcon(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 929     private Resource unpackIcon(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNano</abbr>
 930         Resource res = new Resource();
 931         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 932         if (VERBOSE) {
 933             Log.v(TAG, ((&quot;unpacked icon &quot; + res.dpi) + &quot;/&quot;) + res.data.length);
 934         }
 935         return res;
 936     }
 937 
 938     /** Serialize a widget for persistence, including a checksum wrapper. */
 939     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 940             ComponentName provider) {
 941         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 942         Widget widget = new Widget();
 943         widget.provider = provider.flattenToShortString();
 944         widget.label = info.label;
 945         widget.configure = info.configure != null;
 946         if (info.icon != 0) {
 947             widget.icon = new Resource();
 948             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 949             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 950             ByteArrayOutputStream os = new ByteArrayOutputStream();
 951             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 952                 widget.icon.data = os.toByteArray();
 953                 widget.icon.dpi = dpi;
 954             }
 955         }
 956         if (info.previewImage != 0) {
 957             widget.preview = new Resource();
 958             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 959             ByteArrayOutputStream os = new ByteArrayOutputStream();
 960             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 961                 widget.preview.data = os.toByteArray();
 962                 widget.preview.dpi = dpi;
 963             }
 964         }
 965         return writeCheckedBytes(widget);
 966     }
 967 
 968     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
<abbr title=" 969     private Widget unpackWidget(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 969     private Widget unpackWidget(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNano</abbr>
 970         Widget widget = new Widget();
 971         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 972         if (VERBOSE) {
 973             Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 974         }
 975         return widget;
 976     }
 977 
 978     /**
 979      * Read the old journal from the input file.
 980      *
 981      * In the event of any error, just pretend we didn&#x27;t have a journal,
 982      * in that case, do a full backup.
 983      *
 984      * @param oldState the read-0only file descriptor pointing to the old journal
 985      * @return a Journal protocol buffer
 986      */
 987     private Journal readJournal(ParcelFileDescriptor oldState) {
 988         Journal journal = new Journal();
 989         if (oldState == null) {
 990             return journal;
 991         }
 992         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 993         try {
 994             int availableBytes = inStream.available();
 995             if (DEBUG) {
 996                 Log.d(TAG, &quot;available &quot; + availableBytes);
 997             }
 998             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 999                 byte[] buffer = new byte[availableBytes];
1000                 int bytesRead = 0;
1001                 boolean valid = false;
1002                 InvalidProtocolBufferNanoException lastProtoException = null;
1003                 while (availableBytes &gt; 0) {
1004                     try {
1005                         // OMG what are you doing? This is crazy inefficient!
1006                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1007                         // However, we don&#x27;t know how many bytes to expect (oops).
1008                         // So we have to step through *slowly*, watching for the end.
1009                         int result = inStream.read(buffer, bytesRead, 1);
1010                         if (result &gt; 0) {
1011                             availableBytes -= result;
1012                             bytesRead += result;
1013                             if (DEBUG &amp;&amp; ((bytesRead % 100) == 0)) {
1014                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1015                             }
1016                         } else {
1017                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1018                             // stop reading and see what there is to parse
1019                             availableBytes = 0;
1020                         }
1021                     } catch (IOException e) {
1022                         buffer = null;
1023                         availableBytes = 0;
1024                     }
1025                     // check the buffer to see if we have a valid journal
1026                     try {
1027                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1028                         // if we are here, then we have read a valid, checksum-verified journal
1029                         valid = true;
1030                         availableBytes = 0;
1031                         if (VERBOSE) {
1032                             Log.v(TAG, (&quot;read &quot; + bytesRead) + &quot; bytes of journal&quot;);
1033                         }
1034                     } catch (InvalidProtocolBufferNanoException e) {
1035                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1036                         lastProtoException = e;
1037                         journal.clear();
1038                     }
1039                 }
1040                 if (DEBUG) {
1041                     Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1042                 }
1043                 if (!valid) {
1044                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1045                 }
1046             }
1047         } catch (IOException e) {
1048             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1049         } finally {
1050             try {
1051                 inStream.close();
1052             } catch (IOException e) {
1053                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1054             }
1055         }
1056         return journal;
1057     }
1058 
1059     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1060             BackupDataOutput data) throws IOException {
1061         String backupKey = keyToBackupKey(key);
1062         data.writeEntityHeader(backupKey, blob.length);
1063         data.writeEntityData(blob, blob.length);
1064         out.rows++;
1065         out.bytes += blob.length;
1066         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1067                 getKeyName(key) + &quot;/&quot; + blob.length);
1068         if(DEBUG_PAYLOAD) {
1069             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1070             final int chunkSize = 1024;
1071             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1072                 int end = offset + chunkSize;
1073                 end = Math.min(end, encoded.length());
1074                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1075             }
1076         }
1077     }
1078 
1079     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1080         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1081         for(int i = 0; i &lt; in.key.length; i++) {
1082             Key key = in.key[i];
1083             if (key.type == type) {
1084                 savedIds.add(keyToBackupKey(key));
1085             }
1086         }
1087         return savedIds;
1088     }
1089 
1090     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1091             throws IOException {
1092         int rows = 0;
1093         for(String deleted: deletedIds) {
1094             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1095             data.writeEntityHeader(deleted, -1);
1096             rows++;
1097         }
1098         return rows;
1099     }
1100 
1101     /**
1102      * Write the new journal to the output file.
1103      *
1104      * In the event of any error, just pretend we didn&#x27;t have a journal,
1105      * in that case, do a full backup.
1106 
1107      * @param newState the write-only file descriptor pointing to the new journal
1108      * @param journal a Journal protocol buffer
1109      */
1110     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1111         FileOutputStream outStream = null;
1112         try {
1113             outStream = new FileOutputStream(newState.getFileDescriptor());
1114             final byte[] journalBytes = writeCheckedBytes(journal);
1115             outStream.write(journalBytes);
1116             outStream.close();
1117             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1118         } catch (IOException e) {
1119             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1120         }
1121     }
1122 
1123     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1124     private byte[] writeCheckedBytes(MessageNano proto) {
1125         CheckedMessage wrapper = new CheckedMessage();
1126         wrapper.payload = MessageNano.toByteArray(proto);
1127         CRC32 checksum = new CRC32();
1128         checksum.update(wrapper.payload);
1129         wrapper.checksum = checksum.getValue();
1130         return MessageNano.toByteArray(wrapper);
1131     }
1132 
1133     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
<abbr title="1134     private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {">1134     private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBuffer</abbr>
1135         CheckedMessage wrapper = new CheckedMessage();
1136         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1137         CRC32 checksum = new CRC32();
1138         checksum.update(wrapper.payload);
1139         if (wrapper.checksum != checksum.getValue()) {
1140             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1141         }
1142         return wrapper.payload;
1143     }
1144 
1145     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1146         if (mWidgetMap == null) {
1147             List&lt;AppWidgetProviderInfo&gt; widgets =
1148                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1149             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1150             for (AppWidgetProviderInfo info : widgets) {
1151                 mWidgetMap.put(info.provider, info);
1152             }
1153         }
1154         return mWidgetMap.get(component);
1155     }
1156 
1157     private class KeyParsingException extends Throwable {
1158         private KeyParsingException(Throwable cause) {
1159             super(cause);
1160         }
1161 
1162         public KeyParsingException(String reason) {
1163             super(reason);
1164         }
1165     }
1166 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19  import com.google.protobuf.nano.MessageNano;
  20  
  21  import com.android.launcher3.LauncherSettings.Favorites;
  22  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23  import com.android.launcher3.backup.BackupProtos;
  24  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25  import com.android.launcher3.backup.BackupProtos.Favorite;
  26  import com.android.launcher3.backup.BackupProtos.Journal;
  27  import com.android.launcher3.backup.BackupProtos.Key;
  28  import com.android.launcher3.backup.BackupProtos.Resource;
  29  import com.android.launcher3.backup.BackupProtos.Screen;
  30  import com.android.launcher3.backup.BackupProtos.Widget;
  31  
  32  import android.app.backup.BackupDataInputStream;
  33  import android.app.backup.BackupDataOutput;
  34  import android.app.backup.BackupHelper;
  35  import android.app.backup.BackupManager;
  36  import android.appwidget.AppWidgetManager;
  37  import android.appwidget.AppWidgetProviderInfo;
  38  import android.content.ComponentName;
  39  import android.content.ContentResolver;
  40  import android.content.ContentValues;
  41  import android.content.Context;
  42  import android.content.Intent;
  43  import android.database.Cursor;
  44  import android.graphics.Bitmap;
  45  import android.graphics.BitmapFactory;
  46  import android.graphics.drawable.Drawable;
  47  import android.os.ParcelFileDescriptor;
  48  import android.text.TextUtils;
  49  import android.util.Base64;
  50  import android.util.Log;
  51  
  52  import java.io.ByteArrayOutputStream;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import java.io.File;</span>
  54  import java.io.FileInputStream;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import java.io.FileNotFoundException;</span>
  56  import java.io.FileOutputStream;
  57  import java.io.IOException;
  58  import java.net.URISyntaxException;
  59  import java.util.ArrayList;
  60  import java.util.HashMap;
  61  import java.util.HashSet;
  62  import java.util.List;
  63  import java.util.Set;
  64  import java.util.zip.CRC32;
  65  
  66  /**
  67   * Persist the launcher home state across calamities.
  68   */
  69  public class LauncherBackupHelper implements BackupHelper {
  70  
  71      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  72      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  73      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  74      private static final boolean DEBUG_PAYLOAD = false;
  75  
  76      private static final int MAX_JOURNAL_SIZE = 1000000;
  77  
  78      /** icons are large, dribble them out */
  79      private static final int MAX_ICONS_PER_PASS = 10;
  80  
  81      /** widgets contain previews, which are very large, dribble them out */
  82      private static final int MAX_WIDGETS_PER_PASS = 5;
  83  
  84      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  85  
  86      public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  87  
  88      public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  89  
  90      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  91              android.graphics.Bitmap.CompressFormat.PNG;
  92  
  93      private static BackupManager sBackupManager;
  94  
  95      private static final String[] FAVORITE_PROJECTION = {
  96              Favorites._ID,                     // 0
  97              Favorites.MODIFIED,                // 1
  98              Favorites.INTENT,                  // 2
  99              Favorites.APPWIDGET_PROVIDER,      // 3
 100              Favorites.APPWIDGET_ID,            // 4
 101              Favorites.CELLX,                   // 5
 102              Favorites.CELLY,                   // 6
 103              Favorites.CONTAINER,               // 7
 104              Favorites.ICON,                    // 8
 105              Favorites.ICON_PACKAGE,            // 9
 106              Favorites.ICON_RESOURCE,           // 10
 107              Favorites.ICON_TYPE,               // 11
 108              Favorites.ITEM_TYPE,               // 12
 109              Favorites.SCREEN,                  // 13
 110              Favorites.SPANX,                   // 14
 111              Favorites.SPANY,                   // 15
 112              Favorites.TITLE,                   // 16
 113      };
 114  
 115      private static final int ID_INDEX = 0;
 116      private static final int ID_MODIFIED = 1;
 117      private static final int INTENT_INDEX = 2;
 118      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 119      private static final int APPWIDGET_ID_INDEX = 4;
 120      private static final int CELLX_INDEX = 5;
 121      private static final int CELLY_INDEX = 6;
 122      private static final int CONTAINER_INDEX = 7;
 123      private static final int ICON_INDEX = 8;
 124      private static final int ICON_PACKAGE_INDEX = 9;
 125      private static final int ICON_RESOURCE_INDEX = 10;
 126      private static final int ICON_TYPE_INDEX = 11;
 127      private static final int ITEM_TYPE_INDEX = 12;
 128      private static final int SCREEN_INDEX = 13;
 129      private static final int SPANX_INDEX = 14;
 130      private static final int SPANY_INDEX = 15;
 131      private static final int TITLE_INDEX = 16;
 132  
 133      private static final String[] SCREEN_PROJECTION = {
 134              WorkspaceScreens._ID,              // 0
 135              WorkspaceScreens.MODIFIED,         // 1
 136              WorkspaceScreens.SCREEN_RANK       // 2
 137      };
 138  
 139      private static final int SCREEN_RANK_INDEX = 2;
 140  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -    private static IconCache mIconCache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -</span>
 143      private final Context mContext;
 144  
 145      private final boolean mRestoreEnabled;
 146  
 147      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 148  
 149      private ArrayList&lt;Key&gt; mKeys;
 150  
 151      public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 152          mContext = context;
 153          mRestoreEnabled = restoreEnabled;
 154      }
 155  
 156      private void dataChanged() {
 157          if (sBackupManager == null) {
 158              sBackupManager = new BackupManager(mContext);
 159          }
 160          sBackupManager.dataChanged();
 161      }
 162  
 163      /**
 164       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 165       *
 166       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 167       *
 168       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 169       *
 170       * @param oldState notes from the last backup
 171       * @param data incremental key/value pairs to persist off-device
 172       * @param newState notes for the next backup
 173       * @throws IOException
 174       */
 175      @Override
 176      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 177              ParcelFileDescriptor newState) {
 178          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 179  
 180          Journal in = readJournal(oldState);
 181          Journal out = new Journal();
 182  
 183          long lastBackupTime = in.t;
 184          out.t = System.currentTimeMillis();
 185          out.rows = 0;
 186          out.bytes = 0;
 187  
 188          Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 189  
 190          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 191          try {
 192              backupFavorites(in, data, out, keys);
 193              backupScreens(in, data, out, keys);
 194              backupIcons(in, data, out, keys);
 195              backupWidgets(in, data, out, keys);
 196          } catch (IOException e) {
 197              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 198          }
 199  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -        out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +        out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>













 202          writeJournal(newState, out);
 203          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 204      }
 205  
 206      /**
 207       * Restore launcher configuration from the restored data stream.
 208       *
 209       * &lt;P&gt;Keys may arrive in any order.
 210       *
 211       * @param data the key/value pair from the server
 212       */
 213      @Override
 214      public void restoreEntity(BackupDataInputStream data) {
 215          if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 216          if (mKeys == null) {
 217              mKeys = new ArrayList&lt;Key&gt;();
 218          }
 219          byte[] buffer = new byte[512];
 220              String backupKey = data.getKey();
 221              int dataSize = data.size();
 222              if (buffer.length &lt; dataSize) {
 223                  buffer = new byte[dataSize];
 224              }
 225              Key key = null;
 226          int bytesRead = 0;
 227          try {
 228              bytesRead = data.read(buffer, 0, dataSize);
 229              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 230          } catch (IOException e) {
 231              Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 232          }
 233          try {
 234              key = backupKeyToKey(backupKey);
 235              mKeys.add(key);
 236              switch (key.type) {
 237                  case Key.FAVORITE:
 238                      restoreFavorite(key, buffer, dataSize, mKeys);
 239                      break;
 240  
 241                  case Key.SCREEN:
 242                      restoreScreen(key, buffer, dataSize, mKeys);
 243                      break;
 244  
 245                  case Key.ICON:
 246                      restoreIcon(key, buffer, dataSize, mKeys);
 247                      break;
 248  
 249                  case Key.WIDGET:
 250                      restoreWidget(key, buffer, dataSize, mKeys);
 251                      break;
 252  
 253                  default:
 254                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 255                      break;
 256              }
 257          } catch (KeyParsingException e) {
 258              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 259          }
 260  
 261      }
 262  
 263      /**
 264       * Record the restore state for the next backup.
 265       *
 266       * @param newState notes about the backup state after restore.
 267       */
 268      @Override
 269      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 270          // clear the output journal time, to force a full backup to
 271          // will catch any changes the restore process might have made
 272          Journal out = new Journal();
 273          out.t = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 274 -        out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +        out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 276          writeJournal(newState, out);
 277          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 278          mKeys.clear();
 279      }
 280  
 281      /**
 282       * Write all modified favorites to the data stream.
 283       *
 284       *
 285       * @param in notes from last backup
 286       * @param data output stream for key/value pairs
 287       * @param out notes about this backup
 288       * @param keys keys to mark as clean in the notes for next backup
 289       * @throws IOException
 290       */
 291      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 292              ArrayList&lt;Key&gt; keys)
 293              throws IOException {
 294          // read the old ID set
 295          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 296          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 297  
 298          // persist things that have changed since the last backup
 299          ContentResolver cr = mContext.getContentResolver();
 300          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 301                  null, null, null);
 302          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 303          try {
 304              cursor.moveToPosition(-1);
 305              while(cursor.moveToNext()) {
 306                  final long id = cursor.getLong(ID_INDEX);
 307                  final long updateTime = cursor.getLong(ID_MODIFIED);
 308                  Key key = getKey(Key.FAVORITE, id);
 309                  keys.add(key);
 310                  final String backupKey = keyToBackupKey(key);
 311                  currentIds.add(backupKey);
 312                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 313                      byte[] blob = packFavorite(cursor);
 314                      writeRowToBackup(key, blob, out, data);
 315                  } else {
 316                      if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 317                  }
 318              }
 319          } finally {
 320              cursor.close();
 321          }
 322          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 323  
 324          // these IDs must have been deleted
 325          savedIds.removeAll(currentIds);
 326          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 327      }
 328  
 329      /**
 330       * Read a favorite from the stream.
 331       *
 332       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 333       *
 334       * @param key identifier for the row
 335       * @param buffer the serialized proto from the stream, may be larger than dataSize
 336       * @param dataSize the size of the proto from the stream
 337       * @param keys keys to mark as clean in the notes for next backup
 338       */
 339      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 340          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 341          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 342                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 343  
 344          if (!mRestoreEnabled) {
 345              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 346              return;
 347          }
 348  
 349          try {
 350              ContentResolver cr = mContext.getContentResolver();
 351              ContentValues values = unpackFavorite(buffer, 0, dataSize);
 352              cr.insert(Favorites.CONTENT_URI, values);
 353          } catch (InvalidProtocolBufferNanoException e) {
 354              Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 355          }
 356      }
 357  
 358      /**
 359       * Write all modified screens to the data stream.
 360       *
 361       *
 362       * @param in notes from last backup
 363       * @param data output stream for key/value pairs
 364       * @param out notes about this backup
 365       * @param keys keys to mark as clean in the notes for next backup
 366       * @throws IOException
 367       */
 368      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 369              ArrayList&lt;Key&gt; keys)
 370              throws IOException {
 371          // read the old ID set
 372          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 373          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 374  
 375          // persist things that have changed since the last backup
 376          ContentResolver cr = mContext.getContentResolver();
 377          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 378                  null, null, null);
 379          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 380          try {
 381              cursor.moveToPosition(-1);
 382              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 383              while(cursor.moveToNext()) {
 384                  final long id = cursor.getLong(ID_INDEX);
 385                  final long updateTime = cursor.getLong(ID_MODIFIED);
 386                  Key key = getKey(Key.SCREEN, id);
 387                  keys.add(key);
 388                  final String backupKey = keyToBackupKey(key);
 389                  currentIds.add(backupKey);
 390                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 391                      byte[] blob = packScreen(cursor);
 392                      writeRowToBackup(key, blob, out, data);
 393                  } else {
 394                      if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 395                  }
 396              }
 397          } finally {
 398              cursor.close();
 399          }
 400          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 401  
 402          // these IDs must have been deleted
 403          savedIds.removeAll(currentIds);
 404          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 405      }
 406  
 407      /**
 408       * Read a screen from the stream.
 409       *
 410       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 411       *
 412       * @param key identifier for the row
 413       * @param buffer the serialized proto from the stream, may be larger than dataSize
 414       * @param dataSize the size of the proto from the stream
 415       * @param keys keys to mark as clean in the notes for next backup
 416       */
 417      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 418          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 419          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 420                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 421  
 422          if (!mRestoreEnabled) {
 423              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 424              return;
 425          }
 426  
 427          try {
 428              ContentResolver cr = mContext.getContentResolver();
 429              ContentValues values = unpackScreen(buffer, 0, dataSize);
 430              cr.insert(WorkspaceScreens.CONTENT_URI, values);
 431  
 432          } catch (InvalidProtocolBufferNanoException e) {
 433              Log.e(TAG, &quot;failed to decode screen&quot;, e);
 434          }
 435      }
 436  
 437      /**
 438       * Write all the static icon resources we need to render placeholders
 439       * for a package that is not installed.
 440       *
 441       * @param in notes from last backup
 442       * @param data output stream for key/value pairs
 443       * @param out notes about this backup
 444       * @param keys keys to mark as clean in the notes for next backup
 445       * @throws IOException
 446       */
 447      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 448              ArrayList&lt;Key&gt; keys) throws IOException {
 449          // persist icons that haven&#x27;t been persisted yet
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 451 +        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 452 +        if (appState == null) {</span>
 453              dataChanged(); // try again later
 454              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 455              return;
 456          }
 457          final ContentResolver cr = mContext.getContentResolver();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 458 +        final IconCache iconCache = appState.getIconCache();</span>
 459          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 460  
 461          // read the old ID set
 462          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 463          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 464  
 465          int startRows = out.rows;
 466          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 467          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 468          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 469                  where, null, null);
 470          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 471          try {
 472              cursor.moveToPosition(-1);
 473              while(cursor.moveToNext()) {
 474                  final long id = cursor.getLong(ID_INDEX);
 475                  final String intentDescription = cursor.getString(INTENT_INDEX);
 476                  try {
 477                      Intent intent = Intent.parseUri(intentDescription, 0);
 478                      ComponentName cn = intent.getComponent();
 479                      Key key = null;
 480                      String backupKey = null;
 481                      if (cn != null) {
 482                          key = getKey(Key.ICON, cn.flattenToShortString());
 483                          backupKey = keyToBackupKey(key);
 484                          currentIds.add(backupKey);
 485                      } else {
 486                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 487                      }
 488                      if (savedIds.contains(backupKey)) {
 489                          if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 490  
 491                          // remember that we already backed this up previously
 492                          keys.add(key);
 493                      } else if (backupKey != null) {
 494                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 495                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 496                              if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -                            Bitmap icon = mIconCache.getIcon(intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 498 +                            Bitmap icon = iconCache.getIcon(intent);</span>
 499                              keys.add(key);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 500 -                            if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 501 +                            if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {</span>
 502                                  byte[] blob = packIcon(dpi, icon);
 503                                  writeRowToBackup(key, blob, out, data);
 504                              }
 505                          } else {
 506                              if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 507                              // too many icons for this pass, request another.
 508                              dataChanged();
 509                          }
 510                      }
 511                  } catch (URISyntaxException e) {
 512                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 513                  } catch (IOException e) {
 514                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 515                  }
 516  
 517              }
 518          } finally {
 519              cursor.close();
 520          }
 521          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 522  
 523          // these IDs must have been deleted
 524          savedIds.removeAll(currentIds);
 525          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 526      }
 527  
 528      /**
 529       * Read an icon from the stream.
 530       *
 531       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 532       *
 533       * @param key identifier for the row
 534       * @param buffer the serialized proto from the stream, may be larger than dataSize
 535       * @param dataSize the size of the proto from the stream
 536       * @param keys keys to mark as clean in the notes for next backup
 537       */
 538      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 539          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 540          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 541                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 542 -</span>
 543          try {
 544              Resource res = unpackIcon(buffer, 0, dataSize);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 545 -            if (DEBUG) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 546 -                Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 547 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 548 -            if (DEBUG_PAYLOAD) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 549 -                Log.d(TAG, &quot;read &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 550 -                        Base64.encodeToString(res.data, 0, res.data.length,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 551 -                                Base64.NO_WRAP));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 552 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 553 +            if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 554 +            if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 555 +                    Base64.encodeToString(res.data, 0, res.data.length,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 556 +                            Base64.NO_WRAP));</span>
 557              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 558              if (icon == null) {
 559                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 560              }
 561  
 562              if (!mRestoreEnabled) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -                if (VERBOSE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -                    Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 566 +                if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
 567                  return;
 568              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -                IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -                        icon, res.dpi);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -        } catch (IOException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -            Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 574 +                // future site of icon cache mutation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 575 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 576 +        } catch (InvalidProtocolBufferNanoException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 577 +            Log.e(TAG, &quot;failed to decode icon&quot;, e);</span>
 578          }
 579      }
 580  
 581      /**
 582       * Write all the static widget resources we need to render placeholders
 583       * for a package that is not installed.
 584       *
 585       * @param in notes from last backup
 586       * @param data output stream for key/value pairs
 587       * @param out notes about this backup
 588       * @param keys keys to mark as clean in the notes for next backup
 589       * @throws IOException
 590       */
 591      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 592              ArrayList&lt;Key&gt; keys) throws IOException {
 593          // persist static widget info that hasn&#x27;t been persisted yet
 594          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 595 -        if (appState == null || !initializeIconCache()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 596 -            Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +        if (appState == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +            dataChanged(); // try again later</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +            if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);</span>
 600              return;
 601          }
 602          final ContentResolver cr = mContext.getContentResolver();
 603          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 604          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +        final IconCache iconCache = appState.getIconCache();</span>
 606          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 607          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 608          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 609  
 610          // read the old ID set
 611          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 612          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 613  
 614          int startRows = out.rows;
 615          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 616          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 617          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 618                  where, null, null);
 619          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 620          try {
 621              cursor.moveToPosition(-1);
 622              while(cursor.moveToNext()) {
 623                  final long id = cursor.getLong(ID_INDEX);
 624                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 625                  final int spanX = cursor.getInt(SPANX_INDEX);
 626                  final int spanY = cursor.getInt(SPANY_INDEX);
 627                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 628                  Key key = null;
 629                  String backupKey = null;
 630                  if (provider != null) {
 631                      key = getKey(Key.WIDGET, providerName);
 632                      backupKey = keyToBackupKey(key);
 633                      currentIds.add(backupKey);
 634                  } else {
 635                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 636                  }
 637                  if (savedIds.contains(backupKey)) {
 638                      if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 639  
 640                      // remember that we already backed this up previously
 641                      keys.add(key);
 642                  } else if (backupKey != null) {
 643                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 644                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 645                          if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 646                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 647                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -                        byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +                        byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);</span>
 650                          keys.add(key);
 651                          writeRowToBackup(key, blob, out, data);
 652  
 653                      } else {
 654                          if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 655                          // too many widgets for this pass, request another.
 656                          dataChanged();
 657                      }
 658                  }
 659              }
 660          } finally {
 661              cursor.close();
 662          }
 663          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 664  
 665          // these IDs must have been deleted
 666          savedIds.removeAll(currentIds);
 667          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 668      }
 669  
 670      /**
 671       * Read a widget from the stream.
 672       *
 673       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 674       *
 675       * @param key identifier for the row
 676       * @param buffer the serialized proto from the stream, may be larger than dataSize
 677       * @param dataSize the size of the proto from the stream
 678       * @param keys keys to mark as clean in the notes for next backup
 679       */
 680      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 681          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 682          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 683                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 684          try {
 685              Widget widget = unpackWidget(buffer, 0, dataSize);
 686              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 687              if (widget.icon.data != null)  {
 688                  Bitmap icon = BitmapFactory
 689                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 690                  if (icon == null) {
 691                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 692                  }
 693              }
 694  
 695              if (!mRestoreEnabled) {
 696                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 697                  return;
 698              } else {
 699                  // future site of widget table mutation
 700              }
 701          } catch (InvalidProtocolBufferNanoException e) {
 702              Log.e(TAG, &quot;failed to decode widget&quot;, e);
 703          }
 704      }
 705  
 706      /** create a new key, with an integer ID.
 707       *
 708       * &lt;P&gt; Keys contain their own checksum instead of using
 709       * the heavy-weight CheckedMessage wrapper.
 710       */
 711      private Key getKey(int type, long id) {
 712          Key key = new Key();
 713          key.type = type;
 714          key.id = id;
 715          key.checksum = checkKey(key);
 716          return key;
 717      }
 718  
 719      /** create a new key for a named object.
 720       *
 721       * &lt;P&gt; Keys contain their own checksum instead of using
 722       * the heavy-weight CheckedMessage wrapper.
 723       */
 724      private Key getKey(int type, String name) {
 725          Key key = new Key();
 726          key.type = type;
 727          key.name = name;
 728          key.checksum = checkKey(key);
 729          return key;
 730      }
 731  
 732      /** keys need to be strings, serialize and encode. */
 733      private String keyToBackupKey(Key key) {
 734          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 735      }
 736  
 737      /** keys need to be strings, decode and parse. */
 738      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 739          try {
 740              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 741              if (key.checksum != checkKey(key)) {
 742                  key = null;
 743                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 744              }
 745              return key;
 746          } catch (InvalidProtocolBufferNanoException e) {
 747              throw new KeyParsingException(e);
 748          } catch (IllegalArgumentException e) {
 749              throw new KeyParsingException(e);
 750          }
 751      }
 752  
 753      private String getKeyName(Key key) {
 754          if (TextUtils.isEmpty(key.name)) {
 755              return Long.toString(key.id);
 756          } else {
 757              return key.name;
 758          }
 759  
 760      }
 761  
 762      private String geKeyType(Key key) {
 763          switch (key.type) {
 764              case Key.FAVORITE:
 765                  return &quot;favorite&quot;;
 766              case Key.SCREEN:
 767                  return &quot;screen&quot;;
 768              case Key.ICON:
 769                  return &quot;icon&quot;;
 770              case Key.WIDGET:
 771                  return &quot;widget&quot;;
 772              default:
 773                  return &quot;anonymous&quot;;
 774          }
 775      }
 776  
 777      /** Compute the checksum over the important bits of a key. */
 778      private long checkKey(Key key) {
 779          CRC32 checksum = new CRC32();
 780          checksum.update(key.type);
 781          checksum.update((int) (key.id &amp; 0xffff));
 782          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 783          if (!TextUtils.isEmpty(key.name)) {
 784              checksum.update(key.name.getBytes());
 785          }
 786          return checksum.getValue();
 787      }
 788  
 789      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 790      private byte[] packFavorite(Cursor c) {
 791          Favorite favorite = new Favorite();
 792          favorite.id = c.getLong(ID_INDEX);
 793          favorite.screen = c.getInt(SCREEN_INDEX);
 794          favorite.container = c.getInt(CONTAINER_INDEX);
 795          favorite.cellX = c.getInt(CELLX_INDEX);
 796          favorite.cellY = c.getInt(CELLY_INDEX);
 797          favorite.spanX = c.getInt(SPANX_INDEX);
 798          favorite.spanY = c.getInt(SPANY_INDEX);
 799          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 800          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 801              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 802              if (!TextUtils.isEmpty(iconPackage)) {
 803                  favorite.iconPackage = iconPackage;
 804              }
 805              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 806              if (!TextUtils.isEmpty(iconResource)) {
 807                  favorite.iconResource = iconResource;
 808              }
 809          }
 810          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 811              byte[] blob = c.getBlob(ICON_INDEX);
 812              if (blob != null &amp;&amp; blob.length &gt; 0) {
 813                  favorite.icon = blob;
 814              }
 815          }
 816          String title = c.getString(TITLE_INDEX);
 817          if (!TextUtils.isEmpty(title)) {
 818              favorite.title = title;
 819          }
 820          String intent = c.getString(INTENT_INDEX);
 821          if (!TextUtils.isEmpty(intent)) {
 822              favorite.intent = intent;
 823          }
 824          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 825          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 826              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 827              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 828              if (!TextUtils.isEmpty(appWidgetProvider)) {
 829                  favorite.appWidgetProvider = appWidgetProvider;
 830              }
 831          }
 832  
 833          return writeCheckedBytes(favorite);
 834      }
 835  
 836      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 837      private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 838              throws InvalidProtocolBufferNanoException {
 839          Favorite favorite = new Favorite();
 840          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 841          if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 842                  (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 843          ContentValues values = new ContentValues();
 844          values.put(Favorites._ID, favorite.id);
 845          values.put(Favorites.SCREEN, favorite.screen);
 846          values.put(Favorites.CONTAINER, favorite.container);
 847          values.put(Favorites.CELLX, favorite.cellX);
 848          values.put(Favorites.CELLY, favorite.cellY);
 849          values.put(Favorites.SPANX, favorite.spanX);
 850          values.put(Favorites.SPANY, favorite.spanY);
 851          values.put(Favorites.ICON_TYPE, favorite.iconType);
 852          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 853              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 854              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 855          }
 856          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 857              values.put(Favorites.ICON, favorite.icon);
 858          }
 859          if (!TextUtils.isEmpty(favorite.title)) {
 860              values.put(Favorites.TITLE, favorite.title);
 861          } else {
 862              values.put(Favorites.TITLE, &quot;&quot;);
 863          }
 864          if (!TextUtils.isEmpty(favorite.intent)) {
 865              values.put(Favorites.INTENT, favorite.intent);
 866          }
 867          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 868          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 869              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 870                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 871              }
 872              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 873          }
 874  
 875          // Let LauncherModel know we&#x27;ve been here.
 876          values.put(LauncherSettings.Favorites.RESTORED, 1);
 877  
 878          return values;
 879      }
 880  
 881      /** Serialize a Screen for persistence, including a checksum wrapper. */
 882      private byte[] packScreen(Cursor c) {
 883          Screen screen = new Screen();
 884          screen.id = c.getLong(ID_INDEX);
 885          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 886  
 887          return writeCheckedBytes(screen);
 888      }
 889  
 890      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 891      private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 892              throws InvalidProtocolBufferNanoException {
 893          Screen screen = new Screen();
 894          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 895          if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 896          ContentValues values = new ContentValues();
 897          values.put(WorkspaceScreens._ID, screen.id);
 898          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 899          return values;
 900      }
 901  
 902      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 903      private byte[] packIcon(int dpi, Bitmap icon) {
 904          Resource res = new Resource();
 905          res.dpi = dpi;
 906          ByteArrayOutputStream os = new ByteArrayOutputStream();
 907          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 908              res.data = os.toByteArray();
 909          }
 910          return writeCheckedBytes(res);
 911      }
 912  
 913      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 914 -    private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 915 +    private Resource unpackIcon(byte[] buffer, int offset, int dataSize)</span>
 916              throws InvalidProtocolBufferNanoException {
 917          Resource res = new Resource();
 918          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 919          if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 920          return res;
 921      }
 922  
 923      /** Serialize a widget for persistence, including a checksum wrapper. */
 924      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 925              ComponentName provider) {
 926          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 927          Widget widget = new Widget();
 928          widget.provider = provider.flattenToShortString();
 929          widget.label = info.label;
 930          widget.configure = info.configure != null;
 931          if (info.icon != 0) {
 932              widget.icon = new Resource();
 933              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 934              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 935              ByteArrayOutputStream os = new ByteArrayOutputStream();
 936              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 937                  widget.icon.data = os.toByteArray();
 938                  widget.icon.dpi = dpi;
 939              }
 940          }
 941          if (info.previewImage != 0) {
 942              widget.preview = new Resource();
 943              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 944              ByteArrayOutputStream os = new ByteArrayOutputStream();
 945              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 946                  widget.preview.data = os.toByteArray();
 947                  widget.preview.dpi = dpi;
 948              }
 949          }
 950          return writeCheckedBytes(widget);
 951      }
 952  
 953      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 954      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 955              throws InvalidProtocolBufferNanoException {
 956          Widget widget = new Widget();
 957          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 958          if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 959          return widget;
 960      }
 961  
 962      /**
 963       * Read the old journal from the input file.
 964       *
 965       * In the event of any error, just pretend we didn&#x27;t have a journal,
 966       * in that case, do a full backup.
 967       *
 968       * @param oldState the read-0only file descriptor pointing to the old journal
 969       * @return a Journal protocol buffer
 970       */
 971      private Journal readJournal(ParcelFileDescriptor oldState) {
 972          Journal journal = new Journal();
 973          if (oldState == null) {
 974              return journal;
 975          }
 976          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 977          try {
 978              int availableBytes = inStream.available();
 979              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 980              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 981                  byte[] buffer = new byte[availableBytes];
 982                  int bytesRead = 0;
 983                  boolean valid = false;
 984                  InvalidProtocolBufferNanoException lastProtoException = null;
 985                  while (availableBytes &gt; 0) {
 986                      try {
 987                          // OMG what are you doing? This is crazy inefficient!
 988                          // If we read a byte that is not ours, we will cause trouble: b/12491813
 989                          // However, we don&#x27;t know how many bytes to expect (oops).
 990                          // So we have to step through *slowly*, watching for the end.
 991                          int result = inStream.read(buffer, bytesRead, 1);
 992                          if (result &gt; 0) {
 993                              availableBytes -= result;
 994                              bytesRead += result;
 995                              if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 996                                  Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 997                              }
 998                          } else {
 999                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1000                              // stop reading and see what there is to parse
1001                              availableBytes = 0;
1002                          }
1003                      } catch (IOException e) {
1004                          buffer = null;
1005                          availableBytes = 0;
1006                      }
1007  
1008                      // check the buffer to see if we have a valid journal
1009                      try {
1010                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1011                          // if we are here, then we have read a valid, checksum-verified journal
1012                          valid = true;
1013                          availableBytes = 0;
1014                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1015                      } catch (InvalidProtocolBufferNanoException e) {
1016                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1017                          lastProtoException = e;
1018                          journal.clear();
1019                      }
1020                  }
1021                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1022                  if (!valid) {
1023                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1024                  }
1025              }
1026          } catch (IOException e) {
1027              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1028          } finally {
1029              try {
1030                  inStream.close();
1031              } catch (IOException e) {
1032                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1033              }
1034          }
1035          return journal;
1036      }
1037  
1038      private void writeRowToBackup(Key key, byte[] blob, Journal out,
1039              BackupDataOutput data) throws IOException {
1040          String backupKey = keyToBackupKey(key);
1041          data.writeEntityHeader(backupKey, blob.length);
1042          data.writeEntityData(blob, blob.length);
1043          out.rows++;
1044          out.bytes += blob.length;
1045          if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1046                  getKeyName(key) + &quot;/&quot; + blob.length);
1047          if(DEBUG_PAYLOAD) {
1048              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1049              final int chunkSize = 1024;
1050              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1051                  int end = offset + chunkSize;
1052                  end = Math.min(end, encoded.length());
1053                  Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1054              }
1055          }
1056      }
1057  
1058      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1059          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1060          for(int i = 0; i &lt; in.key.length; i++) {
1061              Key key = in.key[i];
1062              if (key.type == type) {
1063                  savedIds.add(keyToBackupKey(key));
1064              }
1065          }
1066          return savedIds;
1067      }
1068  
1069      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1070              throws IOException {
1071          int rows = 0;
1072          for(String deleted: deletedIds) {
1073              if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1074              data.writeEntityHeader(deleted, -1);
1075              rows++;
1076          }
1077          return rows;
1078      }
1079  
1080      /**
1081       * Write the new journal to the output file.
1082       *
1083       * In the event of any error, just pretend we didn&#x27;t have a journal,
1084       * in that case, do a full backup.
1085  
1086       * @param newState the write-only file descriptor pointing to the new journal
1087       * @param journal a Journal protocol buffer
1088       */
1089      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1090          FileOutputStream outStream = null;
1091          try {
1092              outStream = new FileOutputStream(newState.getFileDescriptor());
1093              final byte[] journalBytes = writeCheckedBytes(journal);
1094              outStream.write(journalBytes);
1095              outStream.close();
1096              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1097          } catch (IOException e) {
1098              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1099          }
1100      }
1101  
1102      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1103      private byte[] writeCheckedBytes(MessageNano proto) {
1104          CheckedMessage wrapper = new CheckedMessage();
1105          wrapper.payload = MessageNano.toByteArray(proto);
1106          CRC32 checksum = new CRC32();
1107          checksum.update(wrapper.payload);
1108          wrapper.checksum = checksum.getValue();
1109          return MessageNano.toByteArray(wrapper);
1110      }
1111  
1112      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1113 -    private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1114 +    private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)</span>
1115              throws InvalidProtocolBufferNanoException {
1116          CheckedMessage wrapper = new CheckedMessage();
1117          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1118          CRC32 checksum = new CRC32();
1119          checksum.update(wrapper.payload);
1120          if (wrapper.checksum != checksum.getValue()) {
1121              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1122          }
1123          return wrapper.payload;
1124      }
1125  
1126      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1127          if (mWidgetMap == null) {
1128              List&lt;AppWidgetProviderInfo&gt; widgets =
1129                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1130              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1131              for (AppWidgetProviderInfo info : widgets) {
1132                  mWidgetMap.put(info.provider, info);
1133              }
1134          }
1135          return mWidgetMap.get(component);
1136      }
1137  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1138 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1139 -    private boolean initializeIconCache() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1140 -        if (mIconCache != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1141 -            return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1142 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1143 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1144 -        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1145 -        if (appState == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1146 -            Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1147 -            stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1148 -            Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1149 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1150 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1151 -        mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1152 -        return mIconCache != null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1153 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1154 -</span>




















1155      private class KeyParsingException extends Throwable {
1156          private KeyParsingException(Throwable cause) {
1157              super(cause);
1158          }
1159  
1160          public KeyParsingException(String reason) {
1161              super(reason);
1162          }
1163      }
1164  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19  import com.google.protobuf.nano.MessageNano;
  20  
  21  import com.android.launcher3.LauncherSettings.Favorites;
  22  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23  import com.android.launcher3.backup.BackupProtos;
  24  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25  import com.android.launcher3.backup.BackupProtos.Favorite;
  26  import com.android.launcher3.backup.BackupProtos.Journal;
  27  import com.android.launcher3.backup.BackupProtos.Key;
  28  import com.android.launcher3.backup.BackupProtos.Resource;
  29  import com.android.launcher3.backup.BackupProtos.Screen;
  30  import com.android.launcher3.backup.BackupProtos.Widget;
  31  
  32  import android.app.backup.BackupDataInputStream;
  33  import android.app.backup.BackupDataOutput;
  34  import android.app.backup.BackupHelper;
  35  import android.app.backup.BackupManager;
  36  import android.appwidget.AppWidgetManager;
  37  import android.appwidget.AppWidgetProviderInfo;
  38  import android.content.ComponentName;
  39  import android.content.ContentResolver;
  40  import android.content.ContentValues;
  41  import android.content.Context;
  42  import android.content.Intent;
  43  import android.database.Cursor;
  44  import android.graphics.Bitmap;
  45  import android.graphics.BitmapFactory;
  46  import android.graphics.drawable.Drawable;
  47  import android.os.ParcelFileDescriptor;
  48  import android.text.TextUtils;
  49  import android.util.Base64;
  50  import android.util.Log;
  51  
  52  import java.io.ByteArrayOutputStream;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import java.io.File;</span>
  54  import java.io.FileInputStream;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import java.io.FileNotFoundException;</span>
  56  import java.io.FileOutputStream;
  57  import java.io.IOException;
  58  import java.net.URISyntaxException;
  59  import java.util.ArrayList;
  60  import java.util.HashMap;
  61  import java.util.HashSet;
  62  import java.util.List;
  63  import java.util.Set;
  64  import java.util.zip.CRC32;
  65  
  66  /**
  67   * Persist the launcher home state across calamities.
  68   */
  69  public class LauncherBackupHelper implements BackupHelper {
  70  
  71      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  72      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  73      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  74      private static final boolean DEBUG_PAYLOAD = false;
  75  
  76      private static final int MAX_JOURNAL_SIZE = 1000000;
  77  
  78      /** icons are large, dribble them out */
  79      private static final int MAX_ICONS_PER_PASS = 10;
  80  
  81      /** widgets contain previews, which are very large, dribble them out */
  82      private static final int MAX_WIDGETS_PER_PASS = 5;
  83  
  84      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  85  
  86      public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  87  
  88      public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  89  
  90      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  91              android.graphics.Bitmap.CompressFormat.PNG;
  92  
  93      private static BackupManager sBackupManager;
  94  
  95      private static final String[] FAVORITE_PROJECTION = {
  96              Favorites._ID,                     // 0
  97              Favorites.MODIFIED,                // 1
  98              Favorites.INTENT,                  // 2
  99              Favorites.APPWIDGET_PROVIDER,      // 3
 100              Favorites.APPWIDGET_ID,            // 4
 101              Favorites.CELLX,                   // 5
 102              Favorites.CELLY,                   // 6
 103              Favorites.CONTAINER,               // 7
 104              Favorites.ICON,                    // 8
 105              Favorites.ICON_PACKAGE,            // 9
 106              Favorites.ICON_RESOURCE,           // 10
 107              Favorites.ICON_TYPE,               // 11
 108              Favorites.ITEM_TYPE,               // 12
 109              Favorites.SCREEN,                  // 13
 110              Favorites.SPANX,                   // 14
 111              Favorites.SPANY,                   // 15
 112              Favorites.TITLE,                   // 16
 113      };
 114  
 115      private static final int ID_INDEX = 0;
 116      private static final int ID_MODIFIED = 1;
 117      private static final int INTENT_INDEX = 2;
 118      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 119      private static final int APPWIDGET_ID_INDEX = 4;
 120      private static final int CELLX_INDEX = 5;
 121      private static final int CELLY_INDEX = 6;
 122      private static final int CONTAINER_INDEX = 7;
 123      private static final int ICON_INDEX = 8;
 124      private static final int ICON_PACKAGE_INDEX = 9;
 125      private static final int ICON_RESOURCE_INDEX = 10;
 126      private static final int ICON_TYPE_INDEX = 11;
 127      private static final int ITEM_TYPE_INDEX = 12;
 128      private static final int SCREEN_INDEX = 13;
 129      private static final int SPANX_INDEX = 14;
 130      private static final int SPANY_INDEX = 15;
 131      private static final int TITLE_INDEX = 16;
 132  
 133      private static final String[] SCREEN_PROJECTION = {
 134              WorkspaceScreens._ID,              // 0
 135              WorkspaceScreens.MODIFIED,         // 1
 136              WorkspaceScreens.SCREEN_RANK       // 2
 137      };
 138  
 139      private static final int SCREEN_RANK_INDEX = 2;
 140  
 141      private static IconCache mIconCache;
 142  
 143      private final Context mContext;
 144  
 145      private final boolean mRestoreEnabled;
 146  
 147      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 148  
 149      private ArrayList&lt;Key&gt; mKeys;
 150  
 151      public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 152          mContext = context;
 153          mRestoreEnabled = restoreEnabled;
 154      }
 155  
 156      private void dataChanged() {
 157          if (sBackupManager == null) {
 158              sBackupManager = new BackupManager(mContext);
 159          }
 160          sBackupManager.dataChanged();
 161      }
 162  
 163      /**
 164       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 165       *
 166       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 167       *
 168       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 169       *
 170       * @param oldState notes from the last backup
 171       * @param data incremental key/value pairs to persist off-device
 172       * @param newState notes for the next backup
 173       * @throws IOException
 174       */
 175      @Override
 176      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 177              ParcelFileDescriptor newState) {
 178          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 179  
 180          Journal in = readJournal(oldState);
 181          Journal out = new Journal();
 182  
 183          long lastBackupTime = in.t;
 184          out.t = System.currentTimeMillis();
 185          out.rows = 0;
 186          out.bytes = 0;
 187  
 188          Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 189  
 190          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 192 -            backupFavorites(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -            backupScreens(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 194 -            backupIcons(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -            backupWidgets(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -        } catch (IOException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -            Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -        out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +        if (launcherIsReady()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +                backupFavorites(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +                backupScreens(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +                backupIcons(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +                backupWidgets(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +            } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +                Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +            out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +            out = in;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +</span>
 215          writeJournal(newState, out);
 216          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 217      }
 218  
 219      /**
 220       * Restore launcher configuration from the restored data stream.
 221       *
 222       * &lt;P&gt;Keys may arrive in any order.
 223       *
 224       * @param data the key/value pair from the server
 225       */
 226      @Override
 227      public void restoreEntity(BackupDataInputStream data) {
 228          if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 229          if (mKeys == null) {
 230              mKeys = new ArrayList&lt;Key&gt;();
 231          }
 232          byte[] buffer = new byte[512];
 233              String backupKey = data.getKey();
 234              int dataSize = data.size();
 235              if (buffer.length &lt; dataSize) {
 236                  buffer = new byte[dataSize];
 237              }
 238              Key key = null;
 239          int bytesRead = 0;
 240          try {
 241              bytesRead = data.read(buffer, 0, dataSize);
 242              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 243          } catch (IOException e) {
 244              Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 245          }
 246          try {
 247              key = backupKeyToKey(backupKey);
 248              mKeys.add(key);
 249              switch (key.type) {
 250                  case Key.FAVORITE:
 251                      restoreFavorite(key, buffer, dataSize, mKeys);
 252                      break;
 253  
 254                  case Key.SCREEN:
 255                      restoreScreen(key, buffer, dataSize, mKeys);
 256                      break;
 257  
 258                  case Key.ICON:
 259                      restoreIcon(key, buffer, dataSize, mKeys);
 260                      break;
 261  
 262                  case Key.WIDGET:
 263                      restoreWidget(key, buffer, dataSize, mKeys);
 264                      break;
 265  
 266                  default:
 267                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 268                      break;
 269              }
 270          } catch (KeyParsingException e) {
 271              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 272          }
 273  
 274      }
 275  
 276      /**
 277       * Record the restore state for the next backup.
 278       *
 279       * @param newState notes about the backup state after restore.
 280       */
 281      @Override
 282      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 283          // clear the output journal time, to force a full backup to
 284          // will catch any changes the restore process might have made
 285          Journal out = new Journal();
 286          out.t = 0;
 287          out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);

 288          writeJournal(newState, out);
 289          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 290          mKeys.clear();
 291      }
 292  
 293      /**
 294       * Write all modified favorites to the data stream.
 295       *
 296       *
 297       * @param in notes from last backup
 298       * @param data output stream for key/value pairs
 299       * @param out notes about this backup
 300       * @param keys keys to mark as clean in the notes for next backup
 301       * @throws IOException
 302       */
 303      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 304              ArrayList&lt;Key&gt; keys)
 305              throws IOException {
 306          // read the old ID set
 307          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 308          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 309  
 310          // persist things that have changed since the last backup
 311          ContentResolver cr = mContext.getContentResolver();
 312          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 313                  null, null, null);
 314          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 315          try {
 316              cursor.moveToPosition(-1);
 317              while(cursor.moveToNext()) {
 318                  final long id = cursor.getLong(ID_INDEX);
 319                  final long updateTime = cursor.getLong(ID_MODIFIED);
 320                  Key key = getKey(Key.FAVORITE, id);
 321                  keys.add(key);
 322                  final String backupKey = keyToBackupKey(key);
 323                  currentIds.add(backupKey);
 324                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 325                      byte[] blob = packFavorite(cursor);
 326                      writeRowToBackup(key, blob, out, data);
 327                  } else {
 328                      if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 329                  }
 330              }
 331          } finally {
 332              cursor.close();
 333          }
 334          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 335  
 336          // these IDs must have been deleted
 337          savedIds.removeAll(currentIds);
 338          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 339      }
 340  
 341      /**
 342       * Read a favorite from the stream.
 343       *
 344       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 345       *
 346       * @param key identifier for the row
 347       * @param buffer the serialized proto from the stream, may be larger than dataSize
 348       * @param dataSize the size of the proto from the stream
 349       * @param keys keys to mark as clean in the notes for next backup
 350       */
 351      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 352          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 353          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 354                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 355  
 356          if (!mRestoreEnabled) {
 357              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 358              return;
 359          }
 360  
 361          try {
 362              ContentResolver cr = mContext.getContentResolver();
 363              ContentValues values = unpackFavorite(buffer, 0, dataSize);
 364              cr.insert(Favorites.CONTENT_URI, values);
 365          } catch (InvalidProtocolBufferNanoException e) {
 366              Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 367          }
 368      }
 369  
 370      /**
 371       * Write all modified screens to the data stream.
 372       *
 373       *
 374       * @param in notes from last backup
 375       * @param data output stream for key/value pairs
 376       * @param out notes about this backup
 377       * @param keys keys to mark as clean in the notes for next backup
 378       * @throws IOException
 379       */
 380      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 381              ArrayList&lt;Key&gt; keys)
 382              throws IOException {
 383          // read the old ID set
 384          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 385          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 386  
 387          // persist things that have changed since the last backup
 388          ContentResolver cr = mContext.getContentResolver();
 389          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 390                  null, null, null);
 391          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 392          try {
 393              cursor.moveToPosition(-1);
 394              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 395              while(cursor.moveToNext()) {
 396                  final long id = cursor.getLong(ID_INDEX);
 397                  final long updateTime = cursor.getLong(ID_MODIFIED);
 398                  Key key = getKey(Key.SCREEN, id);
 399                  keys.add(key);
 400                  final String backupKey = keyToBackupKey(key);
 401                  currentIds.add(backupKey);
 402                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 403                      byte[] blob = packScreen(cursor);
 404                      writeRowToBackup(key, blob, out, data);
 405                  } else {
 406                      if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 407                  }
 408              }
 409          } finally {
 410              cursor.close();
 411          }
 412          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 413  
 414          // these IDs must have been deleted
 415          savedIds.removeAll(currentIds);
 416          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 417      }
 418  
 419      /**
 420       * Read a screen from the stream.
 421       *
 422       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 423       *
 424       * @param key identifier for the row
 425       * @param buffer the serialized proto from the stream, may be larger than dataSize
 426       * @param dataSize the size of the proto from the stream
 427       * @param keys keys to mark as clean in the notes for next backup
 428       */
 429      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 430          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 431          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 432                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 433  
 434          if (!mRestoreEnabled) {
 435              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 436              return;
 437          }
 438  
 439          try {
 440              ContentResolver cr = mContext.getContentResolver();
 441              ContentValues values = unpackScreen(buffer, 0, dataSize);
 442              cr.insert(WorkspaceScreens.CONTENT_URI, values);
 443  
 444          } catch (InvalidProtocolBufferNanoException e) {
 445              Log.e(TAG, &quot;failed to decode screen&quot;, e);
 446          }
 447      }
 448  
 449      /**
 450       * Write all the static icon resources we need to render placeholders
 451       * for a package that is not installed.
 452       *
 453       * @param in notes from last backup
 454       * @param data output stream for key/value pairs
 455       * @param out notes about this backup
 456       * @param keys keys to mark as clean in the notes for next backup
 457       * @throws IOException
 458       */
 459      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 460              ArrayList&lt;Key&gt; keys) throws IOException {
 461          // persist icons that haven&#x27;t been persisted yet
 462          if (!initializeIconCache()) {


 463              dataChanged(); // try again later
 464              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 465              return;
 466          }
 467          final ContentResolver cr = mContext.getContentResolver();

 468          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 469  
 470          // read the old ID set
 471          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 472          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 473  
 474          int startRows = out.rows;
 475          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 476          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 477          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 478                  where, null, null);
 479          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 480          try {
 481              cursor.moveToPosition(-1);
 482              while(cursor.moveToNext()) {
 483                  final long id = cursor.getLong(ID_INDEX);
 484                  final String intentDescription = cursor.getString(INTENT_INDEX);
 485                  try {
 486                      Intent intent = Intent.parseUri(intentDescription, 0);
 487                      ComponentName cn = intent.getComponent();
 488                      Key key = null;
 489                      String backupKey = null;
 490                      if (cn != null) {
 491                          key = getKey(Key.ICON, cn.flattenToShortString());
 492                          backupKey = keyToBackupKey(key);
 493                          currentIds.add(backupKey);
 494                      } else {
 495                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 496                      }
 497                      if (savedIds.contains(backupKey)) {
 498                          if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 499  
 500                          // remember that we already backed this up previously
 501                          keys.add(key);
 502                      } else if (backupKey != null) {
 503                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 504                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 505                              if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 506                              Bitmap icon = mIconCache.getIcon(intent);

 507                              keys.add(key);
 508                              if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon)) {

 509                                  byte[] blob = packIcon(dpi, icon);
 510                                  writeRowToBackup(key, blob, out, data);
 511                              }
 512                          } else {
 513                              if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 514                              // too many icons for this pass, request another.
 515                              dataChanged();
 516                          }
 517                      }
 518                  } catch (URISyntaxException e) {
 519                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 520                  } catch (IOException e) {
 521                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 522                  }
 523  
 524              }
 525          } finally {
 526              cursor.close();
 527          }
 528          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 529  
 530          // these IDs must have been deleted
 531          savedIds.removeAll(currentIds);
 532          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 533      }
 534  
 535      /**
 536       * Read an icon from the stream.
 537       *
 538       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 539       *
 540       * @param key identifier for the row
 541       * @param buffer the serialized proto from the stream, may be larger than dataSize
 542       * @param dataSize the size of the proto from the stream
 543       * @param keys keys to mark as clean in the notes for next backup
 544       */
 545      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 546          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 547          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 548                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 549  
 550          try {
 551              Resource res = unpackIcon(buffer, 0, dataSize);
 552              if (DEBUG) {
 553                  Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 554              }
 555              if (DEBUG_PAYLOAD) {
 556                  Log.d(TAG, &quot;read &quot; +
 557                          Base64.encodeToString(res.data, 0, res.data.length,
 558                                  Base64.NO_WRAP));
 559              }




 560              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 561              if (icon == null) {
 562                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 563              }
 564  
 565              if (!mRestoreEnabled) {
 566                  if (VERBOSE) {
 567                      Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 568                  }

 569                  return;
 570              } else {
 571                  IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),
 572                          icon, res.dpi);
 573              }
 574          } catch (IOException e) {
 575              Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);




 576          }
 577      }
 578  
 579      /**
 580       * Write all the static widget resources we need to render placeholders
 581       * for a package that is not installed.
 582       *
 583       * @param in notes from last backup
 584       * @param data output stream for key/value pairs
 585       * @param out notes about this backup
 586       * @param keys keys to mark as clean in the notes for next backup
 587       * @throws IOException
 588       */
 589      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 590              ArrayList&lt;Key&gt; keys) throws IOException {
 591          // persist static widget info that hasn&#x27;t been persisted yet
 592          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 593          if (appState == null || !initializeIconCache()) {
 594              Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);



 595              return;
 596          }
 597          final ContentResolver cr = mContext.getContentResolver();
 598          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 599          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);

 600          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 601          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 602          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 603  
 604          // read the old ID set
 605          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 606          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 607  
 608          int startRows = out.rows;
 609          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 610          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 611          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 612                  where, null, null);
 613          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 614          try {
 615              cursor.moveToPosition(-1);
 616              while(cursor.moveToNext()) {
 617                  final long id = cursor.getLong(ID_INDEX);
 618                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 619                  final int spanX = cursor.getInt(SPANX_INDEX);
 620                  final int spanY = cursor.getInt(SPANY_INDEX);
 621                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 622                  Key key = null;
 623                  String backupKey = null;
 624                  if (provider != null) {
 625                      key = getKey(Key.WIDGET, providerName);
 626                      backupKey = keyToBackupKey(key);
 627                      currentIds.add(backupKey);
 628                  } else {
 629                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 630                  }
 631                  if (savedIds.contains(backupKey)) {
 632                      if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 633  
 634                      // remember that we already backed this up previously
 635                      keys.add(key);
 636                  } else if (backupKey != null) {
 637                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 638                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 639                          if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 640                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 641                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
 642                          byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);

 643                          keys.add(key);
 644                          writeRowToBackup(key, blob, out, data);
 645  
 646                      } else {
 647                          if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 648                          // too many widgets for this pass, request another.
 649                          dataChanged();
 650                      }
 651                  }
 652              }
 653          } finally {
 654              cursor.close();
 655          }
 656          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 657  
 658          // these IDs must have been deleted
 659          savedIds.removeAll(currentIds);
 660          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 661      }
 662  
 663      /**
 664       * Read a widget from the stream.
 665       *
 666       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 667       *
 668       * @param key identifier for the row
 669       * @param buffer the serialized proto from the stream, may be larger than dataSize
 670       * @param dataSize the size of the proto from the stream
 671       * @param keys keys to mark as clean in the notes for next backup
 672       */
 673      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 674          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 675          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 676                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 677          try {
 678              Widget widget = unpackWidget(buffer, 0, dataSize);
 679              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 680              if (widget.icon.data != null)  {
 681                  Bitmap icon = BitmapFactory
 682                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 683                  if (icon == null) {
 684                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 685                  }
 686              }
 687  
 688              if (!mRestoreEnabled) {
 689                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 690                  return;
 691              } else {
 692                  // future site of widget table mutation
 693              }
 694          } catch (InvalidProtocolBufferNanoException e) {
 695              Log.e(TAG, &quot;failed to decode widget&quot;, e);
 696          }
 697      }
 698  
 699      /** create a new key, with an integer ID.
 700       *
 701       * &lt;P&gt; Keys contain their own checksum instead of using
 702       * the heavy-weight CheckedMessage wrapper.
 703       */
 704      private Key getKey(int type, long id) {
 705          Key key = new Key();
 706          key.type = type;
 707          key.id = id;
 708          key.checksum = checkKey(key);
 709          return key;
 710      }
 711  
 712      /** create a new key for a named object.
 713       *
 714       * &lt;P&gt; Keys contain their own checksum instead of using
 715       * the heavy-weight CheckedMessage wrapper.
 716       */
 717      private Key getKey(int type, String name) {
 718          Key key = new Key();
 719          key.type = type;
 720          key.name = name;
 721          key.checksum = checkKey(key);
 722          return key;
 723      }
 724  
 725      /** keys need to be strings, serialize and encode. */
 726      private String keyToBackupKey(Key key) {
 727          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 728      }
 729  
 730      /** keys need to be strings, decode and parse. */
 731      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 732          try {
 733              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 734              if (key.checksum != checkKey(key)) {
 735                  key = null;
 736                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 737              }
 738              return key;
 739          } catch (InvalidProtocolBufferNanoException e) {
 740              throw new KeyParsingException(e);
 741          } catch (IllegalArgumentException e) {
 742              throw new KeyParsingException(e);
 743          }
 744      }
 745  
 746      private String getKeyName(Key key) {
 747          if (TextUtils.isEmpty(key.name)) {
 748              return Long.toString(key.id);
 749          } else {
 750              return key.name;
 751          }
 752  
 753      }
 754  
 755      private String geKeyType(Key key) {
 756          switch (key.type) {
 757              case Key.FAVORITE:
 758                  return &quot;favorite&quot;;
 759              case Key.SCREEN:
 760                  return &quot;screen&quot;;
 761              case Key.ICON:
 762                  return &quot;icon&quot;;
 763              case Key.WIDGET:
 764                  return &quot;widget&quot;;
 765              default:
 766                  return &quot;anonymous&quot;;
 767          }
 768      }
 769  
 770      /** Compute the checksum over the important bits of a key. */
 771      private long checkKey(Key key) {
 772          CRC32 checksum = new CRC32();
 773          checksum.update(key.type);
 774          checksum.update((int) (key.id &amp; 0xffff));
 775          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 776          if (!TextUtils.isEmpty(key.name)) {
 777              checksum.update(key.name.getBytes());
 778          }
 779          return checksum.getValue();
 780      }
 781  
 782      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 783      private byte[] packFavorite(Cursor c) {
 784          Favorite favorite = new Favorite();
 785          favorite.id = c.getLong(ID_INDEX);
 786          favorite.screen = c.getInt(SCREEN_INDEX);
 787          favorite.container = c.getInt(CONTAINER_INDEX);
 788          favorite.cellX = c.getInt(CELLX_INDEX);
 789          favorite.cellY = c.getInt(CELLY_INDEX);
 790          favorite.spanX = c.getInt(SPANX_INDEX);
 791          favorite.spanY = c.getInt(SPANY_INDEX);
 792          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 793          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 794              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 795              if (!TextUtils.isEmpty(iconPackage)) {
 796                  favorite.iconPackage = iconPackage;
 797              }
 798              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 799              if (!TextUtils.isEmpty(iconResource)) {
 800                  favorite.iconResource = iconResource;
 801              }
 802          }
 803          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 804              byte[] blob = c.getBlob(ICON_INDEX);
 805              if (blob != null &amp;&amp; blob.length &gt; 0) {
 806                  favorite.icon = blob;
 807              }
 808          }
 809          String title = c.getString(TITLE_INDEX);
 810          if (!TextUtils.isEmpty(title)) {
 811              favorite.title = title;
 812          }
 813          String intent = c.getString(INTENT_INDEX);
 814          if (!TextUtils.isEmpty(intent)) {
 815              favorite.intent = intent;
 816          }
 817          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 818          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 819              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 820              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 821              if (!TextUtils.isEmpty(appWidgetProvider)) {
 822                  favorite.appWidgetProvider = appWidgetProvider;
 823              }
 824          }
 825  
 826          return writeCheckedBytes(favorite);
 827      }
 828  
 829      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 830      private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 831              throws InvalidProtocolBufferNanoException {
 832          Favorite favorite = new Favorite();
 833          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 834          if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 835                  (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 836          ContentValues values = new ContentValues();
 837          values.put(Favorites._ID, favorite.id);
 838          values.put(Favorites.SCREEN, favorite.screen);
 839          values.put(Favorites.CONTAINER, favorite.container);
 840          values.put(Favorites.CELLX, favorite.cellX);
 841          values.put(Favorites.CELLY, favorite.cellY);
 842          values.put(Favorites.SPANX, favorite.spanX);
 843          values.put(Favorites.SPANY, favorite.spanY);
 844          values.put(Favorites.ICON_TYPE, favorite.iconType);
 845          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 846              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 847              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 848          }
 849          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 850              values.put(Favorites.ICON, favorite.icon);
 851          }
 852          if (!TextUtils.isEmpty(favorite.title)) {
 853              values.put(Favorites.TITLE, favorite.title);
 854          } else {
 855              values.put(Favorites.TITLE, &quot;&quot;);
 856          }
 857          if (!TextUtils.isEmpty(favorite.intent)) {
 858              values.put(Favorites.INTENT, favorite.intent);
 859          }
 860          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 861          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 862              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 863                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 864              }
 865              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 866          }
 867  
 868          // Let LauncherModel know we&#x27;ve been here.
 869          values.put(LauncherSettings.Favorites.RESTORED, 1);
 870  
 871          return values;
 872      }
 873  
 874      /** Serialize a Screen for persistence, including a checksum wrapper. */
 875      private byte[] packScreen(Cursor c) {
 876          Screen screen = new Screen();
 877          screen.id = c.getLong(ID_INDEX);
 878          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 879  
 880          return writeCheckedBytes(screen);
 881      }
 882  
 883      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 884      private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 885              throws InvalidProtocolBufferNanoException {
 886          Screen screen = new Screen();
 887          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 888          if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 889          ContentValues values = new ContentValues();
 890          values.put(WorkspaceScreens._ID, screen.id);
 891          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 892          return values;
 893      }
 894  
 895      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 896      private byte[] packIcon(int dpi, Bitmap icon) {
 897          Resource res = new Resource();
 898          res.dpi = dpi;
 899          ByteArrayOutputStream os = new ByteArrayOutputStream();
 900          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 901              res.data = os.toByteArray();
 902          }
 903          return writeCheckedBytes(res);
 904      }
 905  
 906      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 907      private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)

 908              throws InvalidProtocolBufferNanoException {
 909          Resource res = new Resource();
 910          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 911          if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 912          return res;
 913      }
 914  
 915      /** Serialize a widget for persistence, including a checksum wrapper. */
 916      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 917              ComponentName provider) {
 918          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 919          Widget widget = new Widget();
 920          widget.provider = provider.flattenToShortString();
 921          widget.label = info.label;
 922          widget.configure = info.configure != null;
 923          if (info.icon != 0) {
 924              widget.icon = new Resource();
 925              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 926              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 927              ByteArrayOutputStream os = new ByteArrayOutputStream();
 928              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 929                  widget.icon.data = os.toByteArray();
 930                  widget.icon.dpi = dpi;
 931              }
 932          }
 933          if (info.previewImage != 0) {
 934              widget.preview = new Resource();
 935              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 936              ByteArrayOutputStream os = new ByteArrayOutputStream();
 937              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 938                  widget.preview.data = os.toByteArray();
 939                  widget.preview.dpi = dpi;
 940              }
 941          }
 942          return writeCheckedBytes(widget);
 943      }
 944  
 945      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 946      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 947              throws InvalidProtocolBufferNanoException {
 948          Widget widget = new Widget();
 949          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 950          if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 951          return widget;
 952      }
 953  
 954      /**
 955       * Read the old journal from the input file.
 956       *
 957       * In the event of any error, just pretend we didn&#x27;t have a journal,
 958       * in that case, do a full backup.
 959       *
 960       * @param oldState the read-0only file descriptor pointing to the old journal
 961       * @return a Journal protocol buffer
 962       */
 963      private Journal readJournal(ParcelFileDescriptor oldState) {
 964          Journal journal = new Journal();
 965          if (oldState == null) {
 966              return journal;
 967          }
 968          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 969          try {
 970              int availableBytes = inStream.available();
 971              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 972              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 973                  byte[] buffer = new byte[availableBytes];
 974                  int bytesRead = 0;
 975                  boolean valid = false;
 976                  InvalidProtocolBufferNanoException lastProtoException = null;
 977                  while (availableBytes &gt; 0) {
 978                      try {
 979                          // OMG what are you doing? This is crazy inefficient!
 980                          // If we read a byte that is not ours, we will cause trouble: b/12491813
 981                          // However, we don&#x27;t know how many bytes to expect (oops).
 982                          // So we have to step through *slowly*, watching for the end.
 983                          int result = inStream.read(buffer, bytesRead, 1);
 984                          if (result &gt; 0) {
 985                              availableBytes -= result;
 986                              bytesRead += result;
 987                              if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 988                                  Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 989                              }
 990                          } else {
 991                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 992                              // stop reading and see what there is to parse
 993                              availableBytes = 0;
 994                          }
 995                      } catch (IOException e) {
 996                          buffer = null;
 997                          availableBytes = 0;
 998                      }
 999  
1000                      // check the buffer to see if we have a valid journal
1001                      try {
1002                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1003                          // if we are here, then we have read a valid, checksum-verified journal
1004                          valid = true;
1005                          availableBytes = 0;
1006                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1007                      } catch (InvalidProtocolBufferNanoException e) {
1008                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1009                          lastProtoException = e;
1010                          journal.clear();
1011                      }
1012                  }
1013                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1014                  if (!valid) {
1015                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1016                  }
1017              }
1018          } catch (IOException e) {
1019              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1020          } finally {
1021              try {
1022                  inStream.close();
1023              } catch (IOException e) {
1024                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1025              }
1026          }
1027          return journal;
1028      }
1029  
1030      private void writeRowToBackup(Key key, byte[] blob, Journal out,
1031              BackupDataOutput data) throws IOException {
1032          String backupKey = keyToBackupKey(key);
1033          data.writeEntityHeader(backupKey, blob.length);
1034          data.writeEntityData(blob, blob.length);
1035          out.rows++;
1036          out.bytes += blob.length;
1037          if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1038                  getKeyName(key) + &quot;/&quot; + blob.length);
1039          if(DEBUG_PAYLOAD) {
1040              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1041              final int chunkSize = 1024;
1042              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1043                  int end = offset + chunkSize;
1044                  end = Math.min(end, encoded.length());
1045                  Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1046              }
1047          }
1048      }
1049  
1050      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1051          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1052          for(int i = 0; i &lt; in.key.length; i++) {
1053              Key key = in.key[i];
1054              if (key.type == type) {
1055                  savedIds.add(keyToBackupKey(key));
1056              }
1057          }
1058          return savedIds;
1059      }
1060  
1061      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1062              throws IOException {
1063          int rows = 0;
1064          for(String deleted: deletedIds) {
1065              if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1066              data.writeEntityHeader(deleted, -1);
1067              rows++;
1068          }
1069          return rows;
1070      }
1071  
1072      /**
1073       * Write the new journal to the output file.
1074       *
1075       * In the event of any error, just pretend we didn&#x27;t have a journal,
1076       * in that case, do a full backup.
1077  
1078       * @param newState the write-only file descriptor pointing to the new journal
1079       * @param journal a Journal protocol buffer
1080       */
1081      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1082          FileOutputStream outStream = null;
1083          try {
1084              outStream = new FileOutputStream(newState.getFileDescriptor());
1085              final byte[] journalBytes = writeCheckedBytes(journal);
1086              outStream.write(journalBytes);
1087              outStream.close();
1088              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1089          } catch (IOException e) {
1090              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1091          }
1092      }
1093  
1094      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1095      private byte[] writeCheckedBytes(MessageNano proto) {
1096          CheckedMessage wrapper = new CheckedMessage();
1097          wrapper.payload = MessageNano.toByteArray(proto);
1098          CRC32 checksum = new CRC32();
1099          checksum.update(wrapper.payload);
1100          wrapper.checksum = checksum.getValue();
1101          return MessageNano.toByteArray(wrapper);
1102      }
1103  
1104      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1105      private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)

1106              throws InvalidProtocolBufferNanoException {
1107          CheckedMessage wrapper = new CheckedMessage();
1108          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1109          CRC32 checksum = new CRC32();
1110          checksum.update(wrapper.payload);
1111          if (wrapper.checksum != checksum.getValue()) {
1112              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1113          }
1114          return wrapper.payload;
1115      }
1116  
1117      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1118          if (mWidgetMap == null) {
1119              List&lt;AppWidgetProviderInfo&gt; widgets =
1120                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1121              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1122              for (AppWidgetProviderInfo info : widgets) {
1123                  mWidgetMap.put(info.provider, info);
1124              }
1125          }
1126          return mWidgetMap.get(component);
1127      }
1128  
1129  
1130      private boolean initializeIconCache() {
1131          if (mIconCache != null) {
1132              return true;
1133          }
1134  
1135          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1136          if (appState == null) {
1137              Throwable stackTrace = new Throwable();
1138              stackTrace.fillInStackTrace();
1139              Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1140              return false;
1141          }
1142          mIconCache = appState.getIconCache();
1143          return mIconCache != null;
1144      }
1145  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1146 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1147 +   // check if the launcher is in a state to support backup</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1148 +    private boolean launcherIsReady() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1149 +        ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1150 +        Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1151 +        if (cursor == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1152 +            // launcher data has been wiped, do nothing</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1153 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1154 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1155 +        cursor.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1156 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1157 +        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1158 +            // launcher services are unavailable, try again later</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1159 +            dataChanged();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1160 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1161 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1162 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1163 +        return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1164 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1165 +</span>
1166      private class KeyParsingException extends Throwable {
1167          private KeyParsingException(Throwable cause) {
1168              super(cause);
1169          }
1170  
1171          public KeyParsingException(String reason) {
1172              super(reason);
1173          }
1174      }
1175  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            