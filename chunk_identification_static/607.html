<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>607</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    607
                    <a href="606.html">prev</a>
                    <a href="608.html">next</a>
                    <a href="607_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_826a661d5bae6a5e2e3bd8fa46a1cae9e68fe2ec_src/com/android/launcher2/Workspace.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;826a661d5bae6a5e2e3bd8fa46a1cae9e68fe2ec:src/com/android/launcher2/Workspace.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;826a661d5bae6a5e2e3bd8fa46a1cae9e68fe2ec^1:src/com/android/launcher2/Workspace.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;826a661d5bae6a5e2e3bd8fa46a1cae9e68fe2ec^2:src/com/android/launcher2/Workspace.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;9168509491a5d052f28af71b99f6980ef859ca4d:src/com/android/launcher2/Workspace.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.AnimatorSet;
  22 import android.animation.ObjectAnimator;
  23 import android.animation.TimeInterpolator;
  24 import android.animation.ValueAnimator;
  25 import android.animation.ValueAnimator.AnimatorUpdateListener;
  26 import android.app.AlertDialog;
  27 import android.app.WallpaperManager;
  28 import android.appwidget.AppWidgetHostView;
  29 import android.appwidget.AppWidgetManager;
  30 import android.appwidget.AppWidgetProviderInfo;
  31 import android.content.ClipData;
  32 import android.content.ClipDescription;
  33 import android.content.ComponentName;
  34 import android.content.Context;
  35 import android.content.Intent;
  36 import android.content.res.Resources;
  37 import android.content.res.TypedArray;
  38 import android.graphics.Bitmap;
  39 import android.graphics.Camera;
  40 import android.graphics.Canvas;
  41 import android.graphics.Matrix;
  42 import android.graphics.Paint;
  43 import android.graphics.Point;
  44 import android.graphics.Rect;
  45 import android.graphics.RectF;
  46 import android.graphics.Region.Op;
  47 import android.graphics.drawable.Drawable;
  48 import android.os.IBinder;
  49 import android.os.Parcelable;
  50 import android.util.AttributeSet;
  51 import android.util.DisplayMetrics;
  52 import android.util.Log;
  53 import android.util.Pair;
  54 import android.view.Display;
  55 import android.view.DragEvent;
  56 import android.view.MotionEvent;
  57 import android.view.View;
  58 import android.view.ViewConfiguration;
  59 import android.view.ViewGroup;
  60 import android.view.View.MeasureSpec;
  61 import android.view.animation.AccelerateInterpolator;
  62 import android.view.animation.DecelerateInterpolator;
  63 import android.widget.ImageView;
  64 import android.widget.TextView;
  65 import android.widget.Toast;
  66 
  67 import com.android.launcher.R;
  68 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  69 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  70 
  71 import java.util.ArrayList;
  72 import java.util.HashSet;
  73 import java.util.List;
  74 
  75 /**
  76  * The workspace is a wide area with a wallpaper and a finite number of pages.
  77  * Each page contains a number of icons, folders or widgets the user can
  78  * interact with. A workspace is meant to be used with a fixed width only.
  79  */
  80 public class Workspace extends SmoothPagedView
  81         implements DropTarget, DragSource, DragScroller, View.OnTouchListener,
  82         DragController.DragListener, LauncherTransitionable {
  83     @SuppressWarnings({&quot;UnusedDeclaration&quot;})
  84     private static final String TAG = &quot;Launcher.Workspace&quot;;
  85 
  86     // Y rotation to apply to the workspace screens
  87     private static final float WORKSPACE_ROTATION = 12.5f;
  88     private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  89     private static float CAMERA_DISTANCE = 6500;
  90 
  91     private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  92     private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  93     private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  94 
  95     private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  96     private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
  97     private static final int FLING_THRESHOLD_VELOCITY = 500;
  98 
  99     // These animators are used to fade the children&#x27;s outlines
 100     private ObjectAnimator mChildrenOutlineFadeInAnimation;
 101     private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 102     private float mChildrenOutlineAlpha = 0;
 103 
 104     // These properties refer to the background protection gradient used for AllApps and Customize
 105     private ValueAnimator mBackgroundFadeInAnimation;
 106     private ValueAnimator mBackgroundFadeOutAnimation;
 107     private Drawable mBackground;
 108     boolean mDrawBackground = true;
 109     private float mBackgroundAlpha = 0;
 110     private float mOverScrollMaxBackgroundAlpha = 0.0f;
 111     private int mOverScrollPageIndex = -1;
 112 
 113     private float mWallpaperScrollRatio = 1.0f;
 114 
 115     private final WallpaperManager mWallpaperManager;
 116     private IBinder mWindowToken;
 117     private static final float WALLPAPER_SCREENS_SPAN = 2f;
 118 
 119     private int mDefaultPage;
 120 
 121     /**
 122      * CellInfo for the cell that is currently being dragged
 123      */
 124     private CellLayout.CellInfo mDragInfo;
 125 
 126     /**
 127      * Target drop area calculated during last acceptDrop call.
 128      */
 129     private int[] mTargetCell = new int[2];
 130 
 131     /**
 132      * The CellLayout that is currently being dragged over
 133      */
 134     private CellLayout mDragTargetLayout = null;
 135     private boolean mDragHasEnteredWorkspace = false;
 136 
 137     private Launcher mLauncher;
 138     private IconCache mIconCache;
 139     private DragController mDragController;
 140 
 141     // These are temporary variables to prevent having to allocate a new object just to
 142     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 143     private int[] mTempCell = new int[2];
 144     private int[] mTempEstimate = new int[2];
 145     private float[] mDragViewVisualCenter = new float[2];
 146     private float[] mTempDragCoordinates = new float[2];
 147     private float[] mTempCellLayoutCenterCoordinates = new float[2];
 148     private float[] mTempDragBottomRightCoordinates = new float[2];
 149     private Matrix mTempInverseMatrix = new Matrix();
 150 
 151     private SpringLoadedDragController mSpringLoadedDragController;
 152     private float mSpringLoadedShrinkFactor;
 153 
 154     private static final int DEFAULT_CELL_COUNT_X = 4;
 155     private static final int DEFAULT_CELL_COUNT_Y = 4;
 156 
 157     // State variable that indicates whether the pages are small (ie when you&#x27;re
 158     // in all apps or customize mode)
 159 
 160     enum State { NORMAL, SPRING_LOADED, SMALL };
 161     private State mState = State.NORMAL;
 162     private boolean mIsSwitchingState = false;
 163 
 164     boolean mAnimatingViewIntoPlace = false;
 165     boolean mIsDragOccuring = false;
 166     boolean mChildrenLayersEnabled = true;
 167 
 168     /** Is the user is dragging an item near the edge of a page? */
 169     private boolean mInScrollArea = false;
 170 
 171     private final HolographicOutlineHelper mOutlineHelper = new HolographicOutlineHelper();
 172     private Bitmap mDragOutline = null;
 173     private final Rect mTempRect = new Rect();
 174     private final int[] mTempXY = new int[2];
 175     private float mOverscrollFade = 0;
 176     public static final int DRAG_BITMAP_PADDING = 0;
 177 
 178     // Paint used to draw external drop outline
 179     private final Paint mExternalDragOutlinePaint = new Paint();
 180 
 181     // Camera and Matrix used to determine the final position of a neighboring CellLayout
 182     private final Matrix mMatrix = new Matrix();
 183     private final Camera mCamera = new Camera();
 184     private final float mTempFloat2[] = new float[2];
 185 
 186     enum WallpaperVerticalOffset { TOP, MIDDLE, BOTTOM };
 187     int mWallpaperWidth;
 188     int mWallpaperHeight;
 189     WallpaperOffsetInterpolator mWallpaperOffset;
 190     boolean mUpdateWallpaperOffsetImmediately = false;
 191     private Runnable mDelayedResizeRunnable;
 192     private int mDisplayWidth;
 193     private int mDisplayHeight;
 194     private boolean mIsStaticWallpaper;
 195     private int mWallpaperTravelWidth;
 196 
 197     // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 198     private static final int FOLDER_CREATION_TIMEOUT = 250;
 199     private final Alarm mFolderCreationAlarm = new Alarm();
 200     private FolderRingAnimator mDragFolderRingAnimator = null;
 201     private View mLastDragOverView = null;
 202     private boolean mCreateUserFolderOnDrop = false;
 203 
 204     // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 205     private float mXDown;
 206     private float mYDown;
 207     final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 208     final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 209     final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
 210 
 211     // Relating to the animation of items being dropped externally
 212     public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;
 213     public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;
 214     public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;
 215     public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;
 216     public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;
 217 
 218     // Relating to workspace drag fade out
 219     private float mDragFadeOutAlpha;
 220     private int mDragFadeOutDuration;
 221 
 222     // These variables are used for storing the initial and final values during workspace animations
 223     private int mSavedScrollX;
 224     private float mSavedRotationY;
 225     private float mSavedTranslationX;
 226     private float mCurrentScaleX;
 227     private float mCurrentScaleY;
 228     private float mCurrentRotationY;
 229     private float mCurrentTranslationX;
 230     private float mCurrentTranslationY;
 231     private float[] mOldTranslationXs;
 232     private float[] mOldTranslationYs;
 233     private float[] mOldScaleXs;
 234     private float[] mOldScaleYs;
 235     private float[] mOldBackgroundAlphas;
 236     private float[] mOldBackgroundAlphaMultipliers;
 237     private float[] mOldAlphas;
 238     private float[] mOldRotationYs;
 239     private float[] mNewTranslationXs;
 240     private float[] mNewTranslationYs;
 241     private float[] mNewScaleXs;
 242     private float[] mNewScaleYs;
 243     private float[] mNewBackgroundAlphas;
 244     private float[] mNewBackgroundAlphaMultipliers;
 245     private float[] mNewAlphas;
 246     private float[] mNewRotationYs;
 247     private float mTransitionProgress;
 248 
 249     /**
 250      * Used to inflate the Workspace from XML.
 251      *
 252      * @param context The application&#x27;s context.
 253      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 254      */
 255     public Workspace(Context context, AttributeSet attrs) {
 256         this(context, attrs, 0);
 257     }
 258 
 259     /**
 260      * Used to inflate the Workspace from XML.
 261      *
 262      * @param context The application&#x27;s context.
 263      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 264      * @param defStyle Unused.
 265      */
 266     public Workspace(Context context, AttributeSet attrs, int defStyle) {
 267         super(context, attrs, defStyle);
 268         mContentIsRefreshable = false;
 269 
 270         // With workspace, data is available straight from the get-go
 271         setDataIsReady();
 272 
 273         final Resources res = getResources();
 274         mFadeInAdjacentScreens = res.getBoolean(R.bool.config_workspaceFadeAdjacentScreens);
 275         mDragFadeOutAlpha = res.getInteger(R.integer.config_dragFadeOutAlpha) / 100f;
 276         mDragFadeOutDuration = res.getInteger(R.integer.config_dragFadeOutDuration);
 277         mWallpaperManager = WallpaperManager.getInstance(context);
 278 
 279         int cellCountX = DEFAULT_CELL_COUNT_X;
 280         int cellCountY = DEFAULT_CELL_COUNT_Y;
 281 
 282         TypedArray a = context.obtainStyledAttributes(attrs,
 283                 R.styleable.Workspace, defStyle, 0);
 284 
 285         if (LauncherApplication.isScreenLarge()) {
 286             // Determine number of rows/columns dynamically
 287             // TODO: This code currently fails on tablets with an aspect ratio &lt; 1.3.
 288             // Around that ratio we should make cells the same size in portrait and
 289             // landscape
 290             TypedArray actionBarSizeTypedArray =
 291                 context.obtainStyledAttributes(new int[] { android.R.attr.actionBarSize });
 292             DisplayMetrics displayMetrics = res.getDisplayMetrics();
 293             final float actionBarHeight = actionBarSizeTypedArray.getDimension(0, 0f);
 294             final float systemBarHeight = res.getDimension(R.dimen.status_bar_height);
 295             final float smallestScreenDim = res.getConfiguration().smallestScreenWidthDp *
 296                     displayMetrics.density;
 297 
 298             cellCountX = 1;
 299             while (CellLayout.widthInPortrait(res, cellCountX + 1) &lt;= smallestScreenDim) {
 300                 cellCountX++;
 301             }
 302 
 303             cellCountY = 1;
 304             while (actionBarHeight + CellLayout.heightInLandscape(res, cellCountY + 1)
 305                 &lt;= smallestScreenDim - systemBarHeight) {
 306                 cellCountY++;
 307             }
 308         }
 309 
 310         mSpringLoadedShrinkFactor =
 311             res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0f;
 312 
 313         // if the value is manually specified, use that instead
 314         cellCountX = a.getInt(R.styleable.Workspace_cellCountX, cellCountX);
 315         cellCountY = a.getInt(R.styleable.Workspace_cellCountY, cellCountY);
 316         mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 317         a.recycle();
 318 
 319         LauncherModel.updateWorkspaceLayoutCells(cellCountX, cellCountY);
 320         setHapticFeedbackEnabled(false);
 321 
 322         mLauncher = (Launcher) context;
 323         initWorkspace();
 324 
 325         // Disable multitouch across the workspace/all apps/customize tray
 326         setMotionEventSplittingEnabled(true);
 327     }
 328 
 329     // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 330     // dimension if unsuccessful
 331     public int[] estimateItemSize(int hSpan, int vSpan,
 332             ItemInfo itemInfo, boolean springLoaded) {
 333         int[] size = new int[2];
 334         if (getChildCount() &gt; 0) {
 335             CellLayout cl = (CellLayout) mLauncher.getWorkspace().getChildAt(0);
 336             Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);
 337             size[0] = r.width();
 338             size[1] = r.height();
 339             if (springLoaded) {
 340                 size[0] *= mSpringLoadedShrinkFactor;
 341                 size[1] *= mSpringLoadedShrinkFactor;
 342             }
 343             return size;
 344         } else {
 345             size[0] = Integer.MAX_VALUE;
 346             size[1] = Integer.MAX_VALUE;
 347             return size;
 348         }
 349     }
 350     public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,
 351             int hCell, int vCell, int hSpan, int vSpan) {
 352         Rect r = new Rect();
 353         cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 354         return r;
 355     }
 356 
 357     public void buildPageHardwareLayers() {
 358         if (getWindowToken() != null) {
 359             final int childCount = getChildCount();
 360             for (int i = 0; i &lt; childCount; i++) {
 361                 CellLayout cl = (CellLayout) getChildAt(i);
 362                 cl.buildChildrenLayer();
 363             }
 364         }
 365     }
 366 
 367     public void onDragStart(DragSource source, Object info, int dragAction) {
 368         mIsDragOccuring = true;
 369         updateChildrenLayersEnabled();
 370         mLauncher.lockScreenOrientationOnLargeUI();
 371 
 372         // Fade out the workspace slightly to highlight the currently dragging item
 373         int count = getChildCount();
 374         for (int i = 0; i &lt; count; i++) {
 375             CellLayout cl = (CellLayout) getPageAt(i);
 376             cl.getChildrenLayout().animate().alpha(mDragFadeOutAlpha)
 377                 .setInterpolator(new AccelerateInterpolator(1.5f))
 378                 .setDuration(mDragFadeOutDuration)
 379                 .start();
 380         }
 381     }
 382 
 383     public void onDragEnd() {
 384         mIsDragOccuring = false;
 385         updateChildrenLayersEnabled();
 386         mLauncher.unlockScreenOrientationOnLargeUI();
 387 
 388         // Fade the workspace back in after we have completed dragging
 389         int count = getChildCount();
 390         for (int i = 0; i &lt; count; i++) {
 391             CellLayout cl = (CellLayout) getPageAt(i);
 392             cl.getChildrenLayout().animate().alpha(1f)
 393                 .setInterpolator(new DecelerateInterpolator(1.5f))
 394                 .setDuration(mDragFadeOutDuration)
 395                 .start();
 396         }
 397     }
 398 
 399     /**
 400      * Initializes various states for this workspace.
 401      */
 402     protected void initWorkspace() {
 403         Context context = getContext();
 404         mCurrentPage = mDefaultPage;
 405         Launcher.setScreen(mCurrentPage);
 406         LauncherApplication app = (LauncherApplication)context.getApplicationContext();
 407         mIconCache = app.getIconCache();
 408         mExternalDragOutlinePaint.setAntiAlias(true);
 409         setWillNotDraw(false);
 410         setChildrenDrawnWithCacheEnabled(true);
 411 
 412         try {
 413             final Resources res = getResources();
 414             mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 415         } catch (Resources.NotFoundException e) {
 416             // In this case, we will skip drawing background protection
 417         }
 418 
 419         mWallpaperOffset = new WallpaperOffsetInterpolator();
 420         Display display = mLauncher.getWindowManager().getDefaultDisplay();
 421         mDisplayWidth = display.getWidth();
 422         mDisplayHeight = display.getHeight();
 423         mWallpaperTravelWidth = (int) (mDisplayWidth *
 424                 wallpaperTravelToScreenWidthRatio(mDisplayWidth, mDisplayHeight));
 425 
 426         mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 427 
 428     }
 429 
 430     @Override
 431     protected int getScrollMode() {
 432         return SmoothPagedView.X_LARGE_MODE;
 433     }
 434 
 435     @Override
 436     protected void onViewAdded(View child) {
 437         super.onViewAdded(child);
 438         if (!(child instanceof CellLayout)) {
 439             throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 440         }
 441         CellLayout cl = ((CellLayout) child);
 442         cl.setOnInterceptTouchListener(this);
 443         cl.setClickable(true);
 444         cl.enableHardwareLayers();
 445     }
 446 
 447     /**
 448      * @return The open folder on the current screen, or null if there is none
 449      */
 450     Folder getOpenFolder() {
 451         DragLayer dragLayer = mLauncher.getDragLayer();
 452         int count = dragLayer.getChildCount();
 453         for (int i = 0; i &lt; count; i++) {
 454             View child = dragLayer.getChildAt(i);
 455             if (child instanceof Folder) {
 456                 Folder folder = (Folder) child;
 457                 if (folder.getInfo().opened)
 458                     return folder;
 459             }
 460         }
 461         return null;
 462     }
 463 
 464     boolean isTouchActive() {
 465         return mTouchState != TOUCH_STATE_REST;
 466     }
 467 
 468     /**
 469      * Adds the specified child in the specified screen. The position and dimension of
 470      * the child are defined by x, y, spanX and spanY.
 471      *
 472      * @param child The child to add in one of the workspace&#x27;s screens.
 473      * @param screen The screen in which to add the child.
 474      * @param x The X position of the child in the screen&#x27;s grid.
 475      * @param y The Y position of the child in the screen&#x27;s grid.
 476      * @param spanX The number of cells spanned horizontally by the child.
 477      * @param spanY The number of cells spanned vertically by the child.
 478      */
 479     void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY) {
 480         addInScreen(child, container, screen, x, y, spanX, spanY, false);
 481     }
 482 
 483     /**
 484      * Adds the specified child in the specified screen. The position and dimension of
 485      * the child are defined by x, y, spanX and spanY.
 486      *
 487      * @param child The child to add in one of the workspace&#x27;s screens.
 488      * @param screen The screen in which to add the child.
 489      * @param x The X position of the child in the screen&#x27;s grid.
 490      * @param y The Y position of the child in the screen&#x27;s grid.
 491      * @param spanX The number of cells spanned horizontally by the child.
 492      * @param spanY The number of cells spanned vertically by the child.
 493      * @param insert When true, the child is inserted at the beginning of the children list.
 494      */
 495     void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY,
 496             boolean insert) {
 497         if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 498             if (screen &lt; 0 || screen &gt;= getChildCount()) {
 499                 Log.e(TAG, &quot;The screen must be &gt;= 0 and &lt; &quot; + getChildCount()
 500                     + &quot; (was &quot; + screen + &quot;); skipping child&quot;);
 501                 return;
 502             }
 503         }
 504 
 505         final CellLayout layout;
 506         if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 507             layout = mLauncher.getHotseat().getLayout();
 508             child.setOnKeyListener(null);
 509 
 510             // Hide folder title in the hotseat
 511             if (child instanceof FolderIcon) {
 512                 ((FolderIcon) child).setTextVisible(false);
 513             }
 514 
 515             if (screen &lt; 0) {
 516                 screen = mLauncher.getHotseat().getOrderInHotseat(x, y);
 517             } else {
 518                 // Note: We do this to ensure that the hotseat is always laid out in the orientation
 519                 // of the hotseat in order regardless of which orientation they were added
 520                 x = mLauncher.getHotseat().getCellXFromOrder(screen);
 521                 y = mLauncher.getHotseat().getCellYFromOrder(screen);
 522             }
 523         } else {
 524             // Show folder title if not in the hotseat
 525             if (child instanceof FolderIcon) {
 526                 ((FolderIcon) child).setTextVisible(true);
 527             }
 528 
 529             layout = (CellLayout) getChildAt(screen);
 530             child.setOnKeyListener(new IconKeyEventListener());
 531         }
 532 
 533         LayoutParams genericLp = child.getLayoutParams();
 534         CellLayout.LayoutParams lp;
 535         if (genericLp == null || !(genericLp instanceof CellLayout.LayoutParams)) {
 536             lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 537         } else {
 538             lp = (CellLayout.LayoutParams) genericLp;
 539             lp.cellX = x;
 540             lp.cellY = y;
 541             lp.cellHSpan = spanX;
 542             lp.cellVSpan = spanY;
 543         }
 544 
 545         if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) {
 546             lp.isLockedToGrid = false;
 547         }
 548 
 549         // Get the canonical child id to uniquely represent this view in this screen
 550         int childId = LauncherModel.getCellLayoutChildId(container, screen, x, y, spanX, spanY);
 551         boolean markCellsAsOccupied = !(child instanceof Folder);
 552         if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 553             // TODO: This branch occurs when the workspace is adding views
 554             // outside of the defined grid
 555             // maybe we should be deleting these items from the LauncherModel?
 556             Log.w(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;);
 557         }
 558 
 559         if (!(child instanceof Folder)) {
 560             child.setHapticFeedbackEnabled(false);
 561             child.setOnLongClickListener(mLongClickListener);
 562         }
 563         if (child instanceof DropTarget) {
 564             mDragController.addDropTarget((DropTarget) child);
 565         }
 566     }
 567 
 568     /**
 569      * Check if the point (x, y) hits a given page.
 570      */
 571     private boolean hitsPage(int index, float x, float y) {
 572         final View page = getChildAt(index);
 573         if (page != null) {
 574             float[] localXY = { x, y };
 575             mapPointFromSelfToChild(page, localXY);
 576             return (localXY[0] &gt;= 0 &amp;&amp; localXY[0] &lt; page.getWidth()
 577                     &amp;&amp; localXY[1] &gt;= 0 &amp;&amp; localXY[1] &lt; page.getHeight());
 578         }
 579         return false;
 580     }
 581 
 582     @Override
 583     protected boolean hitsPreviousPage(float x, float y) {
 584         // mNextPage is set to INVALID_PAGE whenever we are stationary.
 585         // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 586         final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 587 
 588         // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 589         // the active workspace
 590         return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current - 1, x, y);
 591     }
 592 
 593     @Override
 594     protected boolean hitsNextPage(float x, float y) {
 595         // mNextPage is set to INVALID_PAGE whenever we are stationary.
 596         // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 597         final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 598 
 599         // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 600         // the active workspace
 601         return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current + 1, x, y);
 602     }
 603 
 604     /**
 605      * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 606      * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 607      * that it should intercept touch events, which is not something that is normally supported.
 608      */
 609     @Override
 610     public boolean onTouch(View v, MotionEvent event) {
 611         return (isSmall() || !isFinishedSwitchingState());
 612     }
 613 
 614     public boolean isSwitchingState() {
 615         return mIsSwitchingState;
 616     }
 617 
 618     /** This differs from isSwitchingState in that we take into account how far the transition
 619      *  has completed. */
 620     public boolean isFinishedSwitchingState() {
 621         return !mIsSwitchingState || (mTransitionProgress &gt; 0.5f);
 622     }
 623 
 624     protected void onWindowVisibilityChanged (int visibility) {
 625         mLauncher.onWindowVisibilityChanged(visibility);
 626     }
 627 
 628     @Override
 629     public boolean dispatchUnhandledMove(View focused, int direction) {
 630         if (isSmall() || !isFinishedSwitchingState()) {
 631             // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
 632             return false;
 633         }
 634         return super.dispatchUnhandledMove(focused, direction);
 635     }
 636 
 637     @Override
 638     public boolean onInterceptTouchEvent(MotionEvent ev) {
 639         switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
 640         case MotionEvent.ACTION_DOWN:
 641             mXDown = ev.getX();
 642             mYDown = ev.getY();
 643             break;
 644         case MotionEvent.ACTION_POINTER_UP:
 645         case MotionEvent.ACTION_UP:
 646             if (mTouchState == TOUCH_STATE_REST) {
 647                 final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
 648                 if (!currentPage.lastDownOnOccupiedCell()) {
 649                     onWallpaperTap(ev);
 650                 }
 651             }
 652         }
 653         return super.onInterceptTouchEvent(ev);
 654     }
 655 
 656     @Override
 657     protected void determineScrollingStart(MotionEvent ev) {
 658         if (isSmall()) return;
 659         if (!isFinishedSwitchingState()) return;
 660 
 661         float deltaX = Math.abs(ev.getX() - mXDown);
 662         float deltaY = Math.abs(ev.getY() - mYDown);
 663 
 664         if (Float.compare(deltaX, 0f) == 0) return;
 665 
 666         float slope = deltaY / deltaX;
 667         float theta = (float) Math.atan(slope);
 668 
 669 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 670         if (deltaX &gt; mTouchSlop || deltaY &gt; mTouchSlop) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 671             cancelCurrentPageLongPress();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 672         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 673 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 674         if (theta &gt; MAX_SWIPE_ANGLE) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 675             // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 676             return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 677         } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 678             // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 679             // increase the touch slop to make it harder to begin scrolling the workspace. This</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 680             // results in vertically scrolling widgets to more easily. The higher the angle, the</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 681             // more we increase touch slop.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 682             theta -= START_DAMPING_TOUCH_SLOP_ANGLE;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 683             float extraRatio = (float)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 684                     Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 685             super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 686         } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 687             // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 688             super.determineScrollingStart(ev);</span>
 689 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 690             if (theta &gt; MAX_SWIPE_ANGLE) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 691                 // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 692                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 693             } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 694                 // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 695                 // increase the touch slop to make it harder to begin scrolling the workspace. This </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 696                 // results in vertically scrolling widgets to more easily. The higher the angle, the</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 697                 // more we increase touch slop.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 698                 theta -= START_DAMPING_TOUCH_SLOP_ANGLE;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 699                 float extraRatio = (float)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 700                         Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 701                 super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 702             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 703                 // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 704                 super.determineScrollingStart(ev);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 705             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 706         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 707     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 708 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 709     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 710     protected boolean isScrollingIndicatorEnabled() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 711         return mState != State.SPRING_LOADED;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 712     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 713 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 714     protected void onPageBeginMoving() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 715         super.onPageBeginMoving();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 716 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 717         if (isHardwareAccelerated()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 718             updateChildrenLayersEnabled();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 719         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 720             if (mNextPage != INVALID_PAGE) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 721                 // we&#x27;re snapping to a particular screen</span>
 722 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 723             if (theta &gt; MAX_SWIPE_ANGLE) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 724                 // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 725                 return;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 726             } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 727                 // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 728                 // increase the touch slop to make it harder to begin scrolling the workspace. This</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 729                 // results in vertically scrolling widgets to more easily. The higher the angle, the</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 730                 // more we increase touch slop.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 731                 theta -= START_DAMPING_TOUCH_SLOP_ANGLE;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 732                 float extraRatio = (float)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 733                         Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 734                 super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 735             } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 736                 // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 737                 super.determineScrollingStart(ev);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 738             }</span>
 739 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 740         }
 741     }
 742 
 743     @Override
 744     protected boolean isScrollingIndicatorEnabled() {
 745         return mState != State.SPRING_LOADED;
 746     }
 747 
 748     protected void onPageBeginMoving() {
 749         super.onPageBeginMoving();
 750 
 751         if (isHardwareAccelerated()) {
 752             updateChildrenLayersEnabled();
 753         } else {
 754             if (mNextPage != INVALID_PAGE) {
 755                 // we&#x27;re snapping to a particular screen
 756                 enableChildrenCache(mCurrentPage, mNextPage);
 757             } else {
 758                 // this is when user is actively dragging a particular screen, they might
 759                 // swipe it either left or right (but we won&#x27;t advance by more than one screen)
 760                 enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
 761             }
 762         }
 763 
 764         // Only show page outlines as we pan if we are on large screen
 765         if (LauncherApplication.isScreenLarge()) {
 766             showOutlines();
 767             mIsStaticWallpaper = mWallpaperManager.getWallpaperInfo() == null;
 768         }
 769 
 770         // If we are not fading in adjacent screens, we still need to restore the alpha in case the
 771         // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)
 772         if (!mFadeInAdjacentScreens) {
 773             for (int i = 0; i &lt; getChildCount(); ++i) {
 774                 getPageAt(i).setAlpha(1f);
 775             }
 776         }
 777 
 778         // Show the scroll indicator as you pan the page
 779         showScrollingIndicator(false);
 780     }
 781 
 782     protected void onPageEndMoving() {
 783         super.onPageEndMoving();
 784 
 785         if (isHardwareAccelerated()) {
 786             updateChildrenLayersEnabled();
 787         } else {
 788             clearChildrenCache();
 789         }
 790 
 791 
 792         if (mDragController.isDragging()) {
 793             if (isSmall()) {
 794                 // If we are in springloaded mode, then force an event to check if the current touch
 795                 // is under a new page (to scroll to)
 796                 mDragController.forceMoveEvent();
 797             }
 798         } else {
 799             // If we are not mid-dragging, hide the page outlines if we are on a large screen
 800             if (LauncherApplication.isScreenLarge()) {
 801                 hideOutlines();
 802             }
 803 
 804             // Hide the scroll indicator as you pan the page
 805             if (!mDragController.isDragging()) {
 806                 hideScrollingIndicator(false);
 807             }
 808         }
 809         mOverScrollMaxBackgroundAlpha = 0.0f;
 810         mOverScrollPageIndex = -1;
 811 
 812         if (mDelayedResizeRunnable != null) {
 813             mDelayedResizeRunnable.run();
 814             mDelayedResizeRunnable = null;
 815         }
 816     }
 817 
 818     @Override
 819     protected void notifyPageSwitchListener() {
 820         super.notifyPageSwitchListener();
 821         Launcher.setScreen(mCurrentPage);
 822     };
 823 
 824     // As a ratio of screen height, the total distance we want the parallax effect to span
 825     // horizontally
 826     private float wallpaperTravelToScreenWidthRatio(int width, int height) {
 827         float aspectRatio = width / (float) height;
 828 
 829         // At an aspect ratio of 16/10, the wallpaper parallax effect should span 1.5 * screen width
 830         // At an aspect ratio of 10/16, the wallpaper parallax effect should span 1.2 * screen width
 831         // We will use these two data points to extrapolate how much the wallpaper parallax effect
 832         // to span (ie travel) at any aspect ratio:
 833 
 834         final float ASPECT_RATIO_LANDSCAPE = 16/10f;
 835         final float ASPECT_RATIO_PORTRAIT = 10/16f;
 836         final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE = 1.5f;
 837         final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT = 1.2f;
 838 
 839         // To find out the desired width at different aspect ratios, we use the following two
 840         // formulas, where the coefficient on x is the aspect ratio (width/height):
 841         //   (16/10)x + y = 1.5
 842         //   (10/16)x + y = 1.2
 843         // We solve for x and y and end up with a final formula:
 844         final float x =
 845             (WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE - WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT) /
 846             (ASPECT_RATIO_LANDSCAPE - ASPECT_RATIO_PORTRAIT);
 847         final float y = WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT - x * ASPECT_RATIO_PORTRAIT;
 848         return x * aspectRatio + y;
 849     }
 850 
 851     // The range of scroll values for Workspace
 852     private int getScrollRange() {
 853         return getChildOffset(getChildCount() - 1) - getChildOffset(0);
 854     }
 855 
 856     protected void setWallpaperDimension() {
 857         DisplayMetrics displayMetrics = new DisplayMetrics();
 858         mLauncher.getWindowManager().getDefaultDisplay().getRealMetrics(displayMetrics);
 859         final int maxDim = Math.max(displayMetrics.widthPixels, displayMetrics.heightPixels);
 860         final int minDim = Math.min(displayMetrics.widthPixels, displayMetrics.heightPixels);
 861 
 862         // We need to ensure that there is enough extra space in the wallpaper for the intended
 863         // parallax effects
 864         if (LauncherApplication.isScreenLarge()) {
 865             mWallpaperWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
 866             mWallpaperHeight = maxDim;
 867         } else {
 868             mWallpaperWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
 869             mWallpaperHeight = maxDim;
 870         }
 871         new Thread(&quot;setWallpaperDimension&quot;) {
 872             public void run() {
 873                 mWallpaperManager.suggestDesiredDimensions(mWallpaperWidth, mWallpaperHeight);
 874             }
 875         }.start();
 876     }
 877 
 878     private float wallpaperOffsetForCurrentScroll() {
 879         // Set wallpaper offset steps (1 / (number of screens - 1))
 880         mWallpaperManager.setWallpaperOffsetSteps(1.0f / (getChildCount() - 1), 1.0f);
 881 
 882         // For the purposes of computing the scrollRange and overScrollOffset, we assume
 883         // that mLayoutScale is 1. This means that when we&#x27;re in spring-loaded mode,
 884         // there&#x27;s no discrepancy between the wallpaper offset for a given page.
 885         float layoutScale = mLayoutScale;
 886         mLayoutScale = 1f;
 887         int scrollRange = getScrollRange();
 888 
 889         // Again, we adjust the wallpaper offset to be consistent between values of mLayoutScale
 890         float adjustedScrollX = Math.max(0, Math.min(mScrollX, mMaxScrollX));
 891         adjustedScrollX *= mWallpaperScrollRatio;
 892         mLayoutScale = layoutScale;
 893 
 894         float scrollProgress =
 895             adjustedScrollX / (float) scrollRange;
 896 
 897         if (LauncherApplication.isScreenLarge() &amp;&amp; mIsStaticWallpaper) {
 898             // The wallpaper travel width is how far, from left to right, the wallpaper will move
 899             // at this orientation. On tablets in portrait mode we don&#x27;t move all the way to the
 900             // edges of the wallpaper, or otherwise the parallax effect would be too strong.
 901             int wallpaperTravelWidth = Math.min(mWallpaperTravelWidth, mWallpaperWidth);
 902 
 903             float offsetInDips = wallpaperTravelWidth * scrollProgress +
 904                 (mWallpaperWidth - wallpaperTravelWidth) / 2; // center it
 905             float offset = offsetInDips / (float) mWallpaperWidth;
 906             return offset;
 907         } else {
 908             return scrollProgress;
 909         }
 910     }
 911 
 912     private void syncWallpaperOffsetWithScroll() {
 913         final boolean enableWallpaperEffects = isHardwareAccelerated();
 914         if (enableWallpaperEffects) {
 915             mWallpaperOffset.setFinalX(wallpaperOffsetForCurrentScroll());
 916         }
 917     }
 918 
 919     public void updateWallpaperOffsetImmediately() {
 920         mUpdateWallpaperOffsetImmediately = true;
 921     }
 922 
 923     private void updateWallpaperOffsets() {
 924         boolean updateNow = false;
 925         boolean keepUpdating = true;
 926         if (mUpdateWallpaperOffsetImmediately) {
 927             updateNow = true;
 928             keepUpdating = false;
 929             mWallpaperOffset.jumpToFinal();
 930             mUpdateWallpaperOffsetImmediately = false;
 931         } else {
 932             updateNow = keepUpdating = mWallpaperOffset.computeScrollOffset();
 933         }
 934         if (updateNow) {
 935             if (mWindowToken != null) {
 936                 mWallpaperManager.setWallpaperOffsets(mWindowToken,
 937                         mWallpaperOffset.getCurrX(), mWallpaperOffset.getCurrY());
 938             }
 939         }
 940         if (keepUpdating) {
 941             invalidate();
 942         }
 943     }
 944 
 945     @Override
 946     protected void updateCurrentPageScroll() {
 947         super.updateCurrentPageScroll();
 948         computeWallpaperScrollRatio(mCurrentPage);
 949     }
 950 
 951     @Override
 952     protected void snapToPage(int whichPage) {
 953         super.snapToPage(whichPage);
 954         computeWallpaperScrollRatio(whichPage);
 955     }
 956 
 957     private void computeWallpaperScrollRatio(int page) {
 958         // Here, we determine what the desired scroll would be with and without a layout scale,
 959         // and compute a ratio between the two. This allows us to adjust the wallpaper offset
 960         // as though there is no layout scale.
 961         float layoutScale = mLayoutScale;
 962         int scaled = getChildOffset(page) - getRelativeChildOffset(page);
 963         mLayoutScale = 1.0f;
 964         float unscaled = getChildOffset(page) - getRelativeChildOffset(page);
 965         mLayoutScale = layoutScale;
 966         if (scaled &gt; 0) {
 967             mWallpaperScrollRatio = (1.0f * unscaled) / scaled;
 968         } else {
 969             mWallpaperScrollRatio = 1f;
 970         }
 971     }
 972 
 973     class WallpaperOffsetInterpolator {
 974         float mFinalHorizontalWallpaperOffset = 0.0f;
 975         float mFinalVerticalWallpaperOffset = 0.5f;
 976         float mHorizontalWallpaperOffset = 0.0f;
 977         float mVerticalWallpaperOffset = 0.5f;
 978         long mLastWallpaperOffsetUpdateTime;
 979         boolean mIsMovingFast;
 980         boolean mOverrideHorizontalCatchupConstant;
 981         float mHorizontalCatchupConstant = 0.35f;
 982         float mVerticalCatchupConstant = 0.35f;
 983 
 984         public WallpaperOffsetInterpolator() {
 985         }
 986 
 987         public void setOverrideHorizontalCatchupConstant(boolean override) {
 988             mOverrideHorizontalCatchupConstant = override;
 989         }
 990 
 991         public void setHorizontalCatchupConstant(float f) {
 992             mHorizontalCatchupConstant = f;
 993         }
 994 
 995         public void setVerticalCatchupConstant(float f) {
 996             mVerticalCatchupConstant = f;
 997         }
 998 
 999         public boolean computeScrollOffset() {
1000             if (Float.compare(mHorizontalWallpaperOffset, mFinalHorizontalWallpaperOffset) == 0 &amp;&amp;
1001                     Float.compare(mVerticalWallpaperOffset, mFinalVerticalWallpaperOffset) == 0) {
1002                 mIsMovingFast = false;
1003                 return false;
1004             }
1005             boolean isLandscape = mDisplayWidth &gt; mDisplayHeight;
1006 
1007             long currentTime = System.currentTimeMillis();
1008             long timeSinceLastUpdate = currentTime - mLastWallpaperOffsetUpdateTime;
1009             timeSinceLastUpdate = Math.min((long) (1000/30f), timeSinceLastUpdate);
1010             timeSinceLastUpdate = Math.max(1L, timeSinceLastUpdate);
1011 
1012             float xdiff = Math.abs(mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset);
1013             if (!mIsMovingFast &amp;&amp; xdiff &gt; 0.07) {
1014                 mIsMovingFast = true;
1015             }
1016 
1017             float fractionToCatchUpIn1MsHorizontal;
1018             if (mOverrideHorizontalCatchupConstant) {
1019                 fractionToCatchUpIn1MsHorizontal = mHorizontalCatchupConstant;
1020             } else if (mIsMovingFast) {
1021                 fractionToCatchUpIn1MsHorizontal = isLandscape ? 0.5f : 0.75f;
1022             } else {
1023                 // slow
1024                 fractionToCatchUpIn1MsHorizontal = isLandscape ? 0.27f : 0.5f;
1025             }
1026             float fractionToCatchUpIn1MsVertical = mVerticalCatchupConstant;
1027 
1028             fractionToCatchUpIn1MsHorizontal /= 33f;
1029             fractionToCatchUpIn1MsVertical /= 33f;
1030 
1031             final float UPDATE_THRESHOLD = 0.00001f;
1032             float hOffsetDelta = mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset;
1033             float vOffsetDelta = mFinalVerticalWallpaperOffset - mVerticalWallpaperOffset;
1034             boolean jumpToFinalValue = Math.abs(hOffsetDelta) &lt; UPDATE_THRESHOLD &amp;&amp;
1035                 Math.abs(vOffsetDelta) &lt; UPDATE_THRESHOLD;
1036 
1037             // Don&#x27;t have any lag between workspace and wallpaper on non-large devices
1038             if (!LauncherApplication.isScreenLarge() || jumpToFinalValue) {
1039                 mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
1040                 mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
1041             } else {
1042                 float percentToCatchUpVertical =
1043                     Math.min(1.0f, timeSinceLastUpdate * fractionToCatchUpIn1MsVertical);
1044                 float percentToCatchUpHorizontal =
1045                     Math.min(1.0f, timeSinceLastUpdate * fractionToCatchUpIn1MsHorizontal);
1046                 mHorizontalWallpaperOffset += percentToCatchUpHorizontal * hOffsetDelta;
1047                 mVerticalWallpaperOffset += percentToCatchUpVertical * vOffsetDelta;
1048             }
1049 
1050             mLastWallpaperOffsetUpdateTime = System.currentTimeMillis();
1051             return true;
1052         }
1053 
1054         public float getCurrX() {
1055             return mHorizontalWallpaperOffset;
1056         }
1057 
1058         public float getFinalX() {
1059             return mFinalHorizontalWallpaperOffset;
1060         }
1061 
1062         public float getCurrY() {
1063             return mVerticalWallpaperOffset;
1064         }
1065 
1066         public float getFinalY() {
1067             return mFinalVerticalWallpaperOffset;
1068         }
1069 
1070         public void setFinalX(float x) {
1071             mFinalHorizontalWallpaperOffset = Math.max(0f, Math.min(x, 1.0f));
1072         }
1073 
1074         public void setFinalY(float y) {
1075             mFinalVerticalWallpaperOffset = Math.max(0f, Math.min(y, 1.0f));
1076         }
1077 
1078         public void jumpToFinal() {
1079             mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
1080             mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
1081         }
1082     }
1083 
1084     @Override
1085     public void computeScroll() {
1086         super.computeScroll();
1087         syncWallpaperOffsetWithScroll();
1088     }
1089 
1090     void showOutlines() {
1091         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1092             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1093             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1094             mChildrenOutlineFadeInAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);
1095             mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1096             mChildrenOutlineFadeInAnimation.start();
1097         }
1098     }
1099 
1100     void hideOutlines() {
1101         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1102             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1103             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
<abbr title="1104             mChildrenOutlineFadeOutAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);">1104             mChildrenOutlineFadeOutAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f)</abbr>
1105             mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1106             mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1107             mChildrenOutlineFadeOutAnimation.start();
1108         }
1109     }
1110 
1111     public void showOutlinesTemporarily() {
1112         if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1113             snapToPage(mCurrentPage);
1114         }
1115     }
1116 
1117     public void setChildrenOutlineAlpha(float alpha) {
1118         mChildrenOutlineAlpha = alpha;
1119         for (int i = 0; i &lt; getChildCount(); i++) {
1120             CellLayout cl = (CellLayout) getChildAt(i);
1121             cl.setBackgroundAlpha(alpha);
1122         }
1123     }
1124 
1125     public float getChildrenOutlineAlpha() {
1126         return mChildrenOutlineAlpha;
1127     }
1128 
1129     void disableBackground() {
1130         mDrawBackground = false;
1131     }
1132     void enableBackground() {
1133         mDrawBackground = true;
1134     }
1135 
1136     private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1137         if (mBackground == null) return;
1138         if (mBackgroundFadeInAnimation != null) {
1139             mBackgroundFadeInAnimation.cancel();
1140             mBackgroundFadeInAnimation = null;
1141         }
1142         if (mBackgroundFadeOutAnimation != null) {
1143             mBackgroundFadeOutAnimation.cancel();
1144             mBackgroundFadeOutAnimation = null;
1145         }
1146         float startAlpha = getBackgroundAlpha();
1147         if (finalAlpha != startAlpha) {
1148             if (animated) {
1149                 mBackgroundFadeOutAnimation = ValueAnimator.ofFloat(startAlpha, finalAlpha);
1150                 mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1151                     public void onAnimationUpdate(ValueAnimator animation) {
1152                         setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1153                     }
1154                 });
1155                 mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1156                 mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1157                 mBackgroundFadeOutAnimation.start();
1158             } else {
1159                 setBackgroundAlpha(finalAlpha);
1160             }
1161         }
1162     }
1163 
1164     public void setBackgroundAlpha(float alpha) {
1165         if (alpha != mBackgroundAlpha) {
1166             mBackgroundAlpha = alpha;
1167             invalidate();
1168         }
1169     }
1170 
1171     public float getBackgroundAlpha() {
1172         return mBackgroundAlpha;
1173     }
1174 
1175     /**
1176      * Due to 3D transformations, if two CellLayouts are theoretically touching each other,
1177      * on the xy plane, when one is rotated along the y-axis, the gap between them is perceived
1178      * as being larger. This method computes what offset the rotated view should be translated
1179      * in order to minimize this perceived gap.
1180      * @param degrees Angle of the view
1181      * @param width Width of the view
1182      * @param height Height of the view
1183      * @return Offset to be used in a View.setTranslationX() call
1184      */
1185     private float getOffsetXForRotation(float degrees, int width, int height) {
1186         mMatrix.reset();
1187         mCamera.save();
1188         mCamera.rotateY(Math.abs(degrees));
1189         mCamera.getMatrix(mMatrix);
1190         mCamera.restore();
1191 
1192         mMatrix.preTranslate(-width * 0.5f, -height * 0.5f);
1193         mMatrix.postTranslate(width * 0.5f, height * 0.5f);
1194         mTempFloat2[0] = width;
1195         mTempFloat2[1] = height;
1196         mMatrix.mapPoints(mTempFloat2);
1197         return (width - mTempFloat2[0]) * (degrees &gt; 0.0f ? 1.0f : -1.0f);
1198     }
1199 
1200     float backgroundAlphaInterpolator(float r) {
1201         float pivotA = 0.1f;
1202         float pivotB = 0.4f;
1203         if (r &lt; pivotA) {
1204             return 0;
1205         } else if (r &gt; pivotB) {
1206             return 1.0f;
1207         } else {
1208             return (r - pivotA)/(pivotB - pivotA);
1209         }
1210     }
1211 
1212     float overScrollBackgroundAlphaInterpolator(float r) {
1213         float threshold = 0.08f;
1214 
1215         if (r &gt; mOverScrollMaxBackgroundAlpha) {
1216             mOverScrollMaxBackgroundAlpha = r;
1217         } else if (r &lt; mOverScrollMaxBackgroundAlpha) {
1218             r = mOverScrollMaxBackgroundAlpha;
1219         }
1220 
1221         return Math.min(r / threshold, 1.0f);
1222     }
1223 
1224     private void screenScrolledLargeUI(int screenCenter) {
1225         if (isSwitchingState()) return;
1226         boolean isInOverscroll = false;
1227         for (int i = 0; i &lt; getChildCount(); i++) {
1228             CellLayout cl = (CellLayout) getChildAt(i);
1229             if (cl != null) {
1230                 float scrollProgress = getScrollProgress(screenCenter, cl, i);
1231                 float rotation = WORKSPACE_ROTATION * scrollProgress;
1232                 float translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1233 
1234                 // If the current page (i) is being over scrolled, we use a different
1235                 // set of rules for setting the background alpha multiplier.
1236                 if (!isSmall()) {
1237                     if ((mOverScrollX &lt; 0 &amp;&amp; i == 0) || (mOverScrollX &gt; mMaxScrollX &amp;&amp;
1238                             i == getChildCount() -1)) {
1239                         isInOverscroll = true;
1240                         rotation *= -1;
1241                         cl.setBackgroundAlphaMultiplier(
1242                                 overScrollBackgroundAlphaInterpolator(Math.abs(scrollProgress)));
1243                         mOverScrollPageIndex = i;
1244                         cl.setOverScrollAmount(Math.abs(scrollProgress), i == 0);
1245                         cl.setPivotX(cl.getMeasuredWidth() * (i == 0 ? 0.75f : 0.25f));
1246                         cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1247                         cl.setOverscrollTransformsDirty(true);
1248                     } else if (mOverScrollPageIndex != i) {
1249                         cl.setBackgroundAlphaMultiplier(
1250                                 backgroundAlphaInterpolator(Math.abs(scrollProgress)));
1251                     }
1252                 }
1253                 cl.setTranslationX(translationX);
1254                 cl.setRotationY(rotation);
1255                 if (mFadeInAdjacentScreens &amp;&amp; !isSmall()) {
1256                     float alpha = 1 - Math.abs(scrollProgress);
1257                     cl.setAlpha(alpha);
1258                 }
1259             }
1260         }
1261         if (!isSwitchingState() &amp;&amp; !isInOverscroll) {
1262             ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1263             ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1264         }
1265         invalidate();
1266     }
1267 
1268     private void screenScrolledStandardUI(int screenCenter) {
1269         if (mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX) {
1270             int index = mOverScrollX &lt; 0 ? 0 : getChildCount() - 1;
1271             CellLayout cl = (CellLayout) getChildAt(index);
1272             float scrollProgress = getScrollProgress(screenCenter, cl, index);
1273             cl.setOverScrollAmount(Math.abs(scrollProgress), index == 0);
1274             float rotation = - WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1275             cl.setCameraDistance(mDensity * CAMERA_DISTANCE);
1276             cl.setPivotX(cl.getMeasuredWidth() * (index == 0 ? 0.75f : 0.25f));
1277             cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1278             cl.setRotationY(rotation);
1279             cl.setOverscrollTransformsDirty(true);
1280             setFadeForOverScroll(Math.abs(scrollProgress));
1281         } else {
1282             if (mOverscrollFade != 0) {
1283                 setFadeForOverScroll(0);
1284             }
1285             // We don&#x27;t want to mess with the translations during transitions
1286             if (!isSwitchingState()) {
1287                 ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1288                 ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1289             }
1290         }
1291     }
1292 
1293     @Override
1294     protected void screenScrolled(int screenCenter) {
1295         if (LauncherApplication.isScreenLarge()) {
1296             // We don&#x27;t call super.screenScrolled() here because we handle the adjacent pages alpha
1297             // ourselves (for efficiency), and there are no scrolling indicators to update.
1298             screenScrolledLargeUI(screenCenter);
1299         } else {
1300             super.screenScrolled(screenCenter);
1301             screenScrolledStandardUI(screenCenter);
1302         }
1303     }
1304 
1305     @Override
1306     protected void overScroll(float amount) {
1307         if (LauncherApplication.isScreenLarge()) {
1308             dampedOverScroll(amount);
1309         } else {
1310             acceleratedOverScroll(amount);
1311         }
1312     }
1313 
1314     protected void onAttachedToWindow() {
1315         super.onAttachedToWindow();
1316         mWindowToken = getWindowToken();
1317         computeScroll();
1318         mDragController.setWindowToken(mWindowToken);
1319     }
1320 
1321     protected void onDetachedFromWindow() {
1322         mWindowToken = null;
1323     }
1324 
1325     @Override
1326     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1327         if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1328             mUpdateWallpaperOffsetImmediately = true;
1329         }
1330         super.onLayout(changed, left, top, right, bottom);
1331     }
1332 
1333     @Override
1334     protected void onDraw(Canvas canvas) {
1335         updateWallpaperOffsets();
1336 
1337         // Draw the background gradient if necessary
1338         if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1339             int alpha = (int) (mBackgroundAlpha * 255);
1340             mBackground.setAlpha(alpha);
1341             mBackground.setBounds(mScrollX, 0, mScrollX + getMeasuredWidth(),
1342                     getMeasuredHeight());
1343             mBackground.draw(canvas);
1344         }
1345 
1346         super.onDraw(canvas);
1347     }
1348 
1349     boolean isDrawingBackgroundGradient() {
1350         return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1351     }
1352 
1353     @Override
1354     protected void dispatchDraw(Canvas canvas) {
1355         super.dispatchDraw(canvas);
1356 
1357         if (mInScrollArea &amp;&amp; !LauncherApplication.isScreenLarge()) {
1358             final int width = getWidth();
1359             final int height = getHeight();
1360             final int pageHeight = getChildAt(0).getHeight();
1361 
1362             // Set the height of the outline to be the height of the page
1363             final int offset = (height - pageHeight - mPaddingTop - mPaddingBottom) / 2;
1364             final int paddingTop = mPaddingTop + offset;
1365             final int paddingBottom = mPaddingBottom + offset;
1366 
1367             final int page = (mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage);
1368             final CellLayout leftPage = (CellLayout) getChildAt(page - 1);
1369             final CellLayout rightPage = (CellLayout) getChildAt(page + 1);
1370 
1371             if (leftPage != null &amp;&amp; leftPage.getIsDragOverlapping()) {
1372                 final Drawable d = getResources().getDrawable(R.drawable.page_hover_left_holo);
1373                 d.setBounds(mScrollX, paddingTop, mScrollX + d.getIntrinsicWidth(),
1374                         height - paddingBottom);
1375                 d.draw(canvas);
1376             } else if (rightPage != null &amp;&amp; rightPage.getIsDragOverlapping()) {
1377                 final Drawable d = getResources().getDrawable(R.drawable.page_hover_right_holo);
1378                 d.setBounds(mScrollX + width - d.getIntrinsicWidth(), paddingTop, mScrollX + width,
1379                         height - paddingBottom);
1380                 d.draw(canvas);
1381             }
1382         }
1383     }
1384 
1385     @Override
1386     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1387         if (!mLauncher.isAllAppsVisible()) {
1388             final Folder openFolder = getOpenFolder();
1389             if (openFolder != null) {
1390                 return openFolder.requestFocus(direction, previouslyFocusedRect);
1391             } else {
1392                 return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1393             }
1394         }
1395         return false;
1396     }
1397 
1398     @Override
1399     public int getDescendantFocusability() {
1400         if (isSmall()) {
1401             return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1402         }
1403         return super.getDescendantFocusability();
1404     }
1405 
1406     @Override
1407     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1408         if (!mLauncher.isAllAppsVisible()) {
1409             final Folder openFolder = getOpenFolder();
1410             if (openFolder != null) {
1411                 openFolder.addFocusables(views, direction);
1412             } else {
1413                 super.addFocusables(views, direction, focusableMode);
1414             }
1415         }
1416     }
1417 
1418     public boolean isSmall() {
1419         return mState == State.SMALL || mState == State.SPRING_LOADED;
1420     }
1421 
1422     void enableChildrenCache(int fromPage, int toPage) {
1423         if (fromPage &gt; toPage) {
1424             final int temp = fromPage;
1425             fromPage = toPage;
1426             toPage = temp;
1427         }
1428 
1429         final int screenCount = getChildCount();
1430 
1431         fromPage = Math.max(fromPage, 0);
1432         toPage = Math.min(toPage, screenCount - 1);
1433 
1434         for (int i = fromPage; i &lt;= toPage; i++) {
1435             final CellLayout layout = (CellLayout) getChildAt(i);
1436             layout.setChildrenDrawnWithCacheEnabled(true);
1437             layout.setChildrenDrawingCacheEnabled(true);
1438         }
1439     }
1440 
1441     void clearChildrenCache() {
1442         final int screenCount = getChildCount();
1443         for (int i = 0; i &lt; screenCount; i++) {
1444             final CellLayout layout = (CellLayout) getChildAt(i);
1445             layout.setChildrenDrawnWithCacheEnabled(false);
1446             // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1447             if (!isHardwareAccelerated()) {
1448                 layout.setChildrenDrawingCacheEnabled(false);
1449             }
1450         }
1451     }
1452 
1453     private void updateChildrenLayersEnabled() {
1454         boolean small = isSmall() || mIsSwitchingState;
1455         boolean dragging = mAnimatingViewIntoPlace || mIsDragOccuring;
1456         boolean enableChildrenLayers = small || dragging || isPageMoving();
1457 
1458         if (enableChildrenLayers != mChildrenLayersEnabled) {
1459             mChildrenLayersEnabled = enableChildrenLayers;
1460             for (int i = 0; i &lt; getPageCount(); i++) {
1461                 ((ViewGroup)getChildAt(i)).setChildrenLayersEnabled(mChildrenLayersEnabled);
1462             }
1463         }
1464     }
1465 
1466     protected void onWallpaperTap(MotionEvent ev) {
1467         final int[] position = mTempCell;
1468         getLocationOnScreen(position);
1469 
1470         int pointerIndex = ev.getActionIndex();
1471         position[0] += (int) ev.getX(pointerIndex);
1472         position[1] += (int) ev.getY(pointerIndex);
1473 
1474         mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1475                 ev.getAction() == MotionEvent.ACTION_UP
1476                         ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1477                 position[0], position[1], 0, null);
1478     }
1479 
1480     /*
1481      * This interpolator emulates the rate at which the perceived scale of an object changes
1482      * as its distance from a camera increases. When this interpolator is applied to a scale
1483      * animation on a view, it evokes the sense that the object is shrinking due to moving away
1484      * from the camera.
1485      */
1486     static class ZInterpolator implements TimeInterpolator {
1487         private float focalLength;
1488 
1489         public ZInterpolator(float foc) {
1490             focalLength = foc;
1491         }
1492 
1493         public float getInterpolation(float input) {
1494             return (1.0f - focalLength / (focalLength + input)) /
1495                 (1.0f - focalLength / (focalLength + 1.0f));
1496         }
1497     }
1498 
1499     /*
1500      * The exact reverse of ZInterpolator.
1501      */
1502     static class InverseZInterpolator implements TimeInterpolator {
1503         private ZInterpolator zInterpolator;
1504         public InverseZInterpolator(float foc) {
1505             zInterpolator = new ZInterpolator(foc);
1506         }
1507         public float getInterpolation(float input) {
1508             return 1 - zInterpolator.getInterpolation(1 - input);
1509         }
1510     }
1511 
1512     /*
1513      * ZInterpolator compounded with an ease-out.
1514      */
1515     static class ZoomOutInterpolator implements TimeInterpolator {
1516         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75f);
1517         private final ZInterpolator zInterpolator = new ZInterpolator(0.13f);
1518 
1519         public float getInterpolation(float input) {
1520             return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1521         }
1522     }
1523 
1524     /*
1525      * InvereZInterpolator compounded with an ease-out.
1526      */
1527     static class ZoomInInterpolator implements TimeInterpolator {
1528         private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35f);
1529         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0f);
1530 
1531         public float getInterpolation(float input) {
1532             return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1533         }
1534     }
1535 
1536     private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1537 
1538     /*
1539     *
1540     * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1541     * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1542     *
1543     * These methods mark the appropriate pages as accepting drops (which alters their visual
1544     * appearance).
1545     *
1546     */
1547     public void onDragStartedWithItem(View v) {
1548         final Canvas canvas = new Canvas();
1549 
1550         // The outline is used to visualize where the item will land if dropped
1551         mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);
1552     }
1553 
1554     public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, Paint alphaClipPaint) {
1555         final Canvas canvas = new Canvas();
1556 
1557         int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1558 
1559         // The outline is used to visualize where the item will land if dropped
1560         mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0],
1561                 size[1], alphaClipPaint);
1562     }
1563 
1564     // we call this method whenever a drag and drop in Launcher finishes, even if Workspace was
1565     // never dragged over
1566     public void onDragStopped(boolean success) {
1567         // In the success case, DragController has already called onDragExit()
1568         if (!success) {
1569             doDragExit(null);
1570         }
1571     }
1572 
1573     public void exitWidgetResizeMode() {
1574         DragLayer dragLayer = mLauncher.getDragLayer();
1575         dragLayer.clearAllResizeFrames();
1576     }
1577 
1578     private void initAnimationArrays() {
1579         final int childCount = getChildCount();
1580         if (mOldTranslationXs != null) return;
1581         mOldTranslationXs = new float[childCount];
1582         mOldTranslationYs = new float[childCount];
1583         mOldScaleXs = new float[childCount];
1584         mOldScaleYs = new float[childCount];
1585         mOldBackgroundAlphas = new float[childCount];
1586         mOldBackgroundAlphaMultipliers = new float[childCount];
1587         mOldAlphas = new float[childCount];
1588         mOldRotationYs = new float[childCount];
1589         mNewTranslationXs = new float[childCount];
1590         mNewTranslationYs = new float[childCount];
1591         mNewScaleXs = new float[childCount];
1592         mNewScaleYs = new float[childCount];
1593         mNewBackgroundAlphas = new float[childCount];
1594         mNewBackgroundAlphaMultipliers = new float[childCount];
1595         mNewAlphas = new float[childCount];
1596         mNewRotationYs = new float[childCount];
1597     }
1598 
1599     Animator getChangeStateAnimation(final State state, boolean animated) {
1600         return getChangeStateAnimation(state, animated, 0);
1601     }
1602 
1603     Animator getChangeStateAnimation(final State state, boolean animated, int delay) {
1604         if (mState == state) {
1605             return null;
1606         }
1607 
1608         // Initialize animation arrays for the first time if necessary
1609         initAnimationArrays();
1610 
1611         AnimatorSet anim = animated ? new AnimatorSet() : null;
1612 
1613         // Stop any scrolling, move to the current page right away
1614         setCurrentPage((mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage);
1615 
1616         final State oldState = mState;
1617         final boolean oldStateIsNormal = (oldState == State.NORMAL);
1618         final boolean oldStateIsSmall = (oldState == State.SMALL);
1619         mState = state;
1620         final boolean stateIsNormal = (state == State.NORMAL);
1621         final boolean stateIsSpringLoaded = (state == State.SPRING_LOADED);
1622         final boolean stateIsSmall = (state == State.SMALL);
1623         float finalScaleFactor = 1.0f;
1624         float finalBackgroundAlpha = stateIsSpringLoaded ? 1.0f : 0f;
1625         float translationX = 0;
1626         float translationY = 0;
1627         boolean zoomIn = true;
1628 
1629         if (state != State.NORMAL) {
1630             finalScaleFactor = mSpringLoadedShrinkFactor - (stateIsSmall ? 0.1f : 0);
1631             if (oldStateIsNormal &amp;&amp; stateIsSmall) {
1632                 zoomIn = false;
1633                 setLayoutScale(finalScaleFactor);
1634                 updateChildrenLayersEnabled();
1635             } else {
1636                 finalBackgroundAlpha = 1.0f;
1637                 setLayoutScale(finalScaleFactor);
1638             }
1639         } else {
1640             setLayoutScale(1.0f);
1641         }
1642 
1643         final int duration = zoomIn ?
1644                 getResources().getInteger(R.integer.config_workspaceUnshrinkTime) :
1645                 getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
1646         for (int i = 0; i &lt; getChildCount(); i++) {
1647             final CellLayout cl = (CellLayout) getChildAt(i);
1648             float rotation = 0f;
1649             float initialAlpha = cl.getAlpha();
1650             float finalAlphaMultiplierValue = 1f;
1651             float finalAlpha = (!mFadeInAdjacentScreens || stateIsSpringLoaded ||
1652                     (i == mCurrentPage)) ? 1f : 0f;
1653 
1654             // Determine the pages alpha during the state transition
1655             if ((oldStateIsSmall &amp;&amp; stateIsNormal) ||
1656                 (oldStateIsNormal &amp;&amp; stateIsSmall)) {
1657                 // To/from workspace - only show the current page unless the transition is not
1658                 //                     animated and the animation end callback below doesn&#x27;t run
1659                 if (i == mCurrentPage || !animated) {
1660                     finalAlpha = 1f;
1661                     finalAlphaMultiplierValue = 0f;
1662                 } else {
1663                     initialAlpha = 0f;
1664                     finalAlpha = 0f;
1665                 }
1666             }
1667 
1668             // Update the rotation of the screen (don&#x27;t apply rotation on Phone UI)
1669             if (LauncherApplication.isScreenLarge()) {
1670                 if (i &lt; mCurrentPage) {
1671                     rotation = WORKSPACE_ROTATION;
1672                 } else if (i &gt; mCurrentPage) {
1673                     rotation = -WORKSPACE_ROTATION;
1674                 }
1675             }
1676 
1677             // If the screen is not xlarge, then don&#x27;t rotate the CellLayouts
1678             // NOTE: If we don&#x27;t update the side pages alpha, then we should not hide the side
1679             //       pages. see unshrink().
1680             if (LauncherApplication.isScreenLarge()) {
1681                 translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1682             }
1683 
1684             mOldAlphas[i] = initialAlpha;
1685             mNewAlphas[i] = finalAlpha;
1686             if (animated) {
1687                 mOldTranslationXs[i] = cl.getTranslationX();
1688                 mOldTranslationYs[i] = cl.getTranslationY();
1689                 mOldScaleXs[i] = cl.getScaleX();
1690                 mOldScaleYs[i] = cl.getScaleY();
1691                 mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
1692                 mOldBackgroundAlphaMultipliers[i] = cl.getBackgroundAlphaMultiplier();
1693                 mOldRotationYs[i] = cl.getRotationY();
1694 
1695                 mNewTranslationXs[i] = translationX;
1696                 mNewTranslationYs[i] = translationY;
1697                 mNewScaleXs[i] = finalScaleFactor;
1698                 mNewScaleYs[i] = finalScaleFactor;
1699                 mNewBackgroundAlphas[i] = finalBackgroundAlpha;
1700                 mNewBackgroundAlphaMultipliers[i] = finalAlphaMultiplierValue;
1701                 mNewRotationYs[i] = rotation;
1702             } else {
1703                 cl.setTranslationX(translationX);
1704                 cl.setTranslationY(translationY);
1705                 cl.setScaleX(finalScaleFactor);
1706                 cl.setScaleY(finalScaleFactor);
1707                 cl.setBackgroundAlpha(finalBackgroundAlpha);
1708                 cl.setBackgroundAlphaMultiplier(finalAlphaMultiplierValue);
1709                 cl.setAlpha(finalAlpha);
1710                 cl.setRotationY(rotation);
1711             }
1712         }
1713 
1714         if (animated) {
1715             for (int index = 0; index &lt; getChildCount(); index++) {
1716                 final int i = index;
1717                 final CellLayout cl = (CellLayout) getChildAt(i);
1718                 if (mOldAlphas[i] == 0 &amp;&amp; mNewAlphas[i] == 0) {
1719                     cl.setTranslationX(mNewTranslationXs[i]);
1720                     cl.setTranslationY(mNewTranslationYs[i]);
1721                     cl.setScaleX(mNewScaleXs[i]);
1722                     cl.setScaleY(mNewScaleYs[i]);
1723                     cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);
1724                     cl.setBackgroundAlphaMultiplier(mNewBackgroundAlphaMultipliers[i]);
1725                     cl.setAlpha(mNewAlphas[i]);
1726                     cl.setRotationY(mNewRotationYs[i]);
1727                 } else {
1728                     LauncherViewPropertyAnimator a = new LauncherViewPropertyAnimator(cl);
1729                     a.translationX(mNewTranslationXs[i])
1730                         .translationY(mNewTranslationYs[i])
1731                         .scaleX(mNewScaleXs[i])
1732                         .scaleY(mNewScaleYs[i])
1733                         .setDuration(duration)
1734                         .setInterpolator(mZoomInInterpolator);
1735                     if (mOldAlphas[i] != mNewAlphas[i]) {
1736                         a.alpha(mNewAlphas[i]);
1737                     }
1738                     anim.play(a);
1739                     if (mOldRotationYs[i] != 0 || mNewRotationYs[i] != 0) {
1740                         ValueAnimator rotate = ValueAnimator.ofFloat(0f, 1f).setDuration(duration);
1741                         rotate.setInterpolator(new DecelerateInterpolator(2.0f));
1742                         rotate.addUpdateListener(new LauncherAnimatorUpdateListener() {
1743                                 public void onAnimationUpdate(float a, float b) {
1744                                     cl.setRotationY(a * mOldRotationYs[i] + b * mNewRotationYs[i]);
1745                                 }
1746                             });
1747                         anim.play(rotate);
1748                     }
1749                     if (mOldBackgroundAlphas[i] != 0 ||
1750                         mNewBackgroundAlphas[i] != 0 ||
1751                         mOldBackgroundAlphaMultipliers[i] != 0 ||
1752                         mNewBackgroundAlphaMultipliers[i] != 0) {
1753                         ValueAnimator bgAnim = ValueAnimator.ofFloat(0f, 1f).setDuration(duration);
1754                         bgAnim.setInterpolator(mZoomInInterpolator);
1755                         bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
1756                                 public void onAnimationUpdate(float a, float b) {
1757                                     cl.setBackgroundAlpha(
1758                                             a * mOldBackgroundAlphas[i] +
1759                                             b * mNewBackgroundAlphas[i]);
1760                                     cl.setBackgroundAlphaMultiplier(
1761                                             a * mOldBackgroundAlphaMultipliers[i] +
1762                                             b * mNewBackgroundAlphaMultipliers[i]);
1763                                 }
1764                             });
1765                         anim.play(bgAnim);
1766                     }
1767                 }
1768             }
1769             anim.setStartDelay(delay);
1770         }
1771 
1772         if (stateIsSpringLoaded) {
1773             // Right now we&#x27;re covered by Apps Customize
1774             // Show the background gradient immediately, so the gradient will
1775             // be showing once AppsCustomize disappears
1776             animateBackgroundGradient(getResources().getInteger(
1777                     R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, false);
1778         } else {
1779             // Fade the background gradient away
1780             animateBackgroundGradient(0f, true);
1781         }
1782         return anim;
1783     }
1784 
1785     @Override
1786     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
1787         mIsSwitchingState = true;
1788     }
1789 
1790     @Override
1791     public void onLauncherTransitionStep(Launcher l, float t) {
1792         mTransitionProgress = t;
1793     }
1794 
1795     @Override
1796     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
1797         mIsSwitchingState = false;
1798         mWallpaperOffset.setOverrideHorizontalCatchupConstant(false);
1799         updateChildrenLayersEnabled();
1800         // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure
1801         // ensure that only the current page is visible during (and subsequently, after) the
1802         // transition animation.  If fade adjacent pages is disabled, then re-enable the page
1803         // visibility after the transition animation.
1804         if (!mFadeInAdjacentScreens) {
1805             for (int i = 0; i &lt; getChildCount(); i++) {
1806                 final CellLayout cl = (CellLayout) getChildAt(i);
1807                 cl.setAlpha(1f);
1808             }
1809         }
1810     }
1811 
1812     @Override
1813     public View getContent() {
1814         return this;
1815     }
1816 
1817     /**
1818      * Draw the View v into the given Canvas.
1819      *
1820      * @param v the view to draw
1821      * @param destCanvas the canvas to draw on
1822      * @param padding the horizontal and vertical padding to use when drawing
1823      */
1824     private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
1825         final Rect clipRect = mTempRect;
1826         v.getDrawingRect(clipRect);
1827 
1828         boolean textVisible = false;
1829 
1830         destCanvas.save();
1831         if (v instanceof TextView &amp;&amp; pruneToDrawable) {
1832             Drawable d = ((TextView) v).getCompoundDrawables()[1];
1833             clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
1834             destCanvas.translate(padding / 2, padding / 2);
1835             d.draw(destCanvas);
1836         } else {
1837             if (v instanceof FolderIcon) {
1838                 // For FolderIcons the text can bleed into the icon area, and so we need to
1839                 // hide the text completely (which can&#x27;t be achieved by clipping).
1840                 if (((FolderIcon) v).getTextVisible()) {
1841                     ((FolderIcon) v).setTextVisible(false);
1842                     textVisible = true;
1843                 }
1844             } else if (v instanceof BubbleTextView) {
1845                 final BubbleTextView tv = (BubbleTextView) v;
1846                 clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
1847                         tv.getLayout().getLineTop(0);
1848             } else if (v instanceof TextView) {
1849                 final TextView tv = (TextView) v;
1850                 clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
1851                         tv.getLayout().getLineTop(0);
1852             }
1853             destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
1854             destCanvas.clipRect(clipRect, Op.REPLACE);
1855             v.draw(destCanvas);
1856 
1857             // Restore text visibility of FolderIcon if necessary
1858             if (textVisible) {
1859                 ((FolderIcon) v).setTextVisible(true);
1860             }
1861         }
1862         destCanvas.restore();
1863     }
1864 
1865     /**
1866      * Returns a new bitmap to show when the given View is being dragged around.
1867      * Responsibility for the bitmap is transferred to the caller.
1868      */
1869     public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
1870         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1871         Bitmap b;
1872 
1873         if (v instanceof TextView) {
1874             Drawable d = ((TextView) v).getCompoundDrawables()[1];
1875             b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
1876                     d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
1877         } else {
1878             b = Bitmap.createBitmap(
1879                     v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
1880         }
1881 
1882         canvas.setBitmap(b);
1883         drawDragView(v, canvas, padding, true);
1884         canvas.setBitmap(null);
1885 
1886         return b;
1887     }
1888 
1889     /**
1890      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
1891      * Responsibility for the bitmap is transferred to the caller.
1892      */
1893     private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
1894         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1895         final Bitmap b = Bitmap.createBitmap(
1896                 v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
1897 
1898         canvas.setBitmap(b);
1899         drawDragView(v, canvas, padding, true);
1900         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
1901         canvas.setBitmap(null);
1902         return b;
1903     }
1904 
1905     /**
1906      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
1907      * Responsibility for the bitmap is transferred to the caller.
1908      */
1909     private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
1910             Paint alphaClipPaint) {
1911         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1912         final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
1913         canvas.setBitmap(b);
1914 
1915         Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
1916         float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
1917                 (h - padding) / (float) orig.getHeight());
1918         int scaledWidth = (int) (scaleFactor * orig.getWidth());
1919         int scaledHeight = (int) (scaleFactor * orig.getHeight());
1920         Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
1921 
1922         // center the image
1923         dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
1924 
1925         canvas.drawBitmap(orig, src, dst, null);
1926         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
1927                 alphaClipPaint);
1928         canvas.setBitmap(null);
1929 
1930         return b;
1931     }
1932 
1933     /**
1934      * Creates a drag outline to represent a drop (that we don&#x27;t have the actual information for
1935      * yet).  May be changed in the future to alter the drop outline slightly depending on the
1936      * clip description mime data.
1937      */
1938     private Bitmap createExternalDragOutline(Canvas canvas, int padding) {
1939         Resources r = getResources();
1940         final int outlineColor = r.getColor(android.R.color.holo_blue_light);
1941         final int iconWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
1942         final int iconHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
1943         final int rectRadius = r.getDimensionPixelSize(R.dimen.external_drop_icon_rect_radius);
1944         final int inset = (int) (Math.min(iconWidth, iconHeight) * 0.2f);
1945         final Bitmap b = Bitmap.createBitmap(
1946                 iconWidth + padding, iconHeight + padding, Bitmap.Config.ARGB_8888);
1947 
1948         canvas.setBitmap(b);
1949         canvas.drawRoundRect(new RectF(inset, inset, iconWidth - inset, iconHeight - inset),
1950                 rectRadius, rectRadius, mExternalDragOutlinePaint);
1951         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
1952         canvas.setBitmap(null);
1953         return b;
1954     }
1955 
1956     void startDrag(CellLayout.CellInfo cellInfo) {
1957         View child = cellInfo.cell;
1958 
1959         // Make sure the drag was started by a long press as opposed to a long click.
1960         if (!child.isInTouchMode()) {
1961             return;
1962         }
1963 
1964         mDragInfo = cellInfo;
1965         child.setVisibility(INVISIBLE);
1966 
1967         child.clearFocus();
1968         child.setPressed(false);
1969 
1970         final Canvas canvas = new Canvas();
1971 
1972         // The outline is used to visualize where the item will land if dropped
1973         mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);
1974         beginDragShared(child, this);
1975     }
1976 
1977     public void beginDragShared(View child, DragSource source) {
1978         Resources r = getResources();
1979 
1980         // The drag bitmap follows the touch point around on the screen
1981         final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);
1982 
1983         final int bmpWidth = b.getWidth();
1984 
1985         mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
1986         final int dragLayerX = (int) mTempXY[0] + (child.getWidth() - bmpWidth) / 2;
1987         int dragLayerY = mTempXY[1] - DRAG_BITMAP_PADDING / 2;
1988 
1989         Point dragVisualizeOffset = null;
1990         Rect dragRect = null;
1991         if (child instanceof BubbleTextView || child instanceof PagedViewIcon) {
1992             int iconSize = r.getDimensionPixelSize(R.dimen.app_icon_size);
1993             int iconPaddingTop = r.getDimensionPixelSize(R.dimen.app_icon_padding_top);
1994             int top = child.getPaddingTop();
1995             int left = (bmpWidth - iconSize) / 2;
1996             int right = left + iconSize;
1997             int bottom = top + iconSize;
1998             dragLayerY += top;
1999             // Note: The drag region is used to calculate drag layer offsets, but the
2000             // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
2001             dragVisualizeOffset = new Point(-DRAG_BITMAP_PADDING / 2,
2002                     iconPaddingTop - DRAG_BITMAP_PADDING / 2);
2003             dragRect = new Rect(left, top, right, bottom);
2004         } else if (child instanceof FolderIcon) {
2005             int previewSize = r.getDimensionPixelSize(R.dimen.folder_preview_size);
2006             dragRect = new Rect(0, 0, child.getWidth(), previewSize);
2007         }
2008 
2009         // Clear the pressed state if necessary
2010         if (child instanceof BubbleTextView) {
2011             BubbleTextView icon = (BubbleTextView) child;
2012             icon.clearPressedOrFocusedBackground();
2013         }
2014 
2015         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),
2016                 DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, 1f);
2017         b.recycle();
2018 
2019         // Show the scrolling indicator when you pick up an item
2020         showScrollingIndicator(false);
2021     }
2022 
2023     void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, int screen,
2024             int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
2025         View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
2026 
2027         final int[] cellXY = new int[2];
2028         target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
2029         addInScreen(view, container, screen, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
2030         LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen, cellXY[0],
2031                 cellXY[1]);
2032     }
2033 
2034     public boolean transitionStateShouldAllowDrop() {
2035         return ((!isSwitchingState() || mTransitionProgress &gt; 0.5f) &amp;&amp; mState != State.SMALL);
2036     }
2037 
2038     /**
2039      * {@inheritDoc}
2040      */
2041     public boolean acceptDrop(DragObject d) {
2042         // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
2043         if (d.dragSource != this) {
2044             // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
2045             if (mDragTargetLayout == null) {
2046                 return false;
2047             }
2048             if (!transitionStateShouldAllowDrop()) return false;
2049 
2050             mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2051                     d.dragView, mDragViewVisualCenter);
2052 
2053             // We want the point to be mapped to the dragTarget.
2054             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2055                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2056             } else {
2057                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2058             }
2059 
2060             int spanX = 1;
2061             int spanY = 1;
2062             View ignoreView = null;
2063             if (mDragInfo != null) {
2064                 final CellLayout.CellInfo dragCellInfo = mDragInfo;
2065                 spanX = dragCellInfo.spanX;
2066                 spanY = dragCellInfo.spanY;
2067                 ignoreView = dragCellInfo.cell;
2068             } else {
2069                 final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2070                 spanX = dragInfo.spanX;
2071                 spanY = dragInfo.spanY;
2072             }
2073 
2074             int minSpanX = spanX;
2075             int minSpanY = spanY;
2076             if (d.dragInfo instanceof PendingAddWidgetInfo) {
2077                 minSpanX = ((PendingAddWidgetInfo) d.dragInfo).minSpanX;
2078                 minSpanY = ((PendingAddWidgetInfo) d.dragInfo).minSpanY;
2079             }
2080             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2081                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragTargetLayout,
2082                     mTargetCell);
2083             if (willCreateUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout, mTargetCell, true)) {
2084                 return true;
2085             }
2086             if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout,
2087                     mTargetCell)) {
2088                 return true;
2089             }
2090 
2091             // Don&#x27;t accept the drop if there&#x27;s no room for the item
2092             if (!mDragTargetLayout.findCellForSpanIgnoring(null, minSpanX, minSpanY, ignoreView)) {
2093                 // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2094                 // is full
2095                 if (mTargetCell != null &amp;&amp; mLauncher.isHotseatLayout(mDragTargetLayout)) {
2096                     Hotseat hotseat = mLauncher.getHotseat();
2097                     if (hotseat.isAllAppsButtonRank(
2098                             hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2099                         return false;
2100                     }
2101                 }
2102 
2103                 mLauncher.showOutOfSpaceMessage();
2104                 return false;
2105             }
2106         }
2107         return true;
2108     }
2109 
2110     boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell,
2111             boolean considerTimeout) {
2112         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2113 
2114         boolean hasntMoved = false;
2115         if (mDragInfo != null) {
2116             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2117             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2118                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2119         }
2120 
2121         if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2122             return false;
2123         }
2124 
2125         boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2126         boolean willBecomeShortcut =
2127                 (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2128                 info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2129 
2130         return (aboveShortcut &amp;&amp; willBecomeShortcut);
2131     }
2132 
2133     boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell) {
2134         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2135         if (dropOverView instanceof FolderIcon) {
2136             FolderIcon fi = (FolderIcon) dropOverView;
2137             if (fi.acceptDrop(dragInfo)) {
2138                 return true;
2139             }
2140         }
2141         return false;
2142     }
2143 
2144     boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2145             int[] targetCell, boolean external, DragView dragView, Runnable postAnimationRunnable) {
2146         View v = target.getChildAt(targetCell[0], targetCell[1]);
2147         boolean hasntMoved = false;
2148         if (mDragInfo != null) {
2149             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2150             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2151                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2152         }
2153 
2154         if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2155         mCreateUserFolderOnDrop = false;
2156         final int screen = (targetCell == null) ? mDragInfo.screen : indexOfChild(target);
2157 
2158         boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2159         boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2160 
2161         if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2162             ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2163             ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2164             // if the drag started here, we need to remove it from the workspace
2165             if (!external) {
2166                 getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2167             }
2168 
2169             Rect folderLocation = new Rect();
2170             float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2171             target.removeView(v);
2172 
2173             FolderIcon fi =
2174                 mLauncher.addFolder(target, container, screen, targetCell[0], targetCell[1]);
2175             destInfo.cellX = -1;
2176             destInfo.cellY = -1;
2177             sourceInfo.cellX = -1;
2178             sourceInfo.cellY = -1;
2179 
2180             // If the dragView is null, we can&#x27;t animate
2181             boolean animate = dragView != null;
2182             if (animate) {
2183                 fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2184                         postAnimationRunnable);
2185             } else {
2186                 fi.addItem(destInfo);
2187                 fi.addItem(sourceInfo);
2188             }
2189             return true;
2190         }
2191         return false;
2192     }
2193 
2194     boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2195             DragObject d, boolean external) {
2196         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2197         if (dropOverView instanceof FolderIcon) {
2198             FolderIcon fi = (FolderIcon) dropOverView;
2199             if (fi.acceptDrop(d.dragInfo)) {
2200                 fi.onDrop(d);
2201 
2202                 // if the drag started here, we need to remove it from the workspace
2203                 if (!external) {
2204                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2205                 }
2206                 return true;
2207             }
2208         }
2209         return false;
2210     }
2211 
2212     public void onDrop(final DragObject d) {
2213         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView,
2214                 mDragViewVisualCenter);
2215 
2216         // We want the point to be mapped to the dragTarget.
2217         if (mDragTargetLayout != null) {
2218             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2219                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2220             } else {
2221                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2222             }
2223         }
2224 
2225         CellLayout dropTargetLayout = mDragTargetLayout;
2226 
2227         int snapScreen = -1;
2228         boolean resizeOnDrop = false;
2229         if (d.dragSource != this) {
2230             final int[] touchXY = new int[] { (int) mDragViewVisualCenter[0],
2231                     (int) mDragViewVisualCenter[1] };
2232             onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2233         } else if (mDragInfo != null) {
2234             final View cell = mDragInfo.cell;
2235 
2236             Runnable resizeRunnable = null;
2237             if (dropTargetLayout != null) {
2238                 // Move internally
2239                 boolean hasMovedLayouts = (getParentCellLayoutForView(cell) != dropTargetLayout);
2240                 boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2241                 long container = hasMovedIntoHotseat ?
2242                         LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2243                         LauncherSettings.Favorites.CONTAINER_DESKTOP;
2244                 int screen = (mTargetCell[0] &lt; 0) ?
2245                         mDragInfo.screen : indexOfChild(dropTargetLayout);
2246                 int spanX = mDragInfo != null ? mDragInfo.spanX : 1;
2247                 int spanY = mDragInfo != null ? mDragInfo.spanY : 1;
2248                 // First we find the cell nearest to point at which the item is
2249                 // dropped, without any consideration to whether there is an item there.
2250                 mTargetCell = findNearestArea((int) mDragViewVisualCenter[0], (int)
2251                         mDragViewVisualCenter[1], spanX, spanY, dropTargetLayout, mTargetCell);
2252                 // If the item being dropped is a shortcut and the nearest drop
2253                 // cell also contains a shortcut, then create a folder with the two shortcuts.
2254                 if (!mInScrollArea &amp;&amp; createUserFolderIfNecessary(cell, container,
2255                         dropTargetLayout, mTargetCell, false, d.dragView, null)) {
2256                     return;
2257                 }
2258 
2259                 if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell, d, false)) {
2260                     return;
2261                 }
2262 
2263                 // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2264                 // we need to find the nearest cell location that is vacant
2265                 ItemInfo item = (ItemInfo) d.dragInfo;
2266                 int minSpanX = item.spanX;
2267                 int minSpanY = item.spanY;
2268                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2269                     minSpanX = item.minSpanX;
2270                     minSpanY = item.minSpanY;
2271                 }
2272                 int[] resultSpan = new int[2];
2273                 mTargetCell = findNearestVacantArea((int) mDragViewVisualCenter[0],
2274                         (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragInfo.spanX,
2275                         mDragInfo.spanY, cell, dropTargetLayout, mTargetCell, resultSpan);
2276                 boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2277                 if (foundCell &amp;&amp; (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY)) {
2278                     resizeOnDrop = true;
2279                     item.spanX = resultSpan[0];
2280                     item.spanY = resultSpan[1];
2281                 }
2282 
2283                 if (mCurrentPage != screen &amp;&amp; !hasMovedIntoHotseat) {
2284                     snapScreen = screen;
2285                     snapToPage(screen);
2286                 }
2287 
2288                 if (foundCell) {
2289                     final ItemInfo info = (ItemInfo) cell.getTag();
2290                     if (hasMovedLayouts) {
2291                         // Reparent the view
2292                         getParentCellLayoutForView(cell).removeView(cell);
2293                         addInScreen(cell, container, screen, mTargetCell[0], mTargetCell[1],
2294                                 info.spanX, info.spanY);
2295                     }
2296 
2297                     // update the item&#x27;s position after drop
2298                     CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2299                     dropTargetLayout.onMove(cell, mTargetCell[0], mTargetCell[1],
2300                             item.spanX, item.spanY);
2301                     lp.cellX = mTargetCell[0];
2302                     lp.cellY = mTargetCell[1];
2303                     lp.cellHSpan = item.spanX;
2304                     lp.cellVSpan = item.spanY;
2305                     cell.setId(LauncherModel.getCellLayoutChildId(container, mDragInfo.screen,
2306                             mTargetCell[0], mTargetCell[1], mDragInfo.spanX, mDragInfo.spanY));
2307 
2308                     if (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
2309                             cell instanceof LauncherAppWidgetHostView) {
2310                         final CellLayout cellLayout = dropTargetLayout;
2311                         // We post this call so that the widget has a chance to be placed
2312                         // in its final location
2313 
2314                         final LauncherAppWidgetHostView hostView = (LauncherAppWidgetHostView) cell;
2315                         AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2316                         if (pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
2317                             final Runnable addResizeFrame = new Runnable() {
2318                                 public void run() {
2319                                     DragLayer dragLayer = mLauncher.getDragLayer();
2320                                     dragLayer.addResizeFrame(info, hostView, cellLayout);
2321                                 }
2322                             };
2323                             resizeRunnable = (new Runnable() {
2324                                 public void run() {
2325                                     if (!isPageMoving()) {
2326                                         addResizeFrame.run();
2327                                     } else {
2328                                         mDelayedResizeRunnable = addResizeFrame;
2329                                     }
2330                                 }
2331                             });
2332                         }
2333                     }
2334 
2335                     LauncherModel.moveItemInDatabase(mLauncher, info, container, screen, lp.cellX,
2336                             lp.cellY);
2337                 } else {
2338                     // If we can&#x27;t find a drop location, we return the item to its original position
2339                     CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2340                     mTargetCell[0] = lp.cellX;
2341                     mTargetCell[1] = lp.cellY;
2342                 }
2343             }
2344 
2345             final CellLayout parent = (CellLayout) cell.getParent().getParent();
2346             final Runnable finalResizeRunnable = resizeRunnable;
2347             // Prepare it to be animated into its new position
2348             // This must be called after the view has been re-parented
2349             final Runnable onCompleteRunnable = new Runnable() {
2350                 @Override
2351                 public void run() {
2352                     mAnimatingViewIntoPlace = false;
2353                     updateChildrenLayersEnabled();
2354                     if (finalResizeRunnable != null) {
2355                         finalResizeRunnable.run();
2356                     }
2357                 }
2358             };
2359             mAnimatingViewIntoPlace = true;
2360             if (d.dragView.hasDrawn()) {
2361                 final ItemInfo info = (ItemInfo) cell.getTag();
2362                 if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) {
2363                     int animationType = resizeOnDrop ? ANIMATE_INTO_POSITION_AND_RESIZE :
2364                             ANIMATE_INTO_POSITION_AND_DISAPPEAR;
2365                     animateWidgetDrop(info, parent, d.dragView,
2366                             onCompleteRunnable, animationType, cell, false);
2367                 } else {
2368                     mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell,
2369                             onCompleteRunnable);
2370                 }
2371             } else {
2372                 d.deferDragViewCleanupPostAnimation = false;
2373                 cell.setVisibility(VISIBLE);
2374             }
2375             parent.onDropChild(cell);
2376         }
2377     }
2378 
2379     public void setFinalScrollForPageChange(int screen) {
2380         if (screen &gt;= 0) {
2381             mSavedScrollX = getScrollX();
2382             CellLayout cl = (CellLayout) getChildAt(screen);
2383             mSavedTranslationX = cl.getTranslationX();
2384             mSavedRotationY = cl.getRotationY();
2385             final int newX = getChildOffset(screen) - getRelativeChildOffset(screen);
2386             setScrollX(newX);
2387             cl.setTranslationX(0f);
2388             cl.setRotationY(0f);
2389         }
2390     }
2391 
2392     public void resetFinalScrollForPageChange(int screen) {
2393         if (screen &gt;= 0) {
2394             CellLayout cl = (CellLayout) getChildAt(screen);
2395             setScrollX(mSavedScrollX);
2396             cl.setTranslationX(mSavedTranslationX);
2397             cl.setRotationY(mSavedRotationY);
2398         }
2399     }
2400 
2401     public void getViewLocationRelativeToSelf(View v, int[] location) {
2402         getLocationInWindow(location);
2403         int x = location[0];
2404         int y = location[1];
2405 
2406         v.getLocationInWindow(location);
2407         int vX = location[0];
2408         int vY = location[1];
2409 
2410         location[0] = vX - x;
2411         location[1] = vY - y;
2412     }
2413 
2414     public void onDragEnter(DragObject d) {
2415         mDragHasEnteredWorkspace = true;
2416         if (mDragTargetLayout != null) {
2417             mDragTargetLayout.setIsDragOverlapping(false);
2418             mDragTargetLayout.onDragExit();
2419         }
2420         mDragTargetLayout = getCurrentDropLayout();
2421         mDragTargetLayout.setIsDragOverlapping(true);
2422         mDragTargetLayout.onDragEnter();
2423 
2424         // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
2425         // don&#x27;t need to show the outlines
2426         if (LauncherApplication.isScreenLarge()) {
2427             showOutlines();
2428         }
2429     }
2430 
2431     private void doDragExit(DragObject d) {
2432         // Clean up folders
2433         cleanupFolderCreation(d);
2434 
2435         // Reset the scroll area and previous drag target
2436         onResetScrollArea();
2437 
2438         if (mDragTargetLayout != null) {
2439             mDragTargetLayout.setIsDragOverlapping(false);
2440             mDragTargetLayout.onDragExit();
2441         }
2442         mLastDragOverView = null;
2443         mSpringLoadedDragController.cancel();
2444 
2445         if (!mIsPageMoving) {
2446             hideOutlines();
2447         }
2448     }
2449 
2450     public void onDragExit(DragObject d) {
2451         mDragHasEnteredWorkspace = false;
2452         doDragExit(d);
2453     }
2454 
2455     public DropTarget getDropTargetDelegate(DragObject d) {
2456         return null;
2457     }
2458 
2459     /**
2460      * Tests to see if the drop will be accepted by Launcher, and if so, includes additional data
2461      * in the returned structure related to the widgets that match the drop (or a null list if it is
2462      * a shortcut drop).  If the drop is not accepted then a null structure is returned.
2463      */
2464     private Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; validateDrag(DragEvent event) {
2465         final LauncherModel model = mLauncher.getModel();
2466         final ClipDescription desc = event.getClipDescription();
2467         final int mimeTypeCount = desc.getMimeTypeCount();
2468         for (int i = 0; i &lt; mimeTypeCount; ++i) {
2469             final String mimeType = desc.getMimeType(i);
2470             if (mimeType.equals(InstallShortcutReceiver.SHORTCUT_MIMETYPE)) {
2471                 return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, null);
2472             } else {
2473                 final List&lt;WidgetMimeTypeHandlerData&gt; widgets =
2474                     model.resolveWidgetsForMimeType(mContext, mimeType);
2475                 if (widgets.size() &gt; 0) {
2476                     return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, widgets);
2477                 }
2478             }
2479         }
2480         return null;
2481     }
2482 
2483     /**
2484      * Global drag and drop handler
2485      */
2486     @Override
2487     public boolean onDragEvent(DragEvent event) {
2488         final ClipDescription desc = event.getClipDescription();
2489         final CellLayout layout = (CellLayout) getChildAt(mCurrentPage);
2490         final int[] pos = new int[2];
2491         layout.getLocationOnScreen(pos);
2492         // We need to offset the drag coordinates to layout coordinate space
2493         final int x = (int) event.getX() - pos[0];
2494         final int y = (int) event.getY() - pos[1];
2495 
2496         switch (event.getAction()) {
2497         case DragEvent.ACTION_DRAG_STARTED: {
2498             // Validate this drag
2499             Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2500             if (test != null) {
2501                 boolean isShortcut = (test.second == null);
2502                 if (isShortcut) {
2503                     // Check if we have enough space on this screen to add a new shortcut
2504                     if (!layout.findCellForSpan(pos, 1, 1)) {
2505                         mLauncher.showOutOfSpaceMessage();
2506                         return false;
2507                     }
2508                 }
2509             } else {
2510                 // Show error message if we couldn&#x27;t accept any of the items
2511                 Toast.makeText(mContext, mContext.getString(R.string.external_drop_widget_error),
2512                         Toast.LENGTH_SHORT).show();
2513                 return false;
2514             }
2515 
2516             // Create the drag outline
2517             // We need to add extra padding to the bitmap to make room for the glow effect
2518             final Canvas canvas = new Canvas();
2519             mDragOutline = createExternalDragOutline(canvas, DRAG_BITMAP_PADDING);
2520 
2521             // Show the current page outlines to indicate that we can accept this drop
2522             showOutlines();
2523             layout.onDragEnter();
2524             layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, 1, 1, null, null);
2525 
2526             return true;
2527         }
2528         case DragEvent.ACTION_DRAG_LOCATION:
2529             // Visualize the drop location
2530             layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, 1, 1, null, null);
2531             return true;
2532         case DragEvent.ACTION_DROP: {
2533             // Try and add any shortcuts
2534             final LauncherModel model = mLauncher.getModel();
2535             final ClipData data = event.getClipData();
2536 
2537             // We assume that the mime types are ordered in descending importance of
2538             // representation. So we enumerate the list of mime types and alert the
2539             // user if any widgets can handle the drop.  Only the most preferred
2540             // representation will be handled.
2541             pos[0] = x;
2542             pos[1] = y;
2543             Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2544             if (test != null) {
2545                 final int index = test.first;
2546                 final List&lt;WidgetMimeTypeHandlerData&gt; widgets = test.second;
2547                 final boolean isShortcut = (widgets == null);
2548                 final String mimeType = desc.getMimeType(index);
2549                 if (isShortcut) {
2550                     final Intent intent = data.getItemAt(index).getIntent();
2551                     Object info = model.infoFromShortcutIntent(mContext, intent, data.getIcon());
2552                     if (info != null) {
2553                         onDropExternal(new int[] { x, y }, info, layout, false);
2554                     }
2555                 } else {
2556                     if (widgets.size() == 1) {
2557                         // If there is only one item, then go ahead and add and configure
2558                         // that widget
2559                         final AppWidgetProviderInfo widgetInfo = widgets.get(0).widgetInfo;
2560                         final PendingAddWidgetInfo createInfo =
2561                                 new PendingAddWidgetInfo(widgetInfo, mimeType, data);
2562                         mLauncher.addAppWidgetFromDrop(createInfo,
2563                                 LauncherSettings.Favorites.CONTAINER_DESKTOP, mCurrentPage,
2564                                 null, null, pos);
2565                     } else {
2566                         // Show the widget picker dialog if there is more than one widget
2567                         // that can handle this data type
2568                         final InstallWidgetReceiver.WidgetListAdapter adapter =
2569                             new InstallWidgetReceiver.WidgetListAdapter(mLauncher, mimeType,
2570                                     data, widgets, layout, mCurrentPage, pos);
2571                         final AlertDialog.Builder builder =
2572                             new AlertDialog.Builder(mContext);
2573                         builder.setAdapter(adapter, adapter);
2574                         builder.setCancelable(true);
2575                         builder.setTitle(mContext.getString(
2576                                 R.string.external_drop_widget_pick_title));
2577                         builder.setIcon(R.drawable.ic_no_applications);
2578                         builder.show();
2579                     }
2580                 }
2581             }
2582             return true;
2583         }
2584         case DragEvent.ACTION_DRAG_ENDED:
2585             // Hide the page outlines after the drop
2586             layout.onDragExit();
2587             hideOutlines();
2588             return true;
2589         }
2590         return super.onDragEvent(event);
2591     }
2592 
2593     /*
2594     *
2595     * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2596     * coordinate space. The argument xy is modified with the return result.
2597     *
2598     */
2599    void mapPointFromSelfToChild(View v, float[] xy) {
2600        mapPointFromSelfToChild(v, xy, null);
2601    }
2602 
2603    /*
2604     *
2605     * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2606     * coordinate space. The argument xy is modified with the return result.
2607     *
2608     * if cachedInverseMatrix is not null, this method will just use that matrix instead of
2609     * computing it itself; we use this to avoid redundant matrix inversions in
2610     * findMatchingPageForDragOver
2611     *
2612     */
2613    void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
2614        if (cachedInverseMatrix == null) {
2615            v.getMatrix().invert(mTempInverseMatrix);
2616            cachedInverseMatrix = mTempInverseMatrix;
2617        }
2618        int scrollX = mScrollX;
2619        if (mNextPage != INVALID_PAGE) {
2620            scrollX = mScroller.getFinalX();
2621        }
2622        xy[0] = xy[0] + scrollX - v.getLeft();
2623        xy[1] = xy[1] + mScrollY - v.getTop();
2624        cachedInverseMatrix.mapPoints(xy);
2625    }
2626 
2627    /*
2628     * Maps a point from the Workspace&#x27;s coordinate system to another sibling view&#x27;s. (Workspace
2629     * covers the full screen)
2630     */
2631    void mapPointFromSelfToSibling(View v, float[] xy) {
2632        xy[0] = xy[0] - v.getLeft();
2633        xy[1] = xy[1] - v.getTop();
2634    }
2635 
2636    /*
2637     *
2638     * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
2639     * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
2640     *
2641     */
2642    void mapPointFromChildToSelf(View v, float[] xy) {
2643        v.getMatrix().mapPoints(xy);
2644        int scrollX = mScrollX;
2645        if (mNextPage != INVALID_PAGE) {
2646            scrollX = mScroller.getFinalX();
2647        }
2648        xy[0] -= (scrollX - v.getLeft());
2649        xy[1] -= (mScrollY - v.getTop());
2650    }
2651 
2652    static private float squaredDistance(float[] point1, float[] point2) {
2653         float distanceX = point1[0] - point2[0];
2654         float distanceY = point2[1] - point2[1];
2655         return distanceX * distanceX + distanceY * distanceY;
2656    }
2657 
2658     /*
2659      *
2660      * Returns true if the passed CellLayout cl overlaps with dragView
2661      *
2662      */
2663     boolean overlaps(CellLayout cl, DragView dragView,
2664             int dragViewX, int dragViewY, Matrix cachedInverseMatrix) {
2665         // Transform the coordinates of the item being dragged to the CellLayout&#x27;s coordinates
2666         final float[] draggedItemTopLeft = mTempDragCoordinates;
2667         draggedItemTopLeft[0] = dragViewX;
2668         draggedItemTopLeft[1] = dragViewY;
2669         final float[] draggedItemBottomRight = mTempDragBottomRightCoordinates;
2670         draggedItemBottomRight[0] = draggedItemTopLeft[0] + dragView.getDragRegionWidth();
2671         draggedItemBottomRight[1] = draggedItemTopLeft[1] + dragView.getDragRegionHeight();
2672 
2673         // Transform the dragged item&#x27;s top left coordinates
2674         // to the CellLayout&#x27;s local coordinates
2675         mapPointFromSelfToChild(cl, draggedItemTopLeft, cachedInverseMatrix);
2676         float overlapRegionLeft = Math.max(0f, draggedItemTopLeft[0]);
2677         float overlapRegionTop = Math.max(0f, draggedItemTopLeft[1]);
2678 
2679         if (overlapRegionLeft &lt;= cl.getWidth() &amp;&amp; overlapRegionTop &gt;= 0) {
2680             // Transform the dragged item&#x27;s bottom right coordinates
2681             // to the CellLayout&#x27;s local coordinates
2682             mapPointFromSelfToChild(cl, draggedItemBottomRight, cachedInverseMatrix);
2683             float overlapRegionRight = Math.min(cl.getWidth(), draggedItemBottomRight[0]);
2684             float overlapRegionBottom = Math.min(cl.getHeight(), draggedItemBottomRight[1]);
2685 
2686             if (overlapRegionRight &gt;= 0 &amp;&amp; overlapRegionBottom &lt;= cl.getHeight()) {
2687                 float overlap = (overlapRegionRight - overlapRegionLeft) *
2688                          (overlapRegionBottom - overlapRegionTop);
2689                 if (overlap &gt; 0) {
2690                     return true;
2691                 }
2692              }
2693         }
2694         return false;
2695     }
2696 
2697     /*
2698      *
2699      * This method returns the CellLayout that is currently being dragged to. In order to drag
2700      * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
2701      * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
2702      *
2703      * Return null if no CellLayout is currently being dragged over
2704      *
2705      */
2706     private CellLayout findMatchingPageForDragOver(
2707             DragView dragView, float originX, float originY, boolean exact) {
2708         // We loop through all the screens (ie CellLayouts) and see which ones overlap
2709         // with the item being dragged and then choose the one that&#x27;s closest to the touch point
2710         final int screenCount = getChildCount();
2711         CellLayout bestMatchingScreen = null;
2712         float smallestDistSoFar = Float.MAX_VALUE;
2713 
2714         for (int i = 0; i &lt; screenCount; i++) {
2715             CellLayout cl = (CellLayout) getChildAt(i);
2716 
2717             final float[] touchXy = {originX, originY};
2718             // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
2719             // If the touch point is within the bounds of the cell layout, we can return immediately
2720             cl.getMatrix().invert(mTempInverseMatrix);
2721             mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
2722 
2723             if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
2724                     touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
2725                 return cl;
2726             }
2727 
2728             if (!exact) {
2729                 // Get the center of the cell layout in screen coordinates
2730                 final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
2731                 cellLayoutCenter[0] = cl.getWidth()/2;
2732                 cellLayoutCenter[1] = cl.getHeight()/2;
2733                 mapPointFromChildToSelf(cl, cellLayoutCenter);
2734 
2735                 touchXy[0] = originX;
2736                 touchXy[1] = originY;
2737 
2738                 // Calculate the distance between the center of the CellLayout
2739                 // and the touch point
2740                 float dist = squaredDistance(touchXy, cellLayoutCenter);
2741 
2742                 if (dist &lt; smallestDistSoFar) {
2743                     smallestDistSoFar = dist;
2744                     bestMatchingScreen = cl;
2745                 }
2746             }
2747         }
2748         return bestMatchingScreen;
2749     }
2750 
2751     // This is used to compute the visual center of the dragView. This point is then
2752     // used to visualize drop locations and determine where to drop an item. The idea is that
2753     // the visual center represents the user&#x27;s interpretation of where the item is, and hence
2754     // is the appropriate point to use when determining drop location.
2755     private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
2756             DragView dragView, float[] recycle) {
2757         float res[];
2758         if (recycle == null) {
2759             res = new float[2];
2760         } else {
2761             res = recycle;
2762         }
2763 
2764         // First off, the drag view has been shifted in a way that is not represented in the
2765         // x and y values or the x/yOffsets. Here we account for that shift.
2766         x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
2767         y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
2768 
2769         // These represent the visual top and left of drag view if a dragRect was provided.
2770         // If a dragRect was not provided, then they correspond to the actual view left and
2771         // top, as the dragRect is in that case taken to be the entire dragView.
2772         // R.dimen.dragViewOffsetY.
2773         int left = x - xOffset;
2774         int top = y - yOffset;
2775 
2776         // In order to find the visual center, we shift by half the dragRect
2777         res[0] = left + dragView.getDragRegion().width() / 2;
2778         res[1] = top + dragView.getDragRegion().height() / 2;
2779 
2780         return res;
2781     }
2782 
2783     private boolean isDragWidget(DragObject d) {
2784         return (d.dragInfo instanceof LauncherAppWidgetInfo ||
2785                 d.dragInfo instanceof PendingAddWidgetInfo);
2786     }
2787     private boolean isExternalDragWidget(DragObject d) {
2788         return d.dragSource != this &amp;&amp; isDragWidget(d);
2789     }
2790 
2791     public void onDragOver(DragObject d) {
2792         // Skip drag over events while we are dragging over side pages
2793         if (mInScrollArea || mIsSwitchingState || mState == State.SMALL) return;
2794 
2795         Rect r = new Rect();
2796         CellLayout layout = null;
2797         ItemInfo item = (ItemInfo) d.dragInfo;
2798 
2799         // Ensure that we have proper spans for the item that we are dropping
2800         if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
2801         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2802             d.dragView, mDragViewVisualCenter);
2803 
2804         // Identify whether we have dragged over a side page
2805         if (isSmall()) {
2806             if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
2807                 mLauncher.getHotseat().getHitRect(r);
2808                 if (r.contains(d.x, d.y)) {
2809                     layout = mLauncher.getHotseat().getLayout();
2810                 }
2811             }
2812             if (layout == null) {
2813                 layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
2814             }
2815             if (layout != mDragTargetLayout) {
2816                 // Cancel all intermediate folder states
2817                 cleanupFolderCreation(d);
2818 
2819                 if (mDragTargetLayout != null) {
2820                     mDragTargetLayout.setIsDragOverlapping(false);
2821                     mDragTargetLayout.onDragExit();
2822                 }
2823                 mDragTargetLayout = layout;
2824                 if (mDragTargetLayout != null) {
2825                     mDragTargetLayout.setIsDragOverlapping(true);
2826                     mDragTargetLayout.onDragEnter();
2827                 } else {
2828                     mLastDragOverView = null;
2829                 }
2830 
2831                 boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
2832                 if (isInSpringLoadedMode) {
2833                     if (mLauncher.isHotseatLayout(layout)) {
2834                         mSpringLoadedDragController.cancel();
2835                     } else {
2836                         mSpringLoadedDragController.setAlarm(mDragTargetLayout);
2837                     }
2838                 }
2839             }
2840         } else {
2841             // Test to see if we are over the hotseat otherwise just use the current page
2842             if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
2843                 mLauncher.getHotseat().getHitRect(r);
2844                 if (r.contains(d.x, d.y)) {
2845                     layout = mLauncher.getHotseat().getLayout();
2846                 }
2847             }
2848             if (layout == null) {
2849                 layout = getCurrentDropLayout();
2850             }
2851             if (layout != mDragTargetLayout) {
2852                 if (mDragTargetLayout != null) {
2853                     mDragTargetLayout.setIsDragOverlapping(false);
2854                     mDragTargetLayout.onDragExit();
2855                 }
2856                 mDragTargetLayout = layout;
2857                 mDragTargetLayout.setIsDragOverlapping(true);
2858                 mDragTargetLayout.onDragEnter();
2859             }
2860         }
2861 
2862         // Handle the drag over
2863         if (mDragTargetLayout != null) {
2864             final View child = (mDragInfo == null) ? null : mDragInfo.cell;
2865 
2866             // We want the point to be mapped to the dragTarget.
2867             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2868                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2869             } else {
2870                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2871             }
2872             ItemInfo info = (ItemInfo) d.dragInfo;
2873 
2874             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2875                     (int) mDragViewVisualCenter[1], 1, 1, mDragTargetLayout, mTargetCell);
2876             final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
2877                     mTargetCell[1]);
2878 
2879             boolean userFolderPending = willCreateUserFolder(info, mDragTargetLayout,
2880                     mTargetCell, false);
2881             boolean isOverFolder = dragOverView instanceof FolderIcon;
2882             if (dragOverView != mLastDragOverView) {
2883                 cancelFolderCreation();
2884                 if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
2885                     ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
2886                 }
2887             }
2888 
2889             if (userFolderPending &amp;&amp; dragOverView != mLastDragOverView) {
2890                 mFolderCreationAlarm.setOnAlarmListener(new
2891                         FolderCreationAlarmListener(mDragTargetLayout, mTargetCell[0], mTargetCell[1]));
2892                 mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
2893             }
2894 
2895             if (dragOverView != mLastDragOverView &amp;&amp; isOverFolder) {
2896                 ((FolderIcon) dragOverView).onDragEnter(d.dragInfo);
2897                 if (mDragTargetLayout != null) {
2898                     mDragTargetLayout.clearDragOutlines();
2899                 }
2900             }
2901             mLastDragOverView = dragOverView;
2902 
2903             if (!mCreateUserFolderOnDrop &amp;&amp; !isOverFolder) {
2904                 int minSpanX = item.spanX;
2905                 int minSpanY = item.spanY;
2906                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2907                     minSpanX = item.minSpanX;
2908                     minSpanY = item.minSpanY;
2909                 }
2910                 mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
2911                         (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
2912                         minSpanX, minSpanY, item.spanX, item.spanY,
2913                         d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());
2914             }
2915         }
2916     }
2917 
2918     private void cleanupFolderCreation(DragObject d) {
2919         if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
2920             mDragFolderRingAnimator.animateToNaturalState();
2921         }
2922         if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
2923             if (d != null) {
2924                 ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
2925             }
2926         }
2927         mFolderCreationAlarm.cancelAlarm();
2928     }
2929 
2930     private void cancelFolderCreation() {
2931         if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
2932             mDragFolderRingAnimator.animateToNaturalState();
2933         }
2934         mCreateUserFolderOnDrop = false;
2935         mFolderCreationAlarm.cancelAlarm();
2936     }
2937 
2938     class FolderCreationAlarmListener implements OnAlarmListener {
2939         CellLayout layout;
2940         int cellX;
2941         int cellY;
2942 
2943         public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
2944             this.layout = layout;
2945             this.cellX = cellX;
2946             this.cellY = cellY;
2947         }
2948 
2949         public void onAlarm(Alarm alarm) {
2950             if (mDragFolderRingAnimator == null) {
2951                 mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
2952             }
2953             mDragFolderRingAnimator.setCell(cellX, cellY);
2954             mDragFolderRingAnimator.setCellLayout(layout);
2955             mDragFolderRingAnimator.animateToAcceptState();
2956             layout.showFolderAccept(mDragFolderRingAnimator);
2957             layout.clearDragOutlines();
2958             mCreateUserFolderOnDrop = true;
2959         }
2960     }
2961 
2962     @Override
2963     public void getHitRect(Rect outRect) {
2964         // We want the workspace to have the whole area of the display (it will find the correct
2965         // cell layout to drop to in the existing drag/drop logic.
2966         outRect.set(0, 0, mDisplayWidth, mDisplayHeight);
2967     }
2968 
2969     /**
2970      * Add the item specified by dragInfo to the given layout.
2971      * @return true if successful
2972      */
2973     public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
2974         if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
2975             onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
2976             return true;
2977         }
2978         mLauncher.showOutOfSpaceMessage();
2979         return false;
2980     }
2981 
2982     private void onDropExternal(int[] touchXY, Object dragInfo,
2983             CellLayout cellLayout, boolean insertAtFirst) {
2984         onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
2985     }
2986 
2987     /**
2988      * Drop an item that didn&#x27;t originate on one of the workspace screens.
2989      * It may have come from Launcher (e.g. from all apps or customize), or it may have
2990      * come from another app altogether.
2991      *
2992      * NOTE: This can also be called when we are outside of a drag event, when we want
2993      * to add an item to one of the workspace screens.
2994      */
2995     private void onDropExternal(final int[] touchXY, final Object dragInfo,
2996             final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
2997         final Runnable exitSpringLoadedRunnable = new Runnable() {
2998             @Override
2999             public void run() {
3000                 mLauncher.exitSpringLoadedDragModeDelayed(true, false, null);
3001             }
3002         };
3003 
3004         ItemInfo info = (ItemInfo) dragInfo;
3005         int spanX = info.spanX;
3006         int spanY = info.spanY;
3007         if (mDragInfo != null) {
3008             spanX = mDragInfo.spanX;
3009             spanY = mDragInfo.spanY;
3010         }
3011 
3012         final long container = mLauncher.isHotseatLayout(cellLayout) ?
3013                 LauncherSettings.Favorites.CONTAINER_HOTSEAT :
3014                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
3015         final int screen = indexOfChild(cellLayout);
3016         if (!mLauncher.isHotseatLayout(cellLayout) &amp;&amp; screen != mCurrentPage
3017                 &amp;&amp; mState != State.SPRING_LOADED) {
3018             snapToPage(screen);
3019         }
3020 
3021         if (info instanceof PendingAddItemInfo) {
3022             final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
3023 
3024             boolean findNearestVacantCell = true;
3025             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
3026                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3027                         cellLayout, mTargetCell);
3028                 if (willCreateUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout, mTargetCell,
3029                         true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
3030                                 mDragTargetLayout, mTargetCell)) {
3031                     findNearestVacantCell = false;
3032                 }
3033             }
3034             final ItemInfo item = (ItemInfo) d.dragInfo;
3035             int minSpanX = item.spanX;
3036             int minSpanY = item.spanY;
3037             if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3038                 minSpanX = item.minSpanX;
3039                 minSpanY = item.minSpanY;
3040             }
3041             if (findNearestVacantCell) {
3042                 int[] resultSpan = new int[2];
3043                 mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], minSpanX, minSpanY,
3044                         spanX, spanY, null, cellLayout, mTargetCell, resultSpan);
3045                 item.spanX = resultSpan[0];
3046                 item.spanY = resultSpan[1];
3047             }
3048 
3049             Runnable onAnimationCompleteRunnable = new Runnable() {
3050                 @Override
3051                 public void run() {
3052                     // When dragging and dropping from customization tray, we deal with creating
3053                     // widgets/shortcuts/folders in a slightly different way
3054                     switch (pendingInfo.itemType) {
3055                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
3056                         int span[] = new int[2];
3057                         span[0] = item.spanX;
3058                         span[1] = item.spanY;
3059                         mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
3060                                 container, screen, mTargetCell, span, null);
3061                         break;
3062                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3063                         mLauncher.processShortcutFromDrop(pendingInfo.componentName,
3064                                 container, screen, mTargetCell, null);
3065                         break;
3066                     default:
3067                         throw new IllegalStateException(&quot;Unknown item type: &quot; +
3068                                 pendingInfo.itemType);
3069                     }
3070                     cellLayout.onDragExit();
3071                 }
3072             };
3073             View finalView = pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET
3074                     ? ((PendingAddWidgetInfo) pendingInfo).boundWidget : null;
3075             int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;
3076             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
3077                     ((PendingAddWidgetInfo) pendingInfo).info.configure != null) {
3078                 animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;
3079             }
3080             animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable,
3081                     animationStyle, finalView, true);
3082         } else {
3083             // This is for other drag/drop cases, like dragging from All Apps
3084             View view = null;
3085 
3086             switch (info.itemType) {
3087             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3088             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3089                 if (info.container == NO_ID &amp;&amp; info instanceof ApplicationInfo) {
3090                     // Came from all apps -- make a copy
3091                     info = new ShortcutInfo((ApplicationInfo) info);
3092                 }
3093                 view = mLauncher.createShortcut(R.layout.application, cellLayout,
3094                         (ShortcutInfo) info);
3095                 break;
3096             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3097                 view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3098                         (FolderInfo) info, mIconCache);
3099                 break;
3100             default:
3101                 throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3102             }
3103 
3104             // First we find the cell nearest to point at which the item is
3105             // dropped, without any consideration to whether there is an item there.
3106             if (touchXY != null) {
3107                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3108                         cellLayout, mTargetCell);
3109                 d.postAnimationRunnable = exitSpringLoadedRunnable;
3110                 if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, true,
3111                         d.dragView, d.postAnimationRunnable)) {
3112                     return;
3113                 }
3114                 if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, d, true)) {
3115                     return;
3116                 }
3117             }
3118 
3119             if (touchXY != null) {
3120                 // when dragging and dropping, just find the closest free spot
3121                 mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, null,
3122                         cellLayout, mTargetCell);
3123             } else {
3124                 cellLayout.findCellForSpan(mTargetCell, 1, 1);
3125             }
3126             addInScreen(view, container, screen, mTargetCell[0], mTargetCell[1], info.spanX,
3127                     info.spanY, insertAtFirst);
3128             cellLayout.onDropChild(view);
3129             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3130             cellLayout.getChildrenLayout().measureChild(view);
3131 
3132 
3133             LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen,
3134                     lp.cellX, lp.cellY);
3135 
3136             if (d.dragView != null) {
3137                 // We wrap the animation call in the temporary set and reset of the current
3138                 // cellLayout to its final transform -- this means we animate the drag view to
3139                 // the correct final location.
3140                 setFinalTransitionTransform(cellLayout);
3141                 mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3142                         exitSpringLoadedRunnable);
3143                 resetTransitionTransform(cellLayout);
3144             }
3145         }
3146     }
3147 
3148     public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {
3149         int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX,
3150                 widgetInfo.spanY, widgetInfo, false);
3151         int visibility = layout.getVisibility();
3152         layout.setVisibility(VISIBLE);
3153 
3154         int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);
3155         int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);
3156         Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1],
3157                 Bitmap.Config.ARGB_8888);
3158         Canvas c = new Canvas(b);
3159 
3160         layout.measure(width, height);
3161         layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);
3162         layout.draw(c);
3163         c.setBitmap(null);
3164         layout.setVisibility(visibility);
3165         return b;
3166     }
3167 
3168     private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY,
3169             DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell, View finalView,
3170             boolean external) {
3171         // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
3172         // location and size on the home screen.
3173         int spanX = info.spanX;
3174         int spanY = info.spanY;
3175 
3176         Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);
3177         loc[0] = r.left;
3178         loc[1] = r.top;
3179 
3180         setFinalTransitionTransform(layout);
3181         float cellLayoutScale =
3182                 mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc);
3183         resetTransitionTransform(layout);
3184         float dragViewScaleX = (1.0f * r.width()) / dragView.getMeasuredWidth();
3185         float dragViewScaleY = (1.0f * r.height()) / dragView.getMeasuredHeight();
3186 
3187         // The animation will scale the dragView about its center, so we need to center about
3188         // the final location.
3189         loc[0] -= (dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;
3190         loc[1] -= (dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;
3191 
3192         scaleXY[0] = dragViewScaleX * cellLayoutScale;
3193         scaleXY[1] = dragViewScaleY * cellLayoutScale;
3194     }
3195 
3196     public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView,
3197             final Runnable onCompleteRunnable, int animationType, final View finalView,
3198             boolean external) {
3199         Rect from = new Rect();
3200         mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);
3201 
3202         int[] finalPos = new int[2];
3203         float scaleXY[] = new float[2];
3204         getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell,
3205                 finalView, external);
3206 
3207         Resources res = mLauncher.getResources();
3208         int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;
3209 
3210         // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer
3211         if (finalView instanceof AppWidgetHostView &amp;&amp; external) {
3212             mLauncher.getDragLayer().removeView(finalView);
3213         }
3214         if ((animationType == ANIMATE_INTO_POSITION_AND_RESIZE || external) &amp;&amp; finalView != null) {
3215             Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);
3216             dragView.setCrossFadeBitmap(crossFadeBitmap);
3217             dragView.crossFade((int) (duration * 0.8f));
3218         } else if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp; external) {
3219             scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0],  scaleXY[1]);
3220         }
3221 
3222         DragLayer dragLayer = mLauncher.getDragLayer();
3223         if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {
3224             mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0f, 0.1f, 0.1f,
3225                     DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);
3226         } else {
3227             int endStyle;
3228             if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {
3229                 endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;
3230             } else {
3231                 endStyle = DragLayer.ANIMATION_END_DISAPPEAR;;
3232             }
3233 
3234             Runnable onComplete = new Runnable() {
3235                 @Override
3236                 public void run() {
3237                     if (finalView != null) {
3238                         finalView.setVisibility(VISIBLE);
3239                     }
3240                     if (onCompleteRunnable != null) {
3241                         onCompleteRunnable.run();
3242                     }
3243                 }
3244             };
3245             dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0],
3246                     finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle,
3247                     duration, this);
3248         }
3249     }
3250 
3251     public void setFinalTransitionTransform(CellLayout layout) {
3252         if (isSwitchingState()) {
3253             int index = indexOfChild(layout);
3254             mCurrentScaleX = layout.getScaleX();
3255             mCurrentScaleY = layout.getScaleY();
3256             mCurrentTranslationX = layout.getTranslationX();
3257             mCurrentTranslationY = layout.getTranslationY();
3258             mCurrentRotationY = layout.getRotationY();
3259             layout.setScaleX(mNewScaleXs[index]);
3260             layout.setScaleY(mNewScaleYs[index]);
3261             layout.setTranslationX(mNewTranslationXs[index]);
3262             layout.setTranslationY(mNewTranslationYs[index]);
3263             layout.setRotationY(mNewRotationYs[index]);
3264         }
3265     }
3266     public void resetTransitionTransform(CellLayout layout) {
3267         if (isSwitchingState()) {
3268             mCurrentScaleX = layout.getScaleX();
3269             mCurrentScaleY = layout.getScaleY();
3270             mCurrentTranslationX = layout.getTranslationX();
3271             mCurrentTranslationY = layout.getTranslationY();
3272             mCurrentRotationY = layout.getRotationY();
3273             layout.setScaleX(mCurrentScaleX);
3274             layout.setScaleY(mCurrentScaleY);
3275             layout.setTranslationX(mCurrentTranslationX);
3276             layout.setTranslationY(mCurrentTranslationY);
3277             layout.setRotationY(mCurrentRotationY);
3278         }
3279     }
3280 
3281     /**
3282      * Return the current {@link CellLayout}, correctly picking the destination
3283      * screen while a scroll is in progress.
3284      */
3285     public CellLayout getCurrentDropLayout() {
3286         return (CellLayout) getChildAt(mNextPage == INVALID_PAGE ? mCurrentPage : mNextPage);
3287     }
3288 
3289     /**
3290      * Return the current CellInfo describing our current drag; this method exists
3291      * so that Launcher can sync this object with the correct info when the activity is created/
3292      * destroyed
3293      *
3294      */
3295     public CellLayout.CellInfo getDragInfo() {
3296         return mDragInfo;
3297     }
3298 
3299     /**
3300      * Calculate the nearest cell where the given object would be dropped.
3301      *
3302      * pixelX and pixelY should be in the coordinate system of layout
3303      */
3304     private int[] findNearestVacantArea(int pixelX, int pixelY,
3305             int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle) {
3306         return layout.findNearestVacantArea(
3307                 pixelX, pixelY, spanX, spanY, spanX, spanY, ignoreView, recycle, null);
3308     }
3309 
3310     /**
3311      * Calculate the nearest cell where the given object would be dropped.
3312      *
3313      * pixelX and pixelY should be in the coordinate system of layout
3314      */
3315     private int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
3316             int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle,
3317             int[] returnSpan) {
3318         return layout.findNearestVacantArea(
3319                 pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, recycle, returnSpan);
3320     }
3321 
3322     /**
3323      * Calculate the nearest cell where the given object would be dropped.
3324      *
3325      * pixelX and pixelY should be in the coordinate system of layout
3326      */
3327     private int[] findNearestArea(int pixelX, int pixelY,
3328             int spanX, int spanY, CellLayout layout, int[] recycle) {
3329         return layout.findNearestArea(
3330                 pixelX, pixelY, spanX, spanY, recycle);
3331     }
3332 
3333     void setup(DragController dragController) {
3334         mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3335         mDragController = dragController;
3336 
3337         // hardware layers on children are enabled on startup, but should be disabled until
3338         // needed
3339         updateChildrenLayersEnabled();
3340         setWallpaperDimension();
3341     }
3342 
3343     /**
3344      * Called at the end of a drag which originated on the workspace.
3345      */
3346     public void onDropCompleted(View target, DragObject d, boolean success) {
3347         if (success) {
3348             if (target != this) {
3349                 if (mDragInfo != null) {
3350                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
3351                     if (mDragInfo.cell instanceof DropTarget) {
3352                         mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3353                     }
3354                 }
3355             }
3356         } else if (mDragInfo != null) {
3357             // NOTE: When &#x27;success&#x27; is true, onDragExit is called by the DragController before
3358             // calling onDropCompleted(). We call it ourselves here, but maybe this should be
3359             // moved into DragController.cancelDrag().
3360             doDragExit(null);
3361             CellLayout cellLayout;
3362             if (mLauncher.isHotseatLayout(target)) {
3363                 cellLayout = mLauncher.getHotseat().getLayout();
3364             } else {
3365                 cellLayout = (CellLayout) getChildAt(mDragInfo.screen);
3366             }
3367             cellLayout.onDropChild(mDragInfo.cell);
3368         }
3369         if (d.cancelled &amp;&amp;  mDragInfo.cell != null) {
3370                 mDragInfo.cell.setVisibility(VISIBLE);
3371         }
3372         mDragOutline = null;
3373         mDragInfo = null;
3374 
3375         // Hide the scrolling indicator after you pick up an item
3376         hideScrollingIndicator(false);
3377     }
3378 
3379     public boolean isDropEnabled() {
3380         return true;
3381     }
3382 
3383     @Override
3384     protected void onRestoreInstanceState(Parcelable state) {
3385         super.onRestoreInstanceState(state);
3386         Launcher.setScreen(mCurrentPage);
3387     }
3388 
3389     @Override
3390     public void scrollLeft() {
3391         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3392             super.scrollLeft();
3393         }
3394         Folder openFolder = getOpenFolder();
3395         if (openFolder != null) {
3396             openFolder.completeDragExit();
3397         }
3398     }
3399 
3400     @Override
3401     public void scrollRight() {
3402         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3403             super.scrollRight();
3404         }
3405         Folder openFolder = getOpenFolder();
3406         if (openFolder != null) {
3407             openFolder.completeDragExit();
3408         }
3409     }
3410 
3411     @Override
3412     public boolean onEnterScrollArea(int x, int y, int direction) {
3413         // Ignore the scroll area if we are dragging over the hot seat
3414         if (mLauncher.getHotseat() != null) {
3415             Rect r = new Rect();
3416             mLauncher.getHotseat().getHitRect(r);
3417             if (r.contains(x, y)) {
3418                 return false;
3419             }
3420         }
3421 
3422         boolean result = false;
3423         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3424             mInScrollArea = true;
3425 
3426             final int page = (mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage) +
3427                        (direction == DragController.SCROLL_LEFT ? -1 : 1);
3428             cancelFolderCreation();
3429 
3430             if (0 &lt;= page &amp;&amp; page &lt; getChildCount()) {
3431                 CellLayout layout = (CellLayout) getChildAt(page);
3432                 // Exit the current layout and mark the overlapping layout
3433                 if (mDragTargetLayout != null) {
3434                     mDragTargetLayout.setIsDragOverlapping(false);
3435                     mDragTargetLayout.onDragExit();
3436                 }
3437                 mDragTargetLayout = layout;
3438                 mDragTargetLayout.setIsDragOverlapping(true);
3439 
3440                 // Workspace is responsible for drawing the edge glow on adjacent pages,
3441                 // so we need to redraw the workspace when this may have changed.
3442                 invalidate();
3443                 result = true;
3444             }
3445         }
3446         return result;
3447     }
3448 
3449     @Override
3450     public boolean onExitScrollArea() {
3451         boolean result = false;
3452         if (mInScrollArea) {
3453             if (mDragTargetLayout != null) {
3454                 mDragTargetLayout.setIsDragOverlapping(false);
3455                 // Workspace is responsible for drawing the edge glow on adjacent pages,
3456                 // so we need to redraw the workspace when this may have changed.
3457                 invalidate();
3458             }
3459             if (mDragTargetLayout != null &amp;&amp; mDragHasEnteredWorkspace) {
3460                 // Unmark the overlapping layout and re-enter the current layout
3461                 mDragTargetLayout = getCurrentDropLayout();
3462                 mDragTargetLayout.onDragEnter();
3463             }
3464             result = true;
3465             mInScrollArea = false;
3466         }
3467         return result;
3468     }
3469 
3470     private void onResetScrollArea() {
3471         if (mDragTargetLayout != null) {
3472             // Unmark the overlapping layout
3473             mDragTargetLayout.setIsDragOverlapping(false);
3474 
3475             // Workspace is responsible for drawing the edge glow on adjacent pages,
3476             // so we need to redraw the workspace when this may have changed.
3477             invalidate();
3478         }
3479         mInScrollArea = false;
3480     }
3481 
3482     /**
3483      * Returns a specific CellLayout
3484      */
3485     CellLayout getParentCellLayoutForView(View v) {
3486         ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
3487         for (CellLayout layout : layouts) {
3488             if (layout.getChildrenLayout().indexOfChild(v) &gt; -1) {
3489                 return layout;
3490             }
3491         }
3492         return null;
3493     }
3494 
3495     /**
3496      * Returns a list of all the CellLayouts in the workspace.
3497      */
3498     ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
3499         ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
3500         int screenCount = getChildCount();
3501         for (int screen = 0; screen &lt; screenCount; screen++) {
3502             layouts.add(((CellLayout) getChildAt(screen)));
3503         }
3504         if (mLauncher.getHotseat() != null) {
3505             layouts.add(mLauncher.getHotseat().getLayout());
3506         }
3507         return layouts;
3508     }
3509 
3510     /**
3511      * We should only use this to search for specific children.  Do not use this method to modify
3512      * CellLayoutChildren directly.
3513      */
3514     ArrayList&lt;CellLayoutChildren&gt; getWorkspaceAndHotseatCellLayoutChildren() {
3515         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = new ArrayList&lt;CellLayoutChildren&gt;();
3516         int screenCount = getChildCount();
3517         for (int screen = 0; screen &lt; screenCount; screen++) {
3518             childrenLayouts.add(((CellLayout) getChildAt(screen)).getChildrenLayout());
3519         }
3520         if (mLauncher.getHotseat() != null) {
3521             childrenLayouts.add(mLauncher.getHotseat().getLayout().getChildrenLayout());
3522         }
3523         return childrenLayouts;
3524     }
3525 
3526     public Folder getFolderForTag(Object tag) {
3527         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3528         for (CellLayoutChildren layout: childrenLayouts) {
3529             int count = layout.getChildCount();
3530             for (int i = 0; i &lt; count; i++) {
3531                 View child = layout.getChildAt(i);
3532                 if (child instanceof Folder) {
3533                     Folder f = (Folder) child;
3534                     if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
3535                         return f;
3536                     }
3537                 }
3538             }
3539         }
3540         return null;
3541     }
3542 
3543     public View getViewForTag(Object tag) {
3544         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3545         for (CellLayoutChildren layout: childrenLayouts) {
3546             int count = layout.getChildCount();
3547             for (int i = 0; i &lt; count; i++) {
3548                 View child = layout.getChildAt(i);
3549                 if (child.getTag() == tag) {
3550                     return child;
3551                 }
3552             }
3553         }
3554         return null;
3555     }
3556 
3557     void clearDropTargets() {
3558         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3559         for (CellLayoutChildren layout: childrenLayouts) {
3560             int childCount = layout.getChildCount();
3561             for (int j = 0; j &lt; childCount; j++) {
3562                 View v = layout.getChildAt(j);
3563                 if (v instanceof DropTarget) {
3564                     mDragController.removeDropTarget((DropTarget) v);
3565                 }
3566             }
3567         }
3568     }
3569 
3570     void removeItems(final ArrayList&lt;ApplicationInfo&gt; apps) {
3571         final AppWidgetManager widgets = AppWidgetManager.getInstance(getContext());
3572 
3573         final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
3574         final int appCount = apps.size();
3575         for (int i = 0; i &lt; appCount; i++) {
3576             packageNames.add(apps.get(i).componentName.getPackageName());
3577         }
3578 
3579         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
3580         for (final CellLayout layoutParent: cellLayouts) {
3581             final ViewGroup layout = layoutParent.getChildrenLayout();
3582 
3583             // Avoid ANRs by treating each screen separately
3584             post(new Runnable() {
3585                 public void run() {
3586                     final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
3587                     childrenToRemove.clear();
3588 
3589                     int childCount = layout.getChildCount();
3590                     for (int j = 0; j &lt; childCount; j++) {
3591                         final View view = layout.getChildAt(j);
3592                         Object tag = view.getTag();
3593 
3594                         if (tag instanceof ShortcutInfo) {
3595                             final ShortcutInfo info = (ShortcutInfo) tag;
3596                             final Intent intent = info.intent;
3597                             final ComponentName name = intent.getComponent();
3598 
3599                             if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3600                                 for (String packageName: packageNames) {
3601                                     if (packageName.equals(name.getPackageName())) {
3602                                         LauncherModel.deleteItemFromDatabase(mLauncher, info);
3603                                         childrenToRemove.add(view);
3604                                     }
3605                                 }
3606                             }
3607                         } else if (tag instanceof FolderInfo) {
3608                             final FolderInfo info = (FolderInfo) tag;
3609                             final ArrayList&lt;ShortcutInfo&gt; contents = info.contents;
3610                             final int contentsCount = contents.size();
3611                             final ArrayList&lt;ShortcutInfo&gt; appsToRemoveFromFolder =
3612                                     new ArrayList&lt;ShortcutInfo&gt;();
3613 
3614                             for (int k = 0; k &lt; contentsCount; k++) {
3615                                 final ShortcutInfo appInfo = contents.get(k);
3616                                 final Intent intent = appInfo.intent;
3617                                 final ComponentName name = intent.getComponent();
3618 
3619                                 if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3620                                     for (String packageName: packageNames) {
3621                                         if (packageName.equals(name.getPackageName())) {
3622                                             appsToRemoveFromFolder.add(appInfo);
3623                                         }
3624                                     }
3625                                 }
3626                             }
3627                             for (ShortcutInfo item: appsToRemoveFromFolder) {
3628                                 info.remove(item);
3629                                 LauncherModel.deleteItemFromDatabase(mLauncher, item);
3630                             }
3631                         } else if (tag instanceof LauncherAppWidgetInfo) {
3632                             final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) tag;
3633                             final AppWidgetProviderInfo provider =
3634                                     widgets.getAppWidgetInfo(info.appWidgetId);
3635                             if (provider != null) {
3636                                 for (String packageName: packageNames) {
3637                                     if (packageName.equals(provider.provider.getPackageName())) {
3638                                         LauncherModel.deleteItemFromDatabase(mLauncher, info);
3639                                         childrenToRemove.add(view);
3640                                     }
3641                                 }
3642                             }
3643                         }
3644                     }
3645 
3646                     childCount = childrenToRemove.size();
3647                     for (int j = 0; j &lt; childCount; j++) {
3648                         View child = childrenToRemove.get(j);
3649                         // Note: We can not remove the view directly from CellLayoutChildren as this
3650                         // does not re-mark the spaces as unoccupied.
3651                         layoutParent.removeViewInLayout(child);
3652                         if (child instanceof DropTarget) {
3653                             mDragController.removeDropTarget((DropTarget)child);
3654                         }
3655                     }
3656 
3657                     if (childCount &gt; 0) {
3658                         layout.requestLayout();
3659                         layout.invalidate();
3660                     }
3661                 }
3662             });
3663         }
3664     }
3665 
3666     void updateShortcuts(ArrayList&lt;ApplicationInfo&gt; apps) {
3667         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3668         for (CellLayoutChildren layout: childrenLayouts) {
3669             int childCount = layout.getChildCount();
3670             for (int j = 0; j &lt; childCount; j++) {
3671                 final View view = layout.getChildAt(j);
3672                 Object tag = view.getTag();
3673                 if (tag instanceof ShortcutInfo) {
3674                     ShortcutInfo info = (ShortcutInfo)tag;
3675                     // We need to check for ACTION_MAIN otherwise getComponent() might
3676                     // return null for some shortcuts (for instance, for shortcuts to
3677                     // web pages.)
3678                     final Intent intent = info.intent;
3679                     final ComponentName name = intent.getComponent();
3680                     if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3681                             Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3682                         final int appCount = apps.size();
3683                         for (int k = 0; k &lt; appCount; k++) {
3684                             ApplicationInfo app = apps.get(k);
3685                             if (app.componentName.equals(name)) {
3686                                 info.setIcon(mIconCache.getIcon(info.intent));
3687                                 ((TextView)view).setCompoundDrawablesWithIntrinsicBounds(null,
3688                                         new FastBitmapDrawable(info.getIcon(mIconCache)),
3689                                         null, null);
3690                                 }
3691                         }
3692                     }
3693                 }
3694             }
3695         }
3696     }
3697 
3698     void moveToDefaultScreen(boolean animate) {
3699         if (!isSmall()) {
3700             if (animate) {
3701                 snapToPage(mDefaultPage);
3702             } else {
3703                 setCurrentPage(mDefaultPage);
3704             }
3705         }
3706         getChildAt(mDefaultPage).requestFocus();
3707     }
3708 
3709     @Override
3710     public void syncPages() {
3711     }
3712 
3713     @Override
3714     public void syncPageItems(int page, boolean immediate) {
3715     }
3716 
3717     @Override
3718     protected String getCurrentPageDescription() {
3719         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
3720         return String.format(mContext.getString(R.string.workspace_scroll_format),
3721                 page + 1, getChildCount());
3722     }
3723 
3724     public void getLocationInDragLayer(int[] loc) {
3725         mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
3726     }
3727 
3728     void setFadeForOverScroll(float fade) {
3729         if (!isScrollingIndicatorEnabled()) return;
3730 
3731         mOverscrollFade = fade;
3732         float reducedFade = 0.5f + 0.5f * (1 - fade);
3733         final ViewGroup parent = (ViewGroup) getParent();
3734         final ImageView qsbDivider = (ImageView) (parent.findViewById(R.id.qsb_divider));
3735         final ImageView dockDivider = (ImageView) (parent.findViewById(R.id.dock_divider));
3736         final View scrollIndicator = getScrollingIndicator();
3737 
3738         cancelScrollingIndicatorAnimations();
3739         if (qsbDivider != null) qsbDivider.setAlpha(reducedFade);
3740         if (dockDivider != null) dockDivider.setAlpha(reducedFade);
3741         scrollIndicator.setAlpha(1 - fade);
3742     }
3743 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.AnimatorSet;
  22 import android.animation.ObjectAnimator;
  23 import android.animation.TimeInterpolator;
  24 import android.animation.ValueAnimator;
  25 import android.animation.ValueAnimator.AnimatorUpdateListener;
  26 import android.app.AlertDialog;
  27 import android.app.WallpaperManager;
  28 import android.appwidget.AppWidgetHostView;
  29 import android.appwidget.AppWidgetManager;
  30 import android.appwidget.AppWidgetProviderInfo;
  31 import android.content.ClipData;
  32 import android.content.ClipDescription;
  33 import android.content.ComponentName;
  34 import android.content.Context;
  35 import android.content.Intent;
  36 import android.content.res.Resources;
  37 import android.content.res.TypedArray;
  38 import android.graphics.Bitmap;
  39 import android.graphics.Camera;
  40 import android.graphics.Canvas;
  41 import android.graphics.Matrix;
  42 import android.graphics.Paint;
  43 import android.graphics.Point;
  44 import android.graphics.Rect;
  45 import android.graphics.RectF;
  46 import android.graphics.Region.Op;
  47 import android.graphics.drawable.Drawable;
  48 import android.os.IBinder;
  49 import android.os.Parcelable;
  50 import android.util.AttributeSet;
  51 import android.util.DisplayMetrics;
  52 import android.util.Log;
  53 import android.util.Pair;
  54 import android.view.Display;
  55 import android.view.DragEvent;
  56 import android.view.MotionEvent;
  57 import android.view.View;
  58 import android.view.ViewConfiguration;
  59 import android.view.ViewGroup;
  60 import android.view.View.MeasureSpec;
  61 import android.view.animation.AccelerateInterpolator;
  62 import android.view.animation.DecelerateInterpolator;
  63 import android.widget.ImageView;
  64 import android.widget.TextView;
  65 import android.widget.Toast;
  66 
  67 import com.android.launcher.R;
  68 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  69 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  70 
  71 import java.util.ArrayList;
  72 import java.util.HashSet;
  73 import java.util.List;
  74 
  75 /**
  76  * The workspace is a wide area with a wallpaper and a finite number of pages.
  77  * Each page contains a number of icons, folders or widgets the user can
  78  * interact with. A workspace is meant to be used with a fixed width only.
  79  */
  80 public class Workspace extends SmoothPagedView
  81         implements DropTarget, DragSource, DragScroller, View.OnTouchListener,
  82         DragController.DragListener, LauncherTransitionable {
  83     @SuppressWarnings({&quot;UnusedDeclaration&quot;})
  84     private static final String TAG = &quot;Launcher.Workspace&quot;;
  85 
  86     // Y rotation to apply to the workspace screens
  87     private static final float WORKSPACE_ROTATION = 12.5f;
  88     private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  89     private static float CAMERA_DISTANCE = 6500;
  90 
  91     private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  92     private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  93     private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  94 
  95     private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  96     private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
  97     private static final int FLING_THRESHOLD_VELOCITY = 500;
  98 
  99     // These animators are used to fade the children&#x27;s outlines
 100     private ObjectAnimator mChildrenOutlineFadeInAnimation;
 101     private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 102     private float mChildrenOutlineAlpha = 0;
 103 
 104     // These properties refer to the background protection gradient used for AllApps and Customize
 105     private ValueAnimator mBackgroundFadeInAnimation;
 106     private ValueAnimator mBackgroundFadeOutAnimation;
 107     private Drawable mBackground;
 108     boolean mDrawBackground = true;
 109     private float mBackgroundAlpha = 0;
 110     private float mOverScrollMaxBackgroundAlpha = 0.0f;
 111     private int mOverScrollPageIndex = -1;
 112 
 113     private float mWallpaperScrollRatio = 1.0f;
 114 
 115     private final WallpaperManager mWallpaperManager;
 116     private IBinder mWindowToken;
 117     private static final float WALLPAPER_SCREENS_SPAN = 2f;
 118 
 119     private int mDefaultPage;
 120 
 121     /**
 122      * CellInfo for the cell that is currently being dragged
 123      */
 124     private CellLayout.CellInfo mDragInfo;
 125 
 126     /**
 127      * Target drop area calculated during last acceptDrop call.
 128      */
 129     private int[] mTargetCell = new int[2];
 130 
 131     /**
 132      * The CellLayout that is currently being dragged over
 133      */
 134     private CellLayout mDragTargetLayout = null;
 135     private boolean mDragHasEnteredWorkspace = false;
 136 
 137     private Launcher mLauncher;
 138     private IconCache mIconCache;
 139     private DragController mDragController;
 140 
 141     // These are temporary variables to prevent having to allocate a new object just to
 142     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 143     private int[] mTempCell = new int[2];
 144     private int[] mTempEstimate = new int[2];
 145     private float[] mDragViewVisualCenter = new float[2];
 146     private float[] mTempDragCoordinates = new float[2];
 147     private float[] mTempCellLayoutCenterCoordinates = new float[2];
 148     private float[] mTempDragBottomRightCoordinates = new float[2];
 149     private Matrix mTempInverseMatrix = new Matrix();
 150 
 151     private SpringLoadedDragController mSpringLoadedDragController;
 152     private float mSpringLoadedShrinkFactor;
 153 
 154     private static final int DEFAULT_CELL_COUNT_X = 4;
 155     private static final int DEFAULT_CELL_COUNT_Y = 4;
 156 
 157     // State variable that indicates whether the pages are small (ie when you&#x27;re
 158     // in all apps or customize mode)
 159 
 160 
 161 
 162     // State variable that indicates whether the pages are small (ie when you&#x27;re
 163     // in all apps or customize mode)
 164 
 165     enum State { NORMAL, SPRING_LOADED, SMALL };;
 166     private State mState = State.NORMAL;
 167     private boolean mIsSwitchingState = false;
 168 
 169     boolean mAnimatingViewIntoPlace = false;
 170     boolean mIsDragOccuring = false;
 171     boolean mChildrenLayersEnabled = true;
 172 
 173     /** Is the user is dragging an item near the edge of a page? */
 174     private boolean mInScrollArea = false;
 175 
 176     private final HolographicOutlineHelper mOutlineHelper = new HolographicOutlineHelper();
 177     private Bitmap mDragOutline = null;
 178     private final Rect mTempRect = new Rect();
 179     private final int[] mTempXY = new int[2];
 180     private float mOverscrollFade = 0;
 181     public static final int DRAG_BITMAP_PADDING = 0;
 182 
 183     // Paint used to draw external drop outline
 184     private final Paint mExternalDragOutlinePaint = new Paint();
 185 
 186     // Camera and Matrix used to determine the final position of a neighboring CellLayout
 187     private final Matrix mMatrix = new Matrix();
 188     private final Camera mCamera = new Camera();
 189     private final float mTempFloat2[] = new float[2];
 190 
 191     enum WallpaperVerticalOffset { TOP, MIDDLE, BOTTOM };;
 192     int mWallpaperWidth;
 193     int mWallpaperHeight;
 194     WallpaperOffsetInterpolator mWallpaperOffset;
 195     boolean mUpdateWallpaperOffsetImmediately = false;
 196     private Runnable mDelayedResizeRunnable;
 197     private int mDisplayWidth;
 198     private int mDisplayHeight;
 199     private boolean mIsStaticWallpaper;
 200     private int mWallpaperTravelWidth;
 201 
 202     // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 203     private static final int FOLDER_CREATION_TIMEOUT = 250;
 204     private final Alarm mFolderCreationAlarm = new Alarm();
 205     private FolderRingAnimator mDragFolderRingAnimator = null;
 206     private View mLastDragOverView = null;
 207     private boolean mCreateUserFolderOnDrop = false;
 208 
 209     // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 210     private float mXDown;
 211     private float mYDown;
 212     final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 213     final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 214     final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
 215 
 216     // Relating to the animation of items being dropped externally
 217     public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;
 218     public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;
 219     public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;
 220     public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;
 221     public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;
 222 
 223     // Relating to workspace drag fade out
 224     private float mDragFadeOutAlpha;
 225     private int mDragFadeOutDuration;
 226 
 227     // These variables are used for storing the initial and final values during workspace animations
 228     private int mSavedScrollX;
 229     private float mSavedRotationY;
 230     private float mSavedTranslationX;
 231     private float mCurrentScaleX;
 232     private float mCurrentScaleY;
 233     private float mCurrentRotationY;
 234     private float mCurrentTranslationX;
 235     private float mCurrentTranslationY;
 236     private float[] mOldTranslationXs;
 237     private float[] mOldTranslationYs;
 238     private float[] mOldScaleXs;
 239     private float[] mOldScaleYs;
 240     private float[] mOldBackgroundAlphas;
 241     private float[] mOldBackgroundAlphaMultipliers;
 242     private float[] mOldAlphas;
 243     private float[] mOldRotationYs;
 244     private float[] mNewTranslationXs;
 245     private float[] mNewTranslationYs;
 246     private float[] mNewScaleXs;
 247     private float[] mNewScaleYs;
 248     private float[] mNewBackgroundAlphas;
 249     private float[] mNewBackgroundAlphaMultipliers;
 250     private float[] mNewAlphas;
 251     private float[] mNewRotationYs;
 252     private float mTransitionProgress;
 253 
 254     /**
 255      * Used to inflate the Workspace from XML.
 256      *
 257      * @param context The application&#x27;s context.
 258      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 259      */
 260     public Workspace(Context context, AttributeSet attrs) {
 261         this(context, attrs, 0);
 262     }
 263 
 264     /**
 265      * Used to inflate the Workspace from XML.
 266      *
 267      * @param context The application&#x27;s context.
 268      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 269      * @param defStyle Unused.
 270      */
 271     public Workspace(Context context, AttributeSet attrs, int defStyle) {
 272         super(context, attrs, defStyle);
 273         mContentIsRefreshable = false;
 274 
 275         // With workspace, data is available straight from the get-go
 276         setDataIsReady();
 277 
 278         final Resources res = getResources();
 279         mFadeInAdjacentScreens = res.getBoolean(R.bool.config_workspaceFadeAdjacentScreens);
 280         mDragFadeOutAlpha = res.getInteger(R.integer.config_dragFadeOutAlpha) / 100f;
 281         mDragFadeOutDuration = res.getInteger(R.integer.config_dragFadeOutDuration);
 282         mWallpaperManager = WallpaperManager.getInstance(context);
 283 
 284         int cellCountX = DEFAULT_CELL_COUNT_X;
 285         int cellCountY = DEFAULT_CELL_COUNT_Y;
 286 
 287         TypedArray a = context.obtainStyledAttributes(attrs,
 288                 R.styleable.Workspace, defStyle, 0);
 289 
 290         if (LauncherApplication.isScreenLarge()) {
 291             // Determine number of rows/columns dynamically
 292             // TODO: This code currently fails on tablets with an aspect ratio &lt; 1.3.
 293             // Around that ratio we should make cells the same size in portrait and
 294             // landscape
 295             TypedArray actionBarSizeTypedArray =
 296                 context.obtainStyledAttributes(new int[] { android.R.attr.actionBarSize });
 297             DisplayMetrics displayMetrics = res.getDisplayMetrics();
 298             final float actionBarHeight = actionBarSizeTypedArray.getDimension(0, 0f);
 299             final float systemBarHeight = res.getDimension(R.dimen.status_bar_height);
 300             final float smallestScreenDim = res.getConfiguration().smallestScreenWidthDp *
 301                     displayMetrics.density;
 302 
 303             cellCountX = 1;
 304             while (CellLayout.widthInPortrait(res, cellCountX + 1) &lt;= smallestScreenDim) {
 305                 cellCountX++;
 306             }
 307 
 308             cellCountY = 1;
 309             while (actionBarHeight + CellLayout.heightInLandscape(res, cellCountY + 1)
 310                 &lt;= smallestScreenDim - systemBarHeight) {
 311                 cellCountY++;
 312             }
 313         }
 314 
 315         mSpringLoadedShrinkFactor =
 316             res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0f;
 317 
 318         // if the value is manually specified, use that instead
 319         cellCountX = a.getInt(R.styleable.Workspace_cellCountX, cellCountX);
 320         cellCountY = a.getInt(R.styleable.Workspace_cellCountY, cellCountY);
 321         mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 322         a.recycle();
 323 
 324         LauncherModel.updateWorkspaceLayoutCells(cellCountX, cellCountY);
 325         setHapticFeedbackEnabled(false);
 326 
 327         mLauncher = (Launcher) context;
 328         initWorkspace();
 329 
 330         // Disable multitouch across the workspace/all apps/customize tray
 331         setMotionEventSplittingEnabled(true);
 332     }
 333 
 334     // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 335     // dimension if unsuccessful
 336     public int[] estimateItemSize(int hSpan, int vSpan,
 337             ItemInfo itemInfo, boolean springLoaded) {
 338         int[] size = new int[2];
 339         if (getChildCount() &gt; 0) {
 340             CellLayout cl = (CellLayout) mLauncher.getWorkspace().getChildAt(0);
 341             Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);
 342             size[0] = r.width();
 343             size[1] = r.height();
 344             if (springLoaded) {
 345                 size[0] *= mSpringLoadedShrinkFactor;
 346                 size[1] *= mSpringLoadedShrinkFactor;
 347             }
 348             return size;
 349         } else {
 350             size[0] = Integer.MAX_VALUE;
 351             size[1] = Integer.MAX_VALUE;
 352             return size;
 353         }
 354     }
 355     public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,
 356             int hCell, int vCell, int hSpan, int vSpan) {
 357         Rect r = new Rect();
 358         cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 359         return r;
 360     }
 361 
 362     public void buildPageHardwareLayers() {
 363         if (getWindowToken() != null) {
 364             final int childCount = getChildCount();
 365             for (int i = 0; i &lt; childCount; i++) {
 366                 CellLayout cl = (CellLayout) getChildAt(i);
 367                 cl.buildChildrenLayer();
 368             }
 369         }
 370     }
 371 
 372     public void onDragStart(DragSource source, Object info, int dragAction) {
 373         mIsDragOccuring = true;
 374         updateChildrenLayersEnabled();
 375         mLauncher.lockScreenOrientationOnLargeUI();
 376 
 377         // Fade out the workspace slightly to highlight the currently dragging item
 378         int count = getChildCount();
 379         for (int i = 0; i &lt; count; i++) {
 380             CellLayout cl = (CellLayout) getPageAt(i);
 381             cl.getChildrenLayout().animate().alpha(mDragFadeOutAlpha)
 382                 .setInterpolator(new AccelerateInterpolator(1.5f))
 383                 .setDuration(mDragFadeOutDuration)
 384                 .start();
 385         }
 386     }
 387 
 388     public void onDragEnd() {
 389         mIsDragOccuring = false;
 390         updateChildrenLayersEnabled();
 391         mLauncher.unlockScreenOrientationOnLargeUI();
 392 
 393         // Fade the workspace back in after we have completed dragging
 394         int count = getChildCount();
 395         for (int i = 0; i &lt; count; i++) {
 396             CellLayout cl = (CellLayout) getPageAt(i);
 397             cl.getChildrenLayout().animate().alpha(1f)
 398                 .setInterpolator(new DecelerateInterpolator(1.5f))
 399                 .setDuration(mDragFadeOutDuration)
 400                 .start();
 401         }
 402     }
 403 
 404     /**
 405      * Initializes various states for this workspace.
 406      */
 407     protected void initWorkspace() {
 408         Context context = getContext();
 409         mCurrentPage = mDefaultPage;
 410         Launcher.setScreen(mCurrentPage);
 411         LauncherApplication app = (LauncherApplication)context.getApplicationContext();
 412         mIconCache = app.getIconCache();
 413         mExternalDragOutlinePaint.setAntiAlias(true);
 414         setWillNotDraw(false);
 415         setChildrenDrawnWithCacheEnabled(true);
 416 
 417         try {
 418             final Resources res = getResources();
 419             mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 420         } catch (Resources.NotFoundException e) {
 421             // In this case, we will skip drawing background protection
 422         }
 423 
 424         mWallpaperOffset = new WallpaperOffsetInterpolator();
 425         Display display = mLauncher.getWindowManager().getDefaultDisplay();
 426         mDisplayWidth = display.getWidth();
 427         mDisplayHeight = display.getHeight();
 428         mWallpaperTravelWidth = (int) (mDisplayWidth *
 429                 wallpaperTravelToScreenWidthRatio(mDisplayWidth, mDisplayHeight));
 430 
 431         mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 432 
 433     }
 434 
 435     @Override
 436     protected int getScrollMode() {
 437         return SmoothPagedView.X_LARGE_MODE;
 438     }
 439 
 440     @Override
 441     protected void onViewAdded(View child) {
 442         super.onViewAdded(child);
 443         if (!(child instanceof CellLayout)) {
 444             throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 445         }
 446         CellLayout cl = ((CellLayout) child);
 447         cl.setOnInterceptTouchListener(this);
 448         cl.setClickable(true);
 449         cl.enableHardwareLayers();
 450     }
 451 
 452     /**
 453      * @return The open folder on the current screen, or null if there is none
 454      */
 455     Folder getOpenFolder() {
 456         DragLayer dragLayer = mLauncher.getDragLayer();
 457         int count = dragLayer.getChildCount();
 458         for (int i = 0; i &lt; count; i++) {
 459             View child = dragLayer.getChildAt(i);
 460             if (child instanceof Folder) {
 461                 Folder folder = (Folder) child;
 462                 if (folder.getInfo().opened)
 463                     return folder;
 464             }
 465         }
 466         return null;
 467     }
 468 
 469     boolean isTouchActive() {
 470         return mTouchState != TOUCH_STATE_REST;
 471     }
 472 
 473     /**
 474      * Adds the specified child in the specified screen. The position and dimension of
 475      * the child are defined by x, y, spanX and spanY.
 476      *
 477      * @param child The child to add in one of the workspace&#x27;s screens.
 478      * @param screen The screen in which to add the child.
 479      * @param x The X position of the child in the screen&#x27;s grid.
 480      * @param y The Y position of the child in the screen&#x27;s grid.
 481      * @param spanX The number of cells spanned horizontally by the child.
 482      * @param spanY The number of cells spanned vertically by the child.
 483      */
 484     void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY) {
 485         addInScreen(child, container, screen, x, y, spanX, spanY, false);
 486     }
 487 
 488     /**
 489      * Adds the specified child in the specified screen. The position and dimension of
 490      * the child are defined by x, y, spanX and spanY.
 491      *
 492      * @param child The child to add in one of the workspace&#x27;s screens.
 493      * @param screen The screen in which to add the child.
 494      * @param x The X position of the child in the screen&#x27;s grid.
 495      * @param y The Y position of the child in the screen&#x27;s grid.
 496      * @param spanX The number of cells spanned horizontally by the child.
 497      * @param spanY The number of cells spanned vertically by the child.
 498      * @param insert When true, the child is inserted at the beginning of the children list.
 499      */
 500     void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY,
 501             boolean insert) {
 502         if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 503             if (screen &lt; 0 || screen &gt;= getChildCount()) {
 504                 Log.e(TAG, &quot;The screen must be &gt;= 0 and &lt; &quot; + getChildCount()
 505                     + &quot; (was &quot; + screen + &quot;); skipping child&quot;);
 506                 return;
 507             }
 508         }
 509 
 510         final CellLayout layout;
 511         if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 512             layout = mLauncher.getHotseat().getLayout();
 513             child.setOnKeyListener(null);
 514 
 515             // Hide folder title in the hotseat
 516             if (child instanceof FolderIcon) {
 517                 ((FolderIcon) child).setTextVisible(false);
 518             }
 519 
 520             if (screen &lt; 0) {
 521                 screen = mLauncher.getHotseat().getOrderInHotseat(x, y);
 522             } else {
 523                 // Note: We do this to ensure that the hotseat is always laid out in the orientation
 524                 // of the hotseat in order regardless of which orientation they were added
 525                 x = mLauncher.getHotseat().getCellXFromOrder(screen);
 526                 y = mLauncher.getHotseat().getCellYFromOrder(screen);
 527             }
 528         } else {
 529             // Show folder title if not in the hotseat
 530             if (child instanceof FolderIcon) {
 531                 ((FolderIcon) child).setTextVisible(true);
 532             }
 533 
 534             layout = (CellLayout) getChildAt(screen);
 535             child.setOnKeyListener(new IconKeyEventListener());
 536         }
 537 
 538         LayoutParams genericLp = child.getLayoutParams();
 539         CellLayout.LayoutParams lp;
 540         if (genericLp == null || !(genericLp instanceof CellLayout.LayoutParams)) {
 541             lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 542         } else {
 543             lp = (CellLayout.LayoutParams) genericLp;
 544             lp.cellX = x;
 545             lp.cellY = y;
 546             lp.cellHSpan = spanX;
 547             lp.cellVSpan = spanY;
 548         }
 549 
 550         if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) {
 551             lp.isLockedToGrid = false;
 552         }
 553 
 554         // Get the canonical child id to uniquely represent this view in this screen
 555         int childId = LauncherModel.getCellLayoutChildId(container, screen, x, y, spanX, spanY);
 556         boolean markCellsAsOccupied = !(child instanceof Folder);
 557         if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 558             // TODO: This branch occurs when the workspace is adding views
 559             // outside of the defined grid
 560             // maybe we should be deleting these items from the LauncherModel?
 561             Log.w(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;);
 562         }
 563 
 564         if (!(child instanceof Folder)) {
 565             child.setHapticFeedbackEnabled(false);
 566             child.setOnLongClickListener(mLongClickListener);
 567         }
 568         if (child instanceof DropTarget) {
 569             mDragController.addDropTarget((DropTarget) child);
 570         }
 571     }
 572 
 573     /**
 574      * Check if the point (x, y) hits a given page.
 575      */
 576     private boolean hitsPage(int index, float x, float y) {
 577         final View page = getChildAt(index);
 578         if (page != null) {
 579             float[] localXY = { x, y };
 580             mapPointFromSelfToChild(page, localXY);
 581             return (localXY[0] &gt;= 0 &amp;&amp; localXY[0] &lt; page.getWidth()
 582                     &amp;&amp; localXY[1] &gt;= 0 &amp;&amp; localXY[1] &lt; page.getHeight());
 583         }
 584         return false;
 585     }
 586 
 587     @Override
 588     protected boolean hitsPreviousPage(float x, float y) {
 589         // mNextPage is set to INVALID_PAGE whenever we are stationary.
 590         // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 591         final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 592 
 593         // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 594         // the active workspace
 595         return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current - 1, x, y);
 596     }
 597 
 598     @Override
 599     protected boolean hitsNextPage(float x, float y) {
 600         // mNextPage is set to INVALID_PAGE whenever we are stationary.
 601         // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 602         final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 603 
 604         // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 605         // the active workspace
 606         return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current + 1, x, y);
 607     }
 608 
 609     /**
 610      * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 611      * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 612      * that it should intercept touch events, which is not something that is normally supported.
 613      */
 614     @Override
 615     public boolean onTouch(View v, MotionEvent event) {
 616         return (isSmall() || !isFinishedSwitchingState());
 617     }
 618 
 619     public boolean isSwitchingState() {
 620         return mIsSwitchingState;
 621     }
 622 
 623     /** This differs from isSwitchingState in that we take into account how far the transition
 624      *  has completed. */
 625     public boolean isFinishedSwitchingState() {
 626         return !mIsSwitchingState || (mTransitionProgress &gt; 0.5f);
 627     }
 628 
 629     protected void onWindowVisibilityChanged (int visibility) {
 630         mLauncher.onWindowVisibilityChanged(visibility);
 631     }
 632 
 633     @Override
 634     public boolean dispatchUnhandledMove(View focused, int direction) {
 635         if (isSmall() || !isFinishedSwitchingState()) {
 636             // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
 637             return false;
 638         }
 639         return super.dispatchUnhandledMove(focused, direction);
 640     }
 641 
 642     @Override
 643     public boolean onInterceptTouchEvent(MotionEvent ev) {
 644         switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
 645         case MotionEvent.ACTION_DOWN:
 646             mXDown = ev.getX();
 647             mYDown = ev.getY();
 648             break;
 649         case MotionEvent.ACTION_POINTER_UP:
 650         case MotionEvent.ACTION_UP:
 651             if (mTouchState == TOUCH_STATE_REST) {
 652                 final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
 653                 if (!currentPage.lastDownOnOccupiedCell()) {
 654                     onWallpaperTap(ev);
 655                 }
 656             }
 657         }
 658         return super.onInterceptTouchEvent(ev);
 659     }
 660 
 661     @Override
 662     protected void determineScrollingStart(MotionEvent ev) {
 663         if (isSmall()) return;
 664         if (!isFinishedSwitchingState()) return;
 665 
 666             float deltaX = Math.abs(ev.getX() - mXDown);
 667             float deltaY = Math.abs(ev.getY() - mYDown);
 668 
 669             if (Float.compare(deltaX, 0f) == 0) return;
 670 
 671             float slope = deltaY / deltaX;
 672             float theta = (float) Math.atan(slope);
 673 
 674             if (deltaX &gt; mTouchSlop || deltaY &gt; mTouchSlop) {
 675                 cancelCurrentPageLongPress();
 676             }
 677 
 678             if (theta &gt; MAX_SWIPE_ANGLE) {
 679                 // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace
 680                 return;
 681             } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {
 682                 // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to
 683                 // increase the touch slop to make it harder to begin scrolling the workspace. This
 684                 // results in vertically scrolling widgets to more easily. The higher the angle, the
 685                 // more we increase touch slop.
 686                 theta -= START_DAMPING_TOUCH_SLOP_ANGLE;
 687                 float extraRatio = (float)
 688                         Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));
 689                 super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);
 690             } else {
 691                 // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special
 692                 super.determineScrollingStart(ev);
 693             }
 694         }
 695 
 696     @Override
 697     protected boolean isScrollingIndicatorEnabled() {
 698         return mState != State.SPRING_LOADED;
 699     }
 700 
 701     protected void onPageBeginMoving() {
 702         super.onPageBeginMoving();
 703 
 704         if (isHardwareAccelerated()) {
 705             updateChildrenLayersEnabled();
 706         } else {
 707             if (mNextPage != INVALID_PAGE) {
 708                 // we&#x27;re snapping to a particular screen
 709                 enableChildrenCache(mCurrentPage, mNextPage);
 710             } else {
 711                 // this is when user is actively dragging a particular screen, they might
 712                 // swipe it either left or right (but we won&#x27;t advance by more than one screen)
 713                 enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
 714             }
 715         }
 716 
 717         // Only show page outlines as we pan if we are on large screen
 718         if (LauncherApplication.isScreenLarge()) {
 719             showOutlines();
 720             mIsStaticWallpaper = mWallpaperManager.getWallpaperInfo() == null;
 721         }
 722 
 723         // If we are not fading in adjacent screens, we still need to restore the alpha in case the
 724         // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)
 725         if (!mFadeInAdjacentScreens) {
 726             for (int i = 0; i &lt; getChildCount(); ++i) {
 727                 getPageAt(i).setAlpha(1f);
 728             }
 729         }
 730 
 731         // Show the scroll indicator as you pan the page
 732         showScrollingIndicator(false);
 733     }
 734 
 735     protected void onPageEndMoving() {
 736         super.onPageEndMoving();
 737 
 738         if (isHardwareAccelerated()) {
 739             updateChildrenLayersEnabled();
 740         } else {
 741             clearChildrenCache();
 742         }
 743 
 744 
 745         if (mDragController.isDragging()) {
 746             if (isSmall()) {
 747                 // If we are in springloaded mode, then force an event to check if the current touch
 748                 // is under a new page (to scroll to)
 749                 mDragController.forceMoveEvent();
 750             }
 751         } else {
 752             // If we are not mid-dragging, hide the page outlines if we are on a large screen
 753             if (LauncherApplication.isScreenLarge()) {
 754                 hideOutlines();
 755             }
 756 
 757             // Hide the scroll indicator as you pan the page
 758             if (!mDragController.isDragging()) {
 759                 hideScrollingIndicator(false);
 760             }
 761         }
 762         mOverScrollMaxBackgroundAlpha = 0.0f;
 763         mOverScrollPageIndex = -1;
 764 
 765         if (mDelayedResizeRunnable != null) {
 766             mDelayedResizeRunnable.run();
 767             mDelayedResizeRunnable = null;
 768         }
 769     }
 770 
 771     @Override
 772     protected void notifyPageSwitchListener() {
 773         super.notifyPageSwitchListener();
 774         Launcher.setScreen(mCurrentPage);
 775     };;
 776 
 777     // As a ratio of screen height, the total distance we want the parallax effect to span
 778     // horizontally
 779     private float wallpaperTravelToScreenWidthRatio(int width, int height) {
 780         float aspectRatio = width / (float) height;
 781 
 782         // At an aspect ratio of 16/10, the wallpaper parallax effect should span 1.5 * screen width
 783         // At an aspect ratio of 10/16, the wallpaper parallax effect should span 1.2 * screen width
 784         // We will use these two data points to extrapolate how much the wallpaper parallax effect
 785         // to span (ie travel) at any aspect ratio:
 786 
 787         final float ASPECT_RATIO_LANDSCAPE = 16/10f;
 788         final float ASPECT_RATIO_PORTRAIT = 10/16f;
 789         final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE = 1.5f;
 790         final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT = 1.2f;
 791 
 792         // To find out the desired width at different aspect ratios, we use the following two
 793         // formulas, where the coefficient on x is the aspect ratio (width/height):
 794         //   (16/10)x + y = 1.5
 795         //   (10/16)x + y = 1.2
 796         // We solve for x and y and end up with a final formula:
 797         final float x =
 798             (WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE - WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT) /
 799             (ASPECT_RATIO_LANDSCAPE - ASPECT_RATIO_PORTRAIT);
 800         final float y = WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT - x * ASPECT_RATIO_PORTRAIT;
 801         return x * aspectRatio + y;
 802     }
 803 
 804     // The range of scroll values for Workspace
 805     private int getScrollRange() {
 806         return getChildOffset(getChildCount() - 1) - getChildOffset(0);
 807     }
 808 
 809     protected void setWallpaperDimension() {
 810         DisplayMetrics displayMetrics = new DisplayMetrics();
 811         mLauncher.getWindowManager().getDefaultDisplay().getRealMetrics(displayMetrics);
 812         final int maxDim = Math.max(displayMetrics.widthPixels, displayMetrics.heightPixels);
 813         final int minDim = Math.min(displayMetrics.widthPixels, displayMetrics.heightPixels);
 814 
 815         // We need to ensure that there is enough extra space in the wallpaper for the intended
 816         // parallax effects
 817         if (LauncherApplication.isScreenLarge()) {
 818             mWallpaperWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
 819             mWallpaperHeight = maxDim;
 820         } else {
 821             mWallpaperWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
 822             mWallpaperHeight = maxDim;
 823         }
 824         new Thread(&quot;setWallpaperDimension&quot;) {
 825             public void run() {
 826                 mWallpaperManager.suggestDesiredDimensions(mWallpaperWidth, mWallpaperHeight);
 827             }
 828         }.start();
 829     }
 830 
 831     private float wallpaperOffsetForCurrentScroll() {
 832         // Set wallpaper offset steps (1 / (number of screens - 1))
 833         mWallpaperManager.setWallpaperOffsetSteps(1.0f / (getChildCount() - 1), 1.0f);
 834 
 835         // For the purposes of computing the scrollRange and overScrollOffset, we assume
 836         // that mLayoutScale is 1. This means that when we&#x27;re in spring-loaded mode,
 837         // there&#x27;s no discrepancy between the wallpaper offset for a given page.
 838         float layoutScale = mLayoutScale;
 839         mLayoutScale = 1f;
 840         int scrollRange = getScrollRange();
 841 
 842         // Again, we adjust the wallpaper offset to be consistent between values of mLayoutScale
 843         float adjustedScrollX = Math.max(0, Math.min(mScrollX, mMaxScrollX));
 844         adjustedScrollX *= mWallpaperScrollRatio;
 845         mLayoutScale = layoutScale;
 846 
 847         float scrollProgress =
 848             adjustedScrollX / (float) scrollRange;
 849 
 850         if (LauncherApplication.isScreenLarge() &amp;&amp; mIsStaticWallpaper) {
 851             // The wallpaper travel width is how far, from left to right, the wallpaper will move
 852             // at this orientation. On tablets in portrait mode we don&#x27;t move all the way to the
 853             // edges of the wallpaper, or otherwise the parallax effect would be too strong.
 854             int wallpaperTravelWidth = Math.min(mWallpaperTravelWidth, mWallpaperWidth);
 855 
 856         float offsetInDips = wallpaperTravelWidth * scrollProgress +
 857             (mWallpaperWidth - wallpaperTravelWidth) / 2; // center it
 858         float offset = offsetInDips / (float) mWallpaperWidth;
 859         return offset;
 860         } else {
 861             return scrollProgress;
 862         }
 863     }
 864 
 865     private void syncWallpaperOffsetWithScroll() {
 866         final boolean enableWallpaperEffects = isHardwareAccelerated();
 867         if (enableWallpaperEffects) {
 868             mWallpaperOffset.setFinalX(wallpaperOffsetForCurrentScroll());
 869         }
 870     }
 871 
 872     public void updateWallpaperOffsetImmediately() {
 873         mUpdateWallpaperOffsetImmediately = true;
 874     }
 875 
 876     private void updateWallpaperOffsets() {
 877         boolean updateNow = false;
 878         boolean keepUpdating = true;
 879         if (mUpdateWallpaperOffsetImmediately) {
 880             updateNow = true;
 881             keepUpdating = false;
 882             mWallpaperOffset.jumpToFinal();
 883             mUpdateWallpaperOffsetImmediately = false;
 884         } else {
 885             updateNow = keepUpdating = mWallpaperOffset.computeScrollOffset();
 886         }
 887         if (updateNow) {
 888             if (mWindowToken != null) {
 889                 mWallpaperManager.setWallpaperOffsets(mWindowToken,
 890                         mWallpaperOffset.getCurrX(), mWallpaperOffset.getCurrY());
 891             }
 892         }
 893         if (keepUpdating) {
 894             invalidate();
 895         }
 896     }
 897 
 898     @Override
 899     protected void updateCurrentPageScroll() {
 900         super.updateCurrentPageScroll();
 901         computeWallpaperScrollRatio(mCurrentPage);
 902     }
 903 
 904     @Override
 905     protected void snapToPage(int whichPage) {
 906         super.snapToPage(whichPage);
 907         computeWallpaperScrollRatio(whichPage);
 908     }
 909 
 910     private void computeWallpaperScrollRatio(int page) {
 911         // Here, we determine what the desired scroll would be with and without a layout scale,
 912         // and compute a ratio between the two. This allows us to adjust the wallpaper offset
 913         // as though there is no layout scale.
 914         float layoutScale = mLayoutScale;
 915         int scaled = getChildOffset(page) - getRelativeChildOffset(page);
 916         mLayoutScale = 1.0f;
 917         float unscaled = getChildOffset(page) - getRelativeChildOffset(page);
 918         mLayoutScale = layoutScale;
 919         if (scaled &gt; 0) {
 920             mWallpaperScrollRatio = (1.0f * unscaled) / scaled;
 921         } else {
 922             mWallpaperScrollRatio = 1f;
 923         }
 924     }
 925 
 926     class WallpaperOffsetInterpolator {
 927         float mFinalHorizontalWallpaperOffset = 0.0f;
 928         float mFinalVerticalWallpaperOffset = 0.5f;
 929         float mHorizontalWallpaperOffset = 0.0f;
 930         float mVerticalWallpaperOffset = 0.5f;
 931         long mLastWallpaperOffsetUpdateTime;
 932         boolean mIsMovingFast;
 933         boolean mOverrideHorizontalCatchupConstant;
 934         float mHorizontalCatchupConstant = 0.35f;
 935         float mVerticalCatchupConstant = 0.35f;
 936 
 937         public WallpaperOffsetInterpolator() {
 938         }
 939 
 940         public void setOverrideHorizontalCatchupConstant(boolean override) {
 941             mOverrideHorizontalCatchupConstant = override;
 942         }
 943 
 944         public void setHorizontalCatchupConstant(float f) {
 945             mHorizontalCatchupConstant = f;
 946         }
 947 
 948         public void setVerticalCatchupConstant(float f) {
 949             mVerticalCatchupConstant = f;
 950         }
 951 
 952         public boolean computeScrollOffset() {
 953             if (Float.compare(mHorizontalWallpaperOffset, mFinalHorizontalWallpaperOffset) == 0 &amp;&amp;
 954                     Float.compare(mVerticalWallpaperOffset, mFinalVerticalWallpaperOffset) == 0) {
 955                 mIsMovingFast = false;
 956                 return false;
 957             }
 958             boolean isLandscape = mDisplayWidth &gt; mDisplayHeight;
 959 
 960             long currentTime = System.currentTimeMillis();
 961             long timeSinceLastUpdate = currentTime - mLastWallpaperOffsetUpdateTime;
 962             timeSinceLastUpdate = Math.min((long) (1000/30f), timeSinceLastUpdate);
 963             timeSinceLastUpdate = Math.max(1L, timeSinceLastUpdate);
 964 
 965             float xdiff = Math.abs(mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset);
 966             if (!mIsMovingFast &amp;&amp; xdiff &gt; 0.07) {
 967                 mIsMovingFast = true;
 968             }
 969 
 970             float fractionToCatchUpIn1MsHorizontal;
 971             if (mOverrideHorizontalCatchupConstant) {
 972                 fractionToCatchUpIn1MsHorizontal = mHorizontalCatchupConstant;
 973             } else if (mIsMovingFast) {
 974                 fractionToCatchUpIn1MsHorizontal = isLandscape ? 0.5f : 0.75f;
 975             } else {
 976                 // slow
 977                 fractionToCatchUpIn1MsHorizontal = isLandscape ? 0.27f : 0.5f;
 978             }
 979             float fractionToCatchUpIn1MsVertical = mVerticalCatchupConstant;
 980 
 981             fractionToCatchUpIn1MsHorizontal /= 33f;
 982             fractionToCatchUpIn1MsVertical /= 33f;
 983 
 984             final float UPDATE_THRESHOLD = 0.00001f;
 985             float hOffsetDelta = mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset;
 986             float vOffsetDelta = mFinalVerticalWallpaperOffset - mVerticalWallpaperOffset;
 987             boolean jumpToFinalValue = Math.abs(hOffsetDelta) &lt; UPDATE_THRESHOLD &amp;&amp;
 988                 Math.abs(vOffsetDelta) &lt; UPDATE_THRESHOLD;
 989 
 990             // Don&#x27;t have any lag between workspace and wallpaper on non-large devices
 991             if (!LauncherApplication.isScreenLarge() || jumpToFinalValue) {
 992                 mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
 993                 mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
 994             } else {
 995                 float percentToCatchUpVertical =
 996                     Math.min(1.0f, timeSinceLastUpdate * fractionToCatchUpIn1MsVertical);
 997                 float percentToCatchUpHorizontal =
 998                     Math.min(1.0f, timeSinceLastUpdate * fractionToCatchUpIn1MsHorizontal);
 999                 mHorizontalWallpaperOffset += percentToCatchUpHorizontal * hOffsetDelta;
1000                 mVerticalWallpaperOffset += percentToCatchUpVertical * vOffsetDelta;
1001             }
1002 
1003             mLastWallpaperOffsetUpdateTime = System.currentTimeMillis();
1004             return true;
1005         }
1006 
1007         public float getCurrX() {
1008             return mHorizontalWallpaperOffset;
1009         }
1010 
1011         public float getFinalX() {
1012             return mFinalHorizontalWallpaperOffset;
1013         }
1014 
1015         public float getCurrY() {
1016             return mVerticalWallpaperOffset;
1017         }
1018 
1019         public float getFinalY() {
1020             return mFinalVerticalWallpaperOffset;
1021         }
1022 
1023         public void setFinalX(float x) {
1024             mFinalHorizontalWallpaperOffset = Math.max(0f, Math.min(x, 1.0f));
1025         }
1026 
1027         public void setFinalY(float y) {
1028             mFinalVerticalWallpaperOffset = Math.max(0f, Math.min(y, 1.0f));
1029         }
1030 
1031         public void jumpToFinal() {
1032             mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
1033             mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
1034         }
1035     }
1036 
1037     @Override
1038     public void computeScroll() {
1039         super.computeScroll();
1040         syncWallpaperOffsetWithScroll();
1041     }
1042 
1043     void showOutlines() {
1044         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1045             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1046             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1047             mChildrenOutlineFadeInAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);
1048             mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1049             mChildrenOutlineFadeInAnimation.start();
1050         }
1051     }
1052 
1053     void hideOutlines() {
1054         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1055             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1056             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
<abbr title="1057             mChildrenOutlineFadeOutAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);">1057             mChildrenOutlineFadeOutAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f)</abbr>
1058             mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1059             mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1060             mChildrenOutlineFadeOutAnimation.start();
1061         }
1062     }
1063 
1064     public void showOutlinesTemporarily() {
1065         if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1066             snapToPage(mCurrentPage);
1067         }
1068     }
1069 
1070     public void setChildrenOutlineAlpha(float alpha) {
1071         mChildrenOutlineAlpha = alpha;
1072         for (int i = 0; i &lt; getChildCount(); i++) {
1073             CellLayout cl = (CellLayout) getChildAt(i);
1074             cl.setBackgroundAlpha(alpha);
1075         }
1076     }
1077 
1078     public float getChildrenOutlineAlpha() {
1079         return mChildrenOutlineAlpha;
1080     }
1081 
1082     void disableBackground() {
1083         mDrawBackground = false;
1084     }
1085     void enableBackground() {
1086         mDrawBackground = true;
1087     }
1088 
1089     private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1090         if (mBackground == null) return;
1091         if (mBackgroundFadeInAnimation != null) {
1092             mBackgroundFadeInAnimation.cancel();
1093             mBackgroundFadeInAnimation = null;
1094         }
1095         if (mBackgroundFadeOutAnimation != null) {
1096             mBackgroundFadeOutAnimation.cancel();
1097             mBackgroundFadeOutAnimation = null;
1098         }
1099         float startAlpha = getBackgroundAlpha();
1100         if (finalAlpha != startAlpha) {
1101             if (animated) {
1102                 mBackgroundFadeOutAnimation = ValueAnimator.ofFloat(startAlpha, finalAlpha);
1103                 mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1104                     public void onAnimationUpdate(ValueAnimator animation) {
1105                         setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1106                     }
1107                 });
1108                 mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1109                 mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1110                 mBackgroundFadeOutAnimation.start();
1111             } else {
1112                 setBackgroundAlpha(finalAlpha);
1113             }
1114         }
1115     }
1116 
1117     public void setBackgroundAlpha(float alpha) {
1118         if (alpha != mBackgroundAlpha) {
1119             mBackgroundAlpha = alpha;
1120             invalidate();
1121         }
1122     }
1123 
1124     public float getBackgroundAlpha() {
1125         return mBackgroundAlpha;
1126     }
1127 
1128     /**
1129      * Due to 3D transformations, if two CellLayouts are theoretically touching each other,
1130      * on the xy plane, when one is rotated along the y-axis, the gap between them is perceived
1131      * as being larger. This method computes what offset the rotated view should be translated
1132      * in order to minimize this perceived gap.
1133      * @param degrees Angle of the view
1134      * @param width Width of the view
1135      * @param height Height of the view
1136      * @return Offset to be used in a View.setTranslationX() call
1137      */
1138     private float getOffsetXForRotation(float degrees, int width, int height) {
1139         mMatrix.reset();
1140         mCamera.save();
1141         mCamera.rotateY(Math.abs(degrees));
1142         mCamera.getMatrix(mMatrix);
1143         mCamera.restore();
1144 
1145         mMatrix.preTranslate(-width * 0.5f, -height * 0.5f);
1146         mMatrix.postTranslate(width * 0.5f, height * 0.5f);
1147         mTempFloat2[0] = width;
1148         mTempFloat2[1] = height;
1149         mMatrix.mapPoints(mTempFloat2);
1150         return (width - mTempFloat2[0]) * (degrees &gt; 0.0f ? 1.0f : -1.0f);
1151     }
1152 
1153     float backgroundAlphaInterpolator(float r) {
1154         float pivotA = 0.1f;
1155         float pivotB = 0.4f;
1156         if (r &lt; pivotA) {
1157             return 0;
1158         } else if (r &gt; pivotB) {
1159             return 1.0f;
1160         } else {
1161             return (r - pivotA)/(pivotB - pivotA);
1162         }
1163     }
1164 
1165     float overScrollBackgroundAlphaInterpolator(float r) {
1166         float threshold = 0.08f;
1167 
1168         if (r &gt; mOverScrollMaxBackgroundAlpha) {
1169             mOverScrollMaxBackgroundAlpha = r;
1170         } else if (r &lt; mOverScrollMaxBackgroundAlpha) {
1171             r = mOverScrollMaxBackgroundAlpha;
1172         }
1173 
1174         return Math.min(r / threshold, 1.0f);
1175     }
1176 
1177     private void screenScrolledLargeUI(int screenCenter) {
1178         if (isSwitchingState()) return;
1179         boolean isInOverscroll = false;
1180         for (int i = 0; i &lt; getChildCount(); i++) {
1181             CellLayout cl = (CellLayout) getChildAt(i);
1182             if (cl != null) {
1183                 float scrollProgress = getScrollProgress(screenCenter, cl, i);
1184                 float rotation = WORKSPACE_ROTATION * scrollProgress;
1185                 float translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1186 
1187                 // If the current page (i) is being over scrolled, we use a different
1188                 // set of rules for setting the background alpha multiplier.
1189                 if (!isSmall()) {
1190                     if ((mOverScrollX &lt; 0 &amp;&amp; i == 0) || (mOverScrollX &gt; mMaxScrollX &amp;&amp;
1191                             i == getChildCount() -1)) {
1192                         isInOverscroll = true;
1193                         rotation *= -1;
1194                         cl.setBackgroundAlphaMultiplier(
1195                                 overScrollBackgroundAlphaInterpolator(Math.abs(scrollProgress)));
1196                         mOverScrollPageIndex = i;
1197                         cl.setOverScrollAmount(Math.abs(scrollProgress), i == 0);
1198                         cl.setPivotX(cl.getMeasuredWidth() * (i == 0 ? 0.75f : 0.25f));
1199                         cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1200                         cl.setOverscrollTransformsDirty(true);
1201                     } else if (mOverScrollPageIndex != i) {
1202                         cl.setBackgroundAlphaMultiplier(
1203                                 backgroundAlphaInterpolator(Math.abs(scrollProgress)));
1204                     }
1205                 }
1206                 cl.setTranslationX(translationX);
1207                 cl.setRotationY(rotation);
1208                 if (mFadeInAdjacentScreens &amp;&amp; !isSmall()) {
1209                     float alpha = 1 - Math.abs(scrollProgress);
1210                     cl.setAlpha(alpha);
1211                 }
1212             }
1213         }
1214         if (!isSwitchingState() &amp;&amp; !isInOverscroll) {
1215             ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1216             ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1217         }
1218         invalidate();
1219     }
1220 
1221     private void screenScrolledStandardUI(int screenCenter) {
1222         if (mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX) {
1223             int index = mOverScrollX &lt; 0 ? 0 : getChildCount() - 1;
1224             CellLayout cl = (CellLayout) getChildAt(index);
1225             float scrollProgress = getScrollProgress(screenCenter, cl, index);
1226             cl.setOverScrollAmount(Math.abs(scrollProgress), index == 0);
1227             float rotation = - WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1228             cl.setCameraDistance(mDensity * CAMERA_DISTANCE);
1229             cl.setPivotX(cl.getMeasuredWidth() * (index == 0 ? 0.75f : 0.25f));
1230             cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1231             cl.setRotationY(rotation);
1232             cl.setOverscrollTransformsDirty(true);
1233             setFadeForOverScroll(Math.abs(scrollProgress));
1234         } else {
1235             if (mOverscrollFade != 0) {
1236                 setFadeForOverScroll(0);
1237             }
1238             // We don&#x27;t want to mess with the translations during transitions
1239             if (!isSwitchingState()) {
1240                 ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1241                 ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1242             }
1243         }
1244     }
1245 
1246     @Override
1247     protected void screenScrolled(int screenCenter) {
1248         if (LauncherApplication.isScreenLarge()) {
1249             // We don&#x27;t call super.screenScrolled() here because we handle the adjacent pages alpha
1250             // ourselves (for efficiency), and there are no scrolling indicators to update.
1251             screenScrolledLargeUI(screenCenter);
1252         } else {
1253             super.screenScrolled(screenCenter);
1254             screenScrolledStandardUI(screenCenter);
1255         }
1256     }
1257 
1258     @Override
1259     protected void overScroll(float amount) {
1260         if (LauncherApplication.isScreenLarge()) {
1261             dampedOverScroll(amount);
1262         } else {
1263             acceleratedOverScroll(amount);
1264         }
1265     }
1266 
1267     protected void onAttachedToWindow() {
1268         super.onAttachedToWindow();
1269         mWindowToken = getWindowToken();
1270         computeScroll();
1271         mDragController.setWindowToken(mWindowToken);
1272     }
1273 
1274     protected void onDetachedFromWindow() {
1275         mWindowToken = null;
1276     }
1277 
1278     @Override
1279     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1280         if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1281             mUpdateWallpaperOffsetImmediately = true;
1282         }
1283         super.onLayout(changed, left, top, right, bottom);
1284     }
1285 
1286     @Override
1287     protected void onDraw(Canvas canvas) {
1288         updateWallpaperOffsets();
1289 
1290         // Draw the background gradient if necessary
1291         if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1292             int alpha = (int) (mBackgroundAlpha * 255);
1293             mBackground.setAlpha(alpha);
1294             mBackground.setBounds(mScrollX, 0, mScrollX + getMeasuredWidth(),
1295                     getMeasuredHeight());
1296             mBackground.draw(canvas);
1297         }
1298 
1299         super.onDraw(canvas);
1300     }
1301 
1302     boolean isDrawingBackgroundGradient() {
1303         return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1304     }
1305 
1306     @Override
1307     protected void dispatchDraw(Canvas canvas) {
1308         super.dispatchDraw(canvas);
1309 
1310         if (mInScrollArea &amp;&amp; !LauncherApplication.isScreenLarge()) {
1311             final int width = getWidth();
1312             final int height = getHeight();
1313             final int pageHeight = getChildAt(0).getHeight();
1314 
1315             // Set the height of the outline to be the height of the page
1316             final int offset = (height - pageHeight - mPaddingTop - mPaddingBottom) / 2;
1317             final int paddingTop = mPaddingTop + offset;
1318             final int paddingBottom = mPaddingBottom + offset;
1319 
1320             final int page = (mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage);
1321             final CellLayout leftPage = (CellLayout) getChildAt(page - 1);
1322             final CellLayout rightPage = (CellLayout) getChildAt(page + 1);
1323 
1324             if (leftPage != null &amp;&amp; leftPage.getIsDragOverlapping()) {
1325                 final Drawable d = getResources().getDrawable(R.drawable.page_hover_left_holo);
1326                 d.setBounds(mScrollX, paddingTop, mScrollX + d.getIntrinsicWidth(),
1327                         height - paddingBottom);
1328                 d.draw(canvas);
1329             } else if (rightPage != null &amp;&amp; rightPage.getIsDragOverlapping()) {
1330                 final Drawable d = getResources().getDrawable(R.drawable.page_hover_right_holo);
1331                 d.setBounds(mScrollX + width - d.getIntrinsicWidth(), paddingTop, mScrollX + width,
1332                         height - paddingBottom);
1333                 d.draw(canvas);
1334             }
1335         }
1336     }
1337 
1338     @Override
1339     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1340         if (!mLauncher.isAllAppsVisible()) {
1341             final Folder openFolder = getOpenFolder();
1342             if (openFolder != null) {
1343                 return openFolder.requestFocus(direction, previouslyFocusedRect);
1344             } else {
1345                 return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1346             }
1347         }
1348         return false;
1349     }
1350 
1351     @Override
1352     public int getDescendantFocusability() {
1353         if (isSmall()) {
1354             return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1355         }
1356         return super.getDescendantFocusability();
1357     }
1358 
1359     @Override
1360     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1361         if (!mLauncher.isAllAppsVisible()) {
1362             final Folder openFolder = getOpenFolder();
1363             if (openFolder != null) {
1364                 openFolder.addFocusables(views, direction);
1365             } else {
1366                 super.addFocusables(views, direction, focusableMode);
1367             }
1368         }
1369     }
1370 
1371     public boolean isSmall() {
1372         return mState == State.SMALL || mState == State.SPRING_LOADED;
1373     }
1374 
1375     void enableChildrenCache(int fromPage, int toPage) {
1376         if (fromPage &gt; toPage) {
1377             final int temp = fromPage;
1378             fromPage = toPage;
1379             toPage = temp;
1380         }
1381 
1382         final int screenCount = getChildCount();
1383 
1384         fromPage = Math.max(fromPage, 0);
1385         toPage = Math.min(toPage, screenCount - 1);
1386 
1387         for (int i = fromPage; i &lt;= toPage; i++) {
1388             final CellLayout layout = (CellLayout) getChildAt(i);
1389             layout.setChildrenDrawnWithCacheEnabled(true);
1390             layout.setChildrenDrawingCacheEnabled(true);
1391         }
1392     }
1393 
1394     void clearChildrenCache() {
1395         final int screenCount = getChildCount();
1396         for (int i = 0; i &lt; screenCount; i++) {
1397             final CellLayout layout = (CellLayout) getChildAt(i);
1398             layout.setChildrenDrawnWithCacheEnabled(false);
1399             // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1400             if (!isHardwareAccelerated()) {
1401                 layout.setChildrenDrawingCacheEnabled(false);
1402             }
1403         }
1404     }
1405 
1406     private void updateChildrenLayersEnabled() {
1407         boolean small = isSmall() || mIsSwitchingState;
1408         boolean dragging = mAnimatingViewIntoPlace || mIsDragOccuring;
1409         boolean enableChildrenLayers = small || dragging || isPageMoving();
1410 
1411         if (enableChildrenLayers != mChildrenLayersEnabled) {
1412             mChildrenLayersEnabled = enableChildrenLayers;
1413                 for (int i = 0; i &lt; getPageCount(); i++) {
1414                 ((ViewGroup)getChildAt(i)).setChildrenLayersEnabled(mChildrenLayersEnabled);
1415             }
1416         }
1417     }
1418 
1419     protected void onWallpaperTap(MotionEvent ev) {
1420         final int[] position = mTempCell;
1421         getLocationOnScreen(position);
1422 
1423         int pointerIndex = ev.getActionIndex();
1424         position[0] += (int) ev.getX(pointerIndex);
1425         position[1] += (int) ev.getY(pointerIndex);
1426 
1427         mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1428                 ev.getAction() == MotionEvent.ACTION_UP
1429                         ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1430                 position[0], position[1], 0, null);
1431     }
1432 
1433     /*
1434      * This interpolator emulates the rate at which the perceived scale of an object changes
1435      * as its distance from a camera increases. When this interpolator is applied to a scale
1436      * animation on a view, it evokes the sense that the object is shrinking due to moving away
1437      * from the camera.
1438      */
1439     static class ZInterpolator implements TimeInterpolator {
1440         private float focalLength;
1441 
1442         public ZInterpolator(float foc) {
1443             focalLength = foc;
1444         }
1445 
1446         public float getInterpolation(float input) {
1447             return (1.0f - focalLength / (focalLength + input)) /
1448                 (1.0f - focalLength / (focalLength + 1.0f));
1449         }
1450     }
1451 
1452     /*
1453      * The exact reverse of ZInterpolator.
1454      */
1455     static class InverseZInterpolator implements TimeInterpolator {
1456         private ZInterpolator zInterpolator;
1457         public InverseZInterpolator(float foc) {
1458             zInterpolator = new ZInterpolator(foc);
1459         }
1460         public float getInterpolation(float input) {
1461             return 1 - zInterpolator.getInterpolation(1 - input);
1462         }
1463     }
1464 
1465     /*
1466      * ZInterpolator compounded with an ease-out.
1467      */
1468     static class ZoomOutInterpolator implements TimeInterpolator {
1469         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75f);
1470         private final ZInterpolator zInterpolator = new ZInterpolator(0.13f);
1471 
1472         public float getInterpolation(float input) {
1473             return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1474         }
1475     }
1476 
1477     /*
1478      * InvereZInterpolator compounded with an ease-out.
1479      */
1480     static class ZoomInInterpolator implements TimeInterpolator {
1481         private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35f);
1482         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0f);
1483 
1484         public float getInterpolation(float input) {
1485             return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1486         }
1487     }
1488 
1489     private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1490 
1491     /*
1492     *
1493     * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1494     * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1495     *
1496     * These methods mark the appropriate pages as accepting drops (which alters their visual
1497     * appearance).
1498     *
1499     */
1500     public void onDragStartedWithItem(View v) {
1501         final Canvas canvas = new Canvas();
1502 
1503         // The outline is used to visualize where the item will land if dropped
1504         mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);
1505     }
1506 
1507     public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, Paint alphaClipPaint) {
1508         final Canvas canvas = new Canvas();
1509 
1510         int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1511 
1512         // The outline is used to visualize where the item will land if dropped
1513         mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0],
1514                 size[1], alphaClipPaint);
1515     }
1516 
1517     // we call this method whenever a drag and drop in Launcher finishes, even if Workspace was
1518     // never dragged over
1519     public void onDragStopped(boolean success) {
1520         // In the success case, DragController has already called onDragExit()
1521         if (!success) {
1522             doDragExit(null);
1523         }
1524     }
1525 
1526     public void exitWidgetResizeMode() {
1527         DragLayer dragLayer = mLauncher.getDragLayer();
1528         dragLayer.clearAllResizeFrames();
1529     }
1530 
1531     private void initAnimationArrays() {
1532         final int childCount = getChildCount();
1533         if (mOldTranslationXs != null) return;
1534         mOldTranslationXs = new float[childCount];
1535         mOldTranslationYs = new float[childCount];
1536         mOldScaleXs = new float[childCount];
1537         mOldScaleYs = new float[childCount];
1538         mOldBackgroundAlphas = new float[childCount];
1539         mOldBackgroundAlphaMultipliers = new float[childCount];
1540         mOldAlphas = new float[childCount];
1541         mOldRotationYs = new float[childCount];
1542         mNewTranslationXs = new float[childCount];
1543         mNewTranslationYs = new float[childCount];
1544         mNewScaleXs = new float[childCount];
1545         mNewScaleYs = new float[childCount];
1546         mNewBackgroundAlphas = new float[childCount];
1547         mNewBackgroundAlphaMultipliers = new float[childCount];
1548         mNewAlphas = new float[childCount];
1549         mNewRotationYs = new float[childCount];
1550     }
1551 
1552     Animator getChangeStateAnimation(final State state, boolean animated) {
1553         return getChangeStateAnimation(state, animated, 0);
1554     }
1555 
1556     Animator getChangeStateAnimation(final State state, boolean animated, int delay) {
1557         if (mState == state) {
1558             return null;
1559         }
1560 
1561         // Initialize animation arrays for the first time if necessary
1562         initAnimationArrays();
1563 
1564         AnimatorSet anim = animated ? new AnimatorSet() : null;
1565 
1566         // Stop any scrolling, move to the current page right away
1567         setCurrentPage((mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage);
1568 
1569         final State oldState = mState;
1570         final boolean oldStateIsNormal = (oldState == State.NORMAL);
1571         final boolean oldStateIsSmall = (oldState == State.SMALL);
1572         mState = state;
1573         final boolean stateIsNormal = (state == State.NORMAL);
1574         final boolean stateIsSpringLoaded = (state == State.SPRING_LOADED);
1575         final boolean stateIsSmall = (state == State.SMALL);
1576         float finalScaleFactor = 1.0f;
1577         float finalBackgroundAlpha = stateIsSpringLoaded ? 1.0f : 0f;
1578         float translationX = 0;
1579         float translationY = 0;
1580         boolean zoomIn = true;
1581 
1582         if (state != State.NORMAL) {
1583             finalScaleFactor = mSpringLoadedShrinkFactor - (stateIsSmall ? 0.1f : 0);
1584             if (oldStateIsNormal &amp;&amp; stateIsSmall) {
1585                 zoomIn = false;
1586                 setLayoutScale(finalScaleFactor);
1587                 updateChildrenLayersEnabled();
1588             } else {
1589                 finalBackgroundAlpha = 1.0f;
1590                 setLayoutScale(finalScaleFactor);
1591             }
1592         } else {
1593             setLayoutScale(1.0f);
1594         }
1595 
1596         final int duration = zoomIn ?
1597                 getResources().getInteger(R.integer.config_workspaceUnshrinkTime) :
1598                 getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
1599         for (int i = 0; i &lt; getChildCount(); i++) {
1600             final CellLayout cl = (CellLayout) getChildAt(i);
1601             float rotation = 0f;
1602             float initialAlpha = cl.getAlpha();
1603             float finalAlphaMultiplierValue = 1f;
1604             float finalAlpha = (!mFadeInAdjacentScreens || stateIsSpringLoaded ||
1605                     (i == mCurrentPage)) ? 1f : 0f;
1606 
1607             // Determine the pages alpha during the state transition
1608             if ((oldStateIsSmall &amp;&amp; stateIsNormal) ||
1609                 (oldStateIsNormal &amp;&amp; stateIsSmall)) {
1610                 // To/from workspace - only show the current page unless the transition is not
1611                 //                     animated and the animation end callback below doesn&#x27;t run
1612                 if (i == mCurrentPage || !animated) {
1613                     finalAlpha = 1f;
1614                     finalAlphaMultiplierValue = 0f;
1615                 } else {
1616                     initialAlpha = 0f;
1617                     finalAlpha = 0f;
1618                 }
1619             }
1620 
1621             // Update the rotation of the screen (don&#x27;t apply rotation on Phone UI)
1622             if (LauncherApplication.isScreenLarge()) {
1623                 if (i &lt; mCurrentPage) {
1624                     rotation = WORKSPACE_ROTATION;
1625                 } else if (i &gt; mCurrentPage) {
1626                     rotation = -WORKSPACE_ROTATION;
1627                 }
1628             }
1629 
1630             // If the screen is not xlarge, then don&#x27;t rotate the CellLayouts
1631             // NOTE: If we don&#x27;t update the side pages alpha, then we should not hide the side
1632             //       pages. see unshrink().
1633             if (LauncherApplication.isScreenLarge()) {
1634                 translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1635             }
1636 
1637             mOldAlphas[i] = initialAlpha;
1638             mNewAlphas[i] = finalAlpha;
1639             if (animated) {
1640                 mOldTranslationXs[i] = cl.getTranslationX();
1641                 mOldTranslationYs[i] = cl.getTranslationY();
1642                 mOldScaleXs[i] = cl.getScaleX();
1643                 mOldScaleYs[i] = cl.getScaleY();
1644                 mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
1645                 mOldBackgroundAlphaMultipliers[i] = cl.getBackgroundAlphaMultiplier();
1646                 mOldRotationYs[i] = cl.getRotationY();
1647 
1648                 mNewTranslationXs[i] = translationX;
1649                 mNewTranslationYs[i] = translationY;
1650                 mNewScaleXs[i] = finalScaleFactor;
1651                 mNewScaleYs[i] = finalScaleFactor;
1652                 mNewBackgroundAlphas[i] = finalBackgroundAlpha;
1653                 mNewBackgroundAlphaMultipliers[i] = finalAlphaMultiplierValue;
1654                 mNewRotationYs[i] = rotation;
1655             } else {
1656                 cl.setTranslationX(translationX);
1657                 cl.setTranslationY(translationY);
1658                 cl.setScaleX(finalScaleFactor);
1659                 cl.setScaleY(finalScaleFactor);
1660                 cl.setBackgroundAlpha(finalBackgroundAlpha);
1661                 cl.setBackgroundAlphaMultiplier(finalAlphaMultiplierValue);
1662                 cl.setAlpha(finalAlpha);
1663                 cl.setRotationY(rotation);
1664             }
1665         }
1666 
1667         if (animated) {
1668             for (int index = 0; index &lt; getChildCount(); index++) {
1669                 final int i = index;
1670                 final CellLayout cl = (CellLayout) getChildAt(i);
1671                 if (mOldAlphas[i] == 0 &amp;&amp; mNewAlphas[i] == 0) {
1672                     cl.setTranslationX(mNewTranslationXs[i]);
1673                     cl.setTranslationY(mNewTranslationYs[i]);
1674                     cl.setScaleX(mNewScaleXs[i]);
1675                     cl.setScaleY(mNewScaleYs[i]);
1676                     cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);
1677                     cl.setBackgroundAlphaMultiplier(mNewBackgroundAlphaMultipliers[i]);
1678                     cl.setAlpha(mNewAlphas[i]);
1679                     cl.setRotationY(mNewRotationYs[i]);
1680                 } else {
1681                     LauncherViewPropertyAnimator a = new LauncherViewPropertyAnimator(cl);
1682                     a.translationX(mNewTranslationXs[i])
1683                         .translationY(mNewTranslationYs[i])
1684                         .scaleX(mNewScaleXs[i])
1685                         .scaleY(mNewScaleYs[i])
1686                         .setDuration(duration)
1687                         .setInterpolator(mZoomInInterpolator);
1688                     if (mOldAlphas[i] != mNewAlphas[i]) {
1689                         a.alpha(mNewAlphas[i]);
1690                     }
1691                     anim.play(a);
1692                     if (mOldRotationYs[i] != 0 || mNewRotationYs[i] != 0) {
1693                         ValueAnimator rotate = ValueAnimator.ofFloat(0f, 1f).setDuration(duration);
1694                         rotate.setInterpolator(new DecelerateInterpolator(2.0f));
1695                         rotate.addUpdateListener(new LauncherAnimatorUpdateListener() {
1696                                 public void onAnimationUpdate(float a, float b) {
1697                                     cl.setRotationY(a * mOldRotationYs[i] + b * mNewRotationYs[i]);
1698                                 }
1699                             });
1700                         anim.play(rotate);
1701                     }
1702                     if (mOldBackgroundAlphas[i] != 0 ||
1703                         mNewBackgroundAlphas[i] != 0 ||
1704                         mOldBackgroundAlphaMultipliers[i] != 0 ||
1705                         mNewBackgroundAlphaMultipliers[i] != 0) {
1706                         ValueAnimator bgAnim = ValueAnimator.ofFloat(0f, 1f).setDuration(duration);
1707                         bgAnim.setInterpolator(mZoomInInterpolator);
1708                         bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
1709                                 public void onAnimationUpdate(float a, float b) {
1710                                     cl.setBackgroundAlpha(
1711                                             a * mOldBackgroundAlphas[i] +
1712                                             b * mNewBackgroundAlphas[i]);
1713                                     cl.setBackgroundAlphaMultiplier(
1714                                             a * mOldBackgroundAlphaMultipliers[i] +
1715                                             b * mNewBackgroundAlphaMultipliers[i]);
1716                                 }
1717                             });
1718                         anim.play(bgAnim);
1719                     }
1720                 }
1721             }
1722             anim.setStartDelay(delay);
1723         }
1724 
1725         if (stateIsSpringLoaded) {
1726             // Right now we&#x27;re covered by Apps Customize
1727             // Show the background gradient immediately, so the gradient will
1728             // be showing once AppsCustomize disappears
1729             animateBackgroundGradient(getResources().getInteger(
1730                     R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, false);
1731         } else {
1732             // Fade the background gradient away
1733             animateBackgroundGradient(0f, true);
1734         }
1735         return anim;
1736     }
1737 
1738     @Override
1739     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
1740         mIsSwitchingState = true;
1741     }
1742 
1743     @Override
1744     public void onLauncherTransitionStep(Launcher l, float t) {
1745         mTransitionProgress = t;
1746     }
1747 
1748     @Override
1749     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
1750         mIsSwitchingState = false;
1751         mWallpaperOffset.setOverrideHorizontalCatchupConstant(false);
1752         updateChildrenLayersEnabled();
1753         // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure
1754         // ensure that only the current page is visible during (and subsequently, after) the
1755         // transition animation.  If fade adjacent pages is disabled, then re-enable the page
1756         // visibility after the transition animation.
1757         if (!mFadeInAdjacentScreens) {
1758             for (int i = 0; i &lt; getChildCount(); i++) {
1759                 final CellLayout cl = (CellLayout) getChildAt(i);
1760                 cl.setAlpha(1f);
1761             }
1762         }
1763     }
1764 
1765     @Override
1766     public View getContent() {
1767         return this;
1768     }
1769 
1770     /**
1771      * Draw the View v into the given Canvas.
1772      *
1773      * @param v the view to draw
1774      * @param destCanvas the canvas to draw on
1775      * @param padding the horizontal and vertical padding to use when drawing
1776      */
1777     private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
1778         final Rect clipRect = mTempRect;
1779         v.getDrawingRect(clipRect);
1780 
1781         boolean textVisible = false;
1782 
1783         destCanvas.save();
1784         if (v instanceof TextView &amp;&amp; pruneToDrawable) {
1785             Drawable d = ((TextView) v).getCompoundDrawables()[1];
1786             clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
1787             destCanvas.translate(padding / 2, padding / 2);
1788             d.draw(destCanvas);
1789         } else {
1790             if (v instanceof FolderIcon) {
1791                 // For FolderIcons the text can bleed into the icon area, and so we need to
1792                 // hide the text completely (which can&#x27;t be achieved by clipping).
1793                 if (((FolderIcon) v).getTextVisible()) {
1794                     ((FolderIcon) v).setTextVisible(false);
1795                     textVisible = true;
1796                 }
1797             } else if (v instanceof BubbleTextView) {
1798                 final BubbleTextView tv = (BubbleTextView) v;
1799                 clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
1800                         tv.getLayout().getLineTop(0);
1801             } else if (v instanceof TextView) {
1802                 final TextView tv = (TextView) v;
1803                 clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
1804                         tv.getLayout().getLineTop(0);
1805             }
1806             destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
1807             destCanvas.clipRect(clipRect, Op.REPLACE);
1808             v.draw(destCanvas);
1809 
1810             // Restore text visibility of FolderIcon if necessary
1811             if (textVisible) {
1812                 ((FolderIcon) v).setTextVisible(true);
1813             }
1814         }
1815         destCanvas.restore();
1816     }
1817 
1818     /**
1819      * Returns a new bitmap to show when the given View is being dragged around.
1820      * Responsibility for the bitmap is transferred to the caller.
1821      */
1822     public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
1823         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1824         Bitmap b;
1825 
1826         if (v instanceof TextView) {
1827             Drawable d = ((TextView) v).getCompoundDrawables()[1];
1828             b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
1829                     d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
1830         } else {
1831             b = Bitmap.createBitmap(
1832                     v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
1833         }
1834 
1835         canvas.setBitmap(b);
1836         drawDragView(v, canvas, padding, true);
1837         canvas.setBitmap(null);
1838 
1839         return b;
1840     }
1841 
1842     /**
1843      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
1844      * Responsibility for the bitmap is transferred to the caller.
1845      */
1846     private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
1847         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1848         final Bitmap b = Bitmap.createBitmap(
1849                 v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
1850 
1851         canvas.setBitmap(b);
1852         drawDragView(v, canvas, padding, true);
1853         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
1854         canvas.setBitmap(null);
1855         return b;
1856     }
1857 
1858     /**
1859      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
1860      * Responsibility for the bitmap is transferred to the caller.
1861      */
1862     private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
1863             Paint alphaClipPaint) {
1864         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1865         final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
1866         canvas.setBitmap(b);
1867 
1868         Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
1869         float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
1870                 (h - padding) / (float) orig.getHeight());
1871         int scaledWidth = (int) (scaleFactor * orig.getWidth());
1872         int scaledHeight = (int) (scaleFactor * orig.getHeight());
1873         Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
1874 
1875         // center the image
1876         dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
1877 
1878         canvas.drawBitmap(orig, src, dst, null);
1879         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
1880                 alphaClipPaint);
1881         canvas.setBitmap(null);
1882 
1883         return b;
1884     }
1885 
1886     /**
1887      * Creates a drag outline to represent a drop (that we don&#x27;t have the actual information for
1888      * yet).  May be changed in the future to alter the drop outline slightly depending on the
1889      * clip description mime data.
1890      */
1891     private Bitmap createExternalDragOutline(Canvas canvas, int padding) {
1892         Resources r = getResources();
1893         final int outlineColor = r.getColor(android.R.color.holo_blue_light);
1894         final int iconWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
1895         final int iconHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
1896         final int rectRadius = r.getDimensionPixelSize(R.dimen.external_drop_icon_rect_radius);
1897         final int inset = (int) (Math.min(iconWidth, iconHeight) * 0.2f);
1898         final Bitmap b = Bitmap.createBitmap(
1899                 iconWidth + padding, iconHeight + padding, Bitmap.Config.ARGB_8888);
1900 
1901         canvas.setBitmap(b);
1902         canvas.drawRoundRect(new RectF(inset, inset, iconWidth - inset, iconHeight - inset),
1903                 rectRadius, rectRadius, mExternalDragOutlinePaint);
1904         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
1905         canvas.setBitmap(null);
1906         return b;
1907     }
1908 
1909     void startDrag(CellLayout.CellInfo cellInfo) {
1910         View child = cellInfo.cell;
1911 
1912         // Make sure the drag was started by a long press as opposed to a long click.
1913         if (!child.isInTouchMode()) {
1914             return;
1915         }
1916 
1917         mDragInfo = cellInfo;
1918         child.setVisibility(INVISIBLE);
1919 
1920         child.clearFocus();
1921         child.setPressed(false);
1922 
1923         final Canvas canvas = new Canvas();
1924 
1925         // The outline is used to visualize where the item will land if dropped
1926         mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);
1927         beginDragShared(child, this);
1928     }
1929 
1930     public void beginDragShared(View child, DragSource source) {
1931         Resources r = getResources();
1932 
1933         // The drag bitmap follows the touch point around on the screen
1934         final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);
1935 
1936         final int bmpWidth = b.getWidth();
1937 
1938         mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
1939         final int dragLayerX = (int) mTempXY[0] + (child.getWidth() - bmpWidth) / 2;
1940         int dragLayerY = mTempXY[1] - DRAG_BITMAP_PADDING / 2;
1941 
1942         Point dragVisualizeOffset = null;
1943         Rect dragRect = null;
1944         if (child instanceof BubbleTextView || child instanceof PagedViewIcon) {
1945             int iconSize = r.getDimensionPixelSize(R.dimen.app_icon_size);
1946             int iconPaddingTop = r.getDimensionPixelSize(R.dimen.app_icon_padding_top);
1947             int top = child.getPaddingTop();
1948             int left = (bmpWidth - iconSize) / 2;
1949             int right = left + iconSize;
1950             int bottom = top + iconSize;
1951             dragLayerY += top;
1952             // Note: The drag region is used to calculate drag layer offsets, but the
1953             // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
1954             dragVisualizeOffset = new Point(-DRAG_BITMAP_PADDING / 2,
1955                     iconPaddingTop - DRAG_BITMAP_PADDING / 2);
1956             dragRect = new Rect(left, top, right, bottom);
1957         } else if (child instanceof FolderIcon) {
1958             int previewSize = r.getDimensionPixelSize(R.dimen.folder_preview_size);
1959             dragRect = new Rect(0, 0, child.getWidth(), previewSize);
1960         }
1961 
1962         // Clear the pressed state if necessary
1963         if (child instanceof BubbleTextView) {
1964             BubbleTextView icon = (BubbleTextView) child;
1965             icon.clearPressedOrFocusedBackground();
1966         }
1967 
1968         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),
1969                 DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, 1f);
1970         b.recycle();
1971 
1972         // Show the scrolling indicator when you pick up an item
1973         showScrollingIndicator(false);
1974     }
1975 
1976     void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, int screen,
1977             int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
1978         View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
1979 
1980         final int[] cellXY = new int[2];
1981         target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
1982         addInScreen(view, container, screen, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
1983         LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen, cellXY[0],
1984                 cellXY[1]);
1985     }
1986 
1987     public boolean transitionStateShouldAllowDrop() {
1988         return ((!isSwitchingState() || mTransitionProgress &gt; 0.5f) &amp;&amp; mState != State.SMALL);
1989     }
1990 
1991     /**
1992      * {@inheritDoc}
1993      */
1994     public boolean acceptDrop(DragObject d) {
1995         // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
1996         if (d.dragSource != this) {
1997             // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
1998             if (mDragTargetLayout == null) {
1999                 return false;
2000             }
2001             if (!transitionStateShouldAllowDrop()) return false;
2002 
2003             mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2004                     d.dragView, mDragViewVisualCenter);
2005 
2006             // We want the point to be mapped to the dragTarget.
2007             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2008                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2009             } else {
2010                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2011             }
2012 
2013             int spanX = 1;
2014             int spanY = 1;
2015             View ignoreView = null;
2016             if (mDragInfo != null) {
2017                 final CellLayout.CellInfo dragCellInfo = mDragInfo;
2018                 spanX = dragCellInfo.spanX;
2019                 spanY = dragCellInfo.spanY;
2020                 ignoreView = dragCellInfo.cell;
2021             } else {
2022                 final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2023                 spanX = dragInfo.spanX;
2024                 spanY = dragInfo.spanY;
2025             }
2026 
2027             int minSpanX = spanX;
2028             int minSpanY = spanY;
2029             if (d.dragInfo instanceof PendingAddWidgetInfo) {
2030                 minSpanX = ((PendingAddWidgetInfo) d.dragInfo).minSpanX;
2031                 minSpanY = ((PendingAddWidgetInfo) d.dragInfo).minSpanY;
2032             }
2033             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2034                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragTargetLayout,
2035                     mTargetCell);
2036             if (willCreateUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout, mTargetCell, true)) {
2037                 return true;
2038             }
2039             if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout,
2040                     mTargetCell)) {
2041                 return true;
2042             }
2043 
2044             // Don&#x27;t accept the drop if there&#x27;s no room for the item
2045             if (!mDragTargetLayout.findCellForSpanIgnoring(null, minSpanX, minSpanY, ignoreView)) {
2046                 // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2047                 // is full
2048                 if (mTargetCell != null &amp;&amp; mLauncher.isHotseatLayout(mDragTargetLayout)) {
2049                     Hotseat hotseat = mLauncher.getHotseat();
2050                     if (hotseat.isAllAppsButtonRank(
2051                             hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2052                         return false;
2053                     }
2054                 }
2055 
2056                 mLauncher.showOutOfSpaceMessage();
2057                 return false;
2058             }
2059         }
2060         return true;
2061     }
2062 
2063     boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell,
2064             boolean considerTimeout) {
2065         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2066 
2067         boolean hasntMoved = false;
2068         if (mDragInfo != null) {
2069             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2070             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2071                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2072         }
2073 
2074         if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2075             return false;
2076         }
2077 
2078         boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2079         boolean willBecomeShortcut =
2080                 (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2081                 info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2082 
2083         return (aboveShortcut &amp;&amp; willBecomeShortcut);
2084     }
2085 
2086     boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell) {
2087         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2088         if (dropOverView instanceof FolderIcon) {
2089             FolderIcon fi = (FolderIcon) dropOverView;
2090             if (fi.acceptDrop(dragInfo)) {
2091                 return true;
2092             }
2093         }
2094         return false;
2095     }
2096 
2097     boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2098             int[] targetCell, boolean external, DragView dragView, Runnable postAnimationRunnable) {
2099         View v = target.getChildAt(targetCell[0], targetCell[1]);
2100         boolean hasntMoved = false;
2101         if (mDragInfo != null) {
2102             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2103             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2104                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2105         }
2106 
2107         if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2108         mCreateUserFolderOnDrop = false;
2109         final int screen = (targetCell == null) ? mDragInfo.screen : indexOfChild(target);
2110 
2111         boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2112         boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2113 
2114         if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2115             ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2116             ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2117             // if the drag started here, we need to remove it from the workspace
2118             if (!external) {
2119                 getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2120             }
2121 
2122             Rect folderLocation = new Rect();
2123             float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2124             target.removeView(v);
2125 
2126             FolderIcon fi =
2127                 mLauncher.addFolder(target, container, screen, targetCell[0], targetCell[1]);
2128             destInfo.cellX = -1;
2129             destInfo.cellY = -1;
2130             sourceInfo.cellX = -1;
2131             sourceInfo.cellY = -1;
2132 
2133             // If the dragView is null, we can&#x27;t animate
2134             boolean animate = dragView != null;
2135             if (animate) {
2136                 fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2137                         postAnimationRunnable);
2138             } else {
2139                 fi.addItem(destInfo);
2140                 fi.addItem(sourceInfo);
2141             }
2142             return true;
2143         }
2144         return false;
2145     }
2146 
2147     boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2148             DragObject d, boolean external) {
2149         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2150         if (dropOverView instanceof FolderIcon) {
2151             FolderIcon fi = (FolderIcon) dropOverView;
2152             if (fi.acceptDrop(d.dragInfo)) {
2153                 fi.onDrop(d);
2154 
2155                 // if the drag started here, we need to remove it from the workspace
2156                 if (!external) {
2157                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2158                 }
2159                 return true;
2160             }
2161         }
2162         return false;
2163     }
2164 
2165     public void onDrop(final DragObject d) {
2166         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView,
2167                 mDragViewVisualCenter);
2168 
2169         // We want the point to be mapped to the dragTarget.
2170         if (mDragTargetLayout != null) {
2171             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2172                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2173             } else {
2174                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2175             }
2176         }
2177 
2178         CellLayout dropTargetLayout = mDragTargetLayout;
2179 
2180         int snapScreen = -1;
2181         boolean resizeOnDrop = false;
2182         if (d.dragSource != this) {
2183             final int[] touchXY = new int[] { (int) mDragViewVisualCenter[0],
2184                     (int) mDragViewVisualCenter[1] };
2185             onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2186         } else if (mDragInfo != null) {
2187             final View cell = mDragInfo.cell;
2188 
2189             Runnable resizeRunnable = null;
2190             if (dropTargetLayout != null) {
2191                 // Move internally
2192                 boolean hasMovedLayouts = (getParentCellLayoutForView(cell) != dropTargetLayout);
2193                 boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2194                 long container = hasMovedIntoHotseat ?
2195                         LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2196                         LauncherSettings.Favorites.CONTAINER_DESKTOP;
2197                 int screen = (mTargetCell[0] &lt; 0) ?
2198                         mDragInfo.screen : indexOfChild(dropTargetLayout);
2199                 int spanX = mDragInfo != null ? mDragInfo.spanX : 1;
2200                 int spanY = mDragInfo != null ? mDragInfo.spanY : 1;
2201                 // First we find the cell nearest to point at which the item is
2202                 // dropped, without any consideration to whether there is an item there.
2203                 mTargetCell = findNearestArea((int) mDragViewVisualCenter[0], (int)
2204                         mDragViewVisualCenter[1], spanX, spanY, dropTargetLayout, mTargetCell);
2205                 // If the item being dropped is a shortcut and the nearest drop
2206                 // cell also contains a shortcut, then create a folder with the two shortcuts.
2207                 if (!mInScrollArea &amp;&amp; createUserFolderIfNecessary(cell, container,
2208                         dropTargetLayout, mTargetCell, false, d.dragView, null)) {
2209                     return;
2210                 }
2211 
2212                 if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell, d, false)) {
2213                     return;
2214                 }
2215 
2216                 // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2217                 // we need to find the nearest cell location that is vacant
2218                 ItemInfo item = (ItemInfo) d.dragInfo;
2219                 int minSpanX = item.spanX;
2220                 int minSpanY = item.spanY;
2221                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2222                     minSpanX = item.minSpanX;
2223                     minSpanY = item.minSpanY;
2224                 }
2225                 int[] resultSpan = new int[2];
2226                 mTargetCell = findNearestVacantArea((int) mDragViewVisualCenter[0],
2227                         (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragInfo.spanX,
2228                         mDragInfo.spanY, cell, dropTargetLayout, mTargetCell, resultSpan);
2229                 boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2230                 if (foundCell &amp;&amp; (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY)) {
2231                     resizeOnDrop = true;
2232                     item.spanX = resultSpan[0];
2233                     item.spanY = resultSpan[1];
2234                 }
2235 
2236                 if (mCurrentPage != screen &amp;&amp; !hasMovedIntoHotseat) {
2237                     snapScreen = screen;
2238                     snapToPage(screen);
2239                 }
2240 
2241                 if (foundCell) {
2242                     final ItemInfo info = (ItemInfo) cell.getTag();
2243                     if (hasMovedLayouts) {
2244                         // Reparent the view
2245                         getParentCellLayoutForView(cell).removeView(cell);
2246                         addInScreen(cell, container, screen, mTargetCell[0], mTargetCell[1],
2247                                 info.spanX, info.spanY);
2248                     }
2249 
2250                     // update the item&#x27;s position after drop
2251                     CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2252                     dropTargetLayout.onMove(cell, mTargetCell[0], mTargetCell[1],
2253                             item.spanX, item.spanY);
2254                     lp.cellX = mTargetCell[0];
2255                     lp.cellY = mTargetCell[1];
2256                     lp.cellHSpan = item.spanX;
2257                     lp.cellVSpan = item.spanY;
2258                     cell.setId(LauncherModel.getCellLayoutChildId(container, mDragInfo.screen,
2259                             mTargetCell[0], mTargetCell[1], mDragInfo.spanX, mDragInfo.spanY));
2260 
2261                     if (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
2262                             cell instanceof LauncherAppWidgetHostView) {
2263                         final CellLayout cellLayout = dropTargetLayout;
2264                         // We post this call so that the widget has a chance to be placed
2265                         // in its final location
2266 
2267                         final LauncherAppWidgetHostView hostView = (LauncherAppWidgetHostView) cell;
2268                         AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2269                         if (pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
2270                             final Runnable addResizeFrame = new Runnable() {
2271                                 public void run() {
2272                                     DragLayer dragLayer = mLauncher.getDragLayer();
2273                                     dragLayer.addResizeFrame(info, hostView, cellLayout);
2274                                 }
2275                             };
2276                             resizeRunnable = (new Runnable() {
2277                                 public void run() {
2278                                     if (!isPageMoving()) {
2279                                         addResizeFrame.run();
2280                                     } else {
2281                                         mDelayedResizeRunnable = addResizeFrame;
2282                                     }
2283                                 }
2284                             });
2285                         }
2286                     }
2287 
2288                     LauncherModel.moveItemInDatabase(mLauncher, info, container, screen, lp.cellX,
2289                             lp.cellY);
2290                 } else {
2291                     // If we can&#x27;t find a drop location, we return the item to its original position
2292                     CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2293                     mTargetCell[0] = lp.cellX;
2294                     mTargetCell[1] = lp.cellY;
2295                 }
2296             }
2297 
2298             final CellLayout parent = (CellLayout) cell.getParent().getParent();
2299             final Runnable finalResizeRunnable = resizeRunnable;
2300             // Prepare it to be animated into its new position
2301             // This must be called after the view has been re-parented
2302             final Runnable onCompleteRunnable = new Runnable() {
2303                 @Override
2304                 public void run() {
2305                     mAnimatingViewIntoPlace = false;
2306                     updateChildrenLayersEnabled();
2307                     if (finalResizeRunnable != null) {
2308                         finalResizeRunnable.run();
2309                     }
2310                 }
2311             };
2312             mAnimatingViewIntoPlace = true;
2313             if (d.dragView.hasDrawn()) {
2314                 final ItemInfo info = (ItemInfo) cell.getTag();
2315                 if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) {
2316                     int animationType = resizeOnDrop ? ANIMATE_INTO_POSITION_AND_RESIZE :
2317                             ANIMATE_INTO_POSITION_AND_DISAPPEAR;
2318                     animateWidgetDrop(info, parent, d.dragView,
2319                             onCompleteRunnable, animationType, cell, false);
2320             } else {
2321                     mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell,
2322                             onCompleteRunnable);
2323                 }
2324             } else {
2325                 d.deferDragViewCleanupPostAnimation = false;
2326                 cell.setVisibility(VISIBLE);
2327             }
2328             parent.onDropChild(cell);
2329         }
2330     }
2331 
2332     public void setFinalScrollForPageChange(int screen) {
2333         if (screen &gt;= 0) {
2334             mSavedScrollX = getScrollX();
2335             CellLayout cl = (CellLayout) getChildAt(screen);
2336             mSavedTranslationX = cl.getTranslationX();
2337             mSavedRotationY = cl.getRotationY();
2338             final int newX = getChildOffset(screen) - getRelativeChildOffset(screen);
2339             setScrollX(newX);
2340             cl.setTranslationX(0f);
2341             cl.setRotationY(0f);
2342         }
2343     }
2344 
2345     public void resetFinalScrollForPageChange(int screen) {
2346         if (screen &gt;= 0) {
2347             CellLayout cl = (CellLayout) getChildAt(screen);
2348             setScrollX(mSavedScrollX);
2349             cl.setTranslationX(mSavedTranslationX);
2350             cl.setRotationY(mSavedRotationY);
2351         }
2352     }
2353 
2354     public void getViewLocationRelativeToSelf(View v, int[] location) {
2355         getLocationInWindow(location);
2356         int x = location[0];
2357         int y = location[1];
2358 
2359         v.getLocationInWindow(location);
2360         int vX = location[0];
2361         int vY = location[1];
2362 
2363         location[0] = vX - x;
2364         location[1] = vY - y;
2365     }
2366 
2367     public void onDragEnter(DragObject d) {
2368         mDragHasEnteredWorkspace = true;
2369         if (mDragTargetLayout != null) {
2370             mDragTargetLayout.setIsDragOverlapping(false);
2371             mDragTargetLayout.onDragExit();
2372         }
2373         mDragTargetLayout = getCurrentDropLayout();
2374         mDragTargetLayout.setIsDragOverlapping(true);
2375         mDragTargetLayout.onDragEnter();
2376 
2377         // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
2378         // don&#x27;t need to show the outlines
2379         if (LauncherApplication.isScreenLarge()) {
2380             showOutlines();
2381         }
2382     }
2383 
2384     private void doDragExit(DragObject d) {
2385         // Clean up folders
2386         cleanupFolderCreation(d);
2387 
2388         // Reset the scroll area and previous drag target
2389         onResetScrollArea();
2390 
2391         if (mDragTargetLayout != null) {
2392             mDragTargetLayout.setIsDragOverlapping(false);
2393             mDragTargetLayout.onDragExit();
2394         }
2395         mLastDragOverView = null;
2396         mSpringLoadedDragController.cancel();
2397 
2398         if (!mIsPageMoving) {
2399             hideOutlines();
2400         }
2401     }
2402 
2403     public void onDragExit(DragObject d) {
2404         mDragHasEnteredWorkspace = false;
2405         doDragExit(d);
2406     }
2407 
2408     public DropTarget getDropTargetDelegate(DragObject d) {
2409         return null;
2410     }
2411 
2412     /**
2413      * Tests to see if the drop will be accepted by Launcher, and if so, includes additional data
2414      * in the returned structure related to the widgets that match the drop (or a null list if it is
2415      * a shortcut drop).  If the drop is not accepted then a null structure is returned.
2416      */
2417     private Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; validateDrag(DragEvent event) {
2418         final LauncherModel model = mLauncher.getModel();
2419         final ClipDescription desc = event.getClipDescription();
2420         final int mimeTypeCount = desc.getMimeTypeCount();
2421         for (int i = 0; i &lt; mimeTypeCount; ++i) {
2422             final String mimeType = desc.getMimeType(i);
2423             if (mimeType.equals(InstallShortcutReceiver.SHORTCUT_MIMETYPE)) {
2424                 return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, null);
2425             } else {
2426                 final List&lt;WidgetMimeTypeHandlerData&gt; widgets =
2427                     model.resolveWidgetsForMimeType(mContext, mimeType);
2428                 if (widgets.size() &gt; 0) {
2429                     return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, widgets);
2430                 }
2431             }
2432         }
2433         return null;
2434     }
2435 
2436     /**
2437      * Global drag and drop handler
2438      */
2439     @Override
2440     public boolean onDragEvent(DragEvent event) {
2441         final ClipDescription desc = event.getClipDescription();
2442         final CellLayout layout = (CellLayout) getChildAt(mCurrentPage);
2443         final int[] pos = new int[2];
2444         layout.getLocationOnScreen(pos);
2445         // We need to offset the drag coordinates to layout coordinate space
2446         final int x = (int) event.getX() - pos[0];
2447         final int y = (int) event.getY() - pos[1];
2448 
2449         switch (event.getAction()) {
2450         case DragEvent.ACTION_DRAG_STARTED: {
2451             // Validate this drag
2452             Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2453             if (test != null) {
2454                 boolean isShortcut = (test.second == null);
2455                 if (isShortcut) {
2456                     // Check if we have enough space on this screen to add a new shortcut
2457                     if (!layout.findCellForSpan(pos, 1, 1)) {
2458                         mLauncher.showOutOfSpaceMessage();
2459                         return false;
2460                     }
2461                 }
2462             } else {
2463                 // Show error message if we couldn&#x27;t accept any of the items
2464                 Toast.makeText(mContext, mContext.getString(R.string.external_drop_widget_error),
2465                         Toast.LENGTH_SHORT).show();
2466                 return false;
2467             }
2468 
2469             // Create the drag outline
2470             // We need to add extra padding to the bitmap to make room for the glow effect
2471             final Canvas canvas = new Canvas();
2472             mDragOutline = createExternalDragOutline(canvas, DRAG_BITMAP_PADDING);
2473 
2474             // Show the current page outlines to indicate that we can accept this drop
2475             showOutlines();
2476             layout.onDragEnter();
2477             layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, 1, 1, null, null);
2478 
2479             return true;
2480         }
2481         case DragEvent.ACTION_DRAG_LOCATION:
2482             // Visualize the drop location
2483             layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, 1, 1, null, null);
2484             return true;
2485         case DragEvent.ACTION_DROP: {
2486             // Try and add any shortcuts
2487             final LauncherModel model = mLauncher.getModel();
2488             final ClipData data = event.getClipData();
2489 
2490             // We assume that the mime types are ordered in descending importance of
2491             // representation. So we enumerate the list of mime types and alert the
2492             // user if any widgets can handle the drop.  Only the most preferred
2493             // representation will be handled.
2494             pos[0] = x;
2495             pos[1] = y;
2496             Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2497             if (test != null) {
2498                 final int index = test.first;
2499                 final List&lt;WidgetMimeTypeHandlerData&gt; widgets = test.second;
2500                 final boolean isShortcut = (widgets == null);
2501                 final String mimeType = desc.getMimeType(index);
2502                 if (isShortcut) {
2503                     final Intent intent = data.getItemAt(index).getIntent();
2504                     Object info = model.infoFromShortcutIntent(mContext, intent, data.getIcon());
2505                     if (info != null) {
2506                         onDropExternal(new int[] { x, y }, info, layout, false);
2507                     }
2508                 } else {
2509                     if (widgets.size() == 1) {
2510                         // If there is only one item, then go ahead and add and configure
2511                         // that widget
2512                         final AppWidgetProviderInfo widgetInfo = widgets.get(0).widgetInfo;
2513                         final PendingAddWidgetInfo createInfo =
2514                                 new PendingAddWidgetInfo(widgetInfo, mimeType, data);
2515                         mLauncher.addAppWidgetFromDrop(createInfo,
2516                                 LauncherSettings.Favorites.CONTAINER_DESKTOP, mCurrentPage,
2517                                 null, null, pos);
2518                     } else {
2519                         // Show the widget picker dialog if there is more than one widget
2520                         // that can handle this data type
2521                         final InstallWidgetReceiver.WidgetListAdapter adapter =
2522                             new InstallWidgetReceiver.WidgetListAdapter(mLauncher, mimeType,
2523                                     data, widgets, layout, mCurrentPage, pos);
2524                         final AlertDialog.Builder builder =
2525                             new AlertDialog.Builder(mContext);
2526                         builder.setAdapter(adapter, adapter);
2527                         builder.setCancelable(true);
2528                         builder.setTitle(mContext.getString(
2529                                 R.string.external_drop_widget_pick_title));
2530                         builder.setIcon(R.drawable.ic_no_applications);
2531                         builder.show();
2532                     }
2533                 }
2534             }
2535             return true;
2536         }
2537         case DragEvent.ACTION_DRAG_ENDED:
2538             // Hide the page outlines after the drop
2539             layout.onDragExit();
2540             hideOutlines();
2541             return true;
2542         }
2543         return super.onDragEvent(event);
2544     }
2545 
2546     /*
2547     *
2548     * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2549     * coordinate space. The argument xy is modified with the return result.
2550     *
2551     */
2552    void mapPointFromSelfToChild(View v, float[] xy) {
2553        mapPointFromSelfToChild(v, xy, null);
2554    }
2555 
2556    /*
2557     *
2558     * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2559     * coordinate space. The argument xy is modified with the return result.
2560     *
2561     * if cachedInverseMatrix is not null, this method will just use that matrix instead of
2562     * computing it itself; we use this to avoid redundant matrix inversions in
2563     * findMatchingPageForDragOver
2564     *
2565     */
2566    void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
2567        if (cachedInverseMatrix == null) {
2568            v.getMatrix().invert(mTempInverseMatrix);
2569            cachedInverseMatrix = mTempInverseMatrix;
2570        }
2571        int scrollX = mScrollX;
2572        if (mNextPage != INVALID_PAGE) {
2573            scrollX = mScroller.getFinalX();
2574        }
2575        xy[0] = xy[0] + scrollX - v.getLeft();
2576        xy[1] = xy[1] + mScrollY - v.getTop();
2577        cachedInverseMatrix.mapPoints(xy);
2578    }
2579 
2580    /*
2581     * Maps a point from the Workspace&#x27;s coordinate system to another sibling view&#x27;s. (Workspace
2582     * covers the full screen)
2583     */
2584    void mapPointFromSelfToSibling(View v, float[] xy) {
2585        xy[0] = xy[0] - v.getLeft();
2586        xy[1] = xy[1] - v.getTop();
2587    }
2588 
2589    /*
2590     *
2591     * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
2592     * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
2593     *
2594     */
2595    void mapPointFromChildToSelf(View v, float[] xy) {
2596        v.getMatrix().mapPoints(xy);
2597        int scrollX = mScrollX;
2598        if (mNextPage != INVALID_PAGE) {
2599            scrollX = mScroller.getFinalX();
2600        }
2601        xy[0] -= (scrollX - v.getLeft());
2602        xy[1] -= (mScrollY - v.getTop());
2603    }
2604 
2605    static private float squaredDistance(float[] point1, float[] point2) {
2606         float distanceX = point1[0] - point2[0];
2607         float distanceY = point2[1] - point2[1];
2608         return distanceX * distanceX + distanceY * distanceY;
2609    }
2610 
2611     /*
2612      *
2613      * Returns true if the passed CellLayout cl overlaps with dragView
2614      *
2615      */
2616     boolean overlaps(CellLayout cl, DragView dragView,
2617             int dragViewX, int dragViewY, Matrix cachedInverseMatrix) {
2618         // Transform the coordinates of the item being dragged to the CellLayout&#x27;s coordinates
2619         final float[] draggedItemTopLeft = mTempDragCoordinates;
2620         draggedItemTopLeft[0] = dragViewX;
2621         draggedItemTopLeft[1] = dragViewY;
2622         final float[] draggedItemBottomRight = mTempDragBottomRightCoordinates;
2623         draggedItemBottomRight[0] = draggedItemTopLeft[0] + dragView.getDragRegionWidth();
2624         draggedItemBottomRight[1] = draggedItemTopLeft[1] + dragView.getDragRegionHeight();
2625 
2626         // Transform the dragged item&#x27;s top left coordinates
2627         // to the CellLayout&#x27;s local coordinates
2628         mapPointFromSelfToChild(cl, draggedItemTopLeft, cachedInverseMatrix);
2629         float overlapRegionLeft = Math.max(0f, draggedItemTopLeft[0]);
2630         float overlapRegionTop = Math.max(0f, draggedItemTopLeft[1]);
2631 
2632         if (overlapRegionLeft &lt;= cl.getWidth() &amp;&amp; overlapRegionTop &gt;= 0) {
2633             // Transform the dragged item&#x27;s bottom right coordinates
2634             // to the CellLayout&#x27;s local coordinates
2635             mapPointFromSelfToChild(cl, draggedItemBottomRight, cachedInverseMatrix);
2636             float overlapRegionRight = Math.min(cl.getWidth(), draggedItemBottomRight[0]);
2637             float overlapRegionBottom = Math.min(cl.getHeight(), draggedItemBottomRight[1]);
2638 
2639             if (overlapRegionRight &gt;= 0 &amp;&amp; overlapRegionBottom &lt;= cl.getHeight()) {
2640                 float overlap = (overlapRegionRight - overlapRegionLeft) *
2641                          (overlapRegionBottom - overlapRegionTop);
2642                 if (overlap &gt; 0) {
2643                     return true;
2644                 }
2645              }
2646         }
2647         return false;
2648     }
2649 
2650     /*
2651      *
2652      * This method returns the CellLayout that is currently being dragged to. In order to drag
2653      * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
2654      * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
2655      *
2656      * Return null if no CellLayout is currently being dragged over
2657      *
2658      */
2659     private CellLayout findMatchingPageForDragOver(
2660             DragView dragView, float originX, float originY, boolean exact) {
2661         // We loop through all the screens (ie CellLayouts) and see which ones overlap
2662         // with the item being dragged and then choose the one that&#x27;s closest to the touch point
2663         final int screenCount = getChildCount();
2664         CellLayout bestMatchingScreen = null;
2665         float smallestDistSoFar = Float.MAX_VALUE;
2666 
2667         for (int i = 0; i &lt; screenCount; i++) {
2668             CellLayout cl = (CellLayout) getChildAt(i);
2669 
2670             final float[] touchXy = {originX, originY};
2671             // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
2672             // If the touch point is within the bounds of the cell layout, we can return immediately
2673             cl.getMatrix().invert(mTempInverseMatrix);
2674             mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
2675 
2676             if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
2677                     touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
2678                 return cl;
2679             }
2680 
2681             if (!exact) {
2682                 // Get the center of the cell layout in screen coordinates
2683                 final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
2684                 cellLayoutCenter[0] = cl.getWidth()/2;
2685                 cellLayoutCenter[1] = cl.getHeight()/2;
2686                 mapPointFromChildToSelf(cl, cellLayoutCenter);
2687 
2688                 touchXy[0] = originX;
2689                 touchXy[1] = originY;
2690 
2691                 // Calculate the distance between the center of the CellLayout
2692                 // and the touch point
2693                 float dist = squaredDistance(touchXy, cellLayoutCenter);
2694 
2695                 if (dist &lt; smallestDistSoFar) {
2696                     smallestDistSoFar = dist;
2697                     bestMatchingScreen = cl;
2698                 }
2699             }
2700         }
2701         return bestMatchingScreen;
2702     }
2703 
2704     // This is used to compute the visual center of the dragView. This point is then
2705     // used to visualize drop locations and determine where to drop an item. The idea is that
2706     // the visual center represents the user&#x27;s interpretation of where the item is, and hence
2707     // is the appropriate point to use when determining drop location.
2708     private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
2709             DragView dragView, float[] recycle) {
2710         float res[];
2711         if (recycle == null) {
2712             res = new float[2];
2713         } else {
2714             res = recycle;
2715         }
2716 
2717         // First off, the drag view has been shifted in a way that is not represented in the
2718         // x and y values or the x/yOffsets. Here we account for that shift.
2719         x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
2720         y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
2721 
2722         // These represent the visual top and left of drag view if a dragRect was provided.
2723         // If a dragRect was not provided, then they correspond to the actual view left and
2724         // top, as the dragRect is in that case taken to be the entire dragView.
2725         // R.dimen.dragViewOffsetY.
2726         int left = x - xOffset;
2727         int top = y - yOffset;
2728 
2729         // In order to find the visual center, we shift by half the dragRect
2730         res[0] = left + dragView.getDragRegion().width() / 2;
2731         res[1] = top + dragView.getDragRegion().height() / 2;
2732 
2733         return res;
2734     }
2735 
2736     private boolean isDragWidget(DragObject d) {
2737         return (d.dragInfo instanceof LauncherAppWidgetInfo ||
2738                 d.dragInfo instanceof PendingAddWidgetInfo);
2739     }
2740     private boolean isExternalDragWidget(DragObject d) {
2741         return d.dragSource != this &amp;&amp; isDragWidget(d);
2742     }
2743 
2744     public void onDragOver(DragObject d) {
2745         // Skip drag over events while we are dragging over side pages
2746         if (mInScrollArea || mIsSwitchingState || mState == State.SMALL) return;
2747 
2748         Rect r = new Rect();
2749         CellLayout layout = null;
2750         ItemInfo item = (ItemInfo) d.dragInfo;
2751 
2752         // Ensure that we have proper spans for the item that we are dropping
2753         if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
2754         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2755             d.dragView, mDragViewVisualCenter);
2756 
2757         // Identify whether we have dragged over a side page
2758         if (isSmall()) {
2759             if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
2760                 mLauncher.getHotseat().getHitRect(r);
2761                 if (r.contains(d.x, d.y)) {
2762                     layout = mLauncher.getHotseat().getLayout();
2763                 }
2764             }
2765             if (layout == null) {
2766                 layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
2767             }
2768             if (layout != mDragTargetLayout) {
2769                 // Cancel all intermediate folder states
2770                 cleanupFolderCreation(d);
2771 
2772                 if (mDragTargetLayout != null) {
2773                     mDragTargetLayout.setIsDragOverlapping(false);
2774                     mDragTargetLayout.onDragExit();
2775                 }
2776                 mDragTargetLayout = layout;
2777                 if (mDragTargetLayout != null) {
2778                     mDragTargetLayout.setIsDragOverlapping(true);
2779                     mDragTargetLayout.onDragEnter();
2780                 } else {
2781                     mLastDragOverView = null;
2782                 }
2783 
2784                 boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
2785                 if (isInSpringLoadedMode) {
2786                     if (mLauncher.isHotseatLayout(layout)) {
2787                         mSpringLoadedDragController.cancel();
2788                     } else {
2789                         mSpringLoadedDragController.setAlarm(mDragTargetLayout);
2790                     }
2791                 }
2792             }
2793         } else {
2794             // Test to see if we are over the hotseat otherwise just use the current page
2795             if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
2796                 mLauncher.getHotseat().getHitRect(r);
2797                 if (r.contains(d.x, d.y)) {
2798                     layout = mLauncher.getHotseat().getLayout();
2799                 }
2800             }
2801             if (layout == null) {
2802                 layout = getCurrentDropLayout();
2803             }
2804             if (layout != mDragTargetLayout) {
2805                 if (mDragTargetLayout != null) {
2806                     mDragTargetLayout.setIsDragOverlapping(false);
2807                     mDragTargetLayout.onDragExit();
2808                 }
2809                 mDragTargetLayout = layout;
2810                 mDragTargetLayout.setIsDragOverlapping(true);
2811                 mDragTargetLayout.onDragEnter();
2812             }
2813         }
2814 
2815         // Handle the drag over
2816         if (mDragTargetLayout != null) {
2817             final View child = (mDragInfo == null) ? null : mDragInfo.cell;
2818 
2819             // We want the point to be mapped to the dragTarget.
2820             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2821                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2822             } else {
2823                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2824             }
2825             ItemInfo info = (ItemInfo) d.dragInfo;
2826 
2827             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2828                     (int) mDragViewVisualCenter[1], 1, 1, mDragTargetLayout, mTargetCell);
2829             final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
2830                     mTargetCell[1]);
2831 
2832             boolean userFolderPending = willCreateUserFolder(info, mDragTargetLayout,
2833                     mTargetCell, false);
2834             boolean isOverFolder = dragOverView instanceof FolderIcon;
2835             if (dragOverView != mLastDragOverView) {
2836                 cancelFolderCreation();
2837                 if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
2838                     ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
2839                 }
2840             }
2841 
2842             if (userFolderPending &amp;&amp; dragOverView != mLastDragOverView) {
2843                 mFolderCreationAlarm.setOnAlarmListener(new
2844                         FolderCreationAlarmListener(mDragTargetLayout, mTargetCell[0], mTargetCell[1]));
2845                 mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
2846             }
2847 
2848             if (dragOverView != mLastDragOverView &amp;&amp; isOverFolder) {
2849                 ((FolderIcon) dragOverView).onDragEnter(d.dragInfo);
2850                 if (mDragTargetLayout != null) {
2851                     mDragTargetLayout.clearDragOutlines();
2852                 }
2853             }
2854             mLastDragOverView = dragOverView;
2855 
2856             if (!mCreateUserFolderOnDrop &amp;&amp; !isOverFolder) {
2857                 int minSpanX = item.spanX;
2858                 int minSpanY = item.spanY;
2859                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2860                     minSpanX = item.minSpanX;
2861                     minSpanY = item.minSpanY;
2862                 }
2863                 mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
2864                         (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
2865                         minSpanX, minSpanY, item.spanX, item.spanY,
2866                         d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());
2867             }
2868         }
2869     }
2870 
2871     private void cleanupFolderCreation(DragObject d) {
2872         if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
2873             mDragFolderRingAnimator.animateToNaturalState();
2874         }
2875         if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
2876             if (d != null) {
2877                 ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
2878             }
2879         }
2880         mFolderCreationAlarm.cancelAlarm();
2881     }
2882 
2883     private void cancelFolderCreation() {
2884         if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
2885             mDragFolderRingAnimator.animateToNaturalState();
2886         }
2887         mCreateUserFolderOnDrop = false;
2888         mFolderCreationAlarm.cancelAlarm();
2889     }
2890 
2891     class FolderCreationAlarmListener implements OnAlarmListener {
2892         CellLayout layout;
2893         int cellX;
2894         int cellY;
2895 
2896         public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
2897             this.layout = layout;
2898             this.cellX = cellX;
2899             this.cellY = cellY;
2900         }
2901 
2902         public void onAlarm(Alarm alarm) {
2903             if (mDragFolderRingAnimator == null) {
2904                 mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
2905             }
2906             mDragFolderRingAnimator.setCell(cellX, cellY);
2907             mDragFolderRingAnimator.setCellLayout(layout);
2908             mDragFolderRingAnimator.animateToAcceptState();
2909             layout.showFolderAccept(mDragFolderRingAnimator);
2910             layout.clearDragOutlines();
2911             mCreateUserFolderOnDrop = true;
2912         }
2913     }
2914 
2915     @Override
2916     public void getHitRect(Rect outRect) {
2917         // We want the workspace to have the whole area of the display (it will find the correct
2918         // cell layout to drop to in the existing drag/drop logic.
2919         outRect.set(0, 0, mDisplayWidth, mDisplayHeight);
2920     }
2921 
2922     /**
2923      * Add the item specified by dragInfo to the given layout.
2924      * @return true if successful
2925      */
2926     public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
2927         if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
2928             onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
2929             return true;
2930         }
2931         mLauncher.showOutOfSpaceMessage();
2932         return false;
2933     }
2934 
2935     private void onDropExternal(int[] touchXY, Object dragInfo,
2936             CellLayout cellLayout, boolean insertAtFirst) {
2937         onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
2938     }
2939 
2940     /**
2941      * Drop an item that didn&#x27;t originate on one of the workspace screens.
2942      * It may have come from Launcher (e.g. from all apps or customize), or it may have
2943      * come from another app altogether.
2944      *
2945      * NOTE: This can also be called when we are outside of a drag event, when we want
2946      * to add an item to one of the workspace screens.
2947      */
2948     private void onDropExternal(final int[] touchXY, final Object dragInfo,
2949             final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
2950         final Runnable exitSpringLoadedRunnable = new Runnable() {
2951             @Override
2952             public void run() {
2953                 mLauncher.exitSpringLoadedDragModeDelayed(true, false, null);
2954             }
2955         };
2956 
2957         ItemInfo info = (ItemInfo) dragInfo;
2958         int spanX = info.spanX;
2959         int spanY = info.spanY;
2960         if (mDragInfo != null) {
2961             spanX = mDragInfo.spanX;
2962             spanY = mDragInfo.spanY;
2963         }
2964 
2965         final long container = mLauncher.isHotseatLayout(cellLayout) ?
2966                 LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2967                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
2968         final int screen = indexOfChild(cellLayout);
2969         if (!mLauncher.isHotseatLayout(cellLayout) &amp;&amp; screen != mCurrentPage
2970                 &amp;&amp; mState != State.SPRING_LOADED) {
2971             snapToPage(screen);
2972         }
2973 
2974         if (info instanceof PendingAddItemInfo) {
2975             final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
2976 
2977             boolean findNearestVacantCell = true;
2978             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
2979                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
2980                         cellLayout, mTargetCell);
2981                 if (willCreateUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout, mTargetCell,
2982                         true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
2983                                 mDragTargetLayout, mTargetCell)) {
2984                     findNearestVacantCell = false;
2985                 }
2986             }
2987             final ItemInfo item = (ItemInfo) d.dragInfo;
2988             int minSpanX = item.spanX;
2989             int minSpanY = item.spanY;
2990             if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2991                 minSpanX = item.minSpanX;
2992                 minSpanY = item.minSpanY;
2993             }
2994             if (findNearestVacantCell) {
2995                 int[] resultSpan = new int[2];
2996                 mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], minSpanX, minSpanY,
2997                         spanX, spanY, null, cellLayout, mTargetCell, resultSpan);
2998                 item.spanX = resultSpan[0];
2999                 item.spanY = resultSpan[1];
3000             }
3001 
3002             Runnable onAnimationCompleteRunnable = new Runnable() {
3003                 @Override
3004                 public void run() {
3005                     // When dragging and dropping from customization tray, we deal with creating
3006                     // widgets/shortcuts/folders in a slightly different way
3007                     switch (pendingInfo.itemType) {
3008                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
3009                         int span[] = new int[2];
3010                         span[0] = item.spanX;
3011                         span[1] = item.spanY;
3012                         mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
3013                                 container, screen, mTargetCell, span, null);
3014                         break;
3015                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3016                         mLauncher.processShortcutFromDrop(pendingInfo.componentName,
3017                                 container, screen, mTargetCell, null);
3018                         break;
3019                     default:
3020                         throw new IllegalStateException(&quot;Unknown item type: &quot; +
3021                                 pendingInfo.itemType);
3022                     }
3023                     cellLayout.onDragExit();
3024                 }
3025             };
3026             View finalView = pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET
3027                     ? ((PendingAddWidgetInfo) pendingInfo).boundWidget : null;
3028             int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;
3029             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
3030                     ((PendingAddWidgetInfo) pendingInfo).info.configure != null) {
3031                 animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;
3032             }
3033             animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable,
3034                     animationStyle, finalView, true);
3035         } else {
3036             // This is for other drag/drop cases, like dragging from All Apps
3037             View view = null;
3038 
3039             switch (info.itemType) {
3040             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3041             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3042                 if (info.container == NO_ID &amp;&amp; info instanceof ApplicationInfo) {
3043                     // Came from all apps -- make a copy
3044                     info = new ShortcutInfo((ApplicationInfo) info);
3045                 }
3046                 view = mLauncher.createShortcut(R.layout.application, cellLayout,
3047                         (ShortcutInfo) info);
3048                 break;
3049             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3050                 view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3051                         (FolderInfo) info, mIconCache);
3052                 break;
3053             default:
3054                 throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3055             }
3056 
3057             // First we find the cell nearest to point at which the item is
3058             // dropped, without any consideration to whether there is an item there.
3059             if (touchXY != null) {
3060                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3061                         cellLayout, mTargetCell);
3062                 d.postAnimationRunnable = exitSpringLoadedRunnable;
3063                 if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, true,
3064                         d.dragView, d.postAnimationRunnable)) {
3065                     return;
3066                 }
3067                 if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, d, true)) {
3068                     return;
3069                 }
3070             }
3071 
3072             if (touchXY != null) {
3073                 // when dragging and dropping, just find the closest free spot
3074                 mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, null,
3075                         cellLayout, mTargetCell);
3076             } else {
3077                 cellLayout.findCellForSpan(mTargetCell, 1, 1);
3078             }
3079             addInScreen(view, container, screen, mTargetCell[0], mTargetCell[1], info.spanX,
3080                     info.spanY, insertAtFirst);
3081             cellLayout.onDropChild(view);
3082             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3083             cellLayout.getChildrenLayout().measureChild(view);
3084 
3085 
3086             LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen,
3087                     lp.cellX, lp.cellY);
3088 
3089             if (d.dragView != null) {
3090                 // We wrap the animation call in the temporary set and reset of the current
3091                 // cellLayout to its final transform -- this means we animate the drag view to
3092                 // the correct final location.
3093                 setFinalTransitionTransform(cellLayout);
3094                 mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3095                         exitSpringLoadedRunnable);
3096                 resetTransitionTransform(cellLayout);
3097             }
3098         }
3099     }
3100 
3101     public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {
3102         int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX,
3103                 widgetInfo.spanY, widgetInfo, false);
3104         int visibility = layout.getVisibility();
3105         layout.setVisibility(VISIBLE);
3106 
3107         int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);
3108         int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);
3109         Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1],
3110                 Bitmap.Config.ARGB_8888);
3111         Canvas c = new Canvas(b);
3112 
3113         layout.measure(width, height);
3114         layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);
3115         layout.draw(c);
3116         c.setBitmap(null);
3117         layout.setVisibility(visibility);
3118         return b;
3119     }
3120 
3121     private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY,
3122             DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell, View finalView,
3123             boolean external) {
3124         // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
3125         // location and size on the home screen.
3126         int spanX = info.spanX;
3127         int spanY = info.spanY;
3128 
3129         Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);
3130         loc[0] = r.left;
3131         loc[1] = r.top;
3132 
3133         setFinalTransitionTransform(layout);
3134         float cellLayoutScale =
3135                 mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc);
3136         resetTransitionTransform(layout);
3137         float dragViewScaleX = (1.0f * r.width()) / dragView.getMeasuredWidth();
3138         float dragViewScaleY = (1.0f * r.height()) / dragView.getMeasuredHeight();
3139 
3140         // The animation will scale the dragView about its center, so we need to center about
3141         // the final location.
3142         loc[0] -= (dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;
3143         loc[1] -= (dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;
3144 
3145         scaleXY[0] = dragViewScaleX * cellLayoutScale;
3146         scaleXY[1] = dragViewScaleY * cellLayoutScale;
3147     }
3148 
3149     public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView,
3150             final Runnable onCompleteRunnable, int animationType, final View finalView,
3151             boolean external) {
3152         Rect from = new Rect();
3153         mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);
3154 
3155         int[] finalPos = new int[2];
3156         float scaleXY[] = new float[2];
3157         getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell,
3158                 finalView, external);
3159 
3160         Resources res = mLauncher.getResources();
3161         int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;
3162 
3163         // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer
3164         if (finalView instanceof AppWidgetHostView &amp;&amp; external) {
3165             mLauncher.getDragLayer().removeView(finalView);
3166         }
3167         if ((animationType == ANIMATE_INTO_POSITION_AND_RESIZE || external) &amp;&amp; finalView != null) {
3168             Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);
3169             dragView.setCrossFadeBitmap(crossFadeBitmap);
3170             dragView.crossFade((int) (duration * 0.8f));
3171         } else if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp; external) {
3172             scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0],  scaleXY[1]);
3173         }
3174 
3175         DragLayer dragLayer = mLauncher.getDragLayer();
3176         if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {
3177             mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0f, 0.1f, 0.1f,
3178                     DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);
3179         } else {
3180             int endStyle;
3181             if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {
3182                 endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;
3183             } else {
3184                 endStyle = DragLayer.ANIMATION_END_DISAPPEAR;;
3185             }
3186 
3187             Runnable onComplete = new Runnable() {
3188                 @Override
3189                 public void run() {
3190                     if (finalView != null) {
3191                         finalView.setVisibility(VISIBLE);
3192                     }
3193                     if (onCompleteRunnable != null) {
3194                         onCompleteRunnable.run();
3195                     }
3196                 }
3197             };
3198             dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0],
3199                     finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle,
3200                     duration, this);
3201         }
3202     }
3203 
3204     public void setFinalTransitionTransform(CellLayout layout) {
3205         if (isSwitchingState()) {
3206             int index = indexOfChild(layout);
3207             mCurrentScaleX = layout.getScaleX();
3208             mCurrentScaleY = layout.getScaleY();
3209             mCurrentTranslationX = layout.getTranslationX();
3210             mCurrentTranslationY = layout.getTranslationY();
3211             mCurrentRotationY = layout.getRotationY();
3212             layout.setScaleX(mNewScaleXs[index]);
3213             layout.setScaleY(mNewScaleYs[index]);
3214             layout.setTranslationX(mNewTranslationXs[index]);
3215             layout.setTranslationY(mNewTranslationYs[index]);
3216             layout.setRotationY(mNewRotationYs[index]);
3217         }
3218     }
3219     public void resetTransitionTransform(CellLayout layout) {
3220         if (isSwitchingState()) {
3221             mCurrentScaleX = layout.getScaleX();
3222             mCurrentScaleY = layout.getScaleY();
3223             mCurrentTranslationX = layout.getTranslationX();
3224             mCurrentTranslationY = layout.getTranslationY();
3225             mCurrentRotationY = layout.getRotationY();
3226             layout.setScaleX(mCurrentScaleX);
3227             layout.setScaleY(mCurrentScaleY);
3228             layout.setTranslationX(mCurrentTranslationX);
3229             layout.setTranslationY(mCurrentTranslationY);
3230             layout.setRotationY(mCurrentRotationY);
3231         }
3232     }
3233 
3234     /**
3235      * Return the current {@link CellLayout}, correctly picking the destination
3236      * screen while a scroll is in progress.
3237      */
3238     public CellLayout getCurrentDropLayout() {
3239         return (CellLayout) getChildAt(mNextPage == INVALID_PAGE ? mCurrentPage : mNextPage);
3240     }
3241 
3242     /**
3243      * Return the current CellInfo describing our current drag; this method exists
3244      * so that Launcher can sync this object with the correct info when the activity is created/
3245      * destroyed
3246      *
3247      */
3248     public CellLayout.CellInfo getDragInfo() {
3249         return mDragInfo;
3250     }
3251 
3252     /**
3253      * Calculate the nearest cell where the given object would be dropped.
3254      *
3255      * pixelX and pixelY should be in the coordinate system of layout
3256      */
3257     private int[] findNearestVacantArea(int pixelX, int pixelY,
3258             int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle) {
3259         return layout.findNearestVacantArea(
3260                 pixelX, pixelY, spanX, spanY, spanX, spanY, ignoreView, recycle, null);
3261     }
3262 
3263     /**
3264      * Calculate the nearest cell where the given object would be dropped.
3265      *
3266      * pixelX and pixelY should be in the coordinate system of layout
3267      */
3268     private int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
3269             int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle,
3270             int[] returnSpan) {
3271         return layout.findNearestVacantArea(
3272                 pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, recycle, returnSpan);
3273     }
3274 
3275     /**
3276      * Calculate the nearest cell where the given object would be dropped.
3277      *
3278      * pixelX and pixelY should be in the coordinate system of layout
3279      */
3280     private int[] findNearestArea(int pixelX, int pixelY,
3281             int spanX, int spanY, CellLayout layout, int[] recycle) {
3282         return layout.findNearestArea(
3283                 pixelX, pixelY, spanX, spanY, recycle);
3284     }
3285 
3286     void setup(DragController dragController) {
3287         mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3288         mDragController = dragController;
3289 
3290         // hardware layers on children are enabled on startup, but should be disabled until
3291         // needed
3292         updateChildrenLayersEnabled();
3293         setWallpaperDimension();
3294     }
3295 
3296     /**
3297      * Called at the end of a drag which originated on the workspace.
3298      */
3299     public void onDropCompleted(View target, DragObject d, boolean success) {
3300         if (success) {
3301             if (target != this) {
3302                 if (mDragInfo != null) {
3303                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
3304                     if (mDragInfo.cell instanceof DropTarget) {
3305                         mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3306                     }
3307                 }
3308             }
3309         } else if (mDragInfo != null) {
3310             // NOTE: When &#x27;success&#x27; is true, onDragExit is called by the DragController before
3311             // calling onDropCompleted(). We call it ourselves here, but maybe this should be
3312             // moved into DragController.cancelDrag().
3313             doDragExit(null);
3314             CellLayout cellLayout;
3315             if (mLauncher.isHotseatLayout(target)) {
3316                 cellLayout = mLauncher.getHotseat().getLayout();
3317             } else {
3318                 cellLayout = (CellLayout) getChildAt(mDragInfo.screen);
3319             }
3320             cellLayout.onDropChild(mDragInfo.cell);
3321         }
3322         if (d.cancelled &amp;&amp;  mDragInfo.cell != null) {
3323                 mDragInfo.cell.setVisibility(VISIBLE);
3324         }
3325         mDragOutline = null;
3326         mDragInfo = null;
3327 
3328         // Hide the scrolling indicator after you pick up an item
3329         hideScrollingIndicator(false);
3330     }
3331 
3332     public boolean isDropEnabled() {
3333         return true;
3334     }
3335 
3336     @Override
3337     protected void onRestoreInstanceState(Parcelable state) {
3338         super.onRestoreInstanceState(state);
3339         Launcher.setScreen(mCurrentPage);
3340     }
3341 
3342     @Override
3343     public void scrollLeft() {
3344         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3345             super.scrollLeft();
3346         }
3347         Folder openFolder = getOpenFolder();
3348         if (openFolder != null) {
3349             openFolder.completeDragExit();
3350         }
3351     }
3352 
3353     @Override
3354     public void scrollRight() {
3355         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3356             super.scrollRight();
3357         }
3358         Folder openFolder = getOpenFolder();
3359         if (openFolder != null) {
3360             openFolder.completeDragExit();
3361         }
3362     }
3363 
3364     @Override
3365     public boolean onEnterScrollArea(int x, int y, int direction) {
3366         // Ignore the scroll area if we are dragging over the hot seat
3367         if (mLauncher.getHotseat() != null) {
3368             Rect r = new Rect();
3369             mLauncher.getHotseat().getHitRect(r);
3370             if (r.contains(x, y)) {
3371                 return false;
3372             }
3373         }
3374 
3375         boolean result = false;
3376         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3377             mInScrollArea = true;
3378 
3379             final int page = (mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage) +
3380                        (direction == DragController.SCROLL_LEFT ? -1 : 1);
3381             cancelFolderCreation();
3382 
3383             if (0 &lt;= page &amp;&amp; page &lt; getChildCount()) {
3384                 CellLayout layout = (CellLayout) getChildAt(page);
3385                 // Exit the current layout and mark the overlapping layout
3386                 if (mDragTargetLayout != null) {
3387                     mDragTargetLayout.setIsDragOverlapping(false);
3388                     mDragTargetLayout.onDragExit();
3389                 }
3390                 mDragTargetLayout = layout;
3391                 mDragTargetLayout.setIsDragOverlapping(true);
3392 
3393                 // Workspace is responsible for drawing the edge glow on adjacent pages,
3394                 // so we need to redraw the workspace when this may have changed.
3395                 invalidate();
3396                 result = true;
3397             }
3398         }
3399         return result;
3400     }
3401 
3402     @Override
3403     public boolean onExitScrollArea() {
3404         boolean result = false;
3405         if (mInScrollArea) {
3406             if (mDragTargetLayout != null) {
3407                 mDragTargetLayout.setIsDragOverlapping(false);
3408                 // Workspace is responsible for drawing the edge glow on adjacent pages,
3409                 // so we need to redraw the workspace when this may have changed.
3410                 invalidate();
3411             }
3412             if (mDragTargetLayout != null &amp;&amp; mDragHasEnteredWorkspace) {
3413                 // Unmark the overlapping layout and re-enter the current layout
3414                 mDragTargetLayout = getCurrentDropLayout();
3415                 mDragTargetLayout.onDragEnter();
3416             }
3417             result = true;
3418             mInScrollArea = false;
3419         }
3420         return result;
3421     }
3422 
3423     private void onResetScrollArea() {
3424         if (mDragTargetLayout != null) {
3425             // Unmark the overlapping layout
3426             mDragTargetLayout.setIsDragOverlapping(false);
3427 
3428             // Workspace is responsible for drawing the edge glow on adjacent pages,
3429             // so we need to redraw the workspace when this may have changed.
3430             invalidate();
3431         }
3432         mInScrollArea = false;
3433     }
3434 
3435     /**
3436      * Returns a specific CellLayout
3437      */
3438     CellLayout getParentCellLayoutForView(View v) {
3439         ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
3440         for (CellLayout layout : layouts) {
3441             if (layout.getChildrenLayout().indexOfChild(v) &gt; -1) {
3442                 return layout;
3443             }
3444         }
3445         return null;
3446     }
3447 
3448     /**
3449      * Returns a list of all the CellLayouts in the workspace.
3450      */
3451     ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
3452         ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
3453         int screenCount = getChildCount();
3454         for (int screen = 0; screen &lt; screenCount; screen++) {
3455             layouts.add(((CellLayout) getChildAt(screen)));
3456         }
3457         if (mLauncher.getHotseat() != null) {
3458             layouts.add(mLauncher.getHotseat().getLayout());
3459         }
3460         return layouts;
3461     }
3462 
3463     /**
3464      * We should only use this to search for specific children.  Do not use this method to modify
3465      * CellLayoutChildren directly.
3466      */
3467     ArrayList&lt;CellLayoutChildren&gt; getWorkspaceAndHotseatCellLayoutChildren() {
3468         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = new ArrayList&lt;CellLayoutChildren&gt;();
3469         int screenCount = getChildCount();
3470         for (int screen = 0; screen &lt; screenCount; screen++) {
3471             childrenLayouts.add(((CellLayout) getChildAt(screen)).getChildrenLayout());
3472         }
3473         if (mLauncher.getHotseat() != null) {
3474             childrenLayouts.add(mLauncher.getHotseat().getLayout().getChildrenLayout());
3475         }
3476         return childrenLayouts;
3477     }
3478 
3479     public Folder getFolderForTag(Object tag) {
3480         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3481         for (CellLayoutChildren layout: childrenLayouts) {
3482             int count = layout.getChildCount();
3483             for (int i = 0; i &lt; count; i++) {
3484                 View child = layout.getChildAt(i);
3485                 if (child instanceof Folder) {
3486                     Folder f = (Folder) child;
3487                     if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
3488                         return f;
3489                     }
3490                 }
3491             }
3492         }
3493         return null;
3494     }
3495 
3496     public View getViewForTag(Object tag) {
3497         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3498         for (CellLayoutChildren layout: childrenLayouts) {
3499             int count = layout.getChildCount();
3500             for (int i = 0; i &lt; count; i++) {
3501                 View child = layout.getChildAt(i);
3502                 if (child.getTag() == tag) {
3503                     return child;
3504                 }
3505             }
3506         }
3507         return null;
3508     }
3509 
3510     void clearDropTargets() {
3511         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3512         for (CellLayoutChildren layout: childrenLayouts) {
3513             int childCount = layout.getChildCount();
3514             for (int j = 0; j &lt; childCount; j++) {
3515                 View v = layout.getChildAt(j);
3516                 if (v instanceof DropTarget) {
3517                     mDragController.removeDropTarget((DropTarget) v);
3518                 }
3519             }
3520         }
3521     }
3522 
3523     void removeItems(final ArrayList&lt;ApplicationInfo&gt; apps) {
3524         final AppWidgetManager widgets = AppWidgetManager.getInstance(getContext());
3525 
3526         final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
3527         final int appCount = apps.size();
3528         for (int i = 0; i &lt; appCount; i++) {
3529             packageNames.add(apps.get(i).componentName.getPackageName());
3530         }
3531 
3532         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
3533         for (final CellLayout layoutParent: cellLayouts) {
3534             final ViewGroup layout = layoutParent.getChildrenLayout();
3535 
3536             // Avoid ANRs by treating each screen separately
3537             post(new Runnable() {
3538                 public void run() {
3539                     final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
3540                     childrenToRemove.clear();
3541 
3542                     int childCount = layout.getChildCount();
3543                     for (int j = 0; j &lt; childCount; j++) {
3544                         final View view = layout.getChildAt(j);
3545                         Object tag = view.getTag();
3546 
3547                         if (tag instanceof ShortcutInfo) {
3548                             final ShortcutInfo info = (ShortcutInfo) tag;
3549                             final Intent intent = info.intent;
3550                             final ComponentName name = intent.getComponent();
3551 
3552                             if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3553                                 for (String packageName: packageNames) {
3554                                     if (packageName.equals(name.getPackageName())) {
3555                                         LauncherModel.deleteItemFromDatabase(mLauncher, info);
3556                                         childrenToRemove.add(view);
3557                                     }
3558                                 }
3559                             }
3560                         } else if (tag instanceof FolderInfo) {
3561                             final FolderInfo info = (FolderInfo) tag;
3562                             final ArrayList&lt;ShortcutInfo&gt; contents = info.contents;
3563                             final int contentsCount = contents.size();
3564                             final ArrayList&lt;ShortcutInfo&gt; appsToRemoveFromFolder =
3565                                     new ArrayList&lt;ShortcutInfo&gt;();
3566 
3567                             for (int k = 0; k &lt; contentsCount; k++) {
3568                                 final ShortcutInfo appInfo = contents.get(k);
3569                                 final Intent intent = appInfo.intent;
3570                                 final ComponentName name = intent.getComponent();
3571 
3572                                 if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3573                                     for (String packageName: packageNames) {
3574                                         if (packageName.equals(name.getPackageName())) {
3575                                             appsToRemoveFromFolder.add(appInfo);
3576                                         }
3577                                     }
3578                                 }
3579                             }
3580                             for (ShortcutInfo item: appsToRemoveFromFolder) {
3581                                 info.remove(item);
3582                                 LauncherModel.deleteItemFromDatabase(mLauncher, item);
3583                             }
3584                         } else if (tag instanceof LauncherAppWidgetInfo) {
3585                             final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) tag;
3586                             final AppWidgetProviderInfo provider =
3587                                     widgets.getAppWidgetInfo(info.appWidgetId);
3588                             if (provider != null) {
3589                                 for (String packageName: packageNames) {
3590                                     if (packageName.equals(provider.provider.getPackageName())) {
3591                                         LauncherModel.deleteItemFromDatabase(mLauncher, info);
3592                                         childrenToRemove.add(view);
3593                                     }
3594                                 }
3595                             }
3596                         }
3597                     }
3598 
3599                     childCount = childrenToRemove.size();
3600                     for (int j = 0; j &lt; childCount; j++) {
3601                         View child = childrenToRemove.get(j);
3602                         // Note: We can not remove the view directly from CellLayoutChildren as this
3603                         // does not re-mark the spaces as unoccupied.
3604                         layoutParent.removeViewInLayout(child);
3605                         if (child instanceof DropTarget) {
3606                             mDragController.removeDropTarget((DropTarget)child);
3607                         }
3608                     }
3609 
3610                     if (childCount &gt; 0) {
3611                         layout.requestLayout();
3612                         layout.invalidate();
3613                     }
3614                 }
3615             });
3616         }
3617     }
3618 
3619     void updateShortcuts(ArrayList&lt;ApplicationInfo&gt; apps) {
3620         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3621         for (CellLayoutChildren layout: childrenLayouts) {
3622             int childCount = layout.getChildCount();
3623             for (int j = 0; j &lt; childCount; j++) {
3624                 final View view = layout.getChildAt(j);
3625                 Object tag = view.getTag();
3626                 if (tag instanceof ShortcutInfo) {
3627                     ShortcutInfo info = (ShortcutInfo)tag;
3628                     // We need to check for ACTION_MAIN otherwise getComponent() might
3629                     // return null for some shortcuts (for instance, for shortcuts to
3630                     // web pages.)
3631                     final Intent intent = info.intent;
3632                     final ComponentName name = intent.getComponent();
3633                     if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3634                             Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3635                         final int appCount = apps.size();
3636                         for (int k = 0; k &lt; appCount; k++) {
3637                             ApplicationInfo app = apps.get(k);
3638                             if (app.componentName.equals(name)) {
3639                                 info.setIcon(mIconCache.getIcon(info.intent));
3640                                 ((TextView)view).setCompoundDrawablesWithIntrinsicBounds(null,
3641                                         new FastBitmapDrawable(info.getIcon(mIconCache)),
3642                                         null, null);
3643                                 }
3644                         }
3645                     }
3646                 }
3647             }
3648         }
3649     }
3650 
3651     void moveToDefaultScreen(boolean animate) {
3652         if (!isSmall()) {
3653             if (animate) {
3654                 snapToPage(mDefaultPage);
3655             } else {
3656                 setCurrentPage(mDefaultPage);
3657             }
3658         }
3659         getChildAt(mDefaultPage).requestFocus();
3660     }
3661 
3662     @Override
3663     public void syncPages() {
3664     }
3665 
3666     @Override
3667     public void syncPageItems(int page, boolean immediate) {
3668     }
3669 
3670     @Override
3671     protected String getCurrentPageDescription() {
3672         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
3673         return String.format(mContext.getString(R.string.workspace_scroll_format),
3674                 page + 1, getChildCount());
3675     }
3676 
3677     public void getLocationInDragLayer(int[] loc) {
3678         mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
3679     }
3680 
3681     void setFadeForOverScroll(float fade) {
3682         if (!isScrollingIndicatorEnabled()) return;
3683 
3684         mOverscrollFade = fade;
3685         float reducedFade = 0.5f + 0.5f * (1 - fade);
3686         final ViewGroup parent = (ViewGroup) getParent();
3687         final ImageView qsbDivider = (ImageView) (parent.findViewById(R.id.qsb_divider));
3688         final ImageView dockDivider = (ImageView) (parent.findViewById(R.id.dock_divider));
3689         final View scrollIndicator = getScrollingIndicator();
3690 
3691         cancelScrollingIndicatorAnimations();
3692         if (qsbDivider != null) qsbDivider.setAlpha(reducedFade);
3693         if (dockDivider != null) dockDivider.setAlpha(reducedFade);
3694         scrollIndicator.setAlpha(1 - fade);
3695     }
3696 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher2;
  17 
  18 import android.animation.Animator;
  19 import android.animation.AnimatorListenerAdapter;
  20 import android.animation.AnimatorSet;
  21 import android.animation.ObjectAnimator;
  22 import android.animation.TimeInterpolator;
  23 import android.animation.ValueAnimator.AnimatorUpdateListener;
  24 import android.animation.ValueAnimator;
  25 import android.app.AlertDialog;
  26 import android.app.WallpaperManager;
  27 import android.appwidget.AppWidgetHostView;
  28 import android.appwidget.AppWidgetManager;
  29 import android.appwidget.AppWidgetProviderInfo;
  30 import android.content.ClipData;
  31 import android.content.ClipDescription;
  32 import android.content.ComponentName;
  33 import android.content.Context;
  34 import android.content.Intent;
  35 import android.content.res.Resources;
  36 import android.content.res.TypedArray;
  37 import android.graphics.Bitmap;
  38 import android.graphics.Camera;
  39 import android.graphics.Canvas;
  40 import android.graphics.Matrix;
  41 import android.graphics.Paint;
  42 import android.graphics.Point;
  43 import android.graphics.Rect;
  44 import android.graphics.RectF;
  45 import android.graphics.Region.Op;
  46 import android.graphics.drawable.Drawable;
  47 import android.os.IBinder;
  48 import android.os.Parcelable;
  49 import android.util.AttributeSet;
  50 import android.util.DisplayMetrics;
  51 import android.util.Log;
  52 import android.util.Pair;
  53 import android.view.Display;
  54 import android.view.DragEvent;
  55 import android.view.MotionEvent;
  56 import android.view.View.MeasureSpec;
  57 import android.view.View;
  58 import android.view.ViewConfiguration;
  59 import android.view.ViewGroup;
  60 import android.view.animation.AccelerateInterpolator;
  61 import android.view.animation.DecelerateInterpolator;
  62 import android.widget.ImageView;
  63 import android.widget.TextView;
  64 import android.widget.Toast;
  65 import com.android.launcher.R;
  66 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  67 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  68 import java.util.ArrayList;
  69 import java.util.HashSet;
  70 import java.util.List;
  71 
  72 
  73 /**
  74  * The workspace is a wide area with a wallpaper and a finite number of pages.
  75  * Each page contains a number of icons, folders or widgets the user can
  76  * interact with. A workspace is meant to be used with a fixed width only.
  77  */
<abbr title="  78 public class Workspace extends SmoothPagedView implements DropTarget , DragSource , DragScroller , View.OnTouchListener , DragController.DragListener , LauncherTransitionable {">  78 public class Workspace extends SmoothPagedView implements DropTarget , DragSource , DragScroller , View.O</abbr>
  79     @SuppressWarnings({&quot;UnusedDeclaration&quot;})
  80     private static final String TAG = &quot;Launcher.Workspace&quot;;
  81 
  82     // Y rotation to apply to the workspace screens
  83     // Y rotation to apply to the workspace screens
  84     private static final float WORKSPACE_ROTATION = 12.5f;
  85 
  86     private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  87 
  88     private static float CAMERA_DISTANCE = 6500;
  89 
  90     private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  91 
  92     private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  93 
  94     private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  95 
  96     private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  97 
  98     private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
  99 
 100     private static final int FLING_THRESHOLD_VELOCITY = 500;
 101 
 102     // These animators are used to fade the children&#x27;s outlines
 103     // These animators are used to fade the children&#x27;s outlines
 104     private ObjectAnimator mChildrenOutlineFadeInAnimation;
 105 
 106     private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 107 
 108     private float mChildrenOutlineAlpha = 0;
 109 
 110     // These properties refer to the background protection gradient used for AllApps and Customize
 111     // These properties refer to the background protection gradient used for AllApps and Customize
 112     private ValueAnimator mBackgroundFadeInAnimation;
 113 
 114     private ValueAnimator mBackgroundFadeOutAnimation;
 115 
 116     private Drawable mBackground;
 117 
 118     boolean mDrawBackground = true;
 119 
 120     private float mBackgroundAlpha = 0;
 121 
 122     private float mOverScrollMaxBackgroundAlpha = 0.0f;
 123 
 124     private int mOverScrollPageIndex = -1;
 125 
 126     private float mWallpaperScrollRatio = 1.0f;
 127 
 128     private final WallpaperManager mWallpaperManager;
 129 
 130     private IBinder mWindowToken;
 131 
 132     private static final float WALLPAPER_SCREENS_SPAN = 2f;
 133 
 134     private int mDefaultPage;
 135 
 136     /**
 137      * CellInfo for the cell that is currently being dragged
 138      */
 139     private CellLayout.CellInfo mDragInfo;
 140 
 141     /**
 142      * Target drop area calculated during last acceptDrop call.
 143      */
 144     private int[] mTargetCell = new int[2];
 145 
 146     /**
 147      * The CellLayout that is currently being dragged over
 148      */
 149     private CellLayout mDragTargetLayout = null;
 150 
 151     private boolean mDragHasEnteredWorkspace = false;
 152 
 153     private Launcher mLauncher;
 154 
 155     private IconCache mIconCache;
 156 
 157     private DragController mDragController;
 158 
 159     // These are temporary variables to prevent having to allocate a new object just to
 160     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 161     private int[] mTempCell = new int[2];
 162 
 163     private int[] mTempEstimate = new int[2];
 164 
 165     private float[] mDragViewVisualCenter = new float[2];
 166 
 167     private float[] mTempDragCoordinates = new float[2];
 168 
 169     private float[] mTempCellLayoutCenterCoordinates = new float[2];
 170 
 171     private float[] mTempDragBottomRightCoordinates = new float[2];
 172 
 173     private Matrix mTempInverseMatrix = new Matrix();
 174 
 175     private SpringLoadedDragController mSpringLoadedDragController;
 176 
 177     private float mSpringLoadedShrinkFactor;
 178 
 179     private static final int DEFAULT_CELL_COUNT_X = 4;
 180 
 181     private static final int DEFAULT_CELL_COUNT_Y = 4;
 182 
 183     // State variable that indicates whether the pages are small (ie when you&#x27;re
 184     // in all apps or customize mode)
 185     enum State {
 186 
 187         NORMAL,
 188         SPRING_LOADED,
 189         SMALL;}
 190 
 191     private State mState = State.NORMAL;
 192 
 193     private boolean mIsSwitchingState = false;
 194 
 195     boolean mAnimatingViewIntoPlace = false;
 196 
 197     boolean mIsDragOccuring = false;
 198 
 199     boolean mChildrenLayersEnabled = true;
 200 
 201     /** Is the user is dragging an item near the edge of a page? */
 202     private boolean mInScrollArea = false;
 203 
 204     private final HolographicOutlineHelper mOutlineHelper = new HolographicOutlineHelper();
 205 
 206     private Bitmap mDragOutline = null;
 207 
 208     private final Rect mTempRect = new Rect();
 209 
 210     private final int[] mTempXY = new int[2];
 211 
 212     private float mOverscrollFade = 0;
 213 
 214     public static final int DRAG_BITMAP_PADDING = 0;
 215 
 216     // Paint used to draw external drop outline
 217     // Paint used to draw external drop outline
 218     private final Paint mExternalDragOutlinePaint = new Paint();
 219 
 220     // Camera and Matrix used to determine the final position of a neighboring CellLayout
 221     // Camera and Matrix used to determine the final position of a neighboring CellLayout
 222     private final Matrix mMatrix = new Matrix();
 223 
 224     private final Camera mCamera = new Camera();
 225 
 226     private final float mTempFloat2[] = new float[2];
 227 
 228     enum WallpaperVerticalOffset {
 229 
 230         TOP,
 231         MIDDLE,
 232         BOTTOM;}
 233 
 234     int mWallpaperWidth;
 235 
 236     int mWallpaperHeight;
 237 
 238     WallpaperOffsetInterpolator mWallpaperOffset;
 239 
 240     boolean mUpdateWallpaperOffsetImmediately = false;
 241 
 242     private Runnable mDelayedResizeRunnable;
 243 
 244     private int mDisplayWidth;
 245 
 246     private int mDisplayHeight;
 247 
 248     private boolean mIsStaticWallpaper;
 249 
 250     private int mWallpaperTravelWidth;
 251 
 252     // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 253     // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 254     private static final int FOLDER_CREATION_TIMEOUT = 250;
 255 
 256     private final Alarm mFolderCreationAlarm = new Alarm();
 257 
 258     private FolderRingAnimator mDragFolderRingAnimator = null;
 259 
 260     private View mLastDragOverView = null;
 261 
 262     private boolean mCreateUserFolderOnDrop = false;
 263 
 264     // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 265     // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 266     private float mXDown;
 267 
 268     private float mYDown;
 269 
 270     final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 271 
 272     final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 273 
 274     final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
 275 
 276     // Relating to the animation of items being dropped externally
 277     // Relating to the animation of items being dropped externally
 278     public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;
 279 
 280     public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;
 281 
 282     public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;
 283 
 284     public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;
 285 
 286     public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;
 287 
 288     // Relating to workspace drag fade out
 289     private float mDragFadeOutAlpha;
 290 
 291     private int mDragFadeOutDuration;
 292 
 293     // These variables are used for storing the initial and final values during workspace animations
 294     // These variables are used for storing the initial and final values during workspace animations
 295     private int mSavedScrollX;
 296 
 297     private float mSavedRotationY;
 298 
 299     private float mSavedTranslationX;
 300 
 301     private float mCurrentScaleX;
 302 
 303     private float mCurrentScaleY;
 304 
 305     private float mCurrentRotationY;
 306 
 307     private float mCurrentTranslationX;
 308 
 309     private float mCurrentTranslationY;
 310 
 311     private float[] mOldTranslationXs;
 312 
 313     private float[] mOldTranslationYs;
 314 
 315     private float[] mOldScaleXs;
 316 
 317     private float[] mOldScaleYs;
 318 
 319     private float[] mOldBackgroundAlphas;
 320 
 321     private float[] mOldBackgroundAlphaMultipliers;
 322 
 323     private float[] mOldAlphas;
 324 
 325     private float[] mOldRotationYs;
 326 
 327     private float[] mNewTranslationXs;
 328 
 329     private float[] mNewTranslationYs;
 330 
 331     private float[] mNewScaleXs;
 332 
 333     private float[] mNewScaleYs;
 334 
 335     private float[] mNewBackgroundAlphas;
 336 
 337     private float[] mNewBackgroundAlphaMultipliers;
 338 
 339     private float[] mNewAlphas;
 340 
 341     private float[] mNewRotationYs;
 342 
 343     private float mTransitionProgress;
 344 
 345     /**
 346      * Used to inflate the Workspace from XML.
 347      *
 348      * @param context
 349      * 		The application&#x27;s context.
 350      * @param attrs
 351      * 		The attributes set containing the Workspace&#x27;s customization values.
 352      */
 353     public Workspace(Context context, AttributeSet attrs) {
 354         this(context, attrs, 0);
 355     }
 356 
 357     /**
 358      * Used to inflate the Workspace from XML.
 359      *
 360      * @param context The application&#x27;s context.
 361      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 362      * @param defStyle Unused.
 363      */
 364     public Workspace(Context context, AttributeSet attrs, int defStyle) {
 365         super(context, attrs, defStyle);
 366         mContentIsRefreshable = false;
 367         // With workspace, data is available straight from the get-go
 368         setDataIsReady();
 369         final Resources res = getResources();
 370         mFadeInAdjacentScreens = res.getBoolean(R.bool.config_workspaceFadeAdjacentScreens);
 371         mDragFadeOutAlpha = res.getInteger(R.integer.config_dragFadeOutAlpha) / 100.0F;
 372         mDragFadeOutDuration = res.getInteger(R.integer.config_dragFadeOutDuration);
 373         mWallpaperManager = WallpaperManager.getInstance(context);
 374         int cellCountX = DEFAULT_CELL_COUNT_X;
 375         int cellCountY = DEFAULT_CELL_COUNT_Y;
 376         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Workspace, defStyle, 0);
 377         if (LauncherApplication.isScreenLarge()) {
 378             // Determine number of rows/columns dynamically
 379             // TODO: This code currently fails on tablets with an aspect ratio &lt; 1.3.
 380             // Around that ratio we should make cells the same size in portrait and
 381             // landscape
<abbr title=" 382             TypedArray actionBarSizeTypedArray = context.obtainStyledAttributes(new int[]{ android.R.attr.actionBarSize });"> 382             TypedArray actionBarSizeTypedArray = context.obtainStyledAttributes(new int[]{ android.R.attr</abbr>
 383             DisplayMetrics displayMetrics = res.getDisplayMetrics();
 384             final float actionBarHeight = actionBarSizeTypedArray.getDimension(0, 0.0F);
 385             final float systemBarHeight = res.getDimension(R.dimen.status_bar_height);
<abbr title=" 386             final float smallestScreenDim = res.getConfiguration().smallestScreenWidthDp * displayMetrics.density;"> 386             final float smallestScreenDim = res.getConfiguration().smallestScreenWidthDp * displayMetrics</abbr>
 387             cellCountX = 1;
 388             while (CellLayout.widthInPortrait(res, cellCountX + 1) &lt;= smallestScreenDim) {
 389                 cellCountX++;
 390             }
 391             cellCountY = 1;
<abbr title=" 392             while ((actionBarHeight + CellLayout.heightInLandscape(res, cellCountY + 1)) &lt;= (smallestScreenDim - systemBarHeight)) {"> 392             while ((actionBarHeight + CellLayout.heightInLandscape(res, cellCountY + 1)) &lt;= (smallestScre</abbr>
 393                 cellCountY++;
 394             }
 395         }
<abbr title=" 396         mSpringLoadedShrinkFactor = res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0F;"> 396         mSpringLoadedShrinkFactor = res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) </abbr>
 397         // if the value is manually specified, use that instead
 398         cellCountX = a.getInt(R.styleable.Workspace_cellCountX, cellCountX);
 399         cellCountY = a.getInt(R.styleable.Workspace_cellCountY, cellCountY);
 400         mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 401         a.recycle();
 402         LauncherModel.updateWorkspaceLayoutCells(cellCountX, cellCountY);
 403         setHapticFeedbackEnabled(false);
 404         mLauncher = ((Launcher) (context));
 405         initWorkspace();
 406         // Disable multitouch across the workspace/all apps/customize tray
 407         setMotionEventSplittingEnabled(true);
 408     }
 409 
 410     // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 411     // dimension if unsuccessful
 412     public int[] estimateItemSize(int hSpan, int vSpan, ItemInfo itemInfo, boolean springLoaded) {
 413         int[] size = new int[2];
 414         if (getChildCount() &gt; 0) {
 415             CellLayout cl = ((CellLayout) (mLauncher.getWorkspace().getChildAt(0)));
 416             Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);
 417             size[0] = r.width();
 418             size[1] = r.height();
 419             if (springLoaded) {
 420                 size[0] *= mSpringLoadedShrinkFactor;
 421                 size[1] *= mSpringLoadedShrinkFactor;
 422             }
 423             return size;
 424         } else {
 425             size[0] = Integer.MAX_VALUE;
 426             size[1] = Integer.MAX_VALUE;
 427             return size;
 428         }
 429     }
 430 
<abbr title=" 431     public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo, int hCell, int vCell, int hSpan, int vSpan) {"> 431     public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo, int hCell, int vCell, int hSpan</abbr>
 432         Rect r = new Rect();
 433         cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 434         return r;
 435     }
 436 
 437     public void buildPageHardwareLayers() {
 438         if (getWindowToken() != null) {
 439             final int childCount = getChildCount();
 440             for (int i = 0; i &lt; childCount; i++) {
 441                 CellLayout cl = (CellLayout) getChildAt(i);
 442                 cl.buildChildrenLayer();
 443             }
 444         }
 445     }
 446 
 447     public void onDragStart(DragSource source, Object info, int dragAction) {
 448         mIsDragOccuring = true;
 449         updateChildrenLayersEnabled();
 450         mLauncher.lockScreenOrientationOnLargeUI();
 451         // Fade out the workspace slightly to highlight the currently dragging item
 452         int count = getChildCount();
 453         for (int i = 0; i &lt; count; i++) {
 454             CellLayout cl = ((CellLayout) (getPageAt(i)));
<abbr title=" 455             cl.getChildrenLayout().animate().alpha(mDragFadeOutAlpha).setInterpolator(new AccelerateInterpolator(1.5F)).setDuration(mDragFadeOutDuration).start();"> 455             cl.getChildrenLayout().animate().alpha(mDragFadeOutAlpha).setInterpolator(new AccelerateInter</abbr>
 456         }
 457     }
 458 
 459     public void onDragEnd() {
 460         mIsDragOccuring = false;
 461         updateChildrenLayersEnabled();
 462         mLauncher.unlockScreenOrientationOnLargeUI();
 463         // Fade the workspace back in after we have completed dragging
 464         int count = getChildCount();
 465         for (int i = 0; i &lt; count; i++) {
 466             CellLayout cl = ((CellLayout) (getPageAt(i)));
<abbr title=" 467             cl.getChildrenLayout().animate().alpha(1.0F).setInterpolator(new DecelerateInterpolator(1.5F)).setDuration(mDragFadeOutDuration).start();"> 467             cl.getChildrenLayout().animate().alpha(1.0F).setInterpolator(new DecelerateInterpolator(1.5F)</abbr>
 468         }
 469     }
 470 
 471     /**
 472      * Initializes various states for this workspace.
 473      */
 474     protected void initWorkspace() {
 475         Context context = getContext();
 476         mCurrentPage = mDefaultPage;
 477         Launcher.setScreen(mCurrentPage);
 478         LauncherApplication app = ((LauncherApplication) (context.getApplicationContext()));
 479         mIconCache = app.getIconCache();
 480         mExternalDragOutlinePaint.setAntiAlias(true);
 481         setWillNotDraw(false);
 482         setChildrenDrawnWithCacheEnabled(true);
 483         try {
 484             final Resources res = getResources();
 485             mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 486         } catch (Resources e) {
 487             // In this case, we will skip drawing background protection
 488         }
 489         mWallpaperOffset = new WallpaperOffsetInterpolator();
 490         Display display = mLauncher.getWindowManager().getDefaultDisplay();
 491         mDisplayWidth = display.getWidth();
 492         mDisplayHeight = display.getHeight();
<abbr title=" 493         mWallpaperTravelWidth = ((int) (mDisplayWidth * wallpaperTravelToScreenWidthRatio(mDisplayWidth, mDisplayHeight)));"> 493         mWallpaperTravelWidth = ((int) (mDisplayWidth * wallpaperTravelToScreenWidthRatio(mDisplayWidth, </abbr>
 494         mFlingThresholdVelocity = ((int) (FLING_THRESHOLD_VELOCITY * mDensity));
 495     }
 496 
 497     @Override
 498     protected int getScrollMode() {
 499         return SmoothPagedView.X_LARGE_MODE;
 500     }
 501 
 502     @Override
 503     protected void onViewAdded(View child) {
 504         super.onViewAdded(child);
 505         if (!(child instanceof CellLayout)) {
 506             throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 507         }
 508         CellLayout cl = ((CellLayout) child);
 509         cl.setOnInterceptTouchListener(this);
 510         cl.setClickable(true);
 511         cl.enableHardwareLayers();
 512     }
 513 
 514     /**
 515      * @return The open folder on the current screen, or null if there is none
 516      */
 517     Folder getOpenFolder() {
 518         DragLayer dragLayer = mLauncher.getDragLayer();
 519         int count = dragLayer.getChildCount();
 520         for (int i = 0; i &lt; count; i++) {
 521             View child = dragLayer.getChildAt(i);
 522             if (child instanceof Folder) {
 523                 Folder folder = (Folder) child;
 524                 if (folder.getInfo().opened)
 525                     return folder;
 526             }
 527         }
 528         return null;
 529     }
 530 
 531     boolean isTouchActive() {
 532         return mTouchState != TOUCH_STATE_REST;
 533     }
 534 
 535     /**
 536      * Adds the specified child in the specified screen. The position and dimension of
 537      * the child are defined by x, y, spanX and spanY.
 538      *
 539      * @param child The child to add in one of the workspace&#x27;s screens.
 540      * @param screen The screen in which to add the child.
 541      * @param x The X position of the child in the screen&#x27;s grid.
 542      * @param y The Y position of the child in the screen&#x27;s grid.
 543      * @param spanX The number of cells spanned horizontally by the child.
 544      * @param spanY The number of cells spanned vertically by the child.
 545      */
 546     void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY) {
 547         addInScreen(child, container, screen, x, y, spanX, spanY, false);
 548     }
 549 
 550     /**
 551      * Adds the specified child in the specified screen. The position and dimension of
 552      * the child are defined by x, y, spanX and spanY.
 553      *
 554      * @param child The child to add in one of the workspace&#x27;s screens.
 555      * @param screen The screen in which to add the child.
 556      * @param x The X position of the child in the screen&#x27;s grid.
 557      * @param y The Y position of the child in the screen&#x27;s grid.
 558      * @param spanX The number of cells spanned horizontally by the child.
 559      * @param spanY The number of cells spanned vertically by the child.
 560      * @param insert When true, the child is inserted at the beginning of the children list.
 561      */
<abbr title=" 562     void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY, boolean insert) {"> 562     void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY, boolean </abbr>
 563         if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 564             if ((screen &lt; 0) || (screen &gt;= getChildCount())) {
<abbr title=" 565                 Log.e(TAG, (((&quot;The screen must be &gt;= 0 and &lt; &quot; + getChildCount()) + &quot; (was &quot;) + screen) + &quot;); skipping child&quot;);"> 565                 Log.e(TAG, (((&quot;The screen must be &gt;= 0 and &lt; &quot; + getChildCount()) + &quot; (was &quot;) + screen) +</abbr>
 566                 return;
 567             }
 568         }
 569         final CellLayout layout;
 570         if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 571             layout = mLauncher.getHotseat().getLayout();
 572             child.setOnKeyListener(null);
 573             // Hide folder title in the hotseat
 574             if (child instanceof FolderIcon) {
 575                 ((FolderIcon) (child)).setTextVisible(false);
 576             }
 577             if (screen &lt; 0) {
 578                 screen = mLauncher.getHotseat().getOrderInHotseat(x, y);
 579             } else {
 580                 // Note: We do this to ensure that the hotseat is always laid out in the orientation
 581                 // of the hotseat in order regardless of which orientation they were added
 582                 x = mLauncher.getHotseat().getCellXFromOrder(screen);
 583                 y = mLauncher.getHotseat().getCellYFromOrder(screen);
 584             }
 585         } else {
 586             // Show folder title if not in the hotseat
 587             if (child instanceof FolderIcon) {
 588                 ((FolderIcon) (child)).setTextVisible(true);
 589             }
 590             layout = ((CellLayout) (getChildAt(screen)));
 591             child.setOnKeyListener(new IconKeyEventListener());
 592         }
 593         LayoutParams genericLp = child.getLayoutParams();
 594         CellLayout.LayoutParams lp;
 595         if ((genericLp == null) || (!(genericLp instanceof CellLayout.LayoutParams))) {
 596             lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 597         } else {
 598             lp = ((CellLayout.LayoutParams) (genericLp));
 599             lp.cellX = x;
 600             lp.cellY = y;
 601             lp.cellHSpan = spanX;
 602             lp.cellVSpan = spanY;
 603         }
 604         if ((spanX &lt; 0) &amp;&amp; (spanY &lt; 0)) {
 605             lp.isLockedToGrid = false;
 606         }
 607         // Get the canonical child id to uniquely represent this view in this screen
 608         int childId = LauncherModel.getCellLayoutChildId(container, screen, x, y, spanX, spanY);
 609         boolean markCellsAsOccupied = !(child instanceof Folder);
 610         if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 611             // TODO: This branch occurs when the workspace is adding views
 612             // outside of the defined grid
 613             // maybe we should be deleting these items from the LauncherModel?
<abbr title=" 614             Log.w(TAG, (((&quot;Failed to add to item at (&quot; + lp.cellX) + &quot;,&quot;) + lp.cellY) + &quot;) to CellLayout&quot;);"> 614             Log.w(TAG, (((&quot;Failed to add to item at (&quot; + lp.cellX) + &quot;,&quot;) + lp.cellY) + &quot;) to CellLayout&quot;</abbr>
 615         }
 616         if (!(child instanceof Folder)) {
 617             child.setHapticFeedbackEnabled(false);
 618             child.setOnLongClickListener(mLongClickListener);
 619         }
 620         if (child instanceof DropTarget) {
 621             mDragController.addDropTarget(((DropTarget) (child)));
 622         }
 623     }
 624 
 625     /**
 626      * Check if the point (x, y) hits a given page.
 627      */
 628     private boolean hitsPage(int index, float x, float y) {
 629         final View page = getChildAt(index);
 630         if (page != null) {
 631             float[] localXY = { x, y };
 632             mapPointFromSelfToChild(page, localXY);
 633             return (localXY[0] &gt;= 0 &amp;&amp; localXY[0] &lt; page.getWidth()
 634                     &amp;&amp; localXY[1] &gt;= 0 &amp;&amp; localXY[1] &lt; page.getHeight());
 635         }
 636         return false;
 637     }
 638 
 639     @Override
 640     protected boolean hitsPreviousPage(float x, float y) {
 641         // mNextPage is set to INVALID_PAGE whenever we are stationary.
 642         // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 643         final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 644 
 645         // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 646         // the active workspace
 647         return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current - 1, x, y);
 648     }
 649 
 650     @Override
 651     protected boolean hitsNextPage(float x, float y) {
 652         // mNextPage is set to INVALID_PAGE whenever we are stationary.
 653         // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 654         final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 655 
 656         // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 657         // the active workspace
 658         return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current + 1, x, y);
 659     }
 660 
 661     /**
 662      * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 663      * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 664      * that it should intercept touch events, which is not something that is normally supported.
 665      */
 666     @Override
 667     public boolean onTouch(View v, MotionEvent event) {
 668         return isSmall() || (!isFinishedSwitchingState());
 669     }
 670 
 671     public boolean isSwitchingState() {
 672         return mIsSwitchingState;
 673     }
 674 
 675     /** This differs from isSwitchingState in that we take into account how far the transition
 676      *  has completed. */
 677     public boolean isFinishedSwitchingState() {
 678         return (!mIsSwitchingState) || (mTransitionProgress &gt; 0.5F);
 679     }
 680 
 681     protected void onWindowVisibilityChanged (int visibility) {
 682         mLauncher.onWindowVisibilityChanged(visibility);
 683     }
 684 
 685     @Override
 686     public boolean dispatchUnhandledMove(View focused, int direction) {
 687         if (isSmall() || (!isFinishedSwitchingState())) {
 688             // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
 689             return false;
 690         }
 691         return super.dispatchUnhandledMove(focused, direction);
 692     }
 693 
 694     @Override
 695     public boolean onInterceptTouchEvent(MotionEvent ev) {
 696         switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
 697         case MotionEvent.ACTION_DOWN:
 698             mXDown = ev.getX();
 699             mYDown = ev.getY();
 700             break;
 701         case MotionEvent.ACTION_POINTER_UP:
 702         case MotionEvent.ACTION_UP:
 703             if (mTouchState == TOUCH_STATE_REST) {
 704                 final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
 705                 if (!currentPage.lastDownOnOccupiedCell()) {
 706                     onWallpaperTap(ev);
 707                 }
 708             }
 709         }
 710         return super.onInterceptTouchEvent(ev);
 711     }
 712 
 713     @Override
 714     protected void determineScrollingStart(MotionEvent ev) {
 715         if (isSmall()) {
 716             return;
 717         }
 718         if (!isFinishedSwitchingState()) {
 719             return;
 720         }
 721         float deltaX = Math.abs(ev.getX() - mXDown);
 722         float deltaY = Math.abs(ev.getY() - mYDown);
 723         if (Float.compare(deltaX, 0.0F) == 0) {
 724             return;
 725         }
 726         float slope = deltaY / deltaX;
 727         float theta = ((float) (Math.atan(slope)));
 728         if ((deltaX &gt; mTouchSlop) || (deltaY &gt; mTouchSlop)) {
 729             cancelCurrentPageLongPress();
 730         }
 731         if (theta &gt; MAX_SWIPE_ANGLE) {
 732             // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace
 733             return;
 734         } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {
 735             // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to
 736             // increase the touch slop to make it harder to begin scrolling the workspace. This
 737             // results in vertically scrolling widgets to more easily. The higher the angle, the
 738             // more we increase touch slop.
 739             theta -= START_DAMPING_TOUCH_SLOP_ANGLE;
<abbr title=" 740             float extraRatio = ((float) (Math.sqrt(theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE))));"> 740             float extraRatio = ((float) (Math.sqrt(theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_AN</abbr>
 741             super.determineScrollingStart(ev, 1 + (TOUCH_SLOP_DAMPING_FACTOR * extraRatio));
 742         } else {
 743             // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special
 744             super.determineScrollingStart(ev);
 745         }
 746     }
 747 
 748     @Override
 749     protected boolean isScrollingIndicatorEnabled() {
 750         return mState != State.SPRING_LOADED;
 751     }
 752 
 753     protected void onPageBeginMoving() {
 754         super.onPageBeginMoving();
 755         if (isHardwareAccelerated()) {
 756             updateChildrenLayersEnabled();
 757         } else if (mNextPage != INVALID_PAGE) {
 758             // we&#x27;re snapping to a particular screen
 759             enableChildrenCache(mCurrentPage, mNextPage);
 760         } else {
 761             // this is when user is actively dragging a particular screen, they might
 762             // swipe it either left or right (but we won&#x27;t advance by more than one screen)
 763             enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
 764         }
 765         // Only show page outlines as we pan if we are on large screen
 766         if (LauncherApplication.isScreenLarge()) {
 767             showOutlines();
 768             mIsStaticWallpaper = mWallpaperManager.getWallpaperInfo() == null;
 769         }
 770         // If we are not fading in adjacent screens, we still need to restore the alpha in case the
 771         // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)
 772         if (!mFadeInAdjacentScreens) {
 773             for (int i = 0; i &lt; getChildCount(); ++i) {
 774                 getPageAt(i).setAlpha(1.0F);
 775             }
 776         }
 777         // Show the scroll indicator as you pan the page
 778         showScrollingIndicator(false);
 779     }
 780 
 781     protected void onPageEndMoving() {
 782         super.onPageEndMoving();
 783         if (isHardwareAccelerated()) {
 784             updateChildrenLayersEnabled();
 785         } else {
 786             clearChildrenCache();
 787         }
 788         if (mDragController.isDragging()) {
 789             if (isSmall()) {
 790                 // If we are in springloaded mode, then force an event to check if the current touch
 791                 // is under a new page (to scroll to)
 792                 mDragController.forceMoveEvent();
 793             }
 794         } else {
 795             // If we are not mid-dragging, hide the page outlines if we are on a large screen
 796             if (LauncherApplication.isScreenLarge()) {
 797                 hideOutlines();
 798             }
 799             // Hide the scroll indicator as you pan the page
 800             if (!mDragController.isDragging()) {
 801                 hideScrollingIndicator(false);
 802             }
 803         }
 804         mOverScrollMaxBackgroundAlpha = 0.0F;
 805         mOverScrollPageIndex = -1;
 806         if (mDelayedResizeRunnable != null) {
 807             mDelayedResizeRunnable.run();
 808             mDelayedResizeRunnable = null;
 809         }
 810     }
 811 
 812     @Override
 813     protected void notifyPageSwitchListener() {
 814         super.notifyPageSwitchListener();
 815         Launcher.setScreen(mCurrentPage);
 816     }
 817 
 818     // As a ratio of screen height, the total distance we want the parallax effect to span
 819     // horizontally
 820     private float wallpaperTravelToScreenWidthRatio(int width, int height) {
 821         float aspectRatio = width / (float) height;
 822 
 823         // At an aspect ratio of 16/10, the wallpaper parallax effect should span 1.5 * screen width
 824         // At an aspect ratio of 10/16, the wallpaper parallax effect should span 1.2 * screen width
 825         // We will use these two data points to extrapolate how much the wallpaper parallax effect
 826         // to span (ie travel) at any aspect ratio:
 827 
 828         final float ASPECT_RATIO_LANDSCAPE = 16/10f;
 829         final float ASPECT_RATIO_PORTRAIT = 10/16f;
 830         final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE = 1.5f;
 831         final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT = 1.2f;
 832 
 833         // To find out the desired width at different aspect ratios, we use the following two
 834         // formulas, where the coefficient on x is the aspect ratio (width/height):
 835         //   (16/10)x + y = 1.5
 836         //   (10/16)x + y = 1.2
 837         // We solve for x and y and end up with a final formula:
 838         final float x =
 839             (WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE - WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT) /
 840             (ASPECT_RATIO_LANDSCAPE - ASPECT_RATIO_PORTRAIT);
 841         final float y = WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT - x * ASPECT_RATIO_PORTRAIT;
 842         return x * aspectRatio + y;
 843     }
 844 
 845     // The range of scroll values for Workspace
 846     private int getScrollRange() {
 847         return getChildOffset(getChildCount() - 1) - getChildOffset(0);
 848     }
 849 
 850     protected void setWallpaperDimension() {
 851         DisplayMetrics displayMetrics = new DisplayMetrics();
 852         mLauncher.getWindowManager().getDefaultDisplay().getRealMetrics(displayMetrics);
 853         final int maxDim = Math.max(displayMetrics.widthPixels, displayMetrics.heightPixels);
 854         final int minDim = Math.min(displayMetrics.widthPixels, displayMetrics.heightPixels);
 855 
 856         // We need to ensure that there is enough extra space in the wallpaper for the intended
 857         // parallax effects
 858         if (LauncherApplication.isScreenLarge()) {
 859             mWallpaperWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
 860             mWallpaperHeight = maxDim;
 861         } else {
 862             mWallpaperWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
 863             mWallpaperHeight = maxDim;
 864         }
 865         new Thread(&quot;setWallpaperDimension&quot;) {
 866             public void run() {
 867                 mWallpaperManager.suggestDesiredDimensions(mWallpaperWidth, mWallpaperHeight);
 868             }
 869         }.start();
 870     }
 871 
 872     private float wallpaperOffsetForCurrentScroll() {
 873         // Set wallpaper offset steps (1 / (number of screens - 1))
 874         mWallpaperManager.setWallpaperOffsetSteps(1.0F / (getChildCount() - 1), 1.0F);
 875         // For the purposes of computing the scrollRange and overScrollOffset, we assume
 876         // that mLayoutScale is 1. This means that when we&#x27;re in spring-loaded mode,
 877         // there&#x27;s no discrepancy between the wallpaper offset for a given page.
 878         float layoutScale = mLayoutScale;
 879         mLayoutScale = 1.0F;
 880         int scrollRange = getScrollRange();
 881         // Again, we adjust the wallpaper offset to be consistent between values of mLayoutScale
 882         float adjustedScrollX = Math.max(0, Math.min(mScrollX, mMaxScrollX));
 883         adjustedScrollX *= mWallpaperScrollRatio;
 884         mLayoutScale = layoutScale;
 885         float scrollProgress = adjustedScrollX / ((float) (scrollRange));
 886         if (LauncherApplication.isScreenLarge() &amp;&amp; mIsStaticWallpaper) {
 887         // The wallpaper travel width is how far, from left to right, the wallpaper will move
 888         // at this orientation. On tablets in portrait mode we don&#x27;t move all the way to the
 889         // edges of the wallpaper, or otherwise the parallax effect would be too strong.
 890             int wallpaperTravelWidth = Math.min(mWallpaperTravelWidth, mWallpaperWidth);
<abbr title=" 891             float offsetInDips = (wallpaperTravelWidth * scrollProgress) + ((mWallpaperWidth - wallpaperTravelWidth) / 2);// center it"> 891             float offsetInDips = (wallpaperTravelWidth * scrollProgress) + ((mWallpaperWidth - wallpaperT</abbr>
 892 
 893             float offset = offsetInDips / ((float) (mWallpaperWidth));
 894             return offset;
 895         } else {
 896             return scrollProgress;
 897         }
 898     }
 899 
 900     private void syncWallpaperOffsetWithScroll() {
 901         final boolean enableWallpaperEffects = isHardwareAccelerated();
 902         if (enableWallpaperEffects) {
 903             mWallpaperOffset.setFinalX(wallpaperOffsetForCurrentScroll());
 904         }
 905     }
 906 
 907     public void updateWallpaperOffsetImmediately() {
 908         mUpdateWallpaperOffsetImmediately = true;
 909     }
 910 
 911     private void updateWallpaperOffsets() {
 912         boolean updateNow = false;
 913         boolean keepUpdating = true;
 914         if (mUpdateWallpaperOffsetImmediately) {
 915             updateNow = true;
 916             keepUpdating = false;
 917             mWallpaperOffset.jumpToFinal();
 918             mUpdateWallpaperOffsetImmediately = false;
 919         } else {
 920             updateNow = keepUpdating = mWallpaperOffset.computeScrollOffset();
 921         }
 922         if (updateNow) {
 923             if (mWindowToken != null) {
<abbr title=" 924                 mWallpaperManager.setWallpaperOffsets(mWindowToken, mWallpaperOffset.getCurrX(), mWallpaperOffset.getCurrY());"> 924                 mWallpaperManager.setWallpaperOffsets(mWindowToken, mWallpaperOffset.getCurrX(), mWallpap</abbr>
 925             }
 926         }
 927         if (keepUpdating) {
 928             invalidate();
 929         }
 930     }
 931 
 932     @Override
 933     protected void updateCurrentPageScroll() {
 934         super.updateCurrentPageScroll();
 935         computeWallpaperScrollRatio(mCurrentPage);
 936     }
 937 
 938     @Override
 939     protected void snapToPage(int whichPage) {
 940         super.snapToPage(whichPage);
 941         computeWallpaperScrollRatio(whichPage);
 942     }
 943 
 944     private void computeWallpaperScrollRatio(int page) {
 945         // Here, we determine what the desired scroll would be with and without a layout scale,
 946         // and compute a ratio between the two. This allows us to adjust the wallpaper offset
 947         // as though there is no layout scale.
 948         float layoutScale = mLayoutScale;
 949         int scaled = getChildOffset(page) - getRelativeChildOffset(page);
 950         mLayoutScale = 1.0f;
 951         float unscaled = getChildOffset(page) - getRelativeChildOffset(page);
 952         mLayoutScale = layoutScale;
 953         if (scaled &gt; 0) {
 954             mWallpaperScrollRatio = (1.0f * unscaled) / scaled;
 955         } else {
 956             mWallpaperScrollRatio = 1f;
 957         }
 958     }
 959 
 960     class WallpaperOffsetInterpolator {
 961         float mFinalHorizontalWallpaperOffset = 0.0F;
 962 
 963         float mFinalVerticalWallpaperOffset = 0.5F;
 964 
 965         float mHorizontalWallpaperOffset = 0.0F;
 966 
 967         float mVerticalWallpaperOffset = 0.5F;
 968 
 969         long mLastWallpaperOffsetUpdateTime;
 970 
 971         boolean mIsMovingFast;
 972 
 973         boolean mOverrideHorizontalCatchupConstant;
 974 
 975         float mHorizontalCatchupConstant = 0.35F;
 976 
 977         float mVerticalCatchupConstant = 0.35F;
 978 
 979         public WallpaperOffsetInterpolator() {
 980         }
 981 
 982         public void setOverrideHorizontalCatchupConstant(boolean override) {
 983             mOverrideHorizontalCatchupConstant = override;
 984         }
 985 
 986         public void setHorizontalCatchupConstant(float f) {
 987             mHorizontalCatchupConstant = f;
 988         }
 989 
 990         public void setVerticalCatchupConstant(float f) {
 991             mVerticalCatchupConstant = f;
 992         }
 993 
 994         public boolean computeScrollOffset() {
<abbr title=" 995             if ((Float.compare(mHorizontalWallpaperOffset, mFinalHorizontalWallpaperOffset) == 0) &amp;&amp; (Float.compare(mVerticalWallpaperOffset, mFinalVerticalWallpaperOffset) == 0)) {"> 995             if ((Float.compare(mHorizontalWallpaperOffset, mFinalHorizontalWallpaperOffset) == 0) &amp;&amp; (Flo</abbr>
 996                 mIsMovingFast = false;
 997                 return false;
 998             }
 999             boolean isLandscape = mDisplayWidth &gt; mDisplayHeight;
1000             long currentTime = System.currentTimeMillis();
1001             long timeSinceLastUpdate = currentTime - mLastWallpaperOffsetUpdateTime;
1002             timeSinceLastUpdate = Math.min(((long) (1000 / 30.0F)), timeSinceLastUpdate);
1003             timeSinceLastUpdate = Math.max(1L, timeSinceLastUpdate);
1004             float xdiff = Math.abs(mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset);
1005             if ((!mIsMovingFast) &amp;&amp; (xdiff &gt; 0.07)) {
1006                 mIsMovingFast = true;
1007             }
1008             float fractionToCatchUpIn1MsHorizontal;
1009             if (mOverrideHorizontalCatchupConstant) {
1010                 fractionToCatchUpIn1MsHorizontal = mHorizontalCatchupConstant;
1011             } else if (mIsMovingFast) {
1012                 fractionToCatchUpIn1MsHorizontal = (isLandscape) ? 0.5F : 0.75F;
1013             } else {
1014                 // slow
1015                 fractionToCatchUpIn1MsHorizontal = (isLandscape) ? 0.27F : 0.5F;
1016             }
1017             float fractionToCatchUpIn1MsVertical = mVerticalCatchupConstant;
1018             fractionToCatchUpIn1MsHorizontal /= 33.0F;
1019             fractionToCatchUpIn1MsVertical /= 33.0F;
1020             final float UPDATE_THRESHOLD = 1.0E-5F;
1021             float hOffsetDelta = mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset;
1022             float vOffsetDelta = mFinalVerticalWallpaperOffset - mVerticalWallpaperOffset;
<abbr title="1023             boolean jumpToFinalValue = (Math.abs(hOffsetDelta) &lt; UPDATE_THRESHOLD) &amp;&amp; (Math.abs(vOffsetDelta) &lt; UPDATE_THRESHOLD);">1023             boolean jumpToFinalValue = (Math.abs(hOffsetDelta) &lt; UPDATE_THRESHOLD) &amp;&amp; (Math.abs(vOffsetDe</abbr>
1024             // Don&#x27;t have any lag between workspace and wallpaper on non-large devices
1025             if ((!LauncherApplication.isScreenLarge()) || jumpToFinalValue) {
1026                 mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
1027                 mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
1028             } else {
<abbr title="1029                 float percentToCatchUpVertical = Math.min(1.0F, timeSinceLastUpdate * fractionToCatchUpIn1MsVertical);">1029                 float percentToCatchUpVertical = Math.min(1.0F, timeSinceLastUpdate * fractionToCatchUpIn</abbr>
<abbr title="1030                 float percentToCatchUpHorizontal = Math.min(1.0F, timeSinceLastUpdate * fractionToCatchUpIn1MsHorizontal);">1030                 float percentToCatchUpHorizontal = Math.min(1.0F, timeSinceLastUpdate * fractionToCatchUp</abbr>
1031                 mHorizontalWallpaperOffset += percentToCatchUpHorizontal * hOffsetDelta;
1032                 mVerticalWallpaperOffset += percentToCatchUpVertical * vOffsetDelta;
1033             }
1034             mLastWallpaperOffsetUpdateTime = System.currentTimeMillis();
1035             return true;
1036         }
1037 
1038         public float getCurrX() {
1039             return mHorizontalWallpaperOffset;
1040         }
1041 
1042         public float getFinalX() {
1043             return mFinalHorizontalWallpaperOffset;
1044         }
1045 
1046         public float getCurrY() {
1047             return mVerticalWallpaperOffset;
1048         }
1049 
1050         public float getFinalY() {
1051             return mFinalVerticalWallpaperOffset;
1052         }
1053 
1054         public void setFinalX(float x) {
1055             mFinalHorizontalWallpaperOffset = Math.max(0.0F, Math.min(x, 1.0F));
1056         }
1057 
1058         public void setFinalY(float y) {
1059             mFinalVerticalWallpaperOffset = Math.max(0.0F, Math.min(y, 1.0F));
1060         }
1061 
1062         public void jumpToFinal() {
1063             mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
1064             mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
1065         }
1066     }
1067 
1068     @Override
1069     public void computeScroll() {
1070         super.computeScroll();
1071         syncWallpaperOffsetWithScroll();
1072     }
1073 
1074     void showOutlines() {
1075         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1076             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1077             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1078             mChildrenOutlineFadeInAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);
1079             mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1080             mChildrenOutlineFadeInAnimation.start();
1081         }
1082     }
1083 
1084     void hideOutlines() {
1085         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1086             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1087             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
<abbr title="1088             mChildrenOutlineFadeOutAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);">1088             mChildrenOutlineFadeOutAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f)</abbr>
1089             mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1090             mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1091             mChildrenOutlineFadeOutAnimation.start();
1092         }
1093     }
1094 
1095     public void showOutlinesTemporarily() {
1096         if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1097             snapToPage(mCurrentPage);
1098         }
1099     }
1100 
1101     public void setChildrenOutlineAlpha(float alpha) {
1102         mChildrenOutlineAlpha = alpha;
1103         for (int i = 0; i &lt; getChildCount(); i++) {
1104             CellLayout cl = (CellLayout) getChildAt(i);
1105             cl.setBackgroundAlpha(alpha);
1106         }
1107     }
1108 
1109     public float getChildrenOutlineAlpha() {
1110         return mChildrenOutlineAlpha;
1111     }
1112 
1113     void disableBackground() {
1114         mDrawBackground = false;
1115     }
1116 
1117     void enableBackground() {
1118         mDrawBackground = true;
1119     }
1120 
1121     private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1122         if (mBackground == null) return;
1123         if (mBackgroundFadeInAnimation != null) {
1124             mBackgroundFadeInAnimation.cancel();
1125             mBackgroundFadeInAnimation = null;
1126         }
1127         if (mBackgroundFadeOutAnimation != null) {
1128             mBackgroundFadeOutAnimation.cancel();
1129             mBackgroundFadeOutAnimation = null;
1130         }
1131         float startAlpha = getBackgroundAlpha();
1132         if (finalAlpha != startAlpha) {
1133             if (animated) {
1134                 mBackgroundFadeOutAnimation = ValueAnimator.ofFloat(startAlpha, finalAlpha);
1135                 mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1136                     public void onAnimationUpdate(ValueAnimator animation) {
1137                         setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1138                     }
1139                 });
1140                 mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1141                 mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1142                 mBackgroundFadeOutAnimation.start();
1143             } else {
1144                 setBackgroundAlpha(finalAlpha);
1145             }
1146         }
1147     }
1148 
1149     public void setBackgroundAlpha(float alpha) {
1150         if (alpha != mBackgroundAlpha) {
1151             mBackgroundAlpha = alpha;
1152             invalidate();
1153         }
1154     }
1155 
1156     public float getBackgroundAlpha() {
1157         return mBackgroundAlpha;
1158     }
1159 
1160     /**
1161      * Due to 3D transformations, if two CellLayouts are theoretically touching each other,
1162      * on the xy plane, when one is rotated along the y-axis, the gap between them is perceived
1163      * as being larger. This method computes what offset the rotated view should be translated
1164      * in order to minimize this perceived gap.
1165      * @param degrees Angle of the view
1166      * @param width Width of the view
1167      * @param height Height of the view
1168      * @return Offset to be used in a View.setTranslationX() call
1169      */
1170     private float getOffsetXForRotation(float degrees, int width, int height) {
1171         mMatrix.reset();
1172         mCamera.save();
1173         mCamera.rotateY(Math.abs(degrees));
1174         mCamera.getMatrix(mMatrix);
1175         mCamera.restore();
1176 
1177         mMatrix.preTranslate(-width * 0.5f, -height * 0.5f);
1178         mMatrix.postTranslate(width * 0.5f, height * 0.5f);
1179         mTempFloat2[0] = width;
1180         mTempFloat2[1] = height;
1181         mMatrix.mapPoints(mTempFloat2);
1182         return (width - mTempFloat2[0]) * (degrees &gt; 0.0f ? 1.0f : -1.0f);
1183     }
1184 
1185     float backgroundAlphaInterpolator(float r) {
1186         float pivotA = 0.1f;
1187         float pivotB = 0.4f;
1188         if (r &lt; pivotA) {
1189             return 0;
1190         } else if (r &gt; pivotB) {
1191             return 1.0f;
1192         } else {
1193             return (r - pivotA)/(pivotB - pivotA);
1194         }
1195     }
1196 
1197     float overScrollBackgroundAlphaInterpolator(float r) {
1198         float threshold = 0.08f;
1199 
1200         if (r &gt; mOverScrollMaxBackgroundAlpha) {
1201             mOverScrollMaxBackgroundAlpha = r;
1202         } else if (r &lt; mOverScrollMaxBackgroundAlpha) {
1203             r = mOverScrollMaxBackgroundAlpha;
1204         }
1205 
1206         return Math.min(r / threshold, 1.0f);
1207     }
1208 
1209     private void screenScrolledLargeUI(int screenCenter) {
1210         if (isSwitchingState()) {
1211             return;
1212         }
1213         boolean isInOverscroll = false;
1214         for (int i = 0; i &lt; getChildCount(); i++) {
1215             CellLayout cl = ((CellLayout) (getChildAt(i)));
1216             if (cl != null) {
1217                 float scrollProgress = getScrollProgress(screenCenter, cl, i);
1218                 float rotation = WORKSPACE_ROTATION * scrollProgress;
1219                 float translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1220                 // If the current page (i) is being over scrolled, we use a different
1221                 // set of rules for setting the background alpha multiplier.
1222                 if (!isSmall()) {
<abbr title="1223                     if (((mOverScrollX &lt; 0) &amp;&amp; (i == 0)) || ((mOverScrollX &gt; mMaxScrollX) &amp;&amp; (i == (getChildCount() - 1)))) {">1223                     if (((mOverScrollX &lt; 0) &amp;&amp; (i == 0)) || ((mOverScrollX &gt; mMaxScrollX) &amp;&amp; (i == (getCh</abbr>
1224                         isInOverscroll = true;
1225                         rotation *= -1;
<abbr title="1226                         cl.setBackgroundAlphaMultiplier(overScrollBackgroundAlphaInterpolator(Math.abs(scrollProgress)));">1226                         cl.setBackgroundAlphaMultiplier(overScrollBackgroundAlphaInterpolator(Math.abs(sc</abbr>
1227                         mOverScrollPageIndex = i;
1228                         cl.setOverScrollAmount(Math.abs(scrollProgress), i == 0);
1229                         cl.setPivotX(cl.getMeasuredWidth() * (i == 0 ? 0.75F : 0.25F));
1230                         cl.setPivotY(cl.getMeasuredHeight() * 0.5F);
1231                         cl.setOverscrollTransformsDirty(true);
1232                     } else if (mOverScrollPageIndex != i) {
<abbr title="1233                         cl.setBackgroundAlphaMultiplier(backgroundAlphaInterpolator(Math.abs(scrollProgress)));">1233                         cl.setBackgroundAlphaMultiplier(backgroundAlphaInterpolator(Math.abs(scrollProgre</abbr>
1234                     }
1235                 }
1236                 cl.setTranslationX(translationX);
1237                 cl.setRotationY(rotation);
1238                 if (mFadeInAdjacentScreens &amp;&amp; (!isSmall())) {
1239                     float alpha = 1 - Math.abs(scrollProgress);
1240                     cl.setAlpha(alpha);
1241                 }
1242             }
1243         }
1244         if ((!isSwitchingState()) &amp;&amp; (!isInOverscroll)) {
1245             ((CellLayout) (getChildAt(0))).resetOverscrollTransforms();
1246             ((CellLayout) (getChildAt(getChildCount() - 1))).resetOverscrollTransforms();
1247         }
1248         invalidate();
1249     }
1250 
1251     private void screenScrolledStandardUI(int screenCenter) {
1252         if (mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX) {
1253             int index = mOverScrollX &lt; 0 ? 0 : getChildCount() - 1;
1254             CellLayout cl = (CellLayout) getChildAt(index);
1255             float scrollProgress = getScrollProgress(screenCenter, cl, index);
1256             cl.setOverScrollAmount(Math.abs(scrollProgress), index == 0);
1257             float rotation = - WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1258             cl.setCameraDistance(mDensity * CAMERA_DISTANCE);
1259             cl.setPivotX(cl.getMeasuredWidth() * (index == 0 ? 0.75f : 0.25f));
1260             cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1261             cl.setRotationY(rotation);
1262             cl.setOverscrollTransformsDirty(true);
1263             setFadeForOverScroll(Math.abs(scrollProgress));
1264         } else {
1265             if (mOverscrollFade != 0) {
1266                 setFadeForOverScroll(0);
1267             }
1268             // We don&#x27;t want to mess with the translations during transitions
1269             if (!isSwitchingState()) {
1270                 ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1271                 ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1272             }
1273         }
1274     }
1275 
1276     @Override
1277     protected void screenScrolled(int screenCenter) {
1278         if (LauncherApplication.isScreenLarge()) {
1279             // We don&#x27;t call super.screenScrolled() here because we handle the adjacent pages alpha
1280             // ourselves (for efficiency), and there are no scrolling indicators to update.
1281             screenScrolledLargeUI(screenCenter);
1282         } else {
1283             super.screenScrolled(screenCenter);
1284             screenScrolledStandardUI(screenCenter);
1285         }
1286     }
1287 
1288     @Override
1289     protected void overScroll(float amount) {
1290         if (LauncherApplication.isScreenLarge()) {
1291             dampedOverScroll(amount);
1292         } else {
1293             acceleratedOverScroll(amount);
1294         }
1295     }
1296 
1297     protected void onAttachedToWindow() {
1298         super.onAttachedToWindow();
1299         mWindowToken = getWindowToken();
1300         computeScroll();
1301         mDragController.setWindowToken(mWindowToken);
1302     }
1303 
1304     protected void onDetachedFromWindow() {
1305         mWindowToken = null;
1306     }
1307 
1308     @Override
1309     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1310         if ((mFirstLayout &amp;&amp; (mCurrentPage &gt;= 0)) &amp;&amp; (mCurrentPage &lt; getChildCount())) {
1311             mUpdateWallpaperOffsetImmediately = true;
1312         }
1313         super.onLayout(changed, left, top, right, bottom);
1314     }
1315 
1316     @Override
1317     protected void onDraw(Canvas canvas) {
1318         updateWallpaperOffsets();
1319 
1320         // Draw the background gradient if necessary
1321         if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1322             int alpha = (int) (mBackgroundAlpha * 255);
1323             mBackground.setAlpha(alpha);
1324             mBackground.setBounds(mScrollX, 0, mScrollX + getMeasuredWidth(),
1325                     getMeasuredHeight());
1326             mBackground.draw(canvas);
1327         }
1328 
1329         super.onDraw(canvas);
1330     }
1331 
1332     boolean isDrawingBackgroundGradient() {
1333         return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1334     }
1335 
1336     @Override
1337     protected void dispatchDraw(Canvas canvas) {
1338         super.dispatchDraw(canvas);
1339         if (mInScrollArea &amp;&amp; (!LauncherApplication.isScreenLarge())) {
1340             final int width = getWidth();
1341             final int height = getHeight();
1342             final int pageHeight = getChildAt(0).getHeight();
1343             // Set the height of the outline to be the height of the page
1344             final int offset = (((height - pageHeight) - mPaddingTop) - mPaddingBottom) / 2;
1345             final int paddingTop = mPaddingTop + offset;
1346             final int paddingBottom = mPaddingBottom + offset;
1347             final int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1348             final CellLayout leftPage = ((CellLayout) (getChildAt(page - 1)));
1349             final CellLayout rightPage = ((CellLayout) (getChildAt(page + 1)));
1350             if ((leftPage != null) &amp;&amp; leftPage.getIsDragOverlapping()) {
1351                 final Drawable d = getResources().getDrawable(R.drawable.page_hover_left_holo);
<abbr title="1352                 d.setBounds(mScrollX, paddingTop, mScrollX + d.getIntrinsicWidth(), height - paddingBottom);">1352                 d.setBounds(mScrollX, paddingTop, mScrollX + d.getIntrinsicWidth(), height - paddingBotto</abbr>
1353                 d.draw(canvas);
1354             } else if ((rightPage != null) &amp;&amp; rightPage.getIsDragOverlapping()) {
1355                 final Drawable d = getResources().getDrawable(R.drawable.page_hover_right_holo);
<abbr title="1356                 d.setBounds((mScrollX + width) - d.getIntrinsicWidth(), paddingTop, mScrollX + width, height - paddingBottom);">1356                 d.setBounds((mScrollX + width) - d.getIntrinsicWidth(), paddingTop, mScrollX + width, hei</abbr>
1357                 d.draw(canvas);
1358             }
1359         }
1360     }
1361 
1362     @Override
1363     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1364         if (!mLauncher.isAllAppsVisible()) {
1365             final Folder openFolder = getOpenFolder();
1366             if (openFolder != null) {
1367                 return openFolder.requestFocus(direction, previouslyFocusedRect);
1368             } else {
1369                 return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1370             }
1371         }
1372         return false;
1373     }
1374 
1375     @Override
1376     public int getDescendantFocusability() {
1377         if (isSmall()) {
1378             return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1379         }
1380         return super.getDescendantFocusability();
1381     }
1382 
1383     @Override
1384     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1385         if (!mLauncher.isAllAppsVisible()) {
1386             final Folder openFolder = getOpenFolder();
1387             if (openFolder != null) {
1388                 openFolder.addFocusables(views, direction);
1389             } else {
1390                 super.addFocusables(views, direction, focusableMode);
1391             }
1392         }
1393     }
1394 
1395     public boolean isSmall() {
1396         return mState == State.SMALL || mState == State.SPRING_LOADED;
1397     }
1398 
1399     void enableChildrenCache(int fromPage, int toPage) {
1400         if (fromPage &gt; toPage) {
1401             final int temp = fromPage;
1402             fromPage = toPage;
1403             toPage = temp;
1404         }
1405 
1406         final int screenCount = getChildCount();
1407 
1408         fromPage = Math.max(fromPage, 0);
1409         toPage = Math.min(toPage, screenCount - 1);
1410 
1411         for (int i = fromPage; i &lt;= toPage; i++) {
1412             final CellLayout layout = (CellLayout) getChildAt(i);
1413             layout.setChildrenDrawnWithCacheEnabled(true);
1414             layout.setChildrenDrawingCacheEnabled(true);
1415         }
1416     }
1417 
1418     void clearChildrenCache() {
1419         final int screenCount = getChildCount();
1420         for (int i = 0; i &lt; screenCount; i++) {
1421             final CellLayout layout = (CellLayout) getChildAt(i);
1422             layout.setChildrenDrawnWithCacheEnabled(false);
1423             // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1424             if (!isHardwareAccelerated()) {
1425                 layout.setChildrenDrawingCacheEnabled(false);
1426             }
1427         }
1428     }
1429 
1430     private void updateChildrenLayersEnabled() {
1431         boolean small = isSmall() || mIsSwitchingState;
1432         boolean dragging = mAnimatingViewIntoPlace || mIsDragOccuring;
1433         boolean enableChildrenLayers = (small || dragging) || isPageMoving();
1434         if (enableChildrenLayers != mChildrenLayersEnabled) {
1435             mChildrenLayersEnabled = enableChildrenLayers;
1436             for (int i = 0; i &lt; getPageCount(); i++) {
1437                 ((ViewGroup) (getChildAt(i))).setChildrenLayersEnabled(mChildrenLayersEnabled);
1438             }
1439         }
1440     }
1441 
1442     protected void onWallpaperTap(MotionEvent ev) {
1443         final int[] position = mTempCell;
1444         getLocationOnScreen(position);
1445 
1446         int pointerIndex = ev.getActionIndex();
1447         position[0] += (int) ev.getX(pointerIndex);
1448         position[1] += (int) ev.getY(pointerIndex);
1449 
1450         mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1451                 ev.getAction() == MotionEvent.ACTION_UP
1452                         ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1453                 position[0], position[1], 0, null);
1454     }
1455 
1456     /* This interpolator emulates the rate at which the perceived scale of an object changes
1457     as its distance from a camera increases. When this interpolator is applied to a scale
1458     animation on a view, it evokes the sense that the object is shrinking due to moving away
1459     from the camera.
1460      */
1461     static class ZInterpolator implements TimeInterpolator {
1462         private float focalLength;
1463 
1464         public ZInterpolator(float foc) {
1465             focalLength = foc;
1466         }
1467 
1468         public float getInterpolation(float input) {
<abbr title="1469             return (1.0F - (focalLength / (focalLength + input))) / (1.0F - (focalLength / (focalLength + 1.0F)));">1469             return (1.0F - (focalLength / (focalLength + input))) / (1.0F - (focalLength / (focalLength +</abbr>
1470         }
1471     }
1472 
1473     /* The exact reverse of ZInterpolator. */
1474     static class InverseZInterpolator implements TimeInterpolator {
1475         private ZInterpolator zInterpolator;
1476 
1477         public InverseZInterpolator(float foc) {
1478             zInterpolator = new ZInterpolator(foc);
1479         }
1480 
1481         public float getInterpolation(float input) {
1482             return 1 - zInterpolator.getInterpolation(1 - input);
1483         }
1484     }
1485 
1486     /* ZInterpolator compounded with an ease-out. */
1487     static class ZoomOutInterpolator implements TimeInterpolator {
1488         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75F);
1489 
1490         private final ZInterpolator zInterpolator = new ZInterpolator(0.13F);
1491 
1492         public float getInterpolation(float input) {
1493             return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1494         }
1495     }
1496 
1497     /* InvereZInterpolator compounded with an ease-out. */
1498     static class ZoomInInterpolator implements TimeInterpolator {
1499         private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35F);
1500 
1501         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0F);
1502 
1503         public float getInterpolation(float input) {
1504             return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1505         }
1506     }
1507 
1508     private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1509 
1510     /*
1511     *
1512     * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1513     * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1514     *
1515     * These methods mark the appropriate pages as accepting drops (which alters their visual
1516     * appearance).
1517     *
1518     */
1519     public void onDragStartedWithItem(View v) {
1520         final Canvas canvas = new Canvas();
1521         // The outline is used to visualize where the item will land if dropped
1522         mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);
1523     }
1524 
1525     public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, Paint alphaClipPaint) {
1526         final Canvas canvas = new Canvas();
1527         int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1528         // The outline is used to visualize where the item will land if dropped
<abbr title="1529         mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0], size[1], alphaClipPaint);">1529         mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0], size[1], alphaClipPaint</abbr>
1530     }
1531 
1532     // we call this method whenever a drag and drop in Launcher finishes, even if Workspace was
1533     // never dragged over
1534     public void onDragStopped(boolean success) {
1535         // In the success case, DragController has already called onDragExit()
1536         if (!success) {
1537             doDragExit(null);
1538         }
1539     }
1540 
1541     public void exitWidgetResizeMode() {
1542         DragLayer dragLayer = mLauncher.getDragLayer();
1543         dragLayer.clearAllResizeFrames();
1544     }
1545 
1546     private void initAnimationArrays() {
1547         final int childCount = getChildCount();
1548         if (mOldTranslationXs != null) return;
1549         mOldTranslationXs = new float[childCount];
1550         mOldTranslationYs = new float[childCount];
1551         mOldScaleXs = new float[childCount];
1552         mOldScaleYs = new float[childCount];
1553         mOldBackgroundAlphas = new float[childCount];
1554         mOldBackgroundAlphaMultipliers = new float[childCount];
1555         mOldAlphas = new float[childCount];
1556         mOldRotationYs = new float[childCount];
1557         mNewTranslationXs = new float[childCount];
1558         mNewTranslationYs = new float[childCount];
1559         mNewScaleXs = new float[childCount];
1560         mNewScaleYs = new float[childCount];
1561         mNewBackgroundAlphas = new float[childCount];
1562         mNewBackgroundAlphaMultipliers = new float[childCount];
1563         mNewAlphas = new float[childCount];
1564         mNewRotationYs = new float[childCount];
1565     }
1566 
1567     Animator getChangeStateAnimation(final State state, boolean animated) {
1568         return getChangeStateAnimation(state, animated, 0);
1569     }
1570 
1571     Animator getChangeStateAnimation(final State state, boolean animated, int delay) {
1572         if (mState == state) {
1573             return null;
1574         }
1575         // Initialize animation arrays for the first time if necessary
1576         initAnimationArrays();
1577         AnimatorSet anim = (animated) ? new AnimatorSet() : null;
1578         // Stop any scrolling, move to the current page right away
1579         setCurrentPage(mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage);
1580         final State oldState = mState;
1581         final boolean oldStateIsNormal = oldState == State.NORMAL;
1582         final boolean oldStateIsSmall = oldState == State.SMALL;
1583         mState = state;
1584         final boolean stateIsNormal = state == State.NORMAL;
1585         final boolean stateIsSpringLoaded = state == State.SPRING_LOADED;
1586         final boolean stateIsSmall = state == State.SMALL;
1587         float finalScaleFactor = 1.0F;
1588         float finalBackgroundAlpha = (stateIsSpringLoaded) ? 1.0F : 0.0F;
1589         float translationX = 0;
1590         float translationY = 0;
1591         boolean zoomIn = true;
1592         if (state != State.NORMAL) {
1593             finalScaleFactor = mSpringLoadedShrinkFactor - (stateIsSmall ? 0.1F : 0);
1594             if (oldStateIsNormal &amp;&amp; stateIsSmall) {
1595                 zoomIn = false;
1596                 setLayoutScale(finalScaleFactor);
1597                 updateChildrenLayersEnabled();
1598             } else {
1599                 finalBackgroundAlpha = 1.0F;
1600                 setLayoutScale(finalScaleFactor);
1601             }
1602         } else {
1603             setLayoutScale(1.0F);
1604         }
<abbr title="1605         final int duration = (zoomIn) ? getResources().getInteger(R.integer.config_workspaceUnshrinkTime) : getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);">1605         final int duration = (zoomIn) ? getResources().getInteger(R.integer.config_workspaceUnshrinkTime)</abbr>
1606         for (int i = 0; i &lt; getChildCount(); i++) {
1607             final CellLayout cl = ((CellLayout) (getChildAt(i)));
1608             float rotation = 0.0F;
1609             float initialAlpha = cl.getAlpha();
1610             float finalAlphaMultiplierValue = 1.0F;
<abbr title="1611             float finalAlpha = (((!mFadeInAdjacentScreens) || stateIsSpringLoaded) || (i == mCurrentPage)) ? 1.0F : 0.0F;">1611             float finalAlpha = (((!mFadeInAdjacentScreens) || stateIsSpringLoaded) || (i == mCurrentPage)</abbr>
1612             // Determine the pages alpha during the state transition
1613             if ((oldStateIsSmall &amp;&amp; stateIsNormal) || (oldStateIsNormal &amp;&amp; stateIsSmall)) {
1614                 // To/from workspace - only show the current page unless the transition is not
1615                 // animated and the animation end callback below doesn&#x27;t run
1616                 if ((i == mCurrentPage) || (!animated)) {
1617                     finalAlpha = 1.0F;
1618                     finalAlphaMultiplierValue = 0.0F;
1619                 } else {
1620                     initialAlpha = 0.0F;
1621                     finalAlpha = 0.0F;
1622                 }
1623             }
1624             // Update the rotation of the screen (don&#x27;t apply rotation on Phone UI)
1625             if (LauncherApplication.isScreenLarge()) {
1626                 if (i &lt; mCurrentPage) {
1627                     rotation = WORKSPACE_ROTATION;
1628                 } else if (i &gt; mCurrentPage) {
1629                     rotation = -WORKSPACE_ROTATION;
1630                 }
1631             }
1632             // If the screen is not xlarge, then don&#x27;t rotate the CellLayouts
1633             // NOTE: If we don&#x27;t update the side pages alpha, then we should not hide the side
1634             // pages. see unshrink().
1635             if (LauncherApplication.isScreenLarge()) {
1636                 translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1637             }
1638             mOldAlphas[i] = initialAlpha;
1639             mNewAlphas[i] = finalAlpha;
1640             if (animated) {
1641                 mOldTranslationXs[i] = cl.getTranslationX();
1642                 mOldTranslationYs[i] = cl.getTranslationY();
1643                 mOldScaleXs[i] = cl.getScaleX();
1644                 mOldScaleYs[i] = cl.getScaleY();
1645                 mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
1646                 mOldBackgroundAlphaMultipliers[i] = cl.getBackgroundAlphaMultiplier();
1647                 mOldRotationYs[i] = cl.getRotationY();
1648                 mNewTranslationXs[i] = translationX;
1649                 mNewTranslationYs[i] = translationY;
1650                 mNewScaleXs[i] = finalScaleFactor;
1651                 mNewScaleYs[i] = finalScaleFactor;
1652                 mNewBackgroundAlphas[i] = finalBackgroundAlpha;
1653                 mNewBackgroundAlphaMultipliers[i] = finalAlphaMultiplierValue;
1654                 mNewRotationYs[i] = rotation;
1655             } else {
1656                 cl.setTranslationX(translationX);
1657                 cl.setTranslationY(translationY);
1658                 cl.setScaleX(finalScaleFactor);
1659                 cl.setScaleY(finalScaleFactor);
1660                 cl.setBackgroundAlpha(finalBackgroundAlpha);
1661                 cl.setBackgroundAlphaMultiplier(finalAlphaMultiplierValue);
1662                 cl.setAlpha(finalAlpha);
1663                 cl.setRotationY(rotation);
1664             }
1665         }
1666         if (animated) {
1667             for (int index = 0; index &lt; getChildCount(); index++) {
1668                 final int i = index;
1669                 final CellLayout cl = ((CellLayout) (getChildAt(i)));
1670                 if ((mOldAlphas[i] == 0) &amp;&amp; (mNewAlphas[i] == 0)) {
1671                     cl.setTranslationX(mNewTranslationXs[i]);
1672                     cl.setTranslationY(mNewTranslationYs[i]);
1673                     cl.setScaleX(mNewScaleXs[i]);
1674                     cl.setScaleY(mNewScaleYs[i]);
1675                     cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);
1676                     cl.setBackgroundAlphaMultiplier(mNewBackgroundAlphaMultipliers[i]);
1677                     cl.setAlpha(mNewAlphas[i]);
1678                     cl.setRotationY(mNewRotationYs[i]);
1679                 } else {
1680                     LauncherViewPropertyAnimator a = new LauncherViewPropertyAnimator(cl);
<abbr title="1681                     a.translationX(mNewTranslationXs[i]).translationY(mNewTranslationYs[i]).scaleX(mNewScaleXs[i]).scaleY(mNewScaleYs[i]).setDuration(duration).setInterpolator(mZoomInInterpolator);">1681                     a.translationX(mNewTranslationXs[i]).translationY(mNewTranslationYs[i]).scaleX(mNewSc</abbr>
1682                     if (mOldAlphas[i] != mNewAlphas[i]) {
1683                         a.alpha(mNewAlphas[i]);
1684                     }
1685                     anim.play(a);
1686                     if ((mOldRotationYs[i] != 0) || (mNewRotationYs[i] != 0)) {
1687                         ValueAnimator rotate = ValueAnimator.ofFloat(0.0F, 1.0F).setDuration(duration);
1688                         rotate.setInterpolator(new DecelerateInterpolator(2.0F));
1689                         rotate.addUpdateListener(new LauncherAnimatorUpdateListener() {
1690                             public void onAnimationUpdate(float a, float b) {
1691                                 cl.setRotationY((a * mOldRotationYs[i]) + (b * mNewRotationYs[i]));
1692                             }
1693                         });
1694                         anim.play(rotate);
1695                     }
<abbr title="1696                     if ((((mOldBackgroundAlphas[i] != 0) || (mNewBackgroundAlphas[i] != 0)) || (mOldBackgroundAlphaMultipliers[i] != 0)) || (mNewBackgroundAlphaMultipliers[i] != 0)) {">1696                     if ((((mOldBackgroundAlphas[i] != 0) || (mNewBackgroundAlphas[i] != 0)) || (mOldBackg</abbr>
1697                         ValueAnimator bgAnim = ValueAnimator.ofFloat(0.0F, 1.0F).setDuration(duration);
1698                         bgAnim.setInterpolator(mZoomInInterpolator);
1699                         bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
1700                             public void onAnimationUpdate(float a, float b) {
<abbr title="1701                                 cl.setBackgroundAlpha((a * mOldBackgroundAlphas[i]) + (b * mNewBackgroundAlphas[i]));">1701                                 cl.setBackgroundAlpha((a * mOldBackgroundAlphas[i]) + (b * mNewBackground</abbr>
<abbr title="1702                                 cl.setBackgroundAlphaMultiplier((a * mOldBackgroundAlphaMultipliers[i]) + (b * mNewBackgroundAlphaMultipliers[i]));">1702                                 cl.setBackgroundAlphaMultiplier((a * mOldBackgroundAlphaMultipliers[i]) +</abbr>
1703                             }
1704                         });
1705                         anim.play(bgAnim);
1706                     }
1707                 }
1708             }
1709             anim.setStartDelay(delay);
1710         }
1711         if (stateIsSpringLoaded) {
1712             // Right now we&#x27;re covered by Apps Customize
1713             // Show the background gradient immediately, so the gradient will
1714             // be showing once AppsCustomize disappears
<abbr title="1715             animateBackgroundGradient(getResources().getInteger(R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100.0F, false);">1715             animateBackgroundGradient(getResources().getInteger(R.integer.config_appsCustomizeSpringLoade</abbr>
1716         } else {
1717             // Fade the background gradient away
1718             animateBackgroundGradient(0.0F, true);
1719         }
1720         return anim;
1721     }
1722 
1723     @Override
1724     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
1725         mIsSwitchingState = true;
1726     }
1727 
1728     @Override
1729     public void onLauncherTransitionStep(Launcher l, float t) {
1730         mTransitionProgress = t;
1731     }
1732 
1733     @Override
1734     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
1735         mIsSwitchingState = false;
1736         mWallpaperOffset.setOverrideHorizontalCatchupConstant(false);
1737         updateChildrenLayersEnabled();
1738         // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure
1739         // ensure that only the current page is visible during (and subsequently, after) the
1740         // transition animation.  If fade adjacent pages is disabled, then re-enable the page
1741         // visibility after the transition animation.
1742         if (!mFadeInAdjacentScreens) {
1743             for (int i = 0; i &lt; getChildCount(); i++) {
1744                 final CellLayout cl = ((CellLayout) (getChildAt(i)));
1745                 cl.setAlpha(1.0F);
1746             }
1747         }
1748     }
1749 
1750     @Override
1751     public View getContent() {
1752         return this;
1753     }
1754 
1755     /**
1756      * Draw the View v into the given Canvas.
1757      *
1758      * @param v the view to draw
1759      * @param destCanvas the canvas to draw on
1760      * @param padding the horizontal and vertical padding to use when drawing
1761      */
1762     private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
1763         final Rect clipRect = mTempRect;
1764         v.getDrawingRect(clipRect);
1765 
1766         boolean textVisible = false;
1767 
1768         destCanvas.save();
1769         if (v instanceof TextView &amp;&amp; pruneToDrawable) {
1770             Drawable d = ((TextView) v).getCompoundDrawables()[1];
1771             clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
1772             destCanvas.translate(padding / 2, padding / 2);
1773             d.draw(destCanvas);
1774         } else {
1775             if (v instanceof FolderIcon) {
1776                 // For FolderIcons the text can bleed into the icon area, and so we need to
1777                 // hide the text completely (which can&#x27;t be achieved by clipping).
1778                 if (((FolderIcon) v).getTextVisible()) {
1779                     ((FolderIcon) v).setTextVisible(false);
1780                     textVisible = true;
1781                 }
1782             } else if (v instanceof BubbleTextView) {
1783                 final BubbleTextView tv = (BubbleTextView) v;
1784                 clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
1785                         tv.getLayout().getLineTop(0);
1786             } else if (v instanceof TextView) {
1787                 final TextView tv = (TextView) v;
1788                 clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
1789                         tv.getLayout().getLineTop(0);
1790             }
1791             destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
1792             destCanvas.clipRect(clipRect, Op.REPLACE);
1793             v.draw(destCanvas);
1794 
1795             // Restore text visibility of FolderIcon if necessary
1796             if (textVisible) {
1797                 ((FolderIcon) v).setTextVisible(true);
1798             }
1799         }
1800         destCanvas.restore();
1801     }
1802 
1803     /**
1804      * Returns a new bitmap to show when the given View is being dragged around.
1805      * Responsibility for the bitmap is transferred to the caller.
1806      */
1807     public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
1808         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1809         Bitmap b;
1810         if (v instanceof TextView) {
1811             Drawable d = ((TextView) (v)).getCompoundDrawables()[1];
<abbr title="1812             b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);">1812             b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding, Bi</abbr>
1813         } else {
<abbr title="1814             b = Bitmap.createBitmap(v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);">1814             b = Bitmap.createBitmap(v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8</abbr>
1815         }
1816         canvas.setBitmap(b);
1817         drawDragView(v, canvas, padding, true);
1818         canvas.setBitmap(null);
1819         return b;
1820     }
1821 
1822     /**
1823      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
1824      * Responsibility for the bitmap is transferred to the caller.
1825      */
1826     private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
1827         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1828         final Bitmap b = Bitmap.createBitmap(
1829                 v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
1830 
1831         canvas.setBitmap(b);
1832         drawDragView(v, canvas, padding, true);
1833         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
1834         canvas.setBitmap(null);
1835         return b;
1836     }
1837 
1838     /**
1839      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
1840      * Responsibility for the bitmap is transferred to the caller.
1841      */
1842     private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
1843             Paint alphaClipPaint) {
1844         final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1845         final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
1846         canvas.setBitmap(b);
1847 
1848         Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
1849         float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
1850                 (h - padding) / (float) orig.getHeight());
1851         int scaledWidth = (int) (scaleFactor * orig.getWidth());
1852         int scaledHeight = (int) (scaleFactor * orig.getHeight());
1853         Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
1854 
1855         // center the image
1856         dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
1857 
1858         canvas.drawBitmap(orig, src, dst, null);
1859         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
1860                 alphaClipPaint);
1861         canvas.setBitmap(null);
1862 
1863         return b;
1864     }
1865 
1866     /**
1867      * Creates a drag outline to represent a drop (that we don&#x27;t have the actual information for
1868      * yet).  May be changed in the future to alter the drop outline slightly depending on the
1869      * clip description mime data.
1870      */
1871     private Bitmap createExternalDragOutline(Canvas canvas, int padding) {
1872         Resources r = getResources();
1873         final int outlineColor = r.getColor(android.R.color.holo_blue_light);
1874         final int iconWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
1875         final int iconHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
1876         final int rectRadius = r.getDimensionPixelSize(R.dimen.external_drop_icon_rect_radius);
1877         final int inset = (int) (Math.min(iconWidth, iconHeight) * 0.2f);
1878         final Bitmap b = Bitmap.createBitmap(
1879                 iconWidth + padding, iconHeight + padding, Bitmap.Config.ARGB_8888);
1880 
1881         canvas.setBitmap(b);
1882         canvas.drawRoundRect(new RectF(inset, inset, iconWidth - inset, iconHeight - inset),
1883                 rectRadius, rectRadius, mExternalDragOutlinePaint);
1884         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
1885         canvas.setBitmap(null);
1886         return b;
1887     }
1888 
1889     void startDrag(CellLayout.CellInfo cellInfo) {
1890         View child = cellInfo.cell;
1891         // Make sure the drag was started by a long press as opposed to a long click.
1892         if (!child.isInTouchMode()) {
1893             return;
1894         }
1895         mDragInfo = cellInfo;
1896         child.setVisibility(INVISIBLE);
1897         child.clearFocus();
1898         child.setPressed(false);
1899         final Canvas canvas = new Canvas();
1900         // The outline is used to visualize where the item will land if dropped
1901         mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);
1902         beginDragShared(child, this);
1903     }
1904 
1905     public void beginDragShared(View child, DragSource source) {
1906         Resources r = getResources();
1907         // The drag bitmap follows the touch point around on the screen
1908         final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);
1909         final int bmpWidth = b.getWidth();
1910         mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
1911         final int dragLayerX = ((int) (mTempXY[0])) + ((child.getWidth() - bmpWidth) / 2);
1912         int dragLayerY = mTempXY[1] - (DRAG_BITMAP_PADDING / 2);
1913         Point dragVisualizeOffset = null;
1914         Rect dragRect = null;
1915         if ((child instanceof BubbleTextView) || (child instanceof PagedViewIcon)) {
1916             int iconSize = r.getDimensionPixelSize(R.dimen.app_icon_size);
1917             int iconPaddingTop = r.getDimensionPixelSize(R.dimen.app_icon_padding_top);
1918             int top = child.getPaddingTop();
1919             int left = (bmpWidth - iconSize) / 2;
1920             int right = left + iconSize;
1921             int bottom = top + iconSize;
1922             dragLayerY += top;
1923             // Note: The drag region is used to calculate drag layer offsets, but the
1924             // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
<abbr title="1925             dragVisualizeOffset = new Point((-DRAG_BITMAP_PADDING) / 2, iconPaddingTop - (DRAG_BITMAP_PADDING / 2));">1925             dragVisualizeOffset = new Point((-DRAG_BITMAP_PADDING) / 2, iconPaddingTop - (DRAG_BITMAP_PAD</abbr>
1926             dragRect = new Rect(left, top, right, bottom);
1927         } else if (child instanceof FolderIcon) {
1928             int previewSize = r.getDimensionPixelSize(R.dimen.folder_preview_size);
1929             dragRect = new Rect(0, 0, child.getWidth(), previewSize);
1930         }
1931         // Clear the pressed state if necessary
1932         if (child instanceof BubbleTextView) {
1933             BubbleTextView icon = ((BubbleTextView) (child));
1934             icon.clearPressedOrFocusedBackground();
1935         }
<abbr title="1936         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(), DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, 1.0F);">1936         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(), DragController.DRAG_</abbr>
1937         b.recycle();
1938         // Show the scrolling indicator when you pick up an item
1939         showScrollingIndicator(false);
1940     }
1941 
1942     void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, int screen,
1943             int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
1944         View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
1945 
1946         final int[] cellXY = new int[2];
1947         target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
1948         addInScreen(view, container, screen, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
1949         LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen, cellXY[0],
1950                 cellXY[1]);
1951     }
1952 
1953     public boolean transitionStateShouldAllowDrop() {
1954         return ((!isSwitchingState()) || (mTransitionProgress &gt; 0.5F)) &amp;&amp; (mState != State.SMALL);
1955     }
1956 
1957     /**
1958      * {@inheritDoc}
1959      */
1960     public boolean acceptDrop(DragObject d) {
1961         // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
1962         if (d.dragSource != this) {
1963             // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
1964             if (mDragTargetLayout == null) {
1965                 return false;
1966             }
1967             if (!transitionStateShouldAllowDrop()) {
1968                 return false;
1969             }
<abbr title="1970             mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, mDragViewVisualCenter);">1970             mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, m</abbr>
1971             // We want the point to be mapped to the dragTarget.
1972             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
1973                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
1974             } else {
1975                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
1976             }
1977             int spanX = 1;
1978             int spanY = 1;
1979             View ignoreView = null;
1980             if (mDragInfo != null) {
1981                 final CellLayout.CellInfo dragCellInfo = mDragInfo;
1982                 spanX = dragCellInfo.spanX;
1983                 spanY = dragCellInfo.spanY;
1984                 ignoreView = dragCellInfo.cell;
1985             } else {
1986                 final ItemInfo dragInfo = ((ItemInfo) (d.dragInfo));
1987                 spanX = dragInfo.spanX;
1988                 spanY = dragInfo.spanY;
1989             }
1990             int minSpanX = spanX;
1991             int minSpanY = spanY;
1992             if (d.dragInfo instanceof PendingAddWidgetInfo) {
1993                 minSpanX = ((PendingAddWidgetInfo) (d.dragInfo)).minSpanX;
1994                 minSpanY = ((PendingAddWidgetInfo) (d.dragInfo)).minSpanY;
1995             }
<abbr title="1996             mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), minSpanX, minSpanY, mDragTargetLayout, mTargetCell);">1996             mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCent</abbr>
1997             if (willCreateUserFolder(((ItemInfo) (d.dragInfo)), mDragTargetLayout, mTargetCell, true)) {
1998                 return true;
1999             }
2000             if (willAddToExistingUserFolder(((ItemInfo) (d.dragInfo)), mDragTargetLayout, mTargetCell)) {
2001                 return true;
2002             }
2003             // Don&#x27;t accept the drop if there&#x27;s no room for the item
2004             if (!mDragTargetLayout.findCellForSpanIgnoring(null, minSpanX, minSpanY, ignoreView)) {
2005                 // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2006                 // is full
2007                 if ((mTargetCell != null) &amp;&amp; mLauncher.isHotseatLayout(mDragTargetLayout)) {
2008                     Hotseat hotseat = mLauncher.getHotseat();
<abbr title="2009                     if (hotseat.isAllAppsButtonRank(hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {">2009                     if (hotseat.isAllAppsButtonRank(hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell</abbr>
2010                         return false;
2011                     }
2012                 }
2013                 mLauncher.showOutOfSpaceMessage();
2014                 return false;
2015             }
2016         }
2017         return true;
2018     }
2019 
2020     boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell,
2021             boolean considerTimeout) {
2022         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2023 
2024         boolean hasntMoved = false;
2025         if (mDragInfo != null) {
2026             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2027             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2028                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2029         }
2030 
2031         if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2032             return false;
2033         }
2034 
2035         boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2036         boolean willBecomeShortcut =
2037                 (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2038                 info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2039 
2040         return (aboveShortcut &amp;&amp; willBecomeShortcut);
2041     }
2042 
2043     boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell) {
2044         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2045         if (dropOverView instanceof FolderIcon) {
2046             FolderIcon fi = (FolderIcon) dropOverView;
2047             if (fi.acceptDrop(dragInfo)) {
2048                 return true;
2049             }
2050         }
2051         return false;
2052     }
2053 
2054     boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2055             int[] targetCell, boolean external, DragView dragView, Runnable postAnimationRunnable) {
2056         View v = target.getChildAt(targetCell[0], targetCell[1]);
2057         boolean hasntMoved = false;
2058         if (mDragInfo != null) {
2059             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2060             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2061                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2062         }
2063 
2064         if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2065         mCreateUserFolderOnDrop = false;
2066         final int screen = (targetCell == null) ? mDragInfo.screen : indexOfChild(target);
2067 
2068         boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2069         boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2070 
2071         if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2072             ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2073             ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2074             // if the drag started here, we need to remove it from the workspace
2075             if (!external) {
2076                 getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2077             }
2078 
2079             Rect folderLocation = new Rect();
2080             float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2081             target.removeView(v);
2082 
2083             FolderIcon fi =
2084                 mLauncher.addFolder(target, container, screen, targetCell[0], targetCell[1]);
2085             destInfo.cellX = -1;
2086             destInfo.cellY = -1;
2087             sourceInfo.cellX = -1;
2088             sourceInfo.cellY = -1;
2089 
2090             // If the dragView is null, we can&#x27;t animate
2091             boolean animate = dragView != null;
2092             if (animate) {
2093                 fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2094                         postAnimationRunnable);
2095             } else {
2096                 fi.addItem(destInfo);
2097                 fi.addItem(sourceInfo);
2098             }
2099             return true;
2100         }
2101         return false;
2102     }
2103 
2104     boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2105             DragObject d, boolean external) {
2106         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2107         if (dropOverView instanceof FolderIcon) {
2108             FolderIcon fi = (FolderIcon) dropOverView;
2109             if (fi.acceptDrop(d.dragInfo)) {
2110                 fi.onDrop(d);
2111 
2112                 // if the drag started here, we need to remove it from the workspace
2113                 if (!external) {
2114                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2115                 }
2116                 return true;
2117             }
2118         }
2119         return false;
2120     }
2121 
2122     public void onDrop(final DragObject d) {
<abbr title="2123         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, mDragViewVisualCenter);">2123         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, mDrag</abbr>
2124         // We want the point to be mapped to the dragTarget.
2125         if (mDragTargetLayout != null) {
2126             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2127                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2128             } else {
2129                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2130             }
2131         }
2132         CellLayout dropTargetLayout = mDragTargetLayout;
2133         int snapScreen = -1;
2134         boolean resizeOnDrop = false;
2135         if (d.dragSource != this) {
<abbr title="2136             final int[] touchXY = new int[]{ ((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])) };">2136             final int[] touchXY = new int[]{ ((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualC</abbr>
2137             onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2138         } else if (mDragInfo != null) {
2139             final View cell = mDragInfo.cell;
2140             Runnable resizeRunnable = null;
2141             if (dropTargetLayout != null) {
2142                 // Move internally
2143                 boolean hasMovedLayouts = getParentCellLayoutForView(cell) != dropTargetLayout;
2144                 boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
<abbr title="2145                 long container = (hasMovedIntoHotseat) ? LauncherSettings.Favorites.CONTAINER_HOTSEAT : LauncherSettings.Favorites.CONTAINER_DESKTOP;">2145                 long container = (hasMovedIntoHotseat) ? LauncherSettings.Favorites.CONTAINER_HOTSEAT : L</abbr>
2146                 int screen = (mTargetCell[0] &lt; 0) ? mDragInfo.screen : indexOfChild(dropTargetLayout);
2147                 int spanX = (mDragInfo != null) ? mDragInfo.spanX : 1;
2148                 int spanY = (mDragInfo != null) ? mDragInfo.spanY : 1;
2149                 // First we find the cell nearest to point at which the item is
2150                 // dropped, without any consideration to whether there is an item there.
<abbr title="2151                 mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), spanX, spanY, dropTargetLayout, mTargetCell);">2151                 mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisual</abbr>
2152                 // If the item being dropped is a shortcut and the nearest drop
2153                 // cell also contains a shortcut, then create a folder with the two shortcuts.
<abbr title="2154                 if ((!mInScrollArea) &amp;&amp; createUserFolderIfNecessary(cell, container, dropTargetLayout, mTargetCell, false, d.dragView, null)) {">2154                 if ((!mInScrollArea) &amp;&amp; createUserFolderIfNecessary(cell, container, dropTargetLayout, mT</abbr>
2155                     return;
2156                 }
2157                 if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell, d, false)) {
2158                     return;
2159                 }
2160                 // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2161                 // we need to find the nearest cell location that is vacant
2162                 ItemInfo item = ((ItemInfo) (d.dragInfo));
2163                 int minSpanX = item.spanX;
2164                 int minSpanY = item.spanY;
2165                 if ((item.minSpanX &gt; 0) &amp;&amp; (item.minSpanY &gt; 0)) {
2166                     minSpanX = item.minSpanX;
2167                     minSpanY = item.minSpanY;
2168                 }
2169                 int[] resultSpan = new int[2];
<abbr title="2170                 mTargetCell = findNearestVacantArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), minSpanX, minSpanY, mDragInfo.spanX, mDragInfo.spanY, cell, dropTargetLayout, mTargetCell, resultSpan);">2170                 mTargetCell = findNearestVacantArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragView</abbr>
2171                 boolean foundCell = (mTargetCell[0] &gt;= 0) &amp;&amp; (mTargetCell[1] &gt;= 0);
2172                 if (foundCell &amp;&amp; ((resultSpan[0] != item.spanX) || (resultSpan[1] != item.spanY))) {
2173                     resizeOnDrop = true;
2174                     item.spanX = resultSpan[0];
2175                     item.spanY = resultSpan[1];
2176                 }
2177                 if ((mCurrentPage != screen) &amp;&amp; (!hasMovedIntoHotseat)) {
2178                     snapScreen = screen;
2179                     snapToPage(screen);
2180                 }
2181                 if (foundCell) {
2182                     final ItemInfo info = ((ItemInfo) (cell.getTag()));
2183                     if (hasMovedLayouts) {
2184                         // Reparent the view
2185                         getParentCellLayoutForView(cell).removeView(cell);
<abbr title="2186                         addInScreen(cell, container, screen, mTargetCell[0], mTargetCell[1], info.spanX, info.spanY);">2186                         addInScreen(cell, container, screen, mTargetCell[0], mTargetCell[1], info.spanX, </abbr>
2187                     }
2188                     // update the item&#x27;s position after drop
2189                     CellLayout.LayoutParams lp = ((CellLayout.LayoutParams) (cell.getLayoutParams()));
<abbr title="2190                     dropTargetLayout.onMove(cell, mTargetCell[0], mTargetCell[1], item.spanX, item.spanY);">2190                     dropTargetLayout.onMove(cell, mTargetCell[0], mTargetCell[1], item.spanX, item.spanY)</abbr>
2191                     lp.cellX = mTargetCell[0];
2192                     lp.cellY = mTargetCell[1];
2193                     lp.cellHSpan = item.spanX;
2194                     lp.cellVSpan = item.spanY;
<abbr title="2195                     cell.setId(LauncherModel.getCellLayoutChildId(container, mDragInfo.screen, mTargetCell[0], mTargetCell[1], mDragInfo.spanX, mDragInfo.spanY));">2195                     cell.setId(LauncherModel.getCellLayoutChildId(container, mDragInfo.screen, mTargetCel</abbr>
<abbr title="2196                     if ((container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) &amp;&amp; (cell instanceof LauncherAppWidgetHostView)) {">2196                     if ((container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) &amp;&amp; (cell instanceof L</abbr>
2197                         final CellLayout cellLayout = dropTargetLayout;
2198                         // We post this call so that the widget has a chance to be placed
2199                         // in its final location
2200                         final LauncherAppWidgetHostView hostView = ((LauncherAppWidgetHostView) (cell));
2201                         AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2202                         if (pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
2203                             final Runnable addResizeFrame = new Runnable() {
2204                                 public void run() {
2205                                     DragLayer dragLayer = mLauncher.getDragLayer();
2206                                     dragLayer.addResizeFrame(info, hostView, cellLayout);
2207                                 }
2208                             };
2209                             resizeRunnable = new Runnable() {
2210                                 public void run() {
2211                                     if (!isPageMoving()) {
2212                                         addResizeFrame.run();
2213                                     } else {
2214                                         mDelayedResizeRunnable = addResizeFrame;
2215                                     }
2216                                 }
2217                             };
2218                         }
2219                     }
<abbr title="2220                     LauncherModel.moveItemInDatabase(mLauncher, info, container, screen, lp.cellX, lp.cellY);">2220                     LauncherModel.moveItemInDatabase(mLauncher, info, container, screen, lp.cellX, lp.cel</abbr>
2221                 } else {
2222                     // If we can&#x27;t find a drop location, we return the item to its original position
2223                     CellLayout.LayoutParams lp = ((CellLayout.LayoutParams) (cell.getLayoutParams()));
2224                     mTargetCell[0] = lp.cellX;
2225                     mTargetCell[1] = lp.cellY;
2226                 }
2227             }
2228             final CellLayout parent = ((CellLayout) (cell.getParent().getParent()));
2229             final Runnable finalResizeRunnable = resizeRunnable;
2230             // Prepare it to be animated into its new position
2231             // This must be called after the view has been re-parented
2232             final Runnable onCompleteRunnable = new Runnable() {
2233                 @Override
2234                 public void run() {
2235                     mAnimatingViewIntoPlace = false;
2236                     updateChildrenLayersEnabled();
2237                     if (finalResizeRunnable != null) {
2238                         finalResizeRunnable.run();
2239                     }
2240                 }
2241             };
2242             mAnimatingViewIntoPlace = true;
2243             if (d.dragView.hasDrawn()) {
2244                 final ItemInfo info = ((ItemInfo) (cell.getTag()));
2245                 if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) {
<abbr title="2246                     int animationType = (resizeOnDrop) ? ANIMATE_INTO_POSITION_AND_RESIZE : ANIMATE_INTO_POSITION_AND_DISAPPEAR;">2246                     int animationType = (resizeOnDrop) ? ANIMATE_INTO_POSITION_AND_RESIZE : ANIMATE_INTO_</abbr>
<abbr title="2247                     animateWidgetDrop(info, parent, d.dragView, onCompleteRunnable, animationType, cell, false);">2247                     animateWidgetDrop(info, parent, d.dragView, onCompleteRunnable, animationType, cell, </abbr>
2248                 } else {
<abbr title="2249                     mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, onCompleteRunnable);">2249                     mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, onCompleteRunnable</abbr>
2250                 }
2251             } else {
2252                 d.deferDragViewCleanupPostAnimation = false;
2253                 cell.setVisibility(VISIBLE);
2254             }
2255             parent.onDropChild(cell);
2256         }
2257     }
2258 
2259     public void setFinalScrollForPageChange(int screen) {
2260         if (screen &gt;= 0) {
2261             mSavedScrollX = getScrollX();
2262             CellLayout cl = (CellLayout) getChildAt(screen);
2263             mSavedTranslationX = cl.getTranslationX();
2264             mSavedRotationY = cl.getRotationY();
2265             final int newX = getChildOffset(screen) - getRelativeChildOffset(screen);
2266             setScrollX(newX);
2267             cl.setTranslationX(0f);
2268             cl.setRotationY(0f);
2269         }
2270     }
2271 
2272     public void resetFinalScrollForPageChange(int screen) {
2273         if (screen &gt;= 0) {
2274             CellLayout cl = (CellLayout) getChildAt(screen);
2275             setScrollX(mSavedScrollX);
2276             cl.setTranslationX(mSavedTranslationX);
2277             cl.setRotationY(mSavedRotationY);
2278         }
2279     }
2280 
2281     public void getViewLocationRelativeToSelf(View v, int[] location) {
2282         getLocationInWindow(location);
2283         int x = location[0];
2284         int y = location[1];
2285 
2286         v.getLocationInWindow(location);
2287         int vX = location[0];
2288         int vY = location[1];
2289 
2290         location[0] = vX - x;
2291         location[1] = vY - y;
2292     }
2293 
2294     public void onDragEnter(DragObject d) {
2295         mDragHasEnteredWorkspace = true;
2296         if (mDragTargetLayout != null) {
2297             mDragTargetLayout.setIsDragOverlapping(false);
2298             mDragTargetLayout.onDragExit();
2299         }
2300         mDragTargetLayout = getCurrentDropLayout();
2301         mDragTargetLayout.setIsDragOverlapping(true);
2302         mDragTargetLayout.onDragEnter();
2303         // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
2304         // don&#x27;t need to show the outlines
2305         if (LauncherApplication.isScreenLarge()) {
2306             showOutlines();
2307         }
2308     }
2309 
2310     private void doDragExit(DragObject d) {
2311         // Clean up folders
2312         cleanupFolderCreation(d);
2313 
2314         // Reset the scroll area and previous drag target
2315         onResetScrollArea();
2316 
2317         if (mDragTargetLayout != null) {
2318             mDragTargetLayout.setIsDragOverlapping(false);
2319             mDragTargetLayout.onDragExit();
2320         }
2321         mLastDragOverView = null;
2322         mSpringLoadedDragController.cancel();
2323 
2324         if (!mIsPageMoving) {
2325             hideOutlines();
2326         }
2327     }
2328 
2329     public void onDragExit(DragObject d) {
2330         mDragHasEnteredWorkspace = false;
2331         doDragExit(d);
2332     }
2333 
2334     public DropTarget getDropTargetDelegate(DragObject d) {
2335         return null;
2336     }
2337 
2338     /**
2339      * Tests to see if the drop will be accepted by Launcher, and if so, includes additional data
2340      * in the returned structure related to the widgets that match the drop (or a null list if it is
2341      * a shortcut drop).  If the drop is not accepted then a null structure is returned.
2342      */
2343     private Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; validateDrag(DragEvent event) {
2344         final LauncherModel model = mLauncher.getModel();
2345         final ClipDescription desc = event.getClipDescription();
2346         final int mimeTypeCount = desc.getMimeTypeCount();
2347         for (int i = 0; i &lt; mimeTypeCount; ++i) {
2348             final String mimeType = desc.getMimeType(i);
2349             if (mimeType.equals(InstallShortcutReceiver.SHORTCUT_MIMETYPE)) {
2350                 return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, null);
2351             } else {
2352                 final List&lt;WidgetMimeTypeHandlerData&gt; widgets =
2353                     model.resolveWidgetsForMimeType(mContext, mimeType);
2354                 if (widgets.size() &gt; 0) {
2355                     return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, widgets);
2356                 }
2357             }
2358         }
2359         return null;
2360     }
2361 
2362     /**
2363      * Global drag and drop handler
2364      */
2365     @Override
2366     public boolean onDragEvent(DragEvent event) {
2367         final ClipDescription desc = event.getClipDescription();
2368         final CellLayout layout = ((CellLayout) (getChildAt(mCurrentPage)));
2369         final int[] pos = new int[2];
2370         layout.getLocationOnScreen(pos);
2371         // We need to offset the drag coordinates to layout coordinate space
2372         final int x = ((int) (event.getX())) - pos[0];
2373         final int y = ((int) (event.getY())) - pos[1];
2374         switch (event.getAction()) {
2375             case DragEvent.ACTION_DRAG_STARTED :
2376                 {
2377                     // Validate this drag
2378                     Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2379                     if (test != null) {
2380                         boolean isShortcut = test.second == null;
2381                         if (isShortcut) {
2382                             // Check if we have enough space on this screen to add a new shortcut
2383                             if (!layout.findCellForSpan(pos, 1, 1)) {
2384                                 mLauncher.showOutOfSpaceMessage();
2385                                 return false;
2386                             }
2387                         }
2388                     } else {
2389                         // Show error message if we couldn&#x27;t accept any of the items
<abbr title="2390                         Toast.makeText(mContext, mContext.getString(R.string.external_drop_widget_error), Toast.LENGTH_SHORT).show();">2390                         Toast.makeText(mContext, mContext.getString(R.string.external_drop_widget_error),</abbr>
2391                         return false;
2392                     }
2393                     // Create the drag outline
2394                     // We need to add extra padding to the bitmap to make room for the glow effect
2395                     final Canvas canvas = new Canvas();
2396                     mDragOutline = createExternalDragOutline(canvas, DRAG_BITMAP_PADDING);
2397                     // Show the current page outlines to indicate that we can accept this drop
2398                     showOutlines();
2399                     layout.onDragEnter();
2400                     layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, 1, 1, null, null);
2401                     return true;
2402                 }
2403             case DragEvent.ACTION_DRAG_LOCATION :
2404             // Visualize the drop location
2405                 layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, 1, 1, null, null);
2406                 return true;
2407             case DragEvent.ACTION_DROP :
2408                 {
2409                     // Try and add any shortcuts
2410                     final LauncherModel model = mLauncher.getModel();
2411                     final ClipData data = event.getClipData();
2412                     // We assume that the mime types are ordered in descending importance of
2413                     // representation. So we enumerate the list of mime types and alert the
2414                     // user if any widgets can handle the drop.  Only the most preferred
2415                     // representation will be handled.
2416                     pos[0] = x;
2417                     pos[1] = y;
2418                     Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2419                     if (test != null) {
2420                         final int index = test.first;
2421                         final List&lt;WidgetMimeTypeHandlerData&gt; widgets = test.second;
2422                         final boolean isShortcut = widgets == null;
2423                         final String mimeType = desc.getMimeType(index);
2424                         if (isShortcut) {
2425                             final Intent intent = data.getItemAt(index).getIntent();
2426                             Object info = model.infoFromShortcutIntent(mContext, intent, data.getIcon());
2427                             if (info != null) {
2428                                 onDropExternal(new int[]{ x, y }, info, layout, false);
2429                             }
2430                         } else if (widgets.size() == 1) {
2431                             // If there is only one item, then go ahead and add and configure
2432                             // that widget
2433                             final AppWidgetProviderInfo widgetInfo = widgets.get(0).widgetInfo;
<abbr title="2434                             final PendingAddWidgetInfo createInfo = new PendingAddWidgetInfo(widgetInfo, mimeType, data);">2434                             final PendingAddWidgetInfo createInfo = new PendingAddWidgetInfo(widgetInfo, </abbr>
<abbr title="2435                             mLauncher.addAppWidgetFromDrop(createInfo, LauncherSettings.Favorites.CONTAINER_DESKTOP, mCurrentPage, null, null, pos);">2435                             mLauncher.addAppWidgetFromDrop(createInfo, LauncherSettings.Favorites.CONTAIN</abbr>
2436                         } else {
2437                             // Show the widget picker dialog if there is more than one widget
2438                             // that can handle this data type
<abbr title="2439                             final InstallWidgetReceiver.WidgetListAdapter adapter = new InstallWidgetReceiver.WidgetListAdapter(mLauncher, mimeType, data, widgets, layout, mCurrentPage, pos);">2439                             final InstallWidgetReceiver.WidgetListAdapter adapter = new InstallWidgetRece</abbr>
2440                             final AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
2441                             builder.setAdapter(adapter, adapter);
2442                             builder.setCancelable(true);
<abbr title="2443                             builder.setTitle(mContext.getString(R.string.external_drop_widget_pick_title));">2443                             builder.setTitle(mContext.getString(R.string.external_drop_widget_pick_title)</abbr>
2444                             builder.setIcon(R.drawable.ic_no_applications);
2445                             builder.show();
2446                         }
2447                     }
2448                     return true;
2449                 }
2450             case DragEvent.ACTION_DRAG_ENDED :
2451                 // Hide the page outlines after the drop
2452                 layout.onDragExit();
2453                 hideOutlines();
2454                 return true;
2455         }
2456         return super.onDragEvent(event);
2457     }
2458 
2459     /*
2460     *
2461     * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2462     * coordinate space. The argument xy is modified with the return result.
2463     *
2464     */
2465        void mapPointFromSelfToChild(View v, float[] xy) {
2466        mapPointFromSelfToChild(v, xy, null);
2467        }
2468 
2469 /*
2470  *
2471  * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2472  * coordinate space. The argument xy is modified with the return result.
2473  *
2474  * if cachedInverseMatrix is not null, this method will just use that matrix instead of
2475  * computing it itself; we use this to avoid redundant matrix inversions in
2476  * findMatchingPageForDragOver
2477  *
2478  */
2479     void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
2480         if (cachedInverseMatrix == null) {
2481             v.getMatrix().invert(mTempInverseMatrix);
2482             cachedInverseMatrix = mTempInverseMatrix;
2483         }
2484         int scrollX = mScrollX;
2485         if (mNextPage != INVALID_PAGE) {
2486             scrollX = mScroller.getFinalX();
2487         }
2488         xy[0] = (xy[0] + scrollX) - v.getLeft();
2489         xy[1] = (xy[1] + mScrollY) - v.getTop();
2490         cachedInverseMatrix.mapPoints(xy);
2491     }
2492 
2493 /*
2494  * Maps a point from the Workspace&#x27;s coordinate system to another sibling view&#x27;s. (Workspace
2495  * covers the full screen)
2496  */
2497 void mapPointFromSelfToSibling(View v, float[] xy) {
2498     xy[0] = xy[0] - v.getLeft();
2499     xy[1] = xy[1] - v.getTop();
2500 }
2501 
2502 /*
2503  *
2504  * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
2505  * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
2506  *
2507  */
2508     void mapPointFromChildToSelf(View v, float[] xy) {
2509         v.getMatrix().mapPoints(xy);
2510         int scrollX = mScrollX;
2511         if (mNextPage != INVALID_PAGE) {
2512             scrollX = mScroller.getFinalX();
2513         }
2514         xy[0] -= scrollX - v.getLeft();
2515         xy[1] -= mScrollY - v.getTop();
2516     }
2517 
2518 static private float squaredDistance(float[] point1, float[] point2) {
2519      float distanceX = point1[0] - point2[0];
2520      float distanceY = point2[1] - point2[1];
2521      return distanceX * distanceX + distanceY * distanceY;
2522 }
2523 
2524     /*
2525      *
2526      * Returns true if the passed CellLayout cl overlaps with dragView
2527      *
2528      */
2529     boolean overlaps(CellLayout cl, DragView dragView,
2530             int dragViewX, int dragViewY, Matrix cachedInverseMatrix) {
2531         // Transform the coordinates of the item being dragged to the CellLayout&#x27;s coordinates
2532         final float[] draggedItemTopLeft = mTempDragCoordinates;
2533         draggedItemTopLeft[0] = dragViewX;
2534         draggedItemTopLeft[1] = dragViewY;
2535         final float[] draggedItemBottomRight = mTempDragBottomRightCoordinates;
2536         draggedItemBottomRight[0] = draggedItemTopLeft[0] + dragView.getDragRegionWidth();
2537         draggedItemBottomRight[1] = draggedItemTopLeft[1] + dragView.getDragRegionHeight();
2538 
2539         // Transform the dragged item&#x27;s top left coordinates
2540         // to the CellLayout&#x27;s local coordinates
2541         mapPointFromSelfToChild(cl, draggedItemTopLeft, cachedInverseMatrix);
2542         float overlapRegionLeft = Math.max(0f, draggedItemTopLeft[0]);
2543         float overlapRegionTop = Math.max(0f, draggedItemTopLeft[1]);
2544 
2545         if (overlapRegionLeft &lt;= cl.getWidth() &amp;&amp; overlapRegionTop &gt;= 0) {
2546             // Transform the dragged item&#x27;s bottom right coordinates
2547             // to the CellLayout&#x27;s local coordinates
2548             mapPointFromSelfToChild(cl, draggedItemBottomRight, cachedInverseMatrix);
2549             float overlapRegionRight = Math.min(cl.getWidth(), draggedItemBottomRight[0]);
2550             float overlapRegionBottom = Math.min(cl.getHeight(), draggedItemBottomRight[1]);
2551 
2552             if (overlapRegionRight &gt;= 0 &amp;&amp; overlapRegionBottom &lt;= cl.getHeight()) {
2553                 float overlap = (overlapRegionRight - overlapRegionLeft) *
2554                          (overlapRegionBottom - overlapRegionTop);
2555                 if (overlap &gt; 0) {
2556                     return true;
2557                 }
2558              }
2559         }
2560         return false;
2561     }
2562 
2563     /*
2564      *
2565      * This method returns the CellLayout that is currently being dragged to. In order to drag
2566      * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
2567      * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
2568      *
2569      * Return null if no CellLayout is currently being dragged over
2570      *
2571      */
2572     private CellLayout findMatchingPageForDragOver(
2573             DragView dragView, float originX, float originY, boolean exact) {
2574         // We loop through all the screens (ie CellLayouts) and see which ones overlap
2575         // with the item being dragged and then choose the one that&#x27;s closest to the touch point
2576         final int screenCount = getChildCount();
2577         CellLayout bestMatchingScreen = null;
2578         float smallestDistSoFar = Float.MAX_VALUE;
2579 
2580         for (int i = 0; i &lt; screenCount; i++) {
2581             CellLayout cl = (CellLayout) getChildAt(i);
2582 
2583             final float[] touchXy = {originX, originY};
2584             // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
2585             // If the touch point is within the bounds of the cell layout, we can return immediately
2586             cl.getMatrix().invert(mTempInverseMatrix);
2587             mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
2588 
2589             if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
2590                     touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
2591                 return cl;
2592             }
2593 
2594             if (!exact) {
2595                 // Get the center of the cell layout in screen coordinates
2596                 final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
2597                 cellLayoutCenter[0] = cl.getWidth()/2;
2598                 cellLayoutCenter[1] = cl.getHeight()/2;
2599                 mapPointFromChildToSelf(cl, cellLayoutCenter);
2600 
2601                 touchXy[0] = originX;
2602                 touchXy[1] = originY;
2603 
2604                 // Calculate the distance between the center of the CellLayout
2605                 // and the touch point
2606                 float dist = squaredDistance(touchXy, cellLayoutCenter);
2607 
2608                 if (dist &lt; smallestDistSoFar) {
2609                     smallestDistSoFar = dist;
2610                     bestMatchingScreen = cl;
2611                 }
2612             }
2613         }
2614         return bestMatchingScreen;
2615     }
2616 
2617     // This is used to compute the visual center of the dragView. This point is then
2618     // used to visualize drop locations and determine where to drop an item. The idea is that
2619     // the visual center represents the user&#x27;s interpretation of where the item is, and hence
2620     // is the appropriate point to use when determining drop location.
2621     private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
2622             DragView dragView, float[] recycle) {
2623         float res[];
2624         if (recycle == null) {
2625             res = new float[2];
2626         } else {
2627             res = recycle;
2628         }
2629 
2630         // First off, the drag view has been shifted in a way that is not represented in the
2631         // x and y values or the x/yOffsets. Here we account for that shift.
2632         x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
2633         y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
2634 
2635         // These represent the visual top and left of drag view if a dragRect was provided.
2636         // If a dragRect was not provided, then they correspond to the actual view left and
2637         // top, as the dragRect is in that case taken to be the entire dragView.
2638         // R.dimen.dragViewOffsetY.
2639         int left = x - xOffset;
2640         int top = y - yOffset;
2641 
2642         // In order to find the visual center, we shift by half the dragRect
2643         res[0] = left + dragView.getDragRegion().width() / 2;
2644         res[1] = top + dragView.getDragRegion().height() / 2;
2645 
2646         return res;
2647     }
2648 
2649     private boolean isDragWidget(DragObject d) {
2650         return (d.dragInfo instanceof LauncherAppWidgetInfo ||
2651                 d.dragInfo instanceof PendingAddWidgetInfo);
2652     }
2653 
2654     private boolean isExternalDragWidget(DragObject d) {
2655         return d.dragSource != this &amp;&amp; isDragWidget(d);
2656     }
2657 
2658     public void onDragOver(DragObject d) {
2659         // Skip drag over events while we are dragging over side pages
2660         if ((mInScrollArea || mIsSwitchingState) || (mState == State.SMALL)) {
2661             return;
2662         }
2663         Rect r = new Rect();
2664         CellLayout layout = null;
2665         ItemInfo item = ((ItemInfo) (d.dragInfo));
2666         // Ensure that we have proper spans for the item that we are dropping
2667         if ((item.spanX &lt; 0) || (item.spanY &lt; 0)) {
2668             throw new RuntimeException(&quot;Improper spans found&quot;);
2669         }
<abbr title="2670         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, mDragViewVisualCenter);">2670         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, mDrag</abbr>
2671         // Identify whether we have dragged over a side page
2672         if (isSmall()) {
2673             if ((mLauncher.getHotseat() != null) &amp;&amp; (!isExternalDragWidget(d))) {
2674                 mLauncher.getHotseat().getHitRect(r);
2675                 if (r.contains(d.x, d.y)) {
2676                     layout = mLauncher.getHotseat().getLayout();
2677                 }
2678             }
2679             if (layout == null) {
2680                 layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
2681             }
2682             if (layout != mDragTargetLayout) {
2683                 // Cancel all intermediate folder states
2684                 cleanupFolderCreation(d);
2685                 if (mDragTargetLayout != null) {
2686                     mDragTargetLayout.setIsDragOverlapping(false);
2687                     mDragTargetLayout.onDragExit();
2688                 }
2689                 mDragTargetLayout = layout;
2690                 if (mDragTargetLayout != null) {
2691                     mDragTargetLayout.setIsDragOverlapping(true);
2692                     mDragTargetLayout.onDragEnter();
2693                 } else {
2694                     mLastDragOverView = null;
2695                 }
2696                 boolean isInSpringLoadedMode = mState == State.SPRING_LOADED;
2697                 if (isInSpringLoadedMode) {
2698                     if (mLauncher.isHotseatLayout(layout)) {
2699                         mSpringLoadedDragController.cancel();
2700                     } else {
2701                         mSpringLoadedDragController.setAlarm(mDragTargetLayout);
2702                     }
2703                 }
2704             }
2705         } else {
2706             // Test to see if we are over the hotseat otherwise just use the current page
2707             if ((mLauncher.getHotseat() != null) &amp;&amp; (!isDragWidget(d))) {
2708                 mLauncher.getHotseat().getHitRect(r);
2709                 if (r.contains(d.x, d.y)) {
2710                     layout = mLauncher.getHotseat().getLayout();
2711                 }
2712             }
2713             if (layout == null) {
2714                 layout = getCurrentDropLayout();
2715             }
2716             if (layout != mDragTargetLayout) {
2717                 if (mDragTargetLayout != null) {
2718                     mDragTargetLayout.setIsDragOverlapping(false);
2719                     mDragTargetLayout.onDragExit();
2720                 }
2721                 mDragTargetLayout = layout;
2722                 mDragTargetLayout.setIsDragOverlapping(true);
2723                 mDragTargetLayout.onDragEnter();
2724             }
2725         }
2726         // Handle the drag over
2727         if (mDragTargetLayout != null) {
2728             final View child = (mDragInfo == null) ? null : mDragInfo.cell;
2729             // We want the point to be mapped to the dragTarget.
2730             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2731                 mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2732             } else {
2733                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2734             }
2735             ItemInfo info = ((ItemInfo) (d.dragInfo));
<abbr title="2736             mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), 1, 1, mDragTargetLayout, mTargetCell);">2736             mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCent</abbr>
2737             final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0], mTargetCell[1]);
<abbr title="2738             boolean userFolderPending = willCreateUserFolder(info, mDragTargetLayout, mTargetCell, false);">2738             boolean userFolderPending = willCreateUserFolder(info, mDragTargetLayout, mTargetCell, false)</abbr>
2739             boolean isOverFolder = dragOverView instanceof FolderIcon;
2740             if (dragOverView != mLastDragOverView) {
2741                 cancelFolderCreation();
2742                 if ((mLastDragOverView != null) &amp;&amp; (mLastDragOverView instanceof FolderIcon)) {
2743                     ((FolderIcon) (mLastDragOverView)).onDragExit(d.dragInfo);
2744                 }
2745             }
2746             if (userFolderPending &amp;&amp; (dragOverView != mLastDragOverView)) {
<abbr title="2747                 mFolderCreationAlarm.setOnAlarmListener(new FolderCreationAlarmListener(mDragTargetLayout, mTargetCell[0], mTargetCell[1]));">2747                 mFolderCreationAlarm.setOnAlarmListener(new FolderCreationAlarmListener(mDragTargetLayout</abbr>
2748                 mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
2749             }
2750             if ((dragOverView != mLastDragOverView) &amp;&amp; isOverFolder) {
2751                 ((FolderIcon) (dragOverView)).onDragEnter(d.dragInfo);
2752                 if (mDragTargetLayout != null) {
2753                     mDragTargetLayout.clearDragOutlines();
2754                 }
2755             }
2756             mLastDragOverView = dragOverView;
2757             if ((!mCreateUserFolderOnDrop) &amp;&amp; (!isOverFolder)) {
2758                 int minSpanX = item.spanX;
2759                 int minSpanY = item.spanY;
2760                 if ((item.minSpanX &gt; 0) &amp;&amp; (item.minSpanY &gt; 0)) {
2761                     minSpanX = item.minSpanX;
2762                     minSpanY = item.minSpanY;
2763                 }
<abbr title="2764                 mDragTargetLayout.visualizeDropLocation(child, mDragOutline, ((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), minSpanX, minSpanY, item.spanX, item.spanY, d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());">2764                 mDragTargetLayout.visualizeDropLocation(child, mDragOutline, ((int) (mDragViewVisualCente</abbr>
2765             }
2766         }
2767     }
2768 
2769     private void cleanupFolderCreation(DragObject d) {
2770         if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
2771             mDragFolderRingAnimator.animateToNaturalState();
2772         }
2773         if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
2774             if (d != null) {
2775                 ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
2776             }
2777         }
2778         mFolderCreationAlarm.cancelAlarm();
2779     }
2780 
2781     private void cancelFolderCreation() {
2782         if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
2783             mDragFolderRingAnimator.animateToNaturalState();
2784         }
2785         mCreateUserFolderOnDrop = false;
2786         mFolderCreationAlarm.cancelAlarm();
2787     }
2788 
2789     class FolderCreationAlarmListener implements OnAlarmListener {
2790         CellLayout layout;
2791 
2792         int cellX;
2793 
2794         int cellY;
2795 
2796         public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
2797             this.layout = layout;
2798             this.cellX = cellX;
2799             this.cellY = cellY;
2800         }
2801 
2802         public void onAlarm(Alarm alarm) {
2803             if (mDragFolderRingAnimator == null) {
2804                 mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
2805             }
2806             mDragFolderRingAnimator.setCell(cellX, cellY);
2807             mDragFolderRingAnimator.setCellLayout(layout);
2808             mDragFolderRingAnimator.animateToAcceptState();
2809             layout.showFolderAccept(mDragFolderRingAnimator);
2810             layout.clearDragOutlines();
2811             mCreateUserFolderOnDrop = true;
2812         }
2813     }
2814 
2815     @Override
2816     public void getHitRect(Rect outRect) {
2817         // We want the workspace to have the whole area of the display (it will find the correct
2818         // cell layout to drop to in the existing drag/drop logic.
2819         outRect.set(0, 0, mDisplayWidth, mDisplayHeight);
2820     }
2821 
2822     /**
2823      * Add the item specified by dragInfo to the given layout.
2824      * @return true if successful
2825      */
2826     public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
2827         if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
2828             onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
2829             return true;
2830         }
2831         mLauncher.showOutOfSpaceMessage();
2832         return false;
2833     }
2834 
2835     private void onDropExternal(int[] touchXY, Object dragInfo,
2836             CellLayout cellLayout, boolean insertAtFirst) {
2837         onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
2838     }
2839 
2840     /**
2841      * Drop an item that didn&#x27;t originate on one of the workspace screens.
2842      * It may have come from Launcher (e.g. from all apps or customize), or it may have
2843      * come from another app altogether.
2844      *
2845      * NOTE: This can also be called when we are outside of a drag event, when we want
2846      * to add an item to one of the workspace screens.
2847      */
<abbr title="2848     private void onDropExternal(final int[] touchXY, final Object dragInfo, final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {">2848     private void onDropExternal(final int[] touchXY, final Object dragInfo, final CellLayout cellLayout, </abbr>
2849         final Runnable exitSpringLoadedRunnable = new Runnable() {
2850             @Override
2851             public void run() {
2852                 mLauncher.exitSpringLoadedDragModeDelayed(true, false, null);
2853             }
2854         };
2855         ItemInfo info = ((ItemInfo) (dragInfo));
2856         int spanX = info.spanX;
2857         int spanY = info.spanY;
2858         if (mDragInfo != null) {
2859             spanX = mDragInfo.spanX;
2860             spanY = mDragInfo.spanY;
2861         }
<abbr title="2862         final long container = (mLauncher.isHotseatLayout(cellLayout)) ? LauncherSettings.Favorites.CONTAINER_HOTSEAT : LauncherSettings.Favorites.CONTAINER_DESKTOP;">2862         final long container = (mLauncher.isHotseatLayout(cellLayout)) ? LauncherSettings.Favorites.CONTA</abbr>
2863         final int screen = indexOfChild(cellLayout);
<abbr title="2864         if (((!mLauncher.isHotseatLayout(cellLayout)) &amp;&amp; (screen != mCurrentPage)) &amp;&amp; (mState != State.SPRING_LOADED)) {">2864         if (((!mLauncher.isHotseatLayout(cellLayout)) &amp;&amp; (screen != mCurrentPage)) &amp;&amp; (mState != State.SP</abbr>
2865             snapToPage(screen);
2866         }
2867         if (info instanceof PendingAddItemInfo) {
2868             final PendingAddItemInfo pendingInfo = ((PendingAddItemInfo) (dragInfo));
2869             boolean findNearestVacantCell = true;
2870             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
<abbr title="2871                 mTargetCell = findNearestArea(((int) (touchXY[0])), ((int) (touchXY[1])), spanX, spanY, cellLayout, mTargetCell);">2871                 mTargetCell = findNearestArea(((int) (touchXY[0])), ((int) (touchXY[1])), spanX, spanY, c</abbr>
<abbr title="2872                 if (willCreateUserFolder(((ItemInfo) (d.dragInfo)), mDragTargetLayout, mTargetCell, true) || willAddToExistingUserFolder(((ItemInfo) (d.dragInfo)), mDragTargetLayout, mTargetCell)) {">2872                 if (willCreateUserFolder(((ItemInfo) (d.dragInfo)), mDragTargetLayout, mTargetCell, true)</abbr>
2873                     findNearestVacantCell = false;
2874                 }
2875             }
2876             final ItemInfo item = ((ItemInfo) (d.dragInfo));
2877             int minSpanX = item.spanX;
2878             int minSpanY = item.spanY;
2879             if ((item.minSpanX &gt; 0) &amp;&amp; (item.minSpanY &gt; 0)) {
2880                 minSpanX = item.minSpanX;
2881                 minSpanY = item.minSpanY;
2882             }
2883             if (findNearestVacantCell) {
2884                 int[] resultSpan = new int[2];
<abbr title="2885                 mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], minSpanX, minSpanY, spanX, spanY, null, cellLayout, mTargetCell, resultSpan);">2885                 mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], minSpanX, minSpanY, spanX, sp</abbr>
2886                 item.spanX = resultSpan[0];
2887                 item.spanY = resultSpan[1];
2888             }
2889             Runnable onAnimationCompleteRunnable = new Runnable() {
2890                 @Override
2891                 public void run() {
2892                     // When dragging and dropping from customization tray, we deal with creating
2893                     // widgets/shortcuts/folders in a slightly different way
2894                     switch (pendingInfo.itemType) {
2895                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
2896                             int[] span = new int[2];
2897                             span[0] = item.spanX;
2898                             span[1] = item.spanY;
<abbr title="2899                             mLauncher.addAppWidgetFromDrop(((PendingAddWidgetInfo) (pendingInfo)), container, screen, mTargetCell, span, null);">2899                             mLauncher.addAppWidgetFromDrop(((PendingAddWidgetInfo) (pendingInfo)), contai</abbr>
2900                             break;
2901                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
<abbr title="2902                             mLauncher.processShortcutFromDrop(pendingInfo.componentName, container, screen, mTargetCell, null);">2902                             mLauncher.processShortcutFromDrop(pendingInfo.componentName, container, scree</abbr>
2903                             break;
2904                         default :
<abbr title="2905                             throw new IllegalStateException(&quot;Unknown item type: &quot; + pendingInfo.itemType);">2905                             throw new IllegalStateException(&quot;Unknown item type: &quot; + pendingInfo.itemType)</abbr>
2906                     }
2907                     cellLayout.onDragExit();
2908                 }
2909             };
<abbr title="2910             View finalView = (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) ? ((PendingAddWidgetInfo) (pendingInfo)).boundWidget : null;">2910             View finalView = (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) ? (</abbr>
2911             int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;
<abbr title="2912             if ((pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) &amp;&amp; (((PendingAddWidgetInfo) (pendingInfo)).info.configure != null)) {">2912             if ((pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) &amp;&amp; (((PendingAdd</abbr>
2913                 animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;
2914             }
<abbr title="2915             animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable, animationStyle, finalView, true);">2915             animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable, animationStyle, </abbr>
2916         } else {
2917             // This is for other drag/drop cases, like dragging from All Apps
2918             View view = null;
2919             switch (info.itemType) {
2920                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
2921                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
2922                     if ((info.container == NO_ID) &amp;&amp; (info instanceof ApplicationInfo)) {
2923                         // Came from all apps -- make a copy
2924                         info = new ShortcutInfo(((ApplicationInfo) (info)));
2925                     }
<abbr title="2926                     view = mLauncher.createShortcut(R.layout.application, cellLayout, ((ShortcutInfo) (info)));">2926                     view = mLauncher.createShortcut(R.layout.application, cellLayout, ((ShortcutInfo) (in</abbr>
2927                     break;
2928                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
<abbr title="2929                     view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout, ((FolderInfo) (info)), mIconCache);">2929                     view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout, ((FolderInfo) </abbr>
2930                     break;
2931                 default :
2932                     throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
2933             }
2934             // First we find the cell nearest to point at which the item is
2935             // dropped, without any consideration to whether there is an item there.
2936             if (touchXY != null) {
<abbr title="2937                 mTargetCell = findNearestArea(((int) (touchXY[0])), ((int) (touchXY[1])), spanX, spanY, cellLayout, mTargetCell);">2937                 mTargetCell = findNearestArea(((int) (touchXY[0])), ((int) (touchXY[1])), spanX, spanY, c</abbr>
2938                 d.postAnimationRunnable = exitSpringLoadedRunnable;
<abbr title="2939                 if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, true, d.dragView, d.postAnimationRunnable)) {">2939                 if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, true, d.dragVie</abbr>
2940                     return;
2941                 }
2942                 if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, d, true)) {
2943                     return;
2944                 }
2945             }
2946             if (touchXY != null) {
2947                 // when dragging and dropping, just find the closest free spot
<abbr title="2948                 mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, null, cellLayout, mTargetCell);">2948                 mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, null, cellLayout, mTarg</abbr>
2949             } else {
2950                 cellLayout.findCellForSpan(mTargetCell, 1, 1);
2951             }
<abbr title="2952             addInScreen(view, container, screen, mTargetCell[0], mTargetCell[1], info.spanX, info.spanY, insertAtFirst);">2952             addInScreen(view, container, screen, mTargetCell[0], mTargetCell[1], info.spanX, info.spanY, </abbr>
2953             cellLayout.onDropChild(view);
2954             CellLayout.LayoutParams lp = ((CellLayout.LayoutParams) (view.getLayoutParams()));
2955             cellLayout.getChildrenLayout().measureChild(view);
<abbr title="2956             LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen, lp.cellX, lp.cellY);">2956             LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen, lp.cellX, lp.cellY)</abbr>
2957             if (d.dragView != null) {
2958                 // We wrap the animation call in the temporary set and reset of the current
2959                 // cellLayout to its final transform -- this means we animate the drag view to
2960                 // the correct final location.
2961                 setFinalTransitionTransform(cellLayout);
<abbr title="2962                 mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view, exitSpringLoadedRunnable);">2962                 mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view, exitSpringLoadedRunnab</abbr>
2963                 resetTransitionTransform(cellLayout);
2964             }
2965         }
2966     }
2967 
2968     public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {
<abbr title="2969         int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX, widgetInfo.spanY, widgetInfo, false);">2969         int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX, widgetInfo.spanY</abbr>
2970         int visibility = layout.getVisibility();
2971         layout.setVisibility(VISIBLE);
2972         int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);
2973         int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);
2974         Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1], Bitmap.Config.ARGB_8888);
2975         Canvas c = new Canvas(b);
2976         layout.measure(width, height);
2977         layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);
2978         layout.draw(c);
2979         c.setBitmap(null);
2980         layout.setVisibility(visibility);
2981         return b;
2982     }
2983 
<abbr title="2984     private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY, DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell, View finalView, boolean external) {">2984     private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY, DragView dragView, CellLayo</abbr>
2985         // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
2986         // location and size on the home screen.
2987         int spanX = info.spanX;
2988         int spanY = info.spanY;
2989         Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);
2990         loc[0] = r.left;
2991         loc[1] = r.top;
2992         setFinalTransitionTransform(layout);
2993         float cellLayoutScale = mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc);
2994         resetTransitionTransform(layout);
2995         float dragViewScaleX = (1.0F * r.width()) / dragView.getMeasuredWidth();
2996         float dragViewScaleY = (1.0F * r.height()) / dragView.getMeasuredHeight();
2997         // The animation will scale the dragView about its center, so we need to center about
2998         // the final location.
2999         loc[0] -= (dragView.getMeasuredWidth() - (cellLayoutScale * r.width())) / 2;
3000         loc[1] -= (dragView.getMeasuredHeight() - (cellLayoutScale * r.height())) / 2;
3001         scaleXY[0] = dragViewScaleX * cellLayoutScale;
3002         scaleXY[1] = dragViewScaleY * cellLayoutScale;
3003     }
3004 
<abbr title="3005     public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView, final Runnable onCompleteRunnable, int animationType, final View finalView, boolean external) {">3005     public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView, final Runnable</abbr>
3006         Rect from = new Rect();
3007         mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);
3008         int[] finalPos = new int[2];
3009         float[] scaleXY = new float[2];
<abbr title="3010         getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell, finalView, external);">3010         getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell, fina</abbr>
3011         Resources res = mLauncher.getResources();
3012         int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;
3013         // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer
3014         if ((finalView instanceof AppWidgetHostView) &amp;&amp; external) {
3015             mLauncher.getDragLayer().removeView(finalView);
3016         }
3017         if (((animationType == ANIMATE_INTO_POSITION_AND_RESIZE) || external) &amp;&amp; (finalView != null)) {
3018             Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);
3019             dragView.setCrossFadeBitmap(crossFadeBitmap);
3020             dragView.crossFade(((int) (duration * 0.8F)));
3021         } else if ((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) &amp;&amp; external) {
3022             scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0], scaleXY[1]);
3023         }
3024         DragLayer dragLayer = mLauncher.getDragLayer();
3025         if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {
<abbr title="3026             mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0.0F, 0.1F, 0.1F, DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);">3026             mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0.0F, 0.1F, 0.1F, DragLa</abbr>
3027         } else {
3028             int endStyle;
3029             if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {
3030                 endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;
3031             } else {
3032                 endStyle = DragLayer.ANIMATION_END_DISAPPEAR;
3033             }
3034             Runnable onComplete = new Runnable() {
3035                 @Override
3036                 public void run() {
3037                     if (finalView != null) {
3038                         finalView.setVisibility(VISIBLE);
3039                     }
3040                     if (onCompleteRunnable != null) {
3041                         onCompleteRunnable.run();
3042                     }
3043                 }
3044             };
<abbr title="3045             dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0], finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle, duration, this);">3045             dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0], finalPos[1], 1,</abbr>
3046         }
3047     }
3048 
3049     public void setFinalTransitionTransform(CellLayout layout) {
3050         if (isSwitchingState()) {
3051             int index = indexOfChild(layout);
3052             mCurrentScaleX = layout.getScaleX();
3053             mCurrentScaleY = layout.getScaleY();
3054             mCurrentTranslationX = layout.getTranslationX();
3055             mCurrentTranslationY = layout.getTranslationY();
3056             mCurrentRotationY = layout.getRotationY();
3057             layout.setScaleX(mNewScaleXs[index]);
3058             layout.setScaleY(mNewScaleYs[index]);
3059             layout.setTranslationX(mNewTranslationXs[index]);
3060             layout.setTranslationY(mNewTranslationYs[index]);
3061             layout.setRotationY(mNewRotationYs[index]);
3062         }
3063     }
3064 
3065     public void resetTransitionTransform(CellLayout layout) {
3066         if (isSwitchingState()) {
3067             mCurrentScaleX = layout.getScaleX();
3068             mCurrentScaleY = layout.getScaleY();
3069             mCurrentTranslationX = layout.getTranslationX();
3070             mCurrentTranslationY = layout.getTranslationY();
3071             mCurrentRotationY = layout.getRotationY();
3072             layout.setScaleX(mCurrentScaleX);
3073             layout.setScaleY(mCurrentScaleY);
3074             layout.setTranslationX(mCurrentTranslationX);
3075             layout.setTranslationY(mCurrentTranslationY);
3076             layout.setRotationY(mCurrentRotationY);
3077         }
3078     }
3079 
3080     /**
3081      * Return the current {@link CellLayout}, correctly picking the destination
3082      * screen while a scroll is in progress.
3083      */
3084     public CellLayout getCurrentDropLayout() {
3085         return (CellLayout) getChildAt(mNextPage == INVALID_PAGE ? mCurrentPage : mNextPage);
3086     }
3087 
3088     /**
3089      * Return the current CellInfo describing our current drag; this method exists
3090      * so that Launcher can sync this object with the correct info when the activity is created/
3091      * destroyed
3092      *
3093      */
3094     public CellLayout.CellInfo getDragInfo() {
3095         return mDragInfo;
3096     }
3097 
3098     /**
3099      * Calculate the nearest cell where the given object would be dropped.
3100      *
3101      * pixelX and pixelY should be in the coordinate system of layout
3102      */
<abbr title="3103     private int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle) {">3103     private int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView, Ce</abbr>
<abbr title="3104         return layout.findNearestVacantArea(pixelX, pixelY, spanX, spanY, spanX, spanY, ignoreView, recycle, null);">3104         return layout.findNearestVacantArea(pixelX, pixelY, spanX, spanY, spanX, spanY, ignoreView, recyc</abbr>
3105     }
3106 
3107     /**
3108      * Calculate the nearest cell where the given object would be dropped.
3109      *
3110      * pixelX and pixelY should be in the coordinate system of layout
3111      */
<abbr title="3112     private int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle, int[] returnSpan) {">3112     private int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, in</abbr>
<abbr title="3113         return layout.findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, recycle, returnSpan);">3113         return layout.findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView,</abbr>
3114     }
3115 
3116     /**
3117      * Calculate the nearest cell where the given object would be dropped.
3118      *
3119      * pixelX and pixelY should be in the coordinate system of layout
3120      */
3121     private int[] findNearestArea(int pixelX, int pixelY,
3122             int spanX, int spanY, CellLayout layout, int[] recycle) {
3123         return layout.findNearestArea(
3124                 pixelX, pixelY, spanX, spanY, recycle);
3125     }
3126 
3127     void setup(DragController dragController) {
3128         mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3129         mDragController = dragController;
3130 
3131         // hardware layers on children are enabled on startup, but should be disabled until
3132         // needed
3133         updateChildrenLayersEnabled();
3134         setWallpaperDimension();
3135     }
3136 
3137     /**
3138      * Called at the end of a drag which originated on the workspace.
3139      */
3140     public void onDropCompleted(View target, DragObject d, boolean success) {
3141         if (success) {
3142             if (target != this) {
3143                 if (mDragInfo != null) {
3144                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
3145                     if (mDragInfo.cell instanceof DropTarget) {
3146                         mDragController.removeDropTarget(((DropTarget) (mDragInfo.cell)));
3147                     }
3148                 }
3149             }
3150         } else if (mDragInfo != null) {
3151             // NOTE: When &#x27;success&#x27; is true, onDragExit is called by the DragController before
3152             // calling onDropCompleted(). We call it ourselves here, but maybe this should be
3153             // moved into DragController.cancelDrag().
3154             doDragExit(null);
3155             CellLayout cellLayout;
3156             if (mLauncher.isHotseatLayout(target)) {
3157                 cellLayout = mLauncher.getHotseat().getLayout();
3158             } else {
3159                 cellLayout = ((CellLayout) (getChildAt(mDragInfo.screen)));
3160             }
3161             cellLayout.onDropChild(mDragInfo.cell);
3162         }
3163         if (d.cancelled &amp;&amp; (mDragInfo.cell != null)) {
3164             mDragInfo.cell.setVisibility(VISIBLE);
3165         }
3166         mDragOutline = null;
3167         mDragInfo = null;
3168         // Hide the scrolling indicator after you pick up an item
3169         hideScrollingIndicator(false);
3170     }
3171 
3172     public boolean isDropEnabled() {
3173         return true;
3174     }
3175 
3176     @Override
3177     protected void onRestoreInstanceState(Parcelable state) {
3178         super.onRestoreInstanceState(state);
3179         Launcher.setScreen(mCurrentPage);
3180     }
3181 
3182     @Override
3183     public void scrollLeft() {
3184         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3185             super.scrollLeft();
3186         }
3187         Folder openFolder = getOpenFolder();
3188         if (openFolder != null) {
3189             openFolder.completeDragExit();
3190         }
3191     }
3192 
3193     @Override
3194     public void scrollRight() {
3195         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3196             super.scrollRight();
3197         }
3198         Folder openFolder = getOpenFolder();
3199         if (openFolder != null) {
3200             openFolder.completeDragExit();
3201         }
3202     }
3203 
3204     @Override
3205     public boolean onEnterScrollArea(int x, int y, int direction) {
3206         // Ignore the scroll area if we are dragging over the hot seat
3207         if (mLauncher.getHotseat() != null) {
3208             Rect r = new Rect();
3209             mLauncher.getHotseat().getHitRect(r);
3210             if (r.contains(x, y)) {
3211                 return false;
3212             }
3213         }
3214         boolean result = false;
3215         if ((!isSmall()) &amp;&amp; (!mIsSwitchingState)) {
3216             mInScrollArea = true;
<abbr title="3217             final int page = (mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage) + (direction == DragController.SCROLL_LEFT ? -1 : 1);">3217             final int page = (mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage) + (direction == DragC</abbr>
3218             cancelFolderCreation();
3219             if ((0 &lt;= page) &amp;&amp; (page &lt; getChildCount())) {
3220                 CellLayout layout = ((CellLayout) (getChildAt(page)));
3221                 // Exit the current layout and mark the overlapping layout
3222                 if (mDragTargetLayout != null) {
3223                     mDragTargetLayout.setIsDragOverlapping(false);
3224                     mDragTargetLayout.onDragExit();
3225                 }
3226                 mDragTargetLayout = layout;
3227                 mDragTargetLayout.setIsDragOverlapping(true);
3228                 // Workspace is responsible for drawing the edge glow on adjacent pages,
3229                 // so we need to redraw the workspace when this may have changed.
3230                 invalidate();
3231                 result = true;
3232             }
3233         }
3234         return result;
3235     }
3236 
3237     @Override
3238     public boolean onExitScrollArea() {
3239         boolean result = false;
3240         if (mInScrollArea) {
3241             if (mDragTargetLayout != null) {
3242                 mDragTargetLayout.setIsDragOverlapping(false);
3243                 // Workspace is responsible for drawing the edge glow on adjacent pages,
3244                 // so we need to redraw the workspace when this may have changed.
3245                 invalidate();
3246             }
3247             if ((mDragTargetLayout != null) &amp;&amp; mDragHasEnteredWorkspace) {
3248                 // Unmark the overlapping layout and re-enter the current layout
3249                 mDragTargetLayout = getCurrentDropLayout();
3250                 mDragTargetLayout.onDragEnter();
3251             }
3252             result = true;
3253             mInScrollArea = false;
3254         }
3255         return result;
3256     }
3257 
3258     private void onResetScrollArea() {
3259         if (mDragTargetLayout != null) {
3260             // Unmark the overlapping layout
3261             mDragTargetLayout.setIsDragOverlapping(false);
3262 
3263             // Workspace is responsible for drawing the edge glow on adjacent pages,
3264             // so we need to redraw the workspace when this may have changed.
3265             invalidate();
3266         }
3267         mInScrollArea = false;
3268     }
3269 
3270     /**
3271      * Returns a specific CellLayout
3272      */
3273     CellLayout getParentCellLayoutForView(View v) {
3274         ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
3275         for (CellLayout layout : layouts) {
3276             if (layout.getChildrenLayout().indexOfChild(v) &gt; -1) {
3277                 return layout;
3278             }
3279         }
3280         return null;
3281     }
3282 
3283     /**
3284      * Returns a list of all the CellLayouts in the workspace.
3285      */
3286     ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
3287         ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
3288         int screenCount = getChildCount();
3289         for (int screen = 0; screen &lt; screenCount; screen++) {
3290             layouts.add(((CellLayout) getChildAt(screen)));
3291         }
3292         if (mLauncher.getHotseat() != null) {
3293             layouts.add(mLauncher.getHotseat().getLayout());
3294         }
3295         return layouts;
3296     }
3297 
3298     /**
3299      * We should only use this to search for specific children.  Do not use this method to modify
3300      * CellLayoutChildren directly.
3301      */
3302     ArrayList&lt;CellLayoutChildren&gt; getWorkspaceAndHotseatCellLayoutChildren() {
3303         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = new ArrayList&lt;CellLayoutChildren&gt;();
3304         int screenCount = getChildCount();
3305         for (int screen = 0; screen &lt; screenCount; screen++) {
3306             childrenLayouts.add(((CellLayout) getChildAt(screen)).getChildrenLayout());
3307         }
3308         if (mLauncher.getHotseat() != null) {
3309             childrenLayouts.add(mLauncher.getHotseat().getLayout().getChildrenLayout());
3310         }
3311         return childrenLayouts;
3312     }
3313 
3314     public Folder getFolderForTag(Object tag) {
3315         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3316         for (CellLayoutChildren layout: childrenLayouts) {
3317             int count = layout.getChildCount();
3318             for (int i = 0; i &lt; count; i++) {
3319                 View child = layout.getChildAt(i);
3320                 if (child instanceof Folder) {
3321                     Folder f = (Folder) child;
3322                     if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
3323                         return f;
3324                     }
3325                 }
3326             }
3327         }
3328         return null;
3329     }
3330 
3331     public View getViewForTag(Object tag) {
3332         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3333         for (CellLayoutChildren layout: childrenLayouts) {
3334             int count = layout.getChildCount();
3335             for (int i = 0; i &lt; count; i++) {
3336                 View child = layout.getChildAt(i);
3337                 if (child.getTag() == tag) {
3338                     return child;
3339                 }
3340             }
3341         }
3342         return null;
3343     }
3344 
3345     void clearDropTargets() {
3346         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3347         for (CellLayoutChildren layout: childrenLayouts) {
3348             int childCount = layout.getChildCount();
3349             for (int j = 0; j &lt; childCount; j++) {
3350                 View v = layout.getChildAt(j);
3351                 if (v instanceof DropTarget) {
3352                     mDragController.removeDropTarget((DropTarget) v);
3353                 }
3354             }
3355         }
3356     }
3357 
3358     void removeItems(final ArrayList&lt;ApplicationInfo&gt; apps) {
3359         final AppWidgetManager widgets = AppWidgetManager.getInstance(getContext());
3360 
3361         final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
3362         final int appCount = apps.size();
3363         for (int i = 0; i &lt; appCount; i++) {
3364             packageNames.add(apps.get(i).componentName.getPackageName());
3365         }
3366 
3367         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
3368         for (final CellLayout layoutParent: cellLayouts) {
3369             final ViewGroup layout = layoutParent.getChildrenLayout();
3370 
3371             // Avoid ANRs by treating each screen separately
3372             post(new Runnable() {
3373                 public void run() {
3374                     final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
3375                     childrenToRemove.clear();
3376 
3377                     int childCount = layout.getChildCount();
3378                     for (int j = 0; j &lt; childCount; j++) {
3379                         final View view = layout.getChildAt(j);
3380                         Object tag = view.getTag();
3381 
3382                         if (tag instanceof ShortcutInfo) {
3383                             final ShortcutInfo info = (ShortcutInfo) tag;
3384                             final Intent intent = info.intent;
3385                             final ComponentName name = intent.getComponent();
3386 
3387                             if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3388                                 for (String packageName: packageNames) {
3389                                     if (packageName.equals(name.getPackageName())) {
3390                                         LauncherModel.deleteItemFromDatabase(mLauncher, info);
3391                                         childrenToRemove.add(view);
3392                                     }
3393                                 }
3394                             }
3395                         } else if (tag instanceof FolderInfo) {
3396                             final FolderInfo info = (FolderInfo) tag;
3397                             final ArrayList&lt;ShortcutInfo&gt; contents = info.contents;
3398                             final int contentsCount = contents.size();
3399                             final ArrayList&lt;ShortcutInfo&gt; appsToRemoveFromFolder =
3400                                     new ArrayList&lt;ShortcutInfo&gt;();
3401 
3402                             for (int k = 0; k &lt; contentsCount; k++) {
3403                                 final ShortcutInfo appInfo = contents.get(k);
3404                                 final Intent intent = appInfo.intent;
3405                                 final ComponentName name = intent.getComponent();
3406 
3407                                 if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3408                                     for (String packageName: packageNames) {
3409                                         if (packageName.equals(name.getPackageName())) {
3410                                             appsToRemoveFromFolder.add(appInfo);
3411                                         }
3412                                     }
3413                                 }
3414                             }
3415                             for (ShortcutInfo item: appsToRemoveFromFolder) {
3416                                 info.remove(item);
3417                                 LauncherModel.deleteItemFromDatabase(mLauncher, item);
3418                             }
3419                         } else if (tag instanceof LauncherAppWidgetInfo) {
3420                             final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) tag;
3421                             final AppWidgetProviderInfo provider =
3422                                     widgets.getAppWidgetInfo(info.appWidgetId);
3423                             if (provider != null) {
3424                                 for (String packageName: packageNames) {
3425                                     if (packageName.equals(provider.provider.getPackageName())) {
3426                                         LauncherModel.deleteItemFromDatabase(mLauncher, info);
3427                                         childrenToRemove.add(view);
3428                                     }
3429                                 }
3430                             }
3431                         }
3432                     }
3433 
3434                     childCount = childrenToRemove.size();
3435                     for (int j = 0; j &lt; childCount; j++) {
3436                         View child = childrenToRemove.get(j);
3437                         // Note: We can not remove the view directly from CellLayoutChildren as this
3438                         // does not re-mark the spaces as unoccupied.
3439                         layoutParent.removeViewInLayout(child);
3440                         if (child instanceof DropTarget) {
3441                             mDragController.removeDropTarget((DropTarget)child);
3442                         }
3443                     }
3444 
3445                     if (childCount &gt; 0) {
3446                         layout.requestLayout();
3447                         layout.invalidate();
3448                     }
3449                 }
3450             });
3451         }
3452     }
3453 
3454     void updateShortcuts(ArrayList&lt;ApplicationInfo&gt; apps) {
3455         ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3456         for (CellLayoutChildren layout: childrenLayouts) {
3457             int childCount = layout.getChildCount();
3458             for (int j = 0; j &lt; childCount; j++) {
3459                 final View view = layout.getChildAt(j);
3460                 Object tag = view.getTag();
3461                 if (tag instanceof ShortcutInfo) {
3462                     ShortcutInfo info = (ShortcutInfo)tag;
3463                     // We need to check for ACTION_MAIN otherwise getComponent() might
3464                     // return null for some shortcuts (for instance, for shortcuts to
3465                     // web pages.)
3466                     final Intent intent = info.intent;
3467                     final ComponentName name = intent.getComponent();
3468                     if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3469                             Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3470                         final int appCount = apps.size();
3471                         for (int k = 0; k &lt; appCount; k++) {
3472                             ApplicationInfo app = apps.get(k);
3473                             if (app.componentName.equals(name)) {
3474                                 info.setIcon(mIconCache.getIcon(info.intent));
3475                                 ((TextView)view).setCompoundDrawablesWithIntrinsicBounds(null,
3476                                         new FastBitmapDrawable(info.getIcon(mIconCache)),
3477                                         null, null);
3478                                 }
3479                         }
3480                     }
3481                 }
3482             }
3483         }
3484     }
3485 
3486     void moveToDefaultScreen(boolean animate) {
3487         if (!isSmall()) {
3488             if (animate) {
3489                 snapToPage(mDefaultPage);
3490             } else {
3491                 setCurrentPage(mDefaultPage);
3492             }
3493         }
3494         getChildAt(mDefaultPage).requestFocus();
3495     }
3496 
3497     @Override
3498     public void syncPages() {
3499     }
3500 
3501     @Override
3502     public void syncPageItems(int page, boolean immediate) {
3503     }
3504 
3505     @Override
3506     protected String getCurrentPageDescription() {
3507         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
3508         return String.format(mContext.getString(R.string.workspace_scroll_format),
3509                 page + 1, getChildCount());
3510     }
3511 
3512     public void getLocationInDragLayer(int[] loc) {
3513         mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
3514     }
3515 
3516     void setFadeForOverScroll(float fade) {
3517         if (!isScrollingIndicatorEnabled()) {
3518             return;
3519         }
3520         mOverscrollFade = fade;
3521         float reducedFade = 0.5F + (0.5F * (1 - fade));
3522         final ViewGroup parent = ((ViewGroup) (getParent()));
3523         final ImageView qsbDivider = ((ImageView) (parent.findViewById(R.id.qsb_divider)));
3524         final ImageView dockDivider = ((ImageView) (parent.findViewById(R.id.dock_divider)));
3525         final View scrollIndicator = getScrollingIndicator();
3526         cancelScrollingIndicatorAnimations();
3527         if (qsbDivider != null) {
3528             qsbDivider.setAlpha(reducedFade);
3529         }
3530         if (dockDivider != null) {
3531             dockDivider.setAlpha(reducedFade);
3532         }
3533         scrollIndicator.setAlpha(1 - fade);
3534     }
3535 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.Animator;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -import android.animation.Animator.AnimatorListener;</span>
  21  import android.animation.AnimatorListenerAdapter;
  22  import android.animation.AnimatorSet;
  23  import android.animation.ObjectAnimator;
  24  import android.animation.TimeInterpolator;
  25  import android.animation.ValueAnimator;
  26  import android.animation.ValueAnimator.AnimatorUpdateListener;
  27  import android.app.AlertDialog;
  28  import android.app.WallpaperManager;
  29  import android.appwidget.AppWidgetHostView;
  30  import android.appwidget.AppWidgetManager;
  31  import android.appwidget.AppWidgetProviderInfo;
  32  import android.content.ClipData;
  33  import android.content.ClipDescription;
  34  import android.content.ComponentName;
  35  import android.content.Context;
  36  import android.content.Intent;
  37  import android.content.res.Resources;
  38  import android.content.res.TypedArray;
  39  import android.graphics.Bitmap;
  40  import android.graphics.Camera;
  41  import android.graphics.Canvas;
  42  import android.graphics.Matrix;
  43  import android.graphics.Paint;
  44  import android.graphics.Point;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -import android.graphics.PorterDuff;</span>
  46  import android.graphics.Rect;
  47  import android.graphics.RectF;
  48  import android.graphics.Region.Op;
  49  import android.graphics.drawable.Drawable;
  50  import android.os.IBinder;
  51  import android.os.Parcelable;
  52  import android.util.AttributeSet;
  53  import android.util.DisplayMetrics;
  54  import android.util.Log;
  55  import android.util.Pair;
  56  import android.view.Display;
  57  import android.view.DragEvent;
  58  import android.view.MotionEvent;
  59  import android.view.View;
  60  import android.view.ViewConfiguration;
  61  import android.view.ViewGroup;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +import android.view.View.MeasureSpec;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import android.view.animation.AccelerateInterpolator;</span>
  64  import android.view.animation.DecelerateInterpolator;
  65  import android.widget.ImageView;
  66  import android.widget.TextView;
  67  import android.widget.Toast;
  68  
  69  import com.android.launcher.R;
  70  import com.android.launcher2.FolderIcon.FolderRingAnimator;
  71  import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  72  
  73  import java.util.ArrayList;
  74  import java.util.HashSet;
  75  import java.util.List;
  76  
  77  /**
  78   * The workspace is a wide area with a wallpaper and a finite number of pages.
  79   * Each page contains a number of icons, folders or widgets the user can
  80   * interact with. A workspace is meant to be used with a fixed width only.
  81   */
  82  public class Workspace extends SmoothPagedView
  83          implements DropTarget, DragSource, DragScroller, View.OnTouchListener,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  84 -        DragController.DragListener {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +        DragController.DragListener, LauncherTransitionable {</span>
  86      @SuppressWarnings({&quot;UnusedDeclaration&quot;})
  87      private static final String TAG = &quot;Launcher.Workspace&quot;;
  88  
  89      // Y rotation to apply to the workspace screens
  90      private static final float WORKSPACE_ROTATION = 12.5f;
  91      private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  92      private static float CAMERA_DISTANCE = 6500;
  93  
  94      private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  95      private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  96      private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  97  
  98      private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  99      private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +    private static final int FLING_THRESHOLD_VELOCITY = 500;</span>
 101  
 102      // These animators are used to fade the children&#x27;s outlines
 103      private ObjectAnimator mChildrenOutlineFadeInAnimation;
 104      private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 105      private float mChildrenOutlineAlpha = 0;
 106  
 107      // These properties refer to the background protection gradient used for AllApps and Customize
 108      private ValueAnimator mBackgroundFadeInAnimation;
 109      private ValueAnimator mBackgroundFadeOutAnimation;
 110      private Drawable mBackground;
 111      boolean mDrawBackground = true;
 112      private float mBackgroundAlpha = 0;
 113      private float mOverScrollMaxBackgroundAlpha = 0.0f;
 114      private int mOverScrollPageIndex = -1;
 115  
 116      private float mWallpaperScrollRatio = 1.0f;
 117  
 118      private final WallpaperManager mWallpaperManager;
 119      private IBinder mWindowToken;
 120      private static final float WALLPAPER_SCREENS_SPAN = 2f;
 121  
 122      private int mDefaultPage;
 123  
 124      /**
 125       * CellInfo for the cell that is currently being dragged
 126       */
 127      private CellLayout.CellInfo mDragInfo;
 128  
 129      /**
 130       * Target drop area calculated during last acceptDrop call.
 131       */
 132      private int[] mTargetCell = new int[2];
 133  
 134      /**
 135       * The CellLayout that is currently being dragged over
 136       */
 137      private CellLayout mDragTargetLayout = null;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +    private boolean mDragHasEnteredWorkspace = false;</span>
 139  
 140      private Launcher mLauncher;
 141      private IconCache mIconCache;
 142      private DragController mDragController;
 143  
 144      // These are temporary variables to prevent having to allocate a new object just to
 145      // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 146      private int[] mTempCell = new int[2];
 147      private int[] mTempEstimate = new int[2];
 148      private float[] mDragViewVisualCenter = new float[2];
 149      private float[] mTempDragCoordinates = new float[2];
 150      private float[] mTempCellLayoutCenterCoordinates = new float[2];
 151      private float[] mTempDragBottomRightCoordinates = new float[2];
 152      private Matrix mTempInverseMatrix = new Matrix();
 153  
 154      private SpringLoadedDragController mSpringLoadedDragController;
 155      private float mSpringLoadedShrinkFactor;
 156  
 157      private static final int DEFAULT_CELL_COUNT_X = 4;
 158      private static final int DEFAULT_CELL_COUNT_Y = 4;
 159  
 160      // State variable that indicates whether the pages are small (ie when you&#x27;re
 161      // in all apps or customize mode)
 162  
 163      enum State { NORMAL, SPRING_LOADED, SMALL };
 164      private State mState = State.NORMAL;
 165      private boolean mIsSwitchingState = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -    private boolean mSwitchStateAfterFirstLayout = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -    private State mStateAfterFirstLayout;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -    private AnimatorSet mAnimator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -    private AnimatorListener mChangeStateAnimationListener;</span>
 171  
 172      boolean mAnimatingViewIntoPlace = false;
 173      boolean mIsDragOccuring = false;
 174      boolean mChildrenLayersEnabled = true;
 175  
 176      /** Is the user is dragging an item near the edge of a page? */
 177      private boolean mInScrollArea = false;
 178  
 179      private final HolographicOutlineHelper mOutlineHelper = new HolographicOutlineHelper();
 180      private Bitmap mDragOutline = null;
 181      private final Rect mTempRect = new Rect();
 182      private final int[] mTempXY = new int[2];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -    private int mDragViewMultiplyColor;</span>
 184      private float mOverscrollFade = 0;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +    public static final int DRAG_BITMAP_PADDING = 0;</span>
 186  
 187      // Paint used to draw external drop outline
 188      private final Paint mExternalDragOutlinePaint = new Paint();
 189  
 190      // Camera and Matrix used to determine the final position of a neighboring CellLayout
 191      private final Matrix mMatrix = new Matrix();
 192      private final Camera mCamera = new Camera();
 193      private final float mTempFloat2[] = new float[2];
 194  
 195      enum WallpaperVerticalOffset { TOP, MIDDLE, BOTTOM };
 196      int mWallpaperWidth;
 197      int mWallpaperHeight;
 198      WallpaperOffsetInterpolator mWallpaperOffset;
 199      boolean mUpdateWallpaperOffsetImmediately = false;
 200      private Runnable mDelayedResizeRunnable;
 201      private int mDisplayWidth;
 202      private int mDisplayHeight;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +    private boolean mIsStaticWallpaper;</span>
 204      private int mWallpaperTravelWidth;
 205  
 206      // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 207      private static final int FOLDER_CREATION_TIMEOUT = 250;
 208      private final Alarm mFolderCreationAlarm = new Alarm();
 209      private FolderRingAnimator mDragFolderRingAnimator = null;
 210      private View mLastDragOverView = null;
 211      private boolean mCreateUserFolderOnDrop = false;
 212  
 213      // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 214      private float mXDown;
 215      private float mYDown;
 216      final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 217      final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 218      final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +    // Relating to the animation of items being dropped externally</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +    public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +    public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +    public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +    public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +    public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +    // Relating to workspace drag fade out</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +    private float mDragFadeOutAlpha;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +    private int mDragFadeOutDuration;</span>
 230  
 231      // These variables are used for storing the initial and final values during workspace animations
 232      private int mSavedScrollX;
 233      private float mSavedRotationY;
 234      private float mSavedTranslationX;
 235      private float mCurrentScaleX;
 236      private float mCurrentScaleY;
 237      private float mCurrentRotationY;
 238      private float mCurrentTranslationX;
 239      private float mCurrentTranslationY;
 240      private float[] mOldTranslationXs;
 241      private float[] mOldTranslationYs;
 242      private float[] mOldScaleXs;
 243      private float[] mOldScaleYs;
 244      private float[] mOldBackgroundAlphas;
 245      private float[] mOldBackgroundAlphaMultipliers;
 246      private float[] mOldAlphas;
 247      private float[] mOldRotationYs;
 248      private float[] mNewTranslationXs;
 249      private float[] mNewTranslationYs;
 250      private float[] mNewScaleXs;
 251      private float[] mNewScaleYs;
 252      private float[] mNewBackgroundAlphas;
 253      private float[] mNewBackgroundAlphaMultipliers;
 254      private float[] mNewAlphas;
 255      private float[] mNewRotationYs;
 256      private float mTransitionProgress;
 257  
 258      /**
 259       * Used to inflate the Workspace from XML.
 260       *
 261       * @param context The application&#x27;s context.
 262       * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 263       */
 264      public Workspace(Context context, AttributeSet attrs) {
 265          this(context, attrs, 0);
 266      }
 267  
 268      /**
 269       * Used to inflate the Workspace from XML.
 270       *
 271       * @param context The application&#x27;s context.
 272       * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 273       * @param defStyle Unused.
 274       */
 275      public Workspace(Context context, AttributeSet attrs, int defStyle) {
 276          super(context, attrs, defStyle);
 277          mContentIsRefreshable = false;
 278  
 279          // With workspace, data is available straight from the get-go
 280          setDataIsReady();
 281  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 282 -        mFadeInAdjacentScreens =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 283 -            getResources().getBoolean(R.bool.config_workspaceFadeAdjacentScreens);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +        final Resources res = getResources();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +        mFadeInAdjacentScreens = res.getBoolean(R.bool.config_workspaceFadeAdjacentScreens);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +        mDragFadeOutAlpha = res.getInteger(R.integer.config_dragFadeOutAlpha) / 100f;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +        mDragFadeOutDuration = res.getInteger(R.integer.config_dragFadeOutDuration);</span>
 288          mWallpaperManager = WallpaperManager.getInstance(context);
 289  
 290          int cellCountX = DEFAULT_CELL_COUNT_X;
 291          int cellCountY = DEFAULT_CELL_COUNT_Y;
 292  
 293          TypedArray a = context.obtainStyledAttributes(attrs,
 294                  R.styleable.Workspace, defStyle, 0);
 295  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 296 -        final Resources res = context.getResources();</span>
 297          if (LauncherApplication.isScreenLarge()) {
 298              // Determine number of rows/columns dynamically
 299              // TODO: This code currently fails on tablets with an aspect ratio &lt; 1.3.
 300              // Around that ratio we should make cells the same size in portrait and
 301              // landscape
 302              TypedArray actionBarSizeTypedArray =
 303                  context.obtainStyledAttributes(new int[] { android.R.attr.actionBarSize });
 304              DisplayMetrics displayMetrics = res.getDisplayMetrics();
 305              final float actionBarHeight = actionBarSizeTypedArray.getDimension(0, 0f);
 306              final float systemBarHeight = res.getDimension(R.dimen.status_bar_height);
 307              final float smallestScreenDim = res.getConfiguration().smallestScreenWidthDp *
 308                      displayMetrics.density;
 309  
 310              cellCountX = 1;
 311              while (CellLayout.widthInPortrait(res, cellCountX + 1) &lt;= smallestScreenDim) {
 312                  cellCountX++;
 313              }
 314  
 315              cellCountY = 1;
 316              while (actionBarHeight + CellLayout.heightInLandscape(res, cellCountY + 1)
 317                  &lt;= smallestScreenDim - systemBarHeight) {
 318                  cellCountY++;
 319              }
 320          }
 321  
 322          mSpringLoadedShrinkFactor =
 323              res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0f;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 324 -        mDragViewMultiplyColor = res.getColor(R.color.drag_view_multiply_color);</span>
 325  
 326          // if the value is manually specified, use that instead
 327          cellCountX = a.getInt(R.styleable.Workspace_cellCountX, cellCountX);
 328          cellCountY = a.getInt(R.styleable.Workspace_cellCountY, cellCountY);
 329          mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 330          a.recycle();
 331  
 332          LauncherModel.updateWorkspaceLayoutCells(cellCountX, cellCountY);
 333          setHapticFeedbackEnabled(false);
 334  
 335          mLauncher = (Launcher) context;
 336          initWorkspace();
 337  
 338          // Disable multitouch across the workspace/all apps/customize tray
 339          setMotionEventSplittingEnabled(true);
 340      }
 341  
 342      // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 343      // dimension if unsuccessful
 344      public int[] estimateItemSize(int hSpan, int vSpan,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 345 -            PendingAddItemInfo pendingItemInfo, boolean springLoaded) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +            ItemInfo itemInfo, boolean springLoaded) {</span>
 347          int[] size = new int[2];
 348          if (getChildCount() &gt; 0) {
 349              CellLayout cl = (CellLayout) mLauncher.getWorkspace().getChildAt(0);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 350 -            RectF r = estimateItemPosition(cl, pendingItemInfo, 0, 0, hSpan, vSpan);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 351 -            size[0] = (int) r.width();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 352 -            size[1] = (int) r.height();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 353 +            Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +            size[0] = r.width();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +            size[1] = r.height();</span>
 356              if (springLoaded) {
 357                  size[0] *= mSpringLoadedShrinkFactor;
 358                  size[1] *= mSpringLoadedShrinkFactor;
 359              }
 360              return size;
 361          } else {
 362              size[0] = Integer.MAX_VALUE;
 363              size[1] = Integer.MAX_VALUE;
 364              return size;
 365          }
 366      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 367 -    public RectF estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 368 +    public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,</span>
 369              int hCell, int vCell, int hSpan, int vSpan) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 370 -        RectF r = new RectF();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 371 +        Rect r = new Rect();</span>
 372          cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -        if (pendingInfo instanceof PendingAddWidgetInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 374 -            PendingAddWidgetInfo widgetInfo = (PendingAddWidgetInfo) pendingInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 375 -            Rect p = AppWidgetHostView.getDefaultPaddingForWidget(mContext,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 376 -                    widgetInfo.componentName, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 377 -            r.top += p.top;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 378 -            r.left += p.left;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 379 -            r.right -= p.right;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 380 -            r.bottom -= p.bottom;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -        }</span>
 382          return r;
 383      }
 384  
 385      public void buildPageHardwareLayers() {
 386          if (getWindowToken() != null) {
 387              final int childCount = getChildCount();
 388              for (int i = 0; i &lt; childCount; i++) {
 389                  CellLayout cl = (CellLayout) getChildAt(i);
 390                  cl.buildChildrenLayer();
 391              }
 392          }
 393      }
 394  
 395      public void onDragStart(DragSource source, Object info, int dragAction) {
 396          mIsDragOccuring = true;
 397          updateChildrenLayersEnabled();
 398          mLauncher.lockScreenOrientationOnLargeUI();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 399 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 400 +        // Fade out the workspace slightly to highlight the currently dragging item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 401 +        int count = getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 402 +        for (int i = 0; i &lt; count; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 403 +            CellLayout cl = (CellLayout) getPageAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 404 +            cl.getChildrenLayout().animate().alpha(mDragFadeOutAlpha)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 405 +                .setInterpolator(new AccelerateInterpolator(1.5f))</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 406 +                .setDuration(mDragFadeOutDuration)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 407 +                .start();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 408 +        }</span>
 409      }
 410  
 411      public void onDragEnd() {
 412          mIsDragOccuring = false;
 413          updateChildrenLayersEnabled();
 414          mLauncher.unlockScreenOrientationOnLargeUI();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 416 +        // Fade the workspace back in after we have completed dragging</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 417 +        int count = getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +        for (int i = 0; i &lt; count; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +            CellLayout cl = (CellLayout) getPageAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +            cl.getChildrenLayout().animate().alpha(1f)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 421 +                .setInterpolator(new DecelerateInterpolator(1.5f))</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +                .setDuration(mDragFadeOutDuration)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 423 +                .start();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 424 +        }</span>
 425      }
 426  
 427      /**
 428       * Initializes various states for this workspace.
 429       */
 430      protected void initWorkspace() {
 431          Context context = getContext();
 432          mCurrentPage = mDefaultPage;
 433          Launcher.setScreen(mCurrentPage);
 434          LauncherApplication app = (LauncherApplication)context.getApplicationContext();
 435          mIconCache = app.getIconCache();
 436          mExternalDragOutlinePaint.setAntiAlias(true);
 437          setWillNotDraw(false);
 438          setChildrenDrawnWithCacheEnabled(true);
 439  
 440          try {
 441              final Resources res = getResources();
 442              mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 443          } catch (Resources.NotFoundException e) {
 444              // In this case, we will skip drawing background protection
 445          }
 446  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 447 -        mChangeStateAnimationListener = new AnimatorListenerAdapter() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 448 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 449 -            public void onAnimationStart(Animator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -                mIsSwitchingState = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 451 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 452 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 453 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -            public void onAnimationEnd(Animator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 455 -                mIsSwitchingState = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -                mWallpaperOffset.setOverrideHorizontalCatchupConstant(false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 457 -                mAnimator = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -                updateChildrenLayersEnabled();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -        mSnapVelocity = 600;</span>
 463          mWallpaperOffset = new WallpaperOffsetInterpolator();
 464          Display display = mLauncher.getWindowManager().getDefaultDisplay();
 465          mDisplayWidth = display.getWidth();
 466          mDisplayHeight = display.getHeight();
 467          mWallpaperTravelWidth = (int) (mDisplayWidth *
 468                  wallpaperTravelToScreenWidthRatio(mDisplayWidth, mDisplayHeight));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +        mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +</span>
 472      }
 473  
 474      @Override
 475      protected int getScrollMode() {
 476          return SmoothPagedView.X_LARGE_MODE;
 477      }
 478  
 479      @Override
 480      protected void onViewAdded(View child) {
 481          super.onViewAdded(child);
 482          if (!(child instanceof CellLayout)) {
 483              throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 484          }
 485          CellLayout cl = ((CellLayout) child);
 486          cl.setOnInterceptTouchListener(this);
 487          cl.setClickable(true);
 488          cl.enableHardwareLayers();
 489      }
 490  
 491      /**
 492       * @return The open folder on the current screen, or null if there is none
 493       */
 494      Folder getOpenFolder() {
 495          DragLayer dragLayer = mLauncher.getDragLayer();
 496          int count = dragLayer.getChildCount();
 497          for (int i = 0; i &lt; count; i++) {
 498              View child = dragLayer.getChildAt(i);
 499              if (child instanceof Folder) {
 500                  Folder folder = (Folder) child;
 501                  if (folder.getInfo().opened)
 502                      return folder;
 503              }
 504          }
 505          return null;
 506      }
 507  
 508      boolean isTouchActive() {
 509          return mTouchState != TOUCH_STATE_REST;
 510      }
 511  
 512      /**
 513       * Adds the specified child in the specified screen. The position and dimension of
 514       * the child are defined by x, y, spanX and spanY.
 515       *
 516       * @param child The child to add in one of the workspace&#x27;s screens.
 517       * @param screen The screen in which to add the child.
 518       * @param x The X position of the child in the screen&#x27;s grid.
 519       * @param y The Y position of the child in the screen&#x27;s grid.
 520       * @param spanX The number of cells spanned horizontally by the child.
 521       * @param spanY The number of cells spanned vertically by the child.
 522       */
 523      void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY) {
 524          addInScreen(child, container, screen, x, y, spanX, spanY, false);
 525      }
 526  
 527      /**
 528       * Adds the specified child in the specified screen. The position and dimension of
 529       * the child are defined by x, y, spanX and spanY.
 530       *
 531       * @param child The child to add in one of the workspace&#x27;s screens.
 532       * @param screen The screen in which to add the child.
 533       * @param x The X position of the child in the screen&#x27;s grid.
 534       * @param y The Y position of the child in the screen&#x27;s grid.
 535       * @param spanX The number of cells spanned horizontally by the child.
 536       * @param spanY The number of cells spanned vertically by the child.
 537       * @param insert When true, the child is inserted at the beginning of the children list.
 538       */
 539      void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY,
 540              boolean insert) {
 541          if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 542              if (screen &lt; 0 || screen &gt;= getChildCount()) {
 543                  Log.e(TAG, &quot;The screen must be &gt;= 0 and &lt; &quot; + getChildCount()
 544                      + &quot; (was &quot; + screen + &quot;); skipping child&quot;);
 545                  return;
 546              }
 547          }
 548  
 549          final CellLayout layout;
 550          if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 551              layout = mLauncher.getHotseat().getLayout();
 552              child.setOnKeyListener(null);
 553  
 554              // Hide folder title in the hotseat
 555              if (child instanceof FolderIcon) {
 556                  ((FolderIcon) child).setTextVisible(false);
 557              }
 558  
 559              if (screen &lt; 0) {
 560                  screen = mLauncher.getHotseat().getOrderInHotseat(x, y);
 561              } else {
 562                  // Note: We do this to ensure that the hotseat is always laid out in the orientation
 563                  // of the hotseat in order regardless of which orientation they were added
 564                  x = mLauncher.getHotseat().getCellXFromOrder(screen);
 565                  y = mLauncher.getHotseat().getCellYFromOrder(screen);
 566              }
 567          } else {
 568              // Show folder title if not in the hotseat
 569              if (child instanceof FolderIcon) {
 570                  ((FolderIcon) child).setTextVisible(true);
 571              }
 572  
 573              layout = (CellLayout) getChildAt(screen);
 574              child.setOnKeyListener(new IconKeyEventListener());
 575          }
 576  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -        CellLayout.LayoutParams lp = (CellLayout.LayoutParams) child.getLayoutParams();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -        if (lp == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +        LayoutParams genericLp = child.getLayoutParams();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +        CellLayout.LayoutParams lp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +        if (genericLp == null || !(genericLp instanceof CellLayout.LayoutParams)) {</span>
 582              lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 583          } else {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 584 +            lp = (CellLayout.LayoutParams) genericLp;</span>
 585              lp.cellX = x;
 586              lp.cellY = y;
 587              lp.cellHSpan = spanX;
 588              lp.cellVSpan = spanY;
 589          }
 590  
 591          if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) {
 592              lp.isLockedToGrid = false;
 593          }
 594  
 595          // Get the canonical child id to uniquely represent this view in this screen
 596          int childId = LauncherModel.getCellLayoutChildId(container, screen, x, y, spanX, spanY);
 597          boolean markCellsAsOccupied = !(child instanceof Folder);
 598          if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 599              // TODO: This branch occurs when the workspace is adding views
 600              // outside of the defined grid
 601              // maybe we should be deleting these items from the LauncherModel?
 602              Log.w(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;);
 603          }
 604  
 605          if (!(child instanceof Folder)) {
 606              child.setHapticFeedbackEnabled(false);
 607              child.setOnLongClickListener(mLongClickListener);
 608          }
 609          if (child instanceof DropTarget) {
 610              mDragController.addDropTarget((DropTarget) child);
 611          }
 612      }
 613  
 614      /**
 615       * Check if the point (x, y) hits a given page.
 616       */
 617      private boolean hitsPage(int index, float x, float y) {
 618          final View page = getChildAt(index);
 619          if (page != null) {
 620              float[] localXY = { x, y };
 621              mapPointFromSelfToChild(page, localXY);
 622              return (localXY[0] &gt;= 0 &amp;&amp; localXY[0] &lt; page.getWidth()
 623                      &amp;&amp; localXY[1] &gt;= 0 &amp;&amp; localXY[1] &lt; page.getHeight());
 624          }
 625          return false;
 626      }
 627  
 628      @Override
 629      protected boolean hitsPreviousPage(float x, float y) {
 630          // mNextPage is set to INVALID_PAGE whenever we are stationary.
 631          // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 632          final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 633  
 634          // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 635          // the active workspace
 636          return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current - 1, x, y);
 637      }
 638  
 639      @Override
 640      protected boolean hitsNextPage(float x, float y) {
 641          // mNextPage is set to INVALID_PAGE whenever we are stationary.
 642          // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 643          final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 644  
 645          // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 646          // the active workspace
 647          return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current + 1, x, y);
 648      }
 649  
 650      /**
 651       * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 652       * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 653       * that it should intercept touch events, which is not something that is normally supported.
 654       */
 655      @Override
 656      public boolean onTouch(View v, MotionEvent event) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -        return (isSmall() || mIsSwitchingState);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +        return (isSmall() || !isFinishedSwitchingState());</span>
 659      }
 660  
 661      public boolean isSwitchingState() {
 662          return mIsSwitchingState;
 663      }
 664  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +    /** This differs from isSwitchingState in that we take into account how far the transition</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +     *  has completed. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +    public boolean isFinishedSwitchingState() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +        return !mIsSwitchingState || (mTransitionProgress &gt; 0.5f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +</span>
 671      protected void onWindowVisibilityChanged (int visibility) {
 672          mLauncher.onWindowVisibilityChanged(visibility);
 673      }
 674  
 675      @Override
 676      public boolean dispatchUnhandledMove(View focused, int direction) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -        if (isSmall() || mIsSwitchingState) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 678 +        if (isSmall() || !isFinishedSwitchingState()) {</span>
 679              // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
 680              return false;
 681          }
 682          return super.dispatchUnhandledMove(focused, direction);
 683      }
 684  
 685      @Override
 686      public boolean onInterceptTouchEvent(MotionEvent ev) {
 687          switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
 688          case MotionEvent.ACTION_DOWN:
 689              mXDown = ev.getX();
 690              mYDown = ev.getY();
 691              break;
 692          case MotionEvent.ACTION_POINTER_UP:
 693          case MotionEvent.ACTION_UP:
 694              if (mTouchState == TOUCH_STATE_REST) {
 695                  final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
 696                  if (!currentPage.lastDownOnOccupiedCell()) {
 697                      onWallpaperTap(ev);
 698                  }
 699              }
 700          }
 701          return super.onInterceptTouchEvent(ev);
 702      }
 703  
 704      @Override
 705      protected void determineScrollingStart(MotionEvent ev) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 706 -        if (!isSmall() &amp;&amp; !mIsSwitchingState) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 707 -            float deltaX = Math.abs(ev.getX() - mXDown);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 708 -            float deltaY = Math.abs(ev.getY() - mYDown);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 709 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 710 -            if (Float.compare(deltaX, 0f) == 0) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 711 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 712 -            float slope = deltaY / deltaX;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 713 -            float theta = (float) Math.atan(slope);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 714 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 715 -            if (deltaX &gt; mTouchSlop || deltaY &gt; mTouchSlop) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 716 -                cancelCurrentPageLongPress();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 717 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 718 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 719 -            if (theta &gt; MAX_SWIPE_ANGLE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 720 -                // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 721 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 722 -            } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 723 -                // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 724 -                // increase the touch slop to make it harder to begin scrolling the workspace. This</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 725 -                // results in vertically scrolling widgets to more easily. The higher the angle, the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 726 -                // more we increase touch slop.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 727 -                theta -= START_DAMPING_TOUCH_SLOP_ANGLE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 728 -                float extraRatio = (float)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 729 -                        Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 730 -                super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 731 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 732 -                // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 733 -                super.determineScrollingStart(ev);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 734 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 735 +        if (isSmall()) return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 736 +        if (!isFinishedSwitchingState()) return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 737 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 738 +        float deltaX = Math.abs(ev.getX() - mXDown);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 739 +        float deltaY = Math.abs(ev.getY() - mYDown);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 740 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 741 +        if (Float.compare(deltaX, 0f) == 0) return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 742 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 743 +        float slope = deltaY / deltaX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 744 +        float theta = (float) Math.atan(slope);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 745 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 746 +        if (deltaX &gt; mTouchSlop || deltaY &gt; mTouchSlop) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 747 +            cancelCurrentPageLongPress();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 748 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 749 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 750 +        if (theta &gt; MAX_SWIPE_ANGLE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 751 +            // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 752 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 753 +        } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 754 +            // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 755 +            // increase the touch slop to make it harder to begin scrolling the workspace. This</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 756 +            // results in vertically scrolling widgets to more easily. The higher the angle, the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 757 +            // more we increase touch slop.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 758 +            theta -= START_DAMPING_TOUCH_SLOP_ANGLE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 759 +            float extraRatio = (float)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 760 +                    Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 761 +            super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 762 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 763 +            // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 764 +            super.determineScrollingStart(ev);</span>
 765          }
 766      }
 767  
 768      @Override
 769      protected boolean isScrollingIndicatorEnabled() {
 770          return mState != State.SPRING_LOADED;
 771      }
 772  
 773      protected void onPageBeginMoving() {
 774          super.onPageBeginMoving();
 775  
 776          if (isHardwareAccelerated()) {
 777              updateChildrenLayersEnabled();
 778          } else {
 779              if (mNextPage != INVALID_PAGE) {
 780                  // we&#x27;re snapping to a particular screen
 781                  enableChildrenCache(mCurrentPage, mNextPage);
 782              } else {
 783                  // this is when user is actively dragging a particular screen, they might
 784                  // swipe it either left or right (but we won&#x27;t advance by more than one screen)
 785                  enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
 786              }
 787          }
 788  
 789          // Only show page outlines as we pan if we are on large screen
 790          if (LauncherApplication.isScreenLarge()) {
 791              showOutlines();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 792 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 793 +            mIsStaticWallpaper = mWallpaperManager.getWallpaperInfo() == null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 794 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 795 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 796 +        // If we are not fading in adjacent screens, we still need to restore the alpha in case the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 797 +        // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 798 +        if (!mFadeInAdjacentScreens) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 799 +            for (int i = 0; i &lt; getChildCount(); ++i) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 800 +                getPageAt(i).setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 801 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 802 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 803 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 804 +        // Show the scroll indicator as you pan the page</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 805 +        showScrollingIndicator(false);</span>
 806      }
 807  
 808      protected void onPageEndMoving() {
 809          super.onPageEndMoving();
 810  
 811          if (isHardwareAccelerated()) {
 812              updateChildrenLayersEnabled();
 813          } else {
 814              clearChildrenCache();
 815          }
 816  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 817 -        // Hide the outlines, as long as we&#x27;re not dragging</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 818 -        if (!mDragController.dragging()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 819 -            // Only hide page outlines as we pan if we are on large screen</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 820 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 821 +        if (mDragController.isDragging()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 822 +            if (isSmall()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 823 +                // If we are in springloaded mode, then force an event to check if the current touch</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 824 +                // is under a new page (to scroll to)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 825 +                mDragController.forceMoveEvent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 826 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 827 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 828 +            // If we are not mid-dragging, hide the page outlines if we are on a large screen</span>
 829              if (LauncherApplication.isScreenLarge()) {
 830                  hideOutlines();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 831 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 832 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 833 +            // Hide the scroll indicator as you pan the page</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 834 +            if (!mDragController.isDragging()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 835 +                hideScrollingIndicator(false);</span>
 836              }
 837          }
 838          mOverScrollMaxBackgroundAlpha = 0.0f;
 839          mOverScrollPageIndex = -1;
 840  
 841          if (mDelayedResizeRunnable != null) {
 842              mDelayedResizeRunnable.run();
 843              mDelayedResizeRunnable = null;
 844          }
 845      }
 846  
 847      @Override
 848      protected void notifyPageSwitchListener() {
 849          super.notifyPageSwitchListener();
 850          Launcher.setScreen(mCurrentPage);
 851      };
 852  
 853      // As a ratio of screen height, the total distance we want the parallax effect to span
 854      // horizontally
 855      private float wallpaperTravelToScreenWidthRatio(int width, int height) {
 856          float aspectRatio = width / (float) height;
 857  
 858          // At an aspect ratio of 16/10, the wallpaper parallax effect should span 1.5 * screen width
 859          // At an aspect ratio of 10/16, the wallpaper parallax effect should span 1.2 * screen width
 860          // We will use these two data points to extrapolate how much the wallpaper parallax effect
 861          // to span (ie travel) at any aspect ratio:
 862  
 863          final float ASPECT_RATIO_LANDSCAPE = 16/10f;
 864          final float ASPECT_RATIO_PORTRAIT = 10/16f;
 865          final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE = 1.5f;
 866          final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT = 1.2f;
 867  
 868          // To find out the desired width at different aspect ratios, we use the following two
 869          // formulas, where the coefficient on x is the aspect ratio (width/height):
 870          //   (16/10)x + y = 1.5
 871          //   (10/16)x + y = 1.2
 872          // We solve for x and y and end up with a final formula:
 873          final float x =
 874              (WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE - WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT) /
 875              (ASPECT_RATIO_LANDSCAPE - ASPECT_RATIO_PORTRAIT);
 876          final float y = WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT - x * ASPECT_RATIO_PORTRAIT;
 877          return x * aspectRatio + y;
 878      }
 879  
 880      // The range of scroll values for Workspace
 881      private int getScrollRange() {
 882          return getChildOffset(getChildCount() - 1) - getChildOffset(0);
 883      }
 884  
 885      protected void setWallpaperDimension() {
 886          DisplayMetrics displayMetrics = new DisplayMetrics();
 887          mLauncher.getWindowManager().getDefaultDisplay().getRealMetrics(displayMetrics);
 888          final int maxDim = Math.max(displayMetrics.widthPixels, displayMetrics.heightPixels);
 889          final int minDim = Math.min(displayMetrics.widthPixels, displayMetrics.heightPixels);
 890  
 891          // We need to ensure that there is enough extra space in the wallpaper for the intended
 892          // parallax effects
 893          if (LauncherApplication.isScreenLarge()) {
 894              mWallpaperWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
 895              mWallpaperHeight = maxDim;
 896          } else {
 897              mWallpaperWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
 898              mWallpaperHeight = maxDim;
 899          }
 900          new Thread(&quot;setWallpaperDimension&quot;) {
 901              public void run() {
 902                  mWallpaperManager.suggestDesiredDimensions(mWallpaperWidth, mWallpaperHeight);
 903              }
 904          }.start();
 905      }
 906  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 907 -    public void setVerticalWallpaperOffset(float offset) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 908 -        mWallpaperOffset.setFinalY(offset);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 909 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 910 -    public float getVerticalWallpaperOffset() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 911 -        return mWallpaperOffset.getCurrY();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 912 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 913 -    public void setHorizontalWallpaperOffset(float offset) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 914 -        mWallpaperOffset.setFinalX(offset);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 915 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 916 -    public float getHorizontalWallpaperOffset() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 917 -        return mWallpaperOffset.getCurrX();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 918 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 919 -</span>
 920      private float wallpaperOffsetForCurrentScroll() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 921 -        // The wallpaper travel width is how far, from left to right, the wallpaper will move</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 922 -        // at this orientation. On tablets in portrait mode we don&#x27;t move all the way to the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 923 -        // edges of the wallpaper, or otherwise the parallax effect would be too strong.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 924 -        int wallpaperTravelWidth = mWallpaperWidth;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 925 -        if (LauncherApplication.isScreenLarge()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 926 -            wallpaperTravelWidth = mWallpaperTravelWidth;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 927 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 928 -</span>
 929          // Set wallpaper offset steps (1 / (number of screens - 1))
 930          mWallpaperManager.setWallpaperOffsetSteps(1.0f / (getChildCount() - 1), 1.0f);
 931  
 932          // For the purposes of computing the scrollRange and overScrollOffset, we assume
 933          // that mLayoutScale is 1. This means that when we&#x27;re in spring-loaded mode,
 934          // there&#x27;s no discrepancy between the wallpaper offset for a given page.
 935          float layoutScale = mLayoutScale;
 936          mLayoutScale = 1f;
 937          int scrollRange = getScrollRange();
 938  
 939          // Again, we adjust the wallpaper offset to be consistent between values of mLayoutScale
 940          float adjustedScrollX = Math.max(0, Math.min(mScrollX, mMaxScrollX));
 941          adjustedScrollX *= mWallpaperScrollRatio;
 942          mLayoutScale = layoutScale;
 943  
 944          float scrollProgress =
 945              adjustedScrollX / (float) scrollRange;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 946 -        float offsetInDips = wallpaperTravelWidth * scrollProgress +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 947 -            (mWallpaperWidth - wallpaperTravelWidth) / 2; // center it</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 948 -        float offset = offsetInDips / (float) mWallpaperWidth;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 949 -        return offset;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 950 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 952 +        if (LauncherApplication.isScreenLarge() &amp;&amp; mIsStaticWallpaper) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 953 +            // The wallpaper travel width is how far, from left to right, the wallpaper will move</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 954 +            // at this orientation. On tablets in portrait mode we don&#x27;t move all the way to the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 955 +            // edges of the wallpaper, or otherwise the parallax effect would be too strong.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 956 +            int wallpaperTravelWidth = Math.min(mWallpaperTravelWidth, mWallpaperWidth);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 957 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 958 +            float offsetInDips = wallpaperTravelWidth * scrollProgress +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 959 +                (mWallpaperWidth - wallpaperTravelWidth) / 2; // center it</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 960 +            float offset = offsetInDips / (float) mWallpaperWidth;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 961 +            return offset;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 963 +            return scrollProgress;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 964 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 965 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 966 +</span>
 967      private void syncWallpaperOffsetWithScroll() {
 968          final boolean enableWallpaperEffects = isHardwareAccelerated();
 969          if (enableWallpaperEffects) {
 970              mWallpaperOffset.setFinalX(wallpaperOffsetForCurrentScroll());
 971          }
 972      }
 973  
 974      public void updateWallpaperOffsetImmediately() {
 975          mUpdateWallpaperOffsetImmediately = true;
 976      }
 977  
 978      private void updateWallpaperOffsets() {
 979          boolean updateNow = false;
 980          boolean keepUpdating = true;
 981          if (mUpdateWallpaperOffsetImmediately) {
 982              updateNow = true;
 983              keepUpdating = false;
 984              mWallpaperOffset.jumpToFinal();
 985              mUpdateWallpaperOffsetImmediately = false;
 986          } else {
 987              updateNow = keepUpdating = mWallpaperOffset.computeScrollOffset();
 988          }
 989          if (updateNow) {
 990              if (mWindowToken != null) {
 991                  mWallpaperManager.setWallpaperOffsets(mWindowToken,
 992                          mWallpaperOffset.getCurrX(), mWallpaperOffset.getCurrY());
 993              }
 994          }
 995          if (keepUpdating) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 996 -            fastInvalidate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 997 +            invalidate();</span>
 998          }
 999      }
1000  
1001      @Override
1002      protected void updateCurrentPageScroll() {
1003          super.updateCurrentPageScroll();
1004          computeWallpaperScrollRatio(mCurrentPage);
1005      }
1006  
1007      @Override
1008      protected void snapToPage(int whichPage) {
1009          super.snapToPage(whichPage);
1010          computeWallpaperScrollRatio(whichPage);
1011      }
1012  
1013      private void computeWallpaperScrollRatio(int page) {
1014          // Here, we determine what the desired scroll would be with and without a layout scale,
1015          // and compute a ratio between the two. This allows us to adjust the wallpaper offset
1016          // as though there is no layout scale.
1017          float layoutScale = mLayoutScale;
1018          int scaled = getChildOffset(page) - getRelativeChildOffset(page);
1019          mLayoutScale = 1.0f;
1020          float unscaled = getChildOffset(page) - getRelativeChildOffset(page);
1021          mLayoutScale = layoutScale;
1022          if (scaled &gt; 0) {
1023              mWallpaperScrollRatio = (1.0f * unscaled) / scaled;
1024          } else {
1025              mWallpaperScrollRatio = 1f;
1026          }
1027      }
1028  
1029      class WallpaperOffsetInterpolator {
1030          float mFinalHorizontalWallpaperOffset = 0.0f;
1031          float mFinalVerticalWallpaperOffset = 0.5f;
1032          float mHorizontalWallpaperOffset = 0.0f;
1033          float mVerticalWallpaperOffset = 0.5f;
1034          long mLastWallpaperOffsetUpdateTime;
1035          boolean mIsMovingFast;
1036          boolean mOverrideHorizontalCatchupConstant;
1037          float mHorizontalCatchupConstant = 0.35f;
1038          float mVerticalCatchupConstant = 0.35f;
1039  
1040          public WallpaperOffsetInterpolator() {
1041          }
1042  
1043          public void setOverrideHorizontalCatchupConstant(boolean override) {
1044              mOverrideHorizontalCatchupConstant = override;
1045          }
1046  
1047          public void setHorizontalCatchupConstant(float f) {
1048              mHorizontalCatchupConstant = f;
1049          }
1050  
1051          public void setVerticalCatchupConstant(float f) {
1052              mVerticalCatchupConstant = f;
1053          }
1054  
1055          public boolean computeScrollOffset() {
1056              if (Float.compare(mHorizontalWallpaperOffset, mFinalHorizontalWallpaperOffset) == 0 &amp;&amp;
1057                      Float.compare(mVerticalWallpaperOffset, mFinalVerticalWallpaperOffset) == 0) {
1058                  mIsMovingFast = false;
1059                  return false;
1060              }
1061              boolean isLandscape = mDisplayWidth &gt; mDisplayHeight;
1062  
1063              long currentTime = System.currentTimeMillis();
1064              long timeSinceLastUpdate = currentTime - mLastWallpaperOffsetUpdateTime;
1065              timeSinceLastUpdate = Math.min((long) (1000/30f), timeSinceLastUpdate);
1066              timeSinceLastUpdate = Math.max(1L, timeSinceLastUpdate);
1067  
1068              float xdiff = Math.abs(mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset);
1069              if (!mIsMovingFast &amp;&amp; xdiff &gt; 0.07) {
1070                  mIsMovingFast = true;
1071              }
1072  
1073              float fractionToCatchUpIn1MsHorizontal;
1074              if (mOverrideHorizontalCatchupConstant) {
1075                  fractionToCatchUpIn1MsHorizontal = mHorizontalCatchupConstant;
1076              } else if (mIsMovingFast) {
1077                  fractionToCatchUpIn1MsHorizontal = isLandscape ? 0.5f : 0.75f;
1078              } else {
1079                  // slow
1080                  fractionToCatchUpIn1MsHorizontal = isLandscape ? 0.27f : 0.5f;
1081              }
1082              float fractionToCatchUpIn1MsVertical = mVerticalCatchupConstant;
1083  
1084              fractionToCatchUpIn1MsHorizontal /= 33f;
1085              fractionToCatchUpIn1MsVertical /= 33f;
1086  
1087              final float UPDATE_THRESHOLD = 0.00001f;
1088              float hOffsetDelta = mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset;
1089              float vOffsetDelta = mFinalVerticalWallpaperOffset - mVerticalWallpaperOffset;
1090              boolean jumpToFinalValue = Math.abs(hOffsetDelta) &lt; UPDATE_THRESHOLD &amp;&amp;
1091                  Math.abs(vOffsetDelta) &lt; UPDATE_THRESHOLD;
1092  
1093              // Don&#x27;t have any lag between workspace and wallpaper on non-large devices
1094              if (!LauncherApplication.isScreenLarge() || jumpToFinalValue) {
1095                  mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
1096                  mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
1097              } else {
1098                  float percentToCatchUpVertical =
1099                      Math.min(1.0f, timeSinceLastUpdate * fractionToCatchUpIn1MsVertical);
1100                  float percentToCatchUpHorizontal =
1101                      Math.min(1.0f, timeSinceLastUpdate * fractionToCatchUpIn1MsHorizontal);
1102                  mHorizontalWallpaperOffset += percentToCatchUpHorizontal * hOffsetDelta;
1103                  mVerticalWallpaperOffset += percentToCatchUpVertical * vOffsetDelta;
1104              }
1105  
1106              mLastWallpaperOffsetUpdateTime = System.currentTimeMillis();
1107              return true;
1108          }
1109  
1110          public float getCurrX() {
1111              return mHorizontalWallpaperOffset;
1112          }
1113  
1114          public float getFinalX() {
1115              return mFinalHorizontalWallpaperOffset;
1116          }
1117  
1118          public float getCurrY() {
1119              return mVerticalWallpaperOffset;
1120          }
1121  
1122          public float getFinalY() {
1123              return mFinalVerticalWallpaperOffset;
1124          }
1125  
1126          public void setFinalX(float x) {
1127              mFinalHorizontalWallpaperOffset = Math.max(0f, Math.min(x, 1.0f));
1128          }
1129  
1130          public void setFinalY(float y) {
1131              mFinalVerticalWallpaperOffset = Math.max(0f, Math.min(y, 1.0f));
1132          }
1133  
1134          public void jumpToFinal() {
1135              mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
1136              mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
1137          }
1138      }
1139  
1140      @Override
1141      public void computeScroll() {
1142          super.computeScroll();
1143          syncWallpaperOffsetWithScroll();
1144      }
1145  
1146      void showOutlines() {
1147          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1148              if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1149              if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1150              mChildrenOutlineFadeInAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);
1151              mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1152              mChildrenOutlineFadeInAnimation.start();
1153          }
1154      }
1155  
1156      void hideOutlines() {
1157          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1158              if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1159              if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1160              mChildrenOutlineFadeOutAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);
1161              mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1162              mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1163              mChildrenOutlineFadeOutAnimation.start();
1164          }
1165      }
1166  
1167      public void showOutlinesTemporarily() {
1168          if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1169              snapToPage(mCurrentPage);
1170          }
1171      }
1172  
1173      public void setChildrenOutlineAlpha(float alpha) {
1174          mChildrenOutlineAlpha = alpha;
1175          for (int i = 0; i &lt; getChildCount(); i++) {
1176              CellLayout cl = (CellLayout) getChildAt(i);
1177              cl.setBackgroundAlpha(alpha);
1178          }
1179      }
1180  
1181      public float getChildrenOutlineAlpha() {
1182          return mChildrenOutlineAlpha;
1183      }
1184  
1185      void disableBackground() {
1186          mDrawBackground = false;
1187      }
1188      void enableBackground() {
1189          mDrawBackground = true;
1190      }
1191  
1192      private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1193          if (mBackground == null) return;
1194          if (mBackgroundFadeInAnimation != null) {
1195              mBackgroundFadeInAnimation.cancel();
1196              mBackgroundFadeInAnimation = null;
1197          }
1198          if (mBackgroundFadeOutAnimation != null) {
1199              mBackgroundFadeOutAnimation.cancel();
1200              mBackgroundFadeOutAnimation = null;
1201          }
1202          float startAlpha = getBackgroundAlpha();
1203          if (finalAlpha != startAlpha) {
1204              if (animated) {
1205                  mBackgroundFadeOutAnimation = ValueAnimator.ofFloat(startAlpha, finalAlpha);
1206                  mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1207                      public void onAnimationUpdate(ValueAnimator animation) {
1208                          setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1209                      }
1210                  });
1211                  mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1212                  mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1213                  mBackgroundFadeOutAnimation.start();
1214              } else {
1215                  setBackgroundAlpha(finalAlpha);
1216              }
1217          }
1218      }
1219  
1220      public void setBackgroundAlpha(float alpha) {
1221          if (alpha != mBackgroundAlpha) {
1222              mBackgroundAlpha = alpha;
1223              invalidate();
1224          }
1225      }
1226  
1227      public float getBackgroundAlpha() {
1228          return mBackgroundAlpha;
1229      }
1230  
1231      /**
1232       * Due to 3D transformations, if two CellLayouts are theoretically touching each other,
1233       * on the xy plane, when one is rotated along the y-axis, the gap between them is perceived
1234       * as being larger. This method computes what offset the rotated view should be translated
1235       * in order to minimize this perceived gap.
1236       * @param degrees Angle of the view
1237       * @param width Width of the view
1238       * @param height Height of the view
1239       * @return Offset to be used in a View.setTranslationX() call
1240       */
1241      private float getOffsetXForRotation(float degrees, int width, int height) {
1242          mMatrix.reset();
1243          mCamera.save();
1244          mCamera.rotateY(Math.abs(degrees));
1245          mCamera.getMatrix(mMatrix);
1246          mCamera.restore();
1247  
1248          mMatrix.preTranslate(-width * 0.5f, -height * 0.5f);
1249          mMatrix.postTranslate(width * 0.5f, height * 0.5f);
1250          mTempFloat2[0] = width;
1251          mTempFloat2[1] = height;
1252          mMatrix.mapPoints(mTempFloat2);
1253          return (width - mTempFloat2[0]) * (degrees &gt; 0.0f ? 1.0f : -1.0f);
1254      }
1255  
1256      float backgroundAlphaInterpolator(float r) {
1257          float pivotA = 0.1f;
1258          float pivotB = 0.4f;
1259          if (r &lt; pivotA) {
1260              return 0;
1261          } else if (r &gt; pivotB) {
1262              return 1.0f;
1263          } else {
1264              return (r - pivotA)/(pivotB - pivotA);
1265          }
1266      }
1267  
1268      float overScrollBackgroundAlphaInterpolator(float r) {
1269          float threshold = 0.08f;
1270  
1271          if (r &gt; mOverScrollMaxBackgroundAlpha) {
1272              mOverScrollMaxBackgroundAlpha = r;
1273          } else if (r &lt; mOverScrollMaxBackgroundAlpha) {
1274              r = mOverScrollMaxBackgroundAlpha;
1275          }
1276  
1277          return Math.min(r / threshold, 1.0f);
1278      }
1279  
1280      private void screenScrolledLargeUI(int screenCenter) {
1281          if (isSwitchingState()) return;
1282          boolean isInOverscroll = false;
1283          for (int i = 0; i &lt; getChildCount(); i++) {
1284              CellLayout cl = (CellLayout) getChildAt(i);
1285              if (cl != null) {
1286                  float scrollProgress = getScrollProgress(screenCenter, cl, i);
1287                  float rotation = WORKSPACE_ROTATION * scrollProgress;
1288                  float translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1289  
1290                  // If the current page (i) is being over scrolled, we use a different
1291                  // set of rules for setting the background alpha multiplier.
1292                  if (!isSmall()) {
1293                      if ((mOverScrollX &lt; 0 &amp;&amp; i == 0) || (mOverScrollX &gt; mMaxScrollX &amp;&amp;
1294                              i == getChildCount() -1)) {
1295                          isInOverscroll = true;
1296                          rotation *= -1;
1297                          cl.setBackgroundAlphaMultiplier(
1298                                  overScrollBackgroundAlphaInterpolator(Math.abs(scrollProgress)));
1299                          mOverScrollPageIndex = i;
1300                          cl.setOverScrollAmount(Math.abs(scrollProgress), i == 0);
1301                          cl.setPivotX(cl.getMeasuredWidth() * (i == 0 ? 0.75f : 0.25f));
1302                          cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1303                          cl.setOverscrollTransformsDirty(true);
1304                      } else if (mOverScrollPageIndex != i) {
1305                          cl.setBackgroundAlphaMultiplier(
1306                                  backgroundAlphaInterpolator(Math.abs(scrollProgress)));
1307                      }
1308                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1309 -                cl.setFastTranslationX(translationX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1310 -                cl.setFastRotationY(rotation);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1311 +                cl.setTranslationX(translationX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1312 +                cl.setRotationY(rotation);</span>
1313                  if (mFadeInAdjacentScreens &amp;&amp; !isSmall()) {
1314                      float alpha = 1 - Math.abs(scrollProgress);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1315 -                    cl.setFastAlpha(alpha);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1316 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1317 -                cl.fastInvalidate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1318 +                    cl.setAlpha(alpha);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1319 +                }</span>
1320              }
1321          }
1322          if (!isSwitchingState() &amp;&amp; !isInOverscroll) {
1323              ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1324              ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1325          }
1326          invalidate();
1327      }
1328  
1329      private void screenScrolledStandardUI(int screenCenter) {
1330          if (mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX) {
1331              int index = mOverScrollX &lt; 0 ? 0 : getChildCount() - 1;
1332              CellLayout cl = (CellLayout) getChildAt(index);
1333              float scrollProgress = getScrollProgress(screenCenter, cl, index);
1334              cl.setOverScrollAmount(Math.abs(scrollProgress), index == 0);
1335              float rotation = - WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1336              cl.setCameraDistance(mDensity * CAMERA_DISTANCE);
1337              cl.setPivotX(cl.getMeasuredWidth() * (index == 0 ? 0.75f : 0.25f));
1338              cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1339              cl.setRotationY(rotation);
1340              cl.setOverscrollTransformsDirty(true);
1341              setFadeForOverScroll(Math.abs(scrollProgress));
1342          } else {
1343              if (mOverscrollFade != 0) {
1344                  setFadeForOverScroll(0);
1345              }
1346              // We don&#x27;t want to mess with the translations during transitions
1347              if (!isSwitchingState()) {
1348                  ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1349                  ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1350              }
1351          }
1352      }
1353  
1354      @Override
1355      protected void screenScrolled(int screenCenter) {
1356          if (LauncherApplication.isScreenLarge()) {
1357              // We don&#x27;t call super.screenScrolled() here because we handle the adjacent pages alpha
1358              // ourselves (for efficiency), and there are no scrolling indicators to update.
1359              screenScrolledLargeUI(screenCenter);
1360          } else {
1361              super.screenScrolled(screenCenter);
1362              screenScrolledStandardUI(screenCenter);
1363          }
1364      }
1365  
1366      @Override
1367      protected void overScroll(float amount) {
1368          if (LauncherApplication.isScreenLarge()) {
1369              dampedOverScroll(amount);
1370          } else {
1371              acceleratedOverScroll(amount);
1372          }
1373      }
1374  
1375      protected void onAttachedToWindow() {
1376          super.onAttachedToWindow();
1377          mWindowToken = getWindowToken();
1378          computeScroll();
1379          mDragController.setWindowToken(mWindowToken);
1380      }
1381  
1382      protected void onDetachedFromWindow() {
1383          mWindowToken = null;
1384      }
1385  
1386      @Override
1387      protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1388          if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1389              mUpdateWallpaperOffsetImmediately = true;
1390          }
1391          super.onLayout(changed, left, top, right, bottom);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1392 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1393 -        // if shrinkToBottom() is called on initialization, it has to be deferred</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1394 -        // until after the first call to onLayout so that it has the correct width</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1395 -        if (mSwitchStateAfterFirstLayout) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1396 -            mSwitchStateAfterFirstLayout = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1397 -            // shrink can trigger a synchronous onLayout call, so we</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1398 -            // post this to avoid a stack overflow / tangled onLayout calls</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1399 -            post(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1400 -                public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1401 -                    changeState(mStateAfterFirstLayout, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1402 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1403 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1404 -        }</span>
1405      }
1406  
1407      @Override
1408      protected void onDraw(Canvas canvas) {
1409          updateWallpaperOffsets();
1410  
1411          // Draw the background gradient if necessary
1412          if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1413              int alpha = (int) (mBackgroundAlpha * 255);
1414              mBackground.setAlpha(alpha);
1415              mBackground.setBounds(mScrollX, 0, mScrollX + getMeasuredWidth(),
1416                      getMeasuredHeight());
1417              mBackground.draw(canvas);
1418          }
1419  
1420          super.onDraw(canvas);
1421      }
1422  
1423      boolean isDrawingBackgroundGradient() {
1424          return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1425      }
1426  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1427 -    public void scrollTo (int x, int y) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1428 -        super.scrollTo(x, y);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1429 -        syncChildrenLayersEnabledOnVisiblePages();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1430 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1431 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1432 -    // This method just applies the value mChildrenLayersEnabled to all the pages that</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1433 -    // will be rendered on the next frame.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1434 -    // We do this because calling setChildrenLayersEnabled on a view that&#x27;s not</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1435 -    // visible/rendered causes slowdowns on some graphics cards</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1436 -    private void syncChildrenLayersEnabledOnVisiblePages() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1437 -        if (mChildrenLayersEnabled) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1438 -            getVisiblePages(mTempVisiblePagesRange);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1439 -            final int leftScreen = mTempVisiblePagesRange[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1440 -            final int rightScreen = mTempVisiblePagesRange[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1441 -            if (leftScreen != -1 &amp;&amp; rightScreen != -1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1442 -                for (int i = leftScreen; i &lt;= rightScreen; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1443 -                    ViewGroup page = (ViewGroup) getPageAt(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1444 -                    if (page.getVisibility() == VISIBLE &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1445 -                            page.getAlpha() &gt; ViewConfiguration.ALPHA_THRESHOLD) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1446 -                        ((ViewGroup)getPageAt(i)).setChildrenLayersEnabled(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1447 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1448 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1449 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1450 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1451 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1452 -</span>
1453      @Override
1454      protected void dispatchDraw(Canvas canvas) {
1455          super.dispatchDraw(canvas);
1456  
1457          if (mInScrollArea &amp;&amp; !LauncherApplication.isScreenLarge()) {
1458              final int width = getWidth();
1459              final int height = getHeight();
1460              final int pageHeight = getChildAt(0).getHeight();
1461  
1462              // Set the height of the outline to be the height of the page
1463              final int offset = (height - pageHeight - mPaddingTop - mPaddingBottom) / 2;
1464              final int paddingTop = mPaddingTop + offset;
1465              final int paddingBottom = mPaddingBottom + offset;
1466  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1467 -            final CellLayout leftPage = (CellLayout) getChildAt(mCurrentPage - 1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1468 -            final CellLayout rightPage = (CellLayout) getChildAt(mCurrentPage + 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1469 +            final int page = (mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1470 +            final CellLayout leftPage = (CellLayout) getChildAt(page - 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1471 +            final CellLayout rightPage = (CellLayout) getChildAt(page + 1);</span>
1472  
1473              if (leftPage != null &amp;&amp; leftPage.getIsDragOverlapping()) {
1474                  final Drawable d = getResources().getDrawable(R.drawable.page_hover_left_holo);
1475                  d.setBounds(mScrollX, paddingTop, mScrollX + d.getIntrinsicWidth(),
1476                          height - paddingBottom);
1477                  d.draw(canvas);
1478              } else if (rightPage != null &amp;&amp; rightPage.getIsDragOverlapping()) {
1479                  final Drawable d = getResources().getDrawable(R.drawable.page_hover_right_holo);
1480                  d.setBounds(mScrollX + width - d.getIntrinsicWidth(), paddingTop, mScrollX + width,
1481                          height - paddingBottom);
1482                  d.draw(canvas);
1483              }
1484          }
1485      }
1486  
1487      @Override
1488      protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1489          if (!mLauncher.isAllAppsVisible()) {
1490              final Folder openFolder = getOpenFolder();
1491              if (openFolder != null) {
1492                  return openFolder.requestFocus(direction, previouslyFocusedRect);
1493              } else {
1494                  return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1495              }
1496          }
1497          return false;
1498      }
1499  
1500      @Override
1501      public int getDescendantFocusability() {
1502          if (isSmall()) {
1503              return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1504          }
1505          return super.getDescendantFocusability();
1506      }
1507  
1508      @Override
1509      public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1510          if (!mLauncher.isAllAppsVisible()) {
1511              final Folder openFolder = getOpenFolder();
1512              if (openFolder != null) {
1513                  openFolder.addFocusables(views, direction);
1514              } else {
1515                  super.addFocusables(views, direction, focusableMode);
1516              }
1517          }
1518      }
1519  
1520      public boolean isSmall() {
1521          return mState == State.SMALL || mState == State.SPRING_LOADED;
1522      }
1523  
1524      void enableChildrenCache(int fromPage, int toPage) {
1525          if (fromPage &gt; toPage) {
1526              final int temp = fromPage;
1527              fromPage = toPage;
1528              toPage = temp;
1529          }
1530  
1531          final int screenCount = getChildCount();
1532  
1533          fromPage = Math.max(fromPage, 0);
1534          toPage = Math.min(toPage, screenCount - 1);
1535  
1536          for (int i = fromPage; i &lt;= toPage; i++) {
1537              final CellLayout layout = (CellLayout) getChildAt(i);
1538              layout.setChildrenDrawnWithCacheEnabled(true);
1539              layout.setChildrenDrawingCacheEnabled(true);
1540          }
1541      }
1542  
1543      void clearChildrenCache() {
1544          final int screenCount = getChildCount();
1545          for (int i = 0; i &lt; screenCount; i++) {
1546              final CellLayout layout = (CellLayout) getChildAt(i);
1547              layout.setChildrenDrawnWithCacheEnabled(false);
1548              // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1549              if (!isHardwareAccelerated()) {
1550                  layout.setChildrenDrawingCacheEnabled(false);
1551              }
1552          }
1553      }
1554  
1555      private void updateChildrenLayersEnabled() {
1556          boolean small = isSmall() || mIsSwitchingState;
1557          boolean dragging = mAnimatingViewIntoPlace || mIsDragOccuring;
1558          boolean enableChildrenLayers = small || dragging || isPageMoving();
1559  
1560          if (enableChildrenLayers != mChildrenLayersEnabled) {
1561              mChildrenLayersEnabled = enableChildrenLayers;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1562 -            // calling setChildrenLayersEnabled on a view that&#x27;s not visible/rendered</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1563 -            // causes slowdowns on some graphics cards, so we only disable it here and leave</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1564 -            // the enabling to dispatchDraw</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1565 -            if (!enableChildrenLayers) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1566 -                for (int i = 0; i &lt; getPageCount(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1567 -                    ((ViewGroup)getChildAt(i)).setChildrenLayersEnabled(false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1568 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1569 +            for (int i = 0; i &lt; getPageCount(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1570 +                ((ViewGroup)getChildAt(i)).setChildrenLayersEnabled(mChildrenLayersEnabled);</span>
1571              }
1572          }
1573      }
1574  
1575      protected void onWallpaperTap(MotionEvent ev) {
1576          final int[] position = mTempCell;
1577          getLocationOnScreen(position);
1578  
1579          int pointerIndex = ev.getActionIndex();
1580          position[0] += (int) ev.getX(pointerIndex);
1581          position[1] += (int) ev.getY(pointerIndex);
1582  
1583          mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1584                  ev.getAction() == MotionEvent.ACTION_UP
1585                          ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1586                  position[0], position[1], 0, null);
1587      }
1588  
1589      /*
1590       * This interpolator emulates the rate at which the perceived scale of an object changes
1591       * as its distance from a camera increases. When this interpolator is applied to a scale
1592       * animation on a view, it evokes the sense that the object is shrinking due to moving away
1593       * from the camera.
1594       */
1595      static class ZInterpolator implements TimeInterpolator {
1596          private float focalLength;
1597  
1598          public ZInterpolator(float foc) {
1599              focalLength = foc;
1600          }
1601  
1602          public float getInterpolation(float input) {
1603              return (1.0f - focalLength / (focalLength + input)) /
1604                  (1.0f - focalLength / (focalLength + 1.0f));
1605          }
1606      }
1607  
1608      /*
1609       * The exact reverse of ZInterpolator.
1610       */
1611      static class InverseZInterpolator implements TimeInterpolator {
1612          private ZInterpolator zInterpolator;
1613          public InverseZInterpolator(float foc) {
1614              zInterpolator = new ZInterpolator(foc);
1615          }
1616          public float getInterpolation(float input) {
1617              return 1 - zInterpolator.getInterpolation(1 - input);
1618          }
1619      }
1620  
1621      /*
1622       * ZInterpolator compounded with an ease-out.
1623       */
1624      static class ZoomOutInterpolator implements TimeInterpolator {
1625          private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75f);
1626          private final ZInterpolator zInterpolator = new ZInterpolator(0.13f);
1627  
1628          public float getInterpolation(float input) {
1629              return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1630          }
1631      }
1632  
1633      /*
1634       * InvereZInterpolator compounded with an ease-out.
1635       */
1636      static class ZoomInInterpolator implements TimeInterpolator {
1637          private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35f);
1638          private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0f);
1639  
1640          public float getInterpolation(float input) {
1641              return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1642          }
1643      }
1644  
1645      private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1646  
1647      /*
1648      *
1649      * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1650      * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1651      *
1652      * These methods mark the appropriate pages as accepting drops (which alters their visual
1653      * appearance).
1654      *
1655      */
1656      public void onDragStartedWithItem(View v) {
1657          final Canvas canvas = new Canvas();
1658  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1659 -        // We need to add extra padding to the bitmap to make room for the glow effect</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1660 -        final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1661 -</span>
1662          // The outline is used to visualize where the item will land if dropped
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1663 -        mDragOutline = createDragOutline(v, canvas, bitmapPadding);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1664 +        mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);</span>
1665      }
1666  
1667      public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, Paint alphaClipPaint) {
1668          final Canvas canvas = new Canvas();
1669  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1670 -        // We need to add extra padding to the bitmap to make room for the glow effect</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1671 -        final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1672 -</span>
1673          int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1674  
1675          // The outline is used to visualize where the item will land if dropped
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1676 -        mDragOutline = createDragOutline(b, canvas, bitmapPadding, size[0], size[1], alphaClipPaint);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1677 +        mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0],</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1678 +                size[1], alphaClipPaint);</span>
1679      }
1680  
1681      // we call this method whenever a drag and drop in Launcher finishes, even if Workspace was
1682      // never dragged over
1683      public void onDragStopped(boolean success) {
1684          // In the success case, DragController has already called onDragExit()
1685          if (!success) {
1686              doDragExit(null);
1687          }
1688      }
1689  
1690      public void exitWidgetResizeMode() {
1691          DragLayer dragLayer = mLauncher.getDragLayer();
1692          dragLayer.clearAllResizeFrames();
1693      }
1694  
1695      private void initAnimationArrays() {
1696          final int childCount = getChildCount();
1697          if (mOldTranslationXs != null) return;
1698          mOldTranslationXs = new float[childCount];
1699          mOldTranslationYs = new float[childCount];
1700          mOldScaleXs = new float[childCount];
1701          mOldScaleYs = new float[childCount];
1702          mOldBackgroundAlphas = new float[childCount];
1703          mOldBackgroundAlphaMultipliers = new float[childCount];
1704          mOldAlphas = new float[childCount];
1705          mOldRotationYs = new float[childCount];
1706          mNewTranslationXs = new float[childCount];
1707          mNewTranslationYs = new float[childCount];
1708          mNewScaleXs = new float[childCount];
1709          mNewScaleYs = new float[childCount];
1710          mNewBackgroundAlphas = new float[childCount];
1711          mNewBackgroundAlphaMultipliers = new float[childCount];
1712          mNewAlphas = new float[childCount];
1713          mNewRotationYs = new float[childCount];
1714      }
1715  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1716 -    public void changeState(State shrinkState) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1717 -        changeState(shrinkState, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1718 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1719 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1720 -    void changeState(final State state, boolean animated) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1721 -        changeState(state, animated, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1722 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1723 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1724 -    void changeState(final State state, boolean animated, int delay) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1725 +    Animator getChangeStateAnimation(final State state, boolean animated) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1726 +        return getChangeStateAnimation(state, animated, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1727 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1728 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1729 +    Animator getChangeStateAnimation(final State state, boolean animated, int delay) {</span>
1730          if (mState == state) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1731 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1732 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1733 -        if (mFirstLayout) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1734 -            // (mFirstLayout == &quot;first layout has not happened yet&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1735 -            // cancel any pending shrinks that were set earlier</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1736 -            mSwitchStateAfterFirstLayout = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1737 -            mStateAfterFirstLayout = state;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1738 -            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1739 +            return null;</span>
1740          }
1741  
1742          // Initialize animation arrays for the first time if necessary
1743          initAnimationArrays();
1744  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1745 -        // Cancel any running transition animations</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1746 -        if (mAnimator != null) mAnimator.cancel();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1747 -        mAnimator = new AnimatorSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1748 +        AnimatorSet anim = animated ? new AnimatorSet() : null;</span>
1749  
1750          // Stop any scrolling, move to the current page right away
1751          setCurrentPage((mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage);
1752  
1753          final State oldState = mState;
1754          final boolean oldStateIsNormal = (oldState == State.NORMAL);
1755          final boolean oldStateIsSmall = (oldState == State.SMALL);
1756          mState = state;
1757          final boolean stateIsNormal = (state == State.NORMAL);
1758          final boolean stateIsSpringLoaded = (state == State.SPRING_LOADED);
1759          final boolean stateIsSmall = (state == State.SMALL);
1760          float finalScaleFactor = 1.0f;
1761          float finalBackgroundAlpha = stateIsSpringLoaded ? 1.0f : 0f;
1762          float translationX = 0;
1763          float translationY = 0;
1764          boolean zoomIn = true;
1765  
1766          if (state != State.NORMAL) {
1767              finalScaleFactor = mSpringLoadedShrinkFactor - (stateIsSmall ? 0.1f : 0);
1768              if (oldStateIsNormal &amp;&amp; stateIsSmall) {
1769                  zoomIn = false;
1770                  setLayoutScale(finalScaleFactor);
1771                  updateChildrenLayersEnabled();
1772              } else {
1773                  finalBackgroundAlpha = 1.0f;
1774                  setLayoutScale(finalScaleFactor);
1775              }
1776          } else {
1777              setLayoutScale(1.0f);
1778          }
1779  
1780          final int duration = zoomIn ?
1781                  getResources().getInteger(R.integer.config_workspaceUnshrinkTime) :
1782                  getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
1783          for (int i = 0; i &lt; getChildCount(); i++) {
1784              final CellLayout cl = (CellLayout) getChildAt(i);
1785              float rotation = 0f;
1786              float initialAlpha = cl.getAlpha();
1787              float finalAlphaMultiplierValue = 1f;
1788              float finalAlpha = (!mFadeInAdjacentScreens || stateIsSpringLoaded ||
1789                      (i == mCurrentPage)) ? 1f : 0f;
1790  
1791              // Determine the pages alpha during the state transition
1792              if ((oldStateIsSmall &amp;&amp; stateIsNormal) ||
1793                  (oldStateIsNormal &amp;&amp; stateIsSmall)) {
1794                  // To/from workspace - only show the current page unless the transition is not
1795                  //                     animated and the animation end callback below doesn&#x27;t run
1796                  if (i == mCurrentPage || !animated) {
1797                      finalAlpha = 1f;
1798                      finalAlphaMultiplierValue = 0f;
1799                  } else {
1800                      initialAlpha = 0f;
1801                      finalAlpha = 0f;
1802                  }
1803              }
1804  
1805              // Update the rotation of the screen (don&#x27;t apply rotation on Phone UI)
1806              if (LauncherApplication.isScreenLarge()) {
1807                  if (i &lt; mCurrentPage) {
1808                      rotation = WORKSPACE_ROTATION;
1809                  } else if (i &gt; mCurrentPage) {
1810                      rotation = -WORKSPACE_ROTATION;
1811                  }
1812              }
1813  
1814              // If the screen is not xlarge, then don&#x27;t rotate the CellLayouts
1815              // NOTE: If we don&#x27;t update the side pages alpha, then we should not hide the side
1816              //       pages. see unshrink().
1817              if (LauncherApplication.isScreenLarge()) {
1818                  translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1819              }
1820  
1821              mOldAlphas[i] = initialAlpha;
1822              mNewAlphas[i] = finalAlpha;
1823              if (animated) {
1824                  mOldTranslationXs[i] = cl.getTranslationX();
1825                  mOldTranslationYs[i] = cl.getTranslationY();
1826                  mOldScaleXs[i] = cl.getScaleX();
1827                  mOldScaleYs[i] = cl.getScaleY();
1828                  mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
1829                  mOldBackgroundAlphaMultipliers[i] = cl.getBackgroundAlphaMultiplier();
1830                  mOldRotationYs[i] = cl.getRotationY();
1831  
1832                  mNewTranslationXs[i] = translationX;
1833                  mNewTranslationYs[i] = translationY;
1834                  mNewScaleXs[i] = finalScaleFactor;
1835                  mNewScaleYs[i] = finalScaleFactor;
1836                  mNewBackgroundAlphas[i] = finalBackgroundAlpha;
1837                  mNewBackgroundAlphaMultipliers[i] = finalAlphaMultiplierValue;
1838                  mNewRotationYs[i] = rotation;
1839              } else {
1840                  cl.setTranslationX(translationX);
1841                  cl.setTranslationY(translationY);
1842                  cl.setScaleX(finalScaleFactor);
1843                  cl.setScaleY(finalScaleFactor);
1844                  cl.setBackgroundAlpha(finalBackgroundAlpha);
1845                  cl.setBackgroundAlphaMultiplier(finalAlphaMultiplierValue);
1846                  cl.setAlpha(finalAlpha);
1847                  cl.setRotationY(rotation);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1848 -                mChangeStateAnimationListener.onAnimationEnd(null);</span>
1849              }
1850          }
1851  
1852          if (animated) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1853 -            ValueAnimator animWithInterpolator =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1854 -                ValueAnimator.ofFloat(0f, 1f).setDuration(duration);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1855 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1856 -            if (zoomIn) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1857 -                animWithInterpolator.setInterpolator(mZoomInInterpolator);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1858 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1859 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1860 -            animWithInterpolator.addListener(new AnimatorListenerAdapter() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1861 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1862 -                public void onAnimationEnd(android.animation.Animator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1863 -                    // The above code to determine initialAlpha and finalAlpha will ensure that only</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1864 -                    // the current page is visible during (and subsequently, after) the transition</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1865 -                    // animation.  If fade adjacent pages is disabled, then re-enable the page</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1866 -                    // visibility after the transition animation.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1867 -                    if (!mFadeInAdjacentScreens &amp;&amp; stateIsNormal &amp;&amp; oldStateIsSmall) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1868 -                        for (int i = 0; i &lt; getChildCount(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1869 -                            final CellLayout cl = (CellLayout) getChildAt(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1870 -                            cl.setAlpha(1f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1871 -                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1872 +            for (int index = 0; index &lt; getChildCount(); index++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1873 +                final int i = index;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1874 +                final CellLayout cl = (CellLayout) getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1875 +                if (mOldAlphas[i] == 0 &amp;&amp; mNewAlphas[i] == 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1876 +                    cl.setTranslationX(mNewTranslationXs[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1877 +                    cl.setTranslationY(mNewTranslationYs[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1878 +                    cl.setScaleX(mNewScaleXs[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1879 +                    cl.setScaleY(mNewScaleYs[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1880 +                    cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1881 +                    cl.setBackgroundAlphaMultiplier(mNewBackgroundAlphaMultipliers[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1882 +                    cl.setAlpha(mNewAlphas[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1883 +                    cl.setRotationY(mNewRotationYs[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1884 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1885 +                    LauncherViewPropertyAnimator a = new LauncherViewPropertyAnimator(cl);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1886 +                    a.translationX(mNewTranslationXs[i])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1887 +                        .translationY(mNewTranslationYs[i])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1888 +                        .scaleX(mNewScaleXs[i])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1889 +                        .scaleY(mNewScaleYs[i])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1890 +                        .setDuration(duration)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1891 +                        .setInterpolator(mZoomInInterpolator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1892 +                    if (mOldAlphas[i] != mNewAlphas[i]) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1893 +                        a.alpha(mNewAlphas[i]);</span>
1894                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1895 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1896 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1897 -            animWithInterpolator.addUpdateListener(new LauncherAnimatorUpdateListener() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1898 -                public void onAnimationUpdate(float a, float b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1899 -                    mTransitionProgress = b;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1900 -                    if (b == 0f) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1901 -                        // an optimization, but not required</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1902 -                        return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1903 +                    anim.play(a);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1904 +                    if (mOldRotationYs[i] != 0 || mNewRotationYs[i] != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1905 +                        ValueAnimator rotate = ValueAnimator.ofFloat(0f, 1f).setDuration(duration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1906 +                        rotate.setInterpolator(new DecelerateInterpolator(2.0f));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1907 +                        rotate.addUpdateListener(new LauncherAnimatorUpdateListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1908 +                                public void onAnimationUpdate(float a, float b) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1909 +                                    cl.setRotationY(a * mOldRotationYs[i] + b * mNewRotationYs[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1910 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1911 +                            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1912 +                        anim.play(rotate);</span>
1913                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1914 -                    invalidate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1915 -                    for (int i = 0; i &lt; getChildCount(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1916 -                        final CellLayout cl = (CellLayout) getChildAt(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1917 -                        cl.invalidate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1918 -                        cl.setFastTranslationX(a * mOldTranslationXs[i] + b * mNewTranslationXs[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1919 -                        cl.setFastTranslationY(a * mOldTranslationYs[i] + b * mNewTranslationYs[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1920 -                        cl.setFastScaleX(a * mOldScaleXs[i] + b * mNewScaleXs[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1921 -                        cl.setFastScaleY(a * mOldScaleYs[i] + b * mNewScaleYs[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1922 -                        cl.setFastBackgroundAlpha(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1923 -                                a * mOldBackgroundAlphas[i] + b * mNewBackgroundAlphas[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1924 -                        cl.setBackgroundAlphaMultiplier(a * mOldBackgroundAlphaMultipliers[i] +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1925 -                                b * mNewBackgroundAlphaMultipliers[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1926 -                        cl.setFastAlpha(a * mOldAlphas[i] + b * mNewAlphas[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1927 -                        cl.invalidate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1928 +                    if (mOldBackgroundAlphas[i] != 0 ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1929 +                        mNewBackgroundAlphas[i] != 0 ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1930 +                        mOldBackgroundAlphaMultipliers[i] != 0 ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1931 +                        mNewBackgroundAlphaMultipliers[i] != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1932 +                        ValueAnimator bgAnim = ValueAnimator.ofFloat(0f, 1f).setDuration(duration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1933 +                        bgAnim.setInterpolator(mZoomInInterpolator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1934 +                        bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1935 +                                public void onAnimationUpdate(float a, float b) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1936 +                                    cl.setBackgroundAlpha(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1937 +                                            a * mOldBackgroundAlphas[i] +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1938 +                                            b * mNewBackgroundAlphas[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1939 +                                    cl.setBackgroundAlphaMultiplier(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1940 +                                            a * mOldBackgroundAlphaMultipliers[i] +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1941 +                                            b * mNewBackgroundAlphaMultipliers[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1942 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1943 +                            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1944 +                        anim.play(bgAnim);</span>
1945                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1946 -                    syncChildrenLayersEnabledOnVisiblePages();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1947 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1948 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1949 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1950 -            ValueAnimator rotationAnim =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1951 -                ValueAnimator.ofFloat(0f, 1f).setDuration(duration);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1952 -            rotationAnim.setInterpolator(new DecelerateInterpolator(2.0f));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1953 -            rotationAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1954 -                public void onAnimationUpdate(float a, float b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1955 -                    if (b == 0f) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1956 -                        // an optimization, but not required</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1957 -                        return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1958 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1959 -                    for (int i = 0; i &lt; getChildCount(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1960 -                        final CellLayout cl = (CellLayout) getChildAt(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1961 -                        cl.setFastRotationY(a * mOldRotationYs[i] + b * mNewRotationYs[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1962 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1963 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1964 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1965 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1966 -            mAnimator.playTogether(animWithInterpolator, rotationAnim);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1967 -            mAnimator.setStartDelay(delay);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1968 -            // If we call this when we&#x27;re not animated, onAnimationEnd is never called on</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1969 -            // the listener; make sure we only use the listener when we&#x27;re actually animating</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1970 -            mAnimator.addListener(mChangeStateAnimationListener);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1971 -            mAnimator.start();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1972 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1973 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1974 +            anim.setStartDelay(delay);</span>
1975          }
1976  
1977          if (stateIsSpringLoaded) {
1978              // Right now we&#x27;re covered by Apps Customize
1979              // Show the background gradient immediately, so the gradient will
1980              // be showing once AppsCustomize disappears
1981              animateBackgroundGradient(getResources().getInteger(
1982                      R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, false);
1983          } else {
1984              // Fade the background gradient away
1985              animateBackgroundGradient(0f, true);
1986          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1987 -        syncChildrenLayersEnabledOnVisiblePages();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1988 +        return anim;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1989 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1990 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1991 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1992 +    public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1993 +        mIsSwitchingState = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1994 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1995 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1996 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1997 +    public void onLauncherTransitionStep(Launcher l, float t) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1998 +        mTransitionProgress = t;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1999 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2000 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2001 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2002 +    public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2003 +        mIsSwitchingState = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2004 +        mWallpaperOffset.setOverrideHorizontalCatchupConstant(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2005 +        updateChildrenLayersEnabled();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2006 +        // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2007 +        // ensure that only the current page is visible during (and subsequently, after) the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2008 +        // transition animation.  If fade adjacent pages is disabled, then re-enable the page</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2009 +        // visibility after the transition animation.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2010 +        if (!mFadeInAdjacentScreens) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2011 +            for (int i = 0; i &lt; getChildCount(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2012 +                final CellLayout cl = (CellLayout) getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2013 +                cl.setAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2014 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2015 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2016 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2017 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2018 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2019 +    public View getContent() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2020 +        return this;</span>
2021      }
2022  
2023      /**
2024       * Draw the View v into the given Canvas.
2025       *
2026       * @param v the view to draw
2027       * @param destCanvas the canvas to draw on
2028       * @param padding the horizontal and vertical padding to use when drawing
2029       */
2030      private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
2031          final Rect clipRect = mTempRect;
2032          v.getDrawingRect(clipRect);
2033  
2034          boolean textVisible = false;
2035  
2036          destCanvas.save();
2037          if (v instanceof TextView &amp;&amp; pruneToDrawable) {
2038              Drawable d = ((TextView) v).getCompoundDrawables()[1];
2039              clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
2040              destCanvas.translate(padding / 2, padding / 2);
2041              d.draw(destCanvas);
2042          } else {
2043              if (v instanceof FolderIcon) {
2044                  // For FolderIcons the text can bleed into the icon area, and so we need to
2045                  // hide the text completely (which can&#x27;t be achieved by clipping).
2046                  if (((FolderIcon) v).getTextVisible()) {
2047                      ((FolderIcon) v).setTextVisible(false);
2048                      textVisible = true;
2049                  }
2050              } else if (v instanceof BubbleTextView) {
2051                  final BubbleTextView tv = (BubbleTextView) v;
2052                  clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
2053                          tv.getLayout().getLineTop(0);
2054              } else if (v instanceof TextView) {
2055                  final TextView tv = (TextView) v;
2056                  clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
2057                          tv.getLayout().getLineTop(0);
2058              }
2059              destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
2060              destCanvas.clipRect(clipRect, Op.REPLACE);
2061              v.draw(destCanvas);
2062  
2063              // Restore text visibility of FolderIcon if necessary
2064              if (textVisible) {
2065                  ((FolderIcon) v).setTextVisible(true);
2066              }
2067          }
2068          destCanvas.restore();
2069      }
2070  
2071      /**
2072       * Returns a new bitmap to show when the given View is being dragged around.
2073       * Responsibility for the bitmap is transferred to the caller.
2074       */
2075      public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
2076          final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
2077          Bitmap b;
2078  
2079          if (v instanceof TextView) {
2080              Drawable d = ((TextView) v).getCompoundDrawables()[1];
2081              b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
2082                      d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
2083          } else {
2084              b = Bitmap.createBitmap(
2085                      v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2086          }
2087  
2088          canvas.setBitmap(b);
2089          drawDragView(v, canvas, padding, true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2090 -        mOutlineHelper.applyOuterBlur(b, canvas, outlineColor);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2091 -        canvas.drawColor(mDragViewMultiplyColor, PorterDuff.Mode.MULTIPLY);</span>
2092          canvas.setBitmap(null);
2093  
2094          return b;
2095      }
2096  
2097      /**
2098       * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2099       * Responsibility for the bitmap is transferred to the caller.
2100       */
2101      private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
2102          final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
2103          final Bitmap b = Bitmap.createBitmap(
2104                  v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2105  
2106          canvas.setBitmap(b);
2107          drawDragView(v, canvas, padding, true);
2108          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
2109          canvas.setBitmap(null);
2110          return b;
2111      }
2112  
2113      /**
2114       * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2115       * Responsibility for the bitmap is transferred to the caller.
2116       */
2117      private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
2118              Paint alphaClipPaint) {
2119          final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
2120          final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
2121          canvas.setBitmap(b);
2122  
2123          Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
2124          float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
2125                  (h - padding) / (float) orig.getHeight());
2126          int scaledWidth = (int) (scaleFactor * orig.getWidth());
2127          int scaledHeight = (int) (scaleFactor * orig.getHeight());
2128          Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
2129  
2130          // center the image
2131          dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
2132  
2133          canvas.drawBitmap(orig, src, dst, null);
2134          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
2135                  alphaClipPaint);
2136          canvas.setBitmap(null);
2137  
2138          return b;
2139      }
2140  
2141      /**
2142       * Creates a drag outline to represent a drop (that we don&#x27;t have the actual information for
2143       * yet).  May be changed in the future to alter the drop outline slightly depending on the
2144       * clip description mime data.
2145       */
2146      private Bitmap createExternalDragOutline(Canvas canvas, int padding) {
2147          Resources r = getResources();
2148          final int outlineColor = r.getColor(android.R.color.holo_blue_light);
2149          final int iconWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
2150          final int iconHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
2151          final int rectRadius = r.getDimensionPixelSize(R.dimen.external_drop_icon_rect_radius);
2152          final int inset = (int) (Math.min(iconWidth, iconHeight) * 0.2f);
2153          final Bitmap b = Bitmap.createBitmap(
2154                  iconWidth + padding, iconHeight + padding, Bitmap.Config.ARGB_8888);
2155  
2156          canvas.setBitmap(b);
2157          canvas.drawRoundRect(new RectF(inset, inset, iconWidth - inset, iconHeight - inset),
2158                  rectRadius, rectRadius, mExternalDragOutlinePaint);
2159          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
2160          canvas.setBitmap(null);
2161          return b;
2162      }
2163  
2164      void startDrag(CellLayout.CellInfo cellInfo) {
2165          View child = cellInfo.cell;
2166  
2167          // Make sure the drag was started by a long press as opposed to a long click.
2168          if (!child.isInTouchMode()) {
2169              return;
2170          }
2171  
2172          mDragInfo = cellInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2173 -        child.setVisibility(GONE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2174 +        child.setVisibility(INVISIBLE);</span>
2175  
2176          child.clearFocus();
2177          child.setPressed(false);
2178  
2179          final Canvas canvas = new Canvas();
2180  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2181 -        // We need to add extra padding to the bitmap to make room for the glow effect</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2182 -        final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2183 -</span>
2184          // The outline is used to visualize where the item will land if dropped
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2185 -        mDragOutline = createDragOutline(child, canvas, bitmapPadding);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2186 +        mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);</span>
2187          beginDragShared(child, this);
2188      }
2189  
2190      public void beginDragShared(View child, DragSource source) {
2191          Resources r = getResources();
2192  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2193 -        // We need to add extra padding to the bitmap to make room for the glow effect</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2194 -        final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2195 -</span>
2196          // The drag bitmap follows the touch point around on the screen
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2197 -        final Bitmap b = createDragBitmap(child, new Canvas(), bitmapPadding);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2198 +        final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);</span>
2199  
2200          final int bmpWidth = b.getWidth();
2201  
2202          mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
2203          final int dragLayerX = (int) mTempXY[0] + (child.getWidth() - bmpWidth) / 2;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2204 -        int dragLayerY = mTempXY[1] - bitmapPadding / 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2205 +        int dragLayerY = mTempXY[1] - DRAG_BITMAP_PADDING / 2;</span>
2206  
2207          Point dragVisualizeOffset = null;
2208          Rect dragRect = null;
2209          if (child instanceof BubbleTextView || child instanceof PagedViewIcon) {
2210              int iconSize = r.getDimensionPixelSize(R.dimen.app_icon_size);
2211              int iconPaddingTop = r.getDimensionPixelSize(R.dimen.app_icon_padding_top);
2212              int top = child.getPaddingTop();
2213              int left = (bmpWidth - iconSize) / 2;
2214              int right = left + iconSize;
2215              int bottom = top + iconSize;
2216              dragLayerY += top;
2217              // Note: The drag region is used to calculate drag layer offsets, but the
2218              // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2219 -            dragVisualizeOffset = new Point(-bitmapPadding / 2, iconPaddingTop - bitmapPadding / 2);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2220 +            dragVisualizeOffset = new Point(-DRAG_BITMAP_PADDING / 2,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2221 +                    iconPaddingTop - DRAG_BITMAP_PADDING / 2);</span>
2222              dragRect = new Rect(left, top, right, bottom);
2223          } else if (child instanceof FolderIcon) {
2224              int previewSize = r.getDimensionPixelSize(R.dimen.folder_preview_size);
2225              dragRect = new Rect(0, 0, child.getWidth(), previewSize);
2226          }
2227  
2228          // Clear the pressed state if necessary
2229          if (child instanceof BubbleTextView) {
2230              BubbleTextView icon = (BubbleTextView) child;
2231              icon.clearPressedOrFocusedBackground();
2232          }
2233  
2234          mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2235 -                DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2236 +                DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, 1f);</span>
2237          b.recycle();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2238 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2239 +        // Show the scrolling indicator when you pick up an item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2240 +        showScrollingIndicator(false);</span>
2241      }
2242  
2243      void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, int screen,
2244              int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
2245          View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
2246  
2247          final int[] cellXY = new int[2];
2248          target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
2249          addInScreen(view, container, screen, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
2250          LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen, cellXY[0],
2251                  cellXY[1]);
2252      }
2253  
2254      public boolean transitionStateShouldAllowDrop() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2255 -        return (!isSwitchingState() || mTransitionProgress &gt; 0.5f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2256 +        return ((!isSwitchingState() || mTransitionProgress &gt; 0.5f) &amp;&amp; mState != State.SMALL);</span>
2257      }
2258  
2259      /**
2260       * {@inheritDoc}
2261       */
2262      public boolean acceptDrop(DragObject d) {
2263          // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
2264          if (d.dragSource != this) {
2265              // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
2266              if (mDragTargetLayout == null) {
2267                  return false;
2268              }
2269              if (!transitionStateShouldAllowDrop()) return false;
2270  
2271              mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2272                      d.dragView, mDragViewVisualCenter);
2273  
2274              // We want the point to be mapped to the dragTarget.
2275              if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2276                  mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2277              } else {
2278                  mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2279              }
2280  
2281              int spanX = 1;
2282              int spanY = 1;
2283              View ignoreView = null;
2284              if (mDragInfo != null) {
2285                  final CellLayout.CellInfo dragCellInfo = mDragInfo;
2286                  spanX = dragCellInfo.spanX;
2287                  spanY = dragCellInfo.spanY;
2288                  ignoreView = dragCellInfo.cell;
2289              } else {
2290                  final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2291                  spanX = dragInfo.spanX;
2292                  spanY = dragInfo.spanY;
2293              }
2294  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2295 +            int minSpanX = spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2296 +            int minSpanY = spanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2297 +            if (d.dragInfo instanceof PendingAddWidgetInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2298 +                minSpanX = ((PendingAddWidgetInfo) d.dragInfo).minSpanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2299 +                minSpanY = ((PendingAddWidgetInfo) d.dragInfo).minSpanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2300 +            }</span>
2301              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2302 -                    (int) mDragViewVisualCenter[1], spanX, spanY, mDragTargetLayout, mTargetCell);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2303 +                    (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragTargetLayout,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2304 +                    mTargetCell);</span>
2305              if (willCreateUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout, mTargetCell, true)) {
2306                  return true;
2307              }
2308              if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout,
2309                      mTargetCell)) {
2310                  return true;
2311              }
2312  
2313              // Don&#x27;t accept the drop if there&#x27;s no room for the item
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2314 -            if (!mDragTargetLayout.findCellForSpanIgnoring(null, spanX, spanY, ignoreView)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2315 +            if (!mDragTargetLayout.findCellForSpanIgnoring(null, minSpanX, minSpanY, ignoreView)) {</span>
2316                  // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2317                  // is full
2318                  if (mTargetCell != null &amp;&amp; mLauncher.isHotseatLayout(mDragTargetLayout)) {
2319                      Hotseat hotseat = mLauncher.getHotseat();
2320                      if (Hotseat.isAllAppsButtonRank(

2321                              hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2322                          return false;
2323                      }
2324                  }
2325  
2326                  mLauncher.showOutOfSpaceMessage();
2327                  return false;
2328              }
2329          }
2330          return true;
2331      }
2332  
2333      boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell,
2334              boolean considerTimeout) {
2335          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2336  
2337          boolean hasntMoved = false;
2338          if (mDragInfo != null) {
2339              CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2340              hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2341                      mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2342          }
2343  
2344          if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2345              return false;
2346          }
2347  
2348          boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2349          boolean willBecomeShortcut =
2350                  (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2351                  info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2352  
2353          return (aboveShortcut &amp;&amp; willBecomeShortcut);
2354      }
2355  
2356      boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell) {
2357          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2358          if (dropOverView instanceof FolderIcon) {
2359              FolderIcon fi = (FolderIcon) dropOverView;
2360              if (fi.acceptDrop(dragInfo)) {
2361                  return true;
2362              }
2363          }
2364          return false;
2365      }
2366  
2367      boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2368              int[] targetCell, boolean external, DragView dragView, Runnable postAnimationRunnable) {
2369          View v = target.getChildAt(targetCell[0], targetCell[1]);
2370          boolean hasntMoved = false;
2371          if (mDragInfo != null) {
2372              CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2373              hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2374                      mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2375          }
2376  
2377          if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2378          mCreateUserFolderOnDrop = false;
2379          final int screen = (targetCell == null) ? mDragInfo.screen : indexOfChild(target);
2380  
2381          boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2382          boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2383  
2384          if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2385              ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2386              ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2387              // if the drag started here, we need to remove it from the workspace
2388              if (!external) {
2389                  getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2390              }
2391  
2392              Rect folderLocation = new Rect();
2393              float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2394              target.removeView(v);
2395  
2396              FolderIcon fi =
2397                  mLauncher.addFolder(target, container, screen, targetCell[0], targetCell[1]);
2398              destInfo.cellX = -1;
2399              destInfo.cellY = -1;
2400              sourceInfo.cellX = -1;
2401              sourceInfo.cellY = -1;
2402  
2403              // If the dragView is null, we can&#x27;t animate
2404              boolean animate = dragView != null;
2405              if (animate) {
2406                  fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2407                          postAnimationRunnable);
2408              } else {
2409                  fi.addItem(destInfo);
2410                  fi.addItem(sourceInfo);
2411              }
2412              return true;
2413          }
2414          return false;
2415      }
2416  
2417      boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2418              DragObject d, boolean external) {
2419          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2420          if (dropOverView instanceof FolderIcon) {
2421              FolderIcon fi = (FolderIcon) dropOverView;
2422              if (fi.acceptDrop(d.dragInfo)) {
2423                  fi.onDrop(d);
2424  
2425                  // if the drag started here, we need to remove it from the workspace
2426                  if (!external) {
2427                      getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2428                  }
2429                  return true;
2430              }
2431          }
2432          return false;
2433      }
2434  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2435 -    public void onDrop(DragObject d) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2436 +    public void onDrop(final DragObject d) {</span>
2437          mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView,
2438                  mDragViewVisualCenter);
2439  
2440          // We want the point to be mapped to the dragTarget.
2441          if (mDragTargetLayout != null) {
2442              if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2443                  mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2444              } else {
2445                  mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2446              }
2447          }
2448  
2449          CellLayout dropTargetLayout = mDragTargetLayout;
2450  
2451          int snapScreen = -1;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2452 +        boolean resizeOnDrop = false;</span>
2453          if (d.dragSource != this) {
2454              final int[] touchXY = new int[] { (int) mDragViewVisualCenter[0],
2455                      (int) mDragViewVisualCenter[1] };
2456              onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2457          } else if (mDragInfo != null) {
2458              final View cell = mDragInfo.cell;
2459  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2460 +            Runnable resizeRunnable = null;</span>
2461              if (dropTargetLayout != null) {
2462                  // Move internally
2463                  boolean hasMovedLayouts = (getParentCellLayoutForView(cell) != dropTargetLayout);
2464                  boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2465                  long container = hasMovedIntoHotseat ?
2466                          LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2467                          LauncherSettings.Favorites.CONTAINER_DESKTOP;
2468                  int screen = (mTargetCell[0] &lt; 0) ?
2469                          mDragInfo.screen : indexOfChild(dropTargetLayout);
2470                  int spanX = mDragInfo != null ? mDragInfo.spanX : 1;
2471                  int spanY = mDragInfo != null ? mDragInfo.spanY : 1;
2472                  // First we find the cell nearest to point at which the item is
2473                  // dropped, without any consideration to whether there is an item there.
2474                  mTargetCell = findNearestArea((int) mDragViewVisualCenter[0], (int)
2475                          mDragViewVisualCenter[1], spanX, spanY, dropTargetLayout, mTargetCell);
2476                  // If the item being dropped is a shortcut and the nearest drop
2477                  // cell also contains a shortcut, then create a folder with the two shortcuts.
2478                  if (!mInScrollArea &amp;&amp; createUserFolderIfNecessary(cell, container,
2479                          dropTargetLayout, mTargetCell, false, d.dragView, null)) {
2480                      return;
2481                  }
2482  
2483                  if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell, d, false)) {
2484                      return;
2485                  }
2486  
2487                  // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2488                  // we need to find the nearest cell location that is vacant
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2489 +                ItemInfo item = (ItemInfo) d.dragInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2490 +                int minSpanX = item.spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2491 +                int minSpanY = item.spanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2492 +                if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2493 +                    minSpanX = item.minSpanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2494 +                    minSpanY = item.minSpanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2495 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2496 +                int[] resultSpan = new int[2];</span>
2497                  mTargetCell = findNearestVacantArea((int) mDragViewVisualCenter[0],
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2498 -                        (int) mDragViewVisualCenter[1], mDragInfo.spanX, mDragInfo.spanY, cell,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2499 -                        dropTargetLayout, mTargetCell);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2500 +                        (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragInfo.spanX,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2501 +                        mDragInfo.spanY, cell, dropTargetLayout, mTargetCell, resultSpan);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2502 +                boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2503 +                if (foundCell &amp;&amp; (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2504 +                    resizeOnDrop = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2505 +                    item.spanX = resultSpan[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2506 +                    item.spanY = resultSpan[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2507 +                }</span>
2508  
2509                  if (mCurrentPage != screen &amp;&amp; !hasMovedIntoHotseat) {
2510                      snapScreen = screen;
2511                      snapToPage(screen);
2512                  }
2513  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2514 -                if (mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2515 +                if (foundCell) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2516 +                    final ItemInfo info = (ItemInfo) cell.getTag();</span>
2517                      if (hasMovedLayouts) {
2518                          // Reparent the view
2519                          getParentCellLayoutForView(cell).removeView(cell);
2520                          addInScreen(cell, container, screen, mTargetCell[0], mTargetCell[1],
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2521 -                                mDragInfo.spanX, mDragInfo.spanY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2522 +                                info.spanX, info.spanY);</span>
2523                      }
2524  
2525                      // update the item&#x27;s position after drop
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2526 -                    final ItemInfo info = (ItemInfo) cell.getTag();</span>
2527                      CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2528 -                    dropTargetLayout.onMove(cell, mTargetCell[0], mTargetCell[1]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2529 +                    dropTargetLayout.onMove(cell, mTargetCell[0], mTargetCell[1],</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2530 +                            item.spanX, item.spanY);</span>
2531                      lp.cellX = mTargetCell[0];
2532                      lp.cellY = mTargetCell[1];
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2533 +                    lp.cellHSpan = item.spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2534 +                    lp.cellVSpan = item.spanY;</span>
2535                      cell.setId(LauncherModel.getCellLayoutChildId(container, mDragInfo.screen,
2536                              mTargetCell[0], mTargetCell[1], mDragInfo.spanX, mDragInfo.spanY));
2537  
2538                      if (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
2539                              cell instanceof LauncherAppWidgetHostView) {
2540                          final CellLayout cellLayout = dropTargetLayout;
2541                          // We post this call so that the widget has a chance to be placed
2542                          // in its final location
2543  
2544                          final LauncherAppWidgetHostView hostView = (LauncherAppWidgetHostView) cell;
2545                          AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2546                          if (pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2547 -                            final Runnable resizeRunnable = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2548 +                            final Runnable addResizeFrame = new Runnable() {</span>
2549                                  public void run() {
2550                                      DragLayer dragLayer = mLauncher.getDragLayer();
2551                                      dragLayer.addResizeFrame(info, hostView, cellLayout);
2552                                  }
2553                              };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2554 -                            post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2555 +                            resizeRunnable = (new Runnable() {</span>
2556                                  public void run() {
2557                                      if (!isPageMoving()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2558 -                                        resizeRunnable.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2559 +                                        addResizeFrame.run();</span>
2560                                      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2561 -                                        mDelayedResizeRunnable = resizeRunnable;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2562 +                                        mDelayedResizeRunnable = addResizeFrame;</span>
2563                                      }
2564                                  }
2565                              });
2566                          }
2567                      }
2568  
2569                      LauncherModel.moveItemInDatabase(mLauncher, info, container, screen, lp.cellX,
2570                              lp.cellY);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2571 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2572 +                    // If we can&#x27;t find a drop location, we return the item to its original position</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2573 +                    CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2574 +                    mTargetCell[0] = lp.cellX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2575 +                    mTargetCell[1] = lp.cellY;</span>
2576                  }
2577              }
2578  
2579              final CellLayout parent = (CellLayout) cell.getParent().getParent();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2580 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2581 +            final Runnable finalResizeRunnable = resizeRunnable;</span>
2582              // Prepare it to be animated into its new position
2583              // This must be called after the view has been re-parented
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2584 -            final Runnable disableHardwareLayersRunnable = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2585 +            final Runnable onCompleteRunnable = new Runnable() {</span>
2586                  @Override
2587                  public void run() {
2588                      mAnimatingViewIntoPlace = false;
2589                      updateChildrenLayersEnabled();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2590 +                    if (finalResizeRunnable != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2591 +                        finalResizeRunnable.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2592 +                    }</span>
2593                  }
2594              };
2595              mAnimatingViewIntoPlace = true;
2596              if (d.dragView.hasDrawn()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2597 -                int duration = snapScreen &lt; 0 ? -1 : ADJACENT_SCREEN_DROP_DURATION;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2598 -                setFinalScrollForPageChange(snapScreen);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2599 -                mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, duration,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2600 -                        disableHardwareLayersRunnable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2601 -                resetFinalScrollForPageChange(snapScreen);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2602 +                final ItemInfo info = (ItemInfo) cell.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2603 +                if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2604 +                    int animationType = resizeOnDrop ? ANIMATE_INTO_POSITION_AND_RESIZE :</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2605 +                            ANIMATE_INTO_POSITION_AND_DISAPPEAR;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2606 +                    animateWidgetDrop(info, parent, d.dragView,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2607 +                            onCompleteRunnable, animationType, cell, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2608 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2609 +                    mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2610 +                            onCompleteRunnable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2611 +                }</span>
2612              } else {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2613 +                d.deferDragViewCleanupPostAnimation = false;</span>
2614                  cell.setVisibility(VISIBLE);
2615              }
2616              parent.onDropChild(cell);
2617          }
2618      }
2619  
2620      public void setFinalScrollForPageChange(int screen) {
2621          if (screen &gt;= 0) {
2622              mSavedScrollX = getScrollX();
2623              CellLayout cl = (CellLayout) getChildAt(screen);
2624              mSavedTranslationX = cl.getTranslationX();
2625              mSavedRotationY = cl.getRotationY();
2626              final int newX = getChildOffset(screen) - getRelativeChildOffset(screen);
2627              setScrollX(newX);
2628              cl.setTranslationX(0f);
2629              cl.setRotationY(0f);
2630          }
2631      }
2632  
2633      public void resetFinalScrollForPageChange(int screen) {
2634          if (screen &gt;= 0) {
2635              CellLayout cl = (CellLayout) getChildAt(screen);
2636              setScrollX(mSavedScrollX);
2637              cl.setTranslationX(mSavedTranslationX);
2638              cl.setRotationY(mSavedRotationY);
2639          }
2640      }
2641  
2642      public void getViewLocationRelativeToSelf(View v, int[] location) {
2643          getLocationInWindow(location);
2644          int x = location[0];
2645          int y = location[1];
2646  
2647          v.getLocationInWindow(location);
2648          int vX = location[0];
2649          int vY = location[1];
2650  
2651          location[0] = vX - x;
2652          location[1] = vY - y;
2653      }
2654  
2655      public void onDragEnter(DragObject d) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2656 +        mDragHasEnteredWorkspace = true;</span>
2657          if (mDragTargetLayout != null) {
2658              mDragTargetLayout.setIsDragOverlapping(false);
2659              mDragTargetLayout.onDragExit();
2660          }
2661          mDragTargetLayout = getCurrentDropLayout();
2662          mDragTargetLayout.setIsDragOverlapping(true);
2663          mDragTargetLayout.onDragEnter();
2664  
2665          // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
2666          // don&#x27;t need to show the outlines
2667          if (LauncherApplication.isScreenLarge()) {
2668              showOutlines();
2669          }
2670      }
2671  
2672      private void doDragExit(DragObject d) {
2673          // Clean up folders
2674          cleanupFolderCreation(d);
2675  
2676          // Reset the scroll area and previous drag target
2677          onResetScrollArea();
2678  
2679          if (mDragTargetLayout != null) {
2680              mDragTargetLayout.setIsDragOverlapping(false);
2681              mDragTargetLayout.onDragExit();
2682          }
2683          mLastDragOverView = null;
2684          mSpringLoadedDragController.cancel();
2685  
2686          if (!mIsPageMoving) {
2687              hideOutlines();
2688          }
2689      }
2690  
2691      public void onDragExit(DragObject d) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2692 +        mDragHasEnteredWorkspace = false;</span>
2693          doDragExit(d);
2694      }
2695  
2696      public DropTarget getDropTargetDelegate(DragObject d) {
2697          return null;
2698      }
2699  
2700      /**
2701       * Tests to see if the drop will be accepted by Launcher, and if so, includes additional data
2702       * in the returned structure related to the widgets that match the drop (or a null list if it is
2703       * a shortcut drop).  If the drop is not accepted then a null structure is returned.
2704       */
2705      private Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; validateDrag(DragEvent event) {
2706          final LauncherModel model = mLauncher.getModel();
2707          final ClipDescription desc = event.getClipDescription();
2708          final int mimeTypeCount = desc.getMimeTypeCount();
2709          for (int i = 0; i &lt; mimeTypeCount; ++i) {
2710              final String mimeType = desc.getMimeType(i);
2711              if (mimeType.equals(InstallShortcutReceiver.SHORTCUT_MIMETYPE)) {
2712                  return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, null);
2713              } else {
2714                  final List&lt;WidgetMimeTypeHandlerData&gt; widgets =
2715                      model.resolveWidgetsForMimeType(mContext, mimeType);
2716                  if (widgets.size() &gt; 0) {
2717                      return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, widgets);
2718                  }
2719              }
2720          }
2721          return null;
2722      }
2723  
2724      /**
2725       * Global drag and drop handler
2726       */
2727      @Override
2728      public boolean onDragEvent(DragEvent event) {
2729          final ClipDescription desc = event.getClipDescription();
2730          final CellLayout layout = (CellLayout) getChildAt(mCurrentPage);
2731          final int[] pos = new int[2];
2732          layout.getLocationOnScreen(pos);
2733          // We need to offset the drag coordinates to layout coordinate space
2734          final int x = (int) event.getX() - pos[0];
2735          final int y = (int) event.getY() - pos[1];
2736  
2737          switch (event.getAction()) {
2738          case DragEvent.ACTION_DRAG_STARTED: {
2739              // Validate this drag
2740              Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2741              if (test != null) {
2742                  boolean isShortcut = (test.second == null);
2743                  if (isShortcut) {
2744                      // Check if we have enough space on this screen to add a new shortcut
2745                      if (!layout.findCellForSpan(pos, 1, 1)) {
2746                          mLauncher.showOutOfSpaceMessage();
2747                          return false;
2748                      }
2749                  }
2750              } else {
2751                  // Show error message if we couldn&#x27;t accept any of the items
2752                  Toast.makeText(mContext, mContext.getString(R.string.external_drop_widget_error),
2753                          Toast.LENGTH_SHORT).show();
2754                  return false;
2755              }
2756  
2757              // Create the drag outline
2758              // We need to add extra padding to the bitmap to make room for the glow effect
2759              final Canvas canvas = new Canvas();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2760 -            final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2761 -            mDragOutline = createExternalDragOutline(canvas, bitmapPadding);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2762 +            mDragOutline = createExternalDragOutline(canvas, DRAG_BITMAP_PADDING);</span>
2763  
2764              // Show the current page outlines to indicate that we can accept this drop
2765              showOutlines();
2766              layout.onDragEnter();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2767 -            layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2768 +            layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, 1, 1, null, null);</span>
2769  
2770              return true;
2771          }
2772          case DragEvent.ACTION_DRAG_LOCATION:
2773              // Visualize the drop location
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2774 -            layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2775 +            layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, 1, 1, null, null);</span>
2776              return true;
2777          case DragEvent.ACTION_DROP: {
2778              // Try and add any shortcuts
2779              final LauncherModel model = mLauncher.getModel();
2780              final ClipData data = event.getClipData();
2781  
2782              // We assume that the mime types are ordered in descending importance of
2783              // representation. So we enumerate the list of mime types and alert the
2784              // user if any widgets can handle the drop.  Only the most preferred
2785              // representation will be handled.
2786              pos[0] = x;
2787              pos[1] = y;
2788              Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2789              if (test != null) {
2790                  final int index = test.first;
2791                  final List&lt;WidgetMimeTypeHandlerData&gt; widgets = test.second;
2792                  final boolean isShortcut = (widgets == null);
2793                  final String mimeType = desc.getMimeType(index);
2794                  if (isShortcut) {
2795                      final Intent intent = data.getItemAt(index).getIntent();
2796                      Object info = model.infoFromShortcutIntent(mContext, intent, data.getIcon());
2797                      if (info != null) {
2798                          onDropExternal(new int[] { x, y }, info, layout, false);
2799                      }
2800                  } else {
2801                      if (widgets.size() == 1) {
2802                          // If there is only one item, then go ahead and add and configure
2803                          // that widget
2804                          final AppWidgetProviderInfo widgetInfo = widgets.get(0).widgetInfo;
2805                          final PendingAddWidgetInfo createInfo =
2806                                  new PendingAddWidgetInfo(widgetInfo, mimeType, data);
2807                          mLauncher.addAppWidgetFromDrop(createInfo,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2808 -                            LauncherSettings.Favorites.CONTAINER_DESKTOP, mCurrentPage, null, pos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2809 +                                LauncherSettings.Favorites.CONTAINER_DESKTOP, mCurrentPage,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2810 +                                null, null, pos);</span>
2811                      } else {
2812                          // Show the widget picker dialog if there is more than one widget
2813                          // that can handle this data type
2814                          final InstallWidgetReceiver.WidgetListAdapter adapter =
2815                              new InstallWidgetReceiver.WidgetListAdapter(mLauncher, mimeType,
2816                                      data, widgets, layout, mCurrentPage, pos);
2817                          final AlertDialog.Builder builder =
2818                              new AlertDialog.Builder(mContext);
2819                          builder.setAdapter(adapter, adapter);
2820                          builder.setCancelable(true);
2821                          builder.setTitle(mContext.getString(
2822                                  R.string.external_drop_widget_pick_title));
2823                          builder.setIcon(R.drawable.ic_no_applications);
2824                          builder.show();
2825                      }
2826                  }
2827              }
2828              return true;
2829          }
2830          case DragEvent.ACTION_DRAG_ENDED:
2831              // Hide the page outlines after the drop
2832              layout.onDragExit();
2833              hideOutlines();
2834              return true;
2835          }
2836          return super.onDragEvent(event);
2837      }
2838  
2839      /*
2840      *
2841      * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2842      * coordinate space. The argument xy is modified with the return result.
2843      *
2844      */
2845     void mapPointFromSelfToChild(View v, float[] xy) {
2846         mapPointFromSelfToChild(v, xy, null);
2847     }
2848  
2849     /*
2850      *
2851      * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2852      * coordinate space. The argument xy is modified with the return result.
2853      *
2854      * if cachedInverseMatrix is not null, this method will just use that matrix instead of
2855      * computing it itself; we use this to avoid redundant matrix inversions in
2856      * findMatchingPageForDragOver
2857      *
2858      */
2859     void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
2860         if (cachedInverseMatrix == null) {
2861             v.getMatrix().invert(mTempInverseMatrix);
2862             cachedInverseMatrix = mTempInverseMatrix;
2863         }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2864 -       xy[0] = xy[0] + mScrollX - v.getLeft();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2865 +       int scrollX = mScrollX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2866 +       if (mNextPage != INVALID_PAGE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2867 +           scrollX = mScroller.getFinalX();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2868 +       }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2869 +       xy[0] = xy[0] + scrollX - v.getLeft();</span>
2870         xy[1] = xy[1] + mScrollY - v.getTop();
2871         cachedInverseMatrix.mapPoints(xy);
2872     }
2873  
2874     /*
2875      * Maps a point from the Workspace&#x27;s coordinate system to another sibling view&#x27;s. (Workspace
2876      * covers the full screen)
2877      */
2878     void mapPointFromSelfToSibling(View v, float[] xy) {
2879         xy[0] = xy[0] - v.getLeft();
2880         xy[1] = xy[1] - v.getTop();
2881     }
2882  
2883     /*
2884      *
2885      * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
2886      * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
2887      *
2888      */
2889     void mapPointFromChildToSelf(View v, float[] xy) {
2890         v.getMatrix().mapPoints(xy);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2891 -       xy[0] -= (mScrollX - v.getLeft());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2892 +       int scrollX = mScrollX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2893 +       if (mNextPage != INVALID_PAGE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2894 +           scrollX = mScroller.getFinalX();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2895 +       }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2896 +       xy[0] -= (scrollX - v.getLeft());</span>
2897         xy[1] -= (mScrollY - v.getTop());
2898     }
2899  
2900     static private float squaredDistance(float[] point1, float[] point2) {
2901          float distanceX = point1[0] - point2[0];
2902          float distanceY = point2[1] - point2[1];
2903          return distanceX * distanceX + distanceY * distanceY;
2904     }
2905  
2906      /*
2907       *
2908       * Returns true if the passed CellLayout cl overlaps with dragView
2909       *
2910       */
2911      boolean overlaps(CellLayout cl, DragView dragView,
2912              int dragViewX, int dragViewY, Matrix cachedInverseMatrix) {
2913          // Transform the coordinates of the item being dragged to the CellLayout&#x27;s coordinates
2914          final float[] draggedItemTopLeft = mTempDragCoordinates;
2915          draggedItemTopLeft[0] = dragViewX;
2916          draggedItemTopLeft[1] = dragViewY;
2917          final float[] draggedItemBottomRight = mTempDragBottomRightCoordinates;
2918          draggedItemBottomRight[0] = draggedItemTopLeft[0] + dragView.getDragRegionWidth();
2919          draggedItemBottomRight[1] = draggedItemTopLeft[1] + dragView.getDragRegionHeight();
2920  
2921          // Transform the dragged item&#x27;s top left coordinates
2922          // to the CellLayout&#x27;s local coordinates
2923          mapPointFromSelfToChild(cl, draggedItemTopLeft, cachedInverseMatrix);
2924          float overlapRegionLeft = Math.max(0f, draggedItemTopLeft[0]);
2925          float overlapRegionTop = Math.max(0f, draggedItemTopLeft[1]);
2926  
2927          if (overlapRegionLeft &lt;= cl.getWidth() &amp;&amp; overlapRegionTop &gt;= 0) {
2928              // Transform the dragged item&#x27;s bottom right coordinates
2929              // to the CellLayout&#x27;s local coordinates
2930              mapPointFromSelfToChild(cl, draggedItemBottomRight, cachedInverseMatrix);
2931              float overlapRegionRight = Math.min(cl.getWidth(), draggedItemBottomRight[0]);
2932              float overlapRegionBottom = Math.min(cl.getHeight(), draggedItemBottomRight[1]);
2933  
2934              if (overlapRegionRight &gt;= 0 &amp;&amp; overlapRegionBottom &lt;= cl.getHeight()) {
2935                  float overlap = (overlapRegionRight - overlapRegionLeft) *
2936                           (overlapRegionBottom - overlapRegionTop);
2937                  if (overlap &gt; 0) {
2938                      return true;
2939                  }
2940               }
2941          }
2942          return false;
2943      }
2944  
2945      /*
2946       *
2947       * This method returns the CellLayout that is currently being dragged to. In order to drag
2948       * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
2949       * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
2950       *
2951       * Return null if no CellLayout is currently being dragged over
2952       *
2953       */
2954      private CellLayout findMatchingPageForDragOver(
2955              DragView dragView, float originX, float originY, boolean exact) {
2956          // We loop through all the screens (ie CellLayouts) and see which ones overlap
2957          // with the item being dragged and then choose the one that&#x27;s closest to the touch point
2958          final int screenCount = getChildCount();
2959          CellLayout bestMatchingScreen = null;
2960          float smallestDistSoFar = Float.MAX_VALUE;
2961  
2962          for (int i = 0; i &lt; screenCount; i++) {
2963              CellLayout cl = (CellLayout) getChildAt(i);
2964  
2965              final float[] touchXy = {originX, originY};
2966              // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
2967              // If the touch point is within the bounds of the cell layout, we can return immediately
2968              cl.getMatrix().invert(mTempInverseMatrix);
2969              mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
2970  
2971              if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
2972                      touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
2973                  return cl;
2974              }
2975  
2976              if (!exact) {
2977                  // Get the center of the cell layout in screen coordinates
2978                  final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
2979                  cellLayoutCenter[0] = cl.getWidth()/2;
2980                  cellLayoutCenter[1] = cl.getHeight()/2;
2981                  mapPointFromChildToSelf(cl, cellLayoutCenter);
2982  
2983                  touchXy[0] = originX;
2984                  touchXy[1] = originY;
2985  
2986                  // Calculate the distance between the center of the CellLayout
2987                  // and the touch point
2988                  float dist = squaredDistance(touchXy, cellLayoutCenter);
2989  
2990                  if (dist &lt; smallestDistSoFar) {
2991                      smallestDistSoFar = dist;
2992                      bestMatchingScreen = cl;
2993                  }
2994              }
2995          }
2996          return bestMatchingScreen;
2997      }
2998  
2999      // This is used to compute the visual center of the dragView. This point is then
3000      // used to visualize drop locations and determine where to drop an item. The idea is that
3001      // the visual center represents the user&#x27;s interpretation of where the item is, and hence
3002      // is the appropriate point to use when determining drop location.
3003      private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
3004              DragView dragView, float[] recycle) {
3005          float res[];
3006          if (recycle == null) {
3007              res = new float[2];
3008          } else {
3009              res = recycle;
3010          }
3011  
3012          // First off, the drag view has been shifted in a way that is not represented in the
3013          // x and y values or the x/yOffsets. Here we account for that shift.
3014          x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
3015          y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
3016  
3017          // These represent the visual top and left of drag view if a dragRect was provided.
3018          // If a dragRect was not provided, then they correspond to the actual view left and
3019          // top, as the dragRect is in that case taken to be the entire dragView.
3020          // R.dimen.dragViewOffsetY.
3021          int left = x - xOffset;
3022          int top = y - yOffset;
3023  
3024          // In order to find the visual center, we shift by half the dragRect
3025          res[0] = left + dragView.getDragRegion().width() / 2;
3026          res[1] = top + dragView.getDragRegion().height() / 2;
3027  
3028          return res;
3029      }
3030  
3031      private boolean isDragWidget(DragObject d) {
3032          return (d.dragInfo instanceof LauncherAppWidgetInfo ||
3033                  d.dragInfo instanceof PendingAddWidgetInfo);
3034      }
3035      private boolean isExternalDragWidget(DragObject d) {
3036          return d.dragSource != this &amp;&amp; isDragWidget(d);
3037      }
3038  
3039      public void onDragOver(DragObject d) {
3040          // Skip drag over events while we are dragging over side pages
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3041 -        if (mInScrollArea) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3042 -        if (mIsSwitchingState) return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3043 +        if (mInScrollArea || mIsSwitchingState || mState == State.SMALL) return;</span>
3044  
3045          Rect r = new Rect();
3046          CellLayout layout = null;
3047          ItemInfo item = (ItemInfo) d.dragInfo;
3048  
3049          // Ensure that we have proper spans for the item that we are dropping
3050          if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
3051          mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
3052              d.dragView, mDragViewVisualCenter);
3053  
3054          // Identify whether we have dragged over a side page
3055          if (isSmall()) {
3056              if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
3057                  mLauncher.getHotseat().getHitRect(r);
3058                  if (r.contains(d.x, d.y)) {
3059                      layout = mLauncher.getHotseat().getLayout();
3060                  }
3061              }
3062              if (layout == null) {
3063                  layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
3064              }
3065              if (layout != mDragTargetLayout) {
3066                  // Cancel all intermediate folder states
3067                  cleanupFolderCreation(d);
3068  
3069                  if (mDragTargetLayout != null) {
3070                      mDragTargetLayout.setIsDragOverlapping(false);
3071                      mDragTargetLayout.onDragExit();
3072                  }
3073                  mDragTargetLayout = layout;
3074                  if (mDragTargetLayout != null) {
3075                      mDragTargetLayout.setIsDragOverlapping(true);
3076                      mDragTargetLayout.onDragEnter();
3077                  } else {
3078                      mLastDragOverView = null;
3079                  }
3080  
3081                  boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
3082                  if (isInSpringLoadedMode) {
3083                      if (mLauncher.isHotseatLayout(layout)) {
3084                          mSpringLoadedDragController.cancel();
3085                      } else {
3086                          mSpringLoadedDragController.setAlarm(mDragTargetLayout);
3087                      }
3088                  }
3089              }
3090          } else {
3091              // Test to see if we are over the hotseat otherwise just use the current page
3092              if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
3093                  mLauncher.getHotseat().getHitRect(r);
3094                  if (r.contains(d.x, d.y)) {
3095                      layout = mLauncher.getHotseat().getLayout();
3096                  }
3097              }
3098              if (layout == null) {
3099                  layout = getCurrentDropLayout();
3100              }
3101              if (layout != mDragTargetLayout) {
3102                  if (mDragTargetLayout != null) {
3103                      mDragTargetLayout.setIsDragOverlapping(false);
3104                      mDragTargetLayout.onDragExit();
3105                  }
3106                  mDragTargetLayout = layout;
3107                  mDragTargetLayout.setIsDragOverlapping(true);
3108                  mDragTargetLayout.onDragEnter();
3109              }
3110          }
3111  
3112          // Handle the drag over
3113          if (mDragTargetLayout != null) {
3114              final View child = (mDragInfo == null) ? null : mDragInfo.cell;
3115  
3116              // We want the point to be mapped to the dragTarget.
3117              if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
3118                  mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
3119              } else {
3120                  mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
3121              }
3122              ItemInfo info = (ItemInfo) d.dragInfo;
3123  
3124              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3125                      (int) mDragViewVisualCenter[1], 1, 1, mDragTargetLayout, mTargetCell);
3126              final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
3127                      mTargetCell[1]);
3128  
3129              boolean userFolderPending = willCreateUserFolder(info, mDragTargetLayout,
3130                      mTargetCell, false);
3131              boolean isOverFolder = dragOverView instanceof FolderIcon;
3132              if (dragOverView != mLastDragOverView) {
3133                  cancelFolderCreation();
3134                  if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
3135                      ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
3136                  }
3137              }
3138  
3139              if (userFolderPending &amp;&amp; dragOverView != mLastDragOverView) {
3140                  mFolderCreationAlarm.setOnAlarmListener(new
3141                          FolderCreationAlarmListener(mDragTargetLayout, mTargetCell[0], mTargetCell[1]));
3142                  mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
3143              }
3144  
3145              if (dragOverView != mLastDragOverView &amp;&amp; isOverFolder) {
3146                  ((FolderIcon) dragOverView).onDragEnter(d.dragInfo);
3147                  if (mDragTargetLayout != null) {
3148                      mDragTargetLayout.clearDragOutlines();
3149                  }
3150              }
3151              mLastDragOverView = dragOverView;
3152  
3153              if (!mCreateUserFolderOnDrop &amp;&amp; !isOverFolder) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3154 +                int minSpanX = item.spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3155 +                int minSpanY = item.spanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3156 +                if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3157 +                    minSpanX = item.minSpanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3158 +                    minSpanY = item.minSpanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3159 +                }</span>
3160                  mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3161                          (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3162 -                        item.spanX, item.spanY, d.dragView.getDragVisualizeOffset(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3163 -                        d.dragView.getDragRegion());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3164 +                        minSpanX, minSpanY, item.spanX, item.spanY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3165 +                        d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());</span>
3166              }
3167          }
3168      }
3169  
3170      private void cleanupFolderCreation(DragObject d) {
3171          if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
3172              mDragFolderRingAnimator.animateToNaturalState();
3173          }
3174          if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
3175              if (d != null) {
3176                  ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
3177              }
3178          }
3179          mFolderCreationAlarm.cancelAlarm();
3180      }
3181  
3182      private void cancelFolderCreation() {
3183          if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
3184              mDragFolderRingAnimator.animateToNaturalState();
3185          }
3186          mCreateUserFolderOnDrop = false;
3187          mFolderCreationAlarm.cancelAlarm();
3188      }
3189  
3190      class FolderCreationAlarmListener implements OnAlarmListener {
3191          CellLayout layout;
3192          int cellX;
3193          int cellY;
3194  
3195          public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
3196              this.layout = layout;
3197              this.cellX = cellX;
3198              this.cellY = cellY;
3199          }
3200  
3201          public void onAlarm(Alarm alarm) {
3202              if (mDragFolderRingAnimator == null) {
3203                  mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
3204              }
3205              mDragFolderRingAnimator.setCell(cellX, cellY);
3206              mDragFolderRingAnimator.setCellLayout(layout);
3207              mDragFolderRingAnimator.animateToAcceptState();
3208              layout.showFolderAccept(mDragFolderRingAnimator);
3209              layout.clearDragOutlines();
3210              mCreateUserFolderOnDrop = true;
3211          }
3212      }
3213  
3214      @Override
3215      public void getHitRect(Rect outRect) {
3216          // We want the workspace to have the whole area of the display (it will find the correct
3217          // cell layout to drop to in the existing drag/drop logic.
3218          outRect.set(0, 0, mDisplayWidth, mDisplayHeight);
3219      }
3220  
3221      /**
3222       * Add the item specified by dragInfo to the given layout.
3223       * @return true if successful
3224       */
3225      public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
3226          if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
3227              onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
3228              return true;
3229          }
3230          mLauncher.showOutOfSpaceMessage();
3231          return false;
3232      }
3233  
3234      private void onDropExternal(int[] touchXY, Object dragInfo,
3235              CellLayout cellLayout, boolean insertAtFirst) {
3236          onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
3237      }
3238  
3239      /**
3240       * Drop an item that didn&#x27;t originate on one of the workspace screens.
3241       * It may have come from Launcher (e.g. from all apps or customize), or it may have
3242       * come from another app altogether.
3243       *
3244       * NOTE: This can also be called when we are outside of a drag event, when we want
3245       * to add an item to one of the workspace screens.
3246       */
3247      private void onDropExternal(final int[] touchXY, final Object dragInfo,
3248              final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
3249          final Runnable exitSpringLoadedRunnable = new Runnable() {
3250              @Override
3251              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3252 -                mLauncher.exitSpringLoadedDragModeDelayed(true, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3253 +                mLauncher.exitSpringLoadedDragModeDelayed(true, false, null);</span>
3254              }
3255          };
3256  
3257          ItemInfo info = (ItemInfo) dragInfo;
3258          int spanX = info.spanX;
3259          int spanY = info.spanY;
3260          if (mDragInfo != null) {
3261              spanX = mDragInfo.spanX;
3262              spanY = mDragInfo.spanY;
3263          }
3264  
3265          final long container = mLauncher.isHotseatLayout(cellLayout) ?
3266                  LauncherSettings.Favorites.CONTAINER_HOTSEAT :
3267                      LauncherSettings.Favorites.CONTAINER_DESKTOP;
3268          final int screen = indexOfChild(cellLayout);
3269          if (!mLauncher.isHotseatLayout(cellLayout) &amp;&amp; screen != mCurrentPage
3270                  &amp;&amp; mState != State.SPRING_LOADED) {
3271              snapToPage(screen);
3272          }
3273  
3274          if (info instanceof PendingAddItemInfo) {
3275              final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
3276  
3277              boolean findNearestVacantCell = true;
3278              if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
3279                  mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3280                          cellLayout, mTargetCell);
3281                  if (willCreateUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout, mTargetCell,
3282                          true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
3283                                  mDragTargetLayout, mTargetCell)) {
3284                      findNearestVacantCell = false;
3285                  }
3286              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3287 +            final ItemInfo item = (ItemInfo) d.dragInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3288 +            int minSpanX = item.spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3289 +            int minSpanY = item.spanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3290 +            if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3291 +                minSpanX = item.minSpanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3292 +                minSpanY = item.minSpanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3293 +            }</span>
3294              if (findNearestVacantCell) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3295 -                    mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], spanX, spanY, null,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3296 -                        cellLayout, mTargetCell);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3297 +                int[] resultSpan = new int[2];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3298 +                mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], minSpanX, minSpanY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3299 +                        spanX, spanY, null, cellLayout, mTargetCell, resultSpan);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3300 +                item.spanX = resultSpan[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3301 +                item.spanY = resultSpan[1];</span>
3302              }
3303  
3304              Runnable onAnimationCompleteRunnable = new Runnable() {
3305                  @Override
3306                  public void run() {
3307                      // When dragging and dropping from customization tray, we deal with creating
3308                      // widgets/shortcuts/folders in a slightly different way
3309                      switch (pendingInfo.itemType) {
3310                      case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3311 +                        int span[] = new int[2];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3312 +                        span[0] = item.spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3313 +                        span[1] = item.spanY;</span>
3314                          mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3315 -                                container, screen, mTargetCell, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3316 +                                container, screen, mTargetCell, span, null);</span>
3317                          break;
3318                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3319                          mLauncher.processShortcutFromDrop(pendingInfo.componentName,
3320                                  container, screen, mTargetCell, null);
3321                          break;
3322                      default:
3323                          throw new IllegalStateException(&quot;Unknown item type: &quot; +
3324                                  pendingInfo.itemType);
3325                      }
3326                      cellLayout.onDragExit();
3327                  }
3328              };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3329 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3330 -            // Now we animate the dragView, (ie. the widget or shortcut preview) into its final</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3331 -            // location and size on the home screen.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3332 -            RectF r = estimateItemPosition(cellLayout, pendingInfo,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3333 -                    mTargetCell[0], mTargetCell[1], spanX, spanY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3334 -            int loc[] = new int[2];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3335 -            loc[0] = (int) r.left;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3336 -            loc[1] = (int) r.top;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3337 -            setFinalTransitionTransform(cellLayout);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3338 -            float cellLayoutScale =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3339 -                    mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(cellLayout, loc);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3340 -            resetTransitionTransform(cellLayout);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3341 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3342 -            float dragViewScale =  Math.min(r.width() / d.dragView.getMeasuredWidth(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3343 -                    r.height() / d.dragView.getMeasuredHeight());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3344 -            // The animation will scale the dragView about its center, so we need to center about</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3345 -            // the final location.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3346 -            loc[0] -= (d.dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3347 -            loc[1] -= (d.dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3348 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3349 -            mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, loc,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3350 -                    dragViewScale * cellLayoutScale, onAnimationCompleteRunnable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3351 +            View finalView = pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3352 +                    ? ((PendingAddWidgetInfo) pendingInfo).boundWidget : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3353 +            int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3354 +            if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3355 +                    ((PendingAddWidgetInfo) pendingInfo).info.configure != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3356 +                animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3357 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3358 +            animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3359 +                    animationStyle, finalView, true);</span>
3360          } else {
3361              // This is for other drag/drop cases, like dragging from All Apps
3362              View view = null;
3363  
3364              switch (info.itemType) {
3365              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3366              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3367                  if (info.container == NO_ID &amp;&amp; info instanceof ApplicationInfo) {
3368                      // Came from all apps -- make a copy
3369                      info = new ShortcutInfo((ApplicationInfo) info);
3370                  }
3371                  view = mLauncher.createShortcut(R.layout.application, cellLayout,
3372                          (ShortcutInfo) info);
3373                  break;
3374              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3375                  view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3376                          (FolderInfo) info, mIconCache);
3377                  break;
3378              default:
3379                  throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3380              }
3381  
3382              // First we find the cell nearest to point at which the item is
3383              // dropped, without any consideration to whether there is an item there.
3384              if (touchXY != null) {
3385                  mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3386                          cellLayout, mTargetCell);
3387                  d.postAnimationRunnable = exitSpringLoadedRunnable;
3388                  if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, true,
3389                          d.dragView, d.postAnimationRunnable)) {
3390                      return;
3391                  }
3392                  if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, d, true)) {
3393                      return;
3394                  }
3395              }
3396  
3397              if (touchXY != null) {
3398                  // when dragging and dropping, just find the closest free spot
3399                  mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, null,
3400                          cellLayout, mTargetCell);
3401              } else {
3402                  cellLayout.findCellForSpan(mTargetCell, 1, 1);
3403              }
3404              addInScreen(view, container, screen, mTargetCell[0], mTargetCell[1], info.spanX,
3405                      info.spanY, insertAtFirst);
3406              cellLayout.onDropChild(view);
3407              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3408              cellLayout.getChildrenLayout().measureChild(view);
3409  

3410              LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen,
3411                      lp.cellX, lp.cellY);
3412  
3413              if (d.dragView != null) {
3414                  // We wrap the animation call in the temporary set and reset of the current
3415                  // cellLayout to its final transform -- this means we animate the drag view to
3416                  // the correct final location.
3417                  setFinalTransitionTransform(cellLayout);
3418                  mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3419                          exitSpringLoadedRunnable);
3420                  resetTransitionTransform(cellLayout);
3421              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3422 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3423 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3424 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3425 +    public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3426 +        int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3427 +                widgetInfo.spanY, widgetInfo, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3428 +        int visibility = layout.getVisibility();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3429 +        layout.setVisibility(VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3430 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3431 +        int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3432 +        int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3433 +        Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1],</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3434 +                Bitmap.Config.ARGB_8888);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3435 +        Canvas c = new Canvas(b);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3436 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3437 +        layout.measure(width, height);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3438 +        layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3439 +        layout.draw(c);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3440 +        c.setBitmap(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3441 +        layout.setVisibility(visibility);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3442 +        return b;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3443 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3444 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3445 +    private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3446 +            DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell, View finalView,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3447 +            boolean external) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3448 +        // Now we animate the dragView, (ie. the widget or shortcut preview) into its final</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3449 +        // location and size on the home screen.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3450 +        int spanX = info.spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3451 +        int spanY = info.spanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3452 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3453 +        Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3454 +        loc[0] = r.left;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3455 +        loc[1] = r.top;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3456 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3457 +        setFinalTransitionTransform(layout);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3458 +        float cellLayoutScale =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3459 +                mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3460 +        resetTransitionTransform(layout);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3461 +        float dragViewScaleX = (1.0f * r.width()) / dragView.getMeasuredWidth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3462 +        float dragViewScaleY = (1.0f * r.height()) / dragView.getMeasuredHeight();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3463 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3464 +        // The animation will scale the dragView about its center, so we need to center about</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3465 +        // the final location.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3466 +        loc[0] -= (dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3467 +        loc[1] -= (dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3468 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3469 +        scaleXY[0] = dragViewScaleX * cellLayoutScale;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3470 +        scaleXY[1] = dragViewScaleY * cellLayoutScale;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3471 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3472 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3473 +    public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3474 +            final Runnable onCompleteRunnable, int animationType, final View finalView,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3475 +            boolean external) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3476 +        Rect from = new Rect();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3477 +        mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3478 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3479 +        int[] finalPos = new int[2];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3480 +        float scaleXY[] = new float[2];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3481 +        getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3482 +                finalView, external);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3483 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3484 +        Resources res = mLauncher.getResources();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3485 +        int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3486 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3487 +        // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3488 +        if (finalView instanceof AppWidgetHostView &amp;&amp; external) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3489 +            mLauncher.getDragLayer().removeView(finalView);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3490 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3491 +        if ((animationType == ANIMATE_INTO_POSITION_AND_RESIZE || external) &amp;&amp; finalView != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3492 +            Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3493 +            dragView.setCrossFadeBitmap(crossFadeBitmap);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3494 +            dragView.crossFade((int) (duration * 0.8f));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3495 +        } else if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp; external) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3496 +            scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0],  scaleXY[1]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3497 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3498 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3499 +        DragLayer dragLayer = mLauncher.getDragLayer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3500 +        if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3501 +            mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0f, 0.1f, 0.1f,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3502 +                    DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3503 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3504 +            int endStyle;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3505 +            if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3506 +                endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3507 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3508 +                endStyle = DragLayer.ANIMATION_END_DISAPPEAR;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3509 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3510 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3511 +            Runnable onComplete = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3512 +                @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3513 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3514 +                    if (finalView != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3515 +                        finalView.setVisibility(VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3516 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3517 +                    if (onCompleteRunnable != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3518 +                        onCompleteRunnable.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3519 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3520 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3521 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3522 +            dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0],</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3523 +                    finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3524 +                    duration, this);</span>
3525          }
3526      }
3527  
3528      public void setFinalTransitionTransform(CellLayout layout) {
3529          if (isSwitchingState()) {
3530              int index = indexOfChild(layout);
3531              mCurrentScaleX = layout.getScaleX();
3532              mCurrentScaleY = layout.getScaleY();
3533              mCurrentTranslationX = layout.getTranslationX();
3534              mCurrentTranslationY = layout.getTranslationY();
3535              mCurrentRotationY = layout.getRotationY();
3536              layout.setScaleX(mNewScaleXs[index]);
3537              layout.setScaleY(mNewScaleYs[index]);
3538              layout.setTranslationX(mNewTranslationXs[index]);
3539              layout.setTranslationY(mNewTranslationYs[index]);
3540              layout.setRotationY(mNewRotationYs[index]);
3541          }
3542      }
3543      public void resetTransitionTransform(CellLayout layout) {
3544          if (isSwitchingState()) {
3545              mCurrentScaleX = layout.getScaleX();
3546              mCurrentScaleY = layout.getScaleY();
3547              mCurrentTranslationX = layout.getTranslationX();
3548              mCurrentTranslationY = layout.getTranslationY();
3549              mCurrentRotationY = layout.getRotationY();
3550              layout.setScaleX(mCurrentScaleX);
3551              layout.setScaleY(mCurrentScaleY);
3552              layout.setTranslationX(mCurrentTranslationX);
3553              layout.setTranslationY(mCurrentTranslationY);
3554              layout.setRotationY(mCurrentRotationY);
3555          }
3556      }
3557  
3558      /**
3559       * Return the current {@link CellLayout}, correctly picking the destination
3560       * screen while a scroll is in progress.
3561       */
3562      public CellLayout getCurrentDropLayout() {
3563          return (CellLayout) getChildAt(mNextPage == INVALID_PAGE ? mCurrentPage : mNextPage);
3564      }
3565  
3566      /**
3567       * Return the current CellInfo describing our current drag; this method exists
3568       * so that Launcher can sync this object with the correct info when the activity is created/
3569       * destroyed
3570       *
3571       */
3572      public CellLayout.CellInfo getDragInfo() {
3573          return mDragInfo;
3574      }
3575  
3576      /**
3577       * Calculate the nearest cell where the given object would be dropped.
3578       *
3579       * pixelX and pixelY should be in the coordinate system of layout
3580       */
3581      private int[] findNearestVacantArea(int pixelX, int pixelY,
3582              int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle) {
3583          return layout.findNearestVacantArea(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3584 -                pixelX, pixelY, spanX, spanY, ignoreView, recycle);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3585 +                pixelX, pixelY, spanX, spanY, spanX, spanY, ignoreView, recycle, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3586 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3587 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3588 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3589 +     * Calculate the nearest cell where the given object would be dropped.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3590 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3591 +     * pixelX and pixelY should be in the coordinate system of layout</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3592 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3593 +    private int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3594 +            int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3595 +            int[] returnSpan) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3596 +        return layout.findNearestVacantArea(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3597 +                pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, recycle, returnSpan);</span>
3598      }
3599  
3600      /**
3601       * Calculate the nearest cell where the given object would be dropped.
3602       *
3603       * pixelX and pixelY should be in the coordinate system of layout
3604       */
3605      private int[] findNearestArea(int pixelX, int pixelY,
3606              int spanX, int spanY, CellLayout layout, int[] recycle) {
3607          return layout.findNearestArea(
3608                  pixelX, pixelY, spanX, spanY, recycle);
3609      }
3610  
3611      void setup(DragController dragController) {
3612          mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3613          mDragController = dragController;
3614  
3615          // hardware layers on children are enabled on startup, but should be disabled until
3616          // needed
3617          updateChildrenLayersEnabled();
3618          setWallpaperDimension();
3619      }
3620  
3621      /**
3622       * Called at the end of a drag which originated on the workspace.
3623       */
3624      public void onDropCompleted(View target, DragObject d, boolean success) {
3625          if (success) {
3626              if (target != this) {
3627                  if (mDragInfo != null) {
3628                      getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
3629                      if (mDragInfo.cell instanceof DropTarget) {
3630                          mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3631                      }
3632                  }
3633              }
3634          } else if (mDragInfo != null) {
3635              // NOTE: When &#x27;success&#x27; is true, onDragExit is called by the DragController before
3636              // calling onDropCompleted(). We call it ourselves here, but maybe this should be
3637              // moved into DragController.cancelDrag().
3638              doDragExit(null);
3639              CellLayout cellLayout;
3640              if (mLauncher.isHotseatLayout(target)) {
3641                  cellLayout = mLauncher.getHotseat().getLayout();
3642              } else {
3643                  cellLayout = (CellLayout) getChildAt(mDragInfo.screen);
3644              }
3645              cellLayout.onDropChild(mDragInfo.cell);
3646          }
3647          if (d.cancelled &amp;&amp;  mDragInfo.cell != null) {
3648                  mDragInfo.cell.setVisibility(VISIBLE);
3649          }
3650          mDragOutline = null;
3651          mDragInfo = null;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3652 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3653 +        // Hide the scrolling indicator after you pick up an item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3654 +        hideScrollingIndicator(false);</span>
3655      }
3656  
3657      public boolean isDropEnabled() {
3658          return true;
3659      }
3660  
3661      @Override
3662      protected void onRestoreInstanceState(Parcelable state) {
3663          super.onRestoreInstanceState(state);
3664          Launcher.setScreen(mCurrentPage);
3665      }
3666  
3667      @Override
3668      public void scrollLeft() {
3669          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3670              super.scrollLeft();
3671          }
3672          Folder openFolder = getOpenFolder();
3673          if (openFolder != null) {
3674              openFolder.completeDragExit();
3675          }
3676      }
3677  
3678      @Override
3679      public void scrollRight() {
3680          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3681              super.scrollRight();
3682          }
3683          Folder openFolder = getOpenFolder();
3684          if (openFolder != null) {
3685              openFolder.completeDragExit();
3686          }
3687      }
3688  
3689      @Override
3690      public boolean onEnterScrollArea(int x, int y, int direction) {
3691          // Ignore the scroll area if we are dragging over the hot seat
3692          if (mLauncher.getHotseat() != null) {
3693              Rect r = new Rect();
3694              mLauncher.getHotseat().getHitRect(r);
3695              if (r.contains(x, y)) {
3696                  return false;
3697              }
3698          }
3699  
3700          boolean result = false;
3701          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3702              mInScrollArea = true;
3703  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3704 -            final int page = mCurrentPage + (direction == DragController.SCROLL_LEFT ? -1 : 1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3705 -            final CellLayout layout = (CellLayout) getChildAt(page);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3706 +            final int page = (mNextPage != INVALID_PAGE ? mNextPage : mCurrentPage) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3707 +                       (direction == DragController.SCROLL_LEFT ? -1 : 1);</span>
3708              cancelFolderCreation();
3709  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3710 -            if (layout != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3711 +            if (0 &lt;= page &amp;&amp; page &lt; getChildCount()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3712 +                CellLayout layout = (CellLayout) getChildAt(page);</span>
3713                  // Exit the current layout and mark the overlapping layout
3714                  if (mDragTargetLayout != null) {
3715                      mDragTargetLayout.setIsDragOverlapping(false);
3716                      mDragTargetLayout.onDragExit();
3717                  }
3718                  mDragTargetLayout = layout;
3719                  mDragTargetLayout.setIsDragOverlapping(true);
3720  
3721                  // Workspace is responsible for drawing the edge glow on adjacent pages,
3722                  // so we need to redraw the workspace when this may have changed.
3723                  invalidate();
3724                  result = true;
3725              }
3726          }
3727          return result;
3728      }
3729  
3730      @Override
3731      public boolean onExitScrollArea() {
3732          boolean result = false;
3733          if (mInScrollArea) {
3734              if (mDragTargetLayout != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3735 -                // Unmark the overlapping layout and re-enter the current layout</span>
3736                  mDragTargetLayout.setIsDragOverlapping(false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3737 -                mDragTargetLayout = getCurrentDropLayout();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3738 -                mDragTargetLayout.onDragEnter();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3739 -</span>
3740                  // Workspace is responsible for drawing the edge glow on adjacent pages,
3741                  // so we need to redraw the workspace when this may have changed.
3742                  invalidate();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3743 -                result = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3744 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3745 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3746 +            if (mDragTargetLayout != null &amp;&amp; mDragHasEnteredWorkspace) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3747 +                // Unmark the overlapping layout and re-enter the current layout</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3748 +                mDragTargetLayout = getCurrentDropLayout();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3749 +                mDragTargetLayout.onDragEnter();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3750 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3751 +            result = true;</span>
3752              mInScrollArea = false;
3753          }
3754          return result;
3755      }
3756  
3757      private void onResetScrollArea() {
3758          if (mDragTargetLayout != null) {
3759              // Unmark the overlapping layout
3760              mDragTargetLayout.setIsDragOverlapping(false);
3761  
3762              // Workspace is responsible for drawing the edge glow on adjacent pages,
3763              // so we need to redraw the workspace when this may have changed.
3764              invalidate();
3765          }
3766          mInScrollArea = false;
3767      }
3768  
3769      /**
3770       * Returns a specific CellLayout
3771       */
3772      CellLayout getParentCellLayoutForView(View v) {
3773          ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
3774          for (CellLayout layout : layouts) {
3775              if (layout.getChildrenLayout().indexOfChild(v) &gt; -1) {
3776                  return layout;
3777              }
3778          }
3779          return null;
3780      }
3781  
3782      /**
3783       * Returns a list of all the CellLayouts in the workspace.
3784       */
3785      ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
3786          ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
3787          int screenCount = getChildCount();
3788          for (int screen = 0; screen &lt; screenCount; screen++) {
3789              layouts.add(((CellLayout) getChildAt(screen)));
3790          }
3791          if (mLauncher.getHotseat() != null) {
3792              layouts.add(mLauncher.getHotseat().getLayout());
3793          }
3794          return layouts;
3795      }
3796  
3797      /**
3798       * We should only use this to search for specific children.  Do not use this method to modify
3799       * CellLayoutChildren directly.
3800       */
3801      ArrayList&lt;CellLayoutChildren&gt; getWorkspaceAndHotseatCellLayoutChildren() {
3802          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = new ArrayList&lt;CellLayoutChildren&gt;();
3803          int screenCount = getChildCount();
3804          for (int screen = 0; screen &lt; screenCount; screen++) {
3805              childrenLayouts.add(((CellLayout) getChildAt(screen)).getChildrenLayout());
3806          }
3807          if (mLauncher.getHotseat() != null) {
3808              childrenLayouts.add(mLauncher.getHotseat().getLayout().getChildrenLayout());
3809          }
3810          return childrenLayouts;
3811      }
3812  
3813      public Folder getFolderForTag(Object tag) {
3814          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3815          for (CellLayoutChildren layout: childrenLayouts) {
3816              int count = layout.getChildCount();
3817              for (int i = 0; i &lt; count; i++) {
3818                  View child = layout.getChildAt(i);
3819                  if (child instanceof Folder) {
3820                      Folder f = (Folder) child;
3821                      if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
3822                          return f;
3823                      }
3824                  }
3825              }
3826          }
3827          return null;
3828      }
3829  
3830      public View getViewForTag(Object tag) {
3831          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3832          for (CellLayoutChildren layout: childrenLayouts) {
3833              int count = layout.getChildCount();
3834              for (int i = 0; i &lt; count; i++) {
3835                  View child = layout.getChildAt(i);
3836                  if (child.getTag() == tag) {
3837                      return child;
3838                  }
3839              }
3840          }
3841          return null;
3842      }
3843  
3844      void clearDropTargets() {
3845          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3846          for (CellLayoutChildren layout: childrenLayouts) {
3847              int childCount = layout.getChildCount();
3848              for (int j = 0; j &lt; childCount; j++) {
3849                  View v = layout.getChildAt(j);
3850                  if (v instanceof DropTarget) {
3851                      mDragController.removeDropTarget((DropTarget) v);
3852                  }
3853              }
3854          }
3855      }
3856  
3857      void removeItems(final ArrayList&lt;ApplicationInfo&gt; apps) {
3858          final AppWidgetManager widgets = AppWidgetManager.getInstance(getContext());
3859  
3860          final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
3861          final int appCount = apps.size();
3862          for (int i = 0; i &lt; appCount; i++) {
3863              packageNames.add(apps.get(i).componentName.getPackageName());
3864          }
3865  
3866          ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
3867          for (final CellLayout layoutParent: cellLayouts) {
3868              final ViewGroup layout = layoutParent.getChildrenLayout();
3869  
3870              // Avoid ANRs by treating each screen separately
3871              post(new Runnable() {
3872                  public void run() {
3873                      final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
3874                      childrenToRemove.clear();
3875  
3876                      int childCount = layout.getChildCount();
3877                      for (int j = 0; j &lt; childCount; j++) {
3878                          final View view = layout.getChildAt(j);
3879                          Object tag = view.getTag();
3880  
3881                          if (tag instanceof ShortcutInfo) {
3882                              final ShortcutInfo info = (ShortcutInfo) tag;
3883                              final Intent intent = info.intent;
3884                              final ComponentName name = intent.getComponent();
3885  
3886                              if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3887                                  for (String packageName: packageNames) {
3888                                      if (packageName.equals(name.getPackageName())) {
3889                                          LauncherModel.deleteItemFromDatabase(mLauncher, info);
3890                                          childrenToRemove.add(view);
3891                                      }
3892                                  }
3893                              }
3894                          } else if (tag instanceof FolderInfo) {
3895                              final FolderInfo info = (FolderInfo) tag;
3896                              final ArrayList&lt;ShortcutInfo&gt; contents = info.contents;
3897                              final int contentsCount = contents.size();
3898                              final ArrayList&lt;ShortcutInfo&gt; appsToRemoveFromFolder =
3899                                      new ArrayList&lt;ShortcutInfo&gt;();
3900  
3901                              for (int k = 0; k &lt; contentsCount; k++) {
3902                                  final ShortcutInfo appInfo = contents.get(k);
3903                                  final Intent intent = appInfo.intent;
3904                                  final ComponentName name = intent.getComponent();
3905  
3906                                  if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3907                                      for (String packageName: packageNames) {
3908                                          if (packageName.equals(name.getPackageName())) {
3909                                              appsToRemoveFromFolder.add(appInfo);
3910                                          }
3911                                      }
3912                                  }
3913                              }
3914                              for (ShortcutInfo item: appsToRemoveFromFolder) {
3915                                  info.remove(item);
3916                                  LauncherModel.deleteItemFromDatabase(mLauncher, item);
3917                              }
3918                          } else if (tag instanceof LauncherAppWidgetInfo) {
3919                              final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) tag;
3920                              final AppWidgetProviderInfo provider =
3921                                      widgets.getAppWidgetInfo(info.appWidgetId);
3922                              if (provider != null) {
3923                                  for (String packageName: packageNames) {
3924                                      if (packageName.equals(provider.provider.getPackageName())) {
3925                                          LauncherModel.deleteItemFromDatabase(mLauncher, info);
3926                                          childrenToRemove.add(view);
3927                                      }
3928                                  }
3929                              }
3930                          }
3931                      }
3932  
3933                      childCount = childrenToRemove.size();
3934                      for (int j = 0; j &lt; childCount; j++) {
3935                          View child = childrenToRemove.get(j);
3936                          // Note: We can not remove the view directly from CellLayoutChildren as this
3937                          // does not re-mark the spaces as unoccupied.
3938                          layoutParent.removeViewInLayout(child);
3939                          if (child instanceof DropTarget) {
3940                              mDragController.removeDropTarget((DropTarget)child);
3941                          }
3942                      }
3943  
3944                      if (childCount &gt; 0) {
3945                          layout.requestLayout();
3946                          layout.invalidate();
3947                      }
3948                  }
3949              });
3950          }
3951      }
3952  
3953      void updateShortcuts(ArrayList&lt;ApplicationInfo&gt; apps) {
3954          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3955          for (CellLayoutChildren layout: childrenLayouts) {
3956              int childCount = layout.getChildCount();
3957              for (int j = 0; j &lt; childCount; j++) {
3958                  final View view = layout.getChildAt(j);
3959                  Object tag = view.getTag();
3960                  if (tag instanceof ShortcutInfo) {
3961                      ShortcutInfo info = (ShortcutInfo)tag;
3962                      // We need to check for ACTION_MAIN otherwise getComponent() might
3963                      // return null for some shortcuts (for instance, for shortcuts to
3964                      // web pages.)
3965                      final Intent intent = info.intent;
3966                      final ComponentName name = intent.getComponent();
3967                      if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3968                              Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3969                          final int appCount = apps.size();
3970                          for (int k = 0; k &lt; appCount; k++) {
3971                              ApplicationInfo app = apps.get(k);
3972                              if (app.componentName.equals(name)) {
3973                                  info.setIcon(mIconCache.getIcon(info.intent));
3974                                  ((TextView)view).setCompoundDrawablesWithIntrinsicBounds(null,
3975                                          new FastBitmapDrawable(info.getIcon(mIconCache)),
3976                                          null, null);
3977                                  }
3978                          }
3979                      }
3980                  }
3981              }
3982          }
3983      }
3984  
3985      void moveToDefaultScreen(boolean animate) {
3986          if (!isSmall()) {
3987              if (animate) {
3988                  snapToPage(mDefaultPage);
3989              } else {
3990                  setCurrentPage(mDefaultPage);
3991              }
3992          }
3993          getChildAt(mDefaultPage).requestFocus();
3994      }
3995  
3996      @Override
3997      public void syncPages() {
3998      }
3999  
4000      @Override
4001      public void syncPageItems(int page, boolean immediate) {
4002      }
4003  
4004      @Override
4005      protected String getCurrentPageDescription() {
4006          int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
4007          return String.format(mContext.getString(R.string.workspace_scroll_format),
4008                  page + 1, getChildCount());
4009      }
4010  
4011      public void getLocationInDragLayer(int[] loc) {
4012          mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
4013      }
4014  
4015      void setFadeForOverScroll(float fade) {
4016          if (!isScrollingIndicatorEnabled()) return;
4017  
4018          mOverscrollFade = fade;
4019          float reducedFade = 0.5f + 0.5f * (1 - fade);
4020          final ViewGroup parent = (ViewGroup) getParent();
4021          final ImageView qsbDivider = (ImageView) (parent.findViewById(R.id.qsb_divider));
4022          final ImageView dockDivider = (ImageView) (parent.findViewById(R.id.dock_divider));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4023 -        final ImageView scrollIndicator = getScrollingIndicator();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4024 +        final View scrollIndicator = getScrollingIndicator();</span>
4025  
4026          cancelScrollingIndicatorAnimations();
4027          if (qsbDivider != null) qsbDivider.setAlpha(reducedFade);
4028          if (dockDivider != null) dockDivider.setAlpha(reducedFade);
4029          scrollIndicator.setAlpha(1 - fade);
4030      }
4031  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.Animator;
  20  import android.animation.Animator.AnimatorListener;
  21  import android.animation.AnimatorListenerAdapter;
  22  import android.animation.AnimatorSet;
  23  import android.animation.ObjectAnimator;
  24  import android.animation.TimeInterpolator;
  25  import android.animation.ValueAnimator;
  26  import android.animation.ValueAnimator.AnimatorUpdateListener;
  27  import android.app.AlertDialog;
  28  import android.app.WallpaperManager;
  29  import android.appwidget.AppWidgetHostView;
  30  import android.appwidget.AppWidgetManager;
  31  import android.appwidget.AppWidgetProviderInfo;
  32  import android.content.ClipData;
  33  import android.content.ClipDescription;
  34  import android.content.ComponentName;
  35  import android.content.Context;
  36  import android.content.Intent;
  37  import android.content.res.Resources;
  38  import android.content.res.TypedArray;
  39  import android.graphics.Bitmap;
  40  import android.graphics.Camera;
  41  import android.graphics.Canvas;
  42  import android.graphics.Matrix;
  43  import android.graphics.Paint;
  44  import android.graphics.Point;
  45  import android.graphics.PorterDuff;
  46  import android.graphics.Rect;
  47  import android.graphics.RectF;
  48  import android.graphics.Region.Op;
  49  import android.graphics.drawable.Drawable;
  50  import android.os.IBinder;
  51  import android.os.Parcelable;
  52  import android.util.AttributeSet;
  53  import android.util.DisplayMetrics;
  54  import android.util.Log;
  55  import android.util.Pair;
  56  import android.view.Display;
  57  import android.view.DragEvent;
  58  import android.view.MotionEvent;
  59  import android.view.View;
  60  import android.view.ViewConfiguration;
  61  import android.view.ViewGroup;


  62  import android.view.animation.DecelerateInterpolator;
  63  import android.widget.ImageView;
  64  import android.widget.TextView;
  65  import android.widget.Toast;
  66  
  67  import com.android.launcher.R;
  68  import com.android.launcher2.FolderIcon.FolderRingAnimator;
  69  import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  70  
  71  import java.util.ArrayList;
  72  import java.util.HashSet;
  73  import java.util.List;
  74  
  75  /**
  76   * The workspace is a wide area with a wallpaper and a finite number of pages.
  77   * Each page contains a number of icons, folders or widgets the user can
  78   * interact with. A workspace is meant to be used with a fixed width only.
  79   */
  80  public class Workspace extends SmoothPagedView
  81          implements DropTarget, DragSource, DragScroller, View.OnTouchListener,
  82          DragController.DragListener {

  83      @SuppressWarnings({&quot;UnusedDeclaration&quot;})
  84      private static final String TAG = &quot;Launcher.Workspace&quot;;
  85  
  86      // Y rotation to apply to the workspace screens
  87      private static final float WORKSPACE_ROTATION = 12.5f;
  88      private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  89      private static float CAMERA_DISTANCE = 6500;
  90  
  91      private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  92      private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  93      private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  94  
  95      private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  96      private static final int ADJACENT_SCREEN_DROP_DURATION = 300;

  97  
  98      // These animators are used to fade the children&#x27;s outlines
  99      private ObjectAnimator mChildrenOutlineFadeInAnimation;
 100      private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 101      private float mChildrenOutlineAlpha = 0;
 102  
 103      // These properties refer to the background protection gradient used for AllApps and Customize
 104      private ValueAnimator mBackgroundFadeInAnimation;
 105      private ValueAnimator mBackgroundFadeOutAnimation;
 106      private Drawable mBackground;
 107      boolean mDrawBackground = true;
 108      private float mBackgroundAlpha = 0;
 109      private float mOverScrollMaxBackgroundAlpha = 0.0f;
 110      private int mOverScrollPageIndex = -1;
 111  
 112      private float mWallpaperScrollRatio = 1.0f;
 113  
 114      private final WallpaperManager mWallpaperManager;
 115      private IBinder mWindowToken;
 116      private static final float WALLPAPER_SCREENS_SPAN = 2f;
 117  
 118      private int mDefaultPage;
 119  
 120      /**
 121       * CellInfo for the cell that is currently being dragged
 122       */
 123      private CellLayout.CellInfo mDragInfo;
 124  
 125      /**
 126       * Target drop area calculated during last acceptDrop call.
 127       */
 128      private int[] mTargetCell = new int[2];
 129  
 130      /**
 131       * The CellLayout that is currently being dragged over
 132       */
 133      private CellLayout mDragTargetLayout = null;

 134  
 135      private Launcher mLauncher;
 136      private IconCache mIconCache;
 137      private DragController mDragController;
 138  
 139      // These are temporary variables to prevent having to allocate a new object just to
 140      // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 141      private int[] mTempCell = new int[2];
 142      private int[] mTempEstimate = new int[2];
 143      private float[] mDragViewVisualCenter = new float[2];
 144      private float[] mTempDragCoordinates = new float[2];
 145      private float[] mTempCellLayoutCenterCoordinates = new float[2];
 146      private float[] mTempDragBottomRightCoordinates = new float[2];
 147      private Matrix mTempInverseMatrix = new Matrix();
 148  
 149      private SpringLoadedDragController mSpringLoadedDragController;
 150      private float mSpringLoadedShrinkFactor;
 151  
 152      private static final int DEFAULT_CELL_COUNT_X = 4;
 153      private static final int DEFAULT_CELL_COUNT_Y = 4;
 154  
 155      // State variable that indicates whether the pages are small (ie when you&#x27;re
 156      // in all apps or customize mode)
 157  
 158      enum State { NORMAL, SPRING_LOADED, SMALL };
 159      private State mState = State.NORMAL;
 160      private boolean mIsSwitchingState = false;
 161      private boolean mSwitchStateAfterFirstLayout = false;
 162      private State mStateAfterFirstLayout;
 163  
 164      private AnimatorSet mAnimator;
 165      private AnimatorListener mChangeStateAnimationListener;
 166  
 167      boolean mAnimatingViewIntoPlace = false;
 168      boolean mIsDragOccuring = false;
 169      boolean mChildrenLayersEnabled = true;
 170  
 171      /** Is the user is dragging an item near the edge of a page? */
 172      private boolean mInScrollArea = false;
 173  
 174      private final HolographicOutlineHelper mOutlineHelper = new HolographicOutlineHelper();
 175      private Bitmap mDragOutline = null;
 176      private final Rect mTempRect = new Rect();
 177      private final int[] mTempXY = new int[2];
 178      private int mDragViewMultiplyColor;
 179      private float mOverscrollFade = 0;

 180  
 181      // Paint used to draw external drop outline
 182      private final Paint mExternalDragOutlinePaint = new Paint();
 183  
 184      // Camera and Matrix used to determine the final position of a neighboring CellLayout
 185      private final Matrix mMatrix = new Matrix();
 186      private final Camera mCamera = new Camera();
 187      private final float mTempFloat2[] = new float[2];
 188  
 189      enum WallpaperVerticalOffset { TOP, MIDDLE, BOTTOM };
 190      int mWallpaperWidth;
 191      int mWallpaperHeight;
 192      WallpaperOffsetInterpolator mWallpaperOffset;
 193      boolean mUpdateWallpaperOffsetImmediately = false;
 194      private Runnable mDelayedResizeRunnable;
 195      private int mDisplayWidth;
 196      private int mDisplayHeight;

 197      private int mWallpaperTravelWidth;
 198  
 199      // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 200      private static final int FOLDER_CREATION_TIMEOUT = 250;
 201      private final Alarm mFolderCreationAlarm = new Alarm();
 202      private FolderRingAnimator mDragFolderRingAnimator = null;
 203      private View mLastDragOverView = null;
 204      private boolean mCreateUserFolderOnDrop = false;
 205  
 206      // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 207      private float mXDown;
 208      private float mYDown;
 209      final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 210      final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 211      final static float TOUCH_SLOP_DAMPING_FACTOR = 4;











 212  
 213      // These variables are used for storing the initial and final values during workspace animations
 214      private int mSavedScrollX;
 215      private float mSavedRotationY;
 216      private float mSavedTranslationX;
 217      private float mCurrentScaleX;
 218      private float mCurrentScaleY;
 219      private float mCurrentRotationY;
 220      private float mCurrentTranslationX;
 221      private float mCurrentTranslationY;
 222      private float[] mOldTranslationXs;
 223      private float[] mOldTranslationYs;
 224      private float[] mOldScaleXs;
 225      private float[] mOldScaleYs;
 226      private float[] mOldBackgroundAlphas;
 227      private float[] mOldBackgroundAlphaMultipliers;
 228      private float[] mOldAlphas;
 229      private float[] mOldRotationYs;
 230      private float[] mNewTranslationXs;
 231      private float[] mNewTranslationYs;
 232      private float[] mNewScaleXs;
 233      private float[] mNewScaleYs;
 234      private float[] mNewBackgroundAlphas;
 235      private float[] mNewBackgroundAlphaMultipliers;
 236      private float[] mNewAlphas;
 237      private float[] mNewRotationYs;
 238      private float mTransitionProgress;
 239  
 240      /**
 241       * Used to inflate the Workspace from XML.
 242       *
 243       * @param context The application&#x27;s context.
 244       * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 245       */
 246      public Workspace(Context context, AttributeSet attrs) {
 247          this(context, attrs, 0);
 248      }
 249  
 250      /**
 251       * Used to inflate the Workspace from XML.
 252       *
 253       * @param context The application&#x27;s context.
 254       * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 255       * @param defStyle Unused.
 256       */
 257      public Workspace(Context context, AttributeSet attrs, int defStyle) {
 258          super(context, attrs, defStyle);
 259          mContentIsRefreshable = false;
 260  
 261          // With workspace, data is available straight from the get-go
 262          setDataIsReady();
 263  
 264          mFadeInAdjacentScreens =
 265              getResources().getBoolean(R.bool.config_workspaceFadeAdjacentScreens);




 266          mWallpaperManager = WallpaperManager.getInstance(context);
 267  
 268          int cellCountX = DEFAULT_CELL_COUNT_X;
 269          int cellCountY = DEFAULT_CELL_COUNT_Y;
 270  
 271          TypedArray a = context.obtainStyledAttributes(attrs,
 272                  R.styleable.Workspace, defStyle, 0);
 273  
 274          final Resources res = context.getResources();
 275          if (LauncherApplication.isScreenLarge()) {
 276              // Determine number of rows/columns dynamically
 277              // TODO: This code currently fails on tablets with an aspect ratio &lt; 1.3.
 278              // Around that ratio we should make cells the same size in portrait and
 279              // landscape
 280              TypedArray actionBarSizeTypedArray =
 281                  context.obtainStyledAttributes(new int[] { android.R.attr.actionBarSize });
 282              DisplayMetrics displayMetrics = res.getDisplayMetrics();
 283              final float actionBarHeight = actionBarSizeTypedArray.getDimension(0, 0f);
 284              final float systemBarHeight = res.getDimension(R.dimen.status_bar_height);
 285              final float smallestScreenDim = res.getConfiguration().smallestScreenWidthDp *
 286                      displayMetrics.density;
 287  
 288              cellCountX = 1;
 289              while (CellLayout.widthInPortrait(res, cellCountX + 1) &lt;= smallestScreenDim) {
 290                  cellCountX++;
 291              }
 292  
 293              cellCountY = 1;
 294              while (actionBarHeight + CellLayout.heightInLandscape(res, cellCountY + 1)
 295                  &lt;= smallestScreenDim - systemBarHeight) {
 296                  cellCountY++;
 297              }
 298          }
 299  
 300          mSpringLoadedShrinkFactor =
 301              res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0f;
 302          mDragViewMultiplyColor = res.getColor(R.color.drag_view_multiply_color);
 303  
 304          // if the value is manually specified, use that instead
 305          cellCountX = a.getInt(R.styleable.Workspace_cellCountX, cellCountX);
 306          cellCountY = a.getInt(R.styleable.Workspace_cellCountY, cellCountY);
 307          mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 308          a.recycle();
 309  
 310          LauncherModel.updateWorkspaceLayoutCells(cellCountX, cellCountY);
 311          setHapticFeedbackEnabled(false);
 312  
 313          mLauncher = (Launcher) context;
 314          initWorkspace();
 315  
 316          // Disable multitouch across the workspace/all apps/customize tray
 317          setMotionEventSplittingEnabled(true);
 318      }
 319  
 320      // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 321      // dimension if unsuccessful
 322      public int[] estimateItemSize(int hSpan, int vSpan,
 323              PendingAddItemInfo pendingItemInfo, boolean springLoaded) {

 324          int[] size = new int[2];
 325          if (getChildCount() &gt; 0) {
 326              CellLayout cl = (CellLayout) mLauncher.getWorkspace().getChildAt(0);
 327              RectF r = estimateItemPosition(cl, pendingItemInfo, 0, 0, hSpan, vSpan);
 328              size[0] = (int) r.width();
 329              size[1] = (int) r.height();



 330              if (springLoaded) {
 331                  size[0] *= mSpringLoadedShrinkFactor;
 332                  size[1] *= mSpringLoadedShrinkFactor;
 333              }
 334              return size;
 335          } else {
 336              size[0] = Integer.MAX_VALUE;
 337              size[1] = Integer.MAX_VALUE;
 338              return size;
 339          }
 340      }
 341      public RectF estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,

 342              int hCell, int vCell, int hSpan, int vSpan) {
 343          RectF r = new RectF();

 344          cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 345          if (pendingInfo instanceof PendingAddWidgetInfo) {
 346              PendingAddWidgetInfo widgetInfo = (PendingAddWidgetInfo) pendingInfo;
 347              Rect p = AppWidgetHostView.getDefaultPaddingForWidget(mContext,
 348                      widgetInfo.componentName, null);
 349              r.top += p.top;
 350              r.left += p.left;
 351              r.right -= p.right;
 352              r.bottom -= p.bottom;
 353          }
 354          return r;
 355      }
 356  
 357      public void buildPageHardwareLayers() {
 358          if (getWindowToken() != null) {
 359              final int childCount = getChildCount();
 360              for (int i = 0; i &lt; childCount; i++) {
 361                  CellLayout cl = (CellLayout) getChildAt(i);
 362                  cl.buildChildrenLayer();
 363              }
 364          }
 365      }
 366  
 367      public void onDragStart(DragSource source, Object info, int dragAction) {
 368          mIsDragOccuring = true;
 369          updateChildrenLayersEnabled();
 370          mLauncher.lockScreenOrientationOnLargeUI();










 371      }
 372  
 373      public void onDragEnd() {
 374          mIsDragOccuring = false;
 375          updateChildrenLayersEnabled();
 376          mLauncher.unlockScreenOrientationOnLargeUI();










 377      }
 378  
 379      /**
 380       * Initializes various states for this workspace.
 381       */
 382      protected void initWorkspace() {
 383          Context context = getContext();
 384          mCurrentPage = mDefaultPage;
 385          Launcher.setScreen(mCurrentPage);
 386          LauncherApplication app = (LauncherApplication)context.getApplicationContext();
 387          mIconCache = app.getIconCache();
 388          mExternalDragOutlinePaint.setAntiAlias(true);
 389          setWillNotDraw(false);
 390          setChildrenDrawnWithCacheEnabled(true);
 391  
 392          try {
 393              final Resources res = getResources();
 394              mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 395          } catch (Resources.NotFoundException e) {
 396              // In this case, we will skip drawing background protection
 397          }
 398  
 399          mChangeStateAnimationListener = new AnimatorListenerAdapter() {
 400              @Override
 401              public void onAnimationStart(Animator animation) {
 402                  mIsSwitchingState = true;
 403              }
 404  
 405              @Override
 406              public void onAnimationEnd(Animator animation) {
 407                  mIsSwitchingState = false;
 408                  mWallpaperOffset.setOverrideHorizontalCatchupConstant(false);
 409                  mAnimator = null;
 410                  updateChildrenLayersEnabled();
 411              }
 412          };
 413  
 414          mSnapVelocity = 600;
 415          mWallpaperOffset = new WallpaperOffsetInterpolator();
 416          Display display = mLauncher.getWindowManager().getDefaultDisplay();
 417          mDisplayWidth = display.getWidth();
 418          mDisplayHeight = display.getHeight();
 419          mWallpaperTravelWidth = (int) (mDisplayWidth *
 420                  wallpaperTravelToScreenWidthRatio(mDisplayWidth, mDisplayHeight));



 421      }
 422  
 423      @Override
 424      protected int getScrollMode() {
 425          return SmoothPagedView.X_LARGE_MODE;
 426      }
 427  
 428      @Override
 429      protected void onViewAdded(View child) {
 430          super.onViewAdded(child);
 431          if (!(child instanceof CellLayout)) {
 432              throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 433          }
 434          CellLayout cl = ((CellLayout) child);
 435          cl.setOnInterceptTouchListener(this);
 436          cl.setClickable(true);
 437          cl.enableHardwareLayers();
 438      }
 439  
 440      /**
 441       * @return The open folder on the current screen, or null if there is none
 442       */
 443      Folder getOpenFolder() {
 444          DragLayer dragLayer = mLauncher.getDragLayer();
 445          int count = dragLayer.getChildCount();
 446          for (int i = 0; i &lt; count; i++) {
 447              View child = dragLayer.getChildAt(i);
 448              if (child instanceof Folder) {
 449                  Folder folder = (Folder) child;
 450                  if (folder.getInfo().opened)
 451                      return folder;
 452              }
 453          }
 454          return null;
 455      }
 456  
 457      boolean isTouchActive() {
 458          return mTouchState != TOUCH_STATE_REST;
 459      }
 460  
 461      /**
 462       * Adds the specified child in the specified screen. The position and dimension of
 463       * the child are defined by x, y, spanX and spanY.
 464       *
 465       * @param child The child to add in one of the workspace&#x27;s screens.
 466       * @param screen The screen in which to add the child.
 467       * @param x The X position of the child in the screen&#x27;s grid.
 468       * @param y The Y position of the child in the screen&#x27;s grid.
 469       * @param spanX The number of cells spanned horizontally by the child.
 470       * @param spanY The number of cells spanned vertically by the child.
 471       */
 472      void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY) {
 473          addInScreen(child, container, screen, x, y, spanX, spanY, false);
 474      }
 475  
 476      /**
 477       * Adds the specified child in the specified screen. The position and dimension of
 478       * the child are defined by x, y, spanX and spanY.
 479       *
 480       * @param child The child to add in one of the workspace&#x27;s screens.
 481       * @param screen The screen in which to add the child.
 482       * @param x The X position of the child in the screen&#x27;s grid.
 483       * @param y The Y position of the child in the screen&#x27;s grid.
 484       * @param spanX The number of cells spanned horizontally by the child.
 485       * @param spanY The number of cells spanned vertically by the child.
 486       * @param insert When true, the child is inserted at the beginning of the children list.
 487       */
 488      void addInScreen(View child, long container, int screen, int x, int y, int spanX, int spanY,
 489              boolean insert) {
 490          if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 491              if (screen &lt; 0 || screen &gt;= getChildCount()) {
 492                  Log.e(TAG, &quot;The screen must be &gt;= 0 and &lt; &quot; + getChildCount()
 493                      + &quot; (was &quot; + screen + &quot;); skipping child&quot;);
 494                  return;
 495              }
 496          }
 497  
 498          final CellLayout layout;
 499          if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 500              layout = mLauncher.getHotseat().getLayout();
 501              child.setOnKeyListener(null);
 502  
 503              // Hide folder title in the hotseat
 504              if (child instanceof FolderIcon) {
 505                  ((FolderIcon) child).setTextVisible(false);
 506              }
 507  
 508              if (screen &lt; 0) {
 509                  screen = mLauncher.getHotseat().getOrderInHotseat(x, y);
 510              } else {
 511                  // Note: We do this to ensure that the hotseat is always laid out in the orientation
 512                  // of the hotseat in order regardless of which orientation they were added
 513                  x = mLauncher.getHotseat().getCellXFromOrder(screen);
 514                  y = mLauncher.getHotseat().getCellYFromOrder(screen);
 515              }
 516          } else {
 517              // Show folder title if not in the hotseat
 518              if (child instanceof FolderIcon) {
 519                  ((FolderIcon) child).setTextVisible(true);
 520              }
 521  
 522              layout = (CellLayout) getChildAt(screen);
 523              child.setOnKeyListener(new IconKeyEventListener());
 524          }
 525  
 526          CellLayout.LayoutParams lp = (CellLayout.LayoutParams) child.getLayoutParams();
 527          if (lp == null) {



 528              lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 529          } else {

 530              lp.cellX = x;
 531              lp.cellY = y;
 532              lp.cellHSpan = spanX;
 533              lp.cellVSpan = spanY;
 534          }
 535  
 536          if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) {
 537              lp.isLockedToGrid = false;
 538          }
 539  
 540          // Get the canonical child id to uniquely represent this view in this screen
 541          int childId = LauncherModel.getCellLayoutChildId(container, screen, x, y, spanX, spanY);
 542          boolean markCellsAsOccupied = !(child instanceof Folder);
 543          if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 544              // TODO: This branch occurs when the workspace is adding views
 545              // outside of the defined grid
 546              // maybe we should be deleting these items from the LauncherModel?
 547              Log.w(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;);
 548          }
 549  
 550          if (!(child instanceof Folder)) {
 551              child.setHapticFeedbackEnabled(false);
 552              child.setOnLongClickListener(mLongClickListener);
 553          }
 554          if (child instanceof DropTarget) {
 555              mDragController.addDropTarget((DropTarget) child);
 556          }
 557      }
 558  
 559      /**
 560       * Check if the point (x, y) hits a given page.
 561       */
 562      private boolean hitsPage(int index, float x, float y) {
 563          final View page = getChildAt(index);
 564          if (page != null) {
 565              float[] localXY = { x, y };
 566              mapPointFromSelfToChild(page, localXY);
 567              return (localXY[0] &gt;= 0 &amp;&amp; localXY[0] &lt; page.getWidth()
 568                      &amp;&amp; localXY[1] &gt;= 0 &amp;&amp; localXY[1] &lt; page.getHeight());
 569          }
 570          return false;
 571      }
 572  
 573      @Override
 574      protected boolean hitsPreviousPage(float x, float y) {
 575          // mNextPage is set to INVALID_PAGE whenever we are stationary.
 576          // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 577          final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 578  
 579          // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 580          // the active workspace
 581          return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current - 1, x, y);
 582      }
 583  
 584      @Override
 585      protected boolean hitsNextPage(float x, float y) {
 586          // mNextPage is set to INVALID_PAGE whenever we are stationary.
 587          // Calculating &quot;next page&quot; this way ensures that you scroll to whatever page you tap on
 588          final int current = (mNextPage == INVALID_PAGE) ? mCurrentPage : mNextPage;
 589  
 590          // Only allow tap to next page on large devices, where there&#x27;s significant margin outside
 591          // the active workspace
 592          return LauncherApplication.isScreenLarge() &amp;&amp; hitsPage(current + 1, x, y);
 593      }
 594  
 595      /**
 596       * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 597       * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 598       * that it should intercept touch events, which is not something that is normally supported.
 599       */
 600      @Override
 601      public boolean onTouch(View v, MotionEvent event) {
 602          return (isSmall() || mIsSwitchingState);

 603      }
 604  
 605      public boolean isSwitchingState() {
 606          return mIsSwitchingState;
 607      }
 608  






 609      protected void onWindowVisibilityChanged (int visibility) {
 610          mLauncher.onWindowVisibilityChanged(visibility);
 611      }
 612  
 613      @Override
 614      public boolean dispatchUnhandledMove(View focused, int direction) {
 615          if (isSmall() || mIsSwitchingState) {

 616              // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
 617              return false;
 618          }
 619          return super.dispatchUnhandledMove(focused, direction);
 620      }
 621  
 622      @Override
 623      public boolean onInterceptTouchEvent(MotionEvent ev) {
 624          switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
 625          case MotionEvent.ACTION_DOWN:
 626              mXDown = ev.getX();
 627              mYDown = ev.getY();
 628              break;
 629          case MotionEvent.ACTION_POINTER_UP:
 630          case MotionEvent.ACTION_UP:
 631              if (mTouchState == TOUCH_STATE_REST) {
 632                  final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
 633                  if (!currentPage.lastDownOnOccupiedCell()) {
 634                      onWallpaperTap(ev);
 635                  }
 636              }
 637          }
 638          return super.onInterceptTouchEvent(ev);
 639      }
 640  
 641      @Override
 642      protected void determineScrollingStart(MotionEvent ev) {
 643          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
 644              float deltaX = Math.abs(ev.getX() - mXDown);
 645              float deltaY = Math.abs(ev.getY() - mYDown);
 646  
 647              if (Float.compare(deltaX, 0f) == 0) return;
 648  
 649              float slope = deltaY / deltaX;
 650              float theta = (float) Math.atan(slope);
 651  
 652              if (deltaX &gt; mTouchSlop || deltaY &gt; mTouchSlop) {
 653                  cancelCurrentPageLongPress();
 654              }
 655  
 656              if (theta &gt; MAX_SWIPE_ANGLE) {
 657                  // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace
 658                  return;
 659              } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {
 660                  // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to
 661                  // increase the touch slop to make it harder to begin scrolling the workspace. This
 662                  // results in vertically scrolling widgets to more easily. The higher the angle, the
 663                  // more we increase touch slop.
 664                  theta -= START_DAMPING_TOUCH_SLOP_ANGLE;
 665                  float extraRatio = (float)
 666                          Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));
 667                  super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);
 668              } else {
 669                  // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special
 670                  super.determineScrollingStart(ev);
 671              }






























 672          }
 673      }
 674  
 675      @Override
 676      protected boolean isScrollingIndicatorEnabled() {
 677          return mState != State.SPRING_LOADED;
 678      }
 679  
 680      protected void onPageBeginMoving() {
 681          super.onPageBeginMoving();
 682  
 683          if (isHardwareAccelerated()) {
 684              updateChildrenLayersEnabled();
 685          } else {
 686              if (mNextPage != INVALID_PAGE) {
 687                  // we&#x27;re snapping to a particular screen
 688                  enableChildrenCache(mCurrentPage, mNextPage);
 689              } else {
 690                  // this is when user is actively dragging a particular screen, they might
 691                  // swipe it either left or right (but we won&#x27;t advance by more than one screen)
 692                  enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
 693              }
 694          }
 695  
 696          // Only show page outlines as we pan if we are on large screen
 697          if (LauncherApplication.isScreenLarge()) {
 698              showOutlines();
 699          }













 700      }
 701  
 702      protected void onPageEndMoving() {
 703          super.onPageEndMoving();
 704  
 705          if (isHardwareAccelerated()) {
 706              updateChildrenLayersEnabled();
 707          } else {
 708              clearChildrenCache();
 709          }
 710  
 711          // Hide the outlines, as long as we&#x27;re not dragging
 712          if (!mDragController.dragging()) {
 713              // Only hide page outlines as we pan if we are on large screen









 714              if (LauncherApplication.isScreenLarge()) {
 715                  hideOutlines();





 716              }
 717          }
 718          mOverScrollMaxBackgroundAlpha = 0.0f;
 719          mOverScrollPageIndex = -1;
 720  
 721          if (mDelayedResizeRunnable != null) {
 722              mDelayedResizeRunnable.run();
 723              mDelayedResizeRunnable = null;
 724          }
 725      }
 726  
 727      @Override
 728      protected void notifyPageSwitchListener() {
 729          super.notifyPageSwitchListener();
 730          Launcher.setScreen(mCurrentPage);
 731      };
 732  
 733      // As a ratio of screen height, the total distance we want the parallax effect to span
 734      // horizontally
 735      private float wallpaperTravelToScreenWidthRatio(int width, int height) {
 736          float aspectRatio = width / (float) height;
 737  
 738          // At an aspect ratio of 16/10, the wallpaper parallax effect should span 1.5 * screen width
 739          // At an aspect ratio of 10/16, the wallpaper parallax effect should span 1.2 * screen width
 740          // We will use these two data points to extrapolate how much the wallpaper parallax effect
 741          // to span (ie travel) at any aspect ratio:
 742  
 743          final float ASPECT_RATIO_LANDSCAPE = 16/10f;
 744          final float ASPECT_RATIO_PORTRAIT = 10/16f;
 745          final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE = 1.5f;
 746          final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT = 1.2f;
 747  
 748          // To find out the desired width at different aspect ratios, we use the following two
 749          // formulas, where the coefficient on x is the aspect ratio (width/height):
 750          //   (16/10)x + y = 1.5
 751          //   (10/16)x + y = 1.2
 752          // We solve for x and y and end up with a final formula:
 753          final float x =
 754              (WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE - WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT) /
 755              (ASPECT_RATIO_LANDSCAPE - ASPECT_RATIO_PORTRAIT);
 756          final float y = WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT - x * ASPECT_RATIO_PORTRAIT;
 757          return x * aspectRatio + y;
 758      }
 759  
 760      // The range of scroll values for Workspace
 761      private int getScrollRange() {
 762          return getChildOffset(getChildCount() - 1) - getChildOffset(0);
 763      }
 764  
 765      protected void setWallpaperDimension() {
 766          DisplayMetrics displayMetrics = new DisplayMetrics();
 767          mLauncher.getWindowManager().getDefaultDisplay().getRealMetrics(displayMetrics);
 768          final int maxDim = Math.max(displayMetrics.widthPixels, displayMetrics.heightPixels);
 769          final int minDim = Math.min(displayMetrics.widthPixels, displayMetrics.heightPixels);
 770  
 771          // We need to ensure that there is enough extra space in the wallpaper for the intended
 772          // parallax effects
 773          if (LauncherApplication.isScreenLarge()) {
 774              mWallpaperWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
 775              mWallpaperHeight = maxDim;
 776          } else {
 777              mWallpaperWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
 778              mWallpaperHeight = maxDim;
 779          }
 780          new Thread(&quot;setWallpaperDimension&quot;) {
 781              public void run() {
 782                  mWallpaperManager.suggestDesiredDimensions(mWallpaperWidth, mWallpaperHeight);
 783              }
 784          }.start();
 785      }
 786  
 787      public void setVerticalWallpaperOffset(float offset) {
 788          mWallpaperOffset.setFinalY(offset);
 789      }
 790      public float getVerticalWallpaperOffset() {
 791          return mWallpaperOffset.getCurrY();
 792      }
 793      public void setHorizontalWallpaperOffset(float offset) {
 794          mWallpaperOffset.setFinalX(offset);
 795      }
 796      public float getHorizontalWallpaperOffset() {
 797          return mWallpaperOffset.getCurrX();
 798      }
 799  
 800      private float wallpaperOffsetForCurrentScroll() {
 801          // The wallpaper travel width is how far, from left to right, the wallpaper will move
 802          // at this orientation. On tablets in portrait mode we don&#x27;t move all the way to the
 803          // edges of the wallpaper, or otherwise the parallax effect would be too strong.
 804          int wallpaperTravelWidth = mWallpaperWidth;
 805          if (LauncherApplication.isScreenLarge()) {
 806              wallpaperTravelWidth = mWallpaperTravelWidth;
 807          }
 808  
 809          // Set wallpaper offset steps (1 / (number of screens - 1))
 810          mWallpaperManager.setWallpaperOffsetSteps(1.0f / (getChildCount() - 1), 1.0f);
 811  
 812          // For the purposes of computing the scrollRange and overScrollOffset, we assume
 813          // that mLayoutScale is 1. This means that when we&#x27;re in spring-loaded mode,
 814          // there&#x27;s no discrepancy between the wallpaper offset for a given page.
 815          float layoutScale = mLayoutScale;
 816          mLayoutScale = 1f;
 817          int scrollRange = getScrollRange();
 818  
 819          // Again, we adjust the wallpaper offset to be consistent between values of mLayoutScale
 820          float adjustedScrollX = Math.max(0, Math.min(mScrollX, mMaxScrollX));
 821          adjustedScrollX *= mWallpaperScrollRatio;
 822          mLayoutScale = layoutScale;
 823  
 824          float scrollProgress =
 825              adjustedScrollX / (float) scrollRange;
 826          float offsetInDips = wallpaperTravelWidth * scrollProgress +
 827              (mWallpaperWidth - wallpaperTravelWidth) / 2; // center it
 828          float offset = offsetInDips / (float) mWallpaperWidth;
 829          return offset;
 830      }
















 831      private void syncWallpaperOffsetWithScroll() {
 832          final boolean enableWallpaperEffects = isHardwareAccelerated();
 833          if (enableWallpaperEffects) {
 834              mWallpaperOffset.setFinalX(wallpaperOffsetForCurrentScroll());
 835          }
 836      }
 837  
 838      public void updateWallpaperOffsetImmediately() {
 839          mUpdateWallpaperOffsetImmediately = true;
 840      }
 841  
 842      private void updateWallpaperOffsets() {
 843          boolean updateNow = false;
 844          boolean keepUpdating = true;
 845          if (mUpdateWallpaperOffsetImmediately) {
 846              updateNow = true;
 847              keepUpdating = false;
 848              mWallpaperOffset.jumpToFinal();
 849              mUpdateWallpaperOffsetImmediately = false;
 850          } else {
 851              updateNow = keepUpdating = mWallpaperOffset.computeScrollOffset();
 852          }
 853          if (updateNow) {
 854              if (mWindowToken != null) {
 855                  mWallpaperManager.setWallpaperOffsets(mWindowToken,
 856                          mWallpaperOffset.getCurrX(), mWallpaperOffset.getCurrY());
 857              }
 858          }
 859          if (keepUpdating) {
 860              fastInvalidate();

 861          }
 862      }
 863  
 864      @Override
 865      protected void updateCurrentPageScroll() {
 866          super.updateCurrentPageScroll();
 867          computeWallpaperScrollRatio(mCurrentPage);
 868      }
 869  
 870      @Override
 871      protected void snapToPage(int whichPage) {
 872          super.snapToPage(whichPage);
 873          computeWallpaperScrollRatio(whichPage);
 874      }
 875  
 876      private void computeWallpaperScrollRatio(int page) {
 877          // Here, we determine what the desired scroll would be with and without a layout scale,
 878          // and compute a ratio between the two. This allows us to adjust the wallpaper offset
 879          // as though there is no layout scale.
 880          float layoutScale = mLayoutScale;
 881          int scaled = getChildOffset(page) - getRelativeChildOffset(page);
 882          mLayoutScale = 1.0f;
 883          float unscaled = getChildOffset(page) - getRelativeChildOffset(page);
 884          mLayoutScale = layoutScale;
 885          if (scaled &gt; 0) {
 886              mWallpaperScrollRatio = (1.0f * unscaled) / scaled;
 887          } else {
 888              mWallpaperScrollRatio = 1f;
 889          }
 890      }
 891  
 892      class WallpaperOffsetInterpolator {
 893          float mFinalHorizontalWallpaperOffset = 0.0f;
 894          float mFinalVerticalWallpaperOffset = 0.5f;
 895          float mHorizontalWallpaperOffset = 0.0f;
 896          float mVerticalWallpaperOffset = 0.5f;
 897          long mLastWallpaperOffsetUpdateTime;
 898          boolean mIsMovingFast;
 899          boolean mOverrideHorizontalCatchupConstant;
 900          float mHorizontalCatchupConstant = 0.35f;
 901          float mVerticalCatchupConstant = 0.35f;
 902  
 903          public WallpaperOffsetInterpolator() {
 904          }
 905  
 906          public void setOverrideHorizontalCatchupConstant(boolean override) {
 907              mOverrideHorizontalCatchupConstant = override;
 908          }
 909  
 910          public void setHorizontalCatchupConstant(float f) {
 911              mHorizontalCatchupConstant = f;
 912          }
 913  
 914          public void setVerticalCatchupConstant(float f) {
 915              mVerticalCatchupConstant = f;
 916          }
 917  
 918          public boolean computeScrollOffset() {
 919              if (Float.compare(mHorizontalWallpaperOffset, mFinalHorizontalWallpaperOffset) == 0 &amp;&amp;
 920                      Float.compare(mVerticalWallpaperOffset, mFinalVerticalWallpaperOffset) == 0) {
 921                  mIsMovingFast = false;
 922                  return false;
 923              }
 924              boolean isLandscape = mDisplayWidth &gt; mDisplayHeight;
 925  
 926              long currentTime = System.currentTimeMillis();
 927              long timeSinceLastUpdate = currentTime - mLastWallpaperOffsetUpdateTime;
 928              timeSinceLastUpdate = Math.min((long) (1000/30f), timeSinceLastUpdate);
 929              timeSinceLastUpdate = Math.max(1L, timeSinceLastUpdate);
 930  
 931              float xdiff = Math.abs(mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset);
 932              if (!mIsMovingFast &amp;&amp; xdiff &gt; 0.07) {
 933                  mIsMovingFast = true;
 934              }
 935  
 936              float fractionToCatchUpIn1MsHorizontal;
 937              if (mOverrideHorizontalCatchupConstant) {
 938                  fractionToCatchUpIn1MsHorizontal = mHorizontalCatchupConstant;
 939              } else if (mIsMovingFast) {
 940                  fractionToCatchUpIn1MsHorizontal = isLandscape ? 0.5f : 0.75f;
 941              } else {
 942                  // slow
 943                  fractionToCatchUpIn1MsHorizontal = isLandscape ? 0.27f : 0.5f;
 944              }
 945              float fractionToCatchUpIn1MsVertical = mVerticalCatchupConstant;
 946  
 947              fractionToCatchUpIn1MsHorizontal /= 33f;
 948              fractionToCatchUpIn1MsVertical /= 33f;
 949  
 950              final float UPDATE_THRESHOLD = 0.00001f;
 951              float hOffsetDelta = mFinalHorizontalWallpaperOffset - mHorizontalWallpaperOffset;
 952              float vOffsetDelta = mFinalVerticalWallpaperOffset - mVerticalWallpaperOffset;
 953              boolean jumpToFinalValue = Math.abs(hOffsetDelta) &lt; UPDATE_THRESHOLD &amp;&amp;
 954                  Math.abs(vOffsetDelta) &lt; UPDATE_THRESHOLD;
 955  
 956              // Don&#x27;t have any lag between workspace and wallpaper on non-large devices
 957              if (!LauncherApplication.isScreenLarge() || jumpToFinalValue) {
 958                  mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
 959                  mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
 960              } else {
 961                  float percentToCatchUpVertical =
 962                      Math.min(1.0f, timeSinceLastUpdate * fractionToCatchUpIn1MsVertical);
 963                  float percentToCatchUpHorizontal =
 964                      Math.min(1.0f, timeSinceLastUpdate * fractionToCatchUpIn1MsHorizontal);
 965                  mHorizontalWallpaperOffset += percentToCatchUpHorizontal * hOffsetDelta;
 966                  mVerticalWallpaperOffset += percentToCatchUpVertical * vOffsetDelta;
 967              }
 968  
 969              mLastWallpaperOffsetUpdateTime = System.currentTimeMillis();
 970              return true;
 971          }
 972  
 973          public float getCurrX() {
 974              return mHorizontalWallpaperOffset;
 975          }
 976  
 977          public float getFinalX() {
 978              return mFinalHorizontalWallpaperOffset;
 979          }
 980  
 981          public float getCurrY() {
 982              return mVerticalWallpaperOffset;
 983          }
 984  
 985          public float getFinalY() {
 986              return mFinalVerticalWallpaperOffset;
 987          }
 988  
 989          public void setFinalX(float x) {
 990              mFinalHorizontalWallpaperOffset = Math.max(0f, Math.min(x, 1.0f));
 991          }
 992  
 993          public void setFinalY(float y) {
 994              mFinalVerticalWallpaperOffset = Math.max(0f, Math.min(y, 1.0f));
 995          }
 996  
 997          public void jumpToFinal() {
 998              mHorizontalWallpaperOffset = mFinalHorizontalWallpaperOffset;
 999              mVerticalWallpaperOffset = mFinalVerticalWallpaperOffset;
1000          }
1001      }
1002  
1003      @Override
1004      public void computeScroll() {
1005          super.computeScroll();
1006          syncWallpaperOffsetWithScroll();
1007      }
1008  
1009      void showOutlines() {
1010          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1011              if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1012              if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1013              mChildrenOutlineFadeInAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);
1014              mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1015              mChildrenOutlineFadeInAnimation.start();
1016          }
1017      }
1018  
1019      void hideOutlines() {
1020          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1021              if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1022              if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1023              mChildrenOutlineFadeOutAnimation = ObjectAnimator.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);
1024              mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1025              mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1026              mChildrenOutlineFadeOutAnimation.start();
1027          }
1028      }
1029  
1030      public void showOutlinesTemporarily() {
1031          if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1032              snapToPage(mCurrentPage);
1033          }
1034      }
1035  
1036      public void setChildrenOutlineAlpha(float alpha) {
1037          mChildrenOutlineAlpha = alpha;
1038          for (int i = 0; i &lt; getChildCount(); i++) {
1039              CellLayout cl = (CellLayout) getChildAt(i);
1040              cl.setBackgroundAlpha(alpha);
1041          }
1042      }
1043  
1044      public float getChildrenOutlineAlpha() {
1045          return mChildrenOutlineAlpha;
1046      }
1047  
1048      void disableBackground() {
1049          mDrawBackground = false;
1050      }
1051      void enableBackground() {
1052          mDrawBackground = true;
1053      }
1054  
1055      private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1056          if (mBackground == null) return;
1057          if (mBackgroundFadeInAnimation != null) {
1058              mBackgroundFadeInAnimation.cancel();
1059              mBackgroundFadeInAnimation = null;
1060          }
1061          if (mBackgroundFadeOutAnimation != null) {
1062              mBackgroundFadeOutAnimation.cancel();
1063              mBackgroundFadeOutAnimation = null;
1064          }
1065          float startAlpha = getBackgroundAlpha();
1066          if (finalAlpha != startAlpha) {
1067              if (animated) {
1068                  mBackgroundFadeOutAnimation = ValueAnimator.ofFloat(startAlpha, finalAlpha);
1069                  mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1070                      public void onAnimationUpdate(ValueAnimator animation) {
1071                          setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1072                      }
1073                  });
1074                  mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1075                  mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1076                  mBackgroundFadeOutAnimation.start();
1077              } else {
1078                  setBackgroundAlpha(finalAlpha);
1079              }
1080          }
1081      }
1082  
1083      public void setBackgroundAlpha(float alpha) {
1084          if (alpha != mBackgroundAlpha) {
1085              mBackgroundAlpha = alpha;
1086              invalidate();
1087          }
1088      }
1089  
1090      public float getBackgroundAlpha() {
1091          return mBackgroundAlpha;
1092      }
1093  
1094      /**
1095       * Due to 3D transformations, if two CellLayouts are theoretically touching each other,
1096       * on the xy plane, when one is rotated along the y-axis, the gap between them is perceived
1097       * as being larger. This method computes what offset the rotated view should be translated
1098       * in order to minimize this perceived gap.
1099       * @param degrees Angle of the view
1100       * @param width Width of the view
1101       * @param height Height of the view
1102       * @return Offset to be used in a View.setTranslationX() call
1103       */
1104      private float getOffsetXForRotation(float degrees, int width, int height) {
1105          mMatrix.reset();
1106          mCamera.save();
1107          mCamera.rotateY(Math.abs(degrees));
1108          mCamera.getMatrix(mMatrix);
1109          mCamera.restore();
1110  
1111          mMatrix.preTranslate(-width * 0.5f, -height * 0.5f);
1112          mMatrix.postTranslate(width * 0.5f, height * 0.5f);
1113          mTempFloat2[0] = width;
1114          mTempFloat2[1] = height;
1115          mMatrix.mapPoints(mTempFloat2);
1116          return (width - mTempFloat2[0]) * (degrees &gt; 0.0f ? 1.0f : -1.0f);
1117      }
1118  
1119      float backgroundAlphaInterpolator(float r) {
1120          float pivotA = 0.1f;
1121          float pivotB = 0.4f;
1122          if (r &lt; pivotA) {
1123              return 0;
1124          } else if (r &gt; pivotB) {
1125              return 1.0f;
1126          } else {
1127              return (r - pivotA)/(pivotB - pivotA);
1128          }
1129      }
1130  
1131      float overScrollBackgroundAlphaInterpolator(float r) {
1132          float threshold = 0.08f;
1133  
1134          if (r &gt; mOverScrollMaxBackgroundAlpha) {
1135              mOverScrollMaxBackgroundAlpha = r;
1136          } else if (r &lt; mOverScrollMaxBackgroundAlpha) {
1137              r = mOverScrollMaxBackgroundAlpha;
1138          }
1139  
1140          return Math.min(r / threshold, 1.0f);
1141      }
1142  
1143      private void screenScrolledLargeUI(int screenCenter) {
1144          if (isSwitchingState()) return;
1145          boolean isInOverscroll = false;
1146          for (int i = 0; i &lt; getChildCount(); i++) {
1147              CellLayout cl = (CellLayout) getChildAt(i);
1148              if (cl != null) {
1149                  float scrollProgress = getScrollProgress(screenCenter, cl, i);
1150                  float rotation = WORKSPACE_ROTATION * scrollProgress;
1151                  float translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1152  
1153                  // If the current page (i) is being over scrolled, we use a different
1154                  // set of rules for setting the background alpha multiplier.
1155                  if (!isSmall()) {
1156                      if ((mOverScrollX &lt; 0 &amp;&amp; i == 0) || (mOverScrollX &gt; mMaxScrollX &amp;&amp;
1157                              i == getChildCount() -1)) {
1158                          isInOverscroll = true;
1159                          rotation *= -1;
1160                          cl.setBackgroundAlphaMultiplier(
1161                                  overScrollBackgroundAlphaInterpolator(Math.abs(scrollProgress)));
1162                          mOverScrollPageIndex = i;
1163                          cl.setOverScrollAmount(Math.abs(scrollProgress), i == 0);
1164                          cl.setPivotX(cl.getMeasuredWidth() * (i == 0 ? 0.75f : 0.25f));
1165                          cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1166                          cl.setOverscrollTransformsDirty(true);
1167                      } else if (mOverScrollPageIndex != i) {
1168                          cl.setBackgroundAlphaMultiplier(
1169                                  backgroundAlphaInterpolator(Math.abs(scrollProgress)));
1170                      }
1171                  }
1172                  cl.setFastTranslationX(translationX);
1173                  cl.setFastRotationY(rotation);


1174                  if (mFadeInAdjacentScreens &amp;&amp; !isSmall()) {
1175                      float alpha = 1 - Math.abs(scrollProgress);
1176                      cl.setFastAlpha(alpha);
1177                  }
1178                  cl.fastInvalidate();


1179              }
1180          }
1181          if (!isSwitchingState() &amp;&amp; !isInOverscroll) {
1182              ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1183              ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1184          }
1185          invalidate();
1186      }
1187  
1188      private void screenScrolledStandardUI(int screenCenter) {
1189          if (mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX) {
1190              int index = mOverScrollX &lt; 0 ? 0 : getChildCount() - 1;
1191              CellLayout cl = (CellLayout) getChildAt(index);
1192              float scrollProgress = getScrollProgress(screenCenter, cl, index);
1193              cl.setOverScrollAmount(Math.abs(scrollProgress), index == 0);
1194              float rotation = - WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1195              cl.setCameraDistance(mDensity * CAMERA_DISTANCE);
1196              cl.setPivotX(cl.getMeasuredWidth() * (index == 0 ? 0.75f : 0.25f));
1197              cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1198              cl.setRotationY(rotation);
1199              cl.setOverscrollTransformsDirty(true);
1200              setFadeForOverScroll(Math.abs(scrollProgress));
1201          } else {
1202              if (mOverscrollFade != 0) {
1203                  setFadeForOverScroll(0);
1204              }
1205              // We don&#x27;t want to mess with the translations during transitions
1206              if (!isSwitchingState()) {
1207                  ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1208                  ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1209              }
1210          }
1211      }
1212  
1213      @Override
1214      protected void screenScrolled(int screenCenter) {
1215          if (LauncherApplication.isScreenLarge()) {
1216              // We don&#x27;t call super.screenScrolled() here because we handle the adjacent pages alpha
1217              // ourselves (for efficiency), and there are no scrolling indicators to update.
1218              screenScrolledLargeUI(screenCenter);
1219          } else {
1220              super.screenScrolled(screenCenter);
1221              screenScrolledStandardUI(screenCenter);
1222          }
1223      }
1224  
1225      @Override
1226      protected void overScroll(float amount) {
1227          if (LauncherApplication.isScreenLarge()) {
1228              dampedOverScroll(amount);
1229          } else {
1230              acceleratedOverScroll(amount);
1231          }
1232      }
1233  
1234      protected void onAttachedToWindow() {
1235          super.onAttachedToWindow();
1236          mWindowToken = getWindowToken();
1237          computeScroll();
1238          mDragController.setWindowToken(mWindowToken);
1239      }
1240  
1241      protected void onDetachedFromWindow() {
1242          mWindowToken = null;
1243      }
1244  
1245      @Override
1246      protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1247          if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1248              mUpdateWallpaperOffsetImmediately = true;
1249          }
1250          super.onLayout(changed, left, top, right, bottom);
1251  
1252          // if shrinkToBottom() is called on initialization, it has to be deferred
1253          // until after the first call to onLayout so that it has the correct width
1254          if (mSwitchStateAfterFirstLayout) {
1255              mSwitchStateAfterFirstLayout = false;
1256              // shrink can trigger a synchronous onLayout call, so we
1257              // post this to avoid a stack overflow / tangled onLayout calls
1258              post(new Runnable() {
1259                  public void run() {
1260                      changeState(mStateAfterFirstLayout, false);
1261                  }
1262              });
1263          }
1264      }
1265  
1266      @Override
1267      protected void onDraw(Canvas canvas) {
1268          updateWallpaperOffsets();
1269  
1270          // Draw the background gradient if necessary
1271          if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1272              int alpha = (int) (mBackgroundAlpha * 255);
1273              mBackground.setAlpha(alpha);
1274              mBackground.setBounds(mScrollX, 0, mScrollX + getMeasuredWidth(),
1275                      getMeasuredHeight());
1276              mBackground.draw(canvas);
1277          }
1278  
1279          super.onDraw(canvas);
1280      }
1281  
1282      boolean isDrawingBackgroundGradient() {
1283          return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1284      }
1285  
1286      public void scrollTo (int x, int y) {
1287          super.scrollTo(x, y);
1288          syncChildrenLayersEnabledOnVisiblePages();
1289      }
1290  
1291      // This method just applies the value mChildrenLayersEnabled to all the pages that
1292      // will be rendered on the next frame.
1293      // We do this because calling setChildrenLayersEnabled on a view that&#x27;s not
1294      // visible/rendered causes slowdowns on some graphics cards
1295      private void syncChildrenLayersEnabledOnVisiblePages() {
1296          if (mChildrenLayersEnabled) {
1297              getVisiblePages(mTempVisiblePagesRange);
1298              final int leftScreen = mTempVisiblePagesRange[0];
1299              final int rightScreen = mTempVisiblePagesRange[1];
1300              if (leftScreen != -1 &amp;&amp; rightScreen != -1) {
1301                  for (int i = leftScreen; i &lt;= rightScreen; i++) {
1302                      ViewGroup page = (ViewGroup) getPageAt(i);
1303                      if (page.getVisibility() == VISIBLE &amp;&amp;
1304                              page.getAlpha() &gt; ViewConfiguration.ALPHA_THRESHOLD) {
1305                          ((ViewGroup)getPageAt(i)).setChildrenLayersEnabled(true);
1306                      }
1307                  }
1308              }
1309          }
1310      }
1311  
1312      @Override
1313      protected void dispatchDraw(Canvas canvas) {
1314          super.dispatchDraw(canvas);
1315  
1316          if (mInScrollArea &amp;&amp; !LauncherApplication.isScreenLarge()) {
1317              final int width = getWidth();
1318              final int height = getHeight();
1319              final int pageHeight = getChildAt(0).getHeight();
1320  
1321              // Set the height of the outline to be the height of the page
1322              final int offset = (height - pageHeight - mPaddingTop - mPaddingBottom) / 2;
1323              final int paddingTop = mPaddingTop + offset;
1324              final int paddingBottom = mPaddingBottom + offset;
1325  
1326              final CellLayout leftPage = (CellLayout) getChildAt(mCurrentPage - 1);
1327              final CellLayout rightPage = (CellLayout) getChildAt(mCurrentPage + 1);



1328  
1329              if (leftPage != null &amp;&amp; leftPage.getIsDragOverlapping()) {
1330                  final Drawable d = getResources().getDrawable(R.drawable.page_hover_left_holo);
1331                  d.setBounds(mScrollX, paddingTop, mScrollX + d.getIntrinsicWidth(),
1332                          height - paddingBottom);
1333                  d.draw(canvas);
1334              } else if (rightPage != null &amp;&amp; rightPage.getIsDragOverlapping()) {
1335                  final Drawable d = getResources().getDrawable(R.drawable.page_hover_right_holo);
1336                  d.setBounds(mScrollX + width - d.getIntrinsicWidth(), paddingTop, mScrollX + width,
1337                          height - paddingBottom);
1338                  d.draw(canvas);
1339              }
1340          }
1341      }
1342  
1343      @Override
1344      protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1345          if (!mLauncher.isAllAppsVisible()) {
1346              final Folder openFolder = getOpenFolder();
1347              if (openFolder != null) {
1348                  return openFolder.requestFocus(direction, previouslyFocusedRect);
1349              } else {
1350                  return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1351              }
1352          }
1353          return false;
1354      }
1355  
1356      @Override
1357      public int getDescendantFocusability() {
1358          if (isSmall()) {
1359              return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1360          }
1361          return super.getDescendantFocusability();
1362      }
1363  
1364      @Override
1365      public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1366          if (!mLauncher.isAllAppsVisible()) {
1367              final Folder openFolder = getOpenFolder();
1368              if (openFolder != null) {
1369                  openFolder.addFocusables(views, direction);
1370              } else {
1371                  super.addFocusables(views, direction, focusableMode);
1372              }
1373          }
1374      }
1375  
1376      public boolean isSmall() {
1377          return mState == State.SMALL || mState == State.SPRING_LOADED;
1378      }
1379  
1380      void enableChildrenCache(int fromPage, int toPage) {
1381          if (fromPage &gt; toPage) {
1382              final int temp = fromPage;
1383              fromPage = toPage;
1384              toPage = temp;
1385          }
1386  
1387          final int screenCount = getChildCount();
1388  
1389          fromPage = Math.max(fromPage, 0);
1390          toPage = Math.min(toPage, screenCount - 1);
1391  
1392          for (int i = fromPage; i &lt;= toPage; i++) {
1393              final CellLayout layout = (CellLayout) getChildAt(i);
1394              layout.setChildrenDrawnWithCacheEnabled(true);
1395              layout.setChildrenDrawingCacheEnabled(true);
1396          }
1397      }
1398  
1399      void clearChildrenCache() {
1400          final int screenCount = getChildCount();
1401          for (int i = 0; i &lt; screenCount; i++) {
1402              final CellLayout layout = (CellLayout) getChildAt(i);
1403              layout.setChildrenDrawnWithCacheEnabled(false);
1404              // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1405              if (!isHardwareAccelerated()) {
1406                  layout.setChildrenDrawingCacheEnabled(false);
1407              }
1408          }
1409      }
1410  
1411      private void updateChildrenLayersEnabled() {
1412          boolean small = isSmall() || mIsSwitchingState;
1413          boolean dragging = mAnimatingViewIntoPlace || mIsDragOccuring;
1414          boolean enableChildrenLayers = small || dragging || isPageMoving();
1415  
1416          if (enableChildrenLayers != mChildrenLayersEnabled) {
1417              mChildrenLayersEnabled = enableChildrenLayers;
1418              // calling setChildrenLayersEnabled on a view that&#x27;s not visible/rendered
1419              // causes slowdowns on some graphics cards, so we only disable it here and leave
1420              // the enabling to dispatchDraw
1421              if (!enableChildrenLayers) {
1422                  for (int i = 0; i &lt; getPageCount(); i++) {
1423                      ((ViewGroup)getChildAt(i)).setChildrenLayersEnabled(false);
1424                  }


1425              }
1426          }
1427      }
1428  
1429      protected void onWallpaperTap(MotionEvent ev) {
1430          final int[] position = mTempCell;
1431          getLocationOnScreen(position);
1432  
1433          int pointerIndex = ev.getActionIndex();
1434          position[0] += (int) ev.getX(pointerIndex);
1435          position[1] += (int) ev.getY(pointerIndex);
1436  
1437          mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1438                  ev.getAction() == MotionEvent.ACTION_UP
1439                          ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1440                  position[0], position[1], 0, null);
1441      }
1442  
1443      /*
1444       * This interpolator emulates the rate at which the perceived scale of an object changes
1445       * as its distance from a camera increases. When this interpolator is applied to a scale
1446       * animation on a view, it evokes the sense that the object is shrinking due to moving away
1447       * from the camera.
1448       */
1449      static class ZInterpolator implements TimeInterpolator {
1450          private float focalLength;
1451  
1452          public ZInterpolator(float foc) {
1453              focalLength = foc;
1454          }
1455  
1456          public float getInterpolation(float input) {
1457              return (1.0f - focalLength / (focalLength + input)) /
1458                  (1.0f - focalLength / (focalLength + 1.0f));
1459          }
1460      }
1461  
1462      /*
1463       * The exact reverse of ZInterpolator.
1464       */
1465      static class InverseZInterpolator implements TimeInterpolator {
1466          private ZInterpolator zInterpolator;
1467          public InverseZInterpolator(float foc) {
1468              zInterpolator = new ZInterpolator(foc);
1469          }
1470          public float getInterpolation(float input) {
1471              return 1 - zInterpolator.getInterpolation(1 - input);
1472          }
1473      }
1474  
1475      /*
1476       * ZInterpolator compounded with an ease-out.
1477       */
1478      static class ZoomOutInterpolator implements TimeInterpolator {
1479          private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75f);
1480          private final ZInterpolator zInterpolator = new ZInterpolator(0.13f);
1481  
1482          public float getInterpolation(float input) {
1483              return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1484          }
1485      }
1486  
1487      /*
1488       * InvereZInterpolator compounded with an ease-out.
1489       */
1490      static class ZoomInInterpolator implements TimeInterpolator {
1491          private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35f);
1492          private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0f);
1493  
1494          public float getInterpolation(float input) {
1495              return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1496          }
1497      }
1498  
1499      private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1500  
1501      /*
1502      *
1503      * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1504      * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1505      *
1506      * These methods mark the appropriate pages as accepting drops (which alters their visual
1507      * appearance).
1508      *
1509      */
1510      public void onDragStartedWithItem(View v) {
1511          final Canvas canvas = new Canvas();
1512  
1513          // We need to add extra padding to the bitmap to make room for the glow effect
1514          final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;
1515  
1516          // The outline is used to visualize where the item will land if dropped
1517          mDragOutline = createDragOutline(v, canvas, bitmapPadding);

1518      }
1519  
1520      public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, Paint alphaClipPaint) {
1521          final Canvas canvas = new Canvas();
1522  
1523          // We need to add extra padding to the bitmap to make room for the glow effect
1524          final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;
1525  
1526          int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1527  
1528          // The outline is used to visualize where the item will land if dropped
1529          mDragOutline = createDragOutline(b, canvas, bitmapPadding, size[0], size[1], alphaClipPaint);


1530      }
1531  
1532      // we call this method whenever a drag and drop in Launcher finishes, even if Workspace was
1533      // never dragged over
1534      public void onDragStopped(boolean success) {
1535          // In the success case, DragController has already called onDragExit()
1536          if (!success) {
1537              doDragExit(null);
1538          }
1539      }
1540  
1541      public void exitWidgetResizeMode() {
1542          DragLayer dragLayer = mLauncher.getDragLayer();
1543          dragLayer.clearAllResizeFrames();
1544      }
1545  
1546      private void initAnimationArrays() {
1547          final int childCount = getChildCount();
1548          if (mOldTranslationXs != null) return;
1549          mOldTranslationXs = new float[childCount];
1550          mOldTranslationYs = new float[childCount];
1551          mOldScaleXs = new float[childCount];
1552          mOldScaleYs = new float[childCount];
1553          mOldBackgroundAlphas = new float[childCount];
1554          mOldBackgroundAlphaMultipliers = new float[childCount];
1555          mOldAlphas = new float[childCount];
1556          mOldRotationYs = new float[childCount];
1557          mNewTranslationXs = new float[childCount];
1558          mNewTranslationYs = new float[childCount];
1559          mNewScaleXs = new float[childCount];
1560          mNewScaleYs = new float[childCount];
1561          mNewBackgroundAlphas = new float[childCount];
1562          mNewBackgroundAlphaMultipliers = new float[childCount];
1563          mNewAlphas = new float[childCount];
1564          mNewRotationYs = new float[childCount];
1565      }
1566  
1567      public void changeState(State shrinkState) {
1568          changeState(shrinkState, true);
1569      }
1570  
1571      void changeState(final State state, boolean animated) {
1572          changeState(state, animated, 0);
1573      }
1574  
1575      void changeState(final State state, boolean animated, int delay) {





1576          if (mState == state) {
1577              return;
1578          }
1579          if (mFirstLayout) {
1580              // (mFirstLayout == &quot;first layout has not happened yet&quot;)
1581              // cancel any pending shrinks that were set earlier
1582              mSwitchStateAfterFirstLayout = false;
1583              mStateAfterFirstLayout = state;
1584              return;

1585          }
1586  
1587          // Initialize animation arrays for the first time if necessary
1588          initAnimationArrays();
1589  
1590          // Cancel any running transition animations
1591          if (mAnimator != null) mAnimator.cancel();
1592          mAnimator = new AnimatorSet();

1593  
1594          // Stop any scrolling, move to the current page right away
1595          setCurrentPage((mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage);
1596  
1597          final State oldState = mState;
1598          final boolean oldStateIsNormal = (oldState == State.NORMAL);
1599          final boolean oldStateIsSmall = (oldState == State.SMALL);
1600          mState = state;
1601          final boolean stateIsNormal = (state == State.NORMAL);
1602          final boolean stateIsSpringLoaded = (state == State.SPRING_LOADED);
1603          final boolean stateIsSmall = (state == State.SMALL);
1604          float finalScaleFactor = 1.0f;
1605          float finalBackgroundAlpha = stateIsSpringLoaded ? 1.0f : 0f;
1606          float translationX = 0;
1607          float translationY = 0;
1608          boolean zoomIn = true;
1609  
1610          if (state != State.NORMAL) {
1611              finalScaleFactor = mSpringLoadedShrinkFactor - (stateIsSmall ? 0.1f : 0);
1612              if (oldStateIsNormal &amp;&amp; stateIsSmall) {
1613                  zoomIn = false;
1614                  setLayoutScale(finalScaleFactor);
1615                  updateChildrenLayersEnabled();
1616              } else {
1617                  finalBackgroundAlpha = 1.0f;
1618                  setLayoutScale(finalScaleFactor);
1619              }
1620          } else {
1621              setLayoutScale(1.0f);
1622          }
1623  
1624          final int duration = zoomIn ?
1625                  getResources().getInteger(R.integer.config_workspaceUnshrinkTime) :
1626                  getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
1627          for (int i = 0; i &lt; getChildCount(); i++) {
1628              final CellLayout cl = (CellLayout) getChildAt(i);
1629              float rotation = 0f;
1630              float initialAlpha = cl.getAlpha();
1631              float finalAlphaMultiplierValue = 1f;
1632              float finalAlpha = (!mFadeInAdjacentScreens || stateIsSpringLoaded ||
1633                      (i == mCurrentPage)) ? 1f : 0f;
1634  
1635              // Determine the pages alpha during the state transition
1636              if ((oldStateIsSmall &amp;&amp; stateIsNormal) ||
1637                  (oldStateIsNormal &amp;&amp; stateIsSmall)) {
1638                  // To/from workspace - only show the current page unless the transition is not
1639                  //                     animated and the animation end callback below doesn&#x27;t run
1640                  if (i == mCurrentPage || !animated) {
1641                      finalAlpha = 1f;
1642                      finalAlphaMultiplierValue = 0f;
1643                  } else {
1644                      initialAlpha = 0f;
1645                      finalAlpha = 0f;
1646                  }
1647              }
1648  
1649              // Update the rotation of the screen (don&#x27;t apply rotation on Phone UI)
1650              if (LauncherApplication.isScreenLarge()) {
1651                  if (i &lt; mCurrentPage) {
1652                      rotation = WORKSPACE_ROTATION;
1653                  } else if (i &gt; mCurrentPage) {
1654                      rotation = -WORKSPACE_ROTATION;
1655                  }
1656              }
1657  
1658              // If the screen is not xlarge, then don&#x27;t rotate the CellLayouts
1659              // NOTE: If we don&#x27;t update the side pages alpha, then we should not hide the side
1660              //       pages. see unshrink().
1661              if (LauncherApplication.isScreenLarge()) {
1662                  translationX = getOffsetXForRotation(rotation, cl.getWidth(), cl.getHeight());
1663              }
1664  
1665              mOldAlphas[i] = initialAlpha;
1666              mNewAlphas[i] = finalAlpha;
1667              if (animated) {
1668                  mOldTranslationXs[i] = cl.getTranslationX();
1669                  mOldTranslationYs[i] = cl.getTranslationY();
1670                  mOldScaleXs[i] = cl.getScaleX();
1671                  mOldScaleYs[i] = cl.getScaleY();
1672                  mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
1673                  mOldBackgroundAlphaMultipliers[i] = cl.getBackgroundAlphaMultiplier();
1674                  mOldRotationYs[i] = cl.getRotationY();
1675  
1676                  mNewTranslationXs[i] = translationX;
1677                  mNewTranslationYs[i] = translationY;
1678                  mNewScaleXs[i] = finalScaleFactor;
1679                  mNewScaleYs[i] = finalScaleFactor;
1680                  mNewBackgroundAlphas[i] = finalBackgroundAlpha;
1681                  mNewBackgroundAlphaMultipliers[i] = finalAlphaMultiplierValue;
1682                  mNewRotationYs[i] = rotation;
1683              } else {
1684                  cl.setTranslationX(translationX);
1685                  cl.setTranslationY(translationY);
1686                  cl.setScaleX(finalScaleFactor);
1687                  cl.setScaleY(finalScaleFactor);
1688                  cl.setBackgroundAlpha(finalBackgroundAlpha);
1689                  cl.setBackgroundAlphaMultiplier(finalAlphaMultiplierValue);
1690                  cl.setAlpha(finalAlpha);
1691                  cl.setRotationY(rotation);
1692                  mChangeStateAnimationListener.onAnimationEnd(null);
1693              }
1694          }
1695  
1696          if (animated) {
1697              ValueAnimator animWithInterpolator =
1698                  ValueAnimator.ofFloat(0f, 1f).setDuration(duration);
1699  
1700              if (zoomIn) {
1701                  animWithInterpolator.setInterpolator(mZoomInInterpolator);
1702              }
1703  
1704              animWithInterpolator.addListener(new AnimatorListenerAdapter() {
1705                  @Override
1706                  public void onAnimationEnd(android.animation.Animator animation) {
1707                      // The above code to determine initialAlpha and finalAlpha will ensure that only
1708                      // the current page is visible during (and subsequently, after) the transition
1709                      // animation.  If fade adjacent pages is disabled, then re-enable the page
1710                      // visibility after the transition animation.
1711                      if (!mFadeInAdjacentScreens &amp;&amp; stateIsNormal &amp;&amp; oldStateIsSmall) {
1712                          for (int i = 0; i &lt; getChildCount(); i++) {
1713                              final CellLayout cl = (CellLayout) getChildAt(i);
1714                              cl.setAlpha(1f);
1715                          }






















1716                      }
1717                  }
1718              });
1719              animWithInterpolator.addUpdateListener(new LauncherAnimatorUpdateListener() {
1720                  public void onAnimationUpdate(float a, float b) {
1721                      mTransitionProgress = b;
1722                      if (b == 0f) {
1723                          // an optimization, but not required
1724                          return;










1725                      }
1726                      invalidate();
1727                      for (int i = 0; i &lt; getChildCount(); i++) {
1728                          final CellLayout cl = (CellLayout) getChildAt(i);
1729                          cl.invalidate();
1730                          cl.setFastTranslationX(a * mOldTranslationXs[i] + b * mNewTranslationXs[i]);
1731                          cl.setFastTranslationY(a * mOldTranslationYs[i] + b * mNewTranslationYs[i]);
1732                          cl.setFastScaleX(a * mOldScaleXs[i] + b * mNewScaleXs[i]);
1733                          cl.setFastScaleY(a * mOldScaleYs[i] + b * mNewScaleYs[i]);
1734                          cl.setFastBackgroundAlpha(
1735                                  a * mOldBackgroundAlphas[i] + b * mNewBackgroundAlphas[i]);
1736                          cl.setBackgroundAlphaMultiplier(a * mOldBackgroundAlphaMultipliers[i] +
1737                                  b * mNewBackgroundAlphaMultipliers[i]);
1738                          cl.setFastAlpha(a * mOldAlphas[i] + b * mNewAlphas[i]);
1739                          cl.invalidate();

















1740                      }
1741                      syncChildrenLayersEnabledOnVisiblePages();
1742                  }
1743              });
1744  
1745              ValueAnimator rotationAnim =
1746                  ValueAnimator.ofFloat(0f, 1f).setDuration(duration);
1747              rotationAnim.setInterpolator(new DecelerateInterpolator(2.0f));
1748              rotationAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
1749                  public void onAnimationUpdate(float a, float b) {
1750                      if (b == 0f) {
1751                          // an optimization, but not required
1752                          return;
1753                      }
1754                      for (int i = 0; i &lt; getChildCount(); i++) {
1755                          final CellLayout cl = (CellLayout) getChildAt(i);
1756                          cl.setFastRotationY(a * mOldRotationYs[i] + b * mNewRotationYs[i]);
1757                      }
1758                  }
1759              });
1760  
1761              mAnimator.playTogether(animWithInterpolator, rotationAnim);
1762              mAnimator.setStartDelay(delay);
1763              // If we call this when we&#x27;re not animated, onAnimationEnd is never called on
1764              // the listener; make sure we only use the listener when we&#x27;re actually animating
1765              mAnimator.addListener(mChangeStateAnimationListener);
1766              mAnimator.start();



1767          }
1768  
1769          if (stateIsSpringLoaded) {
1770              // Right now we&#x27;re covered by Apps Customize
1771              // Show the background gradient immediately, so the gradient will
1772              // be showing once AppsCustomize disappears
1773              animateBackgroundGradient(getResources().getInteger(
1774                      R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, false);
1775          } else {
1776              // Fade the background gradient away
1777              animateBackgroundGradient(0f, true);
1778          }
1779          syncChildrenLayersEnabledOnVisiblePages();

































1780      }
1781  
1782      /**
1783       * Draw the View v into the given Canvas.
1784       *
1785       * @param v the view to draw
1786       * @param destCanvas the canvas to draw on
1787       * @param padding the horizontal and vertical padding to use when drawing
1788       */
1789      private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
1790          final Rect clipRect = mTempRect;
1791          v.getDrawingRect(clipRect);
1792  
1793          boolean textVisible = false;
1794  
1795          destCanvas.save();
1796          if (v instanceof TextView &amp;&amp; pruneToDrawable) {
1797              Drawable d = ((TextView) v).getCompoundDrawables()[1];
1798              clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
1799              destCanvas.translate(padding / 2, padding / 2);
1800              d.draw(destCanvas);
1801          } else {
1802              if (v instanceof FolderIcon) {
1803                  // For FolderIcons the text can bleed into the icon area, and so we need to
1804                  // hide the text completely (which can&#x27;t be achieved by clipping).
1805                  if (((FolderIcon) v).getTextVisible()) {
1806                      ((FolderIcon) v).setTextVisible(false);
1807                      textVisible = true;
1808                  }
1809              } else if (v instanceof BubbleTextView) {
1810                  final BubbleTextView tv = (BubbleTextView) v;
1811                  clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
1812                          tv.getLayout().getLineTop(0);
1813              } else if (v instanceof TextView) {
1814                  final TextView tv = (TextView) v;
1815                  clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
1816                          tv.getLayout().getLineTop(0);
1817              }
1818              destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
1819              destCanvas.clipRect(clipRect, Op.REPLACE);
1820              v.draw(destCanvas);
1821  
1822              // Restore text visibility of FolderIcon if necessary
1823              if (textVisible) {
1824                  ((FolderIcon) v).setTextVisible(true);
1825              }
1826          }
1827          destCanvas.restore();
1828      }
1829  
1830      /**
1831       * Returns a new bitmap to show when the given View is being dragged around.
1832       * Responsibility for the bitmap is transferred to the caller.
1833       */
1834      public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
1835          final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1836          Bitmap b;
1837  
1838          if (v instanceof TextView) {
1839              Drawable d = ((TextView) v).getCompoundDrawables()[1];
1840              b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
1841                      d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
1842          } else {
1843              b = Bitmap.createBitmap(
1844                      v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
1845          }
1846  
1847          canvas.setBitmap(b);
1848          drawDragView(v, canvas, padding, true);
1849          mOutlineHelper.applyOuterBlur(b, canvas, outlineColor);
1850          canvas.drawColor(mDragViewMultiplyColor, PorterDuff.Mode.MULTIPLY);
1851          canvas.setBitmap(null);
1852  
1853          return b;
1854      }
1855  
1856      /**
1857       * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
1858       * Responsibility for the bitmap is transferred to the caller.
1859       */
1860      private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
1861          final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1862          final Bitmap b = Bitmap.createBitmap(
1863                  v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
1864  
1865          canvas.setBitmap(b);
1866          drawDragView(v, canvas, padding, true);
1867          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
1868          canvas.setBitmap(null);
1869          return b;
1870      }
1871  
1872      /**
1873       * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
1874       * Responsibility for the bitmap is transferred to the caller.
1875       */
1876      private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
1877              Paint alphaClipPaint) {
1878          final int outlineColor = getResources().getColor(android.R.color.holo_blue_light);
1879          final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
1880          canvas.setBitmap(b);
1881  
1882          Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
1883          float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
1884                  (h - padding) / (float) orig.getHeight());
1885          int scaledWidth = (int) (scaleFactor * orig.getWidth());
1886          int scaledHeight = (int) (scaleFactor * orig.getHeight());
1887          Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
1888  
1889          // center the image
1890          dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
1891  
1892          canvas.drawBitmap(orig, src, dst, null);
1893          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
1894                  alphaClipPaint);
1895          canvas.setBitmap(null);
1896  
1897          return b;
1898      }
1899  
1900      /**
1901       * Creates a drag outline to represent a drop (that we don&#x27;t have the actual information for
1902       * yet).  May be changed in the future to alter the drop outline slightly depending on the
1903       * clip description mime data.
1904       */
1905      private Bitmap createExternalDragOutline(Canvas canvas, int padding) {
1906          Resources r = getResources();
1907          final int outlineColor = r.getColor(android.R.color.holo_blue_light);
1908          final int iconWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
1909          final int iconHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
1910          final int rectRadius = r.getDimensionPixelSize(R.dimen.external_drop_icon_rect_radius);
1911          final int inset = (int) (Math.min(iconWidth, iconHeight) * 0.2f);
1912          final Bitmap b = Bitmap.createBitmap(
1913                  iconWidth + padding, iconHeight + padding, Bitmap.Config.ARGB_8888);
1914  
1915          canvas.setBitmap(b);
1916          canvas.drawRoundRect(new RectF(inset, inset, iconWidth - inset, iconHeight - inset),
1917                  rectRadius, rectRadius, mExternalDragOutlinePaint);
1918          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
1919          canvas.setBitmap(null);
1920          return b;
1921      }
1922  
1923      void startDrag(CellLayout.CellInfo cellInfo) {
1924          View child = cellInfo.cell;
1925  
1926          // Make sure the drag was started by a long press as opposed to a long click.
1927          if (!child.isInTouchMode()) {
1928              return;
1929          }
1930  
1931          mDragInfo = cellInfo;
1932          child.setVisibility(GONE);

1933  
1934          child.clearFocus();
1935          child.setPressed(false);
1936  
1937          final Canvas canvas = new Canvas();
1938  
1939          // We need to add extra padding to the bitmap to make room for the glow effect
1940          final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;
1941  
1942          // The outline is used to visualize where the item will land if dropped
1943          mDragOutline = createDragOutline(child, canvas, bitmapPadding);

1944          beginDragShared(child, this);
1945      }
1946  
1947      public void beginDragShared(View child, DragSource source) {
1948          Resources r = getResources();
1949  
1950          // We need to add extra padding to the bitmap to make room for the glow effect
1951          final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;
1952  
1953          // The drag bitmap follows the touch point around on the screen
1954          final Bitmap b = createDragBitmap(child, new Canvas(), bitmapPadding);

1955  
1956          final int bmpWidth = b.getWidth();
1957  
1958          mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
1959          final int dragLayerX = (int) mTempXY[0] + (child.getWidth() - bmpWidth) / 2;
1960          int dragLayerY = mTempXY[1] - bitmapPadding / 2;

1961  
1962          Point dragVisualizeOffset = null;
1963          Rect dragRect = null;
1964          if (child instanceof BubbleTextView || child instanceof PagedViewIcon) {
1965              int iconSize = r.getDimensionPixelSize(R.dimen.app_icon_size);
1966              int iconPaddingTop = r.getDimensionPixelSize(R.dimen.app_icon_padding_top);
1967              int top = child.getPaddingTop();
1968              int left = (bmpWidth - iconSize) / 2;
1969              int right = left + iconSize;
1970              int bottom = top + iconSize;
1971              dragLayerY += top;
1972              // Note: The drag region is used to calculate drag layer offsets, but the
1973              // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
1974              dragVisualizeOffset = new Point(-bitmapPadding / 2, iconPaddingTop - bitmapPadding / 2);


1975              dragRect = new Rect(left, top, right, bottom);
1976          } else if (child instanceof FolderIcon) {
1977              int previewSize = r.getDimensionPixelSize(R.dimen.folder_preview_size);
1978              dragRect = new Rect(0, 0, child.getWidth(), previewSize);
1979          }
1980  
1981          // Clear the pressed state if necessary
1982          if (child instanceof BubbleTextView) {
1983              BubbleTextView icon = (BubbleTextView) child;
1984              icon.clearPressedOrFocusedBackground();
1985          }
1986  
1987          mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),
1988                  DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect);

1989          b.recycle();



1990      }
1991  
1992      void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, int screen,
1993              int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
1994          View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
1995  
1996          final int[] cellXY = new int[2];
1997          target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
1998          addInScreen(view, container, screen, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
1999          LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen, cellXY[0],
2000                  cellXY[1]);
2001      }
2002  
2003      public boolean transitionStateShouldAllowDrop() {
2004          return (!isSwitchingState() || mTransitionProgress &gt; 0.5f);

2005      }
2006  
2007      /**
2008       * {@inheritDoc}
2009       */
2010      public boolean acceptDrop(DragObject d) {
2011          // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
2012          if (d.dragSource != this) {
2013              // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
2014              if (mDragTargetLayout == null) {
2015                  return false;
2016              }
2017              if (!transitionStateShouldAllowDrop()) return false;
2018  
2019              mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2020                      d.dragView, mDragViewVisualCenter);
2021  
2022              // We want the point to be mapped to the dragTarget.
2023              if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2024                  mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2025              } else {
2026                  mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2027              }
2028  
2029              int spanX = 1;
2030              int spanY = 1;
2031              View ignoreView = null;
2032              if (mDragInfo != null) {
2033                  final CellLayout.CellInfo dragCellInfo = mDragInfo;
2034                  spanX = dragCellInfo.spanX;
2035                  spanY = dragCellInfo.spanY;
2036                  ignoreView = dragCellInfo.cell;
2037              } else {
2038                  final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2039                  spanX = dragInfo.spanX;
2040                  spanY = dragInfo.spanY;
2041              }
2042  






2043              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2044                      (int) mDragViewVisualCenter[1], spanX, spanY, mDragTargetLayout, mTargetCell);


2045              if (willCreateUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout, mTargetCell, true)) {
2046                  return true;
2047              }
2048              if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout,
2049                      mTargetCell)) {
2050                  return true;
2051              }
2052  
2053              // Don&#x27;t accept the drop if there&#x27;s no room for the item
2054              if (!mDragTargetLayout.findCellForSpanIgnoring(null, spanX, spanY, ignoreView)) {

2055                  // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2056                  // is full
2057                  if (mTargetCell != null &amp;&amp; mLauncher.isHotseatLayout(mDragTargetLayout)) {
2058                      Hotseat hotseat = mLauncher.getHotseat();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2059 -                    if (Hotseat.isAllAppsButtonRank(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2060 +                    if (hotseat.isAllAppsButtonRank(</span>
2061                              hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2062                          return false;
2063                      }
2064                  }
2065  
2066                  mLauncher.showOutOfSpaceMessage();
2067                  return false;
2068              }
2069          }
2070          return true;
2071      }
2072  
2073      boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell,
2074              boolean considerTimeout) {
2075          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2076  
2077          boolean hasntMoved = false;
2078          if (mDragInfo != null) {
2079              CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2080              hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2081                      mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2082          }
2083  
2084          if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2085              return false;
2086          }
2087  
2088          boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2089          boolean willBecomeShortcut =
2090                  (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2091                  info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2092  
2093          return (aboveShortcut &amp;&amp; willBecomeShortcut);
2094      }
2095  
2096      boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell) {
2097          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2098          if (dropOverView instanceof FolderIcon) {
2099              FolderIcon fi = (FolderIcon) dropOverView;
2100              if (fi.acceptDrop(dragInfo)) {
2101                  return true;
2102              }
2103          }
2104          return false;
2105      }
2106  
2107      boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2108              int[] targetCell, boolean external, DragView dragView, Runnable postAnimationRunnable) {
2109          View v = target.getChildAt(targetCell[0], targetCell[1]);
2110          boolean hasntMoved = false;
2111          if (mDragInfo != null) {
2112              CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2113              hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2114                      mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2115          }
2116  
2117          if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2118          mCreateUserFolderOnDrop = false;
2119          final int screen = (targetCell == null) ? mDragInfo.screen : indexOfChild(target);
2120  
2121          boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2122          boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2123  
2124          if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2125              ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2126              ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2127              // if the drag started here, we need to remove it from the workspace
2128              if (!external) {
2129                  getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2130              }
2131  
2132              Rect folderLocation = new Rect();
2133              float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2134              target.removeView(v);
2135  
2136              FolderIcon fi =
2137                  mLauncher.addFolder(target, container, screen, targetCell[0], targetCell[1]);
2138              destInfo.cellX = -1;
2139              destInfo.cellY = -1;
2140              sourceInfo.cellX = -1;
2141              sourceInfo.cellY = -1;
2142  
2143              // If the dragView is null, we can&#x27;t animate
2144              boolean animate = dragView != null;
2145              if (animate) {
2146                  fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2147                          postAnimationRunnable);
2148              } else {
2149                  fi.addItem(destInfo);
2150                  fi.addItem(sourceInfo);
2151              }
2152              return true;
2153          }
2154          return false;
2155      }
2156  
2157      boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2158              DragObject d, boolean external) {
2159          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2160          if (dropOverView instanceof FolderIcon) {
2161              FolderIcon fi = (FolderIcon) dropOverView;
2162              if (fi.acceptDrop(d.dragInfo)) {
2163                  fi.onDrop(d);
2164  
2165                  // if the drag started here, we need to remove it from the workspace
2166                  if (!external) {
2167                      getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2168                  }
2169                  return true;
2170              }
2171          }
2172          return false;
2173      }
2174  
2175      public void onDrop(DragObject d) {

2176          mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView,
2177                  mDragViewVisualCenter);
2178  
2179          // We want the point to be mapped to the dragTarget.
2180          if (mDragTargetLayout != null) {
2181              if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2182                  mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2183              } else {
2184                  mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2185              }
2186          }
2187  
2188          CellLayout dropTargetLayout = mDragTargetLayout;
2189  
2190          int snapScreen = -1;

2191          if (d.dragSource != this) {
2192              final int[] touchXY = new int[] { (int) mDragViewVisualCenter[0],
2193                      (int) mDragViewVisualCenter[1] };
2194              onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2195          } else if (mDragInfo != null) {
2196              final View cell = mDragInfo.cell;
2197  

2198              if (dropTargetLayout != null) {
2199                  // Move internally
2200                  boolean hasMovedLayouts = (getParentCellLayoutForView(cell) != dropTargetLayout);
2201                  boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2202                  long container = hasMovedIntoHotseat ?
2203                          LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2204                          LauncherSettings.Favorites.CONTAINER_DESKTOP;
2205                  int screen = (mTargetCell[0] &lt; 0) ?
2206                          mDragInfo.screen : indexOfChild(dropTargetLayout);
2207                  int spanX = mDragInfo != null ? mDragInfo.spanX : 1;
2208                  int spanY = mDragInfo != null ? mDragInfo.spanY : 1;
2209                  // First we find the cell nearest to point at which the item is
2210                  // dropped, without any consideration to whether there is an item there.
2211                  mTargetCell = findNearestArea((int) mDragViewVisualCenter[0], (int)
2212                          mDragViewVisualCenter[1], spanX, spanY, dropTargetLayout, mTargetCell);
2213                  // If the item being dropped is a shortcut and the nearest drop
2214                  // cell also contains a shortcut, then create a folder with the two shortcuts.
2215                  if (!mInScrollArea &amp;&amp; createUserFolderIfNecessary(cell, container,
2216                          dropTargetLayout, mTargetCell, false, d.dragView, null)) {
2217                      return;
2218                  }
2219  
2220                  if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell, d, false)) {
2221                      return;
2222                  }
2223  
2224                  // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2225                  // we need to find the nearest cell location that is vacant








2226                  mTargetCell = findNearestVacantArea((int) mDragViewVisualCenter[0],
2227                          (int) mDragViewVisualCenter[1], mDragInfo.spanX, mDragInfo.spanY, cell,
2228                          dropTargetLayout, mTargetCell);








2229  
2230                  if (mCurrentPage != screen &amp;&amp; !hasMovedIntoHotseat) {
2231                      snapScreen = screen;
2232                      snapToPage(screen);
2233                  }
2234  
2235                  if (mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0) {


2236                      if (hasMovedLayouts) {
2237                          // Reparent the view
2238                          getParentCellLayoutForView(cell).removeView(cell);
2239                          addInScreen(cell, container, screen, mTargetCell[0], mTargetCell[1],
2240                                  mDragInfo.spanX, mDragInfo.spanY);

2241                      }
2242  
2243                      // update the item&#x27;s position after drop
2244                      final ItemInfo info = (ItemInfo) cell.getTag();
2245                      CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2246                      dropTargetLayout.onMove(cell, mTargetCell[0], mTargetCell[1]);


2247                      lp.cellX = mTargetCell[0];
2248                      lp.cellY = mTargetCell[1];


2249                      cell.setId(LauncherModel.getCellLayoutChildId(container, mDragInfo.screen,
2250                              mTargetCell[0], mTargetCell[1], mDragInfo.spanX, mDragInfo.spanY));
2251  
2252                      if (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
2253                              cell instanceof LauncherAppWidgetHostView) {
2254                          final CellLayout cellLayout = dropTargetLayout;
2255                          // We post this call so that the widget has a chance to be placed
2256                          // in its final location
2257  
2258                          final LauncherAppWidgetHostView hostView = (LauncherAppWidgetHostView) cell;
2259                          AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2260                          if (pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
2261                              final Runnable resizeRunnable = new Runnable() {

2262                                  public void run() {
2263                                      DragLayer dragLayer = mLauncher.getDragLayer();
2264                                      dragLayer.addResizeFrame(info, hostView, cellLayout);
2265                                  }
2266                              };
2267                              post(new Runnable() {

2268                                  public void run() {
2269                                      if (!isPageMoving()) {
2270                                          resizeRunnable.run();

2271                                      } else {
2272                                          mDelayedResizeRunnable = resizeRunnable;

2273                                      }
2274                                  }
2275                              });
2276                          }
2277                      }
2278  
2279                      LauncherModel.moveItemInDatabase(mLauncher, info, container, screen, lp.cellX,
2280                              lp.cellY);





2281                  }
2282              }
2283  
2284              final CellLayout parent = (CellLayout) cell.getParent().getParent();
2285  

2286              // Prepare it to be animated into its new position
2287              // This must be called after the view has been re-parented
2288              final Runnable disableHardwareLayersRunnable = new Runnable() {

2289                  @Override
2290                  public void run() {
2291                      mAnimatingViewIntoPlace = false;
2292                      updateChildrenLayersEnabled();



2293                  }
2294              };
2295              mAnimatingViewIntoPlace = true;
2296              if (d.dragView.hasDrawn()) {
2297                  int duration = snapScreen &lt; 0 ? -1 : ADJACENT_SCREEN_DROP_DURATION;
2298                  setFinalScrollForPageChange(snapScreen);
2299                  mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, duration,
2300                          disableHardwareLayersRunnable);
2301                  resetFinalScrollForPageChange(snapScreen);










2302              } else {

2303                  cell.setVisibility(VISIBLE);
2304              }
2305              parent.onDropChild(cell);
2306          }
2307      }
2308  
2309      public void setFinalScrollForPageChange(int screen) {
2310          if (screen &gt;= 0) {
2311              mSavedScrollX = getScrollX();
2312              CellLayout cl = (CellLayout) getChildAt(screen);
2313              mSavedTranslationX = cl.getTranslationX();
2314              mSavedRotationY = cl.getRotationY();
2315              final int newX = getChildOffset(screen) - getRelativeChildOffset(screen);
2316              setScrollX(newX);
2317              cl.setTranslationX(0f);
2318              cl.setRotationY(0f);
2319          }
2320      }
2321  
2322      public void resetFinalScrollForPageChange(int screen) {
2323          if (screen &gt;= 0) {
2324              CellLayout cl = (CellLayout) getChildAt(screen);
2325              setScrollX(mSavedScrollX);
2326              cl.setTranslationX(mSavedTranslationX);
2327              cl.setRotationY(mSavedRotationY);
2328          }
2329      }
2330  
2331      public void getViewLocationRelativeToSelf(View v, int[] location) {
2332          getLocationInWindow(location);
2333          int x = location[0];
2334          int y = location[1];
2335  
2336          v.getLocationInWindow(location);
2337          int vX = location[0];
2338          int vY = location[1];
2339  
2340          location[0] = vX - x;
2341          location[1] = vY - y;
2342      }
2343  
2344      public void onDragEnter(DragObject d) {

2345          if (mDragTargetLayout != null) {
2346              mDragTargetLayout.setIsDragOverlapping(false);
2347              mDragTargetLayout.onDragExit();
2348          }
2349          mDragTargetLayout = getCurrentDropLayout();
2350          mDragTargetLayout.setIsDragOverlapping(true);
2351          mDragTargetLayout.onDragEnter();
2352  
2353          // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
2354          // don&#x27;t need to show the outlines
2355          if (LauncherApplication.isScreenLarge()) {
2356              showOutlines();
2357          }
2358      }
2359  
2360      private void doDragExit(DragObject d) {
2361          // Clean up folders
2362          cleanupFolderCreation(d);
2363  
2364          // Reset the scroll area and previous drag target
2365          onResetScrollArea();
2366  
2367          if (mDragTargetLayout != null) {
2368              mDragTargetLayout.setIsDragOverlapping(false);
2369              mDragTargetLayout.onDragExit();
2370          }
2371          mLastDragOverView = null;
2372          mSpringLoadedDragController.cancel();
2373  
2374          if (!mIsPageMoving) {
2375              hideOutlines();
2376          }
2377      }
2378  
2379      public void onDragExit(DragObject d) {

2380          doDragExit(d);
2381      }
2382  
2383      public DropTarget getDropTargetDelegate(DragObject d) {
2384          return null;
2385      }
2386  
2387      /**
2388       * Tests to see if the drop will be accepted by Launcher, and if so, includes additional data
2389       * in the returned structure related to the widgets that match the drop (or a null list if it is
2390       * a shortcut drop).  If the drop is not accepted then a null structure is returned.
2391       */
2392      private Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; validateDrag(DragEvent event) {
2393          final LauncherModel model = mLauncher.getModel();
2394          final ClipDescription desc = event.getClipDescription();
2395          final int mimeTypeCount = desc.getMimeTypeCount();
2396          for (int i = 0; i &lt; mimeTypeCount; ++i) {
2397              final String mimeType = desc.getMimeType(i);
2398              if (mimeType.equals(InstallShortcutReceiver.SHORTCUT_MIMETYPE)) {
2399                  return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, null);
2400              } else {
2401                  final List&lt;WidgetMimeTypeHandlerData&gt; widgets =
2402                      model.resolveWidgetsForMimeType(mContext, mimeType);
2403                  if (widgets.size() &gt; 0) {
2404                      return new Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt;(i, widgets);
2405                  }
2406              }
2407          }
2408          return null;
2409      }
2410  
2411      /**
2412       * Global drag and drop handler
2413       */
2414      @Override
2415      public boolean onDragEvent(DragEvent event) {
2416          final ClipDescription desc = event.getClipDescription();
2417          final CellLayout layout = (CellLayout) getChildAt(mCurrentPage);
2418          final int[] pos = new int[2];
2419          layout.getLocationOnScreen(pos);
2420          // We need to offset the drag coordinates to layout coordinate space
2421          final int x = (int) event.getX() - pos[0];
2422          final int y = (int) event.getY() - pos[1];
2423  
2424          switch (event.getAction()) {
2425          case DragEvent.ACTION_DRAG_STARTED: {
2426              // Validate this drag
2427              Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2428              if (test != null) {
2429                  boolean isShortcut = (test.second == null);
2430                  if (isShortcut) {
2431                      // Check if we have enough space on this screen to add a new shortcut
2432                      if (!layout.findCellForSpan(pos, 1, 1)) {
2433                          mLauncher.showOutOfSpaceMessage();
2434                          return false;
2435                      }
2436                  }
2437              } else {
2438                  // Show error message if we couldn&#x27;t accept any of the items
2439                  Toast.makeText(mContext, mContext.getString(R.string.external_drop_widget_error),
2440                          Toast.LENGTH_SHORT).show();
2441                  return false;
2442              }
2443  
2444              // Create the drag outline
2445              // We need to add extra padding to the bitmap to make room for the glow effect
2446              final Canvas canvas = new Canvas();
2447              final int bitmapPadding = HolographicOutlineHelper.MAX_OUTER_BLUR_RADIUS;
2448              mDragOutline = createExternalDragOutline(canvas, bitmapPadding);

2449  
2450              // Show the current page outlines to indicate that we can accept this drop
2451              showOutlines();
2452              layout.onDragEnter();
2453              layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, null, null);

2454  
2455              return true;
2456          }
2457          case DragEvent.ACTION_DRAG_LOCATION:
2458              // Visualize the drop location
2459              layout.visualizeDropLocation(null, mDragOutline, x, y, 1, 1, null, null);

2460              return true;
2461          case DragEvent.ACTION_DROP: {
2462              // Try and add any shortcuts
2463              final LauncherModel model = mLauncher.getModel();
2464              final ClipData data = event.getClipData();
2465  
2466              // We assume that the mime types are ordered in descending importance of
2467              // representation. So we enumerate the list of mime types and alert the
2468              // user if any widgets can handle the drop.  Only the most preferred
2469              // representation will be handled.
2470              pos[0] = x;
2471              pos[1] = y;
2472              Pair&lt;Integer, List&lt;WidgetMimeTypeHandlerData&gt;&gt; test = validateDrag(event);
2473              if (test != null) {
2474                  final int index = test.first;
2475                  final List&lt;WidgetMimeTypeHandlerData&gt; widgets = test.second;
2476                  final boolean isShortcut = (widgets == null);
2477                  final String mimeType = desc.getMimeType(index);
2478                  if (isShortcut) {
2479                      final Intent intent = data.getItemAt(index).getIntent();
2480                      Object info = model.infoFromShortcutIntent(mContext, intent, data.getIcon());
2481                      if (info != null) {
2482                          onDropExternal(new int[] { x, y }, info, layout, false);
2483                      }
2484                  } else {
2485                      if (widgets.size() == 1) {
2486                          // If there is only one item, then go ahead and add and configure
2487                          // that widget
2488                          final AppWidgetProviderInfo widgetInfo = widgets.get(0).widgetInfo;
2489                          final PendingAddWidgetInfo createInfo =
2490                                  new PendingAddWidgetInfo(widgetInfo, mimeType, data);
2491                          mLauncher.addAppWidgetFromDrop(createInfo,
2492                              LauncherSettings.Favorites.CONTAINER_DESKTOP, mCurrentPage, null, pos);


2493                      } else {
2494                          // Show the widget picker dialog if there is more than one widget
2495                          // that can handle this data type
2496                          final InstallWidgetReceiver.WidgetListAdapter adapter =
2497                              new InstallWidgetReceiver.WidgetListAdapter(mLauncher, mimeType,
2498                                      data, widgets, layout, mCurrentPage, pos);
2499                          final AlertDialog.Builder builder =
2500                              new AlertDialog.Builder(mContext);
2501                          builder.setAdapter(adapter, adapter);
2502                          builder.setCancelable(true);
2503                          builder.setTitle(mContext.getString(
2504                                  R.string.external_drop_widget_pick_title));
2505                          builder.setIcon(R.drawable.ic_no_applications);
2506                          builder.show();
2507                      }
2508                  }
2509              }
2510              return true;
2511          }
2512          case DragEvent.ACTION_DRAG_ENDED:
2513              // Hide the page outlines after the drop
2514              layout.onDragExit();
2515              hideOutlines();
2516              return true;
2517          }
2518          return super.onDragEvent(event);
2519      }
2520  
2521      /*
2522      *
2523      * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2524      * coordinate space. The argument xy is modified with the return result.
2525      *
2526      */
2527     void mapPointFromSelfToChild(View v, float[] xy) {
2528         mapPointFromSelfToChild(v, xy, null);
2529     }
2530  
2531     /*
2532      *
2533      * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
2534      * coordinate space. The argument xy is modified with the return result.
2535      *
2536      * if cachedInverseMatrix is not null, this method will just use that matrix instead of
2537      * computing it itself; we use this to avoid redundant matrix inversions in
2538      * findMatchingPageForDragOver
2539      *
2540      */
2541     void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
2542         if (cachedInverseMatrix == null) {
2543             v.getMatrix().invert(mTempInverseMatrix);
2544             cachedInverseMatrix = mTempInverseMatrix;
2545         }
2546         xy[0] = xy[0] + mScrollX - v.getLeft();





2547         xy[1] = xy[1] + mScrollY - v.getTop();
2548         cachedInverseMatrix.mapPoints(xy);
2549     }
2550  
2551     /*
2552      * Maps a point from the Workspace&#x27;s coordinate system to another sibling view&#x27;s. (Workspace
2553      * covers the full screen)
2554      */
2555     void mapPointFromSelfToSibling(View v, float[] xy) {
2556         xy[0] = xy[0] - v.getLeft();
2557         xy[1] = xy[1] - v.getTop();
2558     }
2559  
2560     /*
2561      *
2562      * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
2563      * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
2564      *
2565      */
2566     void mapPointFromChildToSelf(View v, float[] xy) {
2567         v.getMatrix().mapPoints(xy);
2568         xy[0] -= (mScrollX - v.getLeft());





2569         xy[1] -= (mScrollY - v.getTop());
2570     }
2571  
2572     static private float squaredDistance(float[] point1, float[] point2) {
2573          float distanceX = point1[0] - point2[0];
2574          float distanceY = point2[1] - point2[1];
2575          return distanceX * distanceX + distanceY * distanceY;
2576     }
2577  
2578      /*
2579       *
2580       * Returns true if the passed CellLayout cl overlaps with dragView
2581       *
2582       */
2583      boolean overlaps(CellLayout cl, DragView dragView,
2584              int dragViewX, int dragViewY, Matrix cachedInverseMatrix) {
2585          // Transform the coordinates of the item being dragged to the CellLayout&#x27;s coordinates
2586          final float[] draggedItemTopLeft = mTempDragCoordinates;
2587          draggedItemTopLeft[0] = dragViewX;
2588          draggedItemTopLeft[1] = dragViewY;
2589          final float[] draggedItemBottomRight = mTempDragBottomRightCoordinates;
2590          draggedItemBottomRight[0] = draggedItemTopLeft[0] + dragView.getDragRegionWidth();
2591          draggedItemBottomRight[1] = draggedItemTopLeft[1] + dragView.getDragRegionHeight();
2592  
2593          // Transform the dragged item&#x27;s top left coordinates
2594          // to the CellLayout&#x27;s local coordinates
2595          mapPointFromSelfToChild(cl, draggedItemTopLeft, cachedInverseMatrix);
2596          float overlapRegionLeft = Math.max(0f, draggedItemTopLeft[0]);
2597          float overlapRegionTop = Math.max(0f, draggedItemTopLeft[1]);
2598  
2599          if (overlapRegionLeft &lt;= cl.getWidth() &amp;&amp; overlapRegionTop &gt;= 0) {
2600              // Transform the dragged item&#x27;s bottom right coordinates
2601              // to the CellLayout&#x27;s local coordinates
2602              mapPointFromSelfToChild(cl, draggedItemBottomRight, cachedInverseMatrix);
2603              float overlapRegionRight = Math.min(cl.getWidth(), draggedItemBottomRight[0]);
2604              float overlapRegionBottom = Math.min(cl.getHeight(), draggedItemBottomRight[1]);
2605  
2606              if (overlapRegionRight &gt;= 0 &amp;&amp; overlapRegionBottom &lt;= cl.getHeight()) {
2607                  float overlap = (overlapRegionRight - overlapRegionLeft) *
2608                           (overlapRegionBottom - overlapRegionTop);
2609                  if (overlap &gt; 0) {
2610                      return true;
2611                  }
2612               }
2613          }
2614          return false;
2615      }
2616  
2617      /*
2618       *
2619       * This method returns the CellLayout that is currently being dragged to. In order to drag
2620       * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
2621       * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
2622       *
2623       * Return null if no CellLayout is currently being dragged over
2624       *
2625       */
2626      private CellLayout findMatchingPageForDragOver(
2627              DragView dragView, float originX, float originY, boolean exact) {
2628          // We loop through all the screens (ie CellLayouts) and see which ones overlap
2629          // with the item being dragged and then choose the one that&#x27;s closest to the touch point
2630          final int screenCount = getChildCount();
2631          CellLayout bestMatchingScreen = null;
2632          float smallestDistSoFar = Float.MAX_VALUE;
2633  
2634          for (int i = 0; i &lt; screenCount; i++) {
2635              CellLayout cl = (CellLayout) getChildAt(i);
2636  
2637              final float[] touchXy = {originX, originY};
2638              // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
2639              // If the touch point is within the bounds of the cell layout, we can return immediately
2640              cl.getMatrix().invert(mTempInverseMatrix);
2641              mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
2642  
2643              if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
2644                      touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
2645                  return cl;
2646              }
2647  
2648              if (!exact) {
2649                  // Get the center of the cell layout in screen coordinates
2650                  final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
2651                  cellLayoutCenter[0] = cl.getWidth()/2;
2652                  cellLayoutCenter[1] = cl.getHeight()/2;
2653                  mapPointFromChildToSelf(cl, cellLayoutCenter);
2654  
2655                  touchXy[0] = originX;
2656                  touchXy[1] = originY;
2657  
2658                  // Calculate the distance between the center of the CellLayout
2659                  // and the touch point
2660                  float dist = squaredDistance(touchXy, cellLayoutCenter);
2661  
2662                  if (dist &lt; smallestDistSoFar) {
2663                      smallestDistSoFar = dist;
2664                      bestMatchingScreen = cl;
2665                  }
2666              }
2667          }
2668          return bestMatchingScreen;
2669      }
2670  
2671      // This is used to compute the visual center of the dragView. This point is then
2672      // used to visualize drop locations and determine where to drop an item. The idea is that
2673      // the visual center represents the user&#x27;s interpretation of where the item is, and hence
2674      // is the appropriate point to use when determining drop location.
2675      private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
2676              DragView dragView, float[] recycle) {
2677          float res[];
2678          if (recycle == null) {
2679              res = new float[2];
2680          } else {
2681              res = recycle;
2682          }
2683  
2684          // First off, the drag view has been shifted in a way that is not represented in the
2685          // x and y values or the x/yOffsets. Here we account for that shift.
2686          x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
2687          y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
2688  
2689          // These represent the visual top and left of drag view if a dragRect was provided.
2690          // If a dragRect was not provided, then they correspond to the actual view left and
2691          // top, as the dragRect is in that case taken to be the entire dragView.
2692          // R.dimen.dragViewOffsetY.
2693          int left = x - xOffset;
2694          int top = y - yOffset;
2695  
2696          // In order to find the visual center, we shift by half the dragRect
2697          res[0] = left + dragView.getDragRegion().width() / 2;
2698          res[1] = top + dragView.getDragRegion().height() / 2;
2699  
2700          return res;
2701      }
2702  
2703      private boolean isDragWidget(DragObject d) {
2704          return (d.dragInfo instanceof LauncherAppWidgetInfo ||
2705                  d.dragInfo instanceof PendingAddWidgetInfo);
2706      }
2707      private boolean isExternalDragWidget(DragObject d) {
2708          return d.dragSource != this &amp;&amp; isDragWidget(d);
2709      }
2710  
2711      public void onDragOver(DragObject d) {
2712          // Skip drag over events while we are dragging over side pages
2713          if (mInScrollArea) return;
2714          if (mIsSwitchingState) return;

2715  
2716          Rect r = new Rect();
2717          CellLayout layout = null;
2718          ItemInfo item = (ItemInfo) d.dragInfo;
2719  
2720          // Ensure that we have proper spans for the item that we are dropping
2721          if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
2722          mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2723              d.dragView, mDragViewVisualCenter);
2724  
2725          // Identify whether we have dragged over a side page
2726          if (isSmall()) {
2727              if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
2728                  mLauncher.getHotseat().getHitRect(r);
2729                  if (r.contains(d.x, d.y)) {
2730                      layout = mLauncher.getHotseat().getLayout();
2731                  }
2732              }
2733              if (layout == null) {
2734                  layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
2735              }
2736              if (layout != mDragTargetLayout) {
2737                  // Cancel all intermediate folder states
2738                  cleanupFolderCreation(d);
2739  
2740                  if (mDragTargetLayout != null) {
2741                      mDragTargetLayout.setIsDragOverlapping(false);
2742                      mDragTargetLayout.onDragExit();
2743                  }
2744                  mDragTargetLayout = layout;
2745                  if (mDragTargetLayout != null) {
2746                      mDragTargetLayout.setIsDragOverlapping(true);
2747                      mDragTargetLayout.onDragEnter();
2748                  } else {
2749                      mLastDragOverView = null;
2750                  }
2751  
2752                  boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
2753                  if (isInSpringLoadedMode) {
2754                      if (mLauncher.isHotseatLayout(layout)) {
2755                          mSpringLoadedDragController.cancel();
2756                      } else {
2757                          mSpringLoadedDragController.setAlarm(mDragTargetLayout);
2758                      }
2759                  }
2760              }
2761          } else {
2762              // Test to see if we are over the hotseat otherwise just use the current page
2763              if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
2764                  mLauncher.getHotseat().getHitRect(r);
2765                  if (r.contains(d.x, d.y)) {
2766                      layout = mLauncher.getHotseat().getLayout();
2767                  }
2768              }
2769              if (layout == null) {
2770                  layout = getCurrentDropLayout();
2771              }
2772              if (layout != mDragTargetLayout) {
2773                  if (mDragTargetLayout != null) {
2774                      mDragTargetLayout.setIsDragOverlapping(false);
2775                      mDragTargetLayout.onDragExit();
2776                  }
2777                  mDragTargetLayout = layout;
2778                  mDragTargetLayout.setIsDragOverlapping(true);
2779                  mDragTargetLayout.onDragEnter();
2780              }
2781          }
2782  
2783          // Handle the drag over
2784          if (mDragTargetLayout != null) {
2785              final View child = (mDragInfo == null) ? null : mDragInfo.cell;
2786  
2787              // We want the point to be mapped to the dragTarget.
2788              if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
2789                  mapPointFromSelfToSibling(mLauncher.getHotseat(), mDragViewVisualCenter);
2790              } else {
2791                  mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
2792              }
2793              ItemInfo info = (ItemInfo) d.dragInfo;
2794  
2795              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2796                      (int) mDragViewVisualCenter[1], 1, 1, mDragTargetLayout, mTargetCell);
2797              final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
2798                      mTargetCell[1]);
2799  
2800              boolean userFolderPending = willCreateUserFolder(info, mDragTargetLayout,
2801                      mTargetCell, false);
2802              boolean isOverFolder = dragOverView instanceof FolderIcon;
2803              if (dragOverView != mLastDragOverView) {
2804                  cancelFolderCreation();
2805                  if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
2806                      ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
2807                  }
2808              }
2809  
2810              if (userFolderPending &amp;&amp; dragOverView != mLastDragOverView) {
2811                  mFolderCreationAlarm.setOnAlarmListener(new
2812                          FolderCreationAlarmListener(mDragTargetLayout, mTargetCell[0], mTargetCell[1]));
2813                  mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
2814              }
2815  
2816              if (dragOverView != mLastDragOverView &amp;&amp; isOverFolder) {
2817                  ((FolderIcon) dragOverView).onDragEnter(d.dragInfo);
2818                  if (mDragTargetLayout != null) {
2819                      mDragTargetLayout.clearDragOutlines();
2820                  }
2821              }
2822              mLastDragOverView = dragOverView;
2823  
2824              if (!mCreateUserFolderOnDrop &amp;&amp; !isOverFolder) {






2825                  mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
2826                          (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
2827                          item.spanX, item.spanY, d.dragView.getDragVisualizeOffset(),
2828                          d.dragView.getDragRegion());


2829              }
2830          }
2831      }
2832  
2833      private void cleanupFolderCreation(DragObject d) {
2834          if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
2835              mDragFolderRingAnimator.animateToNaturalState();
2836          }
2837          if (mLastDragOverView != null &amp;&amp; mLastDragOverView instanceof FolderIcon) {
2838              if (d != null) {
2839                  ((FolderIcon) mLastDragOverView).onDragExit(d.dragInfo);
2840              }
2841          }
2842          mFolderCreationAlarm.cancelAlarm();
2843      }
2844  
2845      private void cancelFolderCreation() {
2846          if (mDragFolderRingAnimator != null &amp;&amp; mCreateUserFolderOnDrop) {
2847              mDragFolderRingAnimator.animateToNaturalState();
2848          }
2849          mCreateUserFolderOnDrop = false;
2850          mFolderCreationAlarm.cancelAlarm();
2851      }
2852  
2853      class FolderCreationAlarmListener implements OnAlarmListener {
2854          CellLayout layout;
2855          int cellX;
2856          int cellY;
2857  
2858          public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
2859              this.layout = layout;
2860              this.cellX = cellX;
2861              this.cellY = cellY;
2862          }
2863  
2864          public void onAlarm(Alarm alarm) {
2865              if (mDragFolderRingAnimator == null) {
2866                  mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
2867              }
2868              mDragFolderRingAnimator.setCell(cellX, cellY);
2869              mDragFolderRingAnimator.setCellLayout(layout);
2870              mDragFolderRingAnimator.animateToAcceptState();
2871              layout.showFolderAccept(mDragFolderRingAnimator);
2872              layout.clearDragOutlines();
2873              mCreateUserFolderOnDrop = true;
2874          }
2875      }
2876  
2877      @Override
2878      public void getHitRect(Rect outRect) {
2879          // We want the workspace to have the whole area of the display (it will find the correct
2880          // cell layout to drop to in the existing drag/drop logic.
2881          outRect.set(0, 0, mDisplayWidth, mDisplayHeight);
2882      }
2883  
2884      /**
2885       * Add the item specified by dragInfo to the given layout.
2886       * @return true if successful
2887       */
2888      public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
2889          if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
2890              onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
2891              return true;
2892          }
2893          mLauncher.showOutOfSpaceMessage();
2894          return false;
2895      }
2896  
2897      private void onDropExternal(int[] touchXY, Object dragInfo,
2898              CellLayout cellLayout, boolean insertAtFirst) {
2899          onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
2900      }
2901  
2902      /**
2903       * Drop an item that didn&#x27;t originate on one of the workspace screens.
2904       * It may have come from Launcher (e.g. from all apps or customize), or it may have
2905       * come from another app altogether.
2906       *
2907       * NOTE: This can also be called when we are outside of a drag event, when we want
2908       * to add an item to one of the workspace screens.
2909       */
2910      private void onDropExternal(final int[] touchXY, final Object dragInfo,
2911              final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
2912          final Runnable exitSpringLoadedRunnable = new Runnable() {
2913              @Override
2914              public void run() {
2915                  mLauncher.exitSpringLoadedDragModeDelayed(true, false);

2916              }
2917          };
2918  
2919          ItemInfo info = (ItemInfo) dragInfo;
2920          int spanX = info.spanX;
2921          int spanY = info.spanY;
2922          if (mDragInfo != null) {
2923              spanX = mDragInfo.spanX;
2924              spanY = mDragInfo.spanY;
2925          }
2926  
2927          final long container = mLauncher.isHotseatLayout(cellLayout) ?
2928                  LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2929                      LauncherSettings.Favorites.CONTAINER_DESKTOP;
2930          final int screen = indexOfChild(cellLayout);
2931          if (!mLauncher.isHotseatLayout(cellLayout) &amp;&amp; screen != mCurrentPage
2932                  &amp;&amp; mState != State.SPRING_LOADED) {
2933              snapToPage(screen);
2934          }
2935  
2936          if (info instanceof PendingAddItemInfo) {
2937              final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
2938  
2939              boolean findNearestVacantCell = true;
2940              if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
2941                  mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
2942                          cellLayout, mTargetCell);
2943                  if (willCreateUserFolder((ItemInfo) d.dragInfo, mDragTargetLayout, mTargetCell,
2944                          true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
2945                                  mDragTargetLayout, mTargetCell)) {
2946                      findNearestVacantCell = false;
2947                  }
2948              }







2949              if (findNearestVacantCell) {
2950                      mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], spanX, spanY, null,
2951                          cellLayout, mTargetCell);





2952              }
2953  
2954              Runnable onAnimationCompleteRunnable = new Runnable() {
2955                  @Override
2956                  public void run() {
2957                      // When dragging and dropping from customization tray, we deal with creating
2958                      // widgets/shortcuts/folders in a slightly different way
2959                      switch (pendingInfo.itemType) {
2960                      case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:



2961                          mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
2962                                  container, screen, mTargetCell, null);

2963                          break;
2964                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
2965                          mLauncher.processShortcutFromDrop(pendingInfo.componentName,
2966                                  container, screen, mTargetCell, null);
2967                          break;
2968                      default:
2969                          throw new IllegalStateException(&quot;Unknown item type: &quot; +
2970                                  pendingInfo.itemType);
2971                      }
2972                      cellLayout.onDragExit();
2973                  }
2974              };
2975  
2976              // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
2977              // location and size on the home screen.
2978              RectF r = estimateItemPosition(cellLayout, pendingInfo,
2979                      mTargetCell[0], mTargetCell[1], spanX, spanY);
2980              int loc[] = new int[2];
2981              loc[0] = (int) r.left;
2982              loc[1] = (int) r.top;
2983              setFinalTransitionTransform(cellLayout);
2984              float cellLayoutScale =
2985                      mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(cellLayout, loc);
2986              resetTransitionTransform(cellLayout);
2987  
2988              float dragViewScale =  Math.min(r.width() / d.dragView.getMeasuredWidth(),
2989                      r.height() / d.dragView.getMeasuredHeight());
2990              // The animation will scale the dragView about its center, so we need to center about
2991              // the final location.
2992              loc[0] -= (d.dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;
2993              loc[1] -= (d.dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;
2994  
2995              mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, loc,
2996                      dragViewScale * cellLayoutScale, onAnimationCompleteRunnable);









2997          } else {
2998              // This is for other drag/drop cases, like dragging from All Apps
2999              View view = null;
3000  
3001              switch (info.itemType) {
3002              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3003              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3004                  if (info.container == NO_ID &amp;&amp; info instanceof ApplicationInfo) {
3005                      // Came from all apps -- make a copy
3006                      info = new ShortcutInfo((ApplicationInfo) info);
3007                  }
3008                  view = mLauncher.createShortcut(R.layout.application, cellLayout,
3009                          (ShortcutInfo) info);
3010                  break;
3011              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3012                  view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3013                          (FolderInfo) info, mIconCache);
3014                  break;
3015              default:
3016                  throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3017              }
3018  
3019              // First we find the cell nearest to point at which the item is
3020              // dropped, without any consideration to whether there is an item there.
3021              if (touchXY != null) {
3022                  mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3023                          cellLayout, mTargetCell);
3024                  d.postAnimationRunnable = exitSpringLoadedRunnable;
3025                  if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, true,
3026                          d.dragView, d.postAnimationRunnable)) {
3027                      return;
3028                  }
3029                  if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, d, true)) {
3030                      return;
3031                  }
3032              }
3033  
3034              if (touchXY != null) {
3035                  // when dragging and dropping, just find the closest free spot
3036                  mTargetCell = findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, null,
3037                          cellLayout, mTargetCell);
3038              } else {
3039                  cellLayout.findCellForSpan(mTargetCell, 1, 1);
3040              }
3041              addInScreen(view, container, screen, mTargetCell[0], mTargetCell[1], info.spanX,
3042                      info.spanY, insertAtFirst);
3043              cellLayout.onDropChild(view);
3044              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3045              cellLayout.getChildrenLayout().measureChild(view);
3046  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3047 +</span>
3048              LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screen,
3049                      lp.cellX, lp.cellY);
3050  
3051              if (d.dragView != null) {
3052                  // We wrap the animation call in the temporary set and reset of the current
3053                  // cellLayout to its final transform -- this means we animate the drag view to
3054                  // the correct final location.
3055                  setFinalTransitionTransform(cellLayout);
3056                  mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3057                          exitSpringLoadedRunnable);
3058                  resetTransitionTransform(cellLayout);
3059              }







































































































3060          }
3061      }
3062  
3063      public void setFinalTransitionTransform(CellLayout layout) {
3064          if (isSwitchingState()) {
3065              int index = indexOfChild(layout);
3066              mCurrentScaleX = layout.getScaleX();
3067              mCurrentScaleY = layout.getScaleY();
3068              mCurrentTranslationX = layout.getTranslationX();
3069              mCurrentTranslationY = layout.getTranslationY();
3070              mCurrentRotationY = layout.getRotationY();
3071              layout.setScaleX(mNewScaleXs[index]);
3072              layout.setScaleY(mNewScaleYs[index]);
3073              layout.setTranslationX(mNewTranslationXs[index]);
3074              layout.setTranslationY(mNewTranslationYs[index]);
3075              layout.setRotationY(mNewRotationYs[index]);
3076          }
3077      }
3078      public void resetTransitionTransform(CellLayout layout) {
3079          if (isSwitchingState()) {
3080              mCurrentScaleX = layout.getScaleX();
3081              mCurrentScaleY = layout.getScaleY();
3082              mCurrentTranslationX = layout.getTranslationX();
3083              mCurrentTranslationY = layout.getTranslationY();
3084              mCurrentRotationY = layout.getRotationY();
3085              layout.setScaleX(mCurrentScaleX);
3086              layout.setScaleY(mCurrentScaleY);
3087              layout.setTranslationX(mCurrentTranslationX);
3088              layout.setTranslationY(mCurrentTranslationY);
3089              layout.setRotationY(mCurrentRotationY);
3090          }
3091      }
3092  
3093      /**
3094       * Return the current {@link CellLayout}, correctly picking the destination
3095       * screen while a scroll is in progress.
3096       */
3097      public CellLayout getCurrentDropLayout() {
3098          return (CellLayout) getChildAt(mNextPage == INVALID_PAGE ? mCurrentPage : mNextPage);
3099      }
3100  
3101      /**
3102       * Return the current CellInfo describing our current drag; this method exists
3103       * so that Launcher can sync this object with the correct info when the activity is created/
3104       * destroyed
3105       *
3106       */
3107      public CellLayout.CellInfo getDragInfo() {
3108          return mDragInfo;
3109      }
3110  
3111      /**
3112       * Calculate the nearest cell where the given object would be dropped.
3113       *
3114       * pixelX and pixelY should be in the coordinate system of layout
3115       */
3116      private int[] findNearestVacantArea(int pixelX, int pixelY,
3117              int spanX, int spanY, View ignoreView, CellLayout layout, int[] recycle) {
3118          return layout.findNearestVacantArea(
3119                  pixelX, pixelY, spanX, spanY, ignoreView, recycle);













3120      }
3121  
3122      /**
3123       * Calculate the nearest cell where the given object would be dropped.
3124       *
3125       * pixelX and pixelY should be in the coordinate system of layout
3126       */
3127      private int[] findNearestArea(int pixelX, int pixelY,
3128              int spanX, int spanY, CellLayout layout, int[] recycle) {
3129          return layout.findNearestArea(
3130                  pixelX, pixelY, spanX, spanY, recycle);
3131      }
3132  
3133      void setup(DragController dragController) {
3134          mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3135          mDragController = dragController;
3136  
3137          // hardware layers on children are enabled on startup, but should be disabled until
3138          // needed
3139          updateChildrenLayersEnabled();
3140          setWallpaperDimension();
3141      }
3142  
3143      /**
3144       * Called at the end of a drag which originated on the workspace.
3145       */
3146      public void onDropCompleted(View target, DragObject d, boolean success) {
3147          if (success) {
3148              if (target != this) {
3149                  if (mDragInfo != null) {
3150                      getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
3151                      if (mDragInfo.cell instanceof DropTarget) {
3152                          mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3153                      }
3154                  }
3155              }
3156          } else if (mDragInfo != null) {
3157              // NOTE: When &#x27;success&#x27; is true, onDragExit is called by the DragController before
3158              // calling onDropCompleted(). We call it ourselves here, but maybe this should be
3159              // moved into DragController.cancelDrag().
3160              doDragExit(null);
3161              CellLayout cellLayout;
3162              if (mLauncher.isHotseatLayout(target)) {
3163                  cellLayout = mLauncher.getHotseat().getLayout();
3164              } else {
3165                  cellLayout = (CellLayout) getChildAt(mDragInfo.screen);
3166              }
3167              cellLayout.onDropChild(mDragInfo.cell);
3168          }
3169          if (d.cancelled &amp;&amp;  mDragInfo.cell != null) {
3170                  mDragInfo.cell.setVisibility(VISIBLE);
3171          }
3172          mDragOutline = null;
3173          mDragInfo = null;



3174      }
3175  
3176      public boolean isDropEnabled() {
3177          return true;
3178      }
3179  
3180      @Override
3181      protected void onRestoreInstanceState(Parcelable state) {
3182          super.onRestoreInstanceState(state);
3183          Launcher.setScreen(mCurrentPage);
3184      }
3185  
3186      @Override
3187      public void scrollLeft() {
3188          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3189              super.scrollLeft();
3190          }
3191          Folder openFolder = getOpenFolder();
3192          if (openFolder != null) {
3193              openFolder.completeDragExit();
3194          }
3195      }
3196  
3197      @Override
3198      public void scrollRight() {
3199          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3200              super.scrollRight();
3201          }
3202          Folder openFolder = getOpenFolder();
3203          if (openFolder != null) {
3204              openFolder.completeDragExit();
3205          }
3206      }
3207  
3208      @Override
3209      public boolean onEnterScrollArea(int x, int y, int direction) {
3210          // Ignore the scroll area if we are dragging over the hot seat
3211          if (mLauncher.getHotseat() != null) {
3212              Rect r = new Rect();
3213              mLauncher.getHotseat().getHitRect(r);
3214              if (r.contains(x, y)) {
3215                  return false;
3216              }
3217          }
3218  
3219          boolean result = false;
3220          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
3221              mInScrollArea = true;
3222  
3223              final int page = mCurrentPage + (direction == DragController.SCROLL_LEFT ? -1 : 1);
3224              final CellLayout layout = (CellLayout) getChildAt(page);


3225              cancelFolderCreation();
3226  
3227              if (layout != null) {


3228                  // Exit the current layout and mark the overlapping layout
3229                  if (mDragTargetLayout != null) {
3230                      mDragTargetLayout.setIsDragOverlapping(false);
3231                      mDragTargetLayout.onDragExit();
3232                  }
3233                  mDragTargetLayout = layout;
3234                  mDragTargetLayout.setIsDragOverlapping(true);
3235  
3236                  // Workspace is responsible for drawing the edge glow on adjacent pages,
3237                  // so we need to redraw the workspace when this may have changed.
3238                  invalidate();
3239                  result = true;
3240              }
3241          }
3242          return result;
3243      }
3244  
3245      @Override
3246      public boolean onExitScrollArea() {
3247          boolean result = false;
3248          if (mInScrollArea) {
3249              if (mDragTargetLayout != null) {
3250                  // Unmark the overlapping layout and re-enter the current layout
3251                  mDragTargetLayout.setIsDragOverlapping(false);
3252                  mDragTargetLayout = getCurrentDropLayout();
3253                  mDragTargetLayout.onDragEnter();
3254  
3255                  // Workspace is responsible for drawing the edge glow on adjacent pages,
3256                  // so we need to redraw the workspace when this may have changed.
3257                  invalidate();
3258                  result = true;
3259              }







3260              mInScrollArea = false;
3261          }
3262          return result;
3263      }
3264  
3265      private void onResetScrollArea() {
3266          if (mDragTargetLayout != null) {
3267              // Unmark the overlapping layout
3268              mDragTargetLayout.setIsDragOverlapping(false);
3269  
3270              // Workspace is responsible for drawing the edge glow on adjacent pages,
3271              // so we need to redraw the workspace when this may have changed.
3272              invalidate();
3273          }
3274          mInScrollArea = false;
3275      }
3276  
3277      /**
3278       * Returns a specific CellLayout
3279       */
3280      CellLayout getParentCellLayoutForView(View v) {
3281          ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
3282          for (CellLayout layout : layouts) {
3283              if (layout.getChildrenLayout().indexOfChild(v) &gt; -1) {
3284                  return layout;
3285              }
3286          }
3287          return null;
3288      }
3289  
3290      /**
3291       * Returns a list of all the CellLayouts in the workspace.
3292       */
3293      ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
3294          ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
3295          int screenCount = getChildCount();
3296          for (int screen = 0; screen &lt; screenCount; screen++) {
3297              layouts.add(((CellLayout) getChildAt(screen)));
3298          }
3299          if (mLauncher.getHotseat() != null) {
3300              layouts.add(mLauncher.getHotseat().getLayout());
3301          }
3302          return layouts;
3303      }
3304  
3305      /**
3306       * We should only use this to search for specific children.  Do not use this method to modify
3307       * CellLayoutChildren directly.
3308       */
3309      ArrayList&lt;CellLayoutChildren&gt; getWorkspaceAndHotseatCellLayoutChildren() {
3310          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = new ArrayList&lt;CellLayoutChildren&gt;();
3311          int screenCount = getChildCount();
3312          for (int screen = 0; screen &lt; screenCount; screen++) {
3313              childrenLayouts.add(((CellLayout) getChildAt(screen)).getChildrenLayout());
3314          }
3315          if (mLauncher.getHotseat() != null) {
3316              childrenLayouts.add(mLauncher.getHotseat().getLayout().getChildrenLayout());
3317          }
3318          return childrenLayouts;
3319      }
3320  
3321      public Folder getFolderForTag(Object tag) {
3322          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3323          for (CellLayoutChildren layout: childrenLayouts) {
3324              int count = layout.getChildCount();
3325              for (int i = 0; i &lt; count; i++) {
3326                  View child = layout.getChildAt(i);
3327                  if (child instanceof Folder) {
3328                      Folder f = (Folder) child;
3329                      if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
3330                          return f;
3331                      }
3332                  }
3333              }
3334          }
3335          return null;
3336      }
3337  
3338      public View getViewForTag(Object tag) {
3339          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3340          for (CellLayoutChildren layout: childrenLayouts) {
3341              int count = layout.getChildCount();
3342              for (int i = 0; i &lt; count; i++) {
3343                  View child = layout.getChildAt(i);
3344                  if (child.getTag() == tag) {
3345                      return child;
3346                  }
3347              }
3348          }
3349          return null;
3350      }
3351  
3352      void clearDropTargets() {
3353          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3354          for (CellLayoutChildren layout: childrenLayouts) {
3355              int childCount = layout.getChildCount();
3356              for (int j = 0; j &lt; childCount; j++) {
3357                  View v = layout.getChildAt(j);
3358                  if (v instanceof DropTarget) {
3359                      mDragController.removeDropTarget((DropTarget) v);
3360                  }
3361              }
3362          }
3363      }
3364  
3365      void removeItems(final ArrayList&lt;ApplicationInfo&gt; apps) {
3366          final AppWidgetManager widgets = AppWidgetManager.getInstance(getContext());
3367  
3368          final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
3369          final int appCount = apps.size();
3370          for (int i = 0; i &lt; appCount; i++) {
3371              packageNames.add(apps.get(i).componentName.getPackageName());
3372          }
3373  
3374          ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
3375          for (final CellLayout layoutParent: cellLayouts) {
3376              final ViewGroup layout = layoutParent.getChildrenLayout();
3377  
3378              // Avoid ANRs by treating each screen separately
3379              post(new Runnable() {
3380                  public void run() {
3381                      final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
3382                      childrenToRemove.clear();
3383  
3384                      int childCount = layout.getChildCount();
3385                      for (int j = 0; j &lt; childCount; j++) {
3386                          final View view = layout.getChildAt(j);
3387                          Object tag = view.getTag();
3388  
3389                          if (tag instanceof ShortcutInfo) {
3390                              final ShortcutInfo info = (ShortcutInfo) tag;
3391                              final Intent intent = info.intent;
3392                              final ComponentName name = intent.getComponent();
3393  
3394                              if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3395                                  for (String packageName: packageNames) {
3396                                      if (packageName.equals(name.getPackageName())) {
3397                                          LauncherModel.deleteItemFromDatabase(mLauncher, info);
3398                                          childrenToRemove.add(view);
3399                                      }
3400                                  }
3401                              }
3402                          } else if (tag instanceof FolderInfo) {
3403                              final FolderInfo info = (FolderInfo) tag;
3404                              final ArrayList&lt;ShortcutInfo&gt; contents = info.contents;
3405                              final int contentsCount = contents.size();
3406                              final ArrayList&lt;ShortcutInfo&gt; appsToRemoveFromFolder =
3407                                      new ArrayList&lt;ShortcutInfo&gt;();
3408  
3409                              for (int k = 0; k &lt; contentsCount; k++) {
3410                                  final ShortcutInfo appInfo = contents.get(k);
3411                                  final Intent intent = appInfo.intent;
3412                                  final ComponentName name = intent.getComponent();
3413  
3414                                  if (Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3415                                      for (String packageName: packageNames) {
3416                                          if (packageName.equals(name.getPackageName())) {
3417                                              appsToRemoveFromFolder.add(appInfo);
3418                                          }
3419                                      }
3420                                  }
3421                              }
3422                              for (ShortcutInfo item: appsToRemoveFromFolder) {
3423                                  info.remove(item);
3424                                  LauncherModel.deleteItemFromDatabase(mLauncher, item);
3425                              }
3426                          } else if (tag instanceof LauncherAppWidgetInfo) {
3427                              final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) tag;
3428                              final AppWidgetProviderInfo provider =
3429                                      widgets.getAppWidgetInfo(info.appWidgetId);
3430                              if (provider != null) {
3431                                  for (String packageName: packageNames) {
3432                                      if (packageName.equals(provider.provider.getPackageName())) {
3433                                          LauncherModel.deleteItemFromDatabase(mLauncher, info);
3434                                          childrenToRemove.add(view);
3435                                      }
3436                                  }
3437                              }
3438                          }
3439                      }
3440  
3441                      childCount = childrenToRemove.size();
3442                      for (int j = 0; j &lt; childCount; j++) {
3443                          View child = childrenToRemove.get(j);
3444                          // Note: We can not remove the view directly from CellLayoutChildren as this
3445                          // does not re-mark the spaces as unoccupied.
3446                          layoutParent.removeViewInLayout(child);
3447                          if (child instanceof DropTarget) {
3448                              mDragController.removeDropTarget((DropTarget)child);
3449                          }
3450                      }
3451  
3452                      if (childCount &gt; 0) {
3453                          layout.requestLayout();
3454                          layout.invalidate();
3455                      }
3456                  }
3457              });
3458          }
3459      }
3460  
3461      void updateShortcuts(ArrayList&lt;ApplicationInfo&gt; apps) {
3462          ArrayList&lt;CellLayoutChildren&gt; childrenLayouts = getWorkspaceAndHotseatCellLayoutChildren();
3463          for (CellLayoutChildren layout: childrenLayouts) {
3464              int childCount = layout.getChildCount();
3465              for (int j = 0; j &lt; childCount; j++) {
3466                  final View view = layout.getChildAt(j);
3467                  Object tag = view.getTag();
3468                  if (tag instanceof ShortcutInfo) {
3469                      ShortcutInfo info = (ShortcutInfo)tag;
3470                      // We need to check for ACTION_MAIN otherwise getComponent() might
3471                      // return null for some shortcuts (for instance, for shortcuts to
3472                      // web pages.)
3473                      final Intent intent = info.intent;
3474                      final ComponentName name = intent.getComponent();
3475                      if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3476                              Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3477                          final int appCount = apps.size();
3478                          for (int k = 0; k &lt; appCount; k++) {
3479                              ApplicationInfo app = apps.get(k);
3480                              if (app.componentName.equals(name)) {
3481                                  info.setIcon(mIconCache.getIcon(info.intent));
3482                                  ((TextView)view).setCompoundDrawablesWithIntrinsicBounds(null,
3483                                          new FastBitmapDrawable(info.getIcon(mIconCache)),
3484                                          null, null);
3485                                  }
3486                          }
3487                      }
3488                  }
3489              }
3490          }
3491      }
3492  
3493      void moveToDefaultScreen(boolean animate) {
3494          if (!isSmall()) {
3495              if (animate) {
3496                  snapToPage(mDefaultPage);
3497              } else {
3498                  setCurrentPage(mDefaultPage);
3499              }
3500          }
3501          getChildAt(mDefaultPage).requestFocus();
3502      }
3503  
3504      @Override
3505      public void syncPages() {
3506      }
3507  
3508      @Override
3509      public void syncPageItems(int page, boolean immediate) {
3510      }
3511  
3512      @Override
3513      protected String getCurrentPageDescription() {
3514          int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
3515          return String.format(mContext.getString(R.string.workspace_scroll_format),
3516                  page + 1, getChildCount());
3517      }
3518  
3519      public void getLocationInDragLayer(int[] loc) {
3520          mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
3521      }
3522  
3523      void setFadeForOverScroll(float fade) {
3524          if (!isScrollingIndicatorEnabled()) return;
3525  
3526          mOverscrollFade = fade;
3527          float reducedFade = 0.5f + 0.5f * (1 - fade);
3528          final ViewGroup parent = (ViewGroup) getParent();
3529          final ImageView qsbDivider = (ImageView) (parent.findViewById(R.id.qsb_divider));
3530          final ImageView dockDivider = (ImageView) (parent.findViewById(R.id.dock_divider));
3531          final ImageView scrollIndicator = getScrollingIndicator();

3532  
3533          cancelScrollingIndicatorAnimations();
3534          if (qsbDivider != null) qsbDivider.setAlpha(reducedFade);
3535          if (dockDivider != null) dockDivider.setAlpha(reducedFade);
3536          scrollIndicator.setAlpha(1 - fade);
3537      }
3538  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            