<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>583 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/**\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.rdb;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.sink.IStreamSinkGener;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.format.RetractJDBCOutputFormat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.table.RdbTableInfo;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.TupleTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStreamSink;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.OutputFormatSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.RichSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.sinks.RetractStreamTableSink;\n&#x27;
                         &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.Serializable;\n&#x27;
                         &#x27;import java.math.BigDecimal;\n&#x27;
                         &#x27;import java.sql.Date;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.sql.Types;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/11/27\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public abstract class RdbSink implements &#x27;
                         &#x27;RetractStreamTableSink&lt;Row&gt;, Serializable, &#x27;
                         &#x27;IStreamSinkGener&lt;RdbSink&gt; {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String driverName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbURL;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String userName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String password;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int batchNum = 100;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected long batchWaitInterval = 10000;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int[] sqlTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String tableName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String registerTabName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String sql;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String[] fieldNames;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private int parallelism = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String schema;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RichSinkFunction createJdbcSinkFunc() {\n&#x27;
                         &#x27;        if (driverName == null || dbURL == null || &#x27;
                         &#x27;userName == null\n&#x27;
                         &#x27;                || password == null || sqlTypes == &#x27;
                         &#x27;null || tableName == null) {\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;any of &#x27;
                         &#x27;params in(driverName, dbURL, userName, password, &#x27;
                         &#x27;type, tableName) &quot; +\n&#x27;
                         &#x27;                    &quot; must not be null. please check &#x27;
                         &#x27;it!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        RetractJDBCOutputFormat outputFormat = &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;        outputFormat.setDbURL(dbURL);\n&#x27;
                         &#x27;        outputFormat.setDrivername(driverName);\n&#x27;
                         &#x27;        outputFormat.setUsername(userName);\n&#x27;
                         &#x27;        outputFormat.setPassword(password);\n&#x27;
                         &#x27;        outputFormat.setInsertQuery(sql);\n&#x27;
                         &#x27;        outputFormat.setBatchNum(batchNum);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;outputFormat.setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        outputFormat.setTypesArray(sqlTypes);\n&#x27;
                         &#x27;        outputFormat.setTableName(tableName);\n&#x27;
                         &#x27;        outputFormat.setDbType(dbType);\n&#x27;
                         &#x27;        outputFormat.setSchema(schema);\n&#x27;
                         &#x27;        outputFormat.setDbSink(this);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        outputFormat.verifyField();\n&#x27;
                         &#x27;        OutputFormatSinkFunction &#x27;
                         &#x27;outputFormatSinkFunc = new &#x27;
                         &#x27;OutputFormatSinkFunction(outputFormat);\n&#x27;
                         &#x27;        return outputFormatSinkFunc;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public RdbSink genStreamSink(TargetTableInfo &#x27;
                         &#x27;targetTableInfo) {\n&#x27;
                         &#x27;        RdbTableInfo rdbTableInfo = (RdbTableInfo) &#x27;
                         &#x27;targetTableInfo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String tmpDbURL = rdbTableInfo.getUrl();\n&#x27;
                         &#x27;        String tmpUserName = &#x27;
                         &#x27;rdbTableInfo.getUserName();\n&#x27;
                         &#x27;        String tmpPassword = &#x27;
                         &#x27;rdbTableInfo.getPassword();\n&#x27;
                         &#x27;        String tmpTableName = &#x27;
                         &#x27;rdbTableInfo.getTableName();\n&#x27;
                         &#x27;        String tmpRegisterName = &#x27;
                         &#x27;rdbTableInfo.getName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSqlBatchSize = &#x27;
                         &#x27;rdbTableInfo.getBatchSize();\n&#x27;
                         &#x27;        if (tmpSqlBatchSize != null) {\n&#x27;
                         &#x27;            setBatchNum(tmpSqlBatchSize);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Long batchWaitInterval = &#x27;
                         &#x27;rdbTableInfo.getBatchWaitInterval();\n&#x27;
                         &#x27;        if (batchWaitInterval != null) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSinkParallelism = &#x27;
                         &#x27;rdbTableInfo.getParallelism();\n&#x27;
                         &#x27;        if (tmpSinkParallelism != null) {\n&#x27;
                         &#x27;            setParallelism(tmpSinkParallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fields = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFields());\n&#x27;
                         &#x27;        List&lt;Class&gt; fieldTypeArray = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFieldClasses());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.driverName = getDriverName();\n&#x27;
                         &#x27;        this.dbURL = tmpDbURL;\n&#x27;
                         &#x27;        this.userName = tmpUserName;\n&#x27;
                         &#x27;        this.password = tmpPassword;\n&#x27;
                         &#x27;        this.tableName = tmpTableName;\n&#x27;
                         &#x27;        this.registerTabName = tmpRegisterName;\n&#x27;
                         &#x27;        this.primaryKeys = &#x27;
                         &#x27;rdbTableInfo.getPrimaryKeys();\n&#x27;
                         &#x27;        this.dbType = rdbTableInfo.getType();\n&#x27;
                         &#x27;        this.schema = rdbTableInfo.getSchema();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        buildSql(schema, tableName, fields);\n&#x27;
                         &#x27;        buildSqlTypes(fieldTypeArray);\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * By now specified class type conversion.\n&#x27;
                         &#x27;     * FIXME Follow-up has added a new type of time &#x27;
                         &#x27;needs to be modified\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param fieldTypeArray\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void buildSqlTypes(List&lt;Class&gt; &#x27;
                         &#x27;fieldTypeArray) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int[] tmpFieldsType = new &#x27;
                         &#x27;int[fieldTypeArray.size()];\n&#x27;
                         &#x27;        for (int i = 0; i &lt; fieldTypeArray.size(); &#x27;
                         &#x27;i++) {\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;fieldTypeArray.get(i).getName();\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(fieldType.equals(Integer.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.INTEGER;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Boolean.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BOOLEAN;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Long.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BIGINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TINYINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Short.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.SMALLINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(String.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.CHAR;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BINARY;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Float.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.FLOAT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Double.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DOUBLE;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Timestamp.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TIMESTAMP;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(BigDecimal.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DECIMAL;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Date.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DATE;\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                throw new RuntimeException(&quot;no &#x27;
                         &#x27;support field type for sql. the input type:&quot; + &#x27;
                         &#x27;fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.sqlTypes = tmpFieldsType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TableSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;configure(String[] fieldNames, TypeInformation&lt;?&gt;[] &#x27;
                         &#x27;fieldTypes) {\n&#x27;
                         &#x27;        this.fieldNames = fieldNames;\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                         &#x27;        this.batchNum = batchNum;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchWaitInterval(long &#x27;
                         &#x27;batchWaitInterval) {\n&#x27;
                         &#x27;        this.batchWaitInterval = batchWaitInterval;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TupleTypeInfo&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;getOutputType() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;TupleTypeInfo(org.apache.flink.table.api.Types.BOOLEAN(), &#x27;
                         &#x27;getRecordType());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;Row&gt; getRecordType() {\n&#x27;
                         &#x27;        return new RowTypeInfo(fieldTypes, &#x27;
                         &#x27;fieldNames);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String[] getFieldNames() {\n&#x27;
                         &#x27;        return fieldNames;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;?&gt;[] getFieldTypes() {\n&#x27;
                         &#x27;        return fieldTypes;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setParallelism(int parallelism) {\n&#x27;
                         &#x27;        this.parallelism = parallelism;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setDbType(String dbType) {\n&#x27;
                         &#x27;        this.dbType = dbType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * you need to implements  this method in your &#x27;
                         &#x27;own class.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fields\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract void buildSql(String schema, &#x27;
                         &#x27;String tableName, List&lt;String&gt; fields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * sqlserver and oracle maybe implement\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fieldNames\n&#x27;
                         &#x27;     * @param realIndexes\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract String buildUpdateSql(String &#x27;
                         &#x27;schema, String tableName, List&lt;String&gt; fieldNames, &#x27;
                         &#x27;Map&lt;String, List&lt;String&gt;&gt; realIndexes, List&lt;String&gt; &#x27;
                         &#x27;fullField);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract String getDriverName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract RetractJDBCOutputFormat &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;emitDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        consumeDataStream(dataStream);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public DataStreamSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;consumeDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        RichSinkFunction richSinkFunction = &#x27;
                         &#x27;createJdbcSinkFunc();\n&#x27;
                         &#x27;        DataStreamSink streamSink = &#x27;
                         &#x27;dataStream.addSink(richSinkFunction);\n&#x27;
                         &#x27;        streamSink.name(registerTabName);\n&#x27;
                         &#x27;        if (parallelism &gt; 0) {\n&#x27;
                         &#x27;            streamSink.setParallelism(parallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return streamSink;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/**\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.rdb;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.sink.IStreamSinkGener;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.format.RetractJDBCOutputFormat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.table.RdbTableInfo;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.TupleTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStreamSink;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.OutputFormatSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.RichSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.sinks.RetractStreamTableSink;\n&#x27;
                         &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.Serializable;\n&#x27;
                         &#x27;import java.math.BigDecimal;\n&#x27;
                         &#x27;import java.sql.Date;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.sql.Types;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/11/27\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public abstract class RdbSink implements &#x27;
                         &#x27;RetractStreamTableSink&lt;Row&gt;, Serializable, &#x27;
                         &#x27;IStreamSinkGener&lt;RdbSink&gt; {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String driverName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbURL;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String userName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String password;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int batchNum = 100;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected long batchWaitInterval = 10000;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int[] sqlTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String tableName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String registerTabName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String sql;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String[] fieldNames;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private int parallelism = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String schema;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RichSinkFunction createJdbcSinkFunc() {\n&#x27;
                         &#x27;        if (driverName == null || dbURL == null || &#x27;
                         &#x27;userName == null\n&#x27;
                         &#x27;                || password == null || sqlTypes == &#x27;
                         &#x27;null || tableName == null) {\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;any of &#x27;
                         &#x27;params in(driverName, dbURL, userName, password, &#x27;
                         &#x27;type, tableName) &quot; +\n&#x27;
                         &#x27;                    &quot; must not be null. please check &#x27;
                         &#x27;it!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        RetractJDBCOutputFormat outputFormat = &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;        outputFormat.setDbURL(dbURL);\n&#x27;
                         &#x27;        outputFormat.setDrivername(driverName);\n&#x27;
                         &#x27;        outputFormat.setUsername(userName);\n&#x27;
                         &#x27;        outputFormat.setPassword(password);\n&#x27;
                         &#x27;        outputFormat.setInsertQuery(sql);\n&#x27;
                         &#x27;        outputFormat.setBatchNum(batchNum);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;outputFormat.setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        outputFormat.setTypesArray(sqlTypes);\n&#x27;
                         &#x27;        outputFormat.setTableName(tableName);\n&#x27;
                         &#x27;        outputFormat.setDbType(dbType);\n&#x27;
                         &#x27;        outputFormat.setSchema(schema);\n&#x27;
                         &#x27;        outputFormat.setDbSink(this);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        outputFormat.verifyField();\n&#x27;
                         &#x27;        OutputFormatSinkFunction &#x27;
                         &#x27;outputFormatSinkFunc = new &#x27;
                         &#x27;OutputFormatSinkFunction(outputFormat);\n&#x27;
                         &#x27;        return outputFormatSinkFunc;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public RdbSink genStreamSink(TargetTableInfo &#x27;
                         &#x27;targetTableInfo) {\n&#x27;
                         &#x27;        RdbTableInfo rdbTableInfo = (RdbTableInfo) &#x27;
                         &#x27;targetTableInfo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String tmpDbURL = rdbTableInfo.getUrl();\n&#x27;
                         &#x27;        String tmpUserName = &#x27;
                         &#x27;rdbTableInfo.getUserName();\n&#x27;
                         &#x27;        String tmpPassword = &#x27;
                         &#x27;rdbTableInfo.getPassword();\n&#x27;
                         &#x27;        String tmpTableName = &#x27;
                         &#x27;rdbTableInfo.getTableName();\n&#x27;
                         &#x27;        String tmpRegisterName = &#x27;
                         &#x27;rdbTableInfo.getName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSqlBatchSize = &#x27;
                         &#x27;rdbTableInfo.getBatchSize();\n&#x27;
                         &#x27;        if (tmpSqlBatchSize != null) {\n&#x27;
                         &#x27;            setBatchNum(tmpSqlBatchSize);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Long batchWaitInterval = &#x27;
                         &#x27;rdbTableInfo.getBatchWaitInterval();\n&#x27;
                         &#x27;        if (batchWaitInterval != null) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSinkParallelism = &#x27;
                         &#x27;rdbTableInfo.getParallelism();\n&#x27;
                         &#x27;        if (tmpSinkParallelism != null) {\n&#x27;
                         &#x27;            setParallelism(tmpSinkParallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fields = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFields());\n&#x27;
                         &#x27;        List&lt;Class&gt; fieldTypeArray = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFieldClasses());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.driverName = getDriverName();\n&#x27;
                         &#x27;        this.dbURL = tmpDbURL;\n&#x27;
                         &#x27;        this.userName = tmpUserName;\n&#x27;
                         &#x27;        this.password = tmpPassword;\n&#x27;
                         &#x27;        this.tableName = tmpTableName;\n&#x27;
                         &#x27;        this.registerTabName = tmpRegisterName;\n&#x27;
                         &#x27;        this.primaryKeys = &#x27;
                         &#x27;rdbTableInfo.getPrimaryKeys();\n&#x27;
                         &#x27;        this.dbType = rdbTableInfo.getType();\n&#x27;
                         &#x27;        this.schema = rdbTableInfo.getSchema();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        buildSql(schema, tableName, fields);\n&#x27;
                         &#x27;        buildSqlTypes(fieldTypeArray);\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * By now specified class type conversion.\n&#x27;
                         &#x27;     * FIXME Follow-up has added a new type of time &#x27;
                         &#x27;needs to be modified\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param fieldTypeArray\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void buildSqlTypes(List&lt;Class&gt; &#x27;
                         &#x27;fieldTypeArray) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int[] tmpFieldsType = new &#x27;
                         &#x27;int[fieldTypeArray.size()];\n&#x27;
                         &#x27;        for (int i = 0; i &lt; fieldTypeArray.size(); &#x27;
                         &#x27;i++) {\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;fieldTypeArray.get(i).getName();\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(fieldType.equals(Integer.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.INTEGER;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Boolean.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BOOLEAN;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Long.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BIGINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TINYINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Short.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.SMALLINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(String.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.CHAR;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BINARY;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Float.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.FLOAT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Double.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DOUBLE;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Timestamp.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TIMESTAMP;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(BigDecimal.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DECIMAL;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Date.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DATE;\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                throw new RuntimeException(&quot;no &#x27;
                         &#x27;support field type for sql. the input type:&quot; + &#x27;
                         &#x27;fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.sqlTypes = tmpFieldsType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TableSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;configure(String[] fieldNames, TypeInformation&lt;?&gt;[] &#x27;
                         &#x27;fieldTypes) {\n&#x27;
                         &#x27;        this.fieldNames = fieldNames;\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                         &#x27;        this.batchNum = batchNum;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchWaitInterval(long &#x27;
                         &#x27;batchWaitInterval) {\n&#x27;
                         &#x27;        this.batchWaitInterval = batchWaitInterval;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TupleTypeInfo&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;getOutputType() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;TupleTypeInfo(org.apache.flink.table.api.Types.BOOLEAN(), &#x27;
                         &#x27;getRecordType());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;Row&gt; getRecordType() {\n&#x27;
                         &#x27;        return new RowTypeInfo(fieldTypes, &#x27;
                         &#x27;fieldNames);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String[] getFieldNames() {\n&#x27;
                         &#x27;        return fieldNames;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;?&gt;[] getFieldTypes() {\n&#x27;
                         &#x27;        return fieldTypes;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setParallelism(int parallelism) {\n&#x27;
                         &#x27;        this.parallelism = parallelism;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setDbType(String dbType) {\n&#x27;
                         &#x27;        this.dbType = dbType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * you need to implements  this method in your &#x27;
                         &#x27;own class.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fields\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract void buildSql(String schema, &#x27;
                         &#x27;String tableName, List&lt;String&gt; fields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * sqlserver and oracle maybe implement\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fieldNames\n&#x27;
                         &#x27;     * @param realIndexes\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract String buildUpdateSql(String &#x27;
                         &#x27;schema, String tableName, List&lt;String&gt; fieldNames, &#x27;
                         &#x27;Map&lt;String, List&lt;String&gt;&gt; realIndexes, List&lt;String&gt; &#x27;
                         &#x27;fullField);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract String getDriverName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract RetractJDBCOutputFormat &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;emitDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        consumeDataStream(dataStream);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public DataStreamSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;consumeDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        RichSinkFunction richSinkFunction = &#x27;
                         &#x27;createJdbcSinkFunc();\n&#x27;
                         &#x27;        DataStreamSink streamSink = &#x27;
                         &#x27;dataStream.addSink(richSinkFunction);\n&#x27;
                         &#x27;        streamSink.name(registerTabName);\n&#x27;
                         &#x27;        if (parallelism &gt; 0) {\n&#x27;
                         &#x27;            streamSink.setParallelism(parallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return streamSink;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/**\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.rdb;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.sink.IStreamSinkGener;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.format.RetractJDBCOutputFormat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.table.RdbTableInfo;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.TupleTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStreamSink;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.OutputFormatSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.RichSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.sinks.RetractStreamTableSink;\n&#x27;
                         &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.Serializable;\n&#x27;
                         &#x27;import java.math.BigDecimal;\n&#x27;
                         &#x27;import java.sql.Date;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.sql.Types;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/11/27\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public abstract class RdbSink implements &#x27;
                         &#x27;RetractStreamTableSink&lt;Row&gt;, Serializable, &#x27;
                         &#x27;IStreamSinkGener&lt;RdbSink&gt; {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String driverName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbURL;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String userName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String password;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int batchNum = 100;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected long batchWaitInterval = 10000;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int[] sqlTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String tableName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String registerTabName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String sql;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String[] fieldNames;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private int parallelism = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String schema;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RichSinkFunction createJdbcSinkFunc() {\n&#x27;
                         &#x27;        if (driverName == null || dbURL == null || &#x27;
                         &#x27;userName == null\n&#x27;
                         &#x27;                || password == null || sqlTypes == &#x27;
                         &#x27;null || tableName == null) {\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;any of &#x27;
                         &#x27;params in(driverName, dbURL, userName, password, &#x27;
                         &#x27;type, tableName) &quot; +\n&#x27;
                         &#x27;                    &quot; must not be null. please check &#x27;
                         &#x27;it!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        RetractJDBCOutputFormat outputFormat = &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;        outputFormat.setDbURL(dbURL);\n&#x27;
                         &#x27;        outputFormat.setDrivername(driverName);\n&#x27;
                         &#x27;        outputFormat.setUsername(userName);\n&#x27;
                         &#x27;        outputFormat.setPassword(password);\n&#x27;
                         &#x27;        outputFormat.setInsertQuery(sql);\n&#x27;
                         &#x27;        outputFormat.setBatchNum(batchNum);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;outputFormat.setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        outputFormat.setTypesArray(sqlTypes);\n&#x27;
                         &#x27;        outputFormat.setTableName(tableName);\n&#x27;
                         &#x27;        outputFormat.setDbType(dbType);\n&#x27;
                         &#x27;        outputFormat.setSchema(schema);\n&#x27;
                         &#x27;        outputFormat.setDbSink(this);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        outputFormat.verifyField();\n&#x27;
                         &#x27;        OutputFormatSinkFunction &#x27;
                         &#x27;outputFormatSinkFunc = new &#x27;
                         &#x27;OutputFormatSinkFunction(outputFormat);\n&#x27;
                         &#x27;        return outputFormatSinkFunc;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public RdbSink genStreamSink(TargetTableInfo &#x27;
                         &#x27;targetTableInfo) {\n&#x27;
                         &#x27;        RdbTableInfo rdbTableInfo = (RdbTableInfo) &#x27;
                         &#x27;targetTableInfo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String tmpDbURL = rdbTableInfo.getUrl();\n&#x27;
                         &#x27;        String tmpUserName = &#x27;
                         &#x27;rdbTableInfo.getUserName();\n&#x27;
                         &#x27;        String tmpPassword = &#x27;
                         &#x27;rdbTableInfo.getPassword();\n&#x27;
                         &#x27;        String tmpTableName = &#x27;
                         &#x27;rdbTableInfo.getTableName();\n&#x27;
                         &#x27;        String tmpRegisterName = &#x27;
                         &#x27;rdbTableInfo.getName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSqlBatchSize = &#x27;
                         &#x27;rdbTableInfo.getBatchSize();\n&#x27;
                         &#x27;        if (tmpSqlBatchSize != null) {\n&#x27;
                         &#x27;            setBatchNum(tmpSqlBatchSize);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Long batchWaitInterval = &#x27;
                         &#x27;rdbTableInfo.getBatchWaitInterval();\n&#x27;
                         &#x27;        if (batchWaitInterval != null) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSinkParallelism = &#x27;
                         &#x27;rdbTableInfo.getParallelism();\n&#x27;
                         &#x27;        if (tmpSinkParallelism != null) {\n&#x27;
                         &#x27;            setParallelism(tmpSinkParallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fields = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFields());\n&#x27;
                         &#x27;        List&lt;Class&gt; fieldTypeArray = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFieldClasses());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.driverName = getDriverName();\n&#x27;
                         &#x27;        this.dbURL = tmpDbURL;\n&#x27;
                         &#x27;        this.userName = tmpUserName;\n&#x27;
                         &#x27;        this.password = tmpPassword;\n&#x27;
                         &#x27;        this.tableName = tmpTableName;\n&#x27;
                         &#x27;        this.registerTabName = tmpRegisterName;\n&#x27;
                         &#x27;        this.primaryKeys = &#x27;
                         &#x27;rdbTableInfo.getPrimaryKeys();\n&#x27;
                         &#x27;        this.dbType = rdbTableInfo.getType();\n&#x27;
                         &#x27;        this.schema = rdbTableInfo.getSchema();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        buildSql(schema, tableName, fields);\n&#x27;
                         &#x27;        buildSqlTypes(fieldTypeArray);\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * By now specified class type conversion.\n&#x27;
                         &#x27;     * FIXME Follow-up has added a new type of time &#x27;
                         &#x27;needs to be modified\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param fieldTypeArray\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void buildSqlTypes(List&lt;Class&gt; &#x27;
                         &#x27;fieldTypeArray) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int[] tmpFieldsType = new &#x27;
                         &#x27;int[fieldTypeArray.size()];\n&#x27;
                         &#x27;        for (int i = 0; i &lt; fieldTypeArray.size(); &#x27;
                         &#x27;i++) {\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;fieldTypeArray.get(i).getName();\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(fieldType.equals(Integer.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.INTEGER;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Boolean.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BOOLEAN;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Long.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BIGINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TINYINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Short.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.SMALLINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(String.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.CHAR;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BINARY;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Float.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.FLOAT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Double.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DOUBLE;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Timestamp.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TIMESTAMP;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(BigDecimal.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DECIMAL;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Date.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DATE;\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                throw new RuntimeException(&quot;no &#x27;
                         &#x27;support field type for sql. the input type:&quot; + &#x27;
                         &#x27;fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.sqlTypes = tmpFieldsType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TableSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;configure(String[] fieldNames, TypeInformation&lt;?&gt;[] &#x27;
                         &#x27;fieldTypes) {\n&#x27;
                         &#x27;        this.fieldNames = fieldNames;\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                         &#x27;        this.batchNum = batchNum;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchWaitInterval(long &#x27;
                         &#x27;batchWaitInterval) {\n&#x27;
                         &#x27;        this.batchWaitInterval = batchWaitInterval;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TupleTypeInfo&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;getOutputType() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;TupleTypeInfo(org.apache.flink.table.api.Types.BOOLEAN(), &#x27;
                         &#x27;getRecordType());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;Row&gt; getRecordType() {\n&#x27;
                         &#x27;        return new RowTypeInfo(fieldTypes, &#x27;
                         &#x27;fieldNames);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String[] getFieldNames() {\n&#x27;
                         &#x27;        return fieldNames;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;?&gt;[] getFieldTypes() {\n&#x27;
                         &#x27;        return fieldTypes;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setParallelism(int parallelism) {\n&#x27;
                         &#x27;        this.parallelism = parallelism;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setDbType(String dbType) {\n&#x27;
                         &#x27;        this.dbType = dbType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * you need to implements  this method in your &#x27;
                         &#x27;own class.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fields\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract void buildSql(String schema, &#x27;
                         &#x27;String tableName, List&lt;String&gt; fields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * sqlserver and oracle maybe implement\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fieldNames\n&#x27;
                         &#x27;     * @param realIndexes\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract String buildUpdateSql(String &#x27;
                         &#x27;schema, String tableName, List&lt;String&gt; fieldNames, &#x27;
                         &#x27;Map&lt;String, List&lt;String&gt;&gt; realIndexes, List&lt;String&gt; &#x27;
                         &#x27;fullField);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract String getDriverName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract RetractJDBCOutputFormat &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;emitDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        consumeDataStream(dataStream);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public DataStreamSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;consumeDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        RichSinkFunction richSinkFunction = &#x27;
                         &#x27;createJdbcSinkFunc();\n&#x27;
                         &#x27;        DataStreamSink streamSink = &#x27;
                         &#x27;dataStream.addSink(richSinkFunction);\n&#x27;
                         &#x27;        streamSink.name(registerTabName);\n&#x27;
                         &#x27;        if (parallelism &gt; 0) {\n&#x27;
                         &#x27;            streamSink.setParallelism(parallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return streamSink;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/**\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.rdb;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.sink.IStreamSinkGener;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.format.RetractJDBCOutputFormat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.table.RdbTableInfo;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.TupleTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStreamSink;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.OutputFormatSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.RichSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.sinks.RetractStreamTableSink;\n&#x27;
                         &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.Serializable;\n&#x27;
                         &#x27;import java.math.BigDecimal;\n&#x27;
                         &#x27;import java.sql.Date;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.sql.Types;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/11/27\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public abstract class RdbSink implements &#x27;
                         &#x27;RetractStreamTableSink&lt;Row&gt;, Serializable, &#x27;
                         &#x27;IStreamSinkGener&lt;RdbSink&gt; {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String driverName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbURL;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String userName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String password;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int batchNum = 100;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected long batchWaitInterval = 10000;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int[] sqlTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String tableName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String registerTabName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String sql;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String[] fieldNames;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private int parallelism = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String schema;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RichSinkFunction createJdbcSinkFunc() {\n&#x27;
                         &#x27;        if (driverName == null || dbURL == null || &#x27;
                         &#x27;userName == null\n&#x27;
                         &#x27;                || password == null || sqlTypes == &#x27;
                         &#x27;null || tableName == null) {\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;any of &#x27;
                         &#x27;params in(driverName, dbURL, userName, password, &#x27;
                         &#x27;type, tableName) &quot; +\n&#x27;
                         &#x27;                    &quot; must not be null. please check &#x27;
                         &#x27;it!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        RetractJDBCOutputFormat outputFormat = &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;        outputFormat.setDbURL(dbURL);\n&#x27;
                         &#x27;        outputFormat.setDrivername(driverName);\n&#x27;
                         &#x27;        outputFormat.setUsername(userName);\n&#x27;
                         &#x27;        outputFormat.setPassword(password);\n&#x27;
                         &#x27;        outputFormat.setInsertQuery(sql);\n&#x27;
                         &#x27;        outputFormat.setBatchNum(batchNum);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;outputFormat.setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        outputFormat.setTypesArray(sqlTypes);\n&#x27;
                         &#x27;        outputFormat.setTableName(tableName);\n&#x27;
                         &#x27;        outputFormat.setDbType(dbType);\n&#x27;
                         &#x27;        outputFormat.setSchema(schema);\n&#x27;
                         &#x27;        outputFormat.setDbSink(this);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        outputFormat.verifyField();\n&#x27;
                         &#x27;        OutputFormatSinkFunction &#x27;
                         &#x27;outputFormatSinkFunc = new &#x27;
                         &#x27;OutputFormatSinkFunction(outputFormat);\n&#x27;
                         &#x27;        return outputFormatSinkFunc;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public RdbSink genStreamSink(TargetTableInfo &#x27;
                         &#x27;targetTableInfo) {\n&#x27;
                         &#x27;        RdbTableInfo rdbTableInfo = (RdbTableInfo) &#x27;
                         &#x27;targetTableInfo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String tmpDbURL = rdbTableInfo.getUrl();\n&#x27;
                         &#x27;        String tmpUserName = &#x27;
                         &#x27;rdbTableInfo.getUserName();\n&#x27;
                         &#x27;        String tmpPassword = &#x27;
                         &#x27;rdbTableInfo.getPassword();\n&#x27;
                         &#x27;        String tmpTableName = &#x27;
                         &#x27;rdbTableInfo.getTableName();\n&#x27;
                         &#x27;        String tmpRegisterName = &#x27;
                         &#x27;rdbTableInfo.getName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSqlBatchSize = &#x27;
                         &#x27;rdbTableInfo.getBatchSize();\n&#x27;
                         &#x27;        if (tmpSqlBatchSize != null) {\n&#x27;
                         &#x27;            setBatchNum(tmpSqlBatchSize);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Long batchWaitInterval = &#x27;
                         &#x27;rdbTableInfo.getBatchWaitInterval();\n&#x27;
                         &#x27;        if (batchWaitInterval != null) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSinkParallelism = &#x27;
                         &#x27;rdbTableInfo.getParallelism();\n&#x27;
                         &#x27;        if (tmpSinkParallelism != null) {\n&#x27;
                         &#x27;            setParallelism(tmpSinkParallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fields = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFields());\n&#x27;
                         &#x27;        List&lt;Class&gt; fieldTypeArray = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFieldClasses());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.driverName = getDriverName();\n&#x27;
                         &#x27;        this.dbURL = tmpDbURL;\n&#x27;
                         &#x27;        this.userName = tmpUserName;\n&#x27;
                         &#x27;        this.password = tmpPassword;\n&#x27;
                         &#x27;        this.tableName = tmpTableName;\n&#x27;
                         &#x27;        this.registerTabName = tmpRegisterName;\n&#x27;
                         &#x27;        this.primaryKeys = &#x27;
                         &#x27;rdbTableInfo.getPrimaryKeys();\n&#x27;
                         &#x27;        this.dbType = rdbTableInfo.getType();\n&#x27;
                         &#x27;        this.schema = rdbTableInfo.getSchema();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        buildSql(schema, tableName, fields);\n&#x27;
                         &#x27;        buildSqlTypes(fieldTypeArray);\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * By now specified class type conversion.\n&#x27;
                         &#x27;     * FIXME Follow-up has added a new type of time &#x27;
                         &#x27;needs to be modified\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param fieldTypeArray\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void buildSqlTypes(List&lt;Class&gt; &#x27;
                         &#x27;fieldTypeArray) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int[] tmpFieldsType = new &#x27;
                         &#x27;int[fieldTypeArray.size()];\n&#x27;
                         &#x27;        for (int i = 0; i &lt; fieldTypeArray.size(); &#x27;
                         &#x27;i++) {\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;fieldTypeArray.get(i).getName();\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(fieldType.equals(Integer.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.INTEGER;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Boolean.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BOOLEAN;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Long.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BIGINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TINYINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Short.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.SMALLINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(String.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.CHAR;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BINARY;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Float.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.FLOAT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Double.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DOUBLE;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Timestamp.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TIMESTAMP;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(BigDecimal.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DECIMAL;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Date.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DATE;\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                throw new RuntimeException(&quot;no &#x27;
                         &#x27;support field type for sql. the input type:&quot; + &#x27;
                         &#x27;fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.sqlTypes = tmpFieldsType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TableSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;configure(String[] fieldNames, TypeInformation&lt;?&gt;[] &#x27;
                         &#x27;fieldTypes) {\n&#x27;
                         &#x27;        this.fieldNames = fieldNames;\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                         &#x27;        this.batchNum = batchNum;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchWaitInterval(long &#x27;
                         &#x27;batchWaitInterval) {\n&#x27;
                         &#x27;        this.batchWaitInterval = batchWaitInterval;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TupleTypeInfo&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;getOutputType() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;TupleTypeInfo(org.apache.flink.table.api.Types.BOOLEAN(), &#x27;
                         &#x27;getRecordType());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;Row&gt; getRecordType() {\n&#x27;
                         &#x27;        return new RowTypeInfo(fieldTypes, &#x27;
                         &#x27;fieldNames);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String[] getFieldNames() {\n&#x27;
                         &#x27;        return fieldNames;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;?&gt;[] getFieldTypes() {\n&#x27;
                         &#x27;        return fieldTypes;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setParallelism(int parallelism) {\n&#x27;
                         &#x27;        this.parallelism = parallelism;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setDbType(String dbType) {\n&#x27;
                         &#x27;        this.dbType = dbType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * you need to implements  this method in your &#x27;
                         &#x27;own class.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fields\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract void buildSql(String schema, &#x27;
                         &#x27;String tableName, List&lt;String&gt; fields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * sqlserver and oracle maybe implement\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fieldNames\n&#x27;
                         &#x27;     * @param realIndexes\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract String buildUpdateSql(String &#x27;
                         &#x27;schema, String tableName, List&lt;String&gt; fieldNames, &#x27;
                         &#x27;Map&lt;String, List&lt;String&gt;&gt; realIndexes, List&lt;String&gt; &#x27;
                         &#x27;fullField);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract String getDriverName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract RetractJDBCOutputFormat &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;emitDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        consumeDataStream(dataStream);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public DataStreamSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;consumeDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        RichSinkFunction richSinkFunction = &#x27;
                         &#x27;createJdbcSinkFunc();\n&#x27;
                         &#x27;        DataStreamSink streamSink = &#x27;
                         &#x27;dataStream.addSink(richSinkFunction);\n&#x27;
                         &#x27;        streamSink.name(registerTabName);\n&#x27;
                         &#x27;        if (parallelism &gt; 0) {\n&#x27;
                         &#x27;            streamSink.setParallelism(parallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return streamSink;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/**\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.rdb;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.sink.IStreamSinkGener;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.format.RetractJDBCOutputFormat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.table.RdbTableInfo;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.TupleTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStreamSink;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.OutputFormatSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.RichSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.sinks.RetractStreamTableSink;\n&#x27;
                         &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.Serializable;\n&#x27;
                         &#x27;import java.math.BigDecimal;\n&#x27;
                         &#x27;import java.sql.Date;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.sql.Types;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/11/27\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public abstract class RdbSink implements &#x27;
                         &#x27;RetractStreamTableSink&lt;Row&gt;, Serializable, &#x27;
                         &#x27;IStreamSinkGener&lt;RdbSink&gt; {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String driverName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbURL;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String userName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String password;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int batchNum = 100;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected long batchWaitInterval = 10000;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int[] sqlTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String tableName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String registerTabName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String sql;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String[] fieldNames;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private int parallelism = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String schema;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RichSinkFunction createJdbcSinkFunc() {\n&#x27;
                         &#x27;        if (driverName == null || dbURL == null || &#x27;
                         &#x27;userName == null\n&#x27;
                         &#x27;                || password == null || sqlTypes == &#x27;
                         &#x27;null || tableName == null) {\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;any of &#x27;
                         &#x27;params in(driverName, dbURL, userName, password, &#x27;
                         &#x27;type, tableName) &quot; +\n&#x27;
                         &#x27;                    &quot; must not be null. please check &#x27;
                         &#x27;it!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        RetractJDBCOutputFormat outputFormat = &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;        outputFormat.setDbURL(dbURL);\n&#x27;
                         &#x27;        outputFormat.setDrivername(driverName);\n&#x27;
                         &#x27;        outputFormat.setUsername(userName);\n&#x27;
                         &#x27;        outputFormat.setPassword(password);\n&#x27;
                         &#x27;        outputFormat.setInsertQuery(sql);\n&#x27;
                         &#x27;        outputFormat.setBatchNum(batchNum);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;outputFormat.setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        outputFormat.setTypesArray(sqlTypes);\n&#x27;
                         &#x27;        outputFormat.setTableName(tableName);\n&#x27;
                         &#x27;        outputFormat.setDbType(dbType);\n&#x27;
                         &#x27;        outputFormat.setSchema(schema);\n&#x27;
                         &#x27;        outputFormat.setDbSink(this);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        outputFormat.verifyField();\n&#x27;
                         &#x27;        OutputFormatSinkFunction &#x27;
                         &#x27;outputFormatSinkFunc = new &#x27;
                         &#x27;OutputFormatSinkFunction(outputFormat);\n&#x27;
                         &#x27;        return outputFormatSinkFunc;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public RdbSink genStreamSink(TargetTableInfo &#x27;
                         &#x27;targetTableInfo) {\n&#x27;
                         &#x27;        RdbTableInfo rdbTableInfo = (RdbTableInfo) &#x27;
                         &#x27;targetTableInfo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String tmpDbURL = rdbTableInfo.getUrl();\n&#x27;
                         &#x27;        String tmpUserName = &#x27;
                         &#x27;rdbTableInfo.getUserName();\n&#x27;
                         &#x27;        String tmpPassword = &#x27;
                         &#x27;rdbTableInfo.getPassword();\n&#x27;
                         &#x27;        String tmpTableName = &#x27;
                         &#x27;rdbTableInfo.getTableName();\n&#x27;
                         &#x27;        String tmpRegisterName = &#x27;
                         &#x27;rdbTableInfo.getName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSqlBatchSize = &#x27;
                         &#x27;rdbTableInfo.getBatchSize();\n&#x27;
                         &#x27;        if (tmpSqlBatchSize != null) {\n&#x27;
                         &#x27;            setBatchNum(tmpSqlBatchSize);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Long batchWaitInterval = &#x27;
                         &#x27;rdbTableInfo.getBatchWaitInterval();\n&#x27;
                         &#x27;        if (batchWaitInterval != null) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSinkParallelism = &#x27;
                         &#x27;rdbTableInfo.getParallelism();\n&#x27;
                         &#x27;        if (tmpSinkParallelism != null) {\n&#x27;
                         &#x27;            setParallelism(tmpSinkParallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fields = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFields());\n&#x27;
                         &#x27;        List&lt;Class&gt; fieldTypeArray = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFieldClasses());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.driverName = getDriverName();\n&#x27;
                         &#x27;        this.dbURL = tmpDbURL;\n&#x27;
                         &#x27;        this.userName = tmpUserName;\n&#x27;
                         &#x27;        this.password = tmpPassword;\n&#x27;
                         &#x27;        this.tableName = tmpTableName;\n&#x27;
                         &#x27;        this.registerTabName = tmpRegisterName;\n&#x27;
                         &#x27;        this.primaryKeys = &#x27;
                         &#x27;rdbTableInfo.getPrimaryKeys();\n&#x27;
                         &#x27;        this.dbType = rdbTableInfo.getType();\n&#x27;
                         &#x27;        this.schema = rdbTableInfo.getSchema();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        buildSql(schema, tableName, fields);\n&#x27;
                         &#x27;        buildSqlTypes(fieldTypeArray);\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * By now specified class type conversion.\n&#x27;
                         &#x27;     * FIXME Follow-up has added a new type of time &#x27;
                         &#x27;needs to be modified\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param fieldTypeArray\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void buildSqlTypes(List&lt;Class&gt; &#x27;
                         &#x27;fieldTypeArray) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int[] tmpFieldsType = new &#x27;
                         &#x27;int[fieldTypeArray.size()];\n&#x27;
                         &#x27;        for (int i = 0; i &lt; fieldTypeArray.size(); &#x27;
                         &#x27;i++) {\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;fieldTypeArray.get(i).getName();\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(fieldType.equals(Integer.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.INTEGER;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Boolean.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BOOLEAN;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Long.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BIGINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TINYINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Short.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.SMALLINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(String.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.CHAR;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BINARY;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Float.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.FLOAT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Double.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DOUBLE;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Timestamp.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TIMESTAMP;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(BigDecimal.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DECIMAL;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Date.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DATE;\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                throw new RuntimeException(&quot;no &#x27;
                         &#x27;support field type for sql. the input type:&quot; + &#x27;
                         &#x27;fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.sqlTypes = tmpFieldsType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TableSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;configure(String[] fieldNames, TypeInformation&lt;?&gt;[] &#x27;
                         &#x27;fieldTypes) {\n&#x27;
                         &#x27;        this.fieldNames = fieldNames;\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                         &#x27;        this.batchNum = batchNum;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchWaitInterval(long &#x27;
                         &#x27;batchWaitInterval) {\n&#x27;
                         &#x27;        this.batchWaitInterval = batchWaitInterval;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TupleTypeInfo&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;getOutputType() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;TupleTypeInfo(org.apache.flink.table.api.Types.BOOLEAN(), &#x27;
                         &#x27;getRecordType());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;Row&gt; getRecordType() {\n&#x27;
                         &#x27;        return new RowTypeInfo(fieldTypes, &#x27;
                         &#x27;fieldNames);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String[] getFieldNames() {\n&#x27;
                         &#x27;        return fieldNames;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;?&gt;[] getFieldTypes() {\n&#x27;
                         &#x27;        return fieldTypes;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setParallelism(int parallelism) {\n&#x27;
                         &#x27;        this.parallelism = parallelism;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setDbType(String dbType) {\n&#x27;
                         &#x27;        this.dbType = dbType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * you need to implements  this method in your &#x27;
                         &#x27;own class.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fields\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract void buildSql(String schema, &#x27;
                         &#x27;String tableName, List&lt;String&gt; fields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * sqlserver and oracle maybe implement\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fieldNames\n&#x27;
                         &#x27;     * @param realIndexes\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract String buildUpdateSql(String &#x27;
                         &#x27;schema, String tableName, List&lt;String&gt; fieldNames, &#x27;
                         &#x27;Map&lt;String, List&lt;String&gt;&gt; realIndexes, List&lt;String&gt; &#x27;
                         &#x27;fullField);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract String getDriverName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract RetractJDBCOutputFormat &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;emitDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        consumeDataStream(dataStream);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public DataStreamSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;consumeDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        RichSinkFunction richSinkFunction = &#x27;
                         &#x27;createJdbcSinkFunc();\n&#x27;
                         &#x27;        DataStreamSink streamSink = &#x27;
                         &#x27;dataStream.addSink(richSinkFunction);\n&#x27;
                         &#x27;        streamSink.name(registerTabName);\n&#x27;
                         &#x27;        if (parallelism &gt; 0) {\n&#x27;
                         &#x27;            streamSink.setParallelism(parallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return streamSink;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/**\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; * &lt;p&gt;\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.dtstack.flink.sql.sink.rdb;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.sink.IStreamSinkGener;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.format.RetractJDBCOutputFormat;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.table.RdbTableInfo;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                         &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.api.java.typeutils.TupleTypeInfo;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.datastream.DataStreamSink;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.OutputFormatSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.sink.RichSinkFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.sinks.RetractStreamTableSink;\n&#x27;
                         &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.io.Serializable;\n&#x27;
                         &#x27;import java.math.BigDecimal;\n&#x27;
                         &#x27;import java.sql.Date;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.sql.Types;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Map;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Reason:\n&#x27;
                         &#x27; * Date: 2018/11/27\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @author maqi\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public abstract class RdbSink implements &#x27;
                         &#x27;RetractStreamTableSink&lt;Row&gt;, Serializable, &#x27;
                         &#x27;IStreamSinkGener&lt;RdbSink&gt; {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String driverName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbURL;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String userName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String password;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String dbType;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int batchNum = 100;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected long batchWaitInterval = 10000;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected int[] sqlTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String tableName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String registerTabName;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String sql;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected List&lt;String&gt; primaryKeys;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected String[] fieldNames;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TypeInformation[] fieldTypes;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private int parallelism = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String schema;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public RichSinkFunction createJdbcSinkFunc() {\n&#x27;
                         &#x27;        if (driverName == null || dbURL == null || &#x27;
                         &#x27;userName == null\n&#x27;
                         &#x27;                || password == null || sqlTypes == &#x27;
                         &#x27;null || tableName == null) {\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;any of &#x27;
                         &#x27;params in(driverName, dbURL, userName, password, &#x27;
                         &#x27;type, tableName) &quot; +\n&#x27;
                         &#x27;                    &quot; must not be null. please check &#x27;
                         &#x27;it!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        RetractJDBCOutputFormat outputFormat = &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;        outputFormat.setDbURL(dbURL);\n&#x27;
                         &#x27;        outputFormat.setDrivername(driverName);\n&#x27;
                         &#x27;        outputFormat.setUsername(userName);\n&#x27;
                         &#x27;        outputFormat.setPassword(password);\n&#x27;
                         &#x27;        outputFormat.setInsertQuery(sql);\n&#x27;
                         &#x27;        outputFormat.setBatchNum(batchNum);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;outputFormat.setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        outputFormat.setTypesArray(sqlTypes);\n&#x27;
                         &#x27;        outputFormat.setTableName(tableName);\n&#x27;
                         &#x27;        outputFormat.setDbType(dbType);\n&#x27;
                         &#x27;        outputFormat.setSchema(schema);\n&#x27;
                         &#x27;        outputFormat.setDbSink(this);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        outputFormat.verifyField();\n&#x27;
                         &#x27;        OutputFormatSinkFunction &#x27;
                         &#x27;outputFormatSinkFunc = new &#x27;
                         &#x27;OutputFormatSinkFunction(outputFormat);\n&#x27;
                         &#x27;        return outputFormatSinkFunc;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public RdbSink genStreamSink(TargetTableInfo &#x27;
                         &#x27;targetTableInfo) {\n&#x27;
                         &#x27;        RdbTableInfo rdbTableInfo = (RdbTableInfo) &#x27;
                         &#x27;targetTableInfo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String tmpDbURL = rdbTableInfo.getUrl();\n&#x27;
                         &#x27;        String tmpUserName = &#x27;
                         &#x27;rdbTableInfo.getUserName();\n&#x27;
                         &#x27;        String tmpPassword = &#x27;
                         &#x27;rdbTableInfo.getPassword();\n&#x27;
                         &#x27;        String tmpTableName = &#x27;
                         &#x27;rdbTableInfo.getTableName();\n&#x27;
                         &#x27;        String tmpRegisterName = &#x27;
                         &#x27;rdbTableInfo.getName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSqlBatchSize = &#x27;
                         &#x27;rdbTableInfo.getBatchSize();\n&#x27;
                         &#x27;        if (tmpSqlBatchSize != null) {\n&#x27;
                         &#x27;            setBatchNum(tmpSqlBatchSize);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Long batchWaitInterval = &#x27;
                         &#x27;rdbTableInfo.getBatchWaitInterval();\n&#x27;
                         &#x27;        if (batchWaitInterval != null) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;setBatchWaitInterval(batchWaitInterval);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Integer tmpSinkParallelism = &#x27;
                         &#x27;rdbTableInfo.getParallelism();\n&#x27;
                         &#x27;        if (tmpSinkParallelism != null) {\n&#x27;
                         &#x27;            setParallelism(tmpSinkParallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; fields = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFields());\n&#x27;
                         &#x27;        List&lt;Class&gt; fieldTypeArray = &#x27;
                         &#x27;Arrays.asList(rdbTableInfo.getFieldClasses());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.driverName = getDriverName();\n&#x27;
                         &#x27;        this.dbURL = tmpDbURL;\n&#x27;
                         &#x27;        this.userName = tmpUserName;\n&#x27;
                         &#x27;        this.password = tmpPassword;\n&#x27;
                         &#x27;        this.tableName = tmpTableName;\n&#x27;
                         &#x27;        this.registerTabName = tmpRegisterName;\n&#x27;
                         &#x27;        this.primaryKeys = &#x27;
                         &#x27;rdbTableInfo.getPrimaryKeys();\n&#x27;
                         &#x27;        this.dbType = rdbTableInfo.getType();\n&#x27;
                         &#x27;        this.schema = rdbTableInfo.getSchema();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        buildSql(schema, tableName, fields);\n&#x27;
                         &#x27;        buildSqlTypes(fieldTypeArray);\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * By now specified class type conversion.\n&#x27;
                         &#x27;     * FIXME Follow-up has added a new type of time &#x27;
                         &#x27;needs to be modified\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param fieldTypeArray\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected void buildSqlTypes(List&lt;Class&gt; &#x27;
                         &#x27;fieldTypeArray) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int[] tmpFieldsType = new &#x27;
                         &#x27;int[fieldTypeArray.size()];\n&#x27;
                         &#x27;        for (int i = 0; i &lt; fieldTypeArray.size(); &#x27;
                         &#x27;i++) {\n&#x27;
                         &#x27;            String fieldType = &#x27;
                         &#x27;fieldTypeArray.get(i).getName();\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(fieldType.equals(Integer.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.INTEGER;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Boolean.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BOOLEAN;\n&#x27;
                         &#x27;            }else if &#x27;
                         &#x27;(fieldType.equals(Long.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BIGINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TINYINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Short.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.SMALLINT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(String.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.CHAR;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Byte.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.BINARY;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Float.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.FLOAT;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Double.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DOUBLE;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Timestamp.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.TIMESTAMP;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(BigDecimal.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DECIMAL;\n&#x27;
                         &#x27;            } else if &#x27;
                         &#x27;(fieldType.equals(Date.class.getName())) {\n&#x27;
                         &#x27;                tmpFieldsType[i] = Types.DATE;\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                throw new RuntimeException(&quot;no &#x27;
                         &#x27;support field type for sql. the input type:&quot; + &#x27;
                         &#x27;fieldType);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        this.sqlTypes = tmpFieldsType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TableSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;configure(String[] fieldNames, TypeInformation&lt;?&gt;[] &#x27;
                         &#x27;fieldTypes) {\n&#x27;
                         &#x27;        this.fieldNames = fieldNames;\n&#x27;
                         &#x27;        this.fieldTypes = fieldTypes;\n&#x27;
                         &#x27;        return this;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchNum(int batchNum) {\n&#x27;
                         &#x27;        this.batchNum = batchNum;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setBatchWaitInterval(long &#x27;
                         &#x27;batchWaitInterval) {\n&#x27;
                         &#x27;        this.batchWaitInterval = batchWaitInterval;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TupleTypeInfo&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;getOutputType() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;TupleTypeInfo(org.apache.flink.table.api.Types.BOOLEAN(), &#x27;
                         &#x27;getRecordType());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;Row&gt; getRecordType() {\n&#x27;
                         &#x27;        return new RowTypeInfo(fieldTypes, &#x27;
                         &#x27;fieldNames);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public String[] getFieldNames() {\n&#x27;
                         &#x27;        return fieldNames;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;?&gt;[] getFieldTypes() {\n&#x27;
                         &#x27;        return fieldTypes;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setParallelism(int parallelism) {\n&#x27;
                         &#x27;        this.parallelism = parallelism;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void setDbType(String dbType) {\n&#x27;
                         &#x27;        this.dbType = dbType;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * you need to implements  this method in your &#x27;
                         &#x27;own class.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fields\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract void buildSql(String schema, &#x27;
                         &#x27;String tableName, List&lt;String&gt; fields);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * sqlserver and oracle maybe implement\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param tableName\n&#x27;
                         &#x27;     * @param fieldNames\n&#x27;
                         &#x27;     * @param realIndexes\n&#x27;
                         &#x27;     * @return\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public abstract String buildUpdateSql(String &#x27;
                         &#x27;schema, String tableName, List&lt;String&gt; fieldNames, &#x27;
                         &#x27;Map&lt;String, List&lt;String&gt;&gt; realIndexes, List&lt;String&gt; &#x27;
                         &#x27;fullField);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract String getDriverName();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public abstract RetractJDBCOutputFormat &#x27;
                         &#x27;getOutputFormat();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;emitDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        consumeDataStream(dataStream);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public DataStreamSink&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;consumeDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; &#x27;
                         &#x27;dataStream) {\n&#x27;
                         &#x27;        RichSinkFunction richSinkFunction = &#x27;
                         &#x27;createJdbcSinkFunc();\n&#x27;
                         &#x27;        DataStreamSink streamSink = &#x27;
                         &#x27;dataStream.addSink(richSinkFunction);\n&#x27;
                         &#x27;        streamSink.name(registerTabName);\n&#x27;
                         &#x27;        if (parallelism &gt; 0) {\n&#x27;
                         &#x27;            streamSink.setParallelism(parallelism);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return streamSink;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        