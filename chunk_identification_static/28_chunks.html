<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>28 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;import android.os.Handler;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.BaseDListener;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  protected final String TAG;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private final String TAG = &quot;AbsFileer&quot;;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;  protected final String TAG;\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n  private final String TAG = &quot;AbsFileer&quot;;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  protected int mTotalThreadNum; //总线程数\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n  protected int mTotalThreadNum; //总线程数\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  private IThreadState mStateManager;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private ThreadStateManager mStateManager;\n&#x27;
                           &#x27;  private Handler mStateHandler;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;  private IThreadState mStateManager;\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;  private ThreadStateManager mStateManager;\n&#x27;
                           &#x27;  private Handler mStateHandler;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    TAG = CommonUtil.getClassName(getClass());\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  protected abstract IThreadState &#x27;
                         &#x27;getStateManager(Looper looper);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理任务\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected abstract void handleTask();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    TAG = CommonUtil.getClassName(getClass());\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  protected abstract IThreadState &#x27;
                         &#x27;getStateManager(Looper looper);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理任务\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected abstract void handleTask();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n  }\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;    mTotalThreadNum = 0;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;    mTotalThreadNum = 0;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n    mTotalThreadNum = 0;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    Looper.prepare();\n&#x27;
                         &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                         &#x27;    mStateManager = getStateManager(looper);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    mTotalThreadNum = mRecord.threadNum;\n&#x27;
                           &#x27;    Looper.prepare();\n&#x27;
                           &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                           &#x27;    mStateManager = new ThreadStateManager(looper, &#x27;
                           &#x27;mRecord, mListener);\n&#x27;
                           &#x27;    mStateHandler = new Handler(looper, &#x27;
                           &#x27;mStateManager);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    Looper.prepare();\n&#x27;
                         &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                         &#x27;    mStateManager = getStateManager(looper);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    mTotalThreadNum = mRecord.threadNum;\n&#x27;
                           &#x27;    Looper.prepare();\n&#x27;
                           &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                           &#x27;    mStateManager = new ThreadStateManager(looper, &#x27;
                           &#x27;mRecord, mListener);\n&#x27;
                           &#x27;    mStateHandler = new Handler(looper, &#x27;
                           &#x27;mStateManager);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    Looper.prepare();\n&#x27;
                         &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                         &#x27;    mStateManager = getStateManager(looper);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    mTotalThreadNum = mRecord.threadNum;\n&#x27;
                           &#x27;    Looper.prepare();\n&#x27;
                           &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                           &#x27;    mStateManager = new ThreadStateManager(looper, &#x27;
                           &#x27;mRecord, mListener);\n&#x27;
                           &#x27;    mStateHandler = new Handler(looper, &#x27;
                           &#x27;mStateManager);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;      handleNoSupportBP();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      handleBreakpoint();\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;      handleNoSupportBP();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      handleBreakpoint();\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;      handleNoSupportBP();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      handleBreakpoint();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    handleTask();\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    handleTask();\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    handleTask();\n\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;   * 延迟启动定时器\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected long delayTimer() {\n&#x27;
                         &#x27;    return 1000;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;   * 延迟启动定时器\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected long delayTimer() {\n&#x27;
                         &#x27;    return 1000;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   * 启动断点任务时，创建单线程任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param record 线程记录\n&#x27;
                           &#x27;   * @param startNum 启动的线程数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private AbsThreadTask &#x27;
                           &#x27;createSingThreadTask(ThreadRecord record, int &#x27;
                           &#x27;startNum) {\n&#x27;
                           &#x27;    SubThreadConfig&lt;TASK_WRAPPER&gt; config = new &#x27;
                           &#x27;SubThreadConfig&lt;&gt;();\n&#x27;
                           &#x27;    config.url = mEntity.isRedirect() ? &#x27;
                           &#x27;mEntity.getRedirectUrl() : mEntity.getUrl();\n&#x27;
                           &#x27;    config.tempFile =\n&#x27;
                           &#x27;        mRecord.isBlock ? new File(\n&#x27;
                           &#x27;            String.format(RecordHandler.SUB_PATH, &#x27;
                           &#x27;mTempFile.getPath(), record.threadId))\n&#x27;
                           &#x27;            : mTempFile;\n&#x27;
                           &#x27;    config.isBlock = mRecord.isBlock;\n&#x27;
                           &#x27;    config.isOpenDynamicFile = &#x27;
                           &#x27;mRecord.isOpenDynamicFile;\n&#x27;
                           &#x27;    config.startThreadNum = startNum;\n&#x27;
                           &#x27;    config.taskWrapper = mTaskWrapper;\n&#x27;
                           &#x27;    config.record = record;\n&#x27;
                           &#x27;    config.stateHandler = mStateHandler;\n&#x27;
                           &#x27;    return selectThreadTask(config);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleBreakpoint() {\n&#x27;
                           &#x27;    long fileLength = mEntity.getFileSize();\n&#x27;
                           &#x27;    long blockSize = fileLength / &#x27;
                           &#x27;mTotalThreadNum;\n&#x27;
                           &#x27;    long currentProgress = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mRecord.fileLength = fileLength;\n&#x27;
                           &#x27;    if (mTaskWrapper.isNewTask() &amp;&amp; &#x27;
                           &#x27;!handleNewTask()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int startNum = mRecord.threadNum;\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (!tr.isComplete) {\n&#x27;
                           &#x27;        startNum++;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTotalThreadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(i);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      if (tr.isComplete) {//该线程已经完成\n&#x27;
                           &#x27;        currentProgress += endL - startL;\n&#x27;
                           &#x27;        ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__已完成&quot;, &#x27;
                           &#x27;mTaskWrapper.getEntity().getFileName(), i));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_COMPLETE).sendToTarget();\n&#x27;
                           &#x27;        if (mStateManager.isComplete()) {\n&#x27;
                           &#x27;          mRecord.deleteData();\n&#x27;
                           &#x27;          mListener.onComplete();\n&#x27;
                           &#x27;          return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        continue;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      //如果有记录，则恢复任务\n&#x27;
                           &#x27;      long r = tr.startLocation;\n&#x27;
                           &#x27;      //记录的位置需要在线程区间中\n&#x27;
                           &#x27;      if (startL &lt; r &amp;&amp; r &lt;= (i == &#x27;
                           &#x27;(mTotalThreadNum - 1) ? fileLength : endL)) {\n&#x27;
                           &#x27;        currentProgress += r - startL;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, &#x27;
                           &#x27;mEntity.getFileName(), i));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(tr, startNum);\n&#x27;
                           &#x27;      if (task == null) return;\n&#x27;
                           &#x27;      mTask.put(tr.threadId, task);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (currentProgress != 0 &amp;&amp; currentProgress != &#x27;
                           &#x27;mEntity.getCurrentProgress()) {\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;进度修正，当前进度：%s&quot;, &#x27;
                           &#x27;currentProgress));\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mEntity.setCurrentProgress(currentProgress);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_UPDATE_PROGRESS, &#x27;
                           &#x27;currentProgress)\n&#x27;
                           &#x27;        .sendToTarget();\n&#x27;
                           &#x27;    startThreadTask();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 启动单线程任务\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void startThreadTask() {\n&#x27;
                           &#x27;    if (isBreak()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (mStateManager.getCurrentProgress() &gt; 0) {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mListener.onResume(mStateManager.getCurrentProgress());\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mListener.onStart(mStateManager.getCurrentProgress());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTask.size(); i++) {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;mTask.get(i));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;   * 启动断点任务时，创建单线程任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param record 线程记录\n&#x27;
                           &#x27;   * @param startNum 启动的线程数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private AbsThreadTask &#x27;
                           &#x27;createSingThreadTask(ThreadRecord record, int &#x27;
                           &#x27;startNum) {\n&#x27;
                           &#x27;    SubThreadConfig&lt;TASK_WRAPPER&gt; config = new &#x27;
                           &#x27;SubThreadConfig&lt;&gt;();\n&#x27;
                           &#x27;    config.url = mEntity.isRedirect() ? &#x27;
                           &#x27;mEntity.getRedirectUrl() : mEntity.getUrl();\n&#x27;
                           &#x27;    config.tempFile =\n&#x27;
                           &#x27;        mRecord.isBlock ? new File(\n&#x27;
                           &#x27;            String.format(RecordHandler.SUB_PATH, &#x27;
                           &#x27;mTempFile.getPath(), record.threadId))\n&#x27;
                           &#x27;            : mTempFile;\n&#x27;
                           &#x27;    config.isBlock = mRecord.isBlock;\n&#x27;
                           &#x27;    config.isOpenDynamicFile = &#x27;
                           &#x27;mRecord.isOpenDynamicFile;\n&#x27;
                           &#x27;    config.startThreadNum = startNum;\n&#x27;
                           &#x27;    config.taskWrapper = mTaskWrapper;\n&#x27;
                           &#x27;    config.record = record;\n&#x27;
                           &#x27;    config.stateHandler = mStateHandler;\n&#x27;
                           &#x27;    return selectThreadTask(config);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleBreakpoint() {\n&#x27;
                           &#x27;    long fileLength = mEntity.getFileSize();\n&#x27;
                           &#x27;    long blockSize = fileLength / &#x27;
                           &#x27;mTotalThreadNum;\n&#x27;
                           &#x27;    long currentProgress = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mRecord.fileLength = fileLength;\n&#x27;
                           &#x27;    if (mTaskWrapper.isNewTask() &amp;&amp; &#x27;
                           &#x27;!handleNewTask()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int startNum = mRecord.threadNum;\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (!tr.isComplete) {\n&#x27;
                           &#x27;        startNum++;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTotalThreadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(i);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      if (tr.isComplete) {//该线程已经完成\n&#x27;
                           &#x27;        currentProgress += endL - startL;\n&#x27;
                           &#x27;        ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__已完成&quot;, &#x27;
                           &#x27;mTaskWrapper.getEntity().getFileName(), i));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_COMPLETE).sendToTarget();\n&#x27;
                           &#x27;        if (mStateManager.isComplete()) {\n&#x27;
                           &#x27;          mRecord.deleteData();\n&#x27;
                           &#x27;          mListener.onComplete();\n&#x27;
                           &#x27;          return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        continue;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      //如果有记录，则恢复任务\n&#x27;
                           &#x27;      long r = tr.startLocation;\n&#x27;
                           &#x27;      //记录的位置需要在线程区间中\n&#x27;
                           &#x27;      if (startL &lt; r &amp;&amp; r &lt;= (i == &#x27;
                           &#x27;(mTotalThreadNum - 1) ? fileLength : endL)) {\n&#x27;
                           &#x27;        currentProgress += r - startL;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, &#x27;
                           &#x27;mEntity.getFileName(), i));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(tr, startNum);\n&#x27;
                           &#x27;      if (task == null) return;\n&#x27;
                           &#x27;      mTask.put(tr.threadId, task);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (currentProgress != 0 &amp;&amp; currentProgress != &#x27;
                           &#x27;mEntity.getCurrentProgress()) {\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;进度修正，当前进度：%s&quot;, &#x27;
                           &#x27;currentProgress));\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mEntity.setCurrentProgress(currentProgress);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_UPDATE_PROGRESS, &#x27;
                           &#x27;currentProgress)\n&#x27;
                           &#x27;        .sendToTarget();\n&#x27;
                           &#x27;    startThreadTask();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 启动单线程任务\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void startThreadTask() {\n&#x27;
                           &#x27;    if (isBreak()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (mStateManager.getCurrentProgress() &gt; 0) {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mListener.onResume(mStateManager.getCurrentProgress());\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mListener.onStart(mStateManager.getCurrentProgress());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTask.size(); i++) {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;mTask.get(i));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   * 处理新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@code true}创建新任务失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  protected abstract boolean handleNewTask();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的任务\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBP() {\n&#x27;
                           &#x27;    if (mListener instanceof BaseDListener) {\n&#x27;
                           &#x27;      ((BaseDListener) &#x27;
                           &#x27;mListener).supportBreakpoint(false);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(mRecord.threadRecords.get(0), &#x27;
                           &#x27;1);\n&#x27;
                           &#x27;    if (task == null) return;\n&#x27;
                           &#x27;    mTask.put(0, task);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;task);\n&#x27;
                           &#x27;    mListener.onStart(0);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 选择单任务线程的类型\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  protected abstract AbsThreadTask &#x27;
                           &#x27;selectThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; &#x27;
                           &#x27;config);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;   * 处理新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@code true}创建新任务失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  protected abstract boolean handleNewTask();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的任务\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBP() {\n&#x27;
                           &#x27;    if (mListener instanceof BaseDListener) {\n&#x27;
                           &#x27;      ((BaseDListener) &#x27;
                           &#x27;mListener).supportBreakpoint(false);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(mRecord.threadRecords.get(0), &#x27;
                           &#x27;1);\n&#x27;
                           &#x27;    if (task == null) return;\n&#x27;
                           &#x27;    mTask.put(0, task);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;task);\n&#x27;
                           &#x27;    mListener.onStart(0);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 选择单任务线程的类型\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  protected abstract AbsThreadTask &#x27;
                           &#x27;selectThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; &#x27;
                           &#x27;config);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27; //文件\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27; //文件\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27; //总线程数\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;private IThreadState mStateManager;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private ThreadStateManager mStateManager;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    TAG = CommonUtil.getClassName(getClass());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private void handleBreakpoint() {\n&#x27;
                           &#x27;    long fileLength = mEntity.getFileSize();\n&#x27;
                           &#x27;    long blockSize = fileLength / &#x27;
                           &#x27;mTotalThreadNum;\n&#x27;
                           &#x27;    long currentProgress = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mRecord.fileLength = fileLength;\n&#x27;
                           &#x27;    if (mTaskWrapper.isNewTask() &amp;&amp; &#x27;
                           &#x27;!handleNewTask()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int startNum = mRecord.threadNum;\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (!tr.isComplete) {\n&#x27;
                           &#x27;        startNum++;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTotalThreadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(i);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      if (tr.isComplete) {//该线程已经完成\n&#x27;
                           &#x27;        currentProgress += endL - startL;\n&#x27;
                           &#x27;        ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__已完成&quot;, &#x27;
                           &#x27;mTaskWrapper.getEntity().getFileName(), i));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_COMPLETE).sendToTarget();\n&#x27;
                           &#x27;        if (mStateManager.isComplete()) {\n&#x27;
                           &#x27;          mRecord.deleteData();\n&#x27;
                           &#x27;          mListener.onComplete();\n&#x27;
                           &#x27;          return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        continue;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      //如果有记录，则恢复任务\n&#x27;
                           &#x27;      long r = tr.startLocation;\n&#x27;
                           &#x27;      //记录的位置需要在线程区间中\n&#x27;
                           &#x27;      if (startL &lt; r &amp;&amp; r &lt;= (i == &#x27;
                           &#x27;(mTotalThreadNum - 1) ? fileLength : endL)) {\n&#x27;
                           &#x27;        currentProgress += r - startL;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, &#x27;
                           &#x27;mEntity.getFileName(), i));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(tr, startNum);\n&#x27;
                           &#x27;      if (task == null) return;\n&#x27;
                           &#x27;      mTask.put(tr.threadId, task);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (currentProgress != 0 &amp;&amp; currentProgress != &#x27;
                           &#x27;mEntity.getCurrentProgress()) {\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;进度修正，当前进度：%s&quot;, &#x27;
                           &#x27;currentProgress));\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mEntity.setCurrentProgress(currentProgress);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_UPDATE_PROGRESS, &#x27;
                           &#x27;currentProgress)\n&#x27;
                           &#x27;        .sendToTarget();\n&#x27;
                           &#x27;    startThreadTask();\n&#x27;
                           &#x27;  }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private void handleNoSupportBP() {\n&#x27;
                           &#x27;    if (mListener instanceof BaseDListener) {\n&#x27;
                           &#x27;      ((BaseDListener) &#x27;
                           &#x27;mListener).supportBreakpoint(false);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(mRecord.threadRecords.get(0), &#x27;
                           &#x27;1);\n&#x27;
                           &#x27;    if (task == null) return;\n&#x27;
                           &#x27;    mTask.put(0, task);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;task);\n&#x27;
                           &#x27;    mListener.onStart(0);\n&#x27;
                           &#x27;  }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;import android.os.Handler;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.BaseDListener;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  protected final String TAG;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private final String TAG = &quot;AbsFileer&quot;;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;  protected final String TAG;\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n  private final String TAG = &quot;AbsFileer&quot;;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  protected int mTotalThreadNum; //总线程数\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n  protected int mTotalThreadNum; //总线程数\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  private IThreadState mStateManager;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private ThreadStateManager mStateManager;\n&#x27;
                           &#x27;  private Handler mStateHandler;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;private IThreadState mStateManager;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private ThreadStateManager mStateManager;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;  private IThreadState mStateManager;\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;  private ThreadStateManager mStateManager;\n&#x27;
                           &#x27;  private Handler mStateHandler;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    TAG = CommonUtil.getClassName(getClass());\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  protected abstract IThreadState &#x27;
                         &#x27;getStateManager(Looper looper);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理任务\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected abstract void handleTask();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    handleTask();\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    TAG = CommonUtil.getClassName(getClass());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    handleTask();\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    TAG = CommonUtil.getClassName(getClass());\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  protected abstract IThreadState &#x27;
                         &#x27;getStateManager(Looper looper);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理任务\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected abstract void handleTask();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n  }\n\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    handleTask();\n\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;    mTotalThreadNum = 0;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;    mTotalThreadNum = 0;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n    mTotalThreadNum = 0;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    Looper.prepare();\n&#x27;
                         &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                         &#x27;    mStateManager = getStateManager(looper);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    mTotalThreadNum = mRecord.threadNum;\n&#x27;
                           &#x27;    Looper.prepare();\n&#x27;
                           &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                           &#x27;    mStateManager = new ThreadStateManager(looper, &#x27;
                           &#x27;mRecord, mListener);\n&#x27;
                           &#x27;    mStateHandler = new Handler(looper, &#x27;
                           &#x27;mStateManager);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    Looper.prepare();\n&#x27;
                         &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                         &#x27;    mStateManager = getStateManager(looper);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    mTotalThreadNum = mRecord.threadNum;\n&#x27;
                           &#x27;    Looper.prepare();\n&#x27;
                           &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                           &#x27;    mStateManager = new ThreadStateManager(looper, &#x27;
                           &#x27;mRecord, mListener);\n&#x27;
                           &#x27;    mStateHandler = new Handler(looper, &#x27;
                           &#x27;mStateManager);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    Looper.prepare();\n&#x27;
                         &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                         &#x27;    mStateManager = getStateManager(looper);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    mTotalThreadNum = mRecord.threadNum;\n&#x27;
                           &#x27;    Looper.prepare();\n&#x27;
                           &#x27;    Looper looper = Looper.myLooper();\n&#x27;
                           &#x27;    mStateManager = new ThreadStateManager(looper, &#x27;
                           &#x27;mRecord, mListener);\n&#x27;
                           &#x27;    mStateHandler = new Handler(looper, &#x27;
                           &#x27;mStateManager);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;      handleNoSupportBP();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      handleBreakpoint();\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;      handleNoSupportBP();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      handleBreakpoint();\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;      handleNoSupportBP();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      handleBreakpoint();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;   * 延迟启动定时器\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected long delayTimer() {\n&#x27;
                         &#x27;    return 1000;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;   * 延迟启动定时器\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected long delayTimer() {\n&#x27;
                         &#x27;    return 1000;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   * 启动断点任务时，创建单线程任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param record 线程记录\n&#x27;
                           &#x27;   * @param startNum 启动的线程数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private AbsThreadTask &#x27;
                           &#x27;createSingThreadTask(ThreadRecord record, int &#x27;
                           &#x27;startNum) {\n&#x27;
                           &#x27;    SubThreadConfig&lt;TASK_WRAPPER&gt; config = new &#x27;
                           &#x27;SubThreadConfig&lt;&gt;();\n&#x27;
                           &#x27;    config.url = mEntity.isRedirect() ? &#x27;
                           &#x27;mEntity.getRedirectUrl() : mEntity.getUrl();\n&#x27;
                           &#x27;    config.tempFile =\n&#x27;
                           &#x27;        mRecord.isBlock ? new File(\n&#x27;
                           &#x27;            String.format(RecordHandler.SUB_PATH, &#x27;
                           &#x27;mTempFile.getPath(), record.threadId))\n&#x27;
                           &#x27;            : mTempFile;\n&#x27;
                           &#x27;    config.isBlock = mRecord.isBlock;\n&#x27;
                           &#x27;    config.isOpenDynamicFile = &#x27;
                           &#x27;mRecord.isOpenDynamicFile;\n&#x27;
                           &#x27;    config.startThreadNum = startNum;\n&#x27;
                           &#x27;    config.taskWrapper = mTaskWrapper;\n&#x27;
                           &#x27;    config.record = record;\n&#x27;
                           &#x27;    config.stateHandler = mStateHandler;\n&#x27;
                           &#x27;    return selectThreadTask(config);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleBreakpoint() {\n&#x27;
                           &#x27;    long fileLength = mEntity.getFileSize();\n&#x27;
                           &#x27;    long blockSize = fileLength / &#x27;
                           &#x27;mTotalThreadNum;\n&#x27;
                           &#x27;    long currentProgress = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mRecord.fileLength = fileLength;\n&#x27;
                           &#x27;    if (mTaskWrapper.isNewTask() &amp;&amp; &#x27;
                           &#x27;!handleNewTask()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int startNum = mRecord.threadNum;\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (!tr.isComplete) {\n&#x27;
                           &#x27;        startNum++;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTotalThreadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(i);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      if (tr.isComplete) {//该线程已经完成\n&#x27;
                           &#x27;        currentProgress += endL - startL;\n&#x27;
                           &#x27;        ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__已完成&quot;, &#x27;
                           &#x27;mTaskWrapper.getEntity().getFileName(), i));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_COMPLETE).sendToTarget();\n&#x27;
                           &#x27;        if (mStateManager.isComplete()) {\n&#x27;
                           &#x27;          mRecord.deleteData();\n&#x27;
                           &#x27;          mListener.onComplete();\n&#x27;
                           &#x27;          return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        continue;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      //如果有记录，则恢复任务\n&#x27;
                           &#x27;      long r = tr.startLocation;\n&#x27;
                           &#x27;      //记录的位置需要在线程区间中\n&#x27;
                           &#x27;      if (startL &lt; r &amp;&amp; r &lt;= (i == &#x27;
                           &#x27;(mTotalThreadNum - 1) ? fileLength : endL)) {\n&#x27;
                           &#x27;        currentProgress += r - startL;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, &#x27;
                           &#x27;mEntity.getFileName(), i));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(tr, startNum);\n&#x27;
                           &#x27;      if (task == null) return;\n&#x27;
                           &#x27;      mTask.put(tr.threadId, task);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (currentProgress != 0 &amp;&amp; currentProgress != &#x27;
                           &#x27;mEntity.getCurrentProgress()) {\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;进度修正，当前进度：%s&quot;, &#x27;
                           &#x27;currentProgress));\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mEntity.setCurrentProgress(currentProgress);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_UPDATE_PROGRESS, &#x27;
                           &#x27;currentProgress)\n&#x27;
                           &#x27;        .sendToTarget();\n&#x27;
                           &#x27;    startThreadTask();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 启动单线程任务\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void startThreadTask() {\n&#x27;
                           &#x27;    if (isBreak()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (mStateManager.getCurrentProgress() &gt; 0) {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mListener.onResume(mStateManager.getCurrentProgress());\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mListener.onStart(mStateManager.getCurrentProgress());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTask.size(); i++) {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;mTask.get(i));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private void handleBreakpoint() {\n&#x27;
                           &#x27;    long fileLength = mEntity.getFileSize();\n&#x27;
                           &#x27;    long blockSize = fileLength / &#x27;
                           &#x27;mTotalThreadNum;\n&#x27;
                           &#x27;    long currentProgress = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mRecord.fileLength = fileLength;\n&#x27;
                           &#x27;    if (mTaskWrapper.isNewTask() &amp;&amp; &#x27;
                           &#x27;!handleNewTask()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int startNum = mRecord.threadNum;\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (!tr.isComplete) {\n&#x27;
                           &#x27;        startNum++;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTotalThreadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(i);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      if (tr.isComplete) {//该线程已经完成\n&#x27;
                           &#x27;        currentProgress += endL - startL;\n&#x27;
                           &#x27;        ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__已完成&quot;, &#x27;
                           &#x27;mTaskWrapper.getEntity().getFileName(), i));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_COMPLETE).sendToTarget();\n&#x27;
                           &#x27;        if (mStateManager.isComplete()) {\n&#x27;
                           &#x27;          mRecord.deleteData();\n&#x27;
                           &#x27;          mListener.onComplete();\n&#x27;
                           &#x27;          return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        continue;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      //如果有记录，则恢复任务\n&#x27;
                           &#x27;      long r = tr.startLocation;\n&#x27;
                           &#x27;      //记录的位置需要在线程区间中\n&#x27;
                           &#x27;      if (startL &lt; r &amp;&amp; r &lt;= (i == &#x27;
                           &#x27;(mTotalThreadNum - 1) ? fileLength : endL)) {\n&#x27;
                           &#x27;        currentProgress += r - startL;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, &#x27;
                           &#x27;mEntity.getFileName(), i));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(tr, startNum);\n&#x27;
                           &#x27;      if (task == null) return;\n&#x27;
                           &#x27;      mTask.put(tr.threadId, task);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (currentProgress != 0 &amp;&amp; currentProgress != &#x27;
                           &#x27;mEntity.getCurrentProgress()) {\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;进度修正，当前进度：%s&quot;, &#x27;
                           &#x27;currentProgress));\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mEntity.setCurrentProgress(currentProgress);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_UPDATE_PROGRESS, &#x27;
                           &#x27;currentProgress)\n&#x27;
                           &#x27;        .sendToTarget();\n&#x27;
                           &#x27;    startThreadTask();\n&#x27;
                           &#x27;  }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;   * 启动断点任务时，创建单线程任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param record 线程记录\n&#x27;
                           &#x27;   * @param startNum 启动的线程数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private AbsThreadTask &#x27;
                           &#x27;createSingThreadTask(ThreadRecord record, int &#x27;
                           &#x27;startNum) {\n&#x27;
                           &#x27;    SubThreadConfig&lt;TASK_WRAPPER&gt; config = new &#x27;
                           &#x27;SubThreadConfig&lt;&gt;();\n&#x27;
                           &#x27;    config.url = mEntity.isRedirect() ? &#x27;
                           &#x27;mEntity.getRedirectUrl() : mEntity.getUrl();\n&#x27;
                           &#x27;    config.tempFile =\n&#x27;
                           &#x27;        mRecord.isBlock ? new File(\n&#x27;
                           &#x27;            String.format(RecordHandler.SUB_PATH, &#x27;
                           &#x27;mTempFile.getPath(), record.threadId))\n&#x27;
                           &#x27;            : mTempFile;\n&#x27;
                           &#x27;    config.isBlock = mRecord.isBlock;\n&#x27;
                           &#x27;    config.isOpenDynamicFile = &#x27;
                           &#x27;mRecord.isOpenDynamicFile;\n&#x27;
                           &#x27;    config.startThreadNum = startNum;\n&#x27;
                           &#x27;    config.taskWrapper = mTaskWrapper;\n&#x27;
                           &#x27;    config.record = record;\n&#x27;
                           &#x27;    config.stateHandler = mStateHandler;\n&#x27;
                           &#x27;    return selectThreadTask(config);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleBreakpoint() {\n&#x27;
                           &#x27;    long fileLength = mEntity.getFileSize();\n&#x27;
                           &#x27;    long blockSize = fileLength / &#x27;
                           &#x27;mTotalThreadNum;\n&#x27;
                           &#x27;    long currentProgress = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mRecord.fileLength = fileLength;\n&#x27;
                           &#x27;    if (mTaskWrapper.isNewTask() &amp;&amp; &#x27;
                           &#x27;!handleNewTask()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int startNum = mRecord.threadNum;\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (!tr.isComplete) {\n&#x27;
                           &#x27;        startNum++;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTotalThreadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(i);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      if (tr.isComplete) {//该线程已经完成\n&#x27;
                           &#x27;        currentProgress += endL - startL;\n&#x27;
                           &#x27;        ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__已完成&quot;, &#x27;
                           &#x27;mTaskWrapper.getEntity().getFileName(), i));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_COMPLETE).sendToTarget();\n&#x27;
                           &#x27;        if (mStateManager.isComplete()) {\n&#x27;
                           &#x27;          mRecord.deleteData();\n&#x27;
                           &#x27;          mListener.onComplete();\n&#x27;
                           &#x27;          return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        continue;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      //如果有记录，则恢复任务\n&#x27;
                           &#x27;      long r = tr.startLocation;\n&#x27;
                           &#x27;      //记录的位置需要在线程区间中\n&#x27;
                           &#x27;      if (startL &lt; r &amp;&amp; r &lt;= (i == &#x27;
                           &#x27;(mTotalThreadNum - 1) ? fileLength : endL)) {\n&#x27;
                           &#x27;        currentProgress += r - startL;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      ALog.d(TAG, &#x27;
                           &#x27;String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, &#x27;
                           &#x27;mEntity.getFileName(), i));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(tr, startNum);\n&#x27;
                           &#x27;      if (task == null) return;\n&#x27;
                           &#x27;      mTask.put(tr.threadId, task);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (currentProgress != 0 &amp;&amp; currentProgress != &#x27;
                           &#x27;mEntity.getCurrentProgress()) {\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;进度修正，当前进度：%s&quot;, &#x27;
                           &#x27;currentProgress));\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mEntity.setCurrentProgress(currentProgress);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    &#x27;
                           &#x27;mStateHandler.obtainMessage(ThreadStateManager.STATE_UPDATE_PROGRESS, &#x27;
                           &#x27;currentProgress)\n&#x27;
                           &#x27;        .sendToTarget();\n&#x27;
                           &#x27;    startThreadTask();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 启动单线程任务\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void startThreadTask() {\n&#x27;
                           &#x27;    if (isBreak()) {\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (mStateManager.getCurrentProgress() &gt; 0) {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mListener.onResume(mStateManager.getCurrentProgress());\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;mListener.onStart(mStateManager.getCurrentProgress());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mTask.size(); i++) {\n&#x27;
                           &#x27;      &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;mTask.get(i));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   * 处理新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@code true}创建新任务失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  protected abstract boolean handleNewTask();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的任务\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBP() {\n&#x27;
                           &#x27;    if (mListener instanceof BaseDListener) {\n&#x27;
                           &#x27;      ((BaseDListener) &#x27;
                           &#x27;mListener).supportBreakpoint(false);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(mRecord.threadRecords.get(0), &#x27;
                           &#x27;1);\n&#x27;
                           &#x27;    if (task == null) return;\n&#x27;
                           &#x27;    mTask.put(0, task);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;task);\n&#x27;
                           &#x27;    mListener.onStart(0);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 选择单任务线程的类型\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  protected abstract AbsThreadTask &#x27;
                           &#x27;selectThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; &#x27;
                           &#x27;config);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private void handleNoSupportBP() {\n&#x27;
                           &#x27;    if (mListener instanceof BaseDListener) {\n&#x27;
                           &#x27;      ((BaseDListener) &#x27;
                           &#x27;mListener).supportBreakpoint(false);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(mRecord.threadRecords.get(0), &#x27;
                           &#x27;1);\n&#x27;
                           &#x27;    if (task == null) return;\n&#x27;
                           &#x27;    mTask.put(0, task);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;task);\n&#x27;
                           &#x27;    mListener.onStart(0);\n&#x27;
                           &#x27;  }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;   * 处理新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@code true}创建新任务失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  protected abstract boolean handleNewTask();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的任务\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBP() {\n&#x27;
                           &#x27;    if (mListener instanceof BaseDListener) {\n&#x27;
                           &#x27;      ((BaseDListener) &#x27;
                           &#x27;mListener).supportBreakpoint(false);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    AbsThreadTask task = &#x27;
                           &#x27;createSingThreadTask(mRecord.threadRecords.get(0), &#x27;
                           &#x27;1);\n&#x27;
                           &#x27;    if (task == null) return;\n&#x27;
                           &#x27;    mTask.put(0, task);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;ThreadTaskManager.getInstance().startThread(mTaskWrapper.getKey(), &#x27;
                           &#x27;task);\n&#x27;
                           &#x27;    mListener.onStart(0);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 选择单任务线程的类型\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  protected abstract AbsThreadTask &#x27;
                           &#x27;selectThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; &#x27;
                           &#x27;config);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27; //文件\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27; //文件\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27; //总线程数\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        