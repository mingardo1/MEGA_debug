<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>218</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    218
                    <a href="217.html">prev</a>
                    <a href="219.html">next</a>
                    <a href="218_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_ec3fe183eb432b6541513196e52167ecd7826631_src/com/android/launcher3/LauncherBackupHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;ec3fe183eb432b6541513196e52167ecd7826631:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;ec3fe183eb432b6541513196e52167ecd7826631^1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;ec3fe183eb432b6541513196e52167ecd7826631^2:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;ef30a2a8312b83985a8ad3eb8feebbb944cbae01:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager;
  29 import android.content.pm.PackageManager.NameNotFoundException;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.drawable.Drawable;
  36 import android.os.ParcelFileDescriptor;
  37 import android.text.TextUtils;
  38 import android.util.Base64;
  39 import android.util.Log;
  40 
  41 import com.android.launcher3.LauncherSettings.Favorites;
  42 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  43 import com.android.launcher3.backup.BackupProtos;
  44 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  45 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  46 import com.android.launcher3.backup.BackupProtos.Favorite;
  47 import com.android.launcher3.backup.BackupProtos.Journal;
  48 import com.android.launcher3.backup.BackupProtos.Key;
  49 import com.android.launcher3.backup.BackupProtos.Resource;
  50 import com.android.launcher3.backup.BackupProtos.Screen;
  51 import com.android.launcher3.backup.BackupProtos.Widget;
  52 import com.android.launcher3.compat.UserHandleCompat;
  53 import com.android.launcher3.compat.UserManagerCompat;
  54 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  55 import com.google.protobuf.nano.MessageNano;
  56 
  57 import org.xmlpull.v1.XmlPullParser;
  58 import org.xmlpull.v1.XmlPullParserException;
  59 
  60 import java.io.ByteArrayOutputStream;
  61 import java.io.FileInputStream;
  62 import java.io.FileOutputStream;
  63 import java.io.IOException;
  64 import java.net.URISyntaxException;
  65 import java.util.ArrayList;
  66 import java.util.Arrays;
  67 import java.util.HashSet;
  68 import java.util.zip.CRC32;
  69 
  70 /**
  71  * Persist the launcher home state across calamities.
  72  */
  73 public class LauncherBackupHelper implements BackupHelper {
  74     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  75     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  76     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  77 
  78     private static final int BACKUP_VERSION = 2;
  79     private static final int MAX_JOURNAL_SIZE = 1000000;
  80 
  81     // Journal key is such that it is always smaller than any dynamically generated
  82     // key (any Base64 encoded string).
  83     private static final String JOURNAL_KEY = &quot;#&quot;;
  84 
  85     /** icons are large, dribble them out */
  86     private static final int MAX_ICONS_PER_PASS = 10;
  87 
  88     /** widgets contain previews, which are very large, dribble them out */
  89     private static final int MAX_WIDGETS_PER_PASS = 5;
  90 
  91     private static final int IMAGE_COMPRESSION_QUALITY = 75;
  92 
  93     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  94             android.graphics.Bitmap.CompressFormat.PNG;
  95 
  96     private static final String[] FAVORITE_PROJECTION = {
  97         Favorites._ID,                     // 0
  98         Favorites.MODIFIED,                // 1
  99         Favorites.INTENT,                  // 2
 100         Favorites.APPWIDGET_PROVIDER,      // 3
 101         Favorites.APPWIDGET_ID,            // 4
 102         Favorites.CELLX,                   // 5
 103         Favorites.CELLY,                   // 6
 104         Favorites.CONTAINER,               // 7
 105         Favorites.ICON,                    // 8
 106         Favorites.ICON_PACKAGE,            // 9
 107         Favorites.ICON_RESOURCE,           // 10
 108         Favorites.ICON_TYPE,               // 11
 109         Favorites.ITEM_TYPE,               // 12
 110         Favorites.SCREEN,                  // 13
 111         Favorites.SPANX,                   // 14
 112         Favorites.SPANY,                   // 15
 113         Favorites.TITLE,                   // 16
 114         Favorites.PROFILE_ID,              // 17
 115     };
 116 
 117     private static final int ID_INDEX = 0;
 118     private static final int ID_MODIFIED = 1;
 119     private static final int INTENT_INDEX = 2;
 120     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 121     private static final int APPWIDGET_ID_INDEX = 4;
 122     private static final int CELLX_INDEX = 5;
 123     private static final int CELLY_INDEX = 6;
 124     private static final int CONTAINER_INDEX = 7;
 125     private static final int ICON_INDEX = 8;
 126     private static final int ICON_PACKAGE_INDEX = 9;
 127     private static final int ICON_RESOURCE_INDEX = 10;
 128     private static final int ICON_TYPE_INDEX = 11;
 129     private static final int ITEM_TYPE_INDEX = 12;
 130     private static final int SCREEN_INDEX = 13;
 131     private static final int SPANX_INDEX = 14;
 132     private static final int SPANY_INDEX = 15;
 133     private static final int TITLE_INDEX = 16;
 134 
 135     private static final String[] SCREEN_PROJECTION = {
 136         WorkspaceScreens._ID,              // 0
 137         WorkspaceScreens.MODIFIED,         // 1
 138         WorkspaceScreens.SCREEN_RANK       // 2
 139     };
 140 
 141     private static final int SCREEN_RANK_INDEX = 2;
 142 
 143     private final Context mContext;
 144     private final HashSet&lt;String&gt; mExistingKeys;
 145     private final ArrayList&lt;Key&gt; mKeys;
 146     private final ItemTypeMatcher[] mItemTypeMatchers;
 147     private final long mUserSerial;
 148 
 149     private IconCache mIconCache;
 150     private BackupManager mBackupManager;
 151     private byte[] mBuffer = new byte[512];
 152     private long mLastBackupRestoreTime;
 153     private boolean mBackupDataWasUpdated;
 154 
 155     private DeviceProfieData mCurrentProfile;
 156     boolean restoreSuccessful;
 157     int restoredBackupVersion = 1;
 158 
 159     public LauncherBackupHelper(Context context) {
 160         mContext = context;
 161         mExistingKeys = new HashSet&lt;String&gt;();
 162         mKeys = new ArrayList&lt;Key&gt;();
 163         restoreSuccessful = true;
 164         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 165 
 166         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 167         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 168     }
 169 
 170     private void dataChanged() {
 171         if (mBackupManager == null) {
 172             mBackupManager = new BackupManager(mContext);
 173         }
 174         mBackupManager.dataChanged();
 175     }
 176 
 177     private void applyJournal(Journal journal) {
 178         mLastBackupRestoreTime = journal.t;
 179         mExistingKeys.clear();
 180         if (journal.key != null) {
 181             for (Key key : journal.key) {
 182                 mExistingKeys.add(keyToBackupKey(key));
 183             }
 184         }
 185     }
 186 
 187     /**
 188      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 189      *
 190      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 191      *
 192      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 193      *
 194      * @param oldState notes from the last backup
 195      * @param data incremental key/value pairs to persist off-device
 196      * @param newState notes for the next backup
 197      */
 198     @Override
 199     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 200             ParcelFileDescriptor newState) {
 201         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 202 
 203         Journal in = readJournal(oldState);
 204         if (!launcherIsReady()) {
 205             // Perform backup later.
 206             writeJournal(newState, in);
 207             return;
 208         }
 209         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 210         mKeys.clear();
 211         applyJournal(in);
 212 
 213         // Record the time before performing backup so that entries edited while the backup
 214         // was going on, do not get missed in next backup.
 215         long newBackupTime = System.currentTimeMillis();
 216         mBackupDataWasUpdated = false;
 217         try {
 218             backupFavorites(data);
 219             backupScreens(data);
 220             backupIcons(data);
 221             backupWidgets(data);
 222 
 223             // Delete any key which still exist in the old backup, but is not valid anymore.
 224             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 225             for (Key key : mKeys) {
 226                 validKeys.add(keyToBackupKey(key));
 227             }
 228             mExistingKeys.removeAll(validKeys);
 229 
 230             // Delete anything left in the existing keys.
 231             for (String deleted: mExistingKeys) {
 232                 if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 233                 data.writeEntityHeader(deleted, -1);
 234                 mBackupDataWasUpdated = true;
 235             }
 236 
 237             mExistingKeys.clear();
 238             if (!mBackupDataWasUpdated) {
 239                 // Check if any metadata has changed
 240                 mBackupDataWasUpdated = (in.profile == null)
 241                         || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 242                             DeviceProfieData.toByteArray(getDeviceProfieData()))
 243                         || (in.backupVersion != BACKUP_VERSION)
 244                         || (in.appVersion != getAppVersion());
 245             }
 246 
 247             if (mBackupDataWasUpdated) {
 248                 mLastBackupRestoreTime = newBackupTime;
 249 
 250                 // We store the journal at two places.
 251                 //   1) Storing it in newState allows us to do partial backups by comparing old state
 252                 //   2) Storing it in backup data allows us to validate keys during restore
 253                 Journal state = getCurrentStateJournal();
 254                 writeRowToBackup(JOURNAL_KEY, state, data);
 255             } else {
 256                 if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 257             }
 258         } catch (IOException e) {
 259             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 260         }
 261 
 262         writeNewStateDescription(newState);
 263     }
 264 
 265     /**
 266      * @return true if the backup corresponding to oldstate can be successfully applied
 267      * to this device.
 268      */
 269     private boolean isBackupCompatible(Journal oldState) {
 270         DeviceProfieData currentProfile = getDeviceProfieData();
 271 
 272         DeviceProfieData oldProfile = oldState.profile;
 273 
 274         if (oldProfile == null || oldProfile.desktopCols == 0) {
 275             // Profile info is not valid, ignore the check.
 276             return true;
 277         }
 278 
 279         boolean isHotsetCompatible = false;
 280         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 281             isHotsetCompatible = true;
 282         }
 283         if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 284                 (currentProfile.allappsRank == oldProfile.allappsRank)) {
 285             isHotsetCompatible = true;
 286         }
 287 
 288         return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 289                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 290     }
 291 
 292     /**
 293      * Restore launcher configuration from the restored data stream.
 294      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 295      * backup, it should arrive first.
 296      *
 297      * @param data the key/value pair from the server
 298      */
 299     @Override
 300     public void restoreEntity(BackupDataInputStream data) {
 301         if (!restoreSuccessful) {
 302             return;
 303         }
 304         if (!initializeIconCache()) {
 305             // During restore we do not need an initialized instance of IconCache. We can create
 306             // a temporary icon cache here, as the process will be rebooted after restore
 307             // is complete.
 308             mIconCache = new IconCache(mContext);
 309         }
 310 
 311         int dataSize = data.size();
 312         if (mBuffer.length &lt; dataSize) {
 313             mBuffer = new byte[dataSize];
 314         }
 315         try {
 316             int bytesRead = data.read(mBuffer, 0, dataSize);
 317             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 318             String backupKey = data.getKey();
 319 
 320             if (JOURNAL_KEY.equals(backupKey)) {
 321                 if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 322                 if (!mKeys.isEmpty()) {
 323                     // We received the journal key after a restore key.
 324                     Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 325                     restoreSuccessful = false;
 326                     return;
 327                 }
 328 
 329                 Journal journal = new Journal();
 330                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 331                 applyJournal(journal);
 332                 restoreSuccessful = isBackupCompatible(journal);
 333                 restoredBackupVersion = journal.backupVersion;
 334                 return;
 335             }
 336 
 337             if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 338                 if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 339                 return;
 340             }
 341             Key key = backupKeyToKey(backupKey);
 342             mKeys.add(key);
 343             switch (key.type) {
 344                 case Key.FAVORITE:
 345                     restoreFavorite(key, mBuffer, dataSize);
 346                     break;
 347 
 348                 case Key.SCREEN:
 349                     restoreScreen(key, mBuffer, dataSize);
 350                     break;
 351 
 352                 case Key.ICON:
 353                     restoreIcon(key, mBuffer, dataSize);
 354                     break;
 355 
 356                 case Key.WIDGET:
 357                     restoreWidget(key, mBuffer, dataSize);
 358                     break;
 359 
 360                 default:
 361                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 362                     mKeys.remove(key);
 363                     break;
 364             }
 365         } catch (IOException e) {
 366             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 367         }
 368     }
 369 
 370     /**
 371      * Record the restore state for the next backup.
 372      *
 373      * @param newState notes about the backup state after restore.
 374      */
 375     @Override
 376     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 377         writeJournal(newState, getCurrentStateJournal());
 378     }
 379 
 380     private Journal getCurrentStateJournal() {
 381         Journal journal = new Journal();
 382         journal.t = mLastBackupRestoreTime;
 383         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 384         journal.appVersion = getAppVersion();
 385         journal.backupVersion = BACKUP_VERSION;
 386         journal.profile = getDeviceProfieData();
 387         return journal;
 388     }
 389 
 390     private int getAppVersion() {
 391         try {
 392             return mContext.getPackageManager()
 393                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 394         } catch (NameNotFoundException e) {
 395             return 0;
 396         }
 397     }
 398 
 399     /**
 400      * @return the current device profile information.
 401      */
 402     private DeviceProfieData getDeviceProfieData() {
 403         if (mCurrentProfile != null) {
 404             return mCurrentProfile;
 405         }
 406         final Context applicationContext = mContext.getApplicationContext();
 407         DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)
 408                 .getDeviceProfile();
 409 
 410         mCurrentProfile = new DeviceProfieData();
 411         mCurrentProfile.desktopRows = profile.numRows;
 412         mCurrentProfile.desktopCols = profile.numColumns;
 413         mCurrentProfile.hotseatCount = profile.numHotseatIcons;
 414         mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;
 415         return mCurrentProfile;
 416     }
 417 
 418     /**
 419      * Write all modified favorites to the data stream.
 420      *
 421      * @param data output stream for key/value pairs
 422      * @throws IOException
 423      */
 424     private void backupFavorites(BackupDataOutput data) throws IOException {
 425         // persist things that have changed since the last backup
 426         ContentResolver cr = mContext.getContentResolver();
 427         // Don&#x27;t backup apps in other profiles for now.
 428         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 429                 getUserSelectionArg(), null, null);
 430         try {
 431             cursor.moveToPosition(-1);
 432             while(cursor.moveToNext()) {
 433                 final long id = cursor.getLong(ID_INDEX);
 434                 final long updateTime = cursor.getLong(ID_MODIFIED);
 435                 Key key = getKey(Key.FAVORITE, id);
 436                 mKeys.add(key);
 437                 final String backupKey = keyToBackupKey(key);
 438                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 439                     writeRowToBackup(key, packFavorite(cursor), data);
 440                 } else {
 441                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 442                 }
 443             }
 444         } finally {
 445             cursor.close();
 446         }
 447     }
 448 
 449     /**
 450      * Read a favorite from the stream.
 451      *
 452      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 453      *
 454      * @param key identifier for the row
 455      * @param buffer the serialized proto from the stream, may be larger than dataSize
 456      * @param dataSize the size of the proto from the stream
 457      */
 458     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 459         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 460         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 461                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 462 
 463         ContentResolver cr = mContext.getContentResolver();
 464         ContentValues values = unpackFavorite(buffer, dataSize);
 465         cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 466     }
 467 
 468     /**
 469      * Write all modified screens to the data stream.
 470      *
 471      * @param data output stream for key/value pairs
 472      * @throws IOException
 473      */
 474     private void backupScreens(BackupDataOutput data) throws IOException {
 475         // persist things that have changed since the last backup
 476         ContentResolver cr = mContext.getContentResolver();
 477         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 478                 null, null, null);
 479         try {
 480             cursor.moveToPosition(-1);
 481             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 482             while(cursor.moveToNext()) {
 483                 final long id = cursor.getLong(ID_INDEX);
 484                 final long updateTime = cursor.getLong(ID_MODIFIED);
 485                 Key key = getKey(Key.SCREEN, id);
 486                 mKeys.add(key);
 487                 final String backupKey = keyToBackupKey(key);
 488                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 489                     writeRowToBackup(key, packScreen(cursor), data);
 490                 } else {
 491                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 492                 }
 493             }
 494         } finally {
 495             cursor.close();
 496         }
 497     }
 498 
 499     /**
 500      * Read a screen from the stream.
 501      *
 502      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 503      *
 504      * @param key identifier for the row
 505      * @param buffer the serialized proto from the stream, may be larger than dataSize
 506      * @param dataSize the size of the proto from the stream
 507      */
 508     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 509         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 510         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 511                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 512 
 513         ContentResolver cr = mContext.getContentResolver();
 514         ContentValues values = unpackScreen(buffer, dataSize);
 515         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 516     }
 517 
 518     /**
 519      * Write all the static icon resources we need to render placeholders
 520      * for a package that is not installed.
 521      *
 522      * @param data output stream for key/value pairs
 523      */
 524     private void backupIcons(BackupDataOutput data) throws IOException {
 525         // persist icons that haven&#x27;t been persisted yet
 526         if (!initializeIconCache()) {
 527             dataChanged(); // try again later
 528             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 529             return;
 530         }
 531         final ContentResolver cr = mContext.getContentResolver();
 532         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 533         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 534         int backupUpIconCount = 0;
 535 
 536         // Don&#x27;t backup apps in other profiles for now.
 537         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 538                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 539                 getUserSelectionArg();
 540         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 541                 where, null, null);
 542         try {
 543             cursor.moveToPosition(-1);
 544             while(cursor.moveToNext()) {
 545                 final long id = cursor.getLong(ID_INDEX);
 546                 final String intentDescription = cursor.getString(INTENT_INDEX);
 547                 try {
 548                     Intent intent = Intent.parseUri(intentDescription, 0);
 549                     ComponentName cn = intent.getComponent();
 550                     Key key = null;
 551                     String backupKey = null;
 552                     if (cn != null) {
 553                         key = getKey(Key.ICON, cn.flattenToShortString());
 554                         backupKey = keyToBackupKey(key);
 555                     } else {
 556                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 557                     }
 558                     if (mExistingKeys.contains(backupKey)) {
 559                         if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 560 
 561                         // remember that we already backed this up previously
 562                         mKeys.add(key);
 563                     } else if (backupKey != null) {
 564                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 565                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 566                             if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 567                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 568                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 569                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 570                                 mKeys.add(key);
 571                                 backupUpIconCount ++;
 572                             }
 573                         } else {
 574                             if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 575                             // too many icons for this pass, request another.
 576                             dataChanged();
 577                         }
 578                     }
 579                 } catch (URISyntaxException e) {
 580                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 581                 } catch (IOException e) {
 582                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 583                 }
 584 
 585             }
 586         } finally {
 587             cursor.close();
 588         }
 589     }
 590 
 591     /**
 592      * Read an icon from the stream.
 593      *
 594      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 595      *
 596      * @param key identifier for the row
 597      * @param buffer the serialized proto from the stream, may be larger than dataSize
 598      * @param dataSize the size of the proto from the stream
 599      */
 600     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 601         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 602         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 603                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 604 
 605         Resource res = unpackProto(new Resource(), buffer, dataSize);
 606         if (DEBUG) {
 607             Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 608         }
 609         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 610         if (icon == null) {
 611             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 612         }
 613         if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 614         mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,
 615                 &quot;&quot; /* label */, mUserSerial);
 616     }
 617 
 618     /**
 619      * Write all the static widget resources we need to render placeholders
 620      * for a package that is not installed.
 621      *
 622      * @param data output stream for key/value pairs
 623      * @throws IOException
 624      */
 625     private void backupWidgets(BackupDataOutput data) throws IOException {
 626         // persist static widget info that hasn&#x27;t been persisted yet
 627         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 628         if (appState == null || !initializeIconCache()) {
 629             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 630             return;
 631         }
 632         final ContentResolver cr = mContext.getContentResolver();
 633         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 634         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 635         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 636         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 637         int backupWidgetCount = 0;
 638 
 639         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 640                 + getUserSelectionArg();
 641         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 642                 where, null, null);
 643         try {
 644             cursor.moveToPosition(-1);
 645             while(cursor.moveToNext()) {
 646                 final long id = cursor.getLong(ID_INDEX);
 647                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 648                 final int spanX = cursor.getInt(SPANX_INDEX);
 649                 final int spanY = cursor.getInt(SPANY_INDEX);
 650                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 651                 Key key = null;
 652                 String backupKey = null;
 653                 if (provider != null) {
 654                     key = getKey(Key.WIDGET, providerName);
 655                     backupKey = keyToBackupKey(key);
 656                 } else {
 657                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 658                 }
 659                 if (mExistingKeys.contains(backupKey)) {
 660                     if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 661 
 662                     // remember that we already backed this up previously
 663                     mKeys.add(key);
 664                 } else if (backupKey != null) {
 665                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 666                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 667                         if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
 668 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 669                         previewLoader.setPreviewSize(</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 670                                 spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 671                                 spanY * profile.cellHeightPx);</span>
 672 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 673                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 674                                 spanY * profile.cellHeightPx, widgetSpacingLayout);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 675                         writeRowToBackup(key, packWidget(dpi, previewLoader, mIconCache, provider), data);"> 675                         writeRowToBackup(key, packWidget(dpi, previewLoader, mIconCache, provider), data)ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 676                         mKeys.add(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 677                         backupWidgetCount ++;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 678                     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 679                         if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 680                         // too many widgets for this pass, request another.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 681                         dataChanged();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 682                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 683                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 684             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 685         } finally {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 686             cursor.close();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 687         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 688     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 689 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 690     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 691      * Read a widget from the stream.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 692      *</span>
 693 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 694                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 695                                 spanY * profile.cellHeightPx, widgetSpacingLayout);</span>
 696 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 697                         UserHandleCompat user = UserHandleCompat.myUserHandle();
 698                         writeRowToBackup(key,
 699                                 packWidget(dpi, previewLoader, mIconCache, provider, user),
 700                                 data);
 701                         mKeys.add(key);
 702                         backupWidgetCount ++;
 703                     } else {
 704                         if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 705                         // too many widgets for this pass, request another.
 706                         dataChanged();
 707                     }
 708                 }
 709             }
 710         } finally {
 711             cursor.close();
 712         }
 713     }
 714 
 715     /**
 716      * Read a widget from the stream.
 717      *
 718      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 719      *
 720      * @param key identifier for the row
 721      * @param buffer the serialized proto from the stream, may be larger than dataSize
 722      * @param dataSize the size of the proto from the stream
 723      */
 724     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 725         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 726         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 727                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 728         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 729         if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 730         if (widget.icon.data != null)  {
 731             Bitmap icon = BitmapFactory
 732                     .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 733             if (icon == null) {
 734                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 735             } else {
 736                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),
 737                         icon, widget.icon.dpi, widget.label, mUserSerial);
 738             }
 739         }
 740 
 741         // future site of widget table mutation
 742     }
 743 
 744     /** create a new key, with an integer ID.
 745      *
 746      * &lt;P&gt; Keys contain their own checksum instead of using
 747      * the heavy-weight CheckedMessage wrapper.
 748      */
 749     private Key getKey(int type, long id) {
 750         Key key = new Key();
 751         key.type = type;
 752         key.id = id;
 753         key.checksum = checkKey(key);
 754         return key;
 755     }
 756 
 757     /** create a new key for a named object.
 758      *
 759      * &lt;P&gt; Keys contain their own checksum instead of using
 760      * the heavy-weight CheckedMessage wrapper.
 761      */
 762     private Key getKey(int type, String name) {
 763         Key key = new Key();
 764         key.type = type;
 765         key.name = name;
 766         key.checksum = checkKey(key);
 767         return key;
 768     }
 769 
 770     /** keys need to be strings, serialize and encode. */
 771     private String keyToBackupKey(Key key) {
 772         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 773     }
 774 
 775     /** keys need to be strings, decode and parse. */
 776     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 777         try {
 778             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 779             if (key.checksum != checkKey(key)) {
 780                 key = null;
 781                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 782             }
 783             return key;
 784         } catch (InvalidProtocolBufferNanoException e) {
 785             throw new InvalidBackupException(e);
 786         } catch (IllegalArgumentException e) {
 787             throw new InvalidBackupException(e);
 788         }
 789     }
 790 
 791     /** Compute the checksum over the important bits of a key. */
 792     private long checkKey(Key key) {
 793         CRC32 checksum = new CRC32();
 794         checksum.update(key.type);
 795         checksum.update((int) (key.id &amp; 0xffff));
 796         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 797         if (!TextUtils.isEmpty(key.name)) {
 798             checksum.update(key.name.getBytes());
 799         }
 800         return checksum.getValue();
 801     }
 802 
 803     /**
 804      * @return true if its an hotseat item, that can be replaced during restore.
 805      * TODO: Extend check for folders in hotseat.
 806      */
 807     private boolean isReplaceableHotseatItem(Favorite favorite) {
 808         return favorite.container == Favorites.CONTAINER_HOTSEAT
 809                 &amp;&amp; favorite.intent != null
 810                 &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION
 811                 || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);
 812     }
 813 
 814     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 815     private Favorite packFavorite(Cursor c) {
 816         Favorite favorite = new Favorite();
 817         favorite.id = c.getLong(ID_INDEX);
 818         favorite.screen = c.getInt(SCREEN_INDEX);
 819         favorite.container = c.getInt(CONTAINER_INDEX);
 820         favorite.cellX = c.getInt(CELLX_INDEX);
 821         favorite.cellY = c.getInt(CELLY_INDEX);
 822         favorite.spanX = c.getInt(SPANX_INDEX);
 823         favorite.spanY = c.getInt(SPANY_INDEX);
 824         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 825         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 826             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 827             if (!TextUtils.isEmpty(iconPackage)) {
 828                 favorite.iconPackage = iconPackage;
 829             }
 830             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 831             if (!TextUtils.isEmpty(iconResource)) {
 832                 favorite.iconResource = iconResource;
 833             }
 834         }
 835         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 836             byte[] blob = c.getBlob(ICON_INDEX);
 837             if (blob != null &amp;&amp; blob.length &gt; 0) {
 838                 favorite.icon = blob;
 839             }
 840         }
 841         String title = c.getString(TITLE_INDEX);
 842         if (!TextUtils.isEmpty(title)) {
 843             favorite.title = title;
 844         }
 845         String intentDescription = c.getString(INTENT_INDEX);
 846         Intent intent = null;
 847         if (!TextUtils.isEmpty(intentDescription)) {
 848             try {
 849                 intent = Intent.parseUri(intentDescription, 0);
 850                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 851                 favorite.intent = intent.toUri(0);
 852             } catch (URISyntaxException e) {
 853                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 854             }
 855         }
 856         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 857         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 858             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 859             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 860             if (!TextUtils.isEmpty(appWidgetProvider)) {
 861                 favorite.appWidgetProvider = appWidgetProvider;
 862             }
 863         }
 864 
 865         if (isReplaceableHotseatItem(favorite)) {
 866             if (intent != null &amp;&amp; intent.getComponent() != null) {
 867                 PackageManager pm = mContext.getPackageManager();
 868                 ActivityInfo activity = null;;
 869                 try {
 870                     activity = pm.getActivityInfo(intent.getComponent(), 0);
 871                 } catch (NameNotFoundException e) {
 872                     Log.e(TAG, &quot;Target not found&quot;, e);
 873                 }
 874                 if (activity == null) {
 875                     return favorite;
 876                 }
 877                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
 878                     if (mItemTypeMatchers[i] == null) {
 879                         mItemTypeMatchers[i] = new ItemTypeMatcher(
 880                                 CommonAppTypeParser.getResourceForItemType(i));
 881                     }
 882                     if (mItemTypeMatchers[i].matches(activity, pm)) {
 883                         favorite.targetType = i;
 884                         break;
 885                     }
 886                 }
 887             }
 888         }
 889 
 890         return favorite;
 891     }
 892 
 893     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 894     private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 895             throws IOException {
 896         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
 897 
 898         ContentValues values = new ContentValues();
 899         values.put(Favorites._ID, favorite.id);
 900         values.put(Favorites.SCREEN, favorite.screen);
 901         values.put(Favorites.CONTAINER, favorite.container);
 902         values.put(Favorites.CELLX, favorite.cellX);
 903         values.put(Favorites.CELLY, favorite.cellY);
 904         values.put(Favorites.SPANX, favorite.spanX);
 905         values.put(Favorites.SPANY, favorite.spanY);
 906         values.put(Favorites.ICON_TYPE, favorite.iconType);
 907         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 908             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 909             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 910         }
 911         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 912             values.put(Favorites.ICON, favorite.icon);
 913         }
 914         if (!TextUtils.isEmpty(favorite.title)) {
 915             values.put(Favorites.TITLE, favorite.title);
 916         } else {
 917             values.put(Favorites.TITLE, &quot;&quot;);
 918         }
 919         if (!TextUtils.isEmpty(favorite.intent)) {
 920             values.put(Favorites.INTENT, favorite.intent);
 921         }
 922         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 923 
 924         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 925         long userSerialNumber =
 926                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 927         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 928 
 929         DeviceProfieData currentProfile = getDeviceProfieData();
 930 
 931         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 932             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 933                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 934             }
 935             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 936             values.put(LauncherSettings.Favorites.RESTORED,
 937                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 938                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 939                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 940 
 941             // Verify placement
 942             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 943                     || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 944                 restoreSuccessful = false;
 945                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 946             }
 947         } else {
 948             // Check if it is an hotseat item, that can be replaced.
 949             if (isReplaceableHotseatItem(favorite)
 950                     &amp;&amp; favorite.targetType != Favorite.TARGET_NONE
 951                     &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {
 952                 Log.e(TAG, &quot;Added item type flag&quot;);
 953                 values.put(LauncherSettings.Favorites.RESTORED,
 954                         1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));
 955             } else {
 956                 // Let LauncherModel know we&#x27;ve been here.
 957                 values.put(LauncherSettings.Favorites.RESTORED, 1);
 958             }
 959 
 960             // Verify placement
 961             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 962                 if ((favorite.screen &gt;= currentProfile.hotseatCount)
 963                         || (favorite.screen == currentProfile.allappsRank)) {
 964                     restoreSuccessful = false;
 965                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 966                 }
 967             } else {
 968                 if ((favorite.cellX &gt;= currentProfile.desktopCols)
 969                         || (favorite.cellY &gt;= currentProfile.desktopRows)) {
 970                     restoreSuccessful = false;
 971                     throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 972                 }
 973             }
 974         }
 975 
 976         return values;
 977     }
 978 
 979     /** Serialize a Screen for persistence, including a checksum wrapper. */
 980     private Screen packScreen(Cursor c) {
 981         Screen screen = new Screen();
 982         screen.id = c.getLong(ID_INDEX);
 983         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 984         return screen;
 985     }
 986 
 987     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 988     private ContentValues unpackScreen(byte[] buffer, int dataSize)
 989             throws InvalidProtocolBufferNanoException {
 990         Screen screen = unpackProto(new Screen(), buffer, dataSize);
 991         ContentValues values = new ContentValues();
 992         values.put(WorkspaceScreens._ID, screen.id);
 993         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 994         return values;
 995     }
 996 
 997     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 998     private Resource packIcon(int dpi, Bitmap icon) {
 999         Resource res = new Resource();
1000         res.dpi = dpi;
1001         ByteArrayOutputStream os = new ByteArrayOutputStream();
1002         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1003             res.data = os.toByteArray();
1004         }
1005         return res;
1006     }
1007 
1008     /** Serialize a widget for persistence, including a checksum wrapper. */
1009     private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
1010             ComponentName provider, UserHandleCompat user) {
1011         final LauncherAppWidgetProviderInfo info =
1012                 LauncherModel.getProviderInfo(mContext, provider, user);
1013         Widget widget = new Widget();
1014         widget.provider = provider.flattenToShortString();
1015         widget.label = info.label;
1016         widget.configure = info.configure != null;
1017         if (info.icon != 0) {
1018             widget.icon = new Resource();
1019             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
1020             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
1021             ByteArrayOutputStream os = new ByteArrayOutputStream();
1022             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1023                 widget.icon.data = os.toByteArray();
1024                 widget.icon.dpi = dpi;
1025             }
1026         }
1027         if (info.previewImage != 0) {
1028             widget.preview = new Resource();
1029             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
1030             ByteArrayOutputStream os = new ByteArrayOutputStream();
1031             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1032                 widget.preview.data = os.toByteArray();
1033                 widget.preview.dpi = dpi;
1034             }
1035         }
1036         return widget;
1037     }
1038 
1039     /**
1040      * Deserialize a proto after verifying checksum wrapper.
1041      */
1042     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1043             throws InvalidProtocolBufferNanoException {
1044         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1045         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1046         return proto;
1047     }
1048 
1049     /**
1050      * Read the old journal from the input file.
1051      *
1052      * In the event of any error, just pretend we didn&#x27;t have a journal,
1053      * in that case, do a full backup.
1054      *
1055      * @param oldState the read-0only file descriptor pointing to the old journal
1056      * @return a Journal protocol buffer
1057      */
1058     private Journal readJournal(ParcelFileDescriptor oldState) {
1059         Journal journal = new Journal();
1060         if (oldState == null) {
1061             return journal;
1062         }
1063         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1064         try {
1065             int availableBytes = inStream.available();
1066             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1067             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1068                 byte[] buffer = new byte[availableBytes];
1069                 int bytesRead = 0;
1070                 boolean valid = false;
1071                 InvalidProtocolBufferNanoException lastProtoException = null;
1072                 while (availableBytes &gt; 0) {
1073                     try {
1074                         // OMG what are you doing? This is crazy inefficient!
1075                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1076                         // However, we don&#x27;t know how many bytes to expect (oops).
1077                         // So we have to step through *slowly*, watching for the end.
1078                         int result = inStream.read(buffer, bytesRead, 1);
1079                         if (result &gt; 0) {
1080                             availableBytes -= result;
1081                             bytesRead += result;
1082                         } else {
1083                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1084                             // stop reading and see what there is to parse
1085                             availableBytes = 0;
1086                         }
1087                     } catch (IOException e) {
1088                         buffer = null;
1089                         availableBytes = 0;
1090                     }
1091 
1092                     // check the buffer to see if we have a valid journal
1093                     try {
1094                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1095                         // if we are here, then we have read a valid, checksum-verified journal
1096                         valid = true;
1097                         availableBytes = 0;
1098                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1099                     } catch (InvalidProtocolBufferNanoException e) {
1100                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1101                         lastProtoException = e;
1102                         journal.clear();
1103                     }
1104                 }
1105                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1106                 if (!valid) {
1107                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1108                 }
1109             }
1110         } catch (IOException e) {
1111             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1112         } finally {
1113             try {
1114                 inStream.close();
1115             } catch (IOException e) {
1116                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1117             }
1118         }
1119         return journal;
1120     }
1121 
1122     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1123             throws IOException {
1124         writeRowToBackup(keyToBackupKey(key), proto, data);
1125     }
1126 
1127     private void writeRowToBackup(String backupKey, MessageNano proto,
1128             BackupDataOutput data) throws IOException {
1129         byte[] blob = writeCheckedBytes(proto);
1130         data.writeEntityHeader(backupKey, blob.length);
1131         data.writeEntityData(blob, blob.length);
1132         mBackupDataWasUpdated = true;
1133         if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1134     }
1135 
1136     /**
1137      * Write the new journal to the output file.
1138      *
1139      * In the event of any error, just pretend we didn&#x27;t have a journal,
1140      * in that case, do a full backup.
1141 
1142      * @param newState the write-only file descriptor pointing to the new journal
1143      * @param journal a Journal protocol buffer
1144      */
1145     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1146         FileOutputStream outStream = null;
1147         try {
1148             outStream = new FileOutputStream(newState.getFileDescriptor());
1149             final byte[] journalBytes = writeCheckedBytes(journal);
1150             outStream.write(journalBytes);
1151             outStream.close();
1152             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1153         } catch (IOException e) {
1154             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1155         }
1156     }
1157 
1158     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1159     private byte[] writeCheckedBytes(MessageNano proto) {
1160         CheckedMessage wrapper = new CheckedMessage();
1161         wrapper.payload = MessageNano.toByteArray(proto);
1162         CRC32 checksum = new CRC32();
1163         checksum.update(wrapper.payload);
1164         wrapper.checksum = checksum.getValue();
1165         return MessageNano.toByteArray(wrapper);
1166     }
1167 
1168     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1169     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1170             throws InvalidProtocolBufferNanoException {
1171         CheckedMessage wrapper = new CheckedMessage();
1172         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1173         CRC32 checksum = new CRC32();
1174         checksum.update(wrapper.payload);
1175         if (wrapper.checksum != checksum.getValue()) {
1176             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1177         }
1178         return wrapper.payload;
1179     }
1180 
1181     private boolean initializeIconCache() {
1182         if (mIconCache != null) {
1183             return true;
1184         }
1185 
1186         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1187         if (appState == null) {
1188             if (DEBUG) {
1189                 Throwable stackTrace = new Throwable();
1190                 stackTrace.fillInStackTrace();
1191                 Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1192             }
1193             return false;
1194         }
1195         mIconCache = appState.getIconCache();
1196         return mIconCache != null;
1197     }
1198 
1199 
1200     /**
1201      * @return true if the launcher is in a state to support backup
1202      */
1203     private boolean launcherIsReady() {
1204         ContentResolver cr = mContext.getContentResolver();
1205         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1206         if (cursor == null) {
1207             // launcher data has been wiped, do nothing
1208             return false;
1209         }
1210         cursor.close();
1211 
1212         if (!initializeIconCache()) {
1213             // launcher services are unavailable, try again later
1214             dataChanged();
1215             return false;
1216         }
1217 
1218         return true;
1219     }
1220 
1221     private String getUserSelectionArg() {
1222         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1223                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1224     }
1225 
1226     private class InvalidBackupException extends IOException {
1227 
1228         private static final long serialVersionUID = 8931456637211665082L;
1229 
1230         private InvalidBackupException(Throwable cause) {
1231             super(cause);
1232         }
1233 
1234         public InvalidBackupException(String reason) {
1235             super(reason);
1236         }
1237     }
1238 
1239     /**
1240      * A class to check if an activity can handle one of the intents from a list of
1241      * predefined intents.
1242      */
1243     private class ItemTypeMatcher {
1244 
1245         private final ArrayList&lt;Intent&gt; mIntents;
1246 
1247         ItemTypeMatcher(int xml_res) {
1248             mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1249         }
1250 
1251         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1252             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1253             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1254             try {
1255                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1256                 final int depth = parser.getDepth();
1257                 int type;
1258                 while (((type = parser.next()) != XmlPullParser.END_TAG ||
1259                         parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1260                     if (type != XmlPullParser.START_TAG) {
1261                         continue;
1262                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
1263                         final String uri = DefaultLayoutParser.getAttributeValue(
1264                                 parser, DefaultLayoutParser.ATTR_URI);
1265                         intents.add(Intent.parseUri(uri, 0));
1266                     }
1267                 }
1268             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1269                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1270             } finally {
1271                 parser.close();
1272             }
1273             return intents;
1274         }
1275 
1276         public boolean matches(ActivityInfo activity, PackageManager pm) {
1277             for (Intent intent : mIntents) {
1278                 intent.setPackage(activity.packageName);
1279                 ResolveInfo info = pm.resolveActivity(intent, 0);
1280                 if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)
1281                         || info.activityInfo.name.equals(activity.targetActivity))) {
1282                     return true;
1283                 }
1284             }
1285             return false;
1286         }
1287     }
1288 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager;
  29 import android.content.pm.PackageManager.NameNotFoundException;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.drawable.Drawable;
  36 import android.os.ParcelFileDescriptor;
  37 import android.text.TextUtils;
  38 import android.util.Base64;
  39 import android.util.Log;
  40 
  41 import com.android.launcher3.LauncherSettings.Favorites;
  42 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  43 import com.android.launcher3.backup.BackupProtos;
  44 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  45 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  46 import com.android.launcher3.backup.BackupProtos.Favorite;
  47 import com.android.launcher3.backup.BackupProtos.Journal;
  48 import com.android.launcher3.backup.BackupProtos.Key;
  49 import com.android.launcher3.backup.BackupProtos.Resource;
  50 import com.android.launcher3.backup.BackupProtos.Screen;
  51 import com.android.launcher3.backup.BackupProtos.Widget;
  52 import com.android.launcher3.compat.UserHandleCompat;
  53 import com.android.launcher3.compat.UserManagerCompat;
  54 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  55 import com.google.protobuf.nano.MessageNano;
  56 
  57 import org.xmlpull.v1.XmlPullParser;
  58 import org.xmlpull.v1.XmlPullParserException;
  59 
  60 import java.io.ByteArrayOutputStream;
  61 import java.io.FileInputStream;
  62 import java.io.FileOutputStream;
  63 import java.io.IOException;
  64 import java.net.URISyntaxException;
  65 import java.util.ArrayList;
  66 import java.util.Arrays;
  67 import java.util.HashSet;
  68 import java.util.zip.CRC32;
  69 
  70 /**
  71  * Persist the launcher home state across calamities.
  72  */
  73 public class LauncherBackupHelper implements BackupHelper {
  74     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  75     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  76     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  77 
  78     private static final int BACKUP_VERSION = 2;
  79     private static final int MAX_JOURNAL_SIZE = 1000000;
  80 
  81     // Journal key is such that it is always smaller than any dynamically generated
  82     // key (any Base64 encoded string).
  83     private static final String JOURNAL_KEY = &quot;#&quot;;
  84 
  85     /** icons are large, dribble them out */
  86     private static final int MAX_ICONS_PER_PASS = 10;
  87 
  88     /** widgets contain previews, which are very large, dribble them out */
  89     private static final int MAX_WIDGETS_PER_PASS = 5;
  90 
  91     private static final int IMAGE_COMPRESSION_QUALITY = 75;
  92 
  93     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  94             android.graphics.Bitmap.CompressFormat.PNG;
  95 
  96     private static final String[] FAVORITE_PROJECTION = {
  97         Favorites._ID,                     // 0
  98         Favorites.MODIFIED,                // 1
  99         Favorites.INTENT,                  // 2
 100         Favorites.APPWIDGET_PROVIDER,      // 3
 101         Favorites.APPWIDGET_ID,            // 4
 102         Favorites.CELLX,                   // 5
 103         Favorites.CELLY,                   // 6
 104         Favorites.CONTAINER,               // 7
 105         Favorites.ICON,                    // 8
 106         Favorites.ICON_PACKAGE,            // 9
 107         Favorites.ICON_RESOURCE,           // 10
 108         Favorites.ICON_TYPE,               // 11
 109         Favorites.ITEM_TYPE,               // 12
 110         Favorites.SCREEN,                  // 13
 111         Favorites.SPANX,                   // 14
 112         Favorites.SPANY,                   // 15
 113         Favorites.TITLE,                   // 16
 114         Favorites.PROFILE_ID,              // 17
 115     };
 116 
 117     private static final int ID_INDEX = 0;
 118     private static final int ID_MODIFIED = 1;
 119     private static final int INTENT_INDEX = 2;
 120     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 121     private static final int APPWIDGET_ID_INDEX = 4;
 122     private static final int CELLX_INDEX = 5;
 123     private static final int CELLY_INDEX = 6;
 124     private static final int CONTAINER_INDEX = 7;
 125     private static final int ICON_INDEX = 8;
 126     private static final int ICON_PACKAGE_INDEX = 9;
 127     private static final int ICON_RESOURCE_INDEX = 10;
 128     private static final int ICON_TYPE_INDEX = 11;
 129     private static final int ITEM_TYPE_INDEX = 12;
 130     private static final int SCREEN_INDEX = 13;
 131     private static final int SPANX_INDEX = 14;
 132     private static final int SPANY_INDEX = 15;
 133     private static final int TITLE_INDEX = 16;
 134 
 135     private static final String[] SCREEN_PROJECTION = {
 136         WorkspaceScreens._ID,              // 0
 137         WorkspaceScreens.MODIFIED,         // 1
 138         WorkspaceScreens.SCREEN_RANK       // 2
 139     };
 140 
 141     private static final int SCREEN_RANK_INDEX = 2;
 142 
 143     private final Context mContext;
 144     private final HashSet&lt;String&gt; mExistingKeys;
 145     private final ArrayList&lt;Key&gt; mKeys;
 146     private final ItemTypeMatcher[] mItemTypeMatchers;
 147     private final long mUserSerial;
 148 
 149     private IconCache mIconCache;
 150     private BackupManager mBackupManager;
 151     private byte[] mBuffer = new byte[512];
 152     private long mLastBackupRestoreTime;
 153     private boolean mBackupDataWasUpdated;
 154 
 155     private DeviceProfieData mCurrentProfile;
 156     boolean restoreSuccessful;
 157     int restoredBackupVersion = 1;
 158 
 159     public LauncherBackupHelper(Context context) {
 160         mContext = context;
 161         mExistingKeys = new HashSet&lt;String&gt;();
 162         mKeys = new ArrayList&lt;Key&gt;();
 163         restoreSuccessful = true;
 164         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 165 
 166         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 167         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 168     }
 169 
 170     private void dataChanged() {
 171         if (mBackupManager == null) {
 172             mBackupManager = new BackupManager(mContext);
 173         }
 174         mBackupManager.dataChanged();
 175     }
 176 
 177     private void applyJournal(Journal journal) {
 178         mLastBackupRestoreTime = journal.t;
 179         mExistingKeys.clear();
 180         if (journal.key != null) {
 181             for (Key key : journal.key) {
 182                 mExistingKeys.add(keyToBackupKey(key));
 183             }
 184         }
 185     }
 186 
 187     /**
 188      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 189      *
 190      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 191      *
 192      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 193      *
 194      * @param oldState notes from the last backup
 195      * @param data incremental key/value pairs to persist off-device
 196      * @param newState notes for the next backup
 197      */
 198     @Override
 199     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 200             ParcelFileDescriptor newState) {
 201         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 202 
 203         Journal in = readJournal(oldState);
 204         if (!launcherIsReady()) {
 205             // Perform backup later.
 206             writeJournal(newState, in);
 207             return;
 208         }
 209         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 210         mKeys.clear();
 211         applyJournal(in);
 212 
 213         // Record the time before performing backup so that entries edited while the backup
 214         // was going on, do not get missed in next backup.
 215         long newBackupTime = System.currentTimeMillis();
 216         mBackupDataWasUpdated = false;
 217         try {
 218             backupFavorites(data);
 219             backupScreens(data);
 220             backupIcons(data);
 221             backupWidgets(data);
 222 
 223             // Delete any key which still exist in the old backup, but is not valid anymore.
 224             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 225             for (Key key : mKeys) {
 226                 validKeys.add(keyToBackupKey(key));
 227             }
 228             mExistingKeys.removeAll(validKeys);
 229 
 230             // Delete anything left in the existing keys.
 231             for (String deleted: mExistingKeys) {
 232                 if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 233                 data.writeEntityHeader(deleted, -1);
 234                 mBackupDataWasUpdated = true;
 235             }
 236 
 237             mExistingKeys.clear();
 238             if (!mBackupDataWasUpdated) {
 239                 // Check if any metadata has changed
 240                 mBackupDataWasUpdated = (in.profile == null)
 241                         || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 242                             DeviceProfieData.toByteArray(getDeviceProfieData()))
 243                         || (in.backupVersion != BACKUP_VERSION)
 244                         || (in.appVersion != getAppVersion());
 245             }
 246 
 247             if (mBackupDataWasUpdated) {
 248                 mLastBackupRestoreTime = newBackupTime;
 249 
 250                 // We store the journal at two places.
 251                 //   1) Storing it in newState allows us to do partial backups by comparing old state
 252                 //   2) Storing it in backup data allows us to validate keys during restore
 253                 Journal state = getCurrentStateJournal();
 254                 writeRowToBackup(JOURNAL_KEY, state, data);
 255             } else {
 256                 if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 257             }
 258         } catch (IOException e) {
 259             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 260         }
 261 
 262         writeNewStateDescription(newState);
 263     }
 264 
 265     /**
 266      * @return true if the backup corresponding to oldstate can be successfully applied
 267      * to this device.
 268      */
 269     private boolean isBackupCompatible(Journal oldState) {
 270         DeviceProfieData currentProfile = getDeviceProfieData();
 271 
 272         DeviceProfieData oldProfile = oldState.profile;
 273 
 274         if (oldProfile == null || oldProfile.desktopCols == 0) {
 275             // Profile info is not valid, ignore the check.
 276             return true;
 277         }
 278 
 279         boolean isHotsetCompatible = false;
 280         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 281             isHotsetCompatible = true;
 282         }
 283         if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 284                 (currentProfile.allappsRank == oldProfile.allappsRank)) {
 285             isHotsetCompatible = true;
 286         }
 287 
 288         return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 289                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 290     }
 291 
 292     /**
 293      * Restore launcher configuration from the restored data stream.
 294      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 295      * backup, it should arrive first.
 296      *
 297      * @param data the key/value pair from the server
 298      */
 299     @Override
 300     public void restoreEntity(BackupDataInputStream data) {
 301         if (!restoreSuccessful) {
 302             return;
 303         }
 304         if (!initializeIconCache()) {
 305             // During restore we do not need an initialized instance of IconCache. We can create
 306             // a temporary icon cache here, as the process will be rebooted after restore
 307             // is complete.
 308             mIconCache = new IconCache(mContext);
 309         }
 310 
 311         int dataSize = data.size();
 312         if (mBuffer.length &lt; dataSize) {
 313             mBuffer = new byte[dataSize];
 314         }
 315         try {
 316             int bytesRead = data.read(mBuffer, 0, dataSize);
 317             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 318             String backupKey = data.getKey();
 319 
 320             if (JOURNAL_KEY.equals(backupKey)) {
 321                 if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 322                 if (!mKeys.isEmpty()) {
 323                     // We received the journal key after a restore key.
 324                     Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 325                     restoreSuccessful = false;
 326                     return;
 327                 }
 328 
 329                 Journal journal = new Journal();
 330                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 331                 applyJournal(journal);
 332                 restoreSuccessful = isBackupCompatible(journal);
 333                 restoredBackupVersion = journal.backupVersion;
 334                 return;
 335             }
 336 
 337             if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 338                 if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 339                 return;
 340             }
 341             Key key = backupKeyToKey(backupKey);
 342             mKeys.add(key);
 343             switch (key.type) {
 344                 case Key.FAVORITE:
 345                     restoreFavorite(key, mBuffer, dataSize);
 346                     break;
 347 
 348                 case Key.SCREEN:
 349                     restoreScreen(key, mBuffer, dataSize);
 350                     break;
 351 
 352                 case Key.ICON:
 353                     restoreIcon(key, mBuffer, dataSize);
 354                     break;
 355 
 356                 case Key.WIDGET:
 357                     restoreWidget(key, mBuffer, dataSize);
 358                     break;
 359 
 360                 default:
 361                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 362                     mKeys.remove(key);
 363                     break;
 364             }
 365         } catch (IOException e) {
 366             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 367         }
 368     }
 369 
 370     /**
 371      * Record the restore state for the next backup.
 372      *
 373      * @param newState notes about the backup state after restore.
 374      */
 375     @Override
 376     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 377         writeJournal(newState, getCurrentStateJournal());
 378     }
 379 
 380     private Journal getCurrentStateJournal() {
 381         Journal journal = new Journal();
 382         journal.t = mLastBackupRestoreTime;
 383         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 384         journal.appVersion = getAppVersion();
 385         journal.backupVersion = BACKUP_VERSION;
 386         journal.profile = getDeviceProfieData();
 387         return journal;
 388     }
 389 
 390     private int getAppVersion() {
 391         try {
 392             return mContext.getPackageManager()
 393                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 394         } catch (NameNotFoundException e) {
 395             return 0;
 396         }
 397     }
 398 
 399     /**
 400      * @return the current device profile information.
 401      */
 402     private DeviceProfieData getDeviceProfieData() {
 403         if (mCurrentProfile != null) {
 404             return mCurrentProfile;
 405         }
 406         final Context applicationContext = mContext.getApplicationContext();
 407         DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)
 408                 .getDeviceProfile();
 409 
 410         mCurrentProfile = new DeviceProfieData();
 411         mCurrentProfile.desktopRows = profile.numRows;
 412         mCurrentProfile.desktopCols = profile.numColumns;
 413         mCurrentProfile.hotseatCount = profile.numHotseatIcons;
 414         mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;
 415         return mCurrentProfile;
 416     }
 417 
 418     /**
 419      * Write all modified favorites to the data stream.
 420      *
 421      * @param data output stream for key/value pairs
 422      * @throws IOException
 423      */
 424     private void backupFavorites(BackupDataOutput data) throws IOException {
 425         // persist things that have changed since the last backup
 426         ContentResolver cr = mContext.getContentResolver();
 427         // Don&#x27;t backup apps in other profiles for now.
 428         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 429                 getUserSelectionArg(), null, null);
 430         try {
 431             cursor.moveToPosition(-1);
 432             while(cursor.moveToNext()) {
 433                 final long id = cursor.getLong(ID_INDEX);
 434                 final long updateTime = cursor.getLong(ID_MODIFIED);
 435                 Key key = getKey(Key.FAVORITE, id);
 436                 mKeys.add(key);
 437                 final String backupKey = keyToBackupKey(key);
 438                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 439                     writeRowToBackup(key, packFavorite(cursor), data);
 440                 } else {
 441                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 442                 }
 443             }
 444         } finally {
 445             cursor.close();
 446         }
 447     }
 448 
 449     /**
 450      * Read a favorite from the stream.
 451      *
 452      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 453      *
 454      * @param key identifier for the row
 455      * @param buffer the serialized proto from the stream, may be larger than dataSize
 456      * @param dataSize the size of the proto from the stream
 457      */
 458     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 459         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 460         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 461                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 462 
 463         ContentResolver cr = mContext.getContentResolver();
 464         ContentValues values = unpackFavorite(buffer, dataSize);
 465         cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 466     }
 467 
 468     /**
 469      * Write all modified screens to the data stream.
 470      *
 471      * @param data output stream for key/value pairs
 472      * @throws IOException
 473      */
 474     private void backupScreens(BackupDataOutput data) throws IOException {
 475         // persist things that have changed since the last backup
 476         ContentResolver cr = mContext.getContentResolver();
 477         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 478                 null, null, null);
 479         try {
 480             cursor.moveToPosition(-1);
 481             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 482             while(cursor.moveToNext()) {
 483                 final long id = cursor.getLong(ID_INDEX);
 484                 final long updateTime = cursor.getLong(ID_MODIFIED);
 485                 Key key = getKey(Key.SCREEN, id);
 486                 mKeys.add(key);
 487                 final String backupKey = keyToBackupKey(key);
 488                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 489                     writeRowToBackup(key, packScreen(cursor), data);
 490                 } else {
 491                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 492                 }
 493             }
 494         } finally {
 495             cursor.close();
 496         }
 497     }
 498 
 499     /**
 500      * Read a screen from the stream.
 501      *
 502      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 503      *
 504      * @param key identifier for the row
 505      * @param buffer the serialized proto from the stream, may be larger than dataSize
 506      * @param dataSize the size of the proto from the stream
 507      */
 508     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 509         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 510         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 511                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 512 
 513         ContentResolver cr = mContext.getContentResolver();
 514         ContentValues values = unpackScreen(buffer, dataSize);
 515         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 516     }
 517 
 518     /**
 519      * Write all the static icon resources we need to render placeholders
 520      * for a package that is not installed.
 521      *
 522      * @param data output stream for key/value pairs
 523      */
 524     private void backupIcons(BackupDataOutput data) throws IOException {
 525         // persist icons that haven&#x27;t been persisted yet
 526         if (!initializeIconCache()) {
 527             dataChanged(); // try again later
 528             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 529             return;
 530         }
 531         final ContentResolver cr = mContext.getContentResolver();
 532         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 533         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 534         int backupUpIconCount = 0;
 535 
 536         // Don&#x27;t backup apps in other profiles for now.
 537         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 538                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 539                 getUserSelectionArg();
 540         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 541                 where, null, null);
 542         try {
 543             cursor.moveToPosition(-1);
 544             while(cursor.moveToNext()) {
 545                 final long id = cursor.getLong(ID_INDEX);
 546                 final String intentDescription = cursor.getString(INTENT_INDEX);
 547                 try {
 548                     Intent intent = Intent.parseUri(intentDescription, 0);
 549                     ComponentName cn = intent.getComponent();
 550                     Key key = null;
 551                     String backupKey = null;
 552                     if (cn != null) {
 553                         key = getKey(Key.ICON, cn.flattenToShortString());
 554                         backupKey = keyToBackupKey(key);
 555                     } else {
 556                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 557                     }
 558                     if (mExistingKeys.contains(backupKey)) {
 559                         if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 560 
 561                         // remember that we already backed this up previously
 562                         mKeys.add(key);
 563                     } else if (backupKey != null) {
 564                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 565                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 566                             if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 567                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 568                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 569                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 570                                 mKeys.add(key);
 571                                 backupUpIconCount ++;
 572                             }
 573                         } else {
 574                             if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 575                             // too many icons for this pass, request another.
 576                             dataChanged();
 577                         }
 578                     }
 579                 } catch (URISyntaxException e) {
 580                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 581                 } catch (IOException e) {
 582                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 583                 }
 584 
 585             }
 586         } finally {
 587             cursor.close();
 588         }
 589     }
 590 
 591     /**
 592      * Read an icon from the stream.
 593      *
 594      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 595      *
 596      * @param key identifier for the row
 597      * @param buffer the serialized proto from the stream, may be larger than dataSize
 598      * @param dataSize the size of the proto from the stream
 599      */
 600     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 601         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 602         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 603                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 604 
 605         Resource res = unpackProto(new Resource(), buffer, dataSize);
 606         if (DEBUG) {
 607             Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 608         }
 609         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 610         if (icon == null) {
 611             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 612         }
 613         if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 614         mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,
 615                 &quot;&quot; /* label */, mUserSerial);
 616     }
 617 
 618     /**
 619      * Write all the static widget resources we need to render placeholders
 620      * for a package that is not installed.
 621      *
 622      * @param data output stream for key/value pairs
 623      * @throws IOException
 624      */
 625     private void backupWidgets(BackupDataOutput data) throws IOException {
 626         // persist static widget info that hasn&#x27;t been persisted yet
 627         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 628         if (appState == null || !initializeIconCache()) {
 629             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 630             return;
 631         }
 632         final ContentResolver cr = mContext.getContentResolver();
 633         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 634         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 635         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 636         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 637         int backupWidgetCount = 0;
 638 
 639         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 640                 + getUserSelectionArg();
 641         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 642                 where, null, null);
 643         try {
 644             cursor.moveToPosition(-1);
 645             while(cursor.moveToNext()) {
 646                 final long id = cursor.getLong(ID_INDEX);
 647                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 648                 final int spanX = cursor.getInt(SPANX_INDEX);
 649                 final int spanY = cursor.getInt(SPANY_INDEX);
 650                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 651                 Key key = null;
 652                 String backupKey = null;
 653                 if (provider != null) {
 654                     key = getKey(Key.WIDGET, providerName);
 655                     backupKey = keyToBackupKey(key);
 656                 } else {
 657                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 658                 }
 659                 if (mExistingKeys.contains(backupKey)) {
 660                     if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 661 
 662                     // remember that we already backed this up previously
 663                     mKeys.add(key);
 664                 } else if (backupKey != null) {
 665                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 666                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 667                         if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
 668 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 669                         previewLoader.setPreviewSize(</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 670                                 spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 671                                 spanY * profile.cellHeightPx);</span>
 672 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 673                         if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 674                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 675                                 spanY * profile.cellHeightPx, widgetSpacingLayout);</span>
 676 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 677                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 678                                 spanY * profile.cellHeightPx, widgetSpacingLayout);</span>
 679 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 680                         UserHandleCompat user = UserHandleCompat.myUserHandle();
 681                         writeRowToBackup(key,
 682                                 packWidget(dpi, previewLoader, mIconCache, provider, user),
 683                                 data);
 684                         mKeys.add(key);
 685                         backupWidgetCount ++;
 686                     } else {
 687                         if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 688                         // too many widgets for this pass, request another.
 689                         dataChanged();
 690                     }
 691                 }
 692             }
 693         } finally {
 694             cursor.close();
 695         }
 696     }
 697 
 698     /**
 699      * Read a widget from the stream.
 700      *
 701      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 702      *
 703      * @param key identifier for the row
 704      * @param buffer the serialized proto from the stream, may be larger than dataSize
 705      * @param dataSize the size of the proto from the stream
 706      */
 707     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 708         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 709         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 710                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 711         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 712         if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 713         if (widget.icon.data != null)  {
 714             Bitmap icon = BitmapFactory
 715                     .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 716             if (icon == null) {
 717                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 718             } else {
 719                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),
 720                         icon, widget.icon.dpi, widget.label, mUserSerial);
 721             }
 722         }
 723 
 724         // future site of widget table mutation
 725     }
 726 
 727     /** create a new key, with an integer ID.
 728      *
 729      * &lt;P&gt; Keys contain their own checksum instead of using
 730      * the heavy-weight CheckedMessage wrapper.
 731      */
 732     private Key getKey(int type, long id) {
 733         Key key = new Key();
 734         key.type = type;
 735         key.id = id;
 736         key.checksum = checkKey(key);
 737         return key;
 738     }
 739 
 740     /** create a new key for a named object.
 741      *
 742      * &lt;P&gt; Keys contain their own checksum instead of using
 743      * the heavy-weight CheckedMessage wrapper.
 744      */
 745     private Key getKey(int type, String name) {
 746         Key key = new Key();
 747         key.type = type;
 748         key.name = name;
 749         key.checksum = checkKey(key);
 750         return key;
 751     }
 752 
 753     /** keys need to be strings, serialize and encode. */
 754     private String keyToBackupKey(Key key) {
 755         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 756     }
 757 
 758     /** keys need to be strings, decode and parse. */
 759     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 760         try {
 761             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 762             if (key.checksum != checkKey(key)) {
 763                 key = null;
 764                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 765             }
 766             return key;
 767         } catch (InvalidProtocolBufferNanoException e) {
 768             throw new InvalidBackupException(e);
 769         } catch (IllegalArgumentException e) {
 770             throw new InvalidBackupException(e);
 771         }
 772     }
 773 
 774     /** Compute the checksum over the important bits of a key. */
 775     private long checkKey(Key key) {
 776         CRC32 checksum = new CRC32();
 777         checksum.update(key.type);
 778         checksum.update((int) (key.id &amp; 0xffff));
 779         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 780         if (!TextUtils.isEmpty(key.name)) {
 781             checksum.update(key.name.getBytes());
 782         }
 783         return checksum.getValue();
 784     }
 785 
 786     /**
 787      * @return true if its an hotseat item, that can be replaced during restore.
 788      * TODO: Extend check for folders in hotseat.
 789      */
 790     private boolean isReplaceableHotseatItem(Favorite favorite) {
 791         return favorite.container == Favorites.CONTAINER_HOTSEAT
 792                 &amp;&amp; favorite.intent != null
 793                 &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION
 794                 || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);
 795     }
 796 
 797     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 798     private Favorite packFavorite(Cursor c) {
 799         Favorite favorite = new Favorite();
 800         favorite.id = c.getLong(ID_INDEX);
 801         favorite.screen = c.getInt(SCREEN_INDEX);
 802         favorite.container = c.getInt(CONTAINER_INDEX);
 803         favorite.cellX = c.getInt(CELLX_INDEX);
 804         favorite.cellY = c.getInt(CELLY_INDEX);
 805         favorite.spanX = c.getInt(SPANX_INDEX);
 806         favorite.spanY = c.getInt(SPANY_INDEX);
 807         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 808         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 809             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 810             if (!TextUtils.isEmpty(iconPackage)) {
 811                 favorite.iconPackage = iconPackage;
 812             }
 813             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 814             if (!TextUtils.isEmpty(iconResource)) {
 815                 favorite.iconResource = iconResource;
 816             }
 817         }
 818         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 819             byte[] blob = c.getBlob(ICON_INDEX);
 820             if (blob != null &amp;&amp; blob.length &gt; 0) {
 821                 favorite.icon = blob;
 822             }
 823         }
 824         String title = c.getString(TITLE_INDEX);
 825         if (!TextUtils.isEmpty(title)) {
 826             favorite.title = title;
 827         }
 828         String intentDescription = c.getString(INTENT_INDEX);
 829         Intent intent = null;
 830         if (!TextUtils.isEmpty(intentDescription)) {
 831             try {
 832                 intent = Intent.parseUri(intentDescription, 0);
 833                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 834                 favorite.intent = intent.toUri(0);
 835             } catch (URISyntaxException e) {
 836                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 837             }
 838         }
 839         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 840         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 841             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 842             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 843             if (!TextUtils.isEmpty(appWidgetProvider)) {
 844                 favorite.appWidgetProvider = appWidgetProvider;
 845             }
 846         }
 847 
 848         if (isReplaceableHotseatItem(favorite)) {
 849             if (intent != null &amp;&amp; intent.getComponent() != null) {
 850                 PackageManager pm = mContext.getPackageManager();
 851                 ActivityInfo activity = null;;
 852                 try {
 853                     activity = pm.getActivityInfo(intent.getComponent(), 0);
 854                 } catch (NameNotFoundException e) {
 855                     Log.e(TAG, &quot;Target not found&quot;, e);
 856                 }
 857                 if (activity == null) {
 858                     return favorite;
 859                 }
 860                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
 861                     if (mItemTypeMatchers[i] == null) {
 862                         mItemTypeMatchers[i] = new ItemTypeMatcher(
 863                                 CommonAppTypeParser.getResourceForItemType(i));
 864                     }
 865                     if (mItemTypeMatchers[i].matches(activity, pm)) {
 866                         favorite.targetType = i;
 867                         break;
 868                     }
 869                 }
 870             }
 871         }
 872 
 873         return favorite;
 874     }
 875 
 876     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 877     private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 878             throws IOException {
 879         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
 880 
 881         ContentValues values = new ContentValues();
 882         values.put(Favorites._ID, favorite.id);
 883         values.put(Favorites.SCREEN, favorite.screen);
 884         values.put(Favorites.CONTAINER, favorite.container);
 885         values.put(Favorites.CELLX, favorite.cellX);
 886         values.put(Favorites.CELLY, favorite.cellY);
 887         values.put(Favorites.SPANX, favorite.spanX);
 888         values.put(Favorites.SPANY, favorite.spanY);
 889         values.put(Favorites.ICON_TYPE, favorite.iconType);
 890         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 891             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 892             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 893         }
 894         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 895             values.put(Favorites.ICON, favorite.icon);
 896         }
 897         if (!TextUtils.isEmpty(favorite.title)) {
 898             values.put(Favorites.TITLE, favorite.title);
 899         } else {
 900             values.put(Favorites.TITLE, &quot;&quot;);
 901         }
 902         if (!TextUtils.isEmpty(favorite.intent)) {
 903             values.put(Favorites.INTENT, favorite.intent);
 904         }
 905         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 906 
 907         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 908         long userSerialNumber =
 909                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 910         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 911 
 912         DeviceProfieData currentProfile = getDeviceProfieData();
 913 
 914         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 915             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 916                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 917             }
 918             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 919             values.put(LauncherSettings.Favorites.RESTORED,
 920                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 921                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 922                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 923 
 924             // Verify placement
 925             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 926                     || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 927                 restoreSuccessful = false;
 928                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 929             }
 930         } else {
 931             // Check if it is an hotseat item, that can be replaced.
 932             if (isReplaceableHotseatItem(favorite)
 933                     &amp;&amp; favorite.targetType != Favorite.TARGET_NONE
 934                     &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {
 935                 Log.e(TAG, &quot;Added item type flag&quot;);
 936                 values.put(LauncherSettings.Favorites.RESTORED,
 937                         1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));
 938             } else {
 939             // Let LauncherModel know we&#x27;ve been here.
 940             values.put(LauncherSettings.Favorites.RESTORED, 1);
 941             }
 942 
 943             // Verify placement
 944             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 945                 if ((favorite.screen &gt;= currentProfile.hotseatCount)
 946                         || (favorite.screen == currentProfile.allappsRank)) {
 947                     restoreSuccessful = false;
 948                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 949                 }
 950             } else {
 951                 if ((favorite.cellX &gt;= currentProfile.desktopCols)
 952                         || (favorite.cellY &gt;= currentProfile.desktopRows)) {
 953                     restoreSuccessful = false;
 954                     throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 955                 }
 956             }
 957         }
 958 
 959         return values;
 960     }
 961 
 962     /** Serialize a Screen for persistence, including a checksum wrapper. */
 963     private Screen packScreen(Cursor c) {
 964         Screen screen = new Screen();
 965         screen.id = c.getLong(ID_INDEX);
 966         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 967         return screen;
 968     }
 969 
 970     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 971     private ContentValues unpackScreen(byte[] buffer, int dataSize)
 972             throws InvalidProtocolBufferNanoException {
 973         Screen screen = unpackProto(new Screen(), buffer, dataSize);
 974         ContentValues values = new ContentValues();
 975         values.put(WorkspaceScreens._ID, screen.id);
 976         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 977         return values;
 978     }
 979 
 980     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 981     private Resource packIcon(int dpi, Bitmap icon) {
 982         Resource res = new Resource();
 983         res.dpi = dpi;
 984         ByteArrayOutputStream os = new ByteArrayOutputStream();
 985         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 986             res.data = os.toByteArray();
 987         }
 988         return res;
 989     }
 990 
 991     /** Serialize a widget for persistence, including a checksum wrapper. */
 992     private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 993             ComponentName provider, UserHandleCompat user) {
 994         final LauncherAppWidgetProviderInfo info =
 995                 LauncherModel.getProviderInfo(mContext, provider, user);
 996         Widget widget = new Widget();
 997         widget.provider = provider.flattenToShortString();
 998         widget.label = info.label;
 999         widget.configure = info.configure != null;
1000         if (info.icon != 0) {
1001             widget.icon = new Resource();
1002             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
1003             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
1004             ByteArrayOutputStream os = new ByteArrayOutputStream();
1005             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1006                 widget.icon.data = os.toByteArray();
1007                 widget.icon.dpi = dpi;
1008             }
1009         }
1010         if (info.previewImage != 0) {
1011             widget.preview = new Resource();
1012             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
1013             ByteArrayOutputStream os = new ByteArrayOutputStream();
1014             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1015                 widget.preview.data = os.toByteArray();
1016                 widget.preview.dpi = dpi;
1017             }
1018         }
1019         return widget;
1020     }
1021 
1022     /**
1023      * Deserialize a proto after verifying checksum wrapper.
1024      */
1025     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1026             throws InvalidProtocolBufferNanoException {
1027         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1028         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1029         return proto;
1030     }
1031 
1032     /**
1033      * Read the old journal from the input file.
1034      *
1035      * In the event of any error, just pretend we didn&#x27;t have a journal,
1036      * in that case, do a full backup.
1037      *
1038      * @param oldState the read-0only file descriptor pointing to the old journal
1039      * @return a Journal protocol buffer
1040      */
1041     private Journal readJournal(ParcelFileDescriptor oldState) {
1042         Journal journal = new Journal();
1043         if (oldState == null) {
1044             return journal;
1045         }
1046         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1047         try {
1048             int availableBytes = inStream.available();
1049             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1050             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1051                 byte[] buffer = new byte[availableBytes];
1052                 int bytesRead = 0;
1053                 boolean valid = false;
1054                 InvalidProtocolBufferNanoException lastProtoException = null;
1055                 while (availableBytes &gt; 0) {
1056                     try {
1057                         // OMG what are you doing? This is crazy inefficient!
1058                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1059                         // However, we don&#x27;t know how many bytes to expect (oops).
1060                         // So we have to step through *slowly*, watching for the end.
1061                         int result = inStream.read(buffer, bytesRead, 1);
1062                         if (result &gt; 0) {
1063                             availableBytes -= result;
1064                             bytesRead += result;
1065                         } else {
1066                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1067                             // stop reading and see what there is to parse
1068                             availableBytes = 0;
1069                         }
1070                     } catch (IOException e) {
1071                         buffer = null;
1072                         availableBytes = 0;
1073                     }
1074 
1075                     // check the buffer to see if we have a valid journal
1076                     try {
1077                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1078                         // if we are here, then we have read a valid, checksum-verified journal
1079                         valid = true;
1080                         availableBytes = 0;
1081                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1082                     } catch (InvalidProtocolBufferNanoException e) {
1083                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1084                         lastProtoException = e;
1085                         journal.clear();
1086                     }
1087                 }
1088                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1089                 if (!valid) {
1090                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1091                 }
1092             }
1093         } catch (IOException e) {
1094             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1095         } finally {
1096             try {
1097                 inStream.close();
1098             } catch (IOException e) {
1099                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1100             }
1101         }
1102         return journal;
1103     }
1104 
1105     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1106             throws IOException {
1107         writeRowToBackup(keyToBackupKey(key), proto, data);
1108     }
1109 
1110     private void writeRowToBackup(String backupKey, MessageNano proto,
1111             BackupDataOutput data) throws IOException {
1112         byte[] blob = writeCheckedBytes(proto);
1113         data.writeEntityHeader(backupKey, blob.length);
1114         data.writeEntityData(blob, blob.length);
1115         mBackupDataWasUpdated = true;
1116         if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1117     }
1118 
1119     /**
1120      * Write the new journal to the output file.
1121      *
1122      * In the event of any error, just pretend we didn&#x27;t have a journal,
1123      * in that case, do a full backup.
1124 
1125      * @param newState the write-only file descriptor pointing to the new journal
1126      * @param journal a Journal protocol buffer
1127      */
1128     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1129         FileOutputStream outStream = null;
1130         try {
1131             outStream = new FileOutputStream(newState.getFileDescriptor());
1132             final byte[] journalBytes = writeCheckedBytes(journal);
1133             outStream.write(journalBytes);
1134             outStream.close();
1135             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1136         } catch (IOException e) {
1137             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1138         }
1139     }
1140 
1141     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1142     private byte[] writeCheckedBytes(MessageNano proto) {
1143         CheckedMessage wrapper = new CheckedMessage();
1144         wrapper.payload = MessageNano.toByteArray(proto);
1145         CRC32 checksum = new CRC32();
1146         checksum.update(wrapper.payload);
1147         wrapper.checksum = checksum.getValue();
1148         return MessageNano.toByteArray(wrapper);
1149     }
1150 
1151     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1152     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1153             throws InvalidProtocolBufferNanoException {
1154         CheckedMessage wrapper = new CheckedMessage();
1155         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1156         CRC32 checksum = new CRC32();
1157         checksum.update(wrapper.payload);
1158         if (wrapper.checksum != checksum.getValue()) {
1159             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1160         }
1161         return wrapper.payload;
1162     }
1163 
1164     private boolean initializeIconCache() {
1165         if (mIconCache != null) {
1166             return true;
1167         }
1168 
1169         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1170         if (appState == null) {
1171             if (DEBUG) {
1172             Throwable stackTrace = new Throwable();
1173             stackTrace.fillInStackTrace();
1174             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1175             }
1176             return false;
1177         }
1178         mIconCache = appState.getIconCache();
1179         return mIconCache != null;
1180     }
1181 
1182 
1183     /**
1184      * @return true if the launcher is in a state to support backup
1185      */
1186     private boolean launcherIsReady() {
1187         ContentResolver cr = mContext.getContentResolver();
1188         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1189         if (cursor == null) {
1190             // launcher data has been wiped, do nothing
1191             return false;
1192         }
1193         cursor.close();
1194 
1195         if (!initializeIconCache()) {
1196             // launcher services are unavailable, try again later
1197             dataChanged();
1198             return false;
1199         }
1200 
1201         return true;
1202     }
1203 
1204     private String getUserSelectionArg() {
1205         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1206                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1207     }
1208 
1209     private class InvalidBackupException extends IOException {
1210 
1211         private static final long serialVersionUID = 8931456637211665082L;
1212 
1213         private InvalidBackupException(Throwable cause) {
1214             super(cause);
1215         }
1216 
1217         public InvalidBackupException(String reason) {
1218             super(reason);
1219         }
1220     }
1221 
1222     /**
1223      * A class to check if an activity can handle one of the intents from a list of
1224      * predefined intents.
1225      */
1226     private class ItemTypeMatcher {
1227 
1228         private final ArrayList&lt;Intent&gt; mIntents;
1229 
1230         ItemTypeMatcher(int xml_res) {
1231             mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1232         }
1233 
1234         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1235             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1236             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1237             try {
1238                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1239                 final int depth = parser.getDepth();
1240                 int type;
1241                 while (((type = parser.next()) != XmlPullParser.END_TAG ||
1242                         parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1243                     if (type != XmlPullParser.START_TAG) {
1244                         continue;
1245                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
1246                         final String uri = DefaultLayoutParser.getAttributeValue(
1247                                 parser, DefaultLayoutParser.ATTR_URI);
1248                         intents.add(Intent.parseUri(uri, 0));
1249                     }
1250                 }
1251             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1252                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1253             } finally {
1254                 parser.close();
1255             }
1256             return intents;
1257         }
1258 
1259         public boolean matches(ActivityInfo activity, PackageManager pm) {
1260             for (Intent intent : mIntents) {
1261                 intent.setPackage(activity.packageName);
1262                 ResolveInfo info = pm.resolveActivity(intent, 0);
1263                 if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)
1264                         || info.activityInfo.name.equals(activity.targetActivity))) {
1265                     return true;
1266                 }
1267             }
1268             return false;
1269         }
1270     }
1271 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager.NameNotFoundException;
  29 import android.content.pm.PackageManager;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.drawable.Drawable;
  36 import android.os.ParcelFileDescriptor;
  37 import android.text.TextUtils;
  38 import android.util.Base64;
  39 import android.util.Log;
  40 import com.android.launcher3.LauncherSettings.Favorites;
  41 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  42 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  43 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  44 import com.android.launcher3.backup.BackupProtos.Favorite;
  45 import com.android.launcher3.backup.BackupProtos.Journal;
  46 import com.android.launcher3.backup.BackupProtos.Key;
  47 import com.android.launcher3.backup.BackupProtos.Resource;
  48 import com.android.launcher3.backup.BackupProtos.Screen;
  49 import com.android.launcher3.backup.BackupProtos.Widget;
  50 import com.android.launcher3.backup.BackupProtos;
  51 import com.android.launcher3.compat.UserHandleCompat;
  52 import com.android.launcher3.compat.UserManagerCompat;
  53 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  54 import com.google.protobuf.nano.MessageNano;
  55 import java.io.ByteArrayOutputStream;
  56 import java.io.FileInputStream;
  57 import java.io.FileOutputStream;
  58 import java.io.IOException;
  59 import java.net.URISyntaxException;
  60 import java.util.ArrayList;
  61 import java.util.Arrays;
  62 import java.util.HashSet;
  63 import java.util.zip.CRC32;
  64 import org.xmlpull.v1.XmlPullParser;
  65 import org.xmlpull.v1.XmlPullParserException;
  66 
  67 
  68 /**
  69  * Persist the launcher home state across calamities.
  70  */
  71 public class LauncherBackupHelper implements BackupHelper {
  72     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  73 
  74     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  75 
  76     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  77 
  78     private static final int BACKUP_VERSION = 2;
  79 
  80     private static final int MAX_JOURNAL_SIZE = 1000000;
  81 
  82     // Journal key is such that it is always smaller than any dynamically generated
  83     // key (any Base64 encoded string).
  84     // Journal key is such that it is always smaller than any dynamically generated
  85     // key (any Base64 encoded string).
  86     private static final String JOURNAL_KEY = &quot;#&quot;;
  87 
  88     /**
  89      * icons are large, dribble them out
  90      */
  91     private static final int MAX_ICONS_PER_PASS = 10;
  92 
  93     /**
  94      * widgets contain previews, which are very large, dribble them out
  95      */
  96     private static final int MAX_WIDGETS_PER_PASS = 5;
  97 
  98     private static final int IMAGE_COMPRESSION_QUALITY = 75;
  99 
 100     private static final Bitmap.CompressFormat IMAGE_FORMAT =
 101             android.graphics.Bitmap.CompressFormat.PNG;
 102 
 103     private static final String[] FAVORITE_PROJECTION = new java.lang.String[]{ Favorites._ID, // 0
 104     Favorites.MODIFIED, // 1
 105     Favorites.INTENT, // 2
 106     Favorites.APPWIDGET_PROVIDER// 3
 107     , Favorites.APPWIDGET_ID, // 4
 108     Favorites.CELLX, // 5
 109     Favorites.CELLY, // 6
 110     Favorites.CONTAINER, // 7
 111     Favorites.ICON, // 8
 112     Favorites.ICON_PACKAGE, // 9
 113     Favorites.ICON_RESOURCE, // 10
 114     Favorites.ICON_TYPE, // 11
 115     Favorites.ITEM_TYPE, // 12
 116     Favorites.SCREEN, // 13
 117     Favorites.SPANX, // 14
 118     Favorites.SPANY, // 15
 119     Favorites.TITLE, // 16
 120     Favorites.PROFILE_ID// 17
 121      };
 122 
 123     private static final int ID_INDEX = 0;
 124 
 125     private static final int ID_MODIFIED = 1;
 126 
 127     private static final int INTENT_INDEX = 2;
 128 
 129     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 130 
 131     private static final int APPWIDGET_ID_INDEX = 4;
 132 
 133     private static final int CELLX_INDEX = 5;
 134 
 135     private static final int CELLY_INDEX = 6;
 136 
 137     private static final int CONTAINER_INDEX = 7;
 138 
 139     private static final int ICON_INDEX = 8;
 140 
 141     private static final int ICON_PACKAGE_INDEX = 9;
 142 
 143     private static final int ICON_RESOURCE_INDEX = 10;
 144 
 145     private static final int ICON_TYPE_INDEX = 11;
 146 
 147     private static final int ITEM_TYPE_INDEX = 12;
 148 
 149     private static final int SCREEN_INDEX = 13;
 150 
 151     private static final int SPANX_INDEX = 14;
 152 
 153     private static final int SPANY_INDEX = 15;
 154 
 155     private static final int TITLE_INDEX = 16;
 156 
 157     private static final String[] SCREEN_PROJECTION = new java.lang.String[]{ WorkspaceScreens._ID, // 0
 158     WorkspaceScreens.MODIFIED, // 1
 159     WorkspaceScreens.SCREEN_RANK// 2
 160      };
 161 
 162     private static final int SCREEN_RANK_INDEX = 2;
 163 
 164     private final Context mContext;
 165 
 166     private final HashSet&lt;String&gt; mExistingKeys;
 167 
 168     private final ArrayList&lt;Key&gt; mKeys;
 169 
 170     private final ItemTypeMatcher[] mItemTypeMatchers;
 171 
 172     private final long mUserSerial;
 173 
 174     private IconCache mIconCache;
 175 
 176     private BackupManager mBackupManager;
 177 
 178     private byte[] mBuffer = new byte[512];
 179 
 180     private long mLastBackupRestoreTime;
 181 
 182     private boolean mBackupDataWasUpdated;
 183 
 184     private DeviceProfieData mCurrentProfile;
 185 
 186     boolean restoreSuccessful;
 187 
 188     int restoredBackupVersion = 1;
 189 
 190     public LauncherBackupHelper(Context context) {
 191         mContext = context;
 192         mExistingKeys = new HashSet&lt;String&gt;();
 193         mKeys = new ArrayList&lt;Key&gt;();
 194         restoreSuccessful = true;
 195         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 196         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 197         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 198     }
 199 
 200     private void dataChanged() {
 201         if (mBackupManager == null) {
 202             mBackupManager = new BackupManager(mContext);
 203         }
 204         mBackupManager.dataChanged();
 205     }
 206 
 207     private void applyJournal(Journal journal) {
 208         mLastBackupRestoreTime = journal.t;
 209         mExistingKeys.clear();
 210         if (journal.key != null) {
 211             for (Key key : journal.key) {
 212                 mExistingKeys.add(keyToBackupKey(key));
 213             }
 214         }
 215     }
 216 
 217     /**
 218      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 219      *
 220      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 221      *
 222      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 223      *
 224      * @param oldState notes from the last backup
 225      * @param data incremental key/value pairs to persist off-device
 226      * @param newState notes for the next backup
 227      */
 228     @Override
 229     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 230             ParcelFileDescriptor newState) {
 231         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 232 
 233         Journal in = readJournal(oldState);
 234         if (!launcherIsReady()) {
 235             // Perform backup later.
 236             writeJournal(newState, in);
 237             return;
 238         }
 239         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 240         mKeys.clear();
 241         applyJournal(in);
 242 
 243         // Record the time before performing backup so that entries edited while the backup
 244         // was going on, do not get missed in next backup.
 245         long newBackupTime = System.currentTimeMillis();
 246         mBackupDataWasUpdated = false;
 247         try {
 248             backupFavorites(data);
 249             backupScreens(data);
 250             backupIcons(data);
 251             backupWidgets(data);
 252 
 253             // Delete any key which still exist in the old backup, but is not valid anymore.
 254             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 255             for (Key key : mKeys) {
 256                 validKeys.add(keyToBackupKey(key));
 257             }
 258             mExistingKeys.removeAll(validKeys);
 259 
 260             // Delete anything left in the existing keys.
 261             for (String deleted: mExistingKeys) {
 262                 if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 263                 data.writeEntityHeader(deleted, -1);
 264                 mBackupDataWasUpdated = true;
 265             }
 266 
 267             mExistingKeys.clear();
 268             if (!mBackupDataWasUpdated) {
 269                 // Check if any metadata has changed
 270                 mBackupDataWasUpdated = (in.profile == null)
 271                         || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 272                             DeviceProfieData.toByteArray(getDeviceProfieData()))
 273                         || (in.backupVersion != BACKUP_VERSION)
 274                         || (in.appVersion != getAppVersion());
 275             }
 276 
 277             if (mBackupDataWasUpdated) {
 278                 mLastBackupRestoreTime = newBackupTime;
 279 
 280                 // We store the journal at two places.
 281                 //   1) Storing it in newState allows us to do partial backups by comparing old state
 282                 //   2) Storing it in backup data allows us to validate keys during restore
 283                 Journal state = getCurrentStateJournal();
 284                 writeRowToBackup(JOURNAL_KEY, state, data);
 285             } else {
 286                 if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 287             }
 288         } catch (IOException e) {
 289             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 290         }
 291 
 292         writeNewStateDescription(newState);
 293     }
 294 
 295     /**
 296      * @return true if the backup corresponding to oldstate can be successfully applied
 297      * to this device.
 298      */
 299     private boolean isBackupCompatible(Journal oldState) {
 300         DeviceProfieData currentProfile = getDeviceProfieData();
 301 
 302         DeviceProfieData oldProfile = oldState.profile;
 303 
 304         if (oldProfile == null || oldProfile.desktopCols == 0) {
 305             // Profile info is not valid, ignore the check.
 306             return true;
 307         }
 308 
 309         boolean isHotsetCompatible = false;
 310         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 311             isHotsetCompatible = true;
 312         }
 313         if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 314                 (currentProfile.allappsRank == oldProfile.allappsRank)) {
 315             isHotsetCompatible = true;
 316         }
 317 
 318         return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 319                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 320     }
 321 
 322     /**
 323      * Restore launcher configuration from the restored data stream.
 324      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 325      * backup, it should arrive first.
 326      *
 327      * @param data the key/value pair from the server
 328      */
 329     @Override
 330     public void restoreEntity(BackupDataInputStream data) {
 331         if (!restoreSuccessful) {
 332             return;
 333         }
 334         if (!initializeIconCache()) {
 335             // During restore we do not need an initialized instance of IconCache. We can create
 336             // a temporary icon cache here, as the process will be rebooted after restore
 337             // is complete.
 338             mIconCache = new IconCache(mContext);
 339         }
 340         int dataSize = data.size();
 341         if (mBuffer.length &lt; dataSize) {
 342             mBuffer = new byte[dataSize];
 343         }
 344         try {
 345             int bytesRead = data.read(mBuffer, 0, dataSize);
 346             if (DEBUG) {
 347                 Log.d(TAG, (((&quot;read &quot; + bytesRead) + &quot; of &quot;) + dataSize) + &quot; available&quot;);
 348             }
 349             String backupKey = data.getKey();
 350             if (JOURNAL_KEY.equals(backupKey)) {
 351                 if (VERBOSE) {
 352                     Log.v(TAG, &quot;Journal entry restored&quot;);
 353                 }
 354                 if (!mKeys.isEmpty()) {
 355                     // We received the journal key after a restore key.
 356                     Log.wtf(TAG, (keyToBackupKey(mKeys.get(0)) + &quot; received after &quot;) + JOURNAL_KEY);
 357                     restoreSuccessful = false;
 358                     return;
 359                 }
 360                 Journal journal = new Journal();
 361                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 362                 applyJournal(journal);
 363                 restoreSuccessful = isBackupCompatible(journal);
 364                 restoredBackupVersion = journal.backupVersion;
 365                 return;
 366             }
 367             if ((!mExistingKeys.isEmpty()) &amp;&amp; (!mExistingKeys.contains(backupKey))) {
 368                 if (DEBUG) {
 369                     Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 370                 }
 371                 return;
 372             }
 373             Key key = backupKeyToKey(backupKey);
 374             mKeys.add(key);
 375             switch (key.type) {
 376                 case Key.FAVORITE :
 377                     restoreFavorite(key, mBuffer, dataSize);
 378                     break;
 379                 case Key.SCREEN :
 380                     restoreScreen(key, mBuffer, dataSize);
 381                     break;
 382                 case Key.ICON :
 383                     restoreIcon(key, mBuffer, dataSize);
 384                     break;
 385                 case Key.WIDGET :
 386                     restoreWidget(key, mBuffer, dataSize);
 387                     break;
 388                 default :
 389                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 390                     mKeys.remove(key);
 391                     break;
 392             }
 393         } catch (IOException e) {
 394             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 395         }
 396     }
 397 
 398     /**
 399      * Record the restore state for the next backup.
 400      *
 401      * @param newState notes about the backup state after restore.
 402      */
 403     @Override
 404     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 405         writeJournal(newState, getCurrentStateJournal());
 406     }
 407 
 408     private Journal getCurrentStateJournal() {
 409         Journal journal = new Journal();
 410         journal.t = mLastBackupRestoreTime;
 411         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 412         journal.appVersion = getAppVersion();
 413         journal.backupVersion = BACKUP_VERSION;
 414         journal.profile = getDeviceProfieData();
 415         return journal;
 416     }
 417 
 418     private int getAppVersion() {
 419         try {
 420             return mContext.getPackageManager()
 421                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 422         } catch (NameNotFoundException e) {
 423             return 0;
 424         }
 425     }
 426 
 427     /**
 428      * @return the current device profile information.
 429      */
 430     private DeviceProfieData getDeviceProfieData() {
 431         if (mCurrentProfile != null) {
 432             return mCurrentProfile;
 433         }
 434         final Context applicationContext = mContext.getApplicationContext();
 435         DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)
 436                 .getDeviceProfile();
 437 
 438         mCurrentProfile = new DeviceProfieData();
 439         mCurrentProfile.desktopRows = profile.numRows;
 440         mCurrentProfile.desktopCols = profile.numColumns;
 441         mCurrentProfile.hotseatCount = profile.numHotseatIcons;
 442         mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;
 443         return mCurrentProfile;
 444     }
 445 
 446     /**
 447      * Write all modified favorites to the data stream.
 448      *
 449      * @param data output stream for key/value pairs
 450      * @throws IOException
 451      */
 452     private void backupFavorites(BackupDataOutput data) throws IOException {
 453         // persist things that have changed since the last backup
 454         ContentResolver cr = mContext.getContentResolver();
 455         // Don&#x27;t backup apps in other profiles for now.
 456         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 457                 getUserSelectionArg(), null, null);
 458         try {
 459             cursor.moveToPosition(-1);
 460             while(cursor.moveToNext()) {
 461                 final long id = cursor.getLong(ID_INDEX);
 462                 final long updateTime = cursor.getLong(ID_MODIFIED);
 463                 Key key = getKey(Key.FAVORITE, id);
 464                 mKeys.add(key);
 465                 final String backupKey = keyToBackupKey(key);
 466                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 467                     writeRowToBackup(key, packFavorite(cursor), data);
 468                 } else {
 469                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 470                 }
 471             }
 472         } finally {
 473             cursor.close();
 474         }
 475     }
 476 
 477     /**
 478      * Read a favorite from the stream.
 479      *
 480      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 481      *
 482      * @param key identifier for the row
 483      * @param buffer the serialized proto from the stream, may be larger than dataSize
 484      * @param dataSize the size of the proto from the stream
 485      */
 486     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 487         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 488         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 489                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 490 
 491         ContentResolver cr = mContext.getContentResolver();
 492         ContentValues values = unpackFavorite(buffer, dataSize);
 493         cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 494     }
 495 
 496     /**
 497      * Write all modified screens to the data stream.
 498      *
 499      * @param data output stream for key/value pairs
 500      * @throws IOException
 501      */
 502     private void backupScreens(BackupDataOutput data) throws IOException {
 503         // persist things that have changed since the last backup
 504         ContentResolver cr = mContext.getContentResolver();
 505         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 506                 null, null, null);
 507         try {
 508             cursor.moveToPosition(-1);
 509             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 510             while(cursor.moveToNext()) {
 511                 final long id = cursor.getLong(ID_INDEX);
 512                 final long updateTime = cursor.getLong(ID_MODIFIED);
 513                 Key key = getKey(Key.SCREEN, id);
 514                 mKeys.add(key);
 515                 final String backupKey = keyToBackupKey(key);
 516                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 517                     writeRowToBackup(key, packScreen(cursor), data);
 518                 } else {
 519                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 520                 }
 521             }
 522         } finally {
 523             cursor.close();
 524         }
 525     }
 526 
 527     /**
 528      * Read a screen from the stream.
 529      *
 530      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 531      *
 532      * @param key identifier for the row
 533      * @param buffer the serialized proto from the stream, may be larger than dataSize
 534      * @param dataSize the size of the proto from the stream
 535      */
 536     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 537         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 538         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 539                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 540 
 541         ContentResolver cr = mContext.getContentResolver();
 542         ContentValues values = unpackScreen(buffer, dataSize);
 543         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 544     }
 545 
 546     /**
 547      * Write all the static icon resources we need to render placeholders
 548      * for a package that is not installed.
 549      *
 550      * @param data output stream for key/value pairs
 551      */
 552     private void backupIcons(BackupDataOutput data) throws IOException {
 553         // persist icons that haven&#x27;t been persisted yet
 554         if (!initializeIconCache()) {
 555             dataChanged(); // try again later
 556             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 557             return;
 558         }
 559         final ContentResolver cr = mContext.getContentResolver();
 560         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 561         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 562         int backupUpIconCount = 0;
 563 
 564         // Don&#x27;t backup apps in other profiles for now.
 565         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 566                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 567                 getUserSelectionArg();
 568         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 569                 where, null, null);
 570         try {
 571             cursor.moveToPosition(-1);
 572             while(cursor.moveToNext()) {
 573                 final long id = cursor.getLong(ID_INDEX);
 574                 final String intentDescription = cursor.getString(INTENT_INDEX);
 575                 try {
 576                     Intent intent = Intent.parseUri(intentDescription, 0);
 577                     ComponentName cn = intent.getComponent();
 578                     Key key = null;
 579                     String backupKey = null;
 580                     if (cn != null) {
 581                         key = getKey(Key.ICON, cn.flattenToShortString());
 582                         backupKey = keyToBackupKey(key);
 583                     } else {
 584                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 585                     }
 586                     if (mExistingKeys.contains(backupKey)) {
 587                         if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 588 
 589                         // remember that we already backed this up previously
 590                         mKeys.add(key);
 591                     } else if (backupKey != null) {
 592                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 593                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 594                             if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 595                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 596                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 597                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 598                                 mKeys.add(key);
 599                                 backupUpIconCount ++;
 600                             }
 601                         } else {
 602                             if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 603                             // too many icons for this pass, request another.
 604                             dataChanged();
 605                         }
 606                     }
 607                 } catch (URISyntaxException e) {
 608                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 609                 } catch (IOException e) {
 610                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 611                 }
 612 
 613             }
 614         } finally {
 615             cursor.close();
 616         }
 617     }
 618 
 619     /**
 620      * Read an icon from the stream.
 621      *
 622      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 623      *
 624      * @param key identifier for the row
 625      * @param buffer the serialized proto from the stream, may be larger than dataSize
 626      * @param dataSize the size of the proto from the stream
 627      */
 628     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 629         if (VERBOSE) {
 630             Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 631         }
 632         if (DEBUG) {
<abbr title=" 633             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 633             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, ðŸ”µ</abbr>
 634         }
 635         Resource res = unpackProto(new Resource(), buffer, dataSize);
 636         if (DEBUG) {
 637             Log.d(TAG, (&quot;unpacked &quot; + res.dpi) + &quot; dpi icon&quot;);
 638         }
 639         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 640         if (icon == null) {
 641             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 642         }
 643         if (VERBOSE) {
 644             Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 645         }
 646                 /* label */
<abbr title=" 647         mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi, &quot;&quot;, mUserSerial);"> 647         mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi, &quot;&quot;, mUserSeriaðŸ”µ</abbr>
 648     }
 649 
 650     /**
 651      * Write all the static widget resources we need to render placeholders
 652      * for a package that is not installed.
 653      *
 654      * @param data output stream for key/value pairs
 655      * @throws IOException
 656      */
 657     private void backupWidgets(BackupDataOutput data) throws IOException {
 658         // persist static widget info that hasn&#x27;t been persisted yet
 659         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 660         if ((appState == null) || (!initializeIconCache())) {
 661             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 662             return;
 663         }
 664         final ContentResolver cr = mContext.getContentResolver();
 665         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 666         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 667         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 668         if (DEBUG) {
 669             Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 670         }
 671         int backupWidgetCount = 0;
<abbr title=" 672         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUserSelectionArg();"> 672         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUseðŸ”µ</abbr>
 673         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 674         try {
 675             cursor.moveToPosition(-1);
 676             while (cursor.moveToNext()) {
 677                 final long id = cursor.getLong(ID_INDEX);
 678                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 679                 final int spanX = cursor.getInt(SPANX_INDEX);
 680                 final int spanY = cursor.getInt(SPANY_INDEX);
 681                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 682                 Key key = null;
 683                 String backupKey = null;
 684                 if (provider != null) {
 685                     key = getKey(Key.WIDGET, providerName);
 686                     backupKey = keyToBackupKey(key);
 687                 } else {
 688                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 689                 }
 690                 if (mExistingKeys.contains(backupKey)) {
 691                     if (DEBUG) {
 692                         Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 693                     }
 694                     // remember that we already backed this up previously
 695                     mKeys.add(key);
 696                 } else if (backupKey != null) {
 697                     if (DEBUG) {
 698                         Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 699                     }
 700                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 701                         if (DEBUG) {
 702                             Log.d(TAG, &quot;saving widget &quot; + backupKey);
 703                         }
<abbr title=" 704                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHeightPx);"> 704                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHeiðŸ”µ</abbr>
 705                         UserHandleCompat user = UserHandleCompat.myUserHandle();
<abbr title=" 706                         writeRowToBackup(key, packWidget(dpi, previewLoader, mIconCache, provider, user), data);"> 706                         writeRowToBackup(key, packWidget(dpi, previewLoader, mIconCache, provider, user),ðŸ”µ</abbr>
 707                         mKeys.add(key);
 708                         backupWidgetCount++;
 709                     } else {
 710                         if (VERBOSE) {
 711                             Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 712                         }
 713                         // too many widgets for this pass, request another.
 714                         dataChanged();
 715                     }
 716                 }
 717             }
 718         } finally {
 719             cursor.close();
 720         }
 721     }
 722 
 723     /**
 724      * Read a widget from the stream.
 725      *
 726      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 727      *
 728      * @param key identifier for the row
 729      * @param buffer the serialized proto from the stream, may be larger than dataSize
 730      * @param dataSize the size of the proto from the stream
 731      */
 732     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 733         if (VERBOSE) {
 734             Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 735         }
 736         if (DEBUG) {
<abbr title=" 737             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 737             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, ðŸ”µ</abbr>
 738         }
 739         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 740         if (DEBUG) {
 741             Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 742         }
 743         if (widget.icon.data != null) {
 744             Bitmap icon = BitmapFactory.decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 745             if (icon == null) {
 746                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 747             } else {
<abbr title=" 748                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider), icon, widget.icon.dpi, widget.label, mUserSerial);"> 748                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider), icon, widget.iðŸ”µ</abbr>
 749             }
 750         }
 751         // future site of widget table mutation
 752     }
 753 
 754     /** create a new key, with an integer ID.
 755      *
 756      * &lt;P&gt; Keys contain their own checksum instead of using
 757      * the heavy-weight CheckedMessage wrapper.
 758      */
 759     private Key getKey(int type, long id) {
 760         Key key = new Key();
 761         key.type = type;
 762         key.id = id;
 763         key.checksum = checkKey(key);
 764         return key;
 765     }
 766 
 767     /** create a new key for a named object.
 768      *
 769      * &lt;P&gt; Keys contain their own checksum instead of using
 770      * the heavy-weight CheckedMessage wrapper.
 771      */
 772     private Key getKey(int type, String name) {
 773         Key key = new Key();
 774         key.type = type;
 775         key.name = name;
 776         key.checksum = checkKey(key);
 777         return key;
 778     }
 779 
 780     /** keys need to be strings, serialize and encode. */
 781     private String keyToBackupKey(Key key) {
 782         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 783     }
 784 
 785     /** keys need to be strings, decode and parse. */
 786     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 787         try {
 788             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 789             if (key.checksum != checkKey(key)) {
 790                 key = null;
 791                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 792             }
 793             return key;
 794         } catch (InvalidProtocolBufferNanoException e) {
 795             throw new InvalidBackupException(e);
 796         } catch (IllegalArgumentException e) {
 797             throw new InvalidBackupException(e);
 798         }
 799     }
 800 
 801     /** Compute the checksum over the important bits of a key. */
 802     private long checkKey(Key key) {
 803         CRC32 checksum = new CRC32();
 804         checksum.update(key.type);
 805         checksum.update((int) (key.id &amp; 0xffff));
 806         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 807         if (!TextUtils.isEmpty(key.name)) {
 808             checksum.update(key.name.getBytes());
 809         }
 810         return checksum.getValue();
 811     }
 812 
 813     /**
 814      * @return true if its an hotseat item, that can be replaced during restore.
 815      * TODO: Extend check for folders in hotseat.
 816      */
 817     private boolean isReplaceableHotseatItem(Favorite favorite) {
 818         return favorite.container == Favorites.CONTAINER_HOTSEAT
 819                 &amp;&amp; favorite.intent != null
 820                 &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION
 821                 || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);
 822     }
 823 
 824     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 825     private Favorite packFavorite(Cursor c) {
 826         Favorite favorite = new Favorite();
 827         favorite.id = c.getLong(ID_INDEX);
 828         favorite.screen = c.getInt(SCREEN_INDEX);
 829         favorite.container = c.getInt(CONTAINER_INDEX);
 830         favorite.cellX = c.getInt(CELLX_INDEX);
 831         favorite.cellY = c.getInt(CELLY_INDEX);
 832         favorite.spanX = c.getInt(SPANX_INDEX);
 833         favorite.spanY = c.getInt(SPANY_INDEX);
 834         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 835         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 836             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 837             if (!TextUtils.isEmpty(iconPackage)) {
 838                 favorite.iconPackage = iconPackage;
 839             }
 840             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 841             if (!TextUtils.isEmpty(iconResource)) {
 842                 favorite.iconResource = iconResource;
 843             }
 844         }
 845         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 846             byte[] blob = c.getBlob(ICON_INDEX);
 847             if ((blob != null) &amp;&amp; (blob.length &gt; 0)) {
 848                 favorite.icon = blob;
 849             }
 850         }
 851         String title = c.getString(TITLE_INDEX);
 852         if (!TextUtils.isEmpty(title)) {
 853             favorite.title = title;
 854         }
 855         String intentDescription = c.getString(INTENT_INDEX);
 856         Intent intent = null;
 857         if (!TextUtils.isEmpty(intentDescription)) {
 858             try {
 859                 intent = Intent.parseUri(intentDescription, 0);
 860                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 861                 favorite.intent = intent.toUri(0);
 862             } catch (URISyntaxException e) {
 863                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 864             }
 865         }
 866         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 867         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 868             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 869             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 870             if (!TextUtils.isEmpty(appWidgetProvider)) {
 871                 favorite.appWidgetProvider = appWidgetProvider;
 872             }
 873         }
 874         if (isReplaceableHotseatItem(favorite)) {
 875             if ((intent != null) &amp;&amp; (intent.getComponent() != null)) {
 876                 PackageManager pm = mContext.getPackageManager();
 877                 ActivityInfo activity = null;
 878                 try {
 879                     activity = pm.getActivityInfo(intent.getComponent(), 0);
 880                 } catch (NameNotFoundException e) {
 881                     Log.e(TAG, &quot;Target not found&quot;, e);
 882                 }
 883                 if (activity == null) {
 884                     return favorite;
 885                 }
 886                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
 887                     if (mItemTypeMatchers[i] == null) {
<abbr title=" 888                         mItemTypeMatchers[i] = new ItemTypeMatcher(CommonAppTypeParser.getResourceForItemType(i));"> 888                         mItemTypeMatchers[i] = new ItemTypeMatcher(CommonAppTypeParser.getResourceForItemðŸ”µ</abbr>
 889                     }
 890                     if (mItemTypeMatchers[i].matches(activity, pm)) {
 891                         favorite.targetType = i;
 892                         break;
 893                     }
 894                 }
 895             }
 896         }
 897         return favorite;
 898     }
 899 
 900     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 901     private ContentValues unpackFavorite(byte[] buffer, int dataSize) throws IOException {
 902         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
 903         ContentValues values = new ContentValues();
 904         values.put(Favorites._ID, favorite.id);
 905         values.put(Favorites.SCREEN, favorite.screen);
 906         values.put(Favorites.CONTAINER, favorite.container);
 907         values.put(Favorites.CELLX, favorite.cellX);
 908         values.put(Favorites.CELLY, favorite.cellY);
 909         values.put(Favorites.SPANX, favorite.spanX);
 910         values.put(Favorites.SPANY, favorite.spanY);
 911         values.put(Favorites.ICON_TYPE, favorite.iconType);
 912         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 913             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 914             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 915         }
 916         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 917             values.put(Favorites.ICON, favorite.icon);
 918         }
 919         if (!TextUtils.isEmpty(favorite.title)) {
 920             values.put(Favorites.TITLE, favorite.title);
 921         } else {
 922             values.put(Favorites.TITLE, &quot;&quot;);
 923         }
 924         if (!TextUtils.isEmpty(favorite.intent)) {
 925             values.put(Favorites.INTENT, favorite.intent);
 926         }
 927         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 928         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
<abbr title=" 929         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);"> 929         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandðŸ”µ</abbr>
 930         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 931         DeviceProfieData currentProfile = getDeviceProfieData();
 932         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 933             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 934                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 935             }
 936             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
<abbr title=" 937             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) | LauncherAppWidgetInfo.FLAG_UI_NOT_READY);"> 937             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | LaðŸ”µ</abbr>
 938             // Verify placement
<abbr title=" 939             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols) || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {"> 939             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols) || ((favorite.cellY + faðŸ”µ</abbr>
 940                 restoreSuccessful = false;
 941                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 942             }
 943         } else {
 944             // Check if it is an hotseat item, that can be replaced.
<abbr title=" 945             if ((isReplaceableHotseatItem(favorite) &amp;&amp; (favorite.targetType != Favorite.TARGET_NONE)) &amp;&amp; (favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT)) {"> 945             if ((isReplaceableHotseatItem(favorite) &amp;&amp; (favorite.targetType != Favorite.TARGET_NONE)) &amp;&amp; ðŸ”µ</abbr>
 946                 Log.e(TAG, &quot;Added item type flag&quot;);
<abbr title=" 947                 values.put(LauncherSettings.Favorites.RESTORED, 1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));"> 947                 values.put(LauncherSettings.Favorites.RESTORED, 1 | CommonAppTypeParser.encodeItemTypeToFðŸ”µ</abbr>
 948             } else {
 949                 // Let LauncherModel know we&#x27;ve been here.
 950                 values.put(LauncherSettings.Favorites.RESTORED, 1);
 951             }
 952             // Verify placement
 953             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
<abbr title=" 954                 if ((favorite.screen &gt;= currentProfile.hotseatCount) || (favorite.screen == currentProfile.allappsRank)) {"> 954                 if ((favorite.screen &gt;= currentProfile.hotseatCount) || (favorite.screen == currentProfilðŸ”µ</abbr>
 955                     restoreSuccessful = false;
 956                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 957                 }
<abbr title=" 958             } else if ((favorite.cellX &gt;= currentProfile.desktopCols) || (favorite.cellY &gt;= currentProfile.desktopRows)) {"> 958             } else if ((favorite.cellX &gt;= currentProfile.desktopCols) || (favorite.cellY &gt;= currentProfilðŸ”µ</abbr>
 959                 restoreSuccessful = false;
 960                 throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 961             }
 962         }
 963         return values;
 964     }
 965 
 966     /** Serialize a Screen for persistence, including a checksum wrapper. */
 967     private Screen packScreen(Cursor c) {
 968         Screen screen = new Screen();
 969         screen.id = c.getLong(ID_INDEX);
 970         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 971         return screen;
 972     }
 973 
 974     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 975     private ContentValues unpackScreen(byte[] buffer, int dataSize)
 976             throws InvalidProtocolBufferNanoException {
 977         Screen screen = unpackProto(new Screen(), buffer, dataSize);
 978         ContentValues values = new ContentValues();
 979         values.put(WorkspaceScreens._ID, screen.id);
 980         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 981         return values;
 982     }
 983 
 984     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 985     private Resource packIcon(int dpi, Bitmap icon) {
 986         Resource res = new Resource();
 987         res.dpi = dpi;
 988         ByteArrayOutputStream os = new ByteArrayOutputStream();
 989         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 990             res.data = os.toByteArray();
 991         }
 992         return res;
 993     }
 994 
 995     /** Serialize a widget for persistence, including a checksum wrapper. */
<abbr title=" 996     private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache, ComponentName provider, UserHandleCompat user) {"> 996     private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache, ComponentNðŸ”µ</abbr>
<abbr title=" 997         final LauncherAppWidgetProviderInfo info = LauncherModel.getProviderInfo(mContext, provider, user);"> 997         final LauncherAppWidgetProviderInfo info = LauncherModel.getProviderInfo(mContext, provider, userðŸ”µ</abbr>
 998         Widget widget = new Widget();
 999         widget.provider = provider.flattenToShortString();
1000         widget.label = info.label;
1001         widget.configure = info.configure != null;
1002         if (info.icon != 0) {
1003             widget.icon = new Resource();
1004             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
1005             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
1006             ByteArrayOutputStream os = new ByteArrayOutputStream();
1007             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1008                 widget.icon.data = os.toByteArray();
1009                 widget.icon.dpi = dpi;
1010             }
1011         }
1012         if (info.previewImage != 0) {
1013             widget.preview = new Resource();
1014             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
1015             ByteArrayOutputStream os = new ByteArrayOutputStream();
1016             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1017                 widget.preview.data = os.toByteArray();
1018                 widget.preview.dpi = dpi;
1019             }
1020         }
1021         return widget;
1022     }
1023 
1024     /**
1025      * Deserialize a proto after verifying checksum wrapper.
1026      */
1027     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1028             throws InvalidProtocolBufferNanoException {
1029         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1030         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1031         return proto;
1032     }
1033 
1034     /**
1035      * Read the old journal from the input file.
1036      *
1037      * In the event of any error, just pretend we didn&#x27;t have a journal,
1038      * in that case, do a full backup.
1039      *
1040      * @param oldState the read-0only file descriptor pointing to the old journal
1041      * @return a Journal protocol buffer
1042      */
1043     private Journal readJournal(ParcelFileDescriptor oldState) {
1044         Journal journal = new Journal();
1045         if (oldState == null) {
1046             return journal;
1047         }
1048         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1049         try {
1050             int availableBytes = inStream.available();
1051             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1052             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1053                 byte[] buffer = new byte[availableBytes];
1054                 int bytesRead = 0;
1055                 boolean valid = false;
1056                 InvalidProtocolBufferNanoException lastProtoException = null;
1057                 while (availableBytes &gt; 0) {
1058                     try {
1059                         // OMG what are you doing? This is crazy inefficient!
1060                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1061                         // However, we don&#x27;t know how many bytes to expect (oops).
1062                         // So we have to step through *slowly*, watching for the end.
1063                         int result = inStream.read(buffer, bytesRead, 1);
1064                         if (result &gt; 0) {
1065                             availableBytes -= result;
1066                             bytesRead += result;
1067                         } else {
1068                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1069                             // stop reading and see what there is to parse
1070                             availableBytes = 0;
1071                         }
1072                     } catch (IOException e) {
1073                         buffer = null;
1074                         availableBytes = 0;
1075                     }
1076 
1077                     // check the buffer to see if we have a valid journal
1078                     try {
1079                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1080                         // if we are here, then we have read a valid, checksum-verified journal
1081                         valid = true;
1082                         availableBytes = 0;
1083                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1084                     } catch (InvalidProtocolBufferNanoException e) {
1085                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1086                         lastProtoException = e;
1087                         journal.clear();
1088                     }
1089                 }
1090                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1091                 if (!valid) {
1092                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1093                 }
1094             }
1095         } catch (IOException e) {
1096             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1097         } finally {
1098             try {
1099                 inStream.close();
1100             } catch (IOException e) {
1101                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1102             }
1103         }
1104         return journal;
1105     }
1106 
1107     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1108             throws IOException {
1109         writeRowToBackup(keyToBackupKey(key), proto, data);
1110     }
1111 
1112     private void writeRowToBackup(String backupKey, MessageNano proto,
1113             BackupDataOutput data) throws IOException {
1114         byte[] blob = writeCheckedBytes(proto);
1115         data.writeEntityHeader(backupKey, blob.length);
1116         data.writeEntityData(blob, blob.length);
1117         mBackupDataWasUpdated = true;
1118         if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1119     }
1120 
1121     /**
1122      * Write the new journal to the output file.
1123      *
1124      * In the event of any error, just pretend we didn&#x27;t have a journal,
1125      * in that case, do a full backup.
1126 
1127      * @param newState the write-only file descriptor pointing to the new journal
1128      * @param journal a Journal protocol buffer
1129      */
1130     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1131         FileOutputStream outStream = null;
1132         try {
1133             outStream = new FileOutputStream(newState.getFileDescriptor());
1134             final byte[] journalBytes = writeCheckedBytes(journal);
1135             outStream.write(journalBytes);
1136             outStream.close();
1137             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1138         } catch (IOException e) {
1139             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1140         }
1141     }
1142 
1143     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1144     private byte[] writeCheckedBytes(MessageNano proto) {
1145         CheckedMessage wrapper = new CheckedMessage();
1146         wrapper.payload = MessageNano.toByteArray(proto);
1147         CRC32 checksum = new CRC32();
1148         checksum.update(wrapper.payload);
1149         wrapper.checksum = checksum.getValue();
1150         return MessageNano.toByteArray(wrapper);
1151     }
1152 
1153     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1154     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1155             throws InvalidProtocolBufferNanoException {
1156         CheckedMessage wrapper = new CheckedMessage();
1157         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1158         CRC32 checksum = new CRC32();
1159         checksum.update(wrapper.payload);
1160         if (wrapper.checksum != checksum.getValue()) {
1161             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1162         }
1163         return wrapper.payload;
1164     }
1165 
1166     private boolean initializeIconCache() {
1167         if (mIconCache != null) {
1168             return true;
1169         }
1170         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1171         if (appState == null) {
1172             if (DEBUG) {
1173                 Throwable stackTrace = new Throwable();
1174                 stackTrace.fillInStackTrace();
1175                 Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1176             }
1177             return false;
1178         }
1179         mIconCache = appState.getIconCache();
1180         return mIconCache != null;
1181     }
1182 
1183     /**
1184      * @return true if the launcher is in a state to support backup
1185      */
1186     private boolean launcherIsReady() {
1187         ContentResolver cr = mContext.getContentResolver();
1188         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1189         if (cursor == null) {
1190             // launcher data has been wiped, do nothing
1191             return false;
1192         }
1193         cursor.close();
1194 
1195         if (!initializeIconCache()) {
1196             // launcher services are unavailable, try again later
1197             dataChanged();
1198             return false;
1199         }
1200 
1201         return true;
1202     }
1203 
1204     private String getUserSelectionArg() {
1205         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1206                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1207     }
1208 
1209     private class InvalidBackupException extends IOException {
1210         private static final long serialVersionUID = 8931456637211665082L;
1211 
1212         private InvalidBackupException(Throwable cause) {
1213             super(cause);
1214         }
1215 
1216         public InvalidBackupException(String reason) {
1217             super(reason);
1218         }
1219     }
1220 
1221     /**
1222      * A class to check if an activity can handle one of the intents from a list of
1223      * predefined intents.
1224      */
1225     private class ItemTypeMatcher {
1226         private final ArrayList&lt;Intent&gt; mIntents;
1227 
1228         ItemTypeMatcher(int xml_res) {
1229             mIntents = (xml_res == 0) ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1230         }
1231 
1232         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1233             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1234             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1235             try {
1236                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1237                 final int depth = parser.getDepth();
1238                 int type;
<abbr title="1239                 while ((((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; depth)) &amp;&amp; (type != XmlPullParser.END_DOCUMENT)) {">1239                 while ((((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; depth))ðŸ”µ</abbr>
1240                     if (type != XmlPullParser.START_TAG) {
1241                         continue;
1242                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
<abbr title="1243                         final String uri = DefaultLayoutParser.getAttributeValue(parser, DefaultLayoutParser.ATTR_URI);">1243                         final String uri = DefaultLayoutParser.getAttributeValue(parser, DefaultLayoutParðŸ”µ</abbr>
1244                         intents.add(Intent.parseUri(uri, 0));
1245                     }
1246                 }
1247             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1248                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1249             } finally {
1250                 parser.close();
1251             }
1252             return intents;
1253         }
1254 
1255         public boolean matches(ActivityInfo activity, PackageManager pm) {
1256             for (Intent intent : mIntents) {
1257                 intent.setPackage(activity.packageName);
1258                 ResolveInfo info = pm.resolveActivity(intent, 0);
<abbr title="1259                 if ((info != null) &amp;&amp; (info.activityInfo.name.equals(activity.name) || info.activityInfo.name.equals(activity.targetActivity))) {">1259                 if ((info != null) &amp;&amp; (info.activityInfo.name.equals(activity.name) || info.activityInfo.ðŸ”µ</abbr>
1260                     return true;
1261                 }
1262             }
1263             return false;
1264         }
1265     }
1266 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import android.app.backup.BackupDataInputStream;
  19  import android.app.backup.BackupDataOutput;
  20  import android.app.backup.BackupHelper;
  21  import android.app.backup.BackupManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import android.appwidget.AppWidgetProviderInfo;</span>
  23  import android.content.ComponentName;
  24  import android.content.ContentResolver;
  25  import android.content.ContentValues;
  26  import android.content.Context;
  27  import android.content.Intent;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import android.content.pm.ActivityInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import android.content.pm.PackageManager;</span>
  30  import android.content.pm.PackageManager.NameNotFoundException;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import android.content.pm.ResolveInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import android.content.res.XmlResourceParser;</span>
  33  import android.database.Cursor;
  34  import android.graphics.Bitmap;
  35  import android.graphics.BitmapFactory;
  36  import android.graphics.drawable.Drawable;
  37  import android.os.ParcelFileDescriptor;
  38  import android.text.TextUtils;
  39  import android.util.Base64;
  40  import android.util.Log;
  41  
  42  import com.android.launcher3.LauncherSettings.Favorites;
  43  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  44  import com.android.launcher3.backup.BackupProtos;
  45  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  46  import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  47  import com.android.launcher3.backup.BackupProtos.Favorite;
  48  import com.android.launcher3.backup.BackupProtos.Journal;
  49  import com.android.launcher3.backup.BackupProtos.Key;
  50  import com.android.launcher3.backup.BackupProtos.Resource;
  51  import com.android.launcher3.backup.BackupProtos.Screen;
  52  import com.android.launcher3.backup.BackupProtos.Widget;
  53  import com.android.launcher3.compat.UserHandleCompat;
  54  import com.android.launcher3.compat.UserManagerCompat;
  55  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  56  import com.google.protobuf.nano.MessageNano;
  57  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +import org.xmlpull.v1.XmlPullParser;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +import org.xmlpull.v1.XmlPullParserException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +</span>
  61  import java.io.ByteArrayOutputStream;
  62  import java.io.FileInputStream;
  63  import java.io.FileOutputStream;
  64  import java.io.IOException;
  65  import java.net.URISyntaxException;
  66  import java.util.ArrayList;
  67  import java.util.Arrays;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -import java.util.HashMap;</span>
  69  import java.util.HashSet;
  70  import java.util.zip.CRC32;
  71  
  72  /**
  73   * Persist the launcher home state across calamities.
  74   */
  75  public class LauncherBackupHelper implements BackupHelper {
  76      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  77      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  78      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  79  
  80      private static final int BACKUP_VERSION = 2;
  81      private static final int MAX_JOURNAL_SIZE = 1000000;
  82  
  83      // Journal key is such that it is always smaller than any dynamically generated
  84      // key (any Base64 encoded string).
  85      private static final String JOURNAL_KEY = &quot;#&quot;;
  86  
  87      /** icons are large, dribble them out */
  88      private static final int MAX_ICONS_PER_PASS = 10;
  89  
  90      /** widgets contain previews, which are very large, dribble them out */
  91      private static final int MAX_WIDGETS_PER_PASS = 5;
  92  
  93      private static final int IMAGE_COMPRESSION_QUALITY = 75;
  94  
  95      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  96              android.graphics.Bitmap.CompressFormat.PNG;
  97  
  98      private static final String[] FAVORITE_PROJECTION = {
  99          Favorites._ID,                     // 0
 100          Favorites.MODIFIED,                // 1
 101          Favorites.INTENT,                  // 2
 102          Favorites.APPWIDGET_PROVIDER,      // 3
 103          Favorites.APPWIDGET_ID,            // 4
 104          Favorites.CELLX,                   // 5
 105          Favorites.CELLY,                   // 6
 106          Favorites.CONTAINER,               // 7
 107          Favorites.ICON,                    // 8
 108          Favorites.ICON_PACKAGE,            // 9
 109          Favorites.ICON_RESOURCE,           // 10
 110          Favorites.ICON_TYPE,               // 11
 111          Favorites.ITEM_TYPE,               // 12
 112          Favorites.SCREEN,                  // 13
 113          Favorites.SPANX,                   // 14
 114          Favorites.SPANY,                   // 15
 115          Favorites.TITLE,                   // 16
 116          Favorites.PROFILE_ID,              // 17
 117      };
 118  
 119      private static final int ID_INDEX = 0;
 120      private static final int ID_MODIFIED = 1;
 121      private static final int INTENT_INDEX = 2;
 122      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 123      private static final int APPWIDGET_ID_INDEX = 4;
 124      private static final int CELLX_INDEX = 5;
 125      private static final int CELLY_INDEX = 6;
 126      private static final int CONTAINER_INDEX = 7;
 127      private static final int ICON_INDEX = 8;
 128      private static final int ICON_PACKAGE_INDEX = 9;
 129      private static final int ICON_RESOURCE_INDEX = 10;
 130      private static final int ICON_TYPE_INDEX = 11;
 131      private static final int ITEM_TYPE_INDEX = 12;
 132      private static final int SCREEN_INDEX = 13;
 133      private static final int SPANX_INDEX = 14;
 134      private static final int SPANY_INDEX = 15;
 135      private static final int TITLE_INDEX = 16;
 136  
 137      private static final String[] SCREEN_PROJECTION = {
 138          WorkspaceScreens._ID,              // 0
 139          WorkspaceScreens.MODIFIED,         // 1
 140          WorkspaceScreens.SCREEN_RANK       // 2
 141      };
 142  
 143      private static final int SCREEN_RANK_INDEX = 2;
 144  
 145      private final Context mContext;
 146      private final HashSet&lt;String&gt; mExistingKeys;
 147      private final ArrayList&lt;Key&gt; mKeys;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +    private final ItemTypeMatcher[] mItemTypeMatchers;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +    private final long mUserSerial;</span>
 150  
 151      private IconCache mIconCache;
 152      private BackupManager mBackupManager;
 153      private byte[] mBuffer = new byte[512];
 154      private long mLastBackupRestoreTime;
 155      private boolean mBackupDataWasUpdated;
 156  
 157      private DeviceProfieData mCurrentProfile;
 158      boolean restoreSuccessful;
 159      int restoredBackupVersion = 1;
 160  
 161      public LauncherBackupHelper(Context context) {
 162          mContext = context;
 163          mExistingKeys = new HashSet&lt;String&gt;();
 164          mKeys = new ArrayList&lt;Key&gt;();
 165          restoreSuccessful = true;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +        mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +        UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +        mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());</span>
 170      }
 171  
 172      private void dataChanged() {
 173          if (mBackupManager == null) {
 174              mBackupManager = new BackupManager(mContext);
 175          }
 176          mBackupManager.dataChanged();
 177      }
 178  
 179      private void applyJournal(Journal journal) {
 180          mLastBackupRestoreTime = journal.t;
 181          mExistingKeys.clear();
 182          if (journal.key != null) {
 183              for (Key key : journal.key) {
 184                  mExistingKeys.add(keyToBackupKey(key));
 185              }
 186          }
 187      }
 188  
 189      /**
 190       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 191       *
 192       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 193       *
 194       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 195       *
 196       * @param oldState notes from the last backup
 197       * @param data incremental key/value pairs to persist off-device
 198       * @param newState notes for the next backup
 199       */
 200      @Override
 201      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 202              ParcelFileDescriptor newState) {
 203          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 204  
 205          Journal in = readJournal(oldState);
 206          if (!launcherIsReady()) {
 207              // Perform backup later.
 208              writeJournal(newState, in);
 209              return;
 210          }
 211          Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 212          mKeys.clear();
 213          applyJournal(in);
 214  
 215          // Record the time before performing backup so that entries edited while the backup
 216          // was going on, do not get missed in next backup.
 217          long newBackupTime = System.currentTimeMillis();
 218          mBackupDataWasUpdated = false;
 219          try {
 220              backupFavorites(data);
 221              backupScreens(data);
 222              backupIcons(data);
 223              backupWidgets(data);
 224  
 225              // Delete any key which still exist in the old backup, but is not valid anymore.
 226              HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 227              for (Key key : mKeys) {
 228                  validKeys.add(keyToBackupKey(key));
 229              }
 230              mExistingKeys.removeAll(validKeys);
 231  
 232              // Delete anything left in the existing keys.
 233              for (String deleted: mExistingKeys) {
 234                  if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 235                  data.writeEntityHeader(deleted, -1);
 236                  mBackupDataWasUpdated = true;
 237              }
 238  
 239              mExistingKeys.clear();
 240              if (!mBackupDataWasUpdated) {
 241                  // Check if any metadata has changed
 242                  mBackupDataWasUpdated = (in.profile == null)
 243                          || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 244                              DeviceProfieData.toByteArray(getDeviceProfieData()))
 245                          || (in.backupVersion != BACKUP_VERSION)
 246                          || (in.appVersion != getAppVersion());
 247              }
 248  
 249              if (mBackupDataWasUpdated) {
 250                  mLastBackupRestoreTime = newBackupTime;
 251  
 252                  // We store the journal at two places.
 253                  //   1) Storing it in newState allows us to do partial backups by comparing old state
 254                  //   2) Storing it in backup data allows us to validate keys during restore
 255                  Journal state = getCurrentStateJournal();
 256                  writeRowToBackup(JOURNAL_KEY, state, data);
 257              } else {
 258                  if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 259              }
 260          } catch (IOException e) {
 261              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 262          }
 263  
 264          writeNewStateDescription(newState);
 265      }
 266  
 267      /**
 268       * @return true if the backup corresponding to oldstate can be successfully applied
 269       * to this device.
 270       */
 271      private boolean isBackupCompatible(Journal oldState) {
 272          DeviceProfieData currentProfile = getDeviceProfieData();
 273  
 274          DeviceProfieData oldProfile = oldState.profile;
 275  
 276          if (oldProfile == null || oldProfile.desktopCols == 0) {
 277              // Profile info is not valid, ignore the check.
 278              return true;
 279          }
 280  
 281          boolean isHotsetCompatible = false;
 282          if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 283              isHotsetCompatible = true;
 284          }
 285          if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 286                  (currentProfile.allappsRank == oldProfile.allappsRank)) {
 287              isHotsetCompatible = true;
 288          }
 289  
 290          return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 291                  &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 292      }
 293  
 294      /**
 295       * Restore launcher configuration from the restored data stream.
 296       * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 297       * backup, it should arrive first.
 298       *
 299       * @param data the key/value pair from the server
 300       */
 301      @Override
 302      public void restoreEntity(BackupDataInputStream data) {
 303          if (!restoreSuccessful) {
 304              return;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +            // During restore we do not need an initialized instance of IconCache. We can create</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +            // a temporary icon cache here, as the process will be rebooted after restore</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +            // is complete.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +            mIconCache = new IconCache(mContext);</span>
 311          }
 312  
 313          int dataSize = data.size();
 314          if (mBuffer.length &lt; dataSize) {
 315              mBuffer = new byte[dataSize];
 316          }
 317          try {
 318              int bytesRead = data.read(mBuffer, 0, dataSize);
 319              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 320              String backupKey = data.getKey();
 321  
 322              if (JOURNAL_KEY.equals(backupKey)) {
 323                  if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 324                  if (!mKeys.isEmpty()) {
 325                      // We received the journal key after a restore key.
 326                      Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 327                      restoreSuccessful = false;
 328                      return;
 329                  }
 330  
 331                  Journal journal = new Journal();
 332                  MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 333                  applyJournal(journal);
 334                  restoreSuccessful = isBackupCompatible(journal);
 335                  restoredBackupVersion = journal.backupVersion;
 336                  return;
 337              }
 338  
 339              if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 340                  if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 341                  return;
 342              }
 343              Key key = backupKeyToKey(backupKey);
 344              mKeys.add(key);
 345              switch (key.type) {
 346                  case Key.FAVORITE:
 347                      restoreFavorite(key, mBuffer, dataSize);
 348                      break;
 349  
 350                  case Key.SCREEN:
 351                      restoreScreen(key, mBuffer, dataSize);
 352                      break;
 353  
 354                  case Key.ICON:
 355                      restoreIcon(key, mBuffer, dataSize);
 356                      break;
 357  
 358                  case Key.WIDGET:
 359                      restoreWidget(key, mBuffer, dataSize);
 360                      break;
 361  
 362                  default:
 363                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 364                      mKeys.remove(key);
 365                      break;
 366              }
 367          } catch (IOException e) {
 368              Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 369          }
 370      }
 371  
 372      /**
 373       * Record the restore state for the next backup.
 374       *
 375       * @param newState notes about the backup state after restore.
 376       */
 377      @Override
 378      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 379          writeJournal(newState, getCurrentStateJournal());
 380      }
 381  
 382      private Journal getCurrentStateJournal() {
 383          Journal journal = new Journal();
 384          journal.t = mLastBackupRestoreTime;
 385          journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 386          journal.appVersion = getAppVersion();
 387          journal.backupVersion = BACKUP_VERSION;
 388          journal.profile = getDeviceProfieData();
 389          return journal;
 390      }
 391  
 392      private int getAppVersion() {
 393          try {
 394              return mContext.getPackageManager()
 395                      .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 396          } catch (NameNotFoundException e) {
 397              return 0;
 398          }
 399      }
 400  
 401      /**
 402       * @return the current device profile information.
 403       */
 404      private DeviceProfieData getDeviceProfieData() {
 405          if (mCurrentProfile != null) {
 406              return mCurrentProfile;
 407          }
 408          final Context applicationContext = mContext.getApplicationContext();
 409          DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)
 410                  .getDeviceProfile();
 411  
 412          mCurrentProfile = new DeviceProfieData();
 413          mCurrentProfile.desktopRows = profile.numRows;
 414          mCurrentProfile.desktopCols = profile.numColumns;
 415          mCurrentProfile.hotseatCount = profile.numHotseatIcons;
 416          mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;
 417          return mCurrentProfile;
 418      }
 419  
 420      /**
 421       * Write all modified favorites to the data stream.
 422       *
 423       * @param data output stream for key/value pairs
 424       * @throws IOException
 425       */
 426      private void backupFavorites(BackupDataOutput data) throws IOException {
 427          // persist things that have changed since the last backup
 428          ContentResolver cr = mContext.getContentResolver();
 429          // Don&#x27;t backup apps in other profiles for now.
 430          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 431                  getUserSelectionArg(), null, null);
 432          try {
 433              cursor.moveToPosition(-1);
 434              while(cursor.moveToNext()) {
 435                  final long id = cursor.getLong(ID_INDEX);
 436                  final long updateTime = cursor.getLong(ID_MODIFIED);
 437                  Key key = getKey(Key.FAVORITE, id);
 438                  mKeys.add(key);
 439                  final String backupKey = keyToBackupKey(key);
 440                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 441                      writeRowToBackup(key, packFavorite(cursor), data);
 442                  } else {
 443                      if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 444                  }
 445              }
 446          } finally {
 447              cursor.close();
 448          }
 449      }
 450  
 451      /**
 452       * Read a favorite from the stream.
 453       *
 454       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 455       *
 456       * @param key identifier for the row
 457       * @param buffer the serialized proto from the stream, may be larger than dataSize
 458       * @param dataSize the size of the proto from the stream
 459       */
 460      private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 461          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 462          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 463                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 464  
 465          ContentResolver cr = mContext.getContentResolver();
 466          ContentValues values = unpackFavorite(buffer, dataSize);
 467          cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 468      }
 469  
 470      /**
 471       * Write all modified screens to the data stream.
 472       *
 473       * @param data output stream for key/value pairs
 474       * @throws IOException
 475       */
 476      private void backupScreens(BackupDataOutput data) throws IOException {
 477          // persist things that have changed since the last backup
 478          ContentResolver cr = mContext.getContentResolver();
 479          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 480                  null, null, null);
 481          try {
 482              cursor.moveToPosition(-1);
 483              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 484              while(cursor.moveToNext()) {
 485                  final long id = cursor.getLong(ID_INDEX);
 486                  final long updateTime = cursor.getLong(ID_MODIFIED);
 487                  Key key = getKey(Key.SCREEN, id);
 488                  mKeys.add(key);
 489                  final String backupKey = keyToBackupKey(key);
 490                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 491                      writeRowToBackup(key, packScreen(cursor), data);
 492                  } else {
 493                      if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 494                  }
 495              }
 496          } finally {
 497              cursor.close();
 498          }
 499      }
 500  
 501      /**
 502       * Read a screen from the stream.
 503       *
 504       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 505       *
 506       * @param key identifier for the row
 507       * @param buffer the serialized proto from the stream, may be larger than dataSize
 508       * @param dataSize the size of the proto from the stream
 509       */
 510      private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 511          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 512          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 513                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 514  
 515          ContentResolver cr = mContext.getContentResolver();
 516          ContentValues values = unpackScreen(buffer, dataSize);
 517          cr.insert(WorkspaceScreens.CONTENT_URI, values);
 518      }
 519  
 520      /**
 521       * Write all the static icon resources we need to render placeholders
 522       * for a package that is not installed.
 523       *
 524       * @param data output stream for key/value pairs
 525       */
 526      private void backupIcons(BackupDataOutput data) throws IOException {
 527          // persist icons that haven&#x27;t been persisted yet
 528          if (!initializeIconCache()) {
 529              dataChanged(); // try again later
 530              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 531              return;
 532          }
 533          final ContentResolver cr = mContext.getContentResolver();
 534          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 535          final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 536          int backupUpIconCount = 0;
 537  
 538          // Don&#x27;t backup apps in other profiles for now.
 539          String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 540                  Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 541                  getUserSelectionArg();
 542          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 543                  where, null, null);
 544          try {
 545              cursor.moveToPosition(-1);
 546              while(cursor.moveToNext()) {
 547                  final long id = cursor.getLong(ID_INDEX);
 548                  final String intentDescription = cursor.getString(INTENT_INDEX);
 549                  try {
 550                      Intent intent = Intent.parseUri(intentDescription, 0);
 551                      ComponentName cn = intent.getComponent();
 552                      Key key = null;
 553                      String backupKey = null;
 554                      if (cn != null) {
 555                          key = getKey(Key.ICON, cn.flattenToShortString());
 556                          backupKey = keyToBackupKey(key);
 557                      } else {
 558                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 559                      }
 560                      if (mExistingKeys.contains(backupKey)) {
 561                          if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 562  
 563                          // remember that we already backed this up previously
 564                          mKeys.add(key);
 565                      } else if (backupKey != null) {
 566                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 567                          if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 568                              if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 569                              Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 570                              if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 571                                  writeRowToBackup(key, packIcon(dpi, icon), data);
 572                                  mKeys.add(key);
 573                                  backupUpIconCount ++;
 574                              }
 575                          } else {
 576                              if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 577                              // too many icons for this pass, request another.
 578                              dataChanged();
 579                          }
 580                      }
 581                  } catch (URISyntaxException e) {
 582                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 583                  } catch (IOException e) {
 584                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 585                  }
 586  
 587              }
 588          } finally {
 589              cursor.close();
 590          }
 591      }
 592  
 593      /**
 594       * Read an icon from the stream.
 595       *
 596       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 597       *
 598       * @param key identifier for the row
 599       * @param buffer the serialized proto from the stream, may be larger than dataSize
 600       * @param dataSize the size of the proto from the stream
 601       */
 602      private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 603          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 604          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 605                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 606  
 607          Resource res = unpackProto(new Resource(), buffer, dataSize);
 608          if (DEBUG) {
 609              Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 610          }
 611          Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 612          if (icon == null) {
 613              Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 614          }
 615          if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -        IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dpi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 617 +        mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 618 +                &quot;&quot; /* label */, mUserSerial);</span>
 619      }
 620  
 621      /**
 622       * Write all the static widget resources we need to render placeholders
 623       * for a package that is not installed.
 624       *
 625       * @param data output stream for key/value pairs
 626       * @throws IOException
 627       */
 628      private void backupWidgets(BackupDataOutput data) throws IOException {
 629          // persist static widget info that hasn&#x27;t been persisted yet
 630          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 631          if (appState == null || !initializeIconCache()) {
 632              Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 633              return;
 634          }
 635          final ContentResolver cr = mContext.getContentResolver();
 636          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -        final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);</span>
 638          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 639          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 640          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 641          int backupWidgetCount = 0;
 642  
 643          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 644                  + getUserSelectionArg();
 645          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 646                  where, null, null);
 647          try {
 648              cursor.moveToPosition(-1);
 649              while(cursor.moveToNext()) {
 650                  final long id = cursor.getLong(ID_INDEX);
 651                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 652                  final int spanX = cursor.getInt(SPANX_INDEX);
 653                  final int spanY = cursor.getInt(SPANY_INDEX);
 654                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 655                  Key key = null;
 656                  String backupKey = null;
 657                  if (provider != null) {
 658                      key = getKey(Key.WIDGET, providerName);
 659                      backupKey = keyToBackupKey(key);
 660                  } else {
 661                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 662                  }
 663                  if (mExistingKeys.contains(backupKey)) {
 664                      if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 665  
 666                      // remember that we already backed this up previously
 667                      mKeys.add(key);
 668                  } else if (backupKey != null) {
 669                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 670                      if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 671                          if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 672 -                        previewLoader.setPreviewSize(spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 673 -                                spanY * profile.cellHeightPx, widgetSpacingLayout);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 674 -                        writeRowToBackup(key, packWidget(dpi, previewLoader, mIconCache, provider), data);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 675 +                        previewLoader.setPreviewSize(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 676 +                                spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 677 +                                spanY * profile.cellHeightPx);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 678 +                        UserHandleCompat user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 679 +                        writeRowToBackup(key,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 680 +                                packWidget(dpi, previewLoader, mIconCache, provider, user),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 681 +                                data);</span>
 682                          mKeys.add(key);
 683                          backupWidgetCount ++;
 684                      } else {
 685                          if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 686                          // too many widgets for this pass, request another.
 687                          dataChanged();
 688                      }
 689                  }
 690              }
 691          } finally {
 692              cursor.close();
 693          }
 694      }
 695  
 696      /**
 697       * Read a widget from the stream.
 698       *
 699       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 700       *
 701       * @param key identifier for the row
 702       * @param buffer the serialized proto from the stream, may be larger than dataSize
 703       * @param dataSize the size of the proto from the stream
 704       */
 705      private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 706          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 707          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 708                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 709          Widget widget = unpackProto(new Widget(), buffer, dataSize);
 710          if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 711          if (widget.icon.data != null)  {
 712              Bitmap icon = BitmapFactory
 713                      .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 714              if (icon == null) {
 715                  Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 716              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 717 -                IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 718 -                        icon, widget.icon.dpi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 719 +                mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 720 +                        icon, widget.icon.dpi, widget.label, mUserSerial);</span>
 721              }
 722          }
 723  
 724          // future site of widget table mutation
 725      }
 726  
 727      /** create a new key, with an integer ID.
 728       *
 729       * &lt;P&gt; Keys contain their own checksum instead of using
 730       * the heavy-weight CheckedMessage wrapper.
 731       */
 732      private Key getKey(int type, long id) {
 733          Key key = new Key();
 734          key.type = type;
 735          key.id = id;
 736          key.checksum = checkKey(key);
 737          return key;
 738      }
 739  
 740      /** create a new key for a named object.
 741       *
 742       * &lt;P&gt; Keys contain their own checksum instead of using
 743       * the heavy-weight CheckedMessage wrapper.
 744       */
 745      private Key getKey(int type, String name) {
 746          Key key = new Key();
 747          key.type = type;
 748          key.name = name;
 749          key.checksum = checkKey(key);
 750          return key;
 751      }
 752  
 753      /** keys need to be strings, serialize and encode. */
 754      private String keyToBackupKey(Key key) {
 755          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 756      }
 757  
 758      /** keys need to be strings, decode and parse. */
 759      private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 760          try {
 761              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 762              if (key.checksum != checkKey(key)) {
 763                  key = null;
 764                  throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 765              }
 766              return key;
 767          } catch (InvalidProtocolBufferNanoException e) {
 768              throw new InvalidBackupException(e);
 769          } catch (IllegalArgumentException e) {
 770              throw new InvalidBackupException(e);
 771          }
 772      }
 773  
 774      /** Compute the checksum over the important bits of a key. */
 775      private long checkKey(Key key) {
 776          CRC32 checksum = new CRC32();
 777          checksum.update(key.type);
 778          checksum.update((int) (key.id &amp; 0xffff));
 779          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 780          if (!TextUtils.isEmpty(key.name)) {
 781              checksum.update(key.name.getBytes());
 782          }
 783          return checksum.getValue();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 784 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 785 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 786 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 787 +     * @return true if its an hotseat item, that can be replaced during restore.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 788 +     * TODO: Extend check for folders in hotseat.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 789 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 790 +    private boolean isReplaceableHotseatItem(Favorite favorite) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 791 +        return favorite.container == Favorites.CONTAINER_HOTSEAT</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 792 +                &amp;&amp; favorite.intent != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 793 +                &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 794 +                || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);</span>
 795      }
 796  
 797      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 798      private Favorite packFavorite(Cursor c) {
 799          Favorite favorite = new Favorite();
 800          favorite.id = c.getLong(ID_INDEX);
 801          favorite.screen = c.getInt(SCREEN_INDEX);
 802          favorite.container = c.getInt(CONTAINER_INDEX);
 803          favorite.cellX = c.getInt(CELLX_INDEX);
 804          favorite.cellY = c.getInt(CELLY_INDEX);
 805          favorite.spanX = c.getInt(SPANX_INDEX);
 806          favorite.spanY = c.getInt(SPANY_INDEX);
 807          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 808          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 809              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 810              if (!TextUtils.isEmpty(iconPackage)) {
 811                  favorite.iconPackage = iconPackage;
 812              }
 813              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 814              if (!TextUtils.isEmpty(iconResource)) {
 815                  favorite.iconResource = iconResource;
 816              }
 817          }
 818          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 819              byte[] blob = c.getBlob(ICON_INDEX);
 820              if (blob != null &amp;&amp; blob.length &gt; 0) {
 821                  favorite.icon = blob;
 822              }
 823          }
 824          String title = c.getString(TITLE_INDEX);
 825          if (!TextUtils.isEmpty(title)) {
 826              favorite.title = title;
 827          }
 828          String intentDescription = c.getString(INTENT_INDEX);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 829 +        Intent intent = null;</span>
 830          if (!TextUtils.isEmpty(intentDescription)) {
 831              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 832 -                Intent intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 833 +                intent = Intent.parseUri(intentDescription, 0);</span>
 834                  intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 835                  favorite.intent = intent.toUri(0);
 836              } catch (URISyntaxException e) {
 837                  Log.e(TAG, &quot;Invalid intent&quot;, e);
 838              }
 839          }
 840          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 841          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 842              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 843              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 844              if (!TextUtils.isEmpty(appWidgetProvider)) {
 845                  favorite.appWidgetProvider = appWidgetProvider;
 846              }
 847          }
 848  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 849 +        if (isReplaceableHotseatItem(favorite)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 850 +            if (intent != null &amp;&amp; intent.getComponent() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 851 +                PackageManager pm = mContext.getPackageManager();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 852 +                ActivityInfo activity = null;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 853 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 854 +                    activity = pm.getActivityInfo(intent.getComponent(), 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 855 +                } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 856 +                    Log.e(TAG, &quot;Target not found&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 857 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 858 +                if (activity == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 859 +                    return favorite;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 860 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 861 +                for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 862 +                    if (mItemTypeMatchers[i] == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 863 +                        mItemTypeMatchers[i] = new ItemTypeMatcher(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 864 +                                CommonAppTypeParser.getResourceForItemType(i));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 865 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 866 +                    if (mItemTypeMatchers[i].matches(activity, pm)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 867 +                        favorite.targetType = i;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 868 +                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 869 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 870 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 871 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 872 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 873 +</span>
 874          return favorite;
 875      }
 876  
 877      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 878      private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 879              throws IOException {
 880          Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 881 +</span>
 882          ContentValues values = new ContentValues();
 883          values.put(Favorites._ID, favorite.id);
 884          values.put(Favorites.SCREEN, favorite.screen);
 885          values.put(Favorites.CONTAINER, favorite.container);
 886          values.put(Favorites.CELLX, favorite.cellX);
 887          values.put(Favorites.CELLY, favorite.cellY);
 888          values.put(Favorites.SPANX, favorite.spanX);
 889          values.put(Favorites.SPANY, favorite.spanY);
 890          values.put(Favorites.ICON_TYPE, favorite.iconType);
 891          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 892              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 893              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 894          }
 895          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 896              values.put(Favorites.ICON, favorite.icon);
 897          }
 898          if (!TextUtils.isEmpty(favorite.title)) {
 899              values.put(Favorites.TITLE, favorite.title);
 900          } else {
 901              values.put(Favorites.TITLE, &quot;&quot;);
 902          }
 903          if (!TextUtils.isEmpty(favorite.intent)) {
 904              values.put(Favorites.INTENT, favorite.intent);
 905          }
 906          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 907  
 908          UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 909          long userSerialNumber =
 910                  UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 911          values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 912  
 913          DeviceProfieData currentProfile = getDeviceProfieData();
 914  
 915          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 916              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 917                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 918              }
 919              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 920              values.put(LauncherSettings.Favorites.RESTORED,
 921                      LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 922                      LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 923                      LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 924  
 925              // Verify placement
 926              if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 927                      || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 928                  restoreSuccessful = false;
 929                  throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 930              }
 931          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 932 -            // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 933 -            values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 934 +            // Check if it is an hotseat item, that can be replaced.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 935 +            if (isReplaceableHotseatItem(favorite)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 936 +                    &amp;&amp; favorite.targetType != Favorite.TARGET_NONE</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 937 +                    &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 938 +                Log.e(TAG, &quot;Added item type flag&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 939 +                values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 940 +                        1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 941 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 942 +                // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 943 +                values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +            }</span>
 945  
 946              // Verify placement
 947              if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 948                  if ((favorite.screen &gt;= currentProfile.hotseatCount)
 949                          || (favorite.screen == currentProfile.allappsRank)) {
 950                      restoreSuccessful = false;
 951                      throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 952                  }
 953              } else {
 954                  if ((favorite.cellX &gt;= currentProfile.desktopCols)
 955                          || (favorite.cellY &gt;= currentProfile.desktopRows)) {
 956                      restoreSuccessful = false;
 957                      throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 958                  }
 959              }
 960          }
 961  
 962          return values;
 963      }
 964  
 965      /** Serialize a Screen for persistence, including a checksum wrapper. */
 966      private Screen packScreen(Cursor c) {
 967          Screen screen = new Screen();
 968          screen.id = c.getLong(ID_INDEX);
 969          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 970          return screen;
 971      }
 972  
 973      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 974      private ContentValues unpackScreen(byte[] buffer, int dataSize)
 975              throws InvalidProtocolBufferNanoException {
 976          Screen screen = unpackProto(new Screen(), buffer, dataSize);
 977          ContentValues values = new ContentValues();
 978          values.put(WorkspaceScreens._ID, screen.id);
 979          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 980          return values;
 981      }
 982  
 983      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 984      private Resource packIcon(int dpi, Bitmap icon) {
 985          Resource res = new Resource();
 986          res.dpi = dpi;
 987          ByteArrayOutputStream os = new ByteArrayOutputStream();
 988          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 989              res.data = os.toByteArray();
 990          }
 991          return res;
 992      }
 993  
 994      /** Serialize a widget for persistence, including a checksum wrapper. */
 995      private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 996 -            ComponentName provider) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 997 +            ComponentName provider, UserHandleCompat user) {</span>
 998          final LauncherAppWidgetProviderInfo info =
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 999 -                LauncherModel.getProviderInfo(mContext, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1000 +                LauncherModel.getProviderInfo(mContext, provider, user);</span>
1001          Widget widget = new Widget();
1002          widget.provider = provider.flattenToShortString();
1003          widget.label = info.label;
1004          widget.configure = info.configure != null;
1005          if (info.icon != 0) {
1006              widget.icon = new Resource();
1007              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
1008              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
1009              ByteArrayOutputStream os = new ByteArrayOutputStream();
1010              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1011                  widget.icon.data = os.toByteArray();
1012                  widget.icon.dpi = dpi;
1013              }
1014          }
1015          if (info.previewImage != 0) {
1016              widget.preview = new Resource();
1017              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
1018              ByteArrayOutputStream os = new ByteArrayOutputStream();
1019              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1020                  widget.preview.data = os.toByteArray();
1021                  widget.preview.dpi = dpi;
1022              }
1023          }
1024          return widget;
1025      }
1026  
1027      /**
1028       * Deserialize a proto after verifying checksum wrapper.
1029       */
1030      private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1031              throws InvalidProtocolBufferNanoException {
1032          MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1033          if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1034          return proto;
1035      }
1036  
1037      /**
1038       * Read the old journal from the input file.
1039       *
1040       * In the event of any error, just pretend we didn&#x27;t have a journal,
1041       * in that case, do a full backup.
1042       *
1043       * @param oldState the read-0only file descriptor pointing to the old journal
1044       * @return a Journal protocol buffer
1045       */
1046      private Journal readJournal(ParcelFileDescriptor oldState) {
1047          Journal journal = new Journal();
1048          if (oldState == null) {
1049              return journal;
1050          }
1051          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1052          try {
1053              int availableBytes = inStream.available();
1054              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1055              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1056                  byte[] buffer = new byte[availableBytes];
1057                  int bytesRead = 0;
1058                  boolean valid = false;
1059                  InvalidProtocolBufferNanoException lastProtoException = null;
1060                  while (availableBytes &gt; 0) {
1061                      try {
1062                          // OMG what are you doing? This is crazy inefficient!
1063                          // If we read a byte that is not ours, we will cause trouble: b/12491813
1064                          // However, we don&#x27;t know how many bytes to expect (oops).
1065                          // So we have to step through *slowly*, watching for the end.
1066                          int result = inStream.read(buffer, bytesRead, 1);
1067                          if (result &gt; 0) {
1068                              availableBytes -= result;
1069                              bytesRead += result;
1070                          } else {
1071                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1072                              // stop reading and see what there is to parse
1073                              availableBytes = 0;
1074                          }
1075                      } catch (IOException e) {
1076                          buffer = null;
1077                          availableBytes = 0;
1078                      }
1079  
1080                      // check the buffer to see if we have a valid journal
1081                      try {
1082                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1083                          // if we are here, then we have read a valid, checksum-verified journal
1084                          valid = true;
1085                          availableBytes = 0;
1086                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1087                      } catch (InvalidProtocolBufferNanoException e) {
1088                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1089                          lastProtoException = e;
1090                          journal.clear();
1091                      }
1092                  }
1093                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1094                  if (!valid) {
1095                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1096                  }
1097              }
1098          } catch (IOException e) {
1099              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1100          } finally {
1101              try {
1102                  inStream.close();
1103              } catch (IOException e) {
1104                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1105              }
1106          }
1107          return journal;
1108      }
1109  
1110      private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1111              throws IOException {
1112          writeRowToBackup(keyToBackupKey(key), proto, data);
1113      }
1114  
1115      private void writeRowToBackup(String backupKey, MessageNano proto,
1116              BackupDataOutput data) throws IOException {
1117          byte[] blob = writeCheckedBytes(proto);
1118          data.writeEntityHeader(backupKey, blob.length);
1119          data.writeEntityData(blob, blob.length);
1120          mBackupDataWasUpdated = true;
1121          if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1122      }
1123  
1124      /**
1125       * Write the new journal to the output file.
1126       *
1127       * In the event of any error, just pretend we didn&#x27;t have a journal,
1128       * in that case, do a full backup.
1129  
1130       * @param newState the write-only file descriptor pointing to the new journal
1131       * @param journal a Journal protocol buffer
1132       */
1133      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1134          FileOutputStream outStream = null;
1135          try {
1136              outStream = new FileOutputStream(newState.getFileDescriptor());
1137              final byte[] journalBytes = writeCheckedBytes(journal);
1138              outStream.write(journalBytes);
1139              outStream.close();
1140              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1141          } catch (IOException e) {
1142              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1143          }
1144      }
1145  
1146      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1147      private byte[] writeCheckedBytes(MessageNano proto) {
1148          CheckedMessage wrapper = new CheckedMessage();
1149          wrapper.payload = MessageNano.toByteArray(proto);
1150          CRC32 checksum = new CRC32();
1151          checksum.update(wrapper.payload);
1152          wrapper.checksum = checksum.getValue();
1153          return MessageNano.toByteArray(wrapper);
1154      }
1155  
1156      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1157      private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1158              throws InvalidProtocolBufferNanoException {
1159          CheckedMessage wrapper = new CheckedMessage();
1160          MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1161          CRC32 checksum = new CRC32();
1162          checksum.update(wrapper.payload);
1163          if (wrapper.checksum != checksum.getValue()) {
1164              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1165          }
1166          return wrapper.payload;
1167      }
1168  
1169      private boolean initializeIconCache() {
1170          if (mIconCache != null) {
1171              return true;
1172          }
1173  
1174          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1175          if (appState == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1176 -            Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1177 -            stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1178 -            Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1179 +            if (DEBUG) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1180 +                Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1181 +                stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1182 +                Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1183 +            }</span>
1184              return false;
1185          }
1186          mIconCache = appState.getIconCache();
1187          return mIconCache != null;
1188      }
1189  
1190  
1191      /**
1192       * @return true if the launcher is in a state to support backup
1193       */
1194      private boolean launcherIsReady() {
1195          ContentResolver cr = mContext.getContentResolver();
1196          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1197          if (cursor == null) {
1198              // launcher data has been wiped, do nothing
1199              return false;
1200          }
1201          cursor.close();
1202  
1203          if (!initializeIconCache()) {
1204              // launcher services are unavailable, try again later
1205              dataChanged();
1206              return false;
1207          }
1208  
1209          return true;
1210      }
1211  
1212      private String getUserSelectionArg() {
1213          return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1214                  .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1215      }
1216  
1217      private class InvalidBackupException extends IOException {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1218 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1219 +        private static final long serialVersionUID = 8931456637211665082L;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1220 +</span>
1221          private InvalidBackupException(Throwable cause) {
1222              super(cause);
1223          }
1224  
1225          public InvalidBackupException(String reason) {
1226              super(reason);
1227          }
1228      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1229 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1230 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1231 +     * A class to check if an activity can handle one of the intents from a list of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1232 +     * predefined intents.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1233 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1234 +    private class ItemTypeMatcher {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1235 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1236 +        private final ArrayList&lt;Intent&gt; mIntents;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1237 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1238 +        ItemTypeMatcher(int xml_res) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1239 +            mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1240 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1242 +        private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1243 +            ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1244 +            XmlResourceParser parser = mContext.getResources().getXml(xml_res);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1245 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1246 +                DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1247 +                final int depth = parser.getDepth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1248 +                int type;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1249 +                while (((type = parser.next()) != XmlPullParser.END_TAG ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1250 +                        parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1251 +                    if (type != XmlPullParser.START_TAG) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1252 +                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1253 +                    } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1254 +                        final String uri = DefaultLayoutParser.getAttributeValue(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1255 +                                parser, DefaultLayoutParser.ATTR_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1256 +                        intents.add(Intent.parseUri(uri, 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1257 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1258 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1259 +            } catch (URISyntaxException | XmlPullParserException | IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1260 +                Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1261 +            } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1262 +                parser.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1263 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1264 +            return intents;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1265 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1266 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1267 +        public boolean matches(ActivityInfo activity, PackageManager pm) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1268 +            for (Intent intent : mIntents) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1269 +                intent.setPackage(activity.packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1270 +                ResolveInfo info = pm.resolveActivity(intent, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1271 +                if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1272 +                        || info.activityInfo.name.equals(activity.targetActivity))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1273 +                    return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1274 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1275 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1276 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1277 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1278 +    }</span>
1279  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import android.app.backup.BackupDataInputStream;
  19  import android.app.backup.BackupDataOutput;
  20  import android.app.backup.BackupHelper;
  21  import android.app.backup.BackupManager;
  22  import android.appwidget.AppWidgetProviderInfo;
  23  import android.content.ComponentName;
  24  import android.content.ContentResolver;
  25  import android.content.ContentValues;
  26  import android.content.Context;
  27  import android.content.Intent;


  28  import android.content.pm.PackageManager.NameNotFoundException;


  29  import android.database.Cursor;
  30  import android.graphics.Bitmap;
  31  import android.graphics.BitmapFactory;
  32  import android.graphics.drawable.Drawable;
  33  import android.os.ParcelFileDescriptor;
  34  import android.text.TextUtils;
  35  import android.util.Base64;
  36  import android.util.Log;
  37  
  38  import com.android.launcher3.LauncherSettings.Favorites;
  39  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  40  import com.android.launcher3.backup.BackupProtos;
  41  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  42  import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  43  import com.android.launcher3.backup.BackupProtos.Favorite;
  44  import com.android.launcher3.backup.BackupProtos.Journal;
  45  import com.android.launcher3.backup.BackupProtos.Key;
  46  import com.android.launcher3.backup.BackupProtos.Resource;
  47  import com.android.launcher3.backup.BackupProtos.Screen;
  48  import com.android.launcher3.backup.BackupProtos.Widget;
  49  import com.android.launcher3.compat.UserHandleCompat;
  50  import com.android.launcher3.compat.UserManagerCompat;
  51  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  52  import com.google.protobuf.nano.MessageNano;
  53  



  54  import java.io.ByteArrayOutputStream;
  55  import java.io.FileInputStream;
  56  import java.io.FileOutputStream;
  57  import java.io.IOException;
  58  import java.net.URISyntaxException;
  59  import java.util.ArrayList;
  60  import java.util.Arrays;
  61  import java.util.HashMap;
  62  import java.util.HashSet;
  63  import java.util.zip.CRC32;
  64  
  65  /**
  66   * Persist the launcher home state across calamities.
  67   */
  68  public class LauncherBackupHelper implements BackupHelper {
  69      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72  
  73      private static final int BACKUP_VERSION = 2;
  74      private static final int MAX_JOURNAL_SIZE = 1000000;
  75  
  76      // Journal key is such that it is always smaller than any dynamically generated
  77      // key (any Base64 encoded string).
  78      private static final String JOURNAL_KEY = &quot;#&quot;;
  79  
  80      /** icons are large, dribble them out */
  81      private static final int MAX_ICONS_PER_PASS = 10;
  82  
  83      /** widgets contain previews, which are very large, dribble them out */
  84      private static final int MAX_WIDGETS_PER_PASS = 5;
  85  
  86      private static final int IMAGE_COMPRESSION_QUALITY = 75;
  87  
  88      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89              android.graphics.Bitmap.CompressFormat.PNG;
  90  
  91      private static final String[] FAVORITE_PROJECTION = {
  92          Favorites._ID,                     // 0
  93          Favorites.MODIFIED,                // 1
  94          Favorites.INTENT,                  // 2
  95          Favorites.APPWIDGET_PROVIDER,      // 3
  96          Favorites.APPWIDGET_ID,            // 4
  97          Favorites.CELLX,                   // 5
  98          Favorites.CELLY,                   // 6
  99          Favorites.CONTAINER,               // 7
 100          Favorites.ICON,                    // 8
 101          Favorites.ICON_PACKAGE,            // 9
 102          Favorites.ICON_RESOURCE,           // 10
 103          Favorites.ICON_TYPE,               // 11
 104          Favorites.ITEM_TYPE,               // 12
 105          Favorites.SCREEN,                  // 13
 106          Favorites.SPANX,                   // 14
 107          Favorites.SPANY,                   // 15
 108          Favorites.TITLE,                   // 16
 109          Favorites.PROFILE_ID,              // 17
 110      };
 111  
 112      private static final int ID_INDEX = 0;
 113      private static final int ID_MODIFIED = 1;
 114      private static final int INTENT_INDEX = 2;
 115      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 116      private static final int APPWIDGET_ID_INDEX = 4;
 117      private static final int CELLX_INDEX = 5;
 118      private static final int CELLY_INDEX = 6;
 119      private static final int CONTAINER_INDEX = 7;
 120      private static final int ICON_INDEX = 8;
 121      private static final int ICON_PACKAGE_INDEX = 9;
 122      private static final int ICON_RESOURCE_INDEX = 10;
 123      private static final int ICON_TYPE_INDEX = 11;
 124      private static final int ITEM_TYPE_INDEX = 12;
 125      private static final int SCREEN_INDEX = 13;
 126      private static final int SPANX_INDEX = 14;
 127      private static final int SPANY_INDEX = 15;
 128      private static final int TITLE_INDEX = 16;
 129  
 130      private static final String[] SCREEN_PROJECTION = {
 131          WorkspaceScreens._ID,              // 0
 132          WorkspaceScreens.MODIFIED,         // 1
 133          WorkspaceScreens.SCREEN_RANK       // 2
 134      };
 135  
 136      private static final int SCREEN_RANK_INDEX = 2;
 137  
 138      private final Context mContext;
 139      private final HashSet&lt;String&gt; mExistingKeys;
 140      private final ArrayList&lt;Key&gt; mKeys;


 141  
 142      private IconCache mIconCache;
 143      private BackupManager mBackupManager;
 144      private byte[] mBuffer = new byte[512];
 145      private long mLastBackupRestoreTime;
 146      private boolean mBackupDataWasUpdated;
 147  
 148      private DeviceProfieData mCurrentProfile;
 149      boolean restoreSuccessful;
 150      int restoredBackupVersion = 1;
 151  
 152      public LauncherBackupHelper(Context context) {
 153          mContext = context;
 154          mExistingKeys = new HashSet&lt;String&gt;();
 155          mKeys = new ArrayList&lt;Key&gt;();
 156          restoreSuccessful = true;




 157      }
 158  
 159      private void dataChanged() {
 160          if (mBackupManager == null) {
 161              mBackupManager = new BackupManager(mContext);
 162          }
 163          mBackupManager.dataChanged();
 164      }
 165  
 166      private void applyJournal(Journal journal) {
 167          mLastBackupRestoreTime = journal.t;
 168          mExistingKeys.clear();
 169          if (journal.key != null) {
 170              for (Key key : journal.key) {
 171                  mExistingKeys.add(keyToBackupKey(key));
 172              }
 173          }
 174      }
 175  
 176      /**
 177       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 178       *
 179       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 180       *
 181       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 182       *
 183       * @param oldState notes from the last backup
 184       * @param data incremental key/value pairs to persist off-device
 185       * @param newState notes for the next backup
 186       */
 187      @Override
 188      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 189              ParcelFileDescriptor newState) {
 190          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 191  
 192          Journal in = readJournal(oldState);
 193          if (!launcherIsReady()) {
 194              // Perform backup later.
 195              writeJournal(newState, in);
 196              return;
 197          }
 198          Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 199          mKeys.clear();
 200          applyJournal(in);
 201  
 202          // Record the time before performing backup so that entries edited while the backup
 203          // was going on, do not get missed in next backup.
 204          long newBackupTime = System.currentTimeMillis();
 205          mBackupDataWasUpdated = false;
 206          try {
 207              backupFavorites(data);
 208              backupScreens(data);
 209              backupIcons(data);
 210              backupWidgets(data);
 211  
 212              // Delete any key which still exist in the old backup, but is not valid anymore.
 213              HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 214              for (Key key : mKeys) {
 215                  validKeys.add(keyToBackupKey(key));
 216              }
 217              mExistingKeys.removeAll(validKeys);
 218  
 219              // Delete anything left in the existing keys.
 220              for (String deleted: mExistingKeys) {
 221                  if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 222                  data.writeEntityHeader(deleted, -1);
 223                  mBackupDataWasUpdated = true;
 224              }
 225  
 226              mExistingKeys.clear();
 227              if (!mBackupDataWasUpdated) {
 228                  // Check if any metadata has changed
 229                  mBackupDataWasUpdated = (in.profile == null)
 230                          || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 231                              DeviceProfieData.toByteArray(getDeviceProfieData()))
 232                          || (in.backupVersion != BACKUP_VERSION)
 233                          || (in.appVersion != getAppVersion());
 234              }
 235  
 236              if (mBackupDataWasUpdated) {
 237                  mLastBackupRestoreTime = newBackupTime;
 238  
 239                  // We store the journal at two places.
 240                  //   1) Storing it in newState allows us to do partial backups by comparing old state
 241                  //   2) Storing it in backup data allows us to validate keys during restore
 242                  Journal state = getCurrentStateJournal();
 243                  writeRowToBackup(JOURNAL_KEY, state, data);
 244              } else {
 245                  if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 246              }
 247          } catch (IOException e) {
 248              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 249          }
 250  
 251          writeNewStateDescription(newState);
 252      }
 253  
 254      /**
 255       * @return true if the backup corresponding to oldstate can be successfully applied
 256       * to this device.
 257       */
 258      private boolean isBackupCompatible(Journal oldState) {
 259          DeviceProfieData currentProfile = getDeviceProfieData();
 260  
 261          DeviceProfieData oldProfile = oldState.profile;
 262  
 263          if (oldProfile == null || oldProfile.desktopCols == 0) {
 264              // Profile info is not valid, ignore the check.
 265              return true;
 266          }
 267  
 268          boolean isHotsetCompatible = false;
 269          if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 270              isHotsetCompatible = true;
 271          }
 272          if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 273                  (currentProfile.allappsRank == oldProfile.allappsRank)) {
 274              isHotsetCompatible = true;
 275          }
 276  
 277          return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 278                  &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 279      }
 280  
 281      /**
 282       * Restore launcher configuration from the restored data stream.
 283       * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 284       * backup, it should arrive first.
 285       *
 286       * @param data the key/value pair from the server
 287       */
 288      @Override
 289      public void restoreEntity(BackupDataInputStream data) {
 290          if (!restoreSuccessful) {
 291              return;






 292          }
 293  
 294          int dataSize = data.size();
 295          if (mBuffer.length &lt; dataSize) {
 296              mBuffer = new byte[dataSize];
 297          }
 298          try {
 299              int bytesRead = data.read(mBuffer, 0, dataSize);
 300              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 301              String backupKey = data.getKey();
 302  
 303              if (JOURNAL_KEY.equals(backupKey)) {
 304                  if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 305                  if (!mKeys.isEmpty()) {
 306                      // We received the journal key after a restore key.
 307                      Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 308                      restoreSuccessful = false;
 309                      return;
 310                  }
 311  
 312                  Journal journal = new Journal();
 313                  MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 314                  applyJournal(journal);
 315                  restoreSuccessful = isBackupCompatible(journal);
 316                  restoredBackupVersion = journal.backupVersion;
 317                  return;
 318              }
 319  
 320              if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 321                  if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 322                  return;
 323              }
 324              Key key = backupKeyToKey(backupKey);
 325              mKeys.add(key);
 326              switch (key.type) {
 327                  case Key.FAVORITE:
 328                      restoreFavorite(key, mBuffer, dataSize);
 329                      break;
 330  
 331                  case Key.SCREEN:
 332                      restoreScreen(key, mBuffer, dataSize);
 333                      break;
 334  
 335                  case Key.ICON:
 336                      restoreIcon(key, mBuffer, dataSize);
 337                      break;
 338  
 339                  case Key.WIDGET:
 340                      restoreWidget(key, mBuffer, dataSize);
 341                      break;
 342  
 343                  default:
 344                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 345                      mKeys.remove(key);
 346                      break;
 347              }
 348          } catch (IOException e) {
 349              Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 350          }
 351      }
 352  
 353      /**
 354       * Record the restore state for the next backup.
 355       *
 356       * @param newState notes about the backup state after restore.
 357       */
 358      @Override
 359      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 360          writeJournal(newState, getCurrentStateJournal());
 361      }
 362  
 363      private Journal getCurrentStateJournal() {
 364          Journal journal = new Journal();
 365          journal.t = mLastBackupRestoreTime;
 366          journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 367          journal.appVersion = getAppVersion();
 368          journal.backupVersion = BACKUP_VERSION;
 369          journal.profile = getDeviceProfieData();
 370          return journal;
 371      }
 372  
 373      private int getAppVersion() {
 374          try {
 375              return mContext.getPackageManager()
 376                      .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 377          } catch (NameNotFoundException e) {
 378              return 0;
 379          }
 380      }
 381  
 382      /**
 383       * @return the current device profile information.
 384       */
 385      private DeviceProfieData getDeviceProfieData() {
 386          if (mCurrentProfile != null) {
 387              return mCurrentProfile;
 388          }
 389          final Context applicationContext = mContext.getApplicationContext();
 390          DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)
 391                  .getDeviceProfile();
 392  
 393          mCurrentProfile = new DeviceProfieData();
 394          mCurrentProfile.desktopRows = profile.numRows;
 395          mCurrentProfile.desktopCols = profile.numColumns;
 396          mCurrentProfile.hotseatCount = profile.numHotseatIcons;
 397          mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;
 398          return mCurrentProfile;
 399      }
 400  
 401      /**
 402       * Write all modified favorites to the data stream.
 403       *
 404       * @param data output stream for key/value pairs
 405       * @throws IOException
 406       */
 407      private void backupFavorites(BackupDataOutput data) throws IOException {
 408          // persist things that have changed since the last backup
 409          ContentResolver cr = mContext.getContentResolver();
 410          // Don&#x27;t backup apps in other profiles for now.
 411          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 412                  getUserSelectionArg(), null, null);
 413          try {
 414              cursor.moveToPosition(-1);
 415              while(cursor.moveToNext()) {
 416                  final long id = cursor.getLong(ID_INDEX);
 417                  final long updateTime = cursor.getLong(ID_MODIFIED);
 418                  Key key = getKey(Key.FAVORITE, id);
 419                  mKeys.add(key);
 420                  final String backupKey = keyToBackupKey(key);
 421                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 422                      writeRowToBackup(key, packFavorite(cursor), data);
 423                  } else {
 424                      if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 425                  }
 426              }
 427          } finally {
 428              cursor.close();
 429          }
 430      }
 431  
 432      /**
 433       * Read a favorite from the stream.
 434       *
 435       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 436       *
 437       * @param key identifier for the row
 438       * @param buffer the serialized proto from the stream, may be larger than dataSize
 439       * @param dataSize the size of the proto from the stream
 440       */
 441      private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 442          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 443          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 444                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 445  
 446          ContentResolver cr = mContext.getContentResolver();
 447          ContentValues values = unpackFavorite(buffer, dataSize);
 448          cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 449      }
 450  
 451      /**
 452       * Write all modified screens to the data stream.
 453       *
 454       * @param data output stream for key/value pairs
 455       * @throws IOException
 456       */
 457      private void backupScreens(BackupDataOutput data) throws IOException {
 458          // persist things that have changed since the last backup
 459          ContentResolver cr = mContext.getContentResolver();
 460          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 461                  null, null, null);
 462          try {
 463              cursor.moveToPosition(-1);
 464              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 465              while(cursor.moveToNext()) {
 466                  final long id = cursor.getLong(ID_INDEX);
 467                  final long updateTime = cursor.getLong(ID_MODIFIED);
 468                  Key key = getKey(Key.SCREEN, id);
 469                  mKeys.add(key);
 470                  final String backupKey = keyToBackupKey(key);
 471                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 472                      writeRowToBackup(key, packScreen(cursor), data);
 473                  } else {
 474                      if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 475                  }
 476              }
 477          } finally {
 478              cursor.close();
 479          }
 480      }
 481  
 482      /**
 483       * Read a screen from the stream.
 484       *
 485       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 486       *
 487       * @param key identifier for the row
 488       * @param buffer the serialized proto from the stream, may be larger than dataSize
 489       * @param dataSize the size of the proto from the stream
 490       */
 491      private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 492          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 493          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 494                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 495  
 496          ContentResolver cr = mContext.getContentResolver();
 497          ContentValues values = unpackScreen(buffer, dataSize);
 498          cr.insert(WorkspaceScreens.CONTENT_URI, values);
 499      }
 500  
 501      /**
 502       * Write all the static icon resources we need to render placeholders
 503       * for a package that is not installed.
 504       *
 505       * @param data output stream for key/value pairs
 506       */
 507      private void backupIcons(BackupDataOutput data) throws IOException {
 508          // persist icons that haven&#x27;t been persisted yet
 509          if (!initializeIconCache()) {
 510              dataChanged(); // try again later
 511              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 512              return;
 513          }
 514          final ContentResolver cr = mContext.getContentResolver();
 515          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 516          final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 517          int backupUpIconCount = 0;
 518  
 519          // Don&#x27;t backup apps in other profiles for now.
 520          String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 521                  Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 522                  getUserSelectionArg();
 523          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 524                  where, null, null);
 525          try {
 526              cursor.moveToPosition(-1);
 527              while(cursor.moveToNext()) {
 528                  final long id = cursor.getLong(ID_INDEX);
 529                  final String intentDescription = cursor.getString(INTENT_INDEX);
 530                  try {
 531                      Intent intent = Intent.parseUri(intentDescription, 0);
 532                      ComponentName cn = intent.getComponent();
 533                      Key key = null;
 534                      String backupKey = null;
 535                      if (cn != null) {
 536                          key = getKey(Key.ICON, cn.flattenToShortString());
 537                          backupKey = keyToBackupKey(key);
 538                      } else {
 539                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 540                      }
 541                      if (mExistingKeys.contains(backupKey)) {
 542                          if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 543  
 544                          // remember that we already backed this up previously
 545                          mKeys.add(key);
 546                      } else if (backupKey != null) {
 547                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 548                          if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 549                              if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 550                              Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 551                              if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 552                                  writeRowToBackup(key, packIcon(dpi, icon), data);
 553                                  mKeys.add(key);
 554                                  backupUpIconCount ++;
 555                              }
 556                          } else {
 557                              if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 558                              // too many icons for this pass, request another.
 559                              dataChanged();
 560                          }
 561                      }
 562                  } catch (URISyntaxException e) {
 563                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 564                  } catch (IOException e) {
 565                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 566                  }
 567  
 568              }
 569          } finally {
 570              cursor.close();
 571          }
 572      }
 573  
 574      /**
 575       * Read an icon from the stream.
 576       *
 577       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 578       *
 579       * @param key identifier for the row
 580       * @param buffer the serialized proto from the stream, may be larger than dataSize
 581       * @param dataSize the size of the proto from the stream
 582       */
 583      private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 584          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 585          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 586                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 587  
 588          Resource res = unpackProto(new Resource(), buffer, dataSize);
 589          if (DEBUG) {
 590              Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 591          }
 592          Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 593          if (icon == null) {
 594              Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 595          }
 596          if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 597          IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dpi);


 598      }
 599  
 600      /**
 601       * Write all the static widget resources we need to render placeholders
 602       * for a package that is not installed.
 603       *
 604       * @param data output stream for key/value pairs
 605       * @throws IOException
 606       */
 607      private void backupWidgets(BackupDataOutput data) throws IOException {
 608          // persist static widget info that hasn&#x27;t been persisted yet
 609          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 610          if (appState == null || !initializeIconCache()) {
 611              Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 612              return;
 613          }
 614          final ContentResolver cr = mContext.getContentResolver();
 615          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 616          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 617          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 618          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 619          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 620          int backupWidgetCount = 0;
 621  
 622          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 623                  + getUserSelectionArg();
 624          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 625                  where, null, null);
 626          try {
 627              cursor.moveToPosition(-1);
 628              while(cursor.moveToNext()) {
 629                  final long id = cursor.getLong(ID_INDEX);
 630                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 631                  final int spanX = cursor.getInt(SPANX_INDEX);
 632                  final int spanY = cursor.getInt(SPANY_INDEX);
 633                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 634                  Key key = null;
 635                  String backupKey = null;
 636                  if (provider != null) {
 637                      key = getKey(Key.WIDGET, providerName);
 638                      backupKey = keyToBackupKey(key);
 639                  } else {
 640                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 641                  }
 642                  if (mExistingKeys.contains(backupKey)) {
 643                      if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 644  
 645                      // remember that we already backed this up previously
 646                      mKeys.add(key);
 647                  } else if (backupKey != null) {
 648                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 649                      if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 650                          if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
 651                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 652                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -                        writeRowToBackup(key, packWidget(dpi, previewLoader, mIconCache, provider), data);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 654 +                        UserHandleCompat user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 655 +                        writeRowToBackup(key,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 656 +                                packWidget(dpi, previewLoader, mIconCache, provider, user),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +                                data);</span>



 658                          mKeys.add(key);
 659                          backupWidgetCount ++;
 660                      } else {
 661                          if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 662                          // too many widgets for this pass, request another.
 663                          dataChanged();
 664                      }
 665                  }
 666              }
 667          } finally {
 668              cursor.close();
 669          }
 670      }
 671  
 672      /**
 673       * Read a widget from the stream.
 674       *
 675       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 676       *
 677       * @param key identifier for the row
 678       * @param buffer the serialized proto from the stream, may be larger than dataSize
 679       * @param dataSize the size of the proto from the stream
 680       */
 681      private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 682          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 683          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 684                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 685          Widget widget = unpackProto(new Widget(), buffer, dataSize);
 686          if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 687          if (widget.icon.data != null)  {
 688              Bitmap icon = BitmapFactory
 689                      .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 690              if (icon == null) {
 691                  Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 692              } else {
 693                  IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),
 694                          icon, widget.icon.dpi);


 695              }
 696          }
 697  
 698          // future site of widget table mutation
 699      }
 700  
 701      /** create a new key, with an integer ID.
 702       *
 703       * &lt;P&gt; Keys contain their own checksum instead of using
 704       * the heavy-weight CheckedMessage wrapper.
 705       */
 706      private Key getKey(int type, long id) {
 707          Key key = new Key();
 708          key.type = type;
 709          key.id = id;
 710          key.checksum = checkKey(key);
 711          return key;
 712      }
 713  
 714      /** create a new key for a named object.
 715       *
 716       * &lt;P&gt; Keys contain their own checksum instead of using
 717       * the heavy-weight CheckedMessage wrapper.
 718       */
 719      private Key getKey(int type, String name) {
 720          Key key = new Key();
 721          key.type = type;
 722          key.name = name;
 723          key.checksum = checkKey(key);
 724          return key;
 725      }
 726  
 727      /** keys need to be strings, serialize and encode. */
 728      private String keyToBackupKey(Key key) {
 729          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 730      }
 731  
 732      /** keys need to be strings, decode and parse. */
 733      private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 734          try {
 735              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 736              if (key.checksum != checkKey(key)) {
 737                  key = null;
 738                  throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 739              }
 740              return key;
 741          } catch (InvalidProtocolBufferNanoException e) {
 742              throw new InvalidBackupException(e);
 743          } catch (IllegalArgumentException e) {
 744              throw new InvalidBackupException(e);
 745          }
 746      }
 747  
 748      /** Compute the checksum over the important bits of a key. */
 749      private long checkKey(Key key) {
 750          CRC32 checksum = new CRC32();
 751          checksum.update(key.type);
 752          checksum.update((int) (key.id &amp; 0xffff));
 753          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 754          if (!TextUtils.isEmpty(key.name)) {
 755              checksum.update(key.name.getBytes());
 756          }
 757          return checksum.getValue();











 758      }
 759  
 760      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 761      private Favorite packFavorite(Cursor c) {
 762          Favorite favorite = new Favorite();
 763          favorite.id = c.getLong(ID_INDEX);
 764          favorite.screen = c.getInt(SCREEN_INDEX);
 765          favorite.container = c.getInt(CONTAINER_INDEX);
 766          favorite.cellX = c.getInt(CELLX_INDEX);
 767          favorite.cellY = c.getInt(CELLY_INDEX);
 768          favorite.spanX = c.getInt(SPANX_INDEX);
 769          favorite.spanY = c.getInt(SPANY_INDEX);
 770          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 771          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 772              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 773              if (!TextUtils.isEmpty(iconPackage)) {
 774                  favorite.iconPackage = iconPackage;
 775              }
 776              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 777              if (!TextUtils.isEmpty(iconResource)) {
 778                  favorite.iconResource = iconResource;
 779              }
 780          }
 781          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 782              byte[] blob = c.getBlob(ICON_INDEX);
 783              if (blob != null &amp;&amp; blob.length &gt; 0) {
 784                  favorite.icon = blob;
 785              }
 786          }
 787          String title = c.getString(TITLE_INDEX);
 788          if (!TextUtils.isEmpty(title)) {
 789              favorite.title = title;
 790          }
 791          String intentDescription = c.getString(INTENT_INDEX);

 792          if (!TextUtils.isEmpty(intentDescription)) {
 793              try {
 794                  Intent intent = Intent.parseUri(intentDescription, 0);

 795                  intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 796                  favorite.intent = intent.toUri(0);
 797              } catch (URISyntaxException e) {
 798                  Log.e(TAG, &quot;Invalid intent&quot;, e);
 799              }
 800          }
 801          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 802          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 803              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 804              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 805              if (!TextUtils.isEmpty(appWidgetProvider)) {
 806                  favorite.appWidgetProvider = appWidgetProvider;
 807              }
 808          }
 809  

























 810          return favorite;
 811      }
 812  
 813      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 814      private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 815              throws IOException {
 816          Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);

 817          ContentValues values = new ContentValues();
 818          values.put(Favorites._ID, favorite.id);
 819          values.put(Favorites.SCREEN, favorite.screen);
 820          values.put(Favorites.CONTAINER, favorite.container);
 821          values.put(Favorites.CELLX, favorite.cellX);
 822          values.put(Favorites.CELLY, favorite.cellY);
 823          values.put(Favorites.SPANX, favorite.spanX);
 824          values.put(Favorites.SPANY, favorite.spanY);
 825          values.put(Favorites.ICON_TYPE, favorite.iconType);
 826          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 827              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 828              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 829          }
 830          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 831              values.put(Favorites.ICON, favorite.icon);
 832          }
 833          if (!TextUtils.isEmpty(favorite.title)) {
 834              values.put(Favorites.TITLE, favorite.title);
 835          } else {
 836              values.put(Favorites.TITLE, &quot;&quot;);
 837          }
 838          if (!TextUtils.isEmpty(favorite.intent)) {
 839              values.put(Favorites.INTENT, favorite.intent);
 840          }
 841          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 842  
 843          UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 844          long userSerialNumber =
 845                  UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 846          values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 847  
 848          DeviceProfieData currentProfile = getDeviceProfieData();
 849  
 850          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 851              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 852                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 853              }
 854              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 855              values.put(LauncherSettings.Favorites.RESTORED,
 856                      LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 857                      LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 858                      LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 859  
 860              // Verify placement
 861              if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 862                      || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 863                  restoreSuccessful = false;
 864                  throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 865              }
 866          } else {
 867              // Let LauncherModel know we&#x27;ve been here.
 868              values.put(LauncherSettings.Favorites.RESTORED, 1);











 869  
 870              // Verify placement
 871              if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 872                  if ((favorite.screen &gt;= currentProfile.hotseatCount)
 873                          || (favorite.screen == currentProfile.allappsRank)) {
 874                      restoreSuccessful = false;
 875                      throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 876                  }
 877              } else {
 878                  if ((favorite.cellX &gt;= currentProfile.desktopCols)
 879                          || (favorite.cellY &gt;= currentProfile.desktopRows)) {
 880                      restoreSuccessful = false;
 881                      throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 882                  }
 883              }
 884          }
 885  
 886          return values;
 887      }
 888  
 889      /** Serialize a Screen for persistence, including a checksum wrapper. */
 890      private Screen packScreen(Cursor c) {
 891          Screen screen = new Screen();
 892          screen.id = c.getLong(ID_INDEX);
 893          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 894          return screen;
 895      }
 896  
 897      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 898      private ContentValues unpackScreen(byte[] buffer, int dataSize)
 899              throws InvalidProtocolBufferNanoException {
 900          Screen screen = unpackProto(new Screen(), buffer, dataSize);
 901          ContentValues values = new ContentValues();
 902          values.put(WorkspaceScreens._ID, screen.id);
 903          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 904          return values;
 905      }
 906  
 907      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 908      private Resource packIcon(int dpi, Bitmap icon) {
 909          Resource res = new Resource();
 910          res.dpi = dpi;
 911          ByteArrayOutputStream os = new ByteArrayOutputStream();
 912          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 913              res.data = os.toByteArray();
 914          }
 915          return res;
 916      }
 917  
 918      /** Serialize a widget for persistence, including a checksum wrapper. */
 919      private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 920 -            ComponentName provider) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 921 +            ComponentName provider, UserHandleCompat user) {</span>
 922          final LauncherAppWidgetProviderInfo info =
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 923 -                LauncherModel.getProviderInfo(mContext, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +                LauncherModel.getProviderInfo(mContext, provider, user);</span>
 925          Widget widget = new Widget();
 926          widget.provider = provider.flattenToShortString();
 927          widget.label = info.label;
 928          widget.configure = info.configure != null;
 929          if (info.icon != 0) {
 930              widget.icon = new Resource();
 931              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 932              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 933              ByteArrayOutputStream os = new ByteArrayOutputStream();
 934              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 935                  widget.icon.data = os.toByteArray();
 936                  widget.icon.dpi = dpi;
 937              }
 938          }
 939          if (info.previewImage != 0) {
 940              widget.preview = new Resource();
 941              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 942              ByteArrayOutputStream os = new ByteArrayOutputStream();
 943              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 944                  widget.preview.data = os.toByteArray();
 945                  widget.preview.dpi = dpi;
 946              }
 947          }
 948          return widget;
 949      }
 950  
 951      /**
 952       * Deserialize a proto after verifying checksum wrapper.
 953       */
 954      private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
 955              throws InvalidProtocolBufferNanoException {
 956          MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
 957          if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
 958          return proto;
 959      }
 960  
 961      /**
 962       * Read the old journal from the input file.
 963       *
 964       * In the event of any error, just pretend we didn&#x27;t have a journal,
 965       * in that case, do a full backup.
 966       *
 967       * @param oldState the read-0only file descriptor pointing to the old journal
 968       * @return a Journal protocol buffer
 969       */
 970      private Journal readJournal(ParcelFileDescriptor oldState) {
 971          Journal journal = new Journal();
 972          if (oldState == null) {
 973              return journal;
 974          }
 975          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 976          try {
 977              int availableBytes = inStream.available();
 978              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 979              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 980                  byte[] buffer = new byte[availableBytes];
 981                  int bytesRead = 0;
 982                  boolean valid = false;
 983                  InvalidProtocolBufferNanoException lastProtoException = null;
 984                  while (availableBytes &gt; 0) {
 985                      try {
 986                          // OMG what are you doing? This is crazy inefficient!
 987                          // If we read a byte that is not ours, we will cause trouble: b/12491813
 988                          // However, we don&#x27;t know how many bytes to expect (oops).
 989                          // So we have to step through *slowly*, watching for the end.
 990                          int result = inStream.read(buffer, bytesRead, 1);
 991                          if (result &gt; 0) {
 992                              availableBytes -= result;
 993                              bytesRead += result;
 994                          } else {
 995                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 996                              // stop reading and see what there is to parse
 997                              availableBytes = 0;
 998                          }
 999                      } catch (IOException e) {
1000                          buffer = null;
1001                          availableBytes = 0;
1002                      }
1003  
1004                      // check the buffer to see if we have a valid journal
1005                      try {
1006                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1007                          // if we are here, then we have read a valid, checksum-verified journal
1008                          valid = true;
1009                          availableBytes = 0;
1010                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1011                      } catch (InvalidProtocolBufferNanoException e) {
1012                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1013                          lastProtoException = e;
1014                          journal.clear();
1015                      }
1016                  }
1017                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1018                  if (!valid) {
1019                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1020                  }
1021              }
1022          } catch (IOException e) {
1023              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1024          } finally {
1025              try {
1026                  inStream.close();
1027              } catch (IOException e) {
1028                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1029              }
1030          }
1031          return journal;
1032      }
1033  
1034      private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1035              throws IOException {
1036          writeRowToBackup(keyToBackupKey(key), proto, data);
1037      }
1038  
1039      private void writeRowToBackup(String backupKey, MessageNano proto,
1040              BackupDataOutput data) throws IOException {
1041          byte[] blob = writeCheckedBytes(proto);
1042          data.writeEntityHeader(backupKey, blob.length);
1043          data.writeEntityData(blob, blob.length);
1044          mBackupDataWasUpdated = true;
1045          if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1046      }
1047  
1048      /**
1049       * Write the new journal to the output file.
1050       *
1051       * In the event of any error, just pretend we didn&#x27;t have a journal,
1052       * in that case, do a full backup.
1053  
1054       * @param newState the write-only file descriptor pointing to the new journal
1055       * @param journal a Journal protocol buffer
1056       */
1057      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1058          FileOutputStream outStream = null;
1059          try {
1060              outStream = new FileOutputStream(newState.getFileDescriptor());
1061              final byte[] journalBytes = writeCheckedBytes(journal);
1062              outStream.write(journalBytes);
1063              outStream.close();
1064              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1065          } catch (IOException e) {
1066              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1067          }
1068      }
1069  
1070      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1071      private byte[] writeCheckedBytes(MessageNano proto) {
1072          CheckedMessage wrapper = new CheckedMessage();
1073          wrapper.payload = MessageNano.toByteArray(proto);
1074          CRC32 checksum = new CRC32();
1075          checksum.update(wrapper.payload);
1076          wrapper.checksum = checksum.getValue();
1077          return MessageNano.toByteArray(wrapper);
1078      }
1079  
1080      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1081      private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1082              throws InvalidProtocolBufferNanoException {
1083          CheckedMessage wrapper = new CheckedMessage();
1084          MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1085          CRC32 checksum = new CRC32();
1086          checksum.update(wrapper.payload);
1087          if (wrapper.checksum != checksum.getValue()) {
1088              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1089          }
1090          return wrapper.payload;
1091      }
1092  
1093      private boolean initializeIconCache() {
1094          if (mIconCache != null) {
1095              return true;
1096          }
1097  
1098          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1099          if (appState == null) {
1100              Throwable stackTrace = new Throwable();
1101              stackTrace.fillInStackTrace();
1102              Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);





1103              return false;
1104          }
1105          mIconCache = appState.getIconCache();
1106          return mIconCache != null;
1107      }
1108  
1109  
1110      /**
1111       * @return true if the launcher is in a state to support backup
1112       */
1113      private boolean launcherIsReady() {
1114          ContentResolver cr = mContext.getContentResolver();
1115          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1116          if (cursor == null) {
1117              // launcher data has been wiped, do nothing
1118              return false;
1119          }
1120          cursor.close();
1121  
1122          if (!initializeIconCache()) {
1123              // launcher services are unavailable, try again later
1124              dataChanged();
1125              return false;
1126          }
1127  
1128          return true;
1129      }
1130  
1131      private String getUserSelectionArg() {
1132          return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1133                  .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1134      }
1135  
1136      private class InvalidBackupException extends IOException {



1137          private InvalidBackupException(Throwable cause) {
1138              super(cause);
1139          }
1140  
1141          public InvalidBackupException(String reason) {
1142              super(reason);
1143          }
1144      }


















































1145  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            