<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>35</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    35
                    <a href="34.html">prev</a>
                    <a href="36.html">next</a>
                    <a href="35_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    AriaLyy/Aria_b301590869f31d3a44039c34fcd8bec944b5b7f8_Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;b301590869f31d3a44039c34fcd8bec944b5b7f8:Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;b301590869f31d3a44039c34fcd8bec944b5b7f8^1:Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;b301590869f31d3a44039c34fcd8bec944b5b7f8^2:Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;426c148370677ae2daf8fd879d4a76bdfd2b7f3d:Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.content.Context;
  19 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  20 import android.util.Log;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  21 import android.util.SparseArray;</span>
  22 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  23 import android.util.SparseArray;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  24 import com.arialyy.aria.core.AriaManager;</span>
  25 =======
  26 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  27 import com.arialyy.aria.core.AriaManager;
  28 import com.arialyy.aria.core.download.DownloadEntity;
  29 import com.arialyy.aria.core.inf.AbsNormalEntity;
  30 import com.arialyy.aria.core.inf.AbsTaskEntity;
  31 import com.arialyy.aria.core.inf.IDownloadListener;
  32 import com.arialyy.aria.core.inf.IEventListener;
  33 import com.arialyy.aria.orm.DbEntity;
  34 import com.arialyy.aria.util.ALog;
  35 import com.arialyy.aria.util.CommonUtil;
  36 import com.arialyy.aria.util.DbHelper;
  37 import java.io.File;
  38 import java.util.ArrayList;
  39 import java.util.HashMap;
  40 import java.util.HashSet;
  41 import java.util.List;
  42 import java.util.Map;
  43 import java.util.Properties;
  44 import java.util.Set;
  45 import java.util.Timer;
  46 import java.util.TimerTask;
  47 import java.util.concurrent.ExecutorService;
  48 import java.util.concurrent.Executors;
  49 
  50 /**
  51  * Created by AriaL on 2017/7/1.
  52  * 任务处理器
  53  */
<abbr title="  54 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt;">  54 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;🔵</abbr>
  55     implements Runnable, IUtil {
  56   private static final String STATE = &quot;_state_&quot;;
  57   private static final String RECORD = &quot;_record_&quot;;
  58   /**
  59    * 小于1m的文件不启用多线程
  60    */
  61   protected static final long SUB_LEN = 1024 * 1024;
  62 
  63   private final String TAG = &quot;AbsFileer&quot;;
  64   protected IEventListener mListener;
  65   protected TASK_ENTITY mTaskEntity;
  66   protected ENTITY mEntity;
  67   protected Context mContext;
  68   protected File mTempFile; //文件
  69   protected StateConstance mConstance;
  70   private ExecutorService mFixedThreadPool;
  71   //总线程数
  72   protected int mTotalThreadNum;
  73   //启动线程数
  74   private int mStartThreadNum;
  75   //已完成的线程数
  76   private int mCompleteThreadNum;
  77 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  78   private SparseArray&lt;AbsThreadTask&gt; mTask = new SparseArray&lt;&gt;();</span>
  79 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  80 </span>
  81 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  82   private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();</span>
  83 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  84 
  85   private Timer mTimer;
  86   @Deprecated private File mConfigFile;
  87   /**
  88    * 进度刷新间隔
  89    */
  90   private long mUpdateInterval = 1000;
  91   private TaskRecord mRecord;
  92 
  93   protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
  94     mListener = listener;
  95     mTaskEntity = taskEntity;
  96     mEntity = mTaskEntity.getEntity();
  97     mContext = AriaManager.APP;
  98     mConstance = new StateConstance();
  99   }
 100 
 101   public void setNewTask(boolean newTask) {
 102     mTaskEntity.setNewTask(newTask);
 103   }
 104 
 105   @Override public void setMaxSpeed(double maxSpeed) {
 106     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 107       AbsThreadTask task = mTask.get(i);
 108       if (task != null) {
 109         task.setMaxSpeed(maxSpeed);
 110       }
 111     }
 112   }
 113 
 114   @Override public void run() {
 115     if (mConstance.isRunning) {
 116       return;
 117     }
 118     startFlow();
 119   }
 120 
 121   /**
 122    * 开始流程
 123    */
 124   private void startFlow() {
 125     mConstance.resetState();
 126     checkTask();
 127     mConstance.TASK_RECORD = mRecord;
 128     if (mListener instanceof IDownloadListener) {
 129       ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 130     }
 131     if (!mTaskEntity.isSupportBP()) {
 132       mTotalThreadNum = 1;
 133       mStartThreadNum = 1;
 134       handleNoSupportBP();
 135     } else {
 136       mTotalThreadNum =
 137           mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 138       handleBreakpoint();
 139     }
 140     mConstance.START_THREAD_NUM = mTotalThreadNum;
 141     /*
 142      * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 143      * 动态长度条件：
 144      * 1、总线程数为1，并且是新任务
 145      * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 146      */
 147     if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 148         || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 149       mConstance.isOpenDynamicFile = true;
 150     }
 151     startTimer();
 152   }
 153 
 154   /**
 155    * 设置新任务的最大线程数
 156    */
 157   protected abstract int setNewTaskThreadNum();
 158 
 159   /**
 160    * 启动进度获取定时器
 161    */
 162   private void startTimer() {
 163     mTimer = new Timer(true);
 164     mTimer.schedule(new TimerTask() {
 165       @Override public void run() {
 166         if (mConstance.isComplete()
 167             || mConstance.isStop()
 168             || mConstance.isCancel()
 169             || !mConstance.isRunning) {
 170           closeTimer();
 171         } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 172           mListener.onProgress(mConstance.CURRENT_LOCATION);
 173         }
 174       }
 175     }, 0, mUpdateInterval);
 176   }
 177 
 178   protected void closeTimer() {
 179     if (mTimer != null) {
 180       mTimer.purge();
 181       mTimer.cancel();
 182       mTimer = null;
 183     }
 184   }
 185 
 186   /**
 187    * 设置定时器更新间隔
 188    *
 189    * @param interval 单位毫秒，不能小于0
 190    */
 191   protected void setUpdateInterval(long interval) {
 192     if (interval &lt; 0) {
 193       ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 194       return;
 195     }
 196     mUpdateInterval = interval;
 197   }
 198 
 199   @Override public long getFileSize() {
 200     return mEntity.getFileSize();
 201   }
 202 
 203   /**
 204    * 获取当前任务位置
 205    */
 206   @Override public long getCurrentLocation() {
 207     return mConstance.CURRENT_LOCATION;
 208   }
 209 
 210   @Override public boolean isRunning() {
 211     return mConstance.isRunning;
 212   }
 213 
 214   @Override public void cancel() {
 215     closeTimer();
 216     mConstance.isRunning = false;
 217     mConstance.isCancel = true;
 218     if (mFixedThreadPool != null) {
 219       mFixedThreadPool.shutdown();
 220     }
 221     for (int i = 0; i &lt; mStartThreadNum; i++) {
 222       AbsThreadTask task = mTask.get(i);
 223       if (task != null) {
 224         task.cancel();
 225       }
 226     }
 227   }
 228 
 229   @Override public void stop() {
 230     closeTimer();
 231     mConstance.isRunning = false;
 232     mConstance.isStop = true;
 233     if (mConstance.isComplete()) return;
 234     if (mFixedThreadPool != null) {
 235       mFixedThreadPool.shutdown();
 236     }
 237     for (int i = 0; i &lt; mStartThreadNum; i++) {
 238       AbsThreadTask task = mTask.get(i);
 239       if (task != null) {
 240         task.stop();
 241       }
 242     }
 243   }
 244 
 245   /**
 246    * 直接调用的时候会自动启动线程执行
 247    */
 248   @Override public void start() {
 249     new Thread(this).start();
 250   }
 251 
 252   @Override public void resume() {
 253     start();
 254   }
 255 
 256   /**
 257    * 检查任务、检查线程数
 258    * 新任务条件：
 259    * 1、文件不存在
 260    * 2、任务记录文件缺失或不匹配
 261    * 3、数据库记录不存在
 262    * 4、不支持断点，则是新任务
 263    */
 264   private void checkTask() {
 265     mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 266     if (mConfigFile.exists()) {
 267       convertDb();
 268     } else {
 269       mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 270       if (mRecord == null) {
 271         initRecord();
 272         mTaskEntity.setNewTask(true);
 273       } else {
 274         if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 275           initRecord();
 276           mTaskEntity.setNewTask(true);
 277         } else if (mTempFile.length() == 0) {
 278           mRecord.deleteData();
 279           initRecord();
 280           mTaskEntity.setNewTask(true);
 281         } else {
 282           for (ThreadRecord tr : mRecord.threadRecords) {
 283             if (tr.isComplete) {
 284               mCompleteThreadNum++;
 285             } else {
 286               mStartThreadNum++;
 287             }
 288           }
 289           mTotalThreadNum = mRecord.threadRecords.size();
 290           mTaskEntity.setNewTask(false);
 291         }
 292       }
 293     }
 294   }
 295 
 296   /**
 297    * convertDb 为兼容性代码
 298    * 从3.4.1开始，线程配置信息将存储在数据库中。
 299    * 将配置文件的内容复制到数据库中，并将配置文件删除
 300    */
 301   private void convertDb() {
 302     List&lt;RecordWrapper&gt; records =
 303         DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 304             mTaskEntity.getKey());
 305     if (records == null || records.size() == 0) {
 306       Properties pro = CommonUtil.loadConfig(mConfigFile);
 307       if (pro.isEmpty()) {
 308         mTaskEntity.setNewTask(true);
 309         return;
 310       }
 311       initRecord();
 312       Set&lt;Object&gt; keys = pro.keySet();
 313       // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 314       // 第一步应该是record 和 state去重取正确的线程数
 315       Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 316       for (Object key : keys) {
 317         String str = String.valueOf(key);
 318         int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 319         set.add(i);
 320       }
 321       int threadNum = set.size();
 322       if (threadNum == 0) {
 323         mTaskEntity.setNewTask(true);
 324         return;
 325       }
 326       mRecord.threadNum = threadNum;
 327       mTotalThreadNum = threadNum;
 328 
 329       for (int i = 0; i &lt; threadNum; i++) {
 330         ThreadRecord tRecord = new ThreadRecord();
 331         tRecord.key = mRecord.filePath;
 332         Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 333         Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
 334         if (state != null &amp;&amp; Integer.parseInt(String.valueOf(state)) == 1) {
 335           mCompleteThreadNum++;
 336           tRecord.isComplete = true;
 337           continue;
 338         }
 339         mStartThreadNum++;
 340         if (record != null) {
 341           Long temp = Long.parseLong(String.valueOf(record));
 342           tRecord.startLocation = temp &gt; 0 ? temp : 0;
 343         } else {
 344           tRecord.startLocation = 0;
 345         }
 346         mRecord.threadRecords.add(tRecord);
 347       }
 348       mConfigFile.delete();
 349     }
 350   }
 351 
 352   /**
 353    * 初始化记录
 354    */
 355   private void initRecord() {
 356     mRecord = new TaskRecord();
 357     mRecord.fileName = mEntity.getFileName();
 358     mRecord.filePath = mTaskEntity.getKey();
 359     mRecord.threadRecords = new ArrayList&lt;&gt;();
 360     mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 361     if (mRecord.isGroupRecord) {
 362       if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 363         mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 364       }
 365     }
 366   }
 367 
 368   /**
 369    * 保存任务记录
 370    */
 371   private void saveRecord() {
 372     mRecord.save();
 373     for (ThreadRecord tr : mRecord.threadRecords) {
 374       tr.save();
 375     }
 376   }
 377 
 378   public TaskRecord getRecord() {
 379     return mRecord;
 380   }
 381 
 382   /**
 383    * 恢复记录地址
 384    *
 385    * @return {@code true}任务已完成
 386    */
 387   private boolean resumeRecordLocation(int i, long startL, long endL) {
 388     mConstance.CURRENT_LOCATION += endL - startL;
 389     ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));
 390     mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 391     mConstance.STOP_NUM++;
 392     mConstance.CANCEL_NUM++;
 393     if (mConstance.isComplete()) {
 394       mRecord.deleteData();
 395       mListener.onComplete();
 396       mConstance.isRunning = false;
 397       return true;
 398     }
 399     return false;
 400   }
 401 
 402   /**
 403    * 启动断点任务时，创建单线程任务
 404    *
 405    * @param i 线程id
 406    * @param startL 该任务起始位置
 407    * @param endL 该任务结束位置
 408    * @param fileLength 该任务需要处理的文件长度
 409    */
 410   private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 411       ThreadRecord record) {
 412     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 413     config.FILE_SIZE = fileLength;
 414     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 415     config.TEMP_FILE = mTempFile;
 416     config.THREAD_ID = i;
 417     config.START_LOCATION = startL;
 418     config.END_LOCATION = endL;
 419     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 420     config.TASK_ENTITY = mTaskEntity;
 421     config.THREAD_RECORD = record;
 422     return selectThreadTask(config);
 423   }
 424 
 425   private void handleBreakpoint() {
 426     long fileLength = mEntity.getFileSize();
 427     long blockSize = fileLength / mTotalThreadNum;
 428     int[] threadId = new int[mTotalThreadNum];
 429     int rl = 0;
 430 
 431     mRecord.fileLength = fileLength;
 432     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 433       threadId[i] = -1;
 434     }
 435     if (mTaskEntity.isNewTask() &amp;&amp; !handleNewTask()) {
 436       return;
 437     }
 438     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 439       long startL = i * blockSize, endL = (i + 1) * blockSize;
 440       ThreadRecord tr;
 441       boolean isNewTr = false;  // 是否是新的线程记录
 442       if (mTaskEntity.isNewTask()) {
 443         tr = new ThreadRecord();
 444         tr.key = mRecord.filePath;
 445         tr.threadId = i;
 446         isNewTr = true;
 447       } else {
 448         tr = mRecord.threadRecords.get(i);
 449       }
 450       if (tr.isComplete) {//该线程已经完成
 451         if (resumeRecordLocation(i, startL, endL)) return;
 452         continue;
 453       }
 454 
 455       //如果有记录，则恢复任务
 456       if (tr.startLocation &gt;= 0) {
 457         Long r = tr.startLocation;
 458         //记录的位置需要在线程区间中
 459         if (startL &lt; r &amp;&amp; r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL)) {
 460           mConstance.CURRENT_LOCATION += r - startL;
 461           startL = r;
 462         }
 463         ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));
 464       }
 465       //最后一个线程的结束位置即为文件的总长度
 466       if (i == (mTotalThreadNum - 1)) {
 467         endL = fileLength;
 468       }
 469       // 更新记录
 470       tr.startLocation = startL;
 471       tr.endLocation = endL;
 472       if (isNewTr) {
 473         mRecord.threadRecords.add(tr);
 474       }
 475       AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 476       if (task == null) return;
 477       mTask.put(i, task);
 478       threadId[rl] = i;
 479       rl++;
 480     }
<abbr title=" 481     if (mConstance.CURRENT_LOCATION != 0 &amp;&amp; mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress()) {"> 481     if (mConstance.CURRENT_LOCATION != 0 &amp;&amp; mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress()) 🔵</abbr>
 482       ALog.d(TAG, &quot;进度修正&quot;);
 483       mEntity.setCurrentProgress(mConstance.CURRENT_LOCATION);
 484     }
 485     saveRecord();
 486     startThreadTask(threadId);
 487   }
 488 
 489   /**
 490    * 启动单线程任务
 491    */
 492   private void startThreadTask(int[] recordL) {
 493     if (mConstance.CURRENT_LOCATION &gt; 0) {
 494       mListener.onResume(mConstance.CURRENT_LOCATION);
 495     } else {
 496       mListener.onStart(mConstance.CURRENT_LOCATION);
 497     }
 498     mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 499     for (int l : recordL) {
 500       if (l == -1) continue;
 501       Runnable task = mTask.get(l);
 502       if (task != null) {
 503         mFixedThreadPool.execute(task);
 504       }
 505     }
 506   }
 507 
 508   /**
 509    * 重试线程任务，只有线程创建成功才能重试
 510    */
 511   public void retryThradTask() {
 512     if (mTask == null || mTask.size() == 0) {
 513       ALog.w(TAG, &quot;没有线程任务&quot;);
 514       return;
 515     }
 516     Set&lt;Integer&gt; keys = mTask.keySet();
 517     for (Integer key : keys) {
 518       AbsThreadTask task = mTask.get(key);
 519       if (task != null &amp;&amp; !task.isThreadComplete()) {
 520         task.getConfig().START_LOCATION = task.getCurrentLocation();
 521         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),
 522             key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));
 523         mFixedThreadPool.execute(task);
 524       }
 525     }
 526   }
 527 
 528   /**
 529    * 处理新任务
 530    *
 531    * @return {@code true}创建新任务失败
 532    */
 533   protected abstract boolean handleNewTask();
 534 
 535   /**
 536    * 处理不支持断点的任务
 537    */
 538   private void handleNoSupportBP() {
 539     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 540     config.FILE_SIZE = mEntity.getFileSize();
 541     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 542     config.TEMP_FILE = mTempFile;
 543     config.THREAD_ID = 0;
 544     config.START_LOCATION = 0;
 545     config.END_LOCATION = config.FILE_SIZE;
 546     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 547     config.TASK_ENTITY = mTaskEntity;
 548     AbsThreadTask task = selectThreadTask(config);
 549     if (task == null) return;
 550     mTask.put(0, task);
 551     mFixedThreadPool = Executors.newFixedThreadPool(1);
 552     mFixedThreadPool.execute(task);
 553     mListener.onStart(0);
 554   }
 555 
 556   /**
 557    * 选择单任务线程的类型
 558    */
 559   protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 560 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.content.Context;
  19 import android.util.Log;
  20 import com.arialyy.aria.core.AriaManager;
  21 import com.arialyy.aria.core.download.DownloadEntity;
  22 import com.arialyy.aria.core.inf.AbsNormalEntity;
  23 import com.arialyy.aria.core.inf.AbsTaskEntity;
  24 import com.arialyy.aria.core.inf.IDownloadListener;
  25 import com.arialyy.aria.core.inf.IEventListener;
  26 import com.arialyy.aria.orm.DbEntity;
  27 import com.arialyy.aria.util.ALog;
  28 import com.arialyy.aria.util.CommonUtil;
  29 import com.arialyy.aria.util.DbHelper;
  30 import java.io.File;
  31 import java.util.ArrayList;
  32 import java.util.HashMap;
  33 import java.util.HashSet;
  34 import java.util.List;
  35 import java.util.Map;
  36 import java.util.Properties;
  37 import java.util.Set;
  38 import java.util.Timer;
  39 import java.util.TimerTask;
  40 import java.util.concurrent.ExecutorService;
  41 import java.util.concurrent.Executors;
  42 
  43 /**
  44  * Created by AriaL on 2017/7/1.
  45  * 任务处理器
  46  */
<abbr title="  47 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt;">  47 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;🔵</abbr>
  48     implements Runnable, IUtil {
  49   private static final String STATE = &quot;_state_&quot;;
  50   private static final String RECORD = &quot;_record_&quot;;
  51   /**
  52    * 小于1m的文件不启用多线程
  53    */
  54   protected static final long SUB_LEN = 1024 * 1024;
  55 
  56   private final String TAG = &quot;AbsFileer&quot;;
  57   protected IEventListener mListener;
  58   protected TASK_ENTITY mTaskEntity;
  59   protected ENTITY mEntity;
  60   protected Context mContext;
  61   protected File mTempFile; //文件
  62   protected StateConstance mConstance;
  63   private ExecutorService mFixedThreadPool;
  64   //总线程数
  65   protected int mTotalThreadNum;
  66   //启动线程数
  67   private int mStartThreadNum;
  68   //已完成的线程数
  69   private int mCompleteThreadNum;
  70   private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();
  71 
  72   private Timer mTimer;
  73   @Deprecated private File mConfigFile;
  74   /**
  75    * 进度刷新间隔
  76    */
  77   private long mUpdateInterval = 1000;
  78   private TaskRecord mRecord;
  79 
  80   protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
  81     mListener = listener;
  82     mTaskEntity = taskEntity;
  83     mEntity = mTaskEntity.getEntity();
  84     mContext = AriaManager.APP;
  85     mConstance = new StateConstance();
  86   }
  87 
  88   public void setNewTask(boolean newTask) {
  89     mTaskEntity.setNewTask(newTask);
  90   }
  91 
  92   @Override public void setMaxSpeed(double maxSpeed) {
  93     for (int i = 0; i &lt; mTotalThreadNum; i++) {
  94       AbsThreadTask task = mTask.get(i);
  95       if (task != null) {
  96         task.setMaxSpeed(maxSpeed);
  97       }
  98     }
  99   }
 100 
 101   @Override public void run() {
 102     if (mConstance.isRunning) {
 103       return;
 104     }
 105     startFlow();
 106   }
 107 
 108   /**
 109    * 开始流程
 110    */
 111   private void startFlow() {
 112     mConstance.resetState();
 113     checkTask();
 114     mConstance.TASK_RECORD = mRecord;
 115     if (mListener instanceof IDownloadListener) {
 116       ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 117     }
 118     if (!mTaskEntity.isSupportBP()) {
 119       mTotalThreadNum = 1;
 120       mStartThreadNum = 1;
 121       handleNoSupportBP();
 122     } else {
 123       mTotalThreadNum =
 124           mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 125       handleBreakpoint();
 126     }
 127     mConstance.START_THREAD_NUM = mTotalThreadNum;
 128     /*
 129      * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 130      * 动态长度条件：
 131      * 1、总线程数为1，并且是新任务
 132      * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 133      */
 134     if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 135         || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 136       mConstance.isOpenDynamicFile = true;
 137     }
 138     startTimer();
 139   }
 140 
 141   /**
 142    * 设置新任务的最大线程数
 143    */
 144   protected abstract int setNewTaskThreadNum();
 145 
 146   /**
 147    * 启动进度获取定时器
 148    */
 149   private void startTimer() {
 150     mTimer = new Timer(true);
 151     mTimer.schedule(new TimerTask() {
 152       @Override public void run() {
 153         if (mConstance.isComplete()
 154             || mConstance.isStop()
 155             || mConstance.isCancel()
 156             || !mConstance.isRunning) {
 157           closeTimer();
 158         } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 159           mListener.onProgress(mConstance.CURRENT_LOCATION);
 160         }
 161       }
 162     }, 0, mUpdateInterval);
 163   }
 164 
 165   protected void closeTimer() {
 166     if (mTimer != null) {
 167       mTimer.purge();
 168       mTimer.cancel();
 169       mTimer = null;
 170     }
 171   }
 172 
 173   /**
 174    * 设置定时器更新间隔
 175    *
 176    * @param interval 单位毫秒，不能小于0
 177    */
 178   protected void setUpdateInterval(long interval) {
 179     if (interval &lt; 0) {
 180       ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 181       return;
 182     }
 183     mUpdateInterval = interval;
 184   }
 185 
 186   @Override public long getFileSize() {
 187     return mEntity.getFileSize();
 188   }
 189 
 190   /**
 191    * 获取当前任务位置
 192    */
 193   @Override public long getCurrentLocation() {
 194     return mConstance.CURRENT_LOCATION;
 195   }
 196 
 197   @Override public boolean isRunning() {
 198     return mConstance.isRunning;
 199   }
 200 
 201   @Override public void cancel() {
 202     closeTimer();
 203     mConstance.isRunning = false;
 204     mConstance.isCancel = true;
 205     if (mFixedThreadPool != null) {
 206       mFixedThreadPool.shutdown();
 207     }
 208     for (int i = 0; i &lt; mStartThreadNum; i++) {
 209       AbsThreadTask task = mTask.get(i);
 210       if (task != null) {
 211         task.cancel();
 212       }
 213     }
 214   }
 215 
 216   @Override public void stop() {
 217     closeTimer();
 218     mConstance.isRunning = false;
 219     mConstance.isStop = true;
 220     if (mConstance.isComplete()) return;
 221     if (mFixedThreadPool != null) {
 222       mFixedThreadPool.shutdown();
 223     }
 224     for (int i = 0; i &lt; mStartThreadNum; i++) {
 225       AbsThreadTask task = mTask.get(i);
 226       if (task != null) {
 227         task.stop();
 228       }
 229     }
 230   }
 231 
 232   /**
 233    * 直接调用的时候会自动启动线程执行
 234    */
 235   @Override public void start() {
 236     new Thread(this).start();
 237   }
 238 
 239   @Override public void resume() {
 240     start();
 241   }
 242 
 243   /**
 244    * 检查任务、检查线程数
 245    * 新任务条件：
 246    * 1、文件不存在
 247    * 2、任务记录文件缺失或不匹配
 248    * 3、数据库记录不存在
 249    * 4、不支持断点，则是新任务
 250    */
 251   private void checkTask() {
 252     mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 253     if (mConfigFile.exists()) {
 254       convertDb();
 255     } else {
 256       mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 257       if (mRecord == null) {
 258         initRecord();
 259         mTaskEntity.setNewTask(true);
 260       } else {
 261         if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 262           initRecord();
 263           mTaskEntity.setNewTask(true);
 264         } else if (mTempFile.length() == 0) {
 265           mRecord.deleteData();
 266           initRecord();
 267           mTaskEntity.setNewTask(true);
 268         } else {
 269           for (ThreadRecord tr : mRecord.threadRecords) {
 270             if (tr.isComplete) {
 271               mCompleteThreadNum++;
 272             } else {
 273               mStartThreadNum++;
 274             }
 275           }
 276           mTotalThreadNum = mRecord.threadRecords.size();
 277           mTaskEntity.setNewTask(false);
 278         }
 279       }
 280     }
 281   }
 282 
 283   /**
 284    * convertDb 为兼容性代码
 285    * 从3.4.1开始，线程配置信息将存储在数据库中。
 286    * 将配置文件的内容复制到数据库中，并将配置文件删除
 287    */
 288   private void convertDb() {
 289     List&lt;RecordWrapper&gt; records =
 290         DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 291             mTaskEntity.getKey());
 292     if (records == null || records.size() == 0) {
 293       Properties pro = CommonUtil.loadConfig(mConfigFile);
 294       if (pro.isEmpty()) {
 295         mTaskEntity.setNewTask(true);
 296         return;
 297       }
 298       initRecord();
 299       Set&lt;Object&gt; keys = pro.keySet();
 300       // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 301       // 第一步应该是record 和 state去重取正确的线程数
 302       Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 303       for (Object key : keys) {
 304         String str = String.valueOf(key);
 305         int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 306         set.add(i);
 307       }
 308       int threadNum = set.size();
 309       if (threadNum == 0) {
 310         mTaskEntity.setNewTask(true);
 311         return;
 312       }
 313       mRecord.threadNum = threadNum;
 314       mTotalThreadNum = threadNum;
 315 
 316       for (int i = 0; i &lt; threadNum; i++) {
 317         ThreadRecord tRecord = new ThreadRecord();
 318         tRecord.key = mRecord.filePath;
 319         Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 320         Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
 321         if (state != null &amp;&amp; Integer.parseInt(String.valueOf(state)) == 1) {
 322           mCompleteThreadNum++;
 323           tRecord.isComplete = true;
 324           continue;
 325         }
 326         mStartThreadNum++;
 327         if (record != null) {
 328           Long temp = Long.parseLong(String.valueOf(record));
 329           tRecord.startLocation = temp &gt; 0 ? temp : 0;
 330         } else {
 331           tRecord.startLocation = 0;
 332         }
 333         mRecord.threadRecords.add(tRecord);
 334       }
 335       mConfigFile.delete();
 336     }
 337   }
 338 
 339   /**
 340    * 初始化记录
 341    */
 342   private void initRecord() {
 343     mRecord = new TaskRecord();
 344     mRecord.fileName = mEntity.getFileName();
 345     mRecord.filePath = mTaskEntity.getKey();
 346     mRecord.threadRecords = new ArrayList&lt;&gt;();
 347     mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 348     if (mRecord.isGroupRecord) {
 349       if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 350         mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 351       }
 352     }
 353   }
 354 
 355   /**
 356    * 保存任务记录
 357    */
 358   private void saveRecord() {
 359     mRecord.save();
 360     for (ThreadRecord tr : mRecord.threadRecords) {
 361       tr.save();
 362     }
 363   }
 364 
 365   public TaskRecord getRecord() {
 366     return mRecord;
 367   }
 368 
 369   /**
 370    * 恢复记录地址
 371    *
 372    * @return {@code true}任务已完成
 373    */
 374   private boolean resumeRecordLocation(int i, long startL, long endL) {
 375     mConstance.CURRENT_LOCATION += endL - startL;
 376     ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));
 377     mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 378     mConstance.STOP_NUM++;
 379     mConstance.CANCEL_NUM++;
 380     if (mConstance.isComplete()) {
 381       mRecord.deleteData();
 382       mListener.onComplete();
 383       mConstance.isRunning = false;
 384       return true;
 385     }
 386     return false;
 387   }
 388 
 389   /**
 390    * 启动断点任务时，创建单线程任务
 391    *
 392    * @param i 线程id
 393    * @param startL 该任务起始位置
 394    * @param endL 该任务结束位置
 395    * @param fileLength 该任务需要处理的文件长度
 396    */
 397   private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 398       ThreadRecord record) {
 399     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 400     config.FILE_SIZE = fileLength;
 401     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 402     config.TEMP_FILE = mTempFile;
 403     config.THREAD_ID = i;
 404     config.START_LOCATION = startL;
 405     config.END_LOCATION = endL;
 406     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 407     config.TASK_ENTITY = mTaskEntity;
 408     config.THREAD_RECORD = record;
 409     return selectThreadTask(config);
 410   }
 411 
 412   private void handleBreakpoint() {
 413     long fileLength = mEntity.getFileSize();
 414     long blockSize = fileLength / mTotalThreadNum;
 415     int[] threadId = new int[mTotalThreadNum];
 416     int rl = 0;
 417 
 418     mRecord.fileLength = fileLength;
 419     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 420       threadId[i] = -1;
 421     }
 422     if (mTaskEntity.isNewTask() &amp;&amp; !handleNewTask()) {
 423       return;
 424     }
 425     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 426       long startL = i * blockSize, endL = (i + 1) * blockSize;
 427       ThreadRecord tr;
 428       boolean isNewTr = false;  // 是否是新的线程记录
 429       if (mTaskEntity.isNewTask()) {
 430         tr = new ThreadRecord();
 431         tr.key = mRecord.filePath;
 432         tr.threadId = i;
 433         isNewTr = true;
 434       } else {
 435         tr = mRecord.threadRecords.get(i);
 436       }
 437       if (tr.isComplete) {//该线程已经完成
 438         if (resumeRecordLocation(i, startL, endL)) return;
 439         continue;
 440       }
 441 
 442       //如果有记录，则恢复任务
 443       if (tr.startLocation &gt;= 0) {
 444         Long r = tr.startLocation;
 445         //记录的位置需要在线程区间中
 446         if (startL &lt; r &amp;&amp; r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL)) {
 447           mConstance.CURRENT_LOCATION += r - startL;
 448           startL = r;
 449         }
 450         ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));
 451       }
 452       //最后一个线程的结束位置即为文件的总长度
 453       if (i == (mTotalThreadNum - 1)) {
 454         endL = fileLength;
 455       }
 456       // 更新记录
 457       tr.startLocation = startL;
 458       tr.endLocation = endL;
 459       if (isNewTr) {
 460         mRecord.threadRecords.add(tr);
 461       }
 462       AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 463       if (task == null) return;
 464       mTask.put(i, task);
 465       threadId[rl] = i;
 466       rl++;
 467     }
<abbr title=" 468     if (mConstance.CURRENT_LOCATION != 0 &amp;&amp; mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress()) {"> 468     if (mConstance.CURRENT_LOCATION != 0 &amp;&amp; mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress()) 🔵</abbr>
 469       ALog.d(TAG, &quot;进度修正&quot;);
 470       mEntity.setCurrentProgress(mConstance.CURRENT_LOCATION);
 471     }
 472     saveRecord();
 473     startThreadTask(threadId);
 474   }
 475 
 476   /**
 477    * 启动单线程任务
 478    */
 479   private void startThreadTask(int[] recordL) {
 480     if (mConstance.CURRENT_LOCATION &gt; 0) {
 481       mListener.onResume(mConstance.CURRENT_LOCATION);
 482     } else {
 483       mListener.onStart(mConstance.CURRENT_LOCATION);
 484     }
 485     mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 486     for (int l : recordL) {
 487       if (l == -1) continue;
 488       Runnable task = mTask.get(l);
 489       if (task != null) {
 490         mFixedThreadPool.execute(task);
 491       }
 492     }
 493   }
 494 
 495   /**
 496    * 重试线程任务，只有线程创建成功才能重试
 497    */
 498   public void retryThradTask() {
 499     if (mTask == null || mTask.size() == 0) {
 500       ALog.w(TAG, &quot;没有线程任务&quot;);
 501       return;
 502     }
 503     Set&lt;Integer&gt; keys = mTask.keySet();
 504     for (Integer key : keys) {
 505       AbsThreadTask task = mTask.get(key);
 506       if (task != null &amp;&amp; !task.isThreadComplete()) {
 507         task.getConfig().START_LOCATION = task.getCurrentLocation();
 508         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),
 509             key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));
 510         mFixedThreadPool.execute(task);
 511       }
 512     }
 513   }
 514 
 515   /**
 516    * 处理新任务
 517    *
 518    * @return {@code true}创建新任务失败
 519    */
 520   protected abstract boolean handleNewTask();
 521 
 522   /**
 523    * 处理不支持断点的任务
 524    */
 525   private void handleNoSupportBP() {
 526     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 527     config.FILE_SIZE = mEntity.getFileSize();
 528     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 529     config.TEMP_FILE = mTempFile;
 530     config.THREAD_ID = 0;
 531     config.START_LOCATION = 0;
 532     config.END_LOCATION = config.FILE_SIZE;
 533     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 534     config.TASK_ENTITY = mTaskEntity;
 535     AbsThreadTask task = selectThreadTask(config);
 536     if (task == null) return;
 537     mTask.put(0, task);
 538     mFixedThreadPool = Executors.newFixedThreadPool(1);
 539     mFixedThreadPool.execute(task);
 540     mListener.onStart(0);
 541   }
 542 
 543   /**
 544    * 选择单任务线程的类型
 545    */
 546   protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 547 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.content.Context;
  19 import android.util.Log;
  20 import com.arialyy.aria.core.AriaManager;
  21 import com.arialyy.aria.core.download.DownloadEntity;
  22 import com.arialyy.aria.core.inf.AbsNormalEntity;
  23 import com.arialyy.aria.core.inf.AbsTaskEntity;
  24 import com.arialyy.aria.core.inf.IDownloadListener;
  25 import com.arialyy.aria.core.inf.IEventListener;
  26 import com.arialyy.aria.orm.DbEntity;
  27 import com.arialyy.aria.util.ALog;
  28 import com.arialyy.aria.util.CommonUtil;
  29 import com.arialyy.aria.util.DbHelper;
  30 import java.io.File;
  31 import java.util.ArrayList;
  32 import java.util.HashMap;
  33 import java.util.HashSet;
  34 import java.util.List;
  35 import java.util.Map;
  36 import java.util.Properties;
  37 import java.util.Set;
  38 import java.util.Timer;
  39 import java.util.TimerTask;
  40 import java.util.concurrent.ExecutorService;
  41 import java.util.concurrent.Executors;
  42 
  43 
  44 /**
  45  * Created by AriaL on 2017/7/1.
  46  * 任务处理器
  47  */
<abbr title="  48 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt; implements Runnable , IUtil {">  48 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;🔵</abbr>
  49   private static final String STATE = &quot;_state_&quot;;
  50 
  51   private static final String RECORD = &quot;_record_&quot;;
  52 
  53   /**
  54    * 小于1m的文件不启用多线程
  55    */
  56   protected static final long SUB_LEN = 1024 * 1024;
  57 
  58   private final String TAG = &quot;AbsFileer&quot;;
  59 
  60   protected IEventListener mListener;
  61 
  62   protected TASK_ENTITY mTaskEntity;
  63 
  64   protected ENTITY mEntity;
  65 
  66   protected Context mContext;
  67 
  68   //文件
  69   protected File mTempFile; //文件
  70 
  71   protected StateConstance mConstance;
  72 
  73   private ExecutorService mFixedThreadPool;
  74 
  75   //总线程数
  76   //总线程数
  77   protected int mTotalThreadNum;
  78 
  79   //启动线程数
  80   //启动线程数
  81   private int mStartThreadNum;
  82 
  83   //已完成的线程数
  84   //已完成的线程数
  85   private int mCompleteThreadNum;
  86 
  87   private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();
  88 
  89   private Timer mTimer;
  90 
  91   @Deprecated
  92   private File mConfigFile;
  93 
  94   /**
  95    * 进度刷新间隔
  96    */
  97   private long mUpdateInterval = 1000;
  98 
  99   private TaskRecord mRecord;
 100 
 101   protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
 102     mListener = listener;
 103     mTaskEntity = taskEntity;
 104     mEntity = mTaskEntity.getEntity();
 105     mContext = AriaManager.APP;
 106     mConstance = new StateConstance();
 107   }
 108 
 109   public void setNewTask(boolean newTask) {
 110     mTaskEntity.setNewTask(newTask);
 111   }
 112 
 113   @Override
 114   public void setMaxSpeed(double maxSpeed) {
 115     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 116       AbsThreadTask task = mTask.get(i);
 117       if (task != null) {
 118         task.setMaxSpeed(maxSpeed);
 119       }
 120     }
 121   }
 122 
 123   @Override public void run() {
 124     if (mConstance.isRunning) {
 125       return;
 126     }
 127     startFlow();
 128   }
 129 
 130   /**
 131    * 开始流程
 132    */
 133   private void startFlow() {
 134     mConstance.resetState();
 135     checkTask();
 136     mConstance.TASK_RECORD = mRecord;
 137     if (mListener instanceof IDownloadListener) {
 138       ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 139     }
 140     if (!mTaskEntity.isSupportBP()) {
 141       mTotalThreadNum = 1;
 142       mStartThreadNum = 1;
 143       handleNoSupportBP();
 144     } else {
 145       mTotalThreadNum =
 146           mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 147       handleBreakpoint();
 148     }
 149     mConstance.START_THREAD_NUM = mTotalThreadNum;
 150     /*
 151      * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 152      * 动态长度条件：
 153      * 1、总线程数为1，并且是新任务
 154      * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 155      */
 156     if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 157         || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 158       mConstance.isOpenDynamicFile = true;
 159     }
 160     startTimer();
 161   }
 162 
 163   /**
 164    * 设置新任务的最大线程数
 165    */
 166   protected abstract int setNewTaskThreadNum();
 167 
 168   /**
 169    * 启动进度获取定时器
 170    */
 171   private void startTimer() {
 172     mTimer = new Timer(true);
 173     mTimer.schedule(new TimerTask() {
 174       @Override public void run() {
 175         if (mConstance.isComplete()
 176             || mConstance.isStop()
 177             || mConstance.isCancel()
 178             || !mConstance.isRunning) {
 179           closeTimer();
 180         } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 181           mListener.onProgress(mConstance.CURRENT_LOCATION);
 182         }
 183       }
 184     }, 0, mUpdateInterval);
 185   }
 186 
 187   protected void closeTimer() {
 188     if (mTimer != null) {
 189       mTimer.purge();
 190       mTimer.cancel();
 191       mTimer = null;
 192     }
 193   }
 194 
 195   /**
 196    * 设置定时器更新间隔
 197    *
 198    * @param interval 单位毫秒，不能小于0
 199    */
 200   protected void setUpdateInterval(long interval) {
 201     if (interval &lt; 0) {
 202       ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 203       return;
 204     }
 205     mUpdateInterval = interval;
 206   }
 207 
 208   @Override public long getFileSize() {
 209     return mEntity.getFileSize();
 210   }
 211 
 212   /**
 213    * 获取当前任务位置
 214    */
 215   @Override
 216   public long getCurrentLocation() {
 217     return mConstance.CURRENT_LOCATION;
 218   }
 219 
 220   @Override public boolean isRunning() {
 221     return mConstance.isRunning;
 222   }
 223 
 224   @Override
 225   public void cancel() {
 226     closeTimer();
 227     mConstance.isRunning = false;
 228     mConstance.isCancel = true;
 229     if (mFixedThreadPool != null) {
 230       mFixedThreadPool.shutdown();
 231     }
 232     for (int i = 0; i &lt; mStartThreadNum; i++) {
 233       AbsThreadTask task = mTask.get(i);
 234       if (task != null) {
 235         task.cancel();
 236       }
 237     }
 238   }
 239 
 240   @Override
 241   public void stop() {
 242     closeTimer();
 243     mConstance.isRunning = false;
 244     mConstance.isStop = true;
 245     if (mConstance.isComplete()) {
 246       return;
 247     }
 248     if (mFixedThreadPool != null) {
 249       mFixedThreadPool.shutdown();
 250     }
 251     for (int i = 0; i &lt; mStartThreadNum; i++) {
 252       AbsThreadTask task = mTask.get(i);
 253       if (task != null) {
 254         task.stop();
 255       }
 256     }
 257   }
 258 
 259   /**
 260    * 直接调用的时候会自动启动线程执行
 261    */
 262   @Override public void start() {
 263     new Thread(this).start();
 264   }
 265 
 266   @Override public void resume() {
 267     start();
 268   }
 269 
 270   /**
 271    * 检查任务、检查线程数
 272    * 新任务条件：
 273    * 1、文件不存在
 274    * 2、任务记录文件缺失或不匹配
 275    * 3、数据库记录不存在
 276    * 4、不支持断点，则是新任务
 277    */
 278   private void checkTask() {
 279     mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 280     if (mConfigFile.exists()) {
 281       convertDb();
 282     } else {
 283       mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 284       if (mRecord == null) {
 285         initRecord();
 286         mTaskEntity.setNewTask(true);
 287       } else if ((mRecord.threadRecords == null) || mRecord.threadRecords.isEmpty()) {
 288         initRecord();
 289         mTaskEntity.setNewTask(true);
 290       } else if (mTempFile.length() == 0) {
 291         mRecord.deleteData();
 292         initRecord();
 293         mTaskEntity.setNewTask(true);
 294       } else {
 295         for (ThreadRecord tr : mRecord.threadRecords) {
 296           if (tr.isComplete) {
 297             mCompleteThreadNum++;
 298           } else {
 299             mStartThreadNum++;
 300           }
 301         }
 302         mTotalThreadNum = mRecord.threadRecords.size();
 303         mTaskEntity.setNewTask(false);
 304       }
 305     }
 306   }
 307 
 308   /**
 309    * convertDb 为兼容性代码
 310    * 从3.4.1开始，线程配置信息将存储在数据库中。
 311    * 将配置文件的内容复制到数据库中，并将配置文件删除
 312    */
 313   private void convertDb() {
<abbr title=" 314     List&lt;RecordWrapper&gt; records = DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;, mTaskEntity.getKey());"> 314     List&lt;RecordWrapper&gt; records = DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,🔵</abbr>
 315     if ((records == null) || (records.size() == 0)) {
 316       Properties pro = CommonUtil.loadConfig(mConfigFile);
 317       if (pro.isEmpty()) {
 318         mTaskEntity.setNewTask(true);
 319         return;
 320       }
 321       initRecord();
 322       Set&lt;Object&gt; keys = pro.keySet();
 323       // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 324       // 第一步应该是record 和 state去重取正确的线程数
 325       Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 326       for (Object key : keys) {
 327         String str = String.valueOf(key);
 328         int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 329         set.add(i);
 330       }
 331       int threadNum = set.size();
 332       if (threadNum == 0) {
 333         mTaskEntity.setNewTask(true);
 334         return;
 335       }
 336       mRecord.threadNum = threadNum;
 337       mTotalThreadNum = threadNum;
 338       for (int i = 0; i &lt; threadNum; i++) {
 339         ThreadRecord tRecord = new ThreadRecord();
 340         tRecord.key = mRecord.filePath;
 341         Object state = pro.getProperty((mTempFile.getName() + STATE) + i);
 342         Object record = pro.getProperty((mTempFile.getName() + RECORD) + i);
 343         if ((state != null) &amp;&amp; (Integer.parseInt(String.valueOf(state)) == 1)) {
 344           mCompleteThreadNum++;
 345           tRecord.isComplete = true;
 346           continue;
 347         }
 348         mStartThreadNum++;
 349         if (record != null) {
 350           Long temp = Long.parseLong(String.valueOf(record));
 351           tRecord.startLocation = (temp &gt; 0) ? temp : 0;
 352         } else {
 353           tRecord.startLocation = 0;
 354         }
 355         mRecord.threadRecords.add(tRecord);
 356       }
 357       mConfigFile.delete();
 358     }
 359   }
 360 
 361   /**
 362    * 初始化记录
 363    */
 364   private void initRecord() {
 365     mRecord = new TaskRecord();
 366     mRecord.fileName = mEntity.getFileName();
 367     mRecord.filePath = mTaskEntity.getKey();
 368     mRecord.threadRecords = new ArrayList&lt;&gt;();
 369     mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 370     if (mRecord.isGroupRecord) {
 371       if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 372         mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 373       }
 374     }
 375   }
 376 
 377   /**
 378    * 保存任务记录
 379    */
 380   private void saveRecord() {
 381     mRecord.save();
 382     for (ThreadRecord tr : mRecord.threadRecords) {
 383       tr.save();
 384     }
 385   }
 386 
 387   public TaskRecord getRecord() {
 388     return mRecord;
 389   }
 390 
 391   /**
 392    * 恢复记录地址
 393    *
 394    * @return {@code true}任务已完成
 395    */
 396   private boolean resumeRecordLocation(int i, long startL, long endL) {
 397     mConstance.CURRENT_LOCATION += endL - startL;
 398     ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));
 399     mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 400     mConstance.STOP_NUM++;
 401     mConstance.CANCEL_NUM++;
 402     if (mConstance.isComplete()) {
 403       mRecord.deleteData();
 404       mListener.onComplete();
 405       mConstance.isRunning = false;
 406       return true;
 407     }
 408     return false;
 409   }
 410 
 411   /**
 412    * 启动断点任务时，创建单线程任务
 413    *
 414    * @param i 线程id
 415    * @param startL 该任务起始位置
 416    * @param endL 该任务结束位置
 417    * @param fileLength 该任务需要处理的文件长度
 418    */
 419   private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 420       ThreadRecord record) {
 421     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 422     config.FILE_SIZE = fileLength;
 423     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 424     config.TEMP_FILE = mTempFile;
 425     config.THREAD_ID = i;
 426     config.START_LOCATION = startL;
 427     config.END_LOCATION = endL;
 428     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 429     config.TASK_ENTITY = mTaskEntity;
 430     config.THREAD_RECORD = record;
 431     return selectThreadTask(config);
 432   }
 433 
 434   private void handleBreakpoint() {
 435     long fileLength = mEntity.getFileSize();
 436     long blockSize = fileLength / mTotalThreadNum;
 437     int[] threadId = new int[mTotalThreadNum];
 438     int rl = 0;
 439     mRecord.fileLength = fileLength;
 440     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 441       threadId[i] = -1;
 442     }
 443     if (mTaskEntity.isNewTask() &amp;&amp; (!handleNewTask())) {
 444       return;
 445     }
 446     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 447       long startL = i * blockSize;
 448       long endL = (i + 1) * blockSize;
 449       ThreadRecord tr;
 450       boolean isNewTr = false;// 是否是新的线程记录
 451 
 452       if (mTaskEntity.isNewTask()) {
 453         tr = new ThreadRecord();
 454         tr.key = mRecord.filePath;
 455         tr.threadId = i;
 456         isNewTr = true;
 457       } else {
 458         tr = mRecord.threadRecords.get(i);
 459       }
 460       if (tr.isComplete) {
 461         // 该线程已经完成
 462         if (resumeRecordLocation(i, startL, endL)) {
 463           return;
 464         }
 465         continue;
 466       }
 467       // 如果有记录，则恢复任务
 468       if (tr.startLocation &gt;= 0) {
 469         Long r = tr.startLocation;
 470         // 记录的位置需要在线程区间中
 471         if ((startL &lt; r) &amp;&amp; (r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL))) {
 472           mConstance.CURRENT_LOCATION += r - startL;
 473           startL = r;
 474         }
 475         ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));
 476       }
 477       // 最后一个线程的结束位置即为文件的总长度
 478       if (i == (mTotalThreadNum - 1)) {
 479         endL = fileLength;
 480       }
 481       // 更新记录
 482       tr.startLocation = startL;
 483       tr.endLocation = endL;
 484       if (isNewTr) {
 485         mRecord.threadRecords.add(tr);
 486       }
 487       AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 488       if (task == null) {
 489         return;
 490       }
 491       mTask.put(i, task);
 492       threadId[rl] = i;
 493       rl++;
 494     }
<abbr title=" 495     if ((mConstance.CURRENT_LOCATION != 0) &amp;&amp; (mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress())) {"> 495     if ((mConstance.CURRENT_LOCATION != 0) &amp;&amp; (mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress(🔵</abbr>
 496       ALog.d(TAG, &quot;进度修正&quot;);
 497       mEntity.setCurrentProgress(mConstance.CURRENT_LOCATION);
 498     }
 499     saveRecord();
 500     startThreadTask(threadId);
 501   }
 502 
 503   /**
 504    * 启动单线程任务
 505    */
 506   private void startThreadTask(int[] recordL) {
 507     if (mConstance.CURRENT_LOCATION &gt; 0) {
 508       mListener.onResume(mConstance.CURRENT_LOCATION);
 509     } else {
 510       mListener.onStart(mConstance.CURRENT_LOCATION);
 511     }
 512     mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 513     for (int l : recordL) {
 514       if (l == (-1)) {
 515         continue;
 516       }
 517       Runnable task = mTask.get(l);
 518       if (task != null) {
 519         mFixedThreadPool.execute(task);
 520       }
 521     }
 522   }
 523 
 524   /**
 525    * 重试线程任务，只有线程创建成功才能重试
 526    */
 527   public void retryThradTask() {
 528     if ((mTask == null) || (mTask.size() == 0)) {
 529       ALog.w(TAG, &quot;没有线程任务&quot;);
 530       return;
 531     }
 532     Set&lt;Integer&gt; keys = mTask.keySet();
 533     for (Integer key : keys) {
 534       AbsThreadTask task = mTask.get(key);
 535       if ((task != null) &amp;&amp; (!task.isThreadComplete())) {
 536         task.getConfig().START_LOCATION = task.getCurrentLocation();
<abbr title=" 537         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(), key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));"> 537         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(), key, tas🔵</abbr>
 538         mFixedThreadPool.execute(task);
 539       }
 540     }
 541   }
 542 
 543   /**
 544    * 处理新任务
 545    *
 546    * @return {@code true}创建新任务失败
 547    */
 548   protected abstract boolean handleNewTask();
 549 
 550   /**
 551    * 处理不支持断点的任务
 552    */
 553   private void handleNoSupportBP() {
 554     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 555     config.FILE_SIZE = mEntity.getFileSize();
 556     config.URL = (mEntity.isRedirect()) ? mEntity.getRedirectUrl() : mEntity.getUrl();
 557     config.TEMP_FILE = mTempFile;
 558     config.THREAD_ID = 0;
 559     config.START_LOCATION = 0;
 560     config.END_LOCATION = config.FILE_SIZE;
 561     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 562     config.TASK_ENTITY = mTaskEntity;
 563     AbsThreadTask task = selectThreadTask(config);
 564     if (task == null) {
 565       return;
 566     }
 567     mTask.put(0, task);
 568     mFixedThreadPool = Executors.newFixedThreadPool(1);
 569     mFixedThreadPool.execute(task);
 570     mListener.onStart(0);
 571   }
 572 
 573   /**
 574    * 选择单任务线程的类型
 575    */
 576   protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 577 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.arialyy.aria.core.common;
  17  
  18  import android.content.Context;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  19 +import android.util.Log;</span>
  20  import android.util.SparseArray;
  21  import com.arialyy.aria.core.AriaManager;
  22  import com.arialyy.aria.core.download.DownloadEntity;
  23  import com.arialyy.aria.core.inf.AbsNormalEntity;
  24  import com.arialyy.aria.core.inf.AbsTaskEntity;
  25  import com.arialyy.aria.core.inf.IDownloadListener;
  26  import com.arialyy.aria.core.inf.IEventListener;
  27  import com.arialyy.aria.orm.DbEntity;
  28  import com.arialyy.aria.util.ALog;
  29  import com.arialyy.aria.util.CommonUtil;
  30  import com.arialyy.aria.util.DbHelper;
  31  import java.io.File;
  32  import java.util.ArrayList;

  33  import java.util.HashSet;
  34  import java.util.List;

  35  import java.util.Properties;
  36  import java.util.Set;
  37  import java.util.Timer;
  38  import java.util.TimerTask;
  39  import java.util.concurrent.ExecutorService;
  40  import java.util.concurrent.Executors;
  41  
  42  /**
  43   * Created by AriaL on 2017/7/1.
  44   * 任务处理器
  45   */
  46  public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt;
  47      implements Runnable, IUtil {
  48    private static final String STATE = &quot;_state_&quot;;
  49    private static final String RECORD = &quot;_record_&quot;;
  50    /**
  51     * 小于1m的文件不启用多线程
  52     */
  53    protected static final long SUB_LEN = 1024 * 1024;
  54  
  55    private final String TAG = &quot;AbsFileer&quot;;
  56    protected IEventListener mListener;
  57    protected TASK_ENTITY mTaskEntity;
  58    protected ENTITY mEntity;
  59    protected Context mContext;
  60    protected File mTempFile; //文件
  61    protected StateConstance mConstance;
  62    private ExecutorService mFixedThreadPool;
  63    //总线程数
  64    protected int mTotalThreadNum;
  65    //启动线程数
  66    private int mStartThreadNum;
  67    //已完成的线程数
  68    private int mCompleteThreadNum;
  69    private SparseArray&lt;AbsThreadTask&gt; mTask = new SparseArray&lt;&gt;();
  70  

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -</span>
  72    private Timer mTimer;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -  @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -  private File mConfigFile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +  @Deprecated private File mConfigFile;</span>
  76    /**
  77     * 进度刷新间隔
  78     */
  79    private long mUpdateInterval = 1000;
  80    private TaskRecord mRecord;
  81  
  82    protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
  83      mListener = listener;
  84      mTaskEntity = taskEntity;
  85      mEntity = mTaskEntity.getEntity();
  86      mContext = AriaManager.APP;
  87      mConstance = new StateConstance();
  88    }
  89  
  90    public void setNewTask(boolean newTask) {
  91      mTaskEntity.setNewTask(newTask);
  92    }
  93  
  94    @Override public void setMaxSpeed(double maxSpeed) {
  95      for (int i = 0; i &lt; mTotalThreadNum; i++) {
  96        AbsThreadTask task = mTask.get(i);
  97        if (task != null) {
  98          task.setMaxSpeed(maxSpeed);
  99        }
 100      }
 101    }
 102  
 103    @Override public void run() {
 104      if (mConstance.isRunning) {
 105        return;
 106      }
 107      startFlow();
 108    }
 109  
 110    /**
 111     * 开始流程
 112     */
 113    private void startFlow() {
 114      mConstance.resetState();
 115      checkTask();
 116      mConstance.TASK_RECORD = mRecord;
 117      if (mListener instanceof IDownloadListener) {
 118        ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 119      }
 120      if (!mTaskEntity.isSupportBP()) {
 121        mTotalThreadNum = 1;
 122        mStartThreadNum = 1;
 123        handleNoSupportBP();
 124      } else {
 125        mTotalThreadNum =
 126            mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 127        handleBreakpoint();
 128      }
 129      mConstance.START_THREAD_NUM = mTotalThreadNum;
 130      /*
 131       * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 132       * 动态长度条件：
 133       * 1、总线程数为1，并且是新任务
 134       * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 135       */
 136      if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 137          || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 138        mConstance.isOpenDynamicFile = true;
 139      }
 140      startTimer();
 141    }
 142  
 143    /**
 144     * 设置新任务的最大线程数
 145     */
 146    protected abstract int setNewTaskThreadNum();
 147  
 148    /**
 149     * 启动进度获取定时器
 150     */
 151    private void startTimer() {
 152      mTimer = new Timer(true);
 153      mTimer.schedule(new TimerTask() {
 154        @Override public void run() {
 155          if (mConstance.isComplete()
 156              || mConstance.isStop()
 157              || mConstance.isCancel()
 158              || !mConstance.isRunning) {
 159            closeTimer();
 160          } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 161            mListener.onProgress(mConstance.CURRENT_LOCATION);
 162          }
 163        }
 164      }, 0, mUpdateInterval);
 165    }
 166  
 167    protected void closeTimer() {
 168      if (mTimer != null) {
 169        mTimer.purge();
 170        mTimer.cancel();
 171        mTimer = null;
 172      }
 173    }
 174  
 175    /**
 176     * 设置定时器更新间隔
 177     *
 178     * @param interval 单位毫秒，不能小于0
 179     */
 180    protected void setUpdateInterval(long interval) {
 181      if (interval &lt; 0) {
 182        ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 183        return;
 184      }
 185      mUpdateInterval = interval;
 186    }
 187  
 188    @Override public long getFileSize() {
 189      return mEntity.getFileSize();
 190    }
 191  
 192    /**
 193     * 获取当前下载位置

 194     */
 195    @Override public long getCurrentLocation() {
 196      return mConstance.CURRENT_LOCATION;
 197    }
 198  
 199    @Override public boolean isRunning() {
 200      return mConstance.isRunning;
 201    }
 202  
 203    @Override public void cancel() {
 204      closeTimer();
 205      mConstance.isRunning = false;
 206      mConstance.isCancel = true;
 207      if (mFixedThreadPool != null) {
 208        mFixedThreadPool.shutdown();
 209      }
 210      for (int i = 0; i &lt; mStartThreadNum; i++) {
 211        AbsThreadTask task = mTask.get(i);
 212        if (task != null) {
 213          task.cancel();
 214        }
 215      }
 216    }
 217  
 218    @Override public void stop() {
 219      closeTimer();
 220      mConstance.isRunning = false;
 221      mConstance.isStop = true;
 222      if (mConstance.isComplete()) return;
 223      if (mFixedThreadPool != null) {
 224        mFixedThreadPool.shutdown();
 225      }
 226      for (int i = 0; i &lt; mStartThreadNum; i++) {
 227        AbsThreadTask task = mTask.get(i);
 228        if (task != null) {
 229          task.stop();
 230        }
 231      }
 232    }
 233  
 234    /**
 235     * 直接调用的时候会自动启动线程执行
 236     */
 237    @Override public void start() {
 238      new Thread(this).start();
 239    }
 240  
 241    @Override public void resume() {
 242      start();
 243    }
 244  
 245    /**
 246     * 检查任务、检查线程数
 247     * 新任务条件：
 248     * 1、文件不存在
 249     * 2、下载记录文件缺失或不匹配

 250     * 3、数据库记录不存在
 251     * 4、不支持断点，则是新任务
 252     */
 253    private void checkTask() {
 254      mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 255      if (mConfigFile.exists()) {
 256        convertDb();
 257      } else {
 258        mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 259        if (mRecord == null) {
 260          initRecord();
 261          mTaskEntity.setNewTask(true);
 262        } else {
 263          if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 264            initRecord();
 265            mTaskEntity.setNewTask(true);
 266          } else if (mTempFile.length() == 0) {
 267            mRecord.deleteData();
 268            initRecord();
 269            mTaskEntity.setNewTask(true);
 270          } else {
 271            for (ThreadRecord tr : mRecord.threadRecords) {
 272              if (tr.isComplete) {
 273                mCompleteThreadNum++;
 274              } else {
 275                mStartThreadNum++;
 276              }
 277            }
 278            mTotalThreadNum = mRecord.threadRecords.size();
 279            mTaskEntity.setNewTask(false);
 280          }
 281        }
 282      }
 283    }
 284  
 285    /**
 286     * convertDb 为兼容性代码
 287     * 从3.4.1开始，线程配置信息将存储在数据库中。
 288     * 将配置文件的内容复制到数据库中，并将配置文件删除
 289     */
 290    private void convertDb() {
 291      List&lt;RecordWrapper&gt; records =
 292          DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 293              mTaskEntity.getKey());
 294      if (records == null || records.size() == 0) {
 295        Properties pro = CommonUtil.loadConfig(mConfigFile);
 296        if (pro.isEmpty()) {
 297          mTaskEntity.setNewTask(true);
 298          return;
 299        }
 300        initRecord();
 301        Set&lt;Object&gt; keys = pro.keySet();
 302        // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 303        // 第一步应该是record 和 state去重取正确的线程数
 304        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 305        for (Object key : keys) {
 306          String str = String.valueOf(key);
 307          int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 308          set.add(i);
 309        }
 310        int threadNum = set.size();
 311        if (threadNum == 0) {
 312          mTaskEntity.setNewTask(true);
 313          return;
 314        }
 315        mRecord.threadNum = threadNum;
 316        mTotalThreadNum = threadNum;
 317  
 318        for (int i = 0; i &lt; threadNum; i++) {
 319          ThreadRecord tRecord = new ThreadRecord();
 320          tRecord.key = mRecord.filePath;
 321          Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 322          Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
 323          if (state != null &amp;&amp; Integer.parseInt(state + &quot;&quot;) == 1) {

 324            mCompleteThreadNum++;
 325            tRecord.isComplete = true;
 326            continue;
 327          }
 328          mStartThreadNum++;
 329          if (record != null) {
 330            Long temp = Long.parseLong(record + &quot;&quot;);

 331            tRecord.startLocation = temp &gt; 0 ? temp : 0;
 332          } else {
 333            tRecord.startLocation = 0;
 334          }
 335          mRecord.threadRecords.add(tRecord);
 336        }
 337        mConfigFile.delete();
 338      }
 339    }
 340  
 341    /**
 342     * 初始化记录
 343     */
 344    private void initRecord() {
 345      mRecord = new TaskRecord();
 346      mRecord.fileName = mEntity.getFileName();
 347      mRecord.filePath = mTaskEntity.getKey();
 348      mRecord.threadRecords = new ArrayList&lt;&gt;();
 349      mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 350      if (mRecord.isGroupRecord) {
 351        if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 352          mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 353        }
 354      }
 355    }
 356  
 357    /**
 358     * 保存任务记录
 359     */
 360    private void saveRecord() {
 361      mRecord.save();
 362      for (ThreadRecord tr : mRecord.threadRecords) {
 363        tr.save();
 364      }
 365    }
 366  
 367    public TaskRecord getRecord() {
 368      return mRecord;
 369    }
 370  
 371    /**
 372     * 恢复记录地址
 373     *
 374     * @return {@code true}任务已完成
 375     */
 376    private boolean resumeRecordLocation(int i, long startL, long endL) {
 377      mConstance.CURRENT_LOCATION += endL - startL;
 378      ALog.d(TAG, &quot;任务【&quot; + mTaskEntity.getEntity().getFileName() + &quot;】线程__&quot; + i + &quot;__已完成&quot;);

 379      mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 380      mConstance.STOP_NUM++;
 381      mConstance.CANCEL_NUM++;
 382      if (mConstance.isComplete()) {
 383        mRecord.deleteData();
 384        mListener.onComplete();
 385        mConstance.isRunning = false;
 386        return true;
 387      }
 388      return false;
 389    }
 390  
 391    /**
 392     * 启动断点任务时，创建单线程任务
 393     *
 394     * @param i 线程id
 395     * @param startL 该任务起始位置
 396     * @param endL 该任务结束位置
 397     * @param fileLength 该任务需要处理的文件长度
 398     */
 399    private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 400        ThreadRecord record) {
 401      SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 402      config.FILE_SIZE = fileLength;
 403      config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 404      config.TEMP_FILE = mTempFile;
 405      config.THREAD_ID = i;
 406      config.START_LOCATION = startL;
 407      config.END_LOCATION = endL;
 408      config.SUPPORT_BP = mTaskEntity.isSupportBP();
 409      config.TASK_ENTITY = mTaskEntity;
 410      config.THREAD_RECORD = record;
 411      return selectThreadTask(config);
 412    }
 413  
 414    private void handleBreakpoint() {
 415      long fileLength = mEntity.getFileSize();
 416      long blockSize = fileLength / mTotalThreadNum;
 417      int[] threadId = new int[mTotalThreadNum];
 418      int rl = 0;
 419  
 420      mRecord.fileLength = fileLength;
 421      for (int i = 0; i &lt; mTotalThreadNum; i++) {
 422        threadId[i] = -1;
 423      }
 424      if (mTaskEntity.isNewTask() &amp;&amp; !handleNewTask()) {
 425        return;
 426      }
 427      for (int i = 0; i &lt; mTotalThreadNum; i++) {
 428        long startL = i * blockSize, endL = (i + 1) * blockSize;
 429        ThreadRecord tr;
 430        boolean isNewTr = false;  // 是否是新的线程记录
 431        if (mTaskEntity.isNewTask()) {
 432          tr = new ThreadRecord();
 433          tr.key = mRecord.filePath;
 434          tr.threadId = i;
 435          isNewTr = true;
 436        } else {
 437          tr = mRecord.threadRecords.get(i);
 438        }
 439        if (tr.isComplete) {//该线程已经完成
 440          if (resumeRecordLocation(i, startL, endL)) return;
 441          continue;
 442        }
 443  
 444        //如果有记录，则恢复下载

 445        if (tr.startLocation &gt;= 0) {
 446          Long r = tr.startLocation;
 447          //记录的位置需要在线程区间中
 448          if (startL &lt; r &amp;&amp; r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL)) {
 449            mConstance.CURRENT_LOCATION += r - startL;
 450            startL = r;
 451          }
 452          ALog.d(TAG, &quot;任务【&quot; + mEntity.getFileName() + &quot;】线程__&quot; + i + &quot;__恢复下载&quot;);

 453        }
 454        //最后一个线程的结束位置即为文件的总长度
 455        if (i == (mTotalThreadNum - 1)) {
 456          endL = fileLength;
 457        }
 458        // 更新记录
 459        tr.startLocation = startL;
 460        tr.endLocation = endL;
 461        if (isNewTr) {
 462          mRecord.threadRecords.add(tr);
 463        }
 464        AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 465        if (task == null) return;
 466        mTask.put(i, task);
 467        threadId[rl] = i;
 468        rl++;
 469      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +    if (mConstance.CURRENT_LOCATION != 0 &amp;&amp; mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +      ALog.d(TAG, &quot;进度修正&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +      mEntity.setCurrentProgress(mConstance.CURRENT_LOCATION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 473 +    }</span>
 474      saveRecord();
 475      startThreadTask(threadId);
 476    }
 477  
 478    /**
 479     * 启动单线程下载任务

 480     */
 481    private void startThreadTask(int[] recordL) {
 482      if (mConstance.CURRENT_LOCATION &gt; 0) {
 483        mListener.onResume(mConstance.CURRENT_LOCATION);
 484      } else {
 485        mListener.onStart(mConstance.CURRENT_LOCATION);
 486      }
 487      mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 488      for (int l : recordL) {
 489        if (l == -1) continue;
 490        Runnable task = mTask.get(l);
 491        if (task != null) {
 492          mFixedThreadPool.execute(task);
 493        }
 494      }
 495    }
 496  
 497    /**




















 498     * 处理新任务
 499     *
 500     * @return {@code true}创建新任务失败
 501     */
 502    protected abstract boolean handleNewTask();
 503  
 504    /**
 505     * 处理不支持断点的下载

 506     */
 507    private void handleNoSupportBP() {
 508      SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 509      config.FILE_SIZE = mEntity.getFileSize();
 510      config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 511      config.TEMP_FILE = mTempFile;
 512      config.THREAD_ID = 0;
 513      config.START_LOCATION = 0;
 514      config.END_LOCATION = config.FILE_SIZE;
 515      config.SUPPORT_BP = mTaskEntity.isSupportBP();
 516      config.TASK_ENTITY = mTaskEntity;
 517      AbsThreadTask task = selectThreadTask(config);
 518      if (task == null) return;
 519      mTask.put(0, task);
 520      mFixedThreadPool = Executors.newFixedThreadPool(1);
 521      mFixedThreadPool.execute(task);
 522      mListener.onStart(0);
 523    }
 524  
 525    /**
 526     * 选择单任务线程的类型
 527     */
 528    protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 529  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.arialyy.aria.core.common;
  17  
  18  import android.content.Context;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  19 -import android.util.SparseArray;</span>
  20  import com.arialyy.aria.core.AriaManager;
  21  import com.arialyy.aria.core.download.DownloadEntity;
  22  import com.arialyy.aria.core.inf.AbsNormalEntity;
  23  import com.arialyy.aria.core.inf.AbsTaskEntity;
  24  import com.arialyy.aria.core.inf.IDownloadListener;
  25  import com.arialyy.aria.core.inf.IEventListener;
  26  import com.arialyy.aria.orm.DbEntity;
  27  import com.arialyy.aria.util.ALog;
  28  import com.arialyy.aria.util.CommonUtil;
  29  import com.arialyy.aria.util.DbHelper;
  30  import java.io.File;
  31  import java.util.ArrayList;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import java.util.HashMap;</span>
  33  import java.util.HashSet;
  34  import java.util.List;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import java.util.Map;</span>
  36  import java.util.Properties;
  37  import java.util.Set;
  38  import java.util.Timer;
  39  import java.util.TimerTask;
  40  import java.util.concurrent.ExecutorService;
  41  import java.util.concurrent.Executors;
  42  
  43  /**
  44   * Created by AriaL on 2017/7/1.
  45   * 任务处理器
  46   */
  47  public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt;
  48      implements Runnable, IUtil {
  49    private static final String STATE = &quot;_state_&quot;;
  50    private static final String RECORD = &quot;_record_&quot;;
  51    /**
  52     * 小于1m的文件不启用多线程
  53     */
  54    protected static final long SUB_LEN = 1024 * 1024;
  55  
  56    private final String TAG = &quot;AbsFileer&quot;;
  57    protected IEventListener mListener;
  58    protected TASK_ENTITY mTaskEntity;
  59    protected ENTITY mEntity;
  60    protected Context mContext;
  61    protected File mTempFile; //文件
  62    protected StateConstance mConstance;
  63    private ExecutorService mFixedThreadPool;
  64    //总线程数
  65    protected int mTotalThreadNum;
  66    //启动线程数
  67    private int mStartThreadNum;
  68    //已完成的线程数
  69    private int mCompleteThreadNum;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -  private SparseArray&lt;AbsThreadTask&gt; mTask = new SparseArray&lt;&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +  private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();</span>
  73  
  74    private Timer mTimer;
  75    @Deprecated
  76    private File mConfigFile;

  77    /**
  78     * 进度刷新间隔
  79     */
  80    private long mUpdateInterval = 1000;
  81    private TaskRecord mRecord;
  82  
  83    protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
  84      mListener = listener;
  85      mTaskEntity = taskEntity;
  86      mEntity = mTaskEntity.getEntity();
  87      mContext = AriaManager.APP;
  88      mConstance = new StateConstance();
  89    }
  90  
  91    public void setNewTask(boolean newTask) {
  92      mTaskEntity.setNewTask(newTask);
  93    }
  94  
  95    @Override public void setMaxSpeed(double maxSpeed) {
  96      for (int i = 0; i &lt; mTotalThreadNum; i++) {
  97        AbsThreadTask task = mTask.get(i);
  98        if (task != null) {
  99          task.setMaxSpeed(maxSpeed);
 100        }
 101      }
 102    }
 103  
 104    @Override public void run() {
 105      if (mConstance.isRunning) {
 106        return;
 107      }
 108      startFlow();
 109    }
 110  
 111    /**
 112     * 开始流程
 113     */
 114    private void startFlow() {
 115      mConstance.resetState();
 116      checkTask();
 117      mConstance.TASK_RECORD = mRecord;
 118      if (mListener instanceof IDownloadListener) {
 119        ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 120      }
 121      if (!mTaskEntity.isSupportBP()) {
 122        mTotalThreadNum = 1;
 123        mStartThreadNum = 1;
 124        handleNoSupportBP();
 125      } else {
 126        mTotalThreadNum =
 127            mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 128        handleBreakpoint();
 129      }
 130      mConstance.START_THREAD_NUM = mTotalThreadNum;
 131      /*
 132       * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 133       * 动态长度条件：
 134       * 1、总线程数为1，并且是新任务
 135       * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 136       */
 137      if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 138          || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 139        mConstance.isOpenDynamicFile = true;
 140      }
 141      startTimer();
 142    }
 143  
 144    /**
 145     * 设置新任务的最大线程数
 146     */
 147    protected abstract int setNewTaskThreadNum();
 148  
 149    /**
 150     * 启动进度获取定时器
 151     */
 152    private void startTimer() {
 153      mTimer = new Timer(true);
 154      mTimer.schedule(new TimerTask() {
 155        @Override public void run() {
 156          if (mConstance.isComplete()
 157              || mConstance.isStop()
 158              || mConstance.isCancel()
 159              || !mConstance.isRunning) {
 160            closeTimer();
 161          } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 162            mListener.onProgress(mConstance.CURRENT_LOCATION);
 163          }
 164        }
 165      }, 0, mUpdateInterval);
 166    }
 167  
 168    protected void closeTimer() {
 169      if (mTimer != null) {
 170        mTimer.purge();
 171        mTimer.cancel();
 172        mTimer = null;
 173      }
 174    }
 175  
 176    /**
 177     * 设置定时器更新间隔
 178     *
 179     * @param interval 单位毫秒，不能小于0
 180     */
 181    protected void setUpdateInterval(long interval) {
 182      if (interval &lt; 0) {
 183        ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 184        return;
 185      }
 186      mUpdateInterval = interval;
 187    }
 188  
 189    @Override public long getFileSize() {
 190      return mEntity.getFileSize();
 191    }
 192  
 193    /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 194 -   * 获取当前下载位置</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +   * 获取当前任务位置</span>
 196     */
 197    @Override public long getCurrentLocation() {
 198      return mConstance.CURRENT_LOCATION;
 199    }
 200  
 201    @Override public boolean isRunning() {
 202      return mConstance.isRunning;
 203    }
 204  
 205    @Override public void cancel() {
 206      closeTimer();
 207      mConstance.isRunning = false;
 208      mConstance.isCancel = true;
 209      if (mFixedThreadPool != null) {
 210        mFixedThreadPool.shutdown();
 211      }
 212      for (int i = 0; i &lt; mStartThreadNum; i++) {
 213        AbsThreadTask task = mTask.get(i);
 214        if (task != null) {
 215          task.cancel();
 216        }
 217      }
 218    }
 219  
 220    @Override public void stop() {
 221      closeTimer();
 222      mConstance.isRunning = false;
 223      mConstance.isStop = true;
 224      if (mConstance.isComplete()) return;
 225      if (mFixedThreadPool != null) {
 226        mFixedThreadPool.shutdown();
 227      }
 228      for (int i = 0; i &lt; mStartThreadNum; i++) {
 229        AbsThreadTask task = mTask.get(i);
 230        if (task != null) {
 231          task.stop();
 232        }
 233      }
 234    }
 235  
 236    /**
 237     * 直接调用的时候会自动启动线程执行
 238     */
 239    @Override public void start() {
 240      new Thread(this).start();
 241    }
 242  
 243    @Override public void resume() {
 244      start();
 245    }
 246  
 247    /**
 248     * 检查任务、检查线程数
 249     * 新任务条件：
 250     * 1、文件不存在
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -   * 2、下载记录文件缺失或不匹配</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +   * 2、任务记录文件缺失或不匹配</span>
 253     * 3、数据库记录不存在
 254     * 4、不支持断点，则是新任务
 255     */
 256    private void checkTask() {
 257      mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 258      if (mConfigFile.exists()) {
 259        convertDb();
 260      } else {
 261        mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 262        if (mRecord == null) {
 263          initRecord();
 264          mTaskEntity.setNewTask(true);
 265        } else {
 266          if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 267            initRecord();
 268            mTaskEntity.setNewTask(true);
 269          } else if (mTempFile.length() == 0) {
 270            mRecord.deleteData();
 271            initRecord();
 272            mTaskEntity.setNewTask(true);
 273          } else {
 274            for (ThreadRecord tr : mRecord.threadRecords) {
 275              if (tr.isComplete) {
 276                mCompleteThreadNum++;
 277              } else {
 278                mStartThreadNum++;
 279              }
 280            }
 281            mTotalThreadNum = mRecord.threadRecords.size();
 282            mTaskEntity.setNewTask(false);
 283          }
 284        }
 285      }
 286    }
 287  
 288    /**
 289     * convertDb 为兼容性代码
 290     * 从3.4.1开始，线程配置信息将存储在数据库中。
 291     * 将配置文件的内容复制到数据库中，并将配置文件删除
 292     */
 293    private void convertDb() {
 294      List&lt;RecordWrapper&gt; records =
 295          DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 296              mTaskEntity.getKey());
 297      if (records == null || records.size() == 0) {
 298        Properties pro = CommonUtil.loadConfig(mConfigFile);
 299        if (pro.isEmpty()) {
 300          mTaskEntity.setNewTask(true);
 301          return;
 302        }
 303        initRecord();
 304        Set&lt;Object&gt; keys = pro.keySet();
 305        // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 306        // 第一步应该是record 和 state去重取正确的线程数
 307        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 308        for (Object key : keys) {
 309          String str = String.valueOf(key);
 310          int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 311          set.add(i);
 312        }
 313        int threadNum = set.size();
 314        if (threadNum == 0) {
 315          mTaskEntity.setNewTask(true);
 316          return;
 317        }
 318        mRecord.threadNum = threadNum;
 319        mTotalThreadNum = threadNum;
 320  
 321        for (int i = 0; i &lt; threadNum; i++) {
 322          ThreadRecord tRecord = new ThreadRecord();
 323          tRecord.key = mRecord.filePath;
 324          Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 325          Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 326 -        if (state != null &amp;&amp; Integer.parseInt(state + &quot;&quot;) == 1) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +        if (state != null &amp;&amp; Integer.parseInt(String.valueOf(state)) == 1) {</span>
 328            mCompleteThreadNum++;
 329            tRecord.isComplete = true;
 330            continue;
 331          }
 332          mStartThreadNum++;
 333          if (record != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 334 -          Long temp = Long.parseLong(record + &quot;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +          Long temp = Long.parseLong(String.valueOf(record));</span>
 336            tRecord.startLocation = temp &gt; 0 ? temp : 0;
 337          } else {
 338            tRecord.startLocation = 0;
 339          }
 340          mRecord.threadRecords.add(tRecord);
 341        }
 342        mConfigFile.delete();
 343      }
 344    }
 345  
 346    /**
 347     * 初始化记录
 348     */
 349    private void initRecord() {
 350      mRecord = new TaskRecord();
 351      mRecord.fileName = mEntity.getFileName();
 352      mRecord.filePath = mTaskEntity.getKey();
 353      mRecord.threadRecords = new ArrayList&lt;&gt;();
 354      mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 355      if (mRecord.isGroupRecord) {
 356        if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 357          mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 358        }
 359      }
 360    }
 361  
 362    /**
 363     * 保存任务记录
 364     */
 365    private void saveRecord() {
 366      mRecord.save();
 367      for (ThreadRecord tr : mRecord.threadRecords) {
 368        tr.save();
 369      }
 370    }
 371  
 372    public TaskRecord getRecord() {
 373      return mRecord;
 374    }
 375  
 376    /**
 377     * 恢复记录地址
 378     *
 379     * @return {@code true}任务已完成
 380     */
 381    private boolean resumeRecordLocation(int i, long startL, long endL) {
 382      mConstance.CURRENT_LOCATION += endL - startL;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 383 -    ALog.d(TAG, &quot;任务【&quot; + mTaskEntity.getEntity().getFileName() + &quot;】线程__&quot; + i + &quot;__已完成&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +    ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));</span>
 385      mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 386      mConstance.STOP_NUM++;
 387      mConstance.CANCEL_NUM++;
 388      if (mConstance.isComplete()) {
 389        mRecord.deleteData();
 390        mListener.onComplete();
 391        mConstance.isRunning = false;
 392        return true;
 393      }
 394      return false;
 395    }
 396  
 397    /**
 398     * 启动断点任务时，创建单线程任务
 399     *
 400     * @param i 线程id
 401     * @param startL 该任务起始位置
 402     * @param endL 该任务结束位置
 403     * @param fileLength 该任务需要处理的文件长度
 404     */
 405    private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 406        ThreadRecord record) {
 407      SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 408      config.FILE_SIZE = fileLength;
 409      config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 410      config.TEMP_FILE = mTempFile;
 411      config.THREAD_ID = i;
 412      config.START_LOCATION = startL;
 413      config.END_LOCATION = endL;
 414      config.SUPPORT_BP = mTaskEntity.isSupportBP();
 415      config.TASK_ENTITY = mTaskEntity;
 416      config.THREAD_RECORD = record;
 417      return selectThreadTask(config);
 418    }
 419  
 420    private void handleBreakpoint() {
 421      long fileLength = mEntity.getFileSize();
 422      long blockSize = fileLength / mTotalThreadNum;
 423      int[] threadId = new int[mTotalThreadNum];
 424      int rl = 0;
 425  
 426      mRecord.fileLength = fileLength;
 427      for (int i = 0; i &lt; mTotalThreadNum; i++) {
 428        threadId[i] = -1;
 429      }
 430      if (mTaskEntity.isNewTask() &amp;&amp; !handleNewTask()) {
 431        return;
 432      }
 433      for (int i = 0; i &lt; mTotalThreadNum; i++) {
 434        long startL = i * blockSize, endL = (i + 1) * blockSize;
 435        ThreadRecord tr;
 436        boolean isNewTr = false;  // 是否是新的线程记录
 437        if (mTaskEntity.isNewTask()) {
 438          tr = new ThreadRecord();
 439          tr.key = mRecord.filePath;
 440          tr.threadId = i;
 441          isNewTr = true;
 442        } else {
 443          tr = mRecord.threadRecords.get(i);
 444        }
 445        if (tr.isComplete) {//该线程已经完成
 446          if (resumeRecordLocation(i, startL, endL)) return;
 447          continue;
 448        }
 449  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -      //如果有记录，则恢复下载</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 451 +      //如果有记录，则恢复任务</span>
 452        if (tr.startLocation &gt;= 0) {
 453          Long r = tr.startLocation;
 454          //记录的位置需要在线程区间中
 455          if (startL &lt; r &amp;&amp; r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL)) {
 456            mConstance.CURRENT_LOCATION += r - startL;
 457            startL = r;
 458          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -        ALog.d(TAG, &quot;任务【&quot; + mEntity.getFileName() + &quot;】线程__&quot; + i + &quot;__恢复下载&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 460 +        ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));</span>
 461        }
 462        //最后一个线程的结束位置即为文件的总长度
 463        if (i == (mTotalThreadNum - 1)) {
 464          endL = fileLength;
 465        }
 466        // 更新记录
 467        tr.startLocation = startL;
 468        tr.endLocation = endL;
 469        if (isNewTr) {
 470          mRecord.threadRecords.add(tr);
 471        }
 472        AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 473        if (task == null) return;
 474        mTask.put(i, task);
 475        threadId[rl] = i;
 476        rl++;
 477      }




 478      saveRecord();
 479      startThreadTask(threadId);
 480    }
 481  
 482    /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 483 -   * 启动单线程下载任务</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 484 +   * 启动单线程任务</span>
 485     */
 486    private void startThreadTask(int[] recordL) {
 487      if (mConstance.CURRENT_LOCATION &gt; 0) {
 488        mListener.onResume(mConstance.CURRENT_LOCATION);
 489      } else {
 490        mListener.onStart(mConstance.CURRENT_LOCATION);
 491      }
 492      mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 493      for (int l : recordL) {
 494        if (l == -1) continue;
 495        Runnable task = mTask.get(l);
 496        if (task != null) {
 497          mFixedThreadPool.execute(task);
 498        }
 499      }
 500    }
 501  
 502    /**
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 503 +   * 重试线程任务，只有线程创建成功才能重试</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 504 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 505 +  public void retryThradTask() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 506 +    if (mTask == null || mTask.size() == 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 507 +      ALog.w(TAG, &quot;没有线程任务&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 508 +      return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 509 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 510 +    Set&lt;Integer&gt; keys = mTask.keySet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 511 +    for (Integer key : keys) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 512 +      AbsThreadTask task = mTask.get(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 513 +      if (task != null &amp;&amp; !task.isThreadComplete()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 514 +        task.getConfig().START_LOCATION = task.getCurrentLocation();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 515 +        ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 516 +            key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 517 +        mFixedThreadPool.execute(task);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 518 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 519 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 520 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 521 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 522 +  /**</span>
 523     * 处理新任务
 524     *
 525     * @return {@code true}创建新任务失败
 526     */
 527    protected abstract boolean handleNewTask();
 528  
 529    /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 530 -   * 处理不支持断点的下载</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 531 +   * 处理不支持断点的任务</span>
 532     */
 533    private void handleNoSupportBP() {
 534      SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 535      config.FILE_SIZE = mEntity.getFileSize();
 536      config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 537      config.TEMP_FILE = mTempFile;
 538      config.THREAD_ID = 0;
 539      config.START_LOCATION = 0;
 540      config.END_LOCATION = config.FILE_SIZE;
 541      config.SUPPORT_BP = mTaskEntity.isSupportBP();
 542      config.TASK_ENTITY = mTaskEntity;
 543      AbsThreadTask task = selectThreadTask(config);
 544      if (task == null) return;
 545      mTask.put(0, task);
 546      mFixedThreadPool = Executors.newFixedThreadPool(1);
 547      mFixedThreadPool.execute(task);
 548      mListener.onStart(0);
 549    }
 550  
 551    /**
 552     * 选择单任务线程的类型
 553     */
 554    protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 555  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            