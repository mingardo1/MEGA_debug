<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>152</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    152
                    <a href="151.html">prev</a>
                    <a href="153.html">next</a>
                    <a href="152_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_eb9f6cb33a94b081f79e2544a1b66941dd4c92ad_admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;eb9f6cb33a94b081f79e2544a1b66941dd4c92ad:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;eb9f6cb33a94b081f79e2544a1b66941dd4c92ad^1:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;eb9f6cb33a94b081f79e2544a1b66941dd4c92ad^2:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;d09b9b2a8021c50bc75b33a8d780992ffde6095a:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2022 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  19 </span>
  20 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  21 /*</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  22  * BroadleafCommerce CMS Module</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  23  * %%</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  24  * Copyright (C) 2009 - 2016 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  25  * %%</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  26  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  27  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  28  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  29  * the Broadleaf End User License Agreement (EULA), Version 1.1</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  30  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  31  * shall apply.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  32  *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  33  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  33  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  34  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  34  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  35  * #L%</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  36  */</span>
  37 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  38 /*</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  39  * BroadleafCommerce CMS Module</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  40  * %%</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  41  * Copyright (C) 2009 - 2022 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  42  * %%</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  43  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  44  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  45  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  46  * the Broadleaf End User License Agreement (EULA), Version 1.1</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  47  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  48  * shall apply.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  49  *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  50  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  50  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  51  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  51  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  52  * #L%</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  53  */</span>
  54 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  55 package org.broadleafcommerce.cms.file.service;
  56 
  57 import org.apache.commons.io.FilenameUtils;
  58 import org.apache.commons.logging.Log;
  59 import org.apache.commons.logging.LogFactory;
  60 import org.apache.tika.Tika;
  61 import org.apache.tika.mime.MimeType;
  62 import org.apache.tika.mime.MimeTypeException;
  63 import org.apache.tika.mime.MimeTypes;
  64 import org.broadleafcommerce.cms.field.type.StorageType;
  65 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  66 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  67 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  68 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  69 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  70 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  71 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  72 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  73 import org.broadleafcommerce.common.util.StringUtil;
  74 import org.broadleafcommerce.common.util.TransactionUtils;
  75 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  76 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  77 import org.springframework.beans.factory.annotation.Value;
  78 import org.springframework.stereotype.Service;
  79 import org.springframework.transaction.annotation.Transactional;
  80 import org.springframework.web.multipart.MultipartFile;
  81 
  82 import java.io.IOException;
  83 import java.io.InputStream;
  84 import java.io.UnsupportedEncodingException;
  85 import java.net.URLDecoder;
  86 import java.util.Arrays;
  87 import java.util.HashMap;
  88 import java.util.List;
  89 import java.util.Map;
  90 import java.util.Random;
  91 
  92 import javax.annotation.Resource;
  93 
  94 /**
  95  * Created by bpolster.
  96  */
  97 @Service(&quot;blStaticAssetService&quot;)
  98 public class StaticAssetServiceImpl implements StaticAssetService {
  99 
 100     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title=" 101     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;"> 101     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
 102 
 103     @Resource(name = &quot;blImageArtifactProcessor&quot;)
 104     protected ImageArtifactProcessor imageArtifactProcessor;
 105 
 106     @Value(&quot;${asset.use.filesystem.storage}&quot;)
 107     protected boolean storeAssetsOnFileSystem = false;
 108 
 109     @Resource(name = &quot;blStaticAssetDao&quot;)
 110     protected StaticAssetDao staticAssetDao;
 111 
 112     @Resource(name = &quot;blStaticAssetStorageService&quot;)
 113     protected StaticAssetStorageService staticAssetStorageService;
 114 
 115     @Resource(name = &quot;blStaticAssetPathService&quot;)
 116     protected StaticAssetPathService staticAssetPathService;
 117 
 118     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
 119     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 120 
 121     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 122     protected boolean shouldAcceptNonImageAsset;
 123 
 124     @Value(&quot;${disabled.file.extensions}&quot;)
 125     protected String disabledFileExtensions;
 126 
 127     private final Random random = new Random();
 128     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 129 
 130     @Override
 131     public StaticAsset findStaticAssetById(Long id) {
 132         return staticAssetDao.readStaticAssetById(id);
 133     }
 134 
 135     @Override
 136     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 137         return staticAssetDao.readAllStaticAssets();
 138     }
 139 
 140     @Override
 141     public Long findTotalStaticAssetCount() {
 142         return staticAssetDao.readTotalStaticAssetCount();
 143     }
 144 
 145     protected String getFileExtension(String fileName) {
 146         int pos = fileName.lastIndexOf(&quot;.&quot;);
 147         if (pos &gt; 0) {
 148             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 149         } else {
 150             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 151             return null;
 152         }
 153     }
 154 
 155     /**
 156      * Generates a filename as a set of Hex digits.
 157      *
 158      * @param size
 159      * @return
 160      */
 161     protected String generateFileName(int size) {
 162         StringBuilder sb = new StringBuilder();
 163         for (int i = 0; i &lt; size; i++) {
 164             int pos = random.nextInt(FILE_NAME_CHARS.length());
 165             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 166         }
 167         return sb.toString();
 168     }
 169 
 170     /**
 171      * Will assemble the url from the passed in properties as
 172      * /{entityType}/{fileName}
 173      * /product/7001-ab12
 174      * &lt;p&gt;
 175      * If the properties above are not set, it will generate the fileName randomly.
 176      *
 177      * @param url
 178      * @param asset
 179      * @param assetProperties
 180      * @return
 181      */
 182     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 183         StringBuilder path = new StringBuilder(&quot;/&quot;);
 184 
 185         String entityType = assetProperties.get(&quot;entityType&quot;);
 186         String entityId = assetProperties.get(&quot;entityId&quot;);
 187         String fileName = assetProperties.get(&quot;fileName&quot;);
 188 
 189         if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 190             path = path.append(entityType).append(&quot;/&quot;);
 191         }
 192 
 193         if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 194             path = path.append(entityId).append(&quot;/&quot;);
 195         }
 196 
 197         if (fileName != null) {
 198             int pos = fileName.indexOf(&quot;:&quot;);
 199             if (pos &gt; 0) {
 200                 if (LOG.isTraceEnabled()) {
 201                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 202                 }
 203                 fileName = fileName.substring(pos + 1);
 204             }
 205         } else {
 206             fileName = originalFilename;
 207         }
 208 
 209         return path.append(fileName).toString();
 210     }
 211 
 212     private static String normalizeFileExtension(MultipartFile file) {
 213         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 214         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 214         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 215     }
 216 
 217     private static String getFileExtension(MultipartFile file) {
 218         String tikaExtension = null;
 219         try {
 220             final Tika tika = new Tika();
 221             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 222             final String detectedType;
 223             detectedType = tika.detect(file.getBytes());
 224             if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 225                 final MimeType mimeType = allTypes.forName(detectedType);
 226                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 227             }
 228         } catch (IOException | MimeTypeException ignored) {
 229         }
<abbr title=" 230         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 230         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtðŸ”µ</abbr>
 231     }
 232 
 233     public void validateFileExtension(MultipartFile file) throws IOException {
 234         final String extension = getFileExtension(file);
 235         if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 236             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 236             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 237             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 238             if (extensions.contains(extension)) {
 239                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 240                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 241             }
 242         }
 243     }
 244 
 245     @Override
 246     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 247     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 248         try {
 249             validateFileExtension(file);
 250             staticAssetStorageService.validateFileSize(file);
<abbr title=" 251             return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), properties);"> 251             return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(),ðŸ”µ</abbr>
 252         } catch (IOException e) {
 253             throw new RuntimeException(e);
 254         }
 255     }
 256 
 257     @Override
 258     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 259     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 259     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 260         if (properties == null) {
 261             properties = new HashMap&lt;String, String&gt;();
 262         }
 263 
 264         String fullUrl = buildAssetURL(properties, fileName);
 265         StringBuilder urlBuilder = new StringBuilder();
 266         urlBuilder.append(fullUrl);
<abbr title=" 267         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 267         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 268         fullUrl = urlBuilder.toString();
 269         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 270         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 271         // logic for handling duplicate files.
 272         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 273             int count = 0;
 274             while (newAsset != null) {
 275                 count++;
 276                 //try the new format first, then the old
 277                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 278                 if (newAsset == null) {
<abbr title=" 279                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 279                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 280                 }
 281             }
 282 
 283             if (count &gt; 0) {
 284                 fullUrl = getCountUrl(fullUrl, count, false);
 285             }
 286         }
 287 
 288         try {
 289             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 290             newAsset = new ImageStaticAssetImpl();
 291             ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 292             ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 293         } catch (Exception e) {
 294             //must not be an image stream
 295             LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 296             LOG.debug(e);
 297 
 298             if (getShouldAcceptNonImageAsset()) {
 299                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 300             } else {
 301                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 302             }
 303         }
 304         if (storeAssetsOnFileSystem) {
 305             newAsset.setStorageType(StorageType.FILESYSTEM);
 306         } else {
 307             newAsset.setStorageType(StorageType.DATABASE);
 308         }
 309 
 310         newAsset.setName(fileName);
 311         getMimeType(inputStream, fileName, newAsset);
 312         newAsset.setFileExtension(getFileExtension(fileName));
 313         newAsset.setFileSize(fileSize);
 314         newAsset.setFullUrl(fullUrl);
 315 
 316         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 317     }
 318 
 319     /**
 320      * Hook-point for implementors to add custom business logic for handling files that are non-images
 321      *
 322      * @param inputStream
 323      * @param fileName
 324      * @param properties
 325      * @return
 326      */
<abbr title=" 327     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 327     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 328         return new StaticAssetImpl();
 329     }
 330 
 331     /**
<abbr title=" 332      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 332      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 333      * &lt;p&gt;
 334      * /path/to/image.jpg-1
 335      * /path/to/image.jpg-2
 336      * &lt;p&gt;
 337      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 338      * &lt;p&gt;
 339      * /path/to/image-1.jpg
 340      * /path/to/image-2.jpg
 341      * &lt;p&gt;
 342      * Used to deal with duplicate URLs of uploaded assets
 343      */
 344     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 345         String countUrl = fullUrl + &#x27;-&#x27; + count;
 346         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 347         if (dotIndex != -1 &amp;&amp; !legacyFormat) {
<abbr title=" 348             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);"> 348             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + ðŸ”µ</abbr>
 349         }
 350 
 351         return countUrl;
 352     }
 353 
 354     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 355         Tika tika = new Tika();
 356         String tikaMimeType = tika.detect(fileName);
 357         if (tikaMimeType == null) {
 358             try {
 359                 tikaMimeType = tika.detect(inputStream);
 360             } catch (IOException e) {
 361                 //if tika can&#x27;t resolve, don&#x27;t throw exception
 362             }
 363         }
 364         if (tikaMimeType != null) {
 365             newAsset.setMimeType(tikaMimeType);
 366         }
 367     }
 368 
 369     @Override
 370     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 371         try {
 372             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 373             //strip out the jsessionid if it&#x27;s there
 374             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 375         } catch (UnsupportedEncodingException e) {
 376             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 377         }
 378         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 379     }
 380 
 381     @Override
 382     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 383     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 384         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 385         return newAsset;
 386     }
 387 
 388     @Override
 389     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 390     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 391         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 392     }
 393 
 394     @Override
 395     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 396     public void deleteStaticAsset(StaticAsset staticAsset) {
 397         staticAssetDao.delete(staticAsset);
 398     }
 399 
 400     @Override
 401     public String getStaticAssetUrlPrefix() {
 402         return staticAssetPathService.getStaticAssetUrlPrefix();
 403     }
 404 
 405     @Override
 406     public String getPrefixedStaticAssetUrl(String assetUrl) {
 407         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 408         if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 409             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 410         }
 411         if (staticAssetUrlPrefix != null) {
 412             return staticAssetUrlPrefix + assetUrl;
 413         }
 414         return assetUrl;
 415     }
 416 
 417     @Override
 418     public String getStaticAssetEnvironmentUrlPrefix() {
 419         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 420     }
 421 
 422     @Override
 423     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 424         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 425     }
 426 
 427     @Override
 428     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 429         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 430     }
 431 
 432     public boolean getShouldAcceptNonImageAsset() {
 433         return shouldAcceptNonImageAsset;
 434     }
 435 
 436     public void setShouldAcceptNonImageAsset(boolean accept) {
 437         shouldAcceptNonImageAsset = accept;
 438     }
 439 }</pre></td>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2022 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.cms.file.service;
  20 
  21 import org.apache.commons.io.FilenameUtils;
  22 import org.apache.commons.logging.Log;
  23 import org.apache.commons.logging.LogFactory;
  24 import org.apache.tika.Tika;
  25 import org.apache.tika.mime.MimeType;
  26 import org.apache.tika.mime.MimeTypeException;
  27 import org.apache.tika.mime.MimeTypes;
  28 import org.broadleafcommerce.cms.field.type.StorageType;
  29 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  30 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  31 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  32 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  33 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  34 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  35 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  36 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  37 import org.broadleafcommerce.common.util.StringUtil;
  38 import org.broadleafcommerce.common.util.TransactionUtils;
  39 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  40 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  41 import org.springframework.beans.factory.annotation.Value;
  42 import org.springframework.stereotype.Service;
  43 import org.springframework.transaction.annotation.Transactional;
  44 import org.springframework.web.multipart.MultipartFile;
  45 
  46 import java.io.IOException;
  47 import java.io.InputStream;
  48 import java.io.UnsupportedEncodingException;
  49 import java.net.URLDecoder;
  50 import java.util.Arrays;
  51 import java.util.HashMap;
  52 import java.util.List;
  53 import java.util.Map;
  54 import java.util.Random;
  55 
  56 import javax.annotation.Resource;
  57 
  58 /**
  59  * Created by bpolster.
  60  */
  61 @Service(&quot;blStaticAssetService&quot;)
  62 public class StaticAssetServiceImpl implements StaticAssetService {
  63 
  64     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  65     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  65     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
  66 
  67     @Resource(name = &quot;blImageArtifactProcessor&quot;)
  68     protected ImageArtifactProcessor imageArtifactProcessor;
  69 
  70     @Value(&quot;${asset.use.filesystem.storage}&quot;)
  71     protected boolean storeAssetsOnFileSystem = false;
  72 
  73     @Resource(name = &quot;blStaticAssetDao&quot;)
  74     protected StaticAssetDao staticAssetDao;
  75 
  76     @Resource(name = &quot;blStaticAssetStorageService&quot;)
  77     protected StaticAssetStorageService staticAssetStorageService;
  78 
  79     @Resource(name = &quot;blStaticAssetPathService&quot;)
  80     protected StaticAssetPathService staticAssetPathService;
  81 
  82     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
  83     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
  84 
  85     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
  86     protected boolean shouldAcceptNonImageAsset;
  87 
  88     @Value(&quot;${disabled.file.extensions}&quot;)
  89     protected String disabledFileExtensions;
  90 
  91     private final Random random = new Random();
  92     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
  93 
  94     @Override
  95     public StaticAsset findStaticAssetById(Long id) {
  96         return staticAssetDao.readStaticAssetById(id);
  97     }
  98 
  99     @Override
 100     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 101         return staticAssetDao.readAllStaticAssets();
 102     }
 103 
 104     @Override
 105     public Long findTotalStaticAssetCount() {
 106         return staticAssetDao.readTotalStaticAssetCount();
 107     }
 108 
 109     protected String getFileExtension(String fileName) {
 110         int pos = fileName.lastIndexOf(&quot;.&quot;);
 111         if (pos &gt; 0) {
 112             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 113         } else {
 114             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 115             return null;
 116         }
 117     }
 118 
 119     /**
 120      * Generates a filename as a set of Hex digits.
 121      *
 122      * @param size
 123      * @return
 124      */
 125     protected String generateFileName(int size) {
 126         StringBuilder sb = new StringBuilder();
 127         for (int i = 0; i &lt; size; i++) {
 128             int pos = random.nextInt(FILE_NAME_CHARS.length());
 129             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 130         }
 131         return sb.toString();
 132     }
 133 
 134     /**
 135      * Will assemble the url from the passed in properties as
 136      * /{entityType}/{fileName}
 137      * /product/7001-ab12
 138      * &lt;p&gt;
 139      * If the properties above are not set, it will generate the fileName randomly.
 140      *
 141      * @param url
 142      * @param asset
 143      * @param assetProperties
 144      * @return
 145      */
 146     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 147         StringBuilder path = new StringBuilder(&quot;/&quot;);
 148 
 149         String entityType = assetProperties.get(&quot;entityType&quot;);
 150         String entityId = assetProperties.get(&quot;entityId&quot;);
 151         String fileName = assetProperties.get(&quot;fileName&quot;);
 152 
 153         if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 154             path = path.append(entityType).append(&quot;/&quot;);
 155         }
 156 
 157         if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 158             path = path.append(entityId).append(&quot;/&quot;);
 159         }
 160 
 161         if (fileName != null) {
 162             int pos = fileName.indexOf(&quot;:&quot;);
 163             if (pos &gt; 0) {
 164                 if (LOG.isTraceEnabled()) {
 165                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 166                 }
 167                 fileName = fileName.substring(pos + 1);
 168             }
 169         } else {
 170             fileName = originalFilename;
 171         }
 172 
 173         return path.append(fileName).toString();
 174     }
 175 
 176     private static String normalizeFileExtension(MultipartFile file) {
 177         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 178         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 178         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 179     }
 180 
 181     private static String getFileExtension(MultipartFile file) {
 182         String tikaExtension = null;
 183         try {
 184             final Tika tika = new Tika();
 185             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 186             final String detectedType;
 187             detectedType = tika.detect(file.getBytes());
 188             if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 189                 final MimeType mimeType = allTypes.forName(detectedType);
 190                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 191             }
 192         } catch (IOException | MimeTypeException ignored) {
 193         }
<abbr title=" 194         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 194         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtðŸ”µ</abbr>
 195     }
 196 
 197     public void validateFileExtension(MultipartFile file) throws IOException {
 198         final String extension = getFileExtension(file);
 199         if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 200             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 200             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 201             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 202             if (extensions.contains(extension)) {
 203                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 204                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 205             }
 206         }
 207     }
 208 
 209     @Override
 210     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 211     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 212         try {
 213             validateFileExtension(file);
 214             staticAssetStorageService.validateFileSize(file);
<abbr title=" 215             return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), properties);"> 215             return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(),ðŸ”µ</abbr>
 216         } catch (IOException e) {
 217             throw new RuntimeException(e);
 218         }
 219     }
 220 
 221     @Override
 222     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 223     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 223     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 224         if (properties == null) {
 225             properties = new HashMap&lt;String, String&gt;();
 226         }
 227 
 228         String fullUrl = buildAssetURL(properties, fileName);
 229         StringBuilder urlBuilder = new StringBuilder();
 230         urlBuilder.append(fullUrl);
<abbr title=" 231         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 231         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 232         fullUrl = urlBuilder.toString();
 233         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 234         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 235         // logic for handling duplicate files.
 236         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 237             int count = 0;
 238             while (newAsset != null) {
 239                 count++;
 240                 //try the new format first, then the old
 241                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 242                 if (newAsset == null) {
<abbr title=" 243                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 243                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 244                 }
 245             }
 246 
 247             if (count &gt; 0) {
 248                 fullUrl = getCountUrl(fullUrl, count, false);
 249             }
 250         }
 251 
 252         try {
 253             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 254             newAsset = new ImageStaticAssetImpl();
 255             ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 256             ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 257         } catch (Exception e) {
 258             //must not be an image stream
 259             LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 260             LOG.debug(e);
 261 
 262             if (getShouldAcceptNonImageAsset()) {
 263                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 264             } else {
 265                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 266             }
 267         }
 268         if (storeAssetsOnFileSystem) {
 269             newAsset.setStorageType(StorageType.FILESYSTEM);
 270         } else {
 271             newAsset.setStorageType(StorageType.DATABASE);
 272         }
 273 
 274         newAsset.setName(fileName);
 275         getMimeType(inputStream, fileName, newAsset);
 276         newAsset.setFileExtension(getFileExtension(fileName));
 277         newAsset.setFileSize(fileSize);
 278         newAsset.setFullUrl(fullUrl);
 279 
 280         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 281     }
 282 
 283     /**
 284      * Hook-point for implementors to add custom business logic for handling files that are non-images
 285      *
 286      * @param inputStream
 287      * @param fileName
 288      * @param properties
 289      * @return
 290      */
<abbr title=" 291     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 291     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 292         return new StaticAssetImpl();
 293     }
 294 
 295     /**
<abbr title=" 296      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 296      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 297      * &lt;p&gt;
 298      * /path/to/image.jpg-1
 299      * /path/to/image.jpg-2
 300      * &lt;p&gt;
 301      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 302      * &lt;p&gt;
 303      * /path/to/image-1.jpg
 304      * /path/to/image-2.jpg
 305      * &lt;p&gt;
 306      * Used to deal with duplicate URLs of uploaded assets
 307      */
 308     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 309         String countUrl = fullUrl + &#x27;-&#x27; + count;
 310         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 311         if (dotIndex != -1 &amp;&amp; !legacyFormat) {
<abbr title=" 312             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);"> 312             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + ðŸ”µ</abbr>
 313         }
 314 
 315         return countUrl;
 316     }
 317 
 318     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 319         Tika tika = new Tika();
 320         String tikaMimeType = tika.detect(fileName);
 321         if (tikaMimeType == null) {
 322             try {
 323                 tikaMimeType = tika.detect(inputStream);
 324             } catch (IOException e) {
 325                 //if tika can&#x27;t resolve, don&#x27;t throw exception
 326             }
 327         }
 328         if (tikaMimeType != null) {
 329             newAsset.setMimeType(tikaMimeType);
 330         }
 331     }
 332 
 333     @Override
 334     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 335         try {
 336             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 337             //strip out the jsessionid if it&#x27;s there
 338             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 339         } catch (UnsupportedEncodingException e) {
 340             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 341         }
 342         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 343     }
 344 
 345     @Override
 346     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 347     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 348         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 349         return newAsset;
 350     }
 351 
 352     @Override
 353     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 354     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 355         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 356     }
 357 
 358     @Override
 359     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 360     public void deleteStaticAsset(StaticAsset staticAsset) {
 361         staticAssetDao.delete(staticAsset);
 362     }
 363 
 364     @Override
 365     public String getStaticAssetUrlPrefix() {
 366         return staticAssetPathService.getStaticAssetUrlPrefix();
 367     }
 368 
 369     @Override
 370     public String getPrefixedStaticAssetUrl(String assetUrl) {
 371         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 372         if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 373             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 374         }
 375         if (staticAssetUrlPrefix != null) {
 376             return staticAssetUrlPrefix + assetUrl;
 377         }
 378         return assetUrl;
 379     }
 380 
 381     @Override
 382     public String getStaticAssetEnvironmentUrlPrefix() {
 383         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 384     }
 385 
 386     @Override
 387     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 388         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 389     }
 390 
 391     @Override
 392     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 393         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 394     }
 395 
 396     public boolean getShouldAcceptNonImageAsset() {
 397         return shouldAcceptNonImageAsset;
 398     }
 399 
 400     public void setShouldAcceptNonImageAsset(boolean accept) {
 401         shouldAcceptNonImageAsset = accept;
 402     }
 403 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2022 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.cms.file.service;
  19 
  20 import java.io.IOException;
  21 import java.io.InputStream;
  22 import java.io.UnsupportedEncodingException;
  23 import java.net.URLDecoder;
  24 import java.util.Arrays;
  25 import java.util.HashMap;
  26 import java.util.List;
  27 import java.util.Map;
  28 import java.util.Random;
  29 import javax.annotation.Resource;
  30 import org.apache.commons.io.FilenameUtils;
  31 import org.apache.commons.logging.Log;
  32 import org.apache.commons.logging.LogFactory;
  33 import org.apache.tika.Tika;
  34 import org.apache.tika.mime.MimeType;
  35 import org.apache.tika.mime.MimeTypeException;
  36 import org.apache.tika.mime.MimeTypes;
  37 import org.broadleafcommerce.cms.field.type.StorageType;
  38 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  39 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  40 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  41 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  42 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  43 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  44 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  45 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  46 import org.broadleafcommerce.common.util.StringUtil;
  47 import org.broadleafcommerce.common.util.TransactionUtils;
  48 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  49 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  50 import org.springframework.beans.factory.annotation.Value;
  51 import org.springframework.stereotype.Service;
  52 import org.springframework.transaction.annotation.Transactional;
  53 import org.springframework.web.multipart.MultipartFile;
  54 
  55 
  56 /**
  57  * Created by bpolster.
  58  */
  59 @Service(&quot;blStaticAssetService&quot;)
  60 public class StaticAssetServiceImpl implements StaticAssetService {
  61     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
  62 
<abbr title="  63     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  63     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
  64 
  65     @Resource(name = &quot;blImageArtifactProcessor&quot;)
  66     protected ImageArtifactProcessor imageArtifactProcessor;
  67 
  68     @Value(&quot;${asset.use.filesystem.storage}&quot;)
  69     protected boolean storeAssetsOnFileSystem = false;
  70 
  71     @Resource(name = &quot;blStaticAssetDao&quot;)
  72     protected StaticAssetDao staticAssetDao;
  73 
  74     @Resource(name = &quot;blStaticAssetStorageService&quot;)
  75     protected StaticAssetStorageService staticAssetStorageService;
  76 
  77     @Resource(name = &quot;blStaticAssetPathService&quot;)
  78     protected StaticAssetPathService staticAssetPathService;
  79 
  80     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
  81     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
  82 
  83     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
  84     protected boolean shouldAcceptNonImageAsset;
  85 
  86     @Value(&quot;${disabled.file.extensions}&quot;)
  87     protected String disabledFileExtensions;
  88 
  89     private final Random random = new Random();
  90 
  91     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
  92 
  93     @Override
  94     public StaticAsset findStaticAssetById(Long id) {
  95         return staticAssetDao.readStaticAssetById(id);
  96     }
  97 
  98     @Override
  99     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 100         return staticAssetDao.readAllStaticAssets();
 101     }
 102 
 103     @Override
 104     public Long findTotalStaticAssetCount() {
 105         return staticAssetDao.readTotalStaticAssetCount();
 106     }
 107 
 108     protected String getFileExtension(String fileName) {
 109         int pos = fileName.lastIndexOf(&quot;.&quot;);
 110         if (pos &gt; 0) {
 111             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 112         } else {
 113             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 114             return null;
 115         }
 116     }
 117 
 118     /**
 119      * Generates a filename as a set of Hex digits.
 120      *
 121      * @param size
 122      * @return
 123      */
 124     protected String generateFileName(int size) {
 125         StringBuilder sb = new StringBuilder();
 126         for (int i = 0; i &lt; size; i++) {
 127             int pos = random.nextInt(FILE_NAME_CHARS.length());
 128             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 129         }
 130         return sb.toString();
 131     }
 132 
 133     /**
 134      * Will assemble the url from the passed in properties as
 135      * /{entityType}/{fileName}
 136      * /product/7001-ab12
 137      * &lt;p&gt;
 138      * If the properties above are not set, it will generate the fileName randomly.
 139      *
 140      * @param url
 141      * @param asset
 142      * @param assetProperties
 143      * @return
 144      */
 145     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 146         StringBuilder path = new StringBuilder(&quot;/&quot;);
 147 
 148         String entityType = assetProperties.get(&quot;entityType&quot;);
 149         String entityId = assetProperties.get(&quot;entityId&quot;);
 150         String fileName = assetProperties.get(&quot;fileName&quot;);
 151 
 152         if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 153             path = path.append(entityType).append(&quot;/&quot;);
 154         }
 155 
 156         if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 157             path = path.append(entityId).append(&quot;/&quot;);
 158         }
 159 
 160         if (fileName != null) {
 161             int pos = fileName.indexOf(&quot;:&quot;);
 162             if (pos &gt; 0) {
 163                 if (LOG.isTraceEnabled()) {
 164                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 165                 }
 166                 fileName = fileName.substring(pos + 1);
 167             }
 168         } else {
 169             fileName = originalFilename;
 170         }
 171 
 172         return path.append(fileName).toString();
 173     }
 174 
 175     private static String normalizeFileExtension(MultipartFile file) {
 176         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 177         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 177         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 178     }
 179 
 180     private static String getFileExtension(MultipartFile file) {
 181         String tikaExtension = null;
 182         try {
 183             final Tika tika = new Tika();
 184             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 185             final String detectedType;
 186             detectedType = tika.detect(file.getBytes());
 187             if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 188                 final MimeType mimeType = allTypes.forName(detectedType);
 189                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 190             }
 191         } catch (IOException | MimeTypeException ignored) {
 192         }
<abbr title=" 193         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 193         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtðŸ”µ</abbr>
 194     }
 195 
 196     public void validateFileExtension(MultipartFile file) throws IOException {
 197         final String extension = getFileExtension(file);
 198         if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 199             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 199             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 200             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 201             if (extensions.contains(extension)) {
 202                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 203                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 204             }
 205         }
 206     }
 207 
 208     @Override
 209     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 210     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 211         try {
 212             validateFileExtension(file);
 213             staticAssetStorageService.validateFileSize(file);
<abbr title=" 214             return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), properties);"> 214             return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(),ðŸ”µ</abbr>
 215         } catch (IOException e) {
 216             throw new RuntimeException(e);
 217         }
 218     }
 219 
 220     @Override
 221     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 222     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 222     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 223         if (properties == null) {
 224             properties = new HashMap&lt;String, String&gt;();
 225         }
 226 
 227         String fullUrl = buildAssetURL(properties, fileName);
 228         StringBuilder urlBuilder = new StringBuilder();
 229         urlBuilder.append(fullUrl);
<abbr title=" 230         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 230         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 231         fullUrl = urlBuilder.toString();
 232         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 233         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 234         // logic for handling duplicate files.
 235         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 236             int count = 0;
 237             while (newAsset != null) {
 238                 count++;
 239                 //try the new format first, then the old
 240                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 241                 if (newAsset == null) {
<abbr title=" 242                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 242                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 243                 }
 244             }
 245 
 246             if (count &gt; 0) {
 247                 fullUrl = getCountUrl(fullUrl, count, false);
 248             }
 249         }
 250 
 251         try {
 252             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 253             newAsset = new ImageStaticAssetImpl();
 254             ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 255             ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 256         } catch (Exception e) {
 257             //must not be an image stream
 258             LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 259             LOG.debug(e);
 260 
 261             if (getShouldAcceptNonImageAsset()) {
 262                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 263             } else {
 264                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 265             }
 266         }
 267         if (storeAssetsOnFileSystem) {
 268             newAsset.setStorageType(StorageType.FILESYSTEM);
 269         } else {
 270             newAsset.setStorageType(StorageType.DATABASE);
 271         }
 272 
 273         newAsset.setName(fileName);
 274         getMimeType(inputStream, fileName, newAsset);
 275         newAsset.setFileExtension(getFileExtension(fileName));
 276         newAsset.setFileSize(fileSize);
 277         newAsset.setFullUrl(fullUrl);
 278 
 279         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 280     }
 281 
 282     /**
 283      * Hook-point for implementors to add custom business logic for handling files that are non-images
 284      *
 285      * @param inputStream
 286      * @param fileName
 287      * @param properties
 288      * @return
 289      */
<abbr title=" 290     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 290     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 291         return new StaticAssetImpl();
 292     }
 293 
 294     /**
<abbr title=" 295      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 295      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 296      * &lt;p&gt;
 297      * /path/to/image.jpg-1
 298      * /path/to/image.jpg-2
 299      * &lt;p&gt;
 300      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 301      * &lt;p&gt;
 302      * /path/to/image-1.jpg
 303      * /path/to/image-2.jpg
 304      * &lt;p&gt;
 305      * Used to deal with duplicate URLs of uploaded assets
 306      */
 307     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 308         String countUrl = fullUrl + &#x27;-&#x27; + count;
 309         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 310         if (dotIndex != -1 &amp;&amp; !legacyFormat) {
<abbr title=" 311             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);"> 311             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + ðŸ”µ</abbr>
 312         }
 313 
 314         return countUrl;
 315     }
 316 
 317     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 318         Tika tika = new Tika();
 319         String tikaMimeType = tika.detect(fileName);
 320         if (tikaMimeType == null) {
 321             try {
 322                 tikaMimeType = tika.detect(inputStream);
 323             } catch (IOException e) {
 324                 //if tika can&#x27;t resolve, don&#x27;t throw exception
 325             }
 326         }
 327         if (tikaMimeType != null) {
 328             newAsset.setMimeType(tikaMimeType);
 329         }
 330     }
 331 
 332     @Override
 333     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 334         try {
 335             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 336             //strip out the jsessionid if it&#x27;s there
 337             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 338         } catch (UnsupportedEncodingException e) {
 339             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 340         }
 341         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 342     }
 343 
 344     @Override
 345     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 346     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 347         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 348         return newAsset;
 349     }
 350 
 351     @Override
 352     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 353     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 354         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 355     }
 356 
 357     @Override
 358     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 359     public void deleteStaticAsset(StaticAsset staticAsset) {
 360         staticAssetDao.delete(staticAsset);
 361     }
 362 
 363     @Override
 364     public String getStaticAssetUrlPrefix() {
 365         return staticAssetPathService.getStaticAssetUrlPrefix();
 366     }
 367 
 368     @Override
 369     public String getPrefixedStaticAssetUrl(String assetUrl) {
 370         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 371         if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 372             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 373         }
 374         if (staticAssetUrlPrefix != null) {
 375             return staticAssetUrlPrefix + assetUrl;
 376         }
 377         return assetUrl;
 378     }
 379 
 380     @Override
 381     public String getStaticAssetEnvironmentUrlPrefix() {
 382         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 383     }
 384 
 385     @Override
 386     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 387         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 388     }
 389 
 390     @Override
 391     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 392         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 393     }
 394 
 395     public boolean getShouldAcceptNonImageAsset() {
 396         return shouldAcceptNonImageAsset;
 397     }
 398 
 399     public void setShouldAcceptNonImageAsset(boolean accept) {
 400         shouldAcceptNonImageAsset = accept;
 401     }
 402 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre><span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   1 -/*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   2 +/*-</span>
   3   * #%L
   4   * BroadleafCommerce CMS Module
   5   * %%
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   6 - * Copyright (C) 2009 - 2018 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   7 + * Copyright (C) 2009 - 2022 Broadleaf Commerce</span>
   8   * %%
   9   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  10   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  11   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  12   * the Broadleaf End User License Agreement (EULA), Version 1.1
  13   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  14   * shall apply.
  15   *
<abbr title="  16   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  16   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  17   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  18   * #L%
  19   */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -/*</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 - * BroadleafCommerce CMS Module</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 - * %%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 - * Copyright (C) 2009 - 2016 Broadleaf Commerce</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 - * %%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 - * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 - * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 - * unless the restrictions on use therein are violated and require payment to Broadleaf in which case</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 - * the Broadleaf End User License Agreement (EULA), Version 1.1</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 - * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  30 - * shall apply.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 - *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  32 - * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  32 - * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 - * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 - * #L%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 - */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +</span>
  37  package org.broadleafcommerce.cms.file.service;
  38  
  39  import org.apache.commons.io.FilenameUtils;
  40  import org.apache.commons.logging.Log;
  41  import org.apache.commons.logging.LogFactory;
  42  import org.apache.tika.Tika;
  43  import org.apache.tika.mime.MimeType;
  44  import org.apache.tika.mime.MimeTypeException;
  45  import org.apache.tika.mime.MimeTypes;
  46  import org.broadleafcommerce.cms.field.type.StorageType;
  47  import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  48  import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  49  import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  50  import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  51  import org.broadleafcommerce.cms.file.domain.StaticAsset;
  52  import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  53  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  54  import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  55  import org.broadleafcommerce.common.util.StringUtil;
  56  import org.broadleafcommerce.common.util.TransactionUtils;
  57  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  58  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  59  import org.springframework.beans.factory.annotation.Value;
  60  import org.springframework.stereotype.Service;
  61  import org.springframework.transaction.annotation.Transactional;
  62  import org.springframework.web.multipart.MultipartFile;
  63  
  64  import java.io.IOException;
  65  import java.io.InputStream;
  66  import java.io.UnsupportedEncodingException;
  67  import java.net.URLDecoder;
  68  import java.util.Arrays;
  69  import java.util.HashMap;
  70  import java.util.List;
  71  import java.util.Map;
  72  import java.util.Random;
  73  
  74  import javax.annotation.Resource;
  75  
  76  /**
  77   * Created by bpolster.
  78   */
  79  @Service(&quot;blStaticAssetService&quot;)
  80  public class StaticAssetServiceImpl implements StaticAssetService {
  81  
  82      private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of ðŸ”µ</abbr>
  84  
  85      @Resource(name = &quot;blImageArtifactProcessor&quot;)
  86      protected ImageArtifactProcessor imageArtifactProcessor;
  87  
  88      @Value(&quot;${asset.use.filesystem.storage}&quot;)
  89      protected boolean storeAssetsOnFileSystem = false;
  90  
  91      @Resource(name = &quot;blStaticAssetDao&quot;)
  92      protected StaticAssetDao staticAssetDao;
  93  
  94      @Resource(name = &quot;blStaticAssetStorageService&quot;)
  95      protected StaticAssetStorageService staticAssetStorageService;
  96  
  97      @Resource(name = &quot;blStaticAssetPathService&quot;)
  98      protected StaticAssetPathService staticAssetPathService;
  99  
 100      @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
 101      protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 102  
 103      @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 104      protected boolean shouldAcceptNonImageAsset;
 105  
 106      @Value(&quot;${disabled.file.extensions}&quot;)
 107      protected String disabledFileExtensions;
 108  
 109      private final Random random = new Random();
 110      private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 111  
 112      @Override
 113      public StaticAsset findStaticAssetById(Long id) {
 114          return staticAssetDao.readStaticAssetById(id);
 115      }
 116  
 117      @Override
 118      public List&lt;StaticAsset&gt; readAllStaticAssets() {
 119          return staticAssetDao.readAllStaticAssets();
 120      }
 121  
 122      @Override
 123      public Long findTotalStaticAssetCount() {
 124          return staticAssetDao.readTotalStaticAssetCount();
 125      }
 126  
 127      protected String getFileExtension(String fileName) {
 128          int pos = fileName.lastIndexOf(&quot;.&quot;);
 129          if (pos &gt; 0) {
 130              return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 131          } else {
 132              LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 133              return null;
 134          }
 135      }
 136  
 137      /**
 138       * Generates a filename as a set of Hex digits.
 139       *
 140       * @param size
 141       * @return
 142       */
 143      protected String generateFileName(int size) {
 144          StringBuilder sb = new StringBuilder();
 145          for (int i = 0; i &lt; size; i++) {
 146              int pos = random.nextInt(FILE_NAME_CHARS.length());
 147              sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 148          }
 149          return sb.toString();
 150      }
 151  
 152      /**
 153       * Will assemble the url from the passed in properties as
 154       * /{entityType}/{fileName}
 155       * /product/7001-ab12
 156       * &lt;p&gt;
 157       * If the properties above are not set, it will generate the fileName randomly.
 158       *
 159       * @param url
 160       * @param asset
 161       * @param assetProperties
 162       * @return
 163       */
 164      protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 165          StringBuilder path = new StringBuilder(&quot;/&quot;);
 166  
 167          String entityType = assetProperties.get(&quot;entityType&quot;);
 168          String entityId = assetProperties.get(&quot;entityId&quot;);
 169          String fileName = assetProperties.get(&quot;fileName&quot;);
 170  
 171          if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 172              path = path.append(entityType).append(&quot;/&quot;);
 173          }
 174  
 175          if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 176              path = path.append(entityId).append(&quot;/&quot;);
 177          }
 178  
 179          if (fileName != null) {
 180              int pos = fileName.indexOf(&quot;:&quot;);
 181              if (pos &gt; 0) {
 182                  if (LOG.isTraceEnabled()) {
 183                      LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 184                  }
 185                  fileName = fileName.substring(pos + 1);
 186              }
 187          } else {
 188              fileName = originalFilename;
 189          }
 190  
 191          return path.append(fileName).toString();
 192      }
 193  
 194      private static String normalizeFileExtension(MultipartFile file) {
 195          int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 196          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 196          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1ðŸ”µ</abbr>
 197      }
 198  
 199      private static String getFileExtension(MultipartFile file) {
 200          String tikaExtension = null;
 201          try {
 202              final Tika tika = new Tika();
 203              final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 204              final String detectedType;
 205              detectedType = tika.detect(file.getBytes());
 206              if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 207                  final MimeType mimeType = allTypes.forName(detectedType);
 208                  tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 209              }
 210          } catch (IOException | MimeTypeException ignored) {
 211          }
<abbr title=" 212          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 212          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(fiðŸ”µ</abbr>
 213      }
 214  
 215      public void validateFileExtension(MultipartFile file) throws IOException {
 216          final String extension = getFileExtension(file);
 217          if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 218              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 218              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;))ðŸ”µ</abbr>
 219              LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 220              if (extensions.contains(extension)) {
 221                  LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 222                  throw new IOException(&quot;Invalid extension type of file.&quot;);
 223              }
 224          }
 225      }
 226  
 227      @Override
 228      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 229      public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 230          try {
 231              validateFileExtension(file);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +            staticAssetStorageService.validateFileSize(file);</span>
<abbr title=" 233              return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), properties);"> 233              return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), propertiðŸ”µ</abbr>
 234          } catch (IOException e) {
 235              throw new RuntimeException(e);
 236          }
 237      }
 238  
 239      @Override
 240      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 241      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 241      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, StriðŸ”µ</abbr>
 242          if (properties == null) {
 243              properties = new HashMap&lt;String, String&gt;();
 244          }
 245  
 246          String fullUrl = buildAssetURL(properties, fileName);
 247          StringBuilder urlBuilder = new StringBuilder();
 248          urlBuilder.append(fullUrl);
<abbr title=" 249          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 249          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURðŸ”µ</abbr>
 250          fullUrl = urlBuilder.toString();
 251          StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 252          // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 253          // logic for handling duplicate files.
 254          if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 255              int count = 0;
 256              while (newAsset != null) {
 257                  count++;
 258                  //try the new format first, then the old
 259                  newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 260                  if (newAsset == null) {
 261                      newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));
 262                  }
 263              }
 264  
 265              if (count &gt; 0) {
 266                  fullUrl = getCountUrl(fullUrl, count, false);
 267              }
 268          }
 269  
 270          try {
 271              ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 272              newAsset = new ImageStaticAssetImpl();
 273              ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 274              ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 275          } catch (Exception e) {
 276              //must not be an image stream
 277              LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 278              LOG.debug(e);
 279  
 280              if (getShouldAcceptNonImageAsset()) {
 281                  newAsset = createNonImageAsset(inputStream, fileName, properties);
 282              } else {
 283                  throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 284              }
 285          }
 286          if (storeAssetsOnFileSystem) {
 287              newAsset.setStorageType(StorageType.FILESYSTEM);
 288          } else {
 289              newAsset.setStorageType(StorageType.DATABASE);
 290          }
 291  
 292          newAsset.setName(fileName);
 293          getMimeType(inputStream, fileName, newAsset);
 294          newAsset.setFileExtension(getFileExtension(fileName));
 295          newAsset.setFileSize(fileSize);
 296          newAsset.setFullUrl(fullUrl);
 297  
 298          return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 299      }
 300  
 301      /**
 302       * Hook-point for implementors to add custom business logic for handling files that are non-images
 303       *
 304       * @param inputStream
 305       * @param fileName
 306       * @param properties
 307       * @return
 308       */
<abbr title=" 309      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 309      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properðŸ”µ</abbr>
 310          return new StaticAssetImpl();
 311      }
 312  
 313      /**
 314       * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:
 315       * &lt;p&gt;
 316       * /path/to/image.jpg-1
 317       * /path/to/image.jpg-2
 318       * &lt;p&gt;
 319       * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 320       * &lt;p&gt;
 321       * /path/to/image-1.jpg
 322       * /path/to/image-2.jpg
 323       * &lt;p&gt;
 324       * Used to deal with duplicate URLs of uploaded assets
 325       */
 326      protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 327          String countUrl = fullUrl + &#x27;-&#x27; + count;
 328          int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 329          if (dotIndex != -1 &amp;&amp; !legacyFormat) {
 330              countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);
 331          }
 332  
 333          return countUrl;
 334      }
 335  
 336      protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 337          Tika tika = new Tika();
 338          String tikaMimeType = tika.detect(fileName);
 339          if (tikaMimeType == null) {
 340              try {
 341                  tikaMimeType = tika.detect(inputStream);
 342              } catch (IOException e) {
 343                  //if tika can&#x27;t resolve, don&#x27;t throw exception
 344              }
 345          }
 346          if (tikaMimeType != null) {
 347              newAsset.setMimeType(tikaMimeType);
 348          }
 349      }
 350  
 351      @Override
 352      public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 353          try {
 354              fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 355              //strip out the jsessionid if it&#x27;s there
 356              fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 357          } catch (UnsupportedEncodingException e) {
 358              throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 359          }
 360          return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 361      }
 362  
 363      @Override
 364      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 365      public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 366          StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 367          return newAsset;
 368      }
 369  
 370      @Override
 371      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 372      public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 373          return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 374      }
 375  
 376      @Override
 377      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 378      public void deleteStaticAsset(StaticAsset staticAsset) {
 379          staticAssetDao.delete(staticAsset);
 380      }
 381  
 382      @Override
 383      public String getStaticAssetUrlPrefix() {
 384          return staticAssetPathService.getStaticAssetUrlPrefix();
 385      }
 386  
 387      @Override
 388      public String getPrefixedStaticAssetUrl(String assetUrl) {
 389          String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 390          if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 391              staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 392          }
 393          if (staticAssetUrlPrefix != null) {
 394              return staticAssetUrlPrefix + assetUrl;
 395          }
 396          return assetUrl;
 397      }
 398  
 399      @Override
 400      public String getStaticAssetEnvironmentUrlPrefix() {
 401          return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 402      }
 403  
 404      @Override
 405      public String getStaticAssetEnvironmentSecureUrlPrefix() {
 406          return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 407      }
 408  
 409      @Override
 410      public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 411          return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 412      }
 413  
 414      public boolean getShouldAcceptNonImageAsset() {
 415          return shouldAcceptNonImageAsset;
 416      }
 417  
 418      public void setShouldAcceptNonImageAsset(boolean accept) {
 419          shouldAcceptNonImageAsset = accept;
 420      }
 421  }</pre></td>
                            <td><pre><span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   1 -/*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   2 +/*-</span>
   3   * #%L
   4   * BroadleafCommerce CMS Module
   5   * %%
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   6 - * Copyright (C) 2009 - 2018 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   7 + * Copyright (C) 2009 - 2022 Broadleaf Commerce</span>
   8   * %%
   9   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  10   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  11   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  12   * the Broadleaf End User License Agreement (EULA), Version 1.1
  13   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  14   * shall apply.
  15   *
<abbr title="  16   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  16   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  17   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  18   * #L%
  19   */
  20  /*
  21   * BroadleafCommerce CMS Module
  22   * %%
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 - * Copyright (C) 2009 - 2016 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 + * Copyright (C) 2009 - 2022 Broadleaf Commerce</span>
  25   * %%
  26   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  27   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  28   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  29   * the Broadleaf End User License Agreement (EULA), Version 1.1
  30   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  31   * shall apply.
  32   *
<abbr title="  33   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  33   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  34   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  35   * #L%
  36   */

  37  package org.broadleafcommerce.cms.file.service;
  38  
  39  import org.apache.commons.io.FilenameUtils;
  40  import org.apache.commons.logging.Log;
  41  import org.apache.commons.logging.LogFactory;
  42  import org.apache.tika.Tika;
  43  import org.apache.tika.mime.MimeType;
  44  import org.apache.tika.mime.MimeTypeException;
  45  import org.apache.tika.mime.MimeTypes;
  46  import org.broadleafcommerce.cms.field.type.StorageType;
  47  import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  48  import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  49  import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  50  import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  51  import org.broadleafcommerce.cms.file.domain.StaticAsset;
  52  import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  53  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  54  import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  55  import org.broadleafcommerce.common.util.StringUtil;
  56  import org.broadleafcommerce.common.util.TransactionUtils;
  57  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  58  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  59  import org.springframework.beans.factory.annotation.Value;
  60  import org.springframework.stereotype.Service;
  61  import org.springframework.transaction.annotation.Transactional;
  62  import org.springframework.web.multipart.MultipartFile;
  63  
  64  import java.io.IOException;
  65  import java.io.InputStream;
  66  import java.io.UnsupportedEncodingException;
  67  import java.net.URLDecoder;
  68  import java.util.Arrays;
  69  import java.util.HashMap;
  70  import java.util.List;
  71  import java.util.Map;
  72  import java.util.Random;
  73  
  74  import javax.annotation.Resource;
  75  
  76  /**
  77   * Created by bpolster.
  78   */
  79  @Service(&quot;blStaticAssetService&quot;)
  80  public class StaticAssetServiceImpl implements StaticAssetService {
  81  
  82      private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of ðŸ”µ</abbr>
  84  
  85      @Resource(name = &quot;blImageArtifactProcessor&quot;)
  86      protected ImageArtifactProcessor imageArtifactProcessor;
  87  
  88      @Value(&quot;${asset.use.filesystem.storage}&quot;)
  89      protected boolean storeAssetsOnFileSystem = false;
  90  
  91      @Resource(name = &quot;blStaticAssetDao&quot;)
  92      protected StaticAssetDao staticAssetDao;
  93  
  94      @Resource(name = &quot;blStaticAssetStorageService&quot;)
  95      protected StaticAssetStorageService staticAssetStorageService;
  96  
  97      @Resource(name = &quot;blStaticAssetPathService&quot;)
  98      protected StaticAssetPathService staticAssetPathService;
  99  
 100      @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
 101      protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 102  
 103      @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 104      protected boolean shouldAcceptNonImageAsset;
 105  
 106      @Value(&quot;${disabled.file.extensions}&quot;)
 107      protected String disabledFileExtensions;
 108  
 109      private final Random random = new Random();
 110      private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 111  
 112      @Override
 113      public StaticAsset findStaticAssetById(Long id) {
 114          return staticAssetDao.readStaticAssetById(id);
 115      }
 116  
 117      @Override
 118      public List&lt;StaticAsset&gt; readAllStaticAssets() {
 119          return staticAssetDao.readAllStaticAssets();
 120      }
 121  
 122      @Override
 123      public Long findTotalStaticAssetCount() {
 124          return staticAssetDao.readTotalStaticAssetCount();
 125      }
 126  
 127      protected String getFileExtension(String fileName) {
 128          int pos = fileName.lastIndexOf(&quot;.&quot;);
 129          if (pos &gt; 0) {
 130              return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 131          } else {
 132              LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 133              return null;
 134          }
 135      }
 136  
 137      /**
 138       * Generates a filename as a set of Hex digits.
 139       *
 140       * @param size
 141       * @return
 142       */
 143      protected String generateFileName(int size) {
 144          StringBuilder sb = new StringBuilder();
 145          for (int i = 0; i &lt; size; i++) {
 146              int pos = random.nextInt(FILE_NAME_CHARS.length());
 147              sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 148          }
 149          return sb.toString();
 150      }
 151  
 152      /**
 153       * Will assemble the url from the passed in properties as
 154       * /{entityType}/{fileName}
 155       * /product/7001-ab12
 156       * &lt;p&gt;
 157       * If the properties above are not set, it will generate the fileName randomly.
 158       *
 159       * @param url
 160       * @param asset
 161       * @param assetProperties
 162       * @return
 163       */
 164      protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 165          StringBuilder path = new StringBuilder(&quot;/&quot;);
 166  
 167          String entityType = assetProperties.get(&quot;entityType&quot;);
 168          String entityId = assetProperties.get(&quot;entityId&quot;);
 169          String fileName = assetProperties.get(&quot;fileName&quot;);
 170  
 171          if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 172              path = path.append(entityType).append(&quot;/&quot;);
 173          }
 174  
 175          if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 176              path = path.append(entityId).append(&quot;/&quot;);
 177          }
 178  
 179          if (fileName != null) {
 180              int pos = fileName.indexOf(&quot;:&quot;);
 181              if (pos &gt; 0) {
 182                  if (LOG.isTraceEnabled()) {
 183                      LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 184                  }
 185                  fileName = fileName.substring(pos + 1);
 186              }
 187          } else {
 188              fileName = originalFilename;
 189          }
 190  
 191          return path.append(fileName).toString();
 192      }
 193  
 194      private static String normalizeFileExtension(MultipartFile file) {
 195          int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 196          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 196          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1ðŸ”µ</abbr>
 197      }
 198  
 199      private static String getFileExtension(MultipartFile file) {
 200          String tikaExtension = null;
 201          try {
 202              final Tika tika = new Tika();
 203              final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 204              final String detectedType;
 205              detectedType = tika.detect(file.getBytes());
 206              if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 207                  final MimeType mimeType = allTypes.forName(detectedType);
 208                  tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 209              }
 210          } catch (IOException | MimeTypeException ignored) {
 211          }
<abbr title=" 212          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 212          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(fiðŸ”µ</abbr>
 213      }
 214  
 215      public void validateFileExtension(MultipartFile file) throws IOException {
 216          final String extension = getFileExtension(file);
 217          if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 218              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 218              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;))ðŸ”µ</abbr>
 219              LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 220              if (extensions.contains(extension)) {
 221                  LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 222                  throw new IOException(&quot;Invalid extension type of file.&quot;);
 223              }
 224          }
 225      }
 226  
 227      @Override
 228      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 229      public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 230          try {
 231              validateFileExtension(file);

<abbr title=" 232              return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), properties);"> 232              return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), propertiðŸ”µ</abbr>
 233          } catch (IOException e) {
 234              throw new RuntimeException(e);
 235          }
 236      }
 237  
 238      @Override
 239      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 240      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 240      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, StriðŸ”µ</abbr>
 241          if (properties == null) {
 242              properties = new HashMap&lt;String, String&gt;();
 243          }
 244  
 245          String fullUrl = buildAssetURL(properties, fileName);
 246          StringBuilder urlBuilder = new StringBuilder();
 247          urlBuilder.append(fullUrl);
<abbr title=" 248          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 248          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURðŸ”µ</abbr>
 249          fullUrl = urlBuilder.toString();
 250          StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 251          // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 252          // logic for handling duplicate files.
 253          if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 254              int count = 0;
 255              while (newAsset != null) {
 256                  count++;
 257                  //try the new format first, then the old
 258                  newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 259                  if (newAsset == null) {
 260                      newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));
 261                  }
 262              }
 263  
 264              if (count &gt; 0) {
 265                  fullUrl = getCountUrl(fullUrl, count, false);
 266              }
 267          }
 268  
 269          try {
 270              ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 271              newAsset = new ImageStaticAssetImpl();
 272              ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 273              ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 274          } catch (Exception e) {
 275              //must not be an image stream
 276              LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 277              LOG.debug(e);
 278  
 279              if (getShouldAcceptNonImageAsset()) {
 280                  newAsset = createNonImageAsset(inputStream, fileName, properties);
 281              } else {
 282                  throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 283              }
 284          }
 285          if (storeAssetsOnFileSystem) {
 286              newAsset.setStorageType(StorageType.FILESYSTEM);
 287          } else {
 288              newAsset.setStorageType(StorageType.DATABASE);
 289          }
 290  
 291          newAsset.setName(fileName);
 292          getMimeType(inputStream, fileName, newAsset);
 293          newAsset.setFileExtension(getFileExtension(fileName));
 294          newAsset.setFileSize(fileSize);
 295          newAsset.setFullUrl(fullUrl);
 296  
 297          return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 298      }
 299  
 300      /**
 301       * Hook-point for implementors to add custom business logic for handling files that are non-images
 302       *
 303       * @param inputStream
 304       * @param fileName
 305       * @param properties
 306       * @return
 307       */
<abbr title=" 308      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 308      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properðŸ”µ</abbr>
 309          return new StaticAssetImpl();
 310      }
 311  
 312      /**
 313       * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:
 314       * &lt;p&gt;
 315       * /path/to/image.jpg-1
 316       * /path/to/image.jpg-2
 317       * &lt;p&gt;
 318       * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 319       * &lt;p&gt;
 320       * /path/to/image-1.jpg
 321       * /path/to/image-2.jpg
 322       * &lt;p&gt;
 323       * Used to deal with duplicate URLs of uploaded assets
 324       */
 325      protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 326          String countUrl = fullUrl + &#x27;-&#x27; + count;
 327          int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 328          if (dotIndex != -1 &amp;&amp; !legacyFormat) {
 329              countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);
 330          }
 331  
 332          return countUrl;
 333      }
 334  
 335      protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 336          Tika tika = new Tika();
 337          String tikaMimeType = tika.detect(fileName);
 338          if (tikaMimeType == null) {
 339              try {
 340                  tikaMimeType = tika.detect(inputStream);
 341              } catch (IOException e) {
 342                  //if tika can&#x27;t resolve, don&#x27;t throw exception
 343              }
 344          }
 345          if (tikaMimeType != null) {
 346              newAsset.setMimeType(tikaMimeType);
 347          }
 348      }
 349  
 350      @Override
 351      public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 352          try {
 353              fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 354              //strip out the jsessionid if it&#x27;s there
 355              fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 356          } catch (UnsupportedEncodingException e) {
 357              throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 358          }
 359          return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 360      }
 361  
 362      @Override
 363      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 364      public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 365          StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 366          return newAsset;
 367      }
 368  
 369      @Override
 370      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 371      public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 372          return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 373      }
 374  
 375      @Override
 376      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 377      public void deleteStaticAsset(StaticAsset staticAsset) {
 378          staticAssetDao.delete(staticAsset);
 379      }
 380  
 381      @Override
 382      public String getStaticAssetUrlPrefix() {
 383          return staticAssetPathService.getStaticAssetUrlPrefix();
 384      }
 385  
 386      @Override
 387      public String getPrefixedStaticAssetUrl(String assetUrl) {
 388          String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 389          if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 390              staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 391          }
 392          if (staticAssetUrlPrefix != null) {
 393              return staticAssetUrlPrefix + assetUrl;
 394          }
 395          return assetUrl;
 396      }
 397  
 398      @Override
 399      public String getStaticAssetEnvironmentUrlPrefix() {
 400          return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 401      }
 402  
 403      @Override
 404      public String getStaticAssetEnvironmentSecureUrlPrefix() {
 405          return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 406      }
 407  
 408      @Override
 409      public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 410          return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 411      }
 412  
 413      public boolean getShouldAcceptNonImageAsset() {
 414          return shouldAcceptNonImageAsset;
 415      }
 416  
 417      public void setShouldAcceptNonImageAsset(boolean accept) {
 418          shouldAcceptNonImageAsset = accept;
 419      }
 420  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            