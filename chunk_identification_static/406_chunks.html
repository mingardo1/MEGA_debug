<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>406 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                         &#x27;fieldExtraInfos;\n&#x27;
                         &#x27;    private TypeInformation&lt;Row&gt; typeInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private final &#x27;
                           &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                           &#x27;fieldExtraInfos;\n&#x27;
                           &#x27;    private final String charsetName;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public &#x27;
                         &#x27;DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; &#x27;
                         &#x27;typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, &#x27;
                         &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                         &#x27;fieldExtraInfos) {\n&#x27;
                         &#x27;        this.typeInfo = typeInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public &#x27;
                           &#x27;DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; &#x27;
                           &#x27;typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,\n&#x27;
                           &#x27;                                          &#x27;
                           &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                           &#x27;fieldExtraInfos,\n&#x27;
                           &#x27;                                          String &#x27;
                           &#x27;charsetName) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public &#x27;
                         &#x27;DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; &#x27;
                         &#x27;typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, &#x27;
                         &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                         &#x27;fieldExtraInfos) {\n&#x27;
                         &#x27;        this.typeInfo = typeInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public &#x27;
                           &#x27;DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; &#x27;
                           &#x27;typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,\n&#x27;
                           &#x27;                                          &#x27;
                           &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                           &#x27;fieldExtraInfos,\n&#x27;
                           &#x27;                                          String &#x27;
                           &#x27;charsetName) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;Row&gt; getProducedType() {\n&#x27;
                         &#x27;        return typeInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private Row convertTopRow() {\n&#x27;
                           &#x27;        Row row = new Row(fieldNames.length);\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            for (int i = 0; i &lt; fieldNames.length; &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;                JsonNode node = &#x27;
                           &#x27;getIgnoreCase(fieldNames[i]);\n&#x27;
                           &#x27;                AbstractTableInfo.FieldExtraInfo &#x27;
                           &#x27;fieldExtraInfo = fieldExtraInfos.get(i);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if (node == null) {\n&#x27;
                           &#x27;                    if (fieldExtraInfo != null &amp;&amp; &#x27;
                           &#x27;fieldExtraInfo.getNotNull()) {\n&#x27;
                           &#x27;                        throw new &#x27;
                           &#x27;IllegalStateException(&quot;Failed to find field with &#x27;
                           &#x27;name \&#x27;&quot;\n&#x27;
                           &#x27;                            + fieldNames[i] + &#x27;
                           &#x27;&quot;\&#x27;.&quot;);\n&#x27;
                           &#x27;                    } else {\n&#x27;
                           &#x27;                        row.setField(i, null);\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    // Read the value as specified &#x27;
                           &#x27;type\n&#x27;
                           &#x27;                    Object value = convert(node, &#x27;
                           &#x27;fieldTypes[i]);\n&#x27;
                           &#x27;                    row.setField(i, value);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return row;\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            nodeAndJsonNodeMapping.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Row convertRow(JsonNode node, &#x27;
                           &#x27;RowTypeInfo info) {\n&#x27;
                           &#x27;        final String[] names = &#x27;
                           &#x27;info.getFieldNames();\n&#x27;
                           &#x27;        final TypeInformation&lt;?&gt;[] types = &#x27;
                           &#x27;info.getFieldTypes();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final Row row = new Row(names.length);\n&#x27;
                           &#x27;        for (int i = 0; i &lt; names.length; i++) {\n&#x27;
                           &#x27;            final String name = names[i];\n&#x27;
                           &#x27;            final JsonNode subNode = &#x27;
                           &#x27;node.get(name);\n&#x27;
                           &#x27;            if (subNode == null) {\n&#x27;
                           &#x27;                row.setField(i, null);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                row.setField(i, convert(subNode, &#x27;
                           &#x27;types[i]));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return row;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Object convertObjectArray(JsonNode &#x27;
                           &#x27;node, TypeInformation&lt;?&gt; elementType) {\n&#x27;
                           &#x27;        final Object[] array = (Object[]) &#x27;
                           &#x27;Array.newInstance(elementType.getTypeClass(), &#x27;
                           &#x27;node.size());\n&#x27;
                           &#x27;        for (int i = 0; i &lt; node.size(); i++) {\n&#x27;
                           &#x27;            array[i] = convert(node.get(i), &#x27;
                           &#x27;elementType);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return array;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                         &#x27;fieldExtraInfos;\n&#x27;
                         &#x27;    private TypeInformation&lt;Row&gt; typeInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private final &#x27;
                           &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                           &#x27;fieldExtraInfos;\n&#x27;
                           &#x27;    private final String charsetName;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public &#x27;
                         &#x27;DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; &#x27;
                         &#x27;typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, &#x27;
                         &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                         &#x27;fieldExtraInfos) {\n&#x27;
                         &#x27;        this.typeInfo = typeInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public &#x27;
                           &#x27;DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; &#x27;
                           &#x27;typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,\n&#x27;
                           &#x27;                                          &#x27;
                           &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                           &#x27;fieldExtraInfos,\n&#x27;
                           &#x27;                                          String &#x27;
                           &#x27;charsetName) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public &#x27;
                         &#x27;DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; &#x27;
                         &#x27;typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, &#x27;
                         &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                         &#x27;fieldExtraInfos) {\n&#x27;
                         &#x27;        this.typeInfo = typeInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public &#x27;
                           &#x27;DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; &#x27;
                           &#x27;typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,\n&#x27;
                           &#x27;                                          &#x27;
                           &#x27;List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                           &#x27;fieldExtraInfos,\n&#x27;
                           &#x27;                                          String &#x27;
                           &#x27;charsetName) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    @Override\n&#x27;
                         &#x27;    public TypeInformation&lt;Row&gt; getProducedType() {\n&#x27;
                         &#x27;        return typeInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private Row convertTopRow() {\n&#x27;
                           &#x27;        Row row = new Row(fieldNames.length);\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            for (int i = 0; i &lt; fieldNames.length; &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;                JsonNode node = &#x27;
                           &#x27;getIgnoreCase(fieldNames[i]);\n&#x27;
                           &#x27;                AbstractTableInfo.FieldExtraInfo &#x27;
                           &#x27;fieldExtraInfo = fieldExtraInfos.get(i);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if (node == null) {\n&#x27;
                           &#x27;                    if (fieldExtraInfo != null &amp;&amp; &#x27;
                           &#x27;fieldExtraInfo.getNotNull()) {\n&#x27;
                           &#x27;                        throw new &#x27;
                           &#x27;IllegalStateException(&quot;Failed to find field with &#x27;
                           &#x27;name \&#x27;&quot;\n&#x27;
                           &#x27;                            + fieldNames[i] + &#x27;
                           &#x27;&quot;\&#x27;.&quot;);\n&#x27;
                           &#x27;                    } else {\n&#x27;
                           &#x27;                        row.setField(i, null);\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    // Read the value as specified &#x27;
                           &#x27;type\n&#x27;
                           &#x27;                    Object value = convert(node, &#x27;
                           &#x27;fieldTypes[i]);\n&#x27;
                           &#x27;                    row.setField(i, value);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return row;\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            nodeAndJsonNodeMapping.clear();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Row convertRow(JsonNode node, &#x27;
                           &#x27;RowTypeInfo info) {\n&#x27;
                           &#x27;        final String[] names = &#x27;
                           &#x27;info.getFieldNames();\n&#x27;
                           &#x27;        final TypeInformation&lt;?&gt;[] types = &#x27;
                           &#x27;info.getFieldTypes();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final Row row = new Row(names.length);\n&#x27;
                           &#x27;        for (int i = 0; i &lt; names.length; i++) {\n&#x27;
                           &#x27;            final String name = names[i];\n&#x27;
                           &#x27;            final JsonNode subNode = &#x27;
                           &#x27;node.get(name);\n&#x27;
                           &#x27;            if (subNode == null) {\n&#x27;
                           &#x27;                row.setField(i, null);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                row.setField(i, convert(subNode, &#x27;
                           &#x27;types[i]));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return row;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Object convertObjectArray(JsonNode &#x27;
                           &#x27;node, TypeInformation&lt;?&gt; elementType) {\n&#x27;
                           &#x27;        final Object[] array = (Object[]) &#x27;
                           &#x27;Array.newInstance(elementType.getTypeClass(), &#x27;
                           &#x27;node.size());\n&#x27;
                           &#x27;        for (int i = 0; i &lt; node.size(); i++) {\n&#x27;
                           &#x27;            array[i] = convert(node.get(i), &#x27;
                           &#x27;elementType);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return array;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}]]</pre>
          </body>
        </html>
        