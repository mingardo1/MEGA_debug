<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>485</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    485
                    <a href="484.html">prev</a>
                    <a href="486.html">next</a>
                    <a href="485_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_e346a804d69c8cd0124b4eb3d35156cfb5cd0779_core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779^1:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779^2:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;6e351a99f6e8449c76ad55e517a5da6cbb108379:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b], [j]], subset: [[b], [b], [b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheContentType;
  24 import com.dtstack.flink.sql.enums.ECacheType;
  25 import com.dtstack.flink.sql.metric.MetricConstant;
  26 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  27 import com.dtstack.flink.sql.side.cache.CacheObj;
  28 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  29 import com.google.common.collect.Lists;
  30 import com.google.common.collect.Maps;
  31 import org.apache.calcite.sql.JoinType;
  32 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  33 import org.apache.flink.api.java.tuple.Tuple2;</span>
  34 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  35 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  36 import org.apache.flink.metrics.Counter;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  37 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  38 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  39 import org.apache.flink.table.runtime.types.CRow;</span>
  40 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  41 import org.apache.commons.collections.MapUtils;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  42 import org.apache.flink.api.common.functions.RuntimeContext;</span>
  43 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  44 import org.apache.flink.configuration.Configuration;
  45 import org.apache.flink.metrics.Counter;
  46 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  47 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  48 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  49 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
  50 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  51 import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  52 import org.slf4j.Logger;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  53 import org.slf4j.LoggerFactory;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  54 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  55 import java.util.Collections;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  56 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  57 /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  58  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  59  * only support Left join / inner join(join),not support right join</span>
  60 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  61 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  62 import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  63 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  64 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  65 import org.apache.flink.table.runtime.types.CRow;</span>
  66 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  67 import org.apache.flink.types.Row;
  68 import org.slf4j.Logger;
  69 import org.slf4j.LoggerFactory;
  70 
  71 import java.sql.Timestamp;
  72 import java.time.LocalDateTime;
  73 import java.util.Collections;
  74 import java.util.List;
  75 import java.util.Map;
  76 import java.util.concurrent.LinkedBlockingQueue;
  77 import java.util.concurrent.ScheduledFuture;
  78 import java.util.concurrent.ThreadPoolExecutor;
  79 import java.util.concurrent.TimeUnit;
  80 
  81 /**
  82  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  83  * only support Left join / inner join(join),not support right join
  84  * Date: 2018/7/9
  85  * Company: www.dtstack.com
  86  * @author xuchao
  87  */
  88 
<abbr title="  89 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt; implements ISideReqRow {">  89 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt;ðŸ”µ</abbr>
  90     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  91     private static final long serialVersionUID = 2098635244857937717L;
  92     private RuntimeContext runtimeContext;
  93     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  94     private int timeOutNum = 0;
  95     protected BaseSideInfo sideInfo;
  96     protected transient Counter parseErrorRecords;
  97 
  98     public BaseAsyncReqRow(BaseSideInfo sideInfo){
  99         this.sideInfo = sideInfo;
 100     }
 101     @Override
 102     public void setRuntimeContext(RuntimeContext runtimeContext) {
 103         super.setRuntimeContext(runtimeContext);
 104         this.runtimeContext = runtimeContext;
 105     }
 106     @Override
 107     public void open(Configuration parameters) throws Exception {
 108         super.open(parameters);
 109         initCache();
 110         initMetric();
 111         LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());
 112     }
 113 
 114     private void initCache(){
 115         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title=" 116         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){"> 116         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
 117             return;
 118         }
 119 
 120         AbstractSideCache sideCache;
 121         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
 122             sideCache = new LRUSideCache(sideTableInfo);
 123             sideInfo.setSideCache(sideCache);
 124         }else{
<abbr title=" 125             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());"> 125             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 126         }
 127 
 128         sideCache.initCache();
 129     }
 130 
 131     private void initMetric() {
<abbr title=" 132         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 132         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 133     }
 134 
 135 
 136     protected Object convertTimeIndictorTypeInfo(Integer index, Object obj) {
<abbr title=" 137         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());"> 137         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypðŸ”µ</abbr>
 138 
<abbr title=" 139         //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 139         //Type information for indicating event or processing time. However, it behaves like a regular SQðŸ”µ</abbr>
 140         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {
 141             obj = Timestamp.valueOf(((LocalDateTime) obj));
 142         }
 143         return obj;
 144     }
 145 
 146     protected CacheObj getFromCache(String key){
 147         return sideInfo.getSideCache().getFromCache(key);
 148     }
 149 
 150     protected void putCache(String key, CacheObj value){
 151         sideInfo.getSideCache().putCache(key, value);
 152     }
 153 
 154     protected boolean openCache(){
 155         return sideInfo.getSideCache() != null;
 156     }
 157 
<abbr title=" 158     protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 158     protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)ðŸ”µ</abbr>
 159         if(sideInfo.getJoinType() == JoinType.LEFT){
 160             //Reserved left table data
 161             try {
 162                 Row row = fillData(input.f1, null);
 163                 resultFuture.complete(Collections.singleton(new Tuple2&lt;&gt;(input.f0, row)));
 164             } catch (Exception e) {
 165                 dealFillDataError(input, resultFuture, e);
 166             }
 167         }else{
 168             resultFuture.complete(null);
 169         }
 170     }
 171 
 172     protected void dealCacheData(String key, CacheObj missKeyObj) {
 173         if (openCache()) {
 174             putCache(key, missKeyObj);
 175         }
 176     }
 177 
 178     @Override
<abbr title=" 179     public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 179     public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throwsðŸ”µ</abbr>
 180 
 181         if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
<abbr title=" 182             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);"> 182             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOðŸ”µ</abbr>
 183         }
 184         timeOutNum ++;
 185         if(sideInfo.getJoinType() == JoinType.LEFT){
 186             resultFuture.complete(null);
 187             return;
 188         }
 189         if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
<abbr title=" 190             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 190             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 191             return;
 192         }
 193         resultFuture.complete(null);
 194     }
 195 
 196     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 197         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 198         cancelTimerWhenComplete(resultFuture, timeFuture);
 199     }
 200 
 201     @Override
 202     public void asyncInvoke(CRow row, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 203         CRow input = new CRow(Row.copy(row.row()), row.change());
 204         preInvoke(input, resultFuture);
 205         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 206         if(MapUtils.isEmpty(inputParams)){
 207             dealMissKey(input, resultFuture);
 208             return;
 209         }
 210         if(isUseCache(inputParams)){
 211             invokeWithCache(inputParams, input, resultFuture);
 212             return;
 213         }
 214         handleAsyncInvoke(inputParams, input, resultFuture);
 215     }
 216 
 217     private Map&lt;String, Object&gt; parseInputParam(CRow input){
 218         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 219         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 220             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 221             Object equalObj = input.row().getField(conValIndex);
 222             if(equalObj == null){
 223                 return inputParams;
 224             }
 225             String columnName = sideInfo.getEqualFieldList().get(i);
 226             inputParams.put(columnName, equalObj);
 227         }
 228         return inputParams;
 229     }
 230 
 231     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 232         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 233     }
 234 
<abbr title=" 235     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 235     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuðŸ”µ</abbr>
 236         if (openCache()) {
 237             CacheObj val = getFromCache(buildCacheKey(inputParams));
 238             if (val != null) {
 239                 if (ECacheContentType.MissVal == val.getType()) {
 240                     dealMissKey(input, resultFuture);
 241                     return;
 242                 }else if(ECacheContentType.SingleLine == val.getType()){
 243                     try {
 244                         Row row = fillData(input.row(), val.getContent());
 245                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 246                     } catch (Exception e) {
 247                         dealFillDataError(input, resultFuture, e);
 248                     }
 249                 } else if (ECacheContentType.MultiLine == val.getType()) {
 250                     try {
 251                         List&lt;CRow&gt; rowList = Lists.newArrayList();
 252                         for (Object one : (List) val.getContent()) {
 253                             Row row = fillData(input.row(), one);
 254                             rowList.add(new CRow(row, input.change()));
 255                         }
 256                         resultFuture.complete(rowList);
 257                     } catch (Exception e) {
 258                         dealFillDataError(input, resultFuture, e);
 259                     }
 260                 } else {
<abbr title=" 261                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 261                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 262                 }
 263                 return;
 264             }
 265         }
 266     }
 267 
<abbr title=" 268     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 268     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRoðŸ”µ</abbr>
 269 
 270 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 271     protected void dealFillDataError(ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Exception e, Object sourceData) {"> 271     protected void dealFillDataError(ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Exception e, Object ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 272         LOG.debug(&quot;source data {} join side table error &quot;, sourceData);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 273         LOG.debug(&quot;async buid row error..{}&quot;, e);</span>
 274 ||||||| GitAnalyzerPlus_base
 275 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 276     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 277 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 278     private ProcessingTimeService getProcessingTimeService(){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 279         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 280     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 281 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 282     protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 283         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 283         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 284         return getProcessingTimeService().registerTimer(</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 285                 timeoutTimestamp,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 286                 new ProcessingTimeCallback() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 287                     @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 288                     public void onProcessingTime(long timestamp) throws Exception {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 289                         timeout(input, resultFuture);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 290                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 291                 });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 292     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 293 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 294     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){"> 294     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuturðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 295         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 295         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 296         if(resultFuture instanceof StreamRecordQueueEntry){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 297             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 298             streamRecordBufferEntry.onComplete((Object value) -&gt; {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 299                 timerFuture.cancel(true);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 300             },executors);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 301         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 302     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 303 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 304     protected void dealFillDataError(CRow input, ResultFuture&lt;CRow&gt; resultFuture, Throwable e) {</span>
 305 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 306         parseErrorRecords.inc();
<abbr title=" 307         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){"> 307         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE))ðŸ”µ</abbr>
 308             LOG.info(&quot;dealFillDataError&quot;, e);
 309             resultFuture.completeExceptionally(e);
 310         } else {
 311             dealMissKey(input, resultFuture);
 312         }
 313     }
 314 
 315     @Override
 316     public void close() throws Exception {
 317         super.close();
 318     }
 319 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheContentType;
  24 import com.dtstack.flink.sql.enums.ECacheType;
  25 import com.dtstack.flink.sql.metric.MetricConstant;
  26 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  27 import com.dtstack.flink.sql.side.cache.CacheObj;
  28 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  29 import com.google.common.collect.Lists;
  30 import com.google.common.collect.Maps;
  31 import org.apache.calcite.sql.JoinType;
  32 import org.apache.flink.api.java.tuple.Tuple2;
  33 import org.apache.commons.collections.MapUtils;
  34 import org.apache.flink.api.common.functions.RuntimeContext;
  35 import org.apache.flink.configuration.Configuration;
  36 import org.apache.flink.metrics.Counter;
  37 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  38 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  39 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  40 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
  41 import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;
  42 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  43 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
  44 import org.apache.flink.types.Row;
  45 import org.slf4j.Logger;
  46 import org.slf4j.LoggerFactory;
  47 
  48 import java.sql.Timestamp;
  49 import java.time.LocalDateTime;
  50 import java.util.Collections;
  51 import java.util.List;
  52 import java.util.Map;
  53 import java.util.concurrent.LinkedBlockingQueue;
  54 import java.util.concurrent.ScheduledFuture;
  55 import java.util.concurrent.ThreadPoolExecutor;
  56 import java.util.concurrent.TimeUnit;
  57 
  58 /**
  59  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  60  * only support Left join / inner join(join),not support right join
  61  * Date: 2018/7/9
  62  * Company: www.dtstack.com
  63  * @author xuchao
  64  */
  65 
<abbr title="  66 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt; implements ISideReqRow {">  66 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt;ðŸ”µ</abbr>
  67     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  68     private static final long serialVersionUID = 2098635244857937717L;
  69     private RuntimeContext runtimeContext;
  70     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  71     private int timeOutNum = 0;
  72     protected BaseSideInfo sideInfo;
  73     protected transient Counter parseErrorRecords;
  74 
  75     public BaseAsyncReqRow(BaseSideInfo sideInfo){
  76         this.sideInfo = sideInfo;
  77     }
  78     @Override
  79     public void setRuntimeContext(RuntimeContext runtimeContext) {
  80         super.setRuntimeContext(runtimeContext);
  81         this.runtimeContext = runtimeContext;
  82     }
  83     @Override
  84     public void open(Configuration parameters) throws Exception {
  85         super.open(parameters);
  86         initCache();
  87         initMetric();
  88         LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());
  89     }
  90 
  91     private void initCache(){
  92         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  93         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  93         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
  94             return;
  95         }
  96 
  97         AbstractSideCache sideCache;
  98         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
  99             sideCache = new LRUSideCache(sideTableInfo);
 100             sideInfo.setSideCache(sideCache);
 101         }else{
<abbr title=" 102             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());"> 102             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 103         }
 104 
 105         sideCache.initCache();
 106     }
 107 
 108     private void initMetric() {
<abbr title=" 109         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 109         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 110     }
 111 
 112 
 113     protected Object convertTimeIndictorTypeInfo(Integer index, Object obj) {
<abbr title=" 114         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());"> 114         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypðŸ”µ</abbr>
 115 
<abbr title=" 116         //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 116         //Type information for indicating event or processing time. However, it behaves like a regular SQðŸ”µ</abbr>
 117         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {
 118             obj = Timestamp.valueOf(((LocalDateTime) obj));
 119         }
 120         return obj;
 121     }
 122 
 123     protected CacheObj getFromCache(String key){
 124         return sideInfo.getSideCache().getFromCache(key);
 125     }
 126 
 127     protected void putCache(String key, CacheObj value){
 128         sideInfo.getSideCache().putCache(key, value);
 129     }
 130 
 131     protected boolean openCache(){
 132         return sideInfo.getSideCache() != null;
 133     }
 134 
<abbr title=" 135     protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 135     protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)ðŸ”µ</abbr>
 136         if(sideInfo.getJoinType() == JoinType.LEFT){
 137             //Reserved left table data
 138             try {
 139                 Row row = fillData(input.f1, null);
 140                 resultFuture.complete(Collections.singleton(new Tuple2&lt;&gt;(input.f0, row)));
 141             } catch (Exception e) {
 142                 dealFillDataError(input, resultFuture, e);
 143             }
 144         }else{
 145             resultFuture.complete(null);
 146         }
 147     }
 148 
 149     protected void dealCacheData(String key, CacheObj missKeyObj) {
 150         if (openCache()) {
 151             putCache(key, missKeyObj);
 152         }
 153     }
 154 
 155     @Override
<abbr title=" 156     public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 156     public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throwsðŸ”µ</abbr>
 157 
 158         if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
<abbr title=" 159             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);"> 159             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOðŸ”µ</abbr>
 160         }
 161         timeOutNum ++;
 162         if(sideInfo.getJoinType() == JoinType.LEFT){
 163             resultFuture.complete(null);
 164             return;
 165         }
 166         if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
<abbr title=" 167             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 167             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 168             return;
 169         }
 170         resultFuture.complete(null);
 171     }
 172 
 173 
 174 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 175     protected void dealFillDataError(ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Exception e, Object sourceData) {"> 175     protected void dealFillDataError(ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Exception e, Object ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 176         LOG.debug(&quot;source data {} join side table error &quot;, sourceData);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 177         LOG.debug(&quot;async buid row error..{}&quot;, e);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 178         parseErrorRecords.inc();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 179         resultFuture.complete(Collections.emptyList());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 180     }</span>
 181 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182     protected void dealFillDataError(ResultFuture&lt;CRow&gt; resultFuture, Exception e, Object sourceData) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183         LOG.debug(&quot;source data {} join side table error &quot;, sourceData);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184         LOG.debug(&quot;async buid row error..{}&quot;, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185         parseErrorRecords.inc();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186         resultFuture.complete(Collections.emptyList());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187     }</span>
 188 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 189 </span>
 190 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 191 
 192     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 193         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 194         cancelTimerWhenComplete(resultFuture, timeFuture);
 195     }
 196 
 197     @Override
 198     public void asyncInvoke(CRow row, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 199         CRow input = new CRow(Row.copy(row.row()), row.change());
 200         preInvoke(input, resultFuture);
 201         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 202         if(MapUtils.isEmpty(inputParams)){
 203             dealMissKey(input, resultFuture);
 204             return;
 205         }
 206         if(isUseCache(inputParams)){
 207             invokeWithCache(inputParams, input, resultFuture);
 208             return;
 209         }
 210         handleAsyncInvoke(inputParams, input, resultFuture);
 211     }
 212 
 213     private Map&lt;String, Object&gt; parseInputParam(CRow input){
 214         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 215         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 216             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 217             Object equalObj = input.row().getField(conValIndex);
 218             if(equalObj == null){
 219                 return inputParams;
 220             }
 221             String columnName = sideInfo.getEqualFieldList().get(i);
 222             inputParams.put(columnName, equalObj);
 223         }
 224         return inputParams;
 225     }
 226 
 227     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 228         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 229     }
 230 
<abbr title=" 231     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 231     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuðŸ”µ</abbr>
 232         if (openCache()) {
 233             CacheObj val = getFromCache(buildCacheKey(inputParams));
 234             if (val != null) {
 235                 if (ECacheContentType.MissVal == val.getType()) {
 236                     dealMissKey(input, resultFuture);
 237                     return;
 238                 }else if(ECacheContentType.SingleLine == val.getType()){
 239                     try {
 240                         Row row = fillData(input.row(), val.getContent());
 241                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 242                     } catch (Exception e) {
 243                         dealFillDataError(input, resultFuture, e);
 244                     }
 245                 } else if (ECacheContentType.MultiLine == val.getType()) {
 246                     try {
 247                         List&lt;CRow&gt; rowList = Lists.newArrayList();
 248                         for (Object one : (List) val.getContent()) {
 249                             Row row = fillData(input.row(), one);
 250                             rowList.add(new CRow(row, input.change()));
 251                         }
 252                         resultFuture.complete(rowList);
 253                     } catch (Exception e) {
 254                         dealFillDataError(input, resultFuture, e);
 255                     }
 256                 } else {
<abbr title=" 257                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 257                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 258                 }
 259                 return;
 260             }
 261         }
 262     }
 263 
<abbr title=" 264     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 264     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRoðŸ”µ</abbr>
 265 
 266     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 267 
 268     private ProcessingTimeService getProcessingTimeService(){
 269         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 270     }
 271 
 272     protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
<abbr title=" 273         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 273         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr>
 274         return getProcessingTimeService().registerTimer(
 275                 timeoutTimestamp,
 276                 new ProcessingTimeCallback() {
 277                     @Override
 278                     public void onProcessingTime(long timestamp) throws Exception {
 279                         timeout(input, resultFuture);
 280                     }
 281                 });
 282     }
 283 
<abbr title=" 284     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){"> 284     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuturðŸ”µ</abbr>
<abbr title=" 285         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 285         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBðŸ”µ</abbr>
 286         if(resultFuture instanceof StreamRecordQueueEntry){
 287             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;
 288             streamRecordBufferEntry.onComplete((Object value) -&gt; {
 289                 timerFuture.cancel(true);
 290             },executors);
 291         }
 292     }
 293 
 294     protected void dealFillDataError(CRow input, ResultFuture&lt;CRow&gt; resultFuture, Throwable e) {
 295         parseErrorRecords.inc();
<abbr title=" 296         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){"> 296         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE))ðŸ”µ</abbr>
 297             LOG.info(&quot;dealFillDataError&quot;, e);
 298             resultFuture.completeExceptionally(e);
 299         } else {
 300             dealMissKey(input, resultFuture);
 301         }
 302     }
 303 
 304     @Override
 305     public void close() throws Exception {
 306         super.close();
 307     }
 308 }
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.enums.ECacheType;
  22 import com.dtstack.flink.sql.metric.MetricConstant;
  23 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  24 import com.dtstack.flink.sql.side.cache.CacheObj;
  25 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  26 import com.google.common.collect.Lists;
  27 import com.google.common.collect.Maps;
  28 import java.sql.Timestamp;
  29 import java.time.LocalDateTime;
  30 import java.util.Collections;
  31 import java.util.List;
  32 import java.util.Map;
  33 import java.util.concurrent.LinkedBlockingQueue;
  34 import java.util.concurrent.ScheduledFuture;
  35 import java.util.concurrent.ThreadPoolExecutor;
  36 import java.util.concurrent.TimeUnit;
  37 import org.apache.calcite.sql.JoinType;
  38 import org.apache.commons.collections.MapUtils;
  39 import org.apache.flink.api.common.functions.RuntimeContext;
  40 import org.apache.flink.api.java.tuple.Tuple2;
  41 import org.apache.flink.configuration.Configuration;
  42 import org.apache.flink.metrics.Counter;
  43 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  44 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  45 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
  46 import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;
  47 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  48 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
  49 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  50 import org.apache.flink.types.Row;
  51 import org.slf4j.Logger;
  52 import org.slf4j.LoggerFactory;
  53 
  54 
  55 /**
  56  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  57  * only support Left join / inner join(join),not support right join
  58  * Date: 2018/7/9
  59  * Company: www.dtstack.com
  60  * @author xuchao
  61  */
<abbr title="  62 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean, Row&gt;, Tuple2&lt;Boolean, Row&gt;&gt; implements ISideReqRow {">  62 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean, Row&gt;, Tuple2&lt;Boolean, RowðŸ”µ</abbr>
  63     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  64 
  65     private static final long serialVersionUID = 2098635244857937717L;
  66 
  67     private RuntimeContext runtimeContext;
  68 
  69     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  70 
  71     private int timeOutNum = 0;
  72 
  73     protected BaseSideInfo sideInfo;
  74 
  75     protected transient Counter parseErrorRecords;
  76 
  77     public BaseAsyncReqRow(BaseSideInfo sideInfo) {
  78         this.sideInfo = sideInfo;
  79     }
  80 
  81     @Override
  82     public void setRuntimeContext(RuntimeContext runtimeContext) {
  83         super.setRuntimeContext(runtimeContext);
  84         this.runtimeContext = runtimeContext;
  85     }
  86 
  87     @Override
  88     public void open(Configuration parameters) throws Exception {
  89         super.open(parameters);
  90         initCache();
  91         initMetric();
  92         LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());
  93     }
  94 
  95     private void initCache(){
  96         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  97         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  97         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
  98             return;
  99         }
 100 
 101         AbstractSideCache sideCache;
 102         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
 103             sideCache = new LRUSideCache(sideTableInfo);
 104             sideInfo.setSideCache(sideCache);
 105         }else{
<abbr title=" 106             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());"> 106             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 107         }
 108         sideCache.initCache();
 109     }
 110 
 111     private void initMetric() {
<abbr title=" 112         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 112         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 113     }
 114 
 115     protected Object convertTimeIndictorTypeInfo(Integer index, Object obj) {
<abbr title=" 116         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());"> 116         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypðŸ”µ</abbr>
 117 
<abbr title=" 118         //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 118         //Type information for indicating event or processing time. However, it behaves like a regular SQðŸ”µ</abbr>
 119         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {
 120             obj = Timestamp.valueOf(((LocalDateTime) obj));
 121         }
 122         return obj;
 123     }
 124 
 125     protected CacheObj getFromCache(String key){
 126         return sideInfo.getSideCache().getFromCache(key);
 127     }
 128 
 129     protected void putCache(String key, CacheObj value){
 130         sideInfo.getSideCache().putCache(key, value);
 131     }
 132 
 133     protected boolean openCache(){
 134         return sideInfo.getSideCache() != null;
 135     }
 136 
<abbr title=" 137     protected void dealMissKey(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) {"> 137     protected void dealMissKey(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuturðŸ”µ</abbr>
 138         if (sideInfo.getJoinType() == JoinType.LEFT) {
 139             //Reserved left table data
 140             try {
 141                 Row row = fillData(input.f1, null);
 142                 resultFuture.complete(Collections.singleton(new Tuple2&lt;&gt;(input.f0, row)));
 143             } catch (java.lang.Exception e) {
 144                 dealFillDataError(input, resultFuture, e);
 145             }
 146         } else {
 147             resultFuture.complete(null);
 148         }
 149     }
 150 
 151     protected void dealCacheData(String key, CacheObj missKeyObj) {
 152         if (openCache()) {
 153             putCache(key, missKeyObj);
 154         }
 155     }
 156 
 157     @Override
<abbr title=" 158     public void timeout(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 158     public void timeout(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throðŸ”µ</abbr>
 159         if ((timeOutNum % TIMEOUT_LOG_FLUSH_NUM) == 0) {
<abbr title=" 160             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;, input.toString(), timeOutNum);"> 160             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;, input.toString(), timeðŸ”µ</abbr>
 161         }
 162         timeOutNum++;
 163         if (sideInfo.getJoinType() == JoinType.LEFT) {
 164             resultFuture.complete(null);
 165             return;
 166         }
 167         if (timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)) {
<abbr title=" 168             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 168             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 169             return;
 170         }
 171         resultFuture.complete(null);
 172     }
 173 
 174     protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 175         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 176         cancelTimerWhenComplete(resultFuture, timeFuture);
 177     }
 178 
 179     @Override
 180     public void asyncInvoke(CRow row, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 181         CRow input = new CRow(Row.copy(row.row()), row.change());
 182         preInvoke(input, resultFuture);
 183         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 184         if(MapUtils.isEmpty(inputParams)){
 185             dealMissKey(input, resultFuture);
 186             return;
 187         }
 188         if(isUseCache(inputParams)){
 189             invokeWithCache(inputParams, input, resultFuture);
 190             return;
 191         }
 192         handleAsyncInvoke(inputParams, input, resultFuture);
 193     }
 194 
 195     private Map&lt;String, Object&gt; parseInputParam(CRow input){
 196         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 197         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 198             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 199             Object equalObj = input.row().getField(conValIndex);
 200             if(equalObj == null){
 201                 return inputParams;
 202             }
 203             String columnName = sideInfo.getEqualFieldList().get(i);
 204             inputParams.put(columnName, equalObj);
 205         }
 206         return inputParams;
 207     }
 208 
 209     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 210         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 211     }
 212 
<abbr title=" 213     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 213     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuðŸ”µ</abbr>
 214         if (openCache()) {
 215             CacheObj val = getFromCache(buildCacheKey(inputParams));
 216             if (val != null) {
 217                 if (ECacheContentType.MissVal == val.getType()) {
 218                     dealMissKey(input, resultFuture);
 219                     return;
 220                 }else if(ECacheContentType.SingleLine == val.getType()){
 221                     try {
 222                         Row row = fillData(input.row(), val.getContent());
 223                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 224                     } catch (Exception e) {
 225                         dealFillDataError(input, resultFuture, e);
 226                     }
 227                 } else if (ECacheContentType.MultiLine == val.getType()) {
 228                     try {
 229                         List&lt;CRow&gt; rowList = Lists.newArrayList();
 230                         for (Object one : (List) val.getContent()) {
 231                             Row row = fillData(input.row(), one);
 232                             rowList.add(new CRow(row, input.change()));
 233                         }
 234                         resultFuture.complete(rowList);
 235                     } catch (Exception e) {
 236                         dealFillDataError(input, resultFuture, e);
 237                     }
 238                 } else {
<abbr title=" 239                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 239                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 240                 }
 241                 return;
 242             }
 243         }
 244     }
 245 
<abbr title=" 246     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 246     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRoðŸ”µ</abbr>
 247 
 248     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 249 
 250     private ProcessingTimeService getProcessingTimeService(){
 251         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 252     }
 253 
 254     protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
<abbr title=" 255         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 255         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr>
 256         return getProcessingTimeService().registerTimer(
 257                 timeoutTimestamp,
 258                 new ProcessingTimeCallback() {
 259                     @Override
 260                     public void onProcessingTime(long timestamp) throws Exception {
 261                         timeout(input, resultFuture);
 262                     }
 263                 });
 264     }
 265 
<abbr title=" 266     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){"> 266     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuturðŸ”µ</abbr>
<abbr title=" 267         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 267         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBðŸ”µ</abbr>
 268         if(resultFuture instanceof StreamRecordQueueEntry){
 269             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;
 270             streamRecordBufferEntry.onComplete((Object value) -&gt; {
 271                 timerFuture.cancel(true);
 272             },executors);
 273         }
 274     }
 275 
<abbr title=" 276     protected void dealFillDataError(CRow input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture, Throwable e) {"> 276     protected void dealFillDataError(CRow input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture, ThrowabðŸ”µ</abbr>
 277         parseErrorRecords.inc();
<abbr title=" 278         if (parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)) {"> 278         if (parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)ðŸ”µ</abbr>
 279             LOG.info(&quot;dealFillDataError&quot;, e);
 280             resultFuture.completeExceptionally(e);
 281         } else {
 282             dealMissKey(input, resultFuture);
 283         }
 284     }
 285 
 286     @Override
 287     public void close() throws Exception {
 288         super.close();
 289     }
 290 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  

  23  import com.dtstack.flink.sql.enums.ECacheType;
  24  import com.dtstack.flink.sql.metric.MetricConstant;
  25  import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  26  import com.dtstack.flink.sql.side.cache.CacheObj;
  27  import com.dtstack.flink.sql.side.cache.LRUSideCache;


  28  import org.apache.calcite.sql.JoinType;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import org.apache.flink.api.java.tuple.Tuple2;</span>

  30  import org.apache.flink.configuration.Configuration;
  31  import org.apache.flink.metrics.Counter;
  32  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  33  import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;




<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
  36  import org.apache.flink.types.Row;
  37  import org.slf4j.Logger;
  38  import org.slf4j.LoggerFactory;
  39  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +import java.time.LocalDateTime;</span>
  42  import java.util.Collections;






  43  
  44  /**
  45   * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  46   * only support Left join / inner join(join),not support right join
  47   * Date: 2018/7/9
  48   * Company: www.dtstack.com
  49   * @author xuchao
  50   */
  51  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  53 +public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt; implements ISideReqRow {">  53 +public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt; implemenðŸ”µ</abbr></span>
  54      private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  55      private static final long serialVersionUID = 2098635244857937717L;
  56  

  57      private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  58      private int timeOutNum = 0;
  59  
  60      protected BaseSideInfo sideInfo;
  61      protected transient Counter parseErrorRecords;
  62  
  63      public BaseAsyncReqRow(BaseSideInfo sideInfo){
  64          this.sideInfo = sideInfo;
  65      }
  66  





  67      @Override
  68      public void open(Configuration parameters) throws Exception {
  69          super.open(parameters);
  70          initCache();
  71          initMetric();

  72      }
  73  
  74      private void initCache(){
  75          AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  76          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  76          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheTðŸ”µ</abbr>
  77              return;
  78          }
  79  
  80          AbstractSideCache sideCache;
  81          if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
  82              sideCache = new LRUSideCache(sideTableInfo);
  83              sideInfo.setSideCache(sideCache);
  84          }else{
  85              throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());
  86          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  87 +</span>
  88          sideCache.initCache();
  89      }
  90  
  91      private void initMetric() {
<abbr title="  92          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);">  92          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_REðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +    protected Object convertTimeIndictorTypeInfo(Integer index, Object obj) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  97 +        boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());">  97 +        boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().gðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  99 +        //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  99 +        //Type information for indicating event or processing time. However, it behaves like a regular SQL timestaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +        if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +            obj = Timestamp.valueOf(((LocalDateTime) obj));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +        return obj;</span>
 104      }
 105  
 106      protected CacheObj getFromCache(String key){
 107          return sideInfo.getSideCache().getFromCache(key);
 108      }
 109  
 110      protected void putCache(String key, CacheObj value){
 111          sideInfo.getSideCache().putCache(key, value);
 112      }
 113  
 114      protected boolean openCache(){
 115          return sideInfo.getSideCache() != null;
 116      }
 117  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -    protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +    protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){</span>
 120          if(sideInfo.getJoinType() == JoinType.LEFT){
 121              //Reserved left table data
 122              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 123 -                Row row = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -                resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +                Row row = fillData(input.f1, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +                resultFuture.complete(Collections.singleton(new Tuple2&lt;&gt;(input.f0, row)));</span>
 127              } catch (Exception e) {
 128                  dealFillDataError(resultFuture, e, input);

 129              }
 130          }else{
 131              resultFuture.complete(null);
 132          }
 133      }
 134  
 135      protected void dealCacheData(String key, CacheObj missKeyObj) {
 136          if (openCache()) {
 137              putCache(key, missKeyObj);
 138          }
 139      }
 140  
 141      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -    public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 143 +    public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 143 +    public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws ExceptioðŸ”µ</abbr></span>
 144  
 145          if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
 146              LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);
 147          }
 148  
 149          timeOutNum ++;
 150          if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncTimeoutNumLimit()){





 151              resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));
















































































































 152          } else {
 153              resultFuture.complete(null);
 154          }
 155      }
 156  
 157  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -    protected void dealFillDataError(ResultFuture&lt;CRow&gt; resultFuture, Exception e, Object sourceData) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 159 +    protected void dealFillDataError(ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Exception e, Object sourceData) {"> 159 +    protected void dealFillDataError(ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Exception e, Object sourceDatðŸ”µ</abbr></span>
 160          LOG.debug(&quot;source data {} join side table error &quot;, sourceData);
 161          LOG.debug(&quot;async buid row error..{}&quot;, e);
 162          parseErrorRecords.inc();
 163          resultFuture.complete(Collections.emptyList());


 164      }
 165  
 166      @Override
 167      public void close() throws Exception {
 168          super.close();
 169      }
 170  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import com.dtstack.flink.sql.enums.ECacheContentType;</span>
  24  import com.dtstack.flink.sql.enums.ECacheType;
  25  import com.dtstack.flink.sql.metric.MetricConstant;
  26  import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  27  import com.dtstack.flink.sql.side.cache.CacheObj;
  28  import com.dtstack.flink.sql.side.cache.LRUSideCache;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import com.google.common.collect.Maps;</span>
  31  import org.apache.calcite.sql.JoinType;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import org.apache.commons.collections.MapUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import org.apache.flink.api.common.functions.RuntimeContext;</span>
  34  import org.apache.flink.configuration.Configuration;
  35  import org.apache.flink.metrics.Counter;
  36  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  37  import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 +import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;</span>
  42  import org.apache.flink.table.runtime.types.CRow;

  43  import org.apache.flink.types.Row;
  44  import org.slf4j.Logger;
  45  import org.slf4j.LoggerFactory;
  46  


  47  import java.util.Collections;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import java.util.List;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import java.util.Map;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import java.util.concurrent.LinkedBlockingQueue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +import java.util.concurrent.ScheduledFuture;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  52 +import java.util.concurrent.ThreadPoolExecutor;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +import java.util.concurrent.TimeUnit;</span>
  54  
  55  /**
  56   * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  57   * only support Left join / inner join(join),not support right join
  58   * Date: 2018/7/9
  59   * Company: www.dtstack.com
  60   * @author xuchao
  61   */
  62  
  63  public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {

  64      private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  65      private static final long serialVersionUID = 2098635244857937717L;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  66 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +    private RuntimeContext runtimeContext;</span>
  68      private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  69      private int timeOutNum = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -</span>
  71      protected BaseSideInfo sideInfo;
  72      protected transient Counter parseErrorRecords;
  73  
  74      public BaseAsyncReqRow(BaseSideInfo sideInfo){
  75          this.sideInfo = sideInfo;
  76      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  77 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +    public void setRuntimeContext(RuntimeContext runtimeContext) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +        super.setRuntimeContext(runtimeContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +        this.runtimeContext = runtimeContext;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +    }</span>
  83      @Override
  84      public void open(Configuration parameters) throws Exception {
  85          super.open(parameters);
  86          initCache();
  87          initMetric();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +        LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());</span>
  89      }
  90  
  91      private void initCache(){
  92          AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  93          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  93          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheTðŸ”µ</abbr>
  94              return;
  95          }
  96  
  97          AbstractSideCache sideCache;
  98          if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
  99              sideCache = new LRUSideCache(sideTableInfo);
 100              sideInfo.setSideCache(sideCache);
 101          }else{
 102              throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());
 103          }

 104          sideCache.initCache();
 105      }
 106  
 107      private void initMetric() {
<abbr title=" 108          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 108          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_REðŸ”µ</abbr>











 109      }
 110  
 111      protected CacheObj getFromCache(String key){
 112          return sideInfo.getSideCache().getFromCache(key);
 113      }
 114  
 115      protected void putCache(String key, CacheObj value){
 116          sideInfo.getSideCache().putCache(key, value);
 117      }
 118  
 119      protected boolean openCache(){
 120          return sideInfo.getSideCache() != null;
 121      }
 122  
 123      protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){

 124          if(sideInfo.getJoinType() == JoinType.LEFT){
 125              //Reserved left table data
 126              try {
 127                  Row row = fillData(input.row(), null);
 128                  resultFuture.complete(Collections.singleton(new CRow(row, input.change())));


 129              } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -                dealFillDataError(resultFuture, e, input);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +                dealFillDataError(input, resultFuture, e);</span>
 132              }
 133          }else{
 134              resultFuture.complete(null);
 135          }
 136      }
 137  
 138      protected void dealCacheData(String key, CacheObj missKeyObj) {
 139          if (openCache()) {
 140              putCache(key, missKeyObj);
 141          }
 142      }
 143  
 144      @Override
 145      public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {

 146  
 147          if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
 148              LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);
 149          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -</span>
 151          timeOutNum ++;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -        if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncTimeoutNumLimit()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +        if(sideInfo.getJoinType() == JoinType.LEFT){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +            resultFuture.complete(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +        if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){</span>
 158              resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +        resultFuture.complete(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +    protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +        ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +        cancelTimerWhenComplete(resultFuture, timeFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +    public void asyncInvoke(CRow row, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +        CRow input = new CRow(Row.copy(row.row()), row.change());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +        preInvoke(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +        Map&lt;String, Object&gt; inputParams = parseInputParam(input);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +        if(MapUtils.isEmpty(inputParams)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +            dealMissKey(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +        if(isUseCache(inputParams)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +            invokeWithCache(inputParams, input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +        handleAsyncInvoke(inputParams, input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +    private Map&lt;String, Object&gt; parseInputParam(CRow input){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +        Map&lt;String, Object&gt; inputParams = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +        for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +            Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +            Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +            if(equalObj == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +                return inputParams;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +            String columnName = sideInfo.getEqualFieldList().get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +            inputParams.put(columnName, equalObj);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +        return inputParams;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 199 +    protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +        return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +    private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +        if (openCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +            CacheObj val = getFromCache(buildCacheKey(inputParams));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +            if (val != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +                if (ECacheContentType.MissVal == val.getType()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +                    dealMissKey(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +                    return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +                }else if(ECacheContentType.SingleLine == val.getType()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +                        Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +                    } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +                        dealFillDataError(input, resultFuture, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +                } else if (ECacheContentType.MultiLine == val.getType()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +                        List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +                        for (Object one : (List) val.getContent()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +                            Row row = fillData(input.row(), one);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +                            rowList.add(new CRow(row, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +                        resultFuture.complete(rowList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +                    } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +                        dealFillDataError(input, resultFuture, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 229 +                    resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 229 +                    resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.geðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 236 +    public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 236 +    public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +    public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +    private ProcessingTimeService getProcessingTimeService(){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +        return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +    protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 245 +        long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 245 +        long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +        return getProcessingTimeService().registerTimer(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +                timeoutTimestamp,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +                new ProcessingTimeCallback() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +                    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +                    public void onProcessingTime(long timestamp) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +                        timeout(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +                });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +    protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 257 +        ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 257 +        ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQuðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +        if(resultFuture instanceof StreamRecordQueueEntry){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +            StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +            streamRecordBufferEntry.onComplete((Object value) -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +                timerFuture.cancel(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +            },executors);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 265 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 266 +    protected void dealFillDataError(CRow input, ResultFuture&lt;CRow&gt; resultFuture, Throwable e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +        parseErrorRecords.inc();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +        if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +            LOG.info(&quot;dealFillDataError&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +            resultFuture.completeExceptionally(e);</span>
 271          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 272 -            resultFuture.complete(null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 273 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 274 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 275 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 276 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 277 -    protected void dealFillDataError(ResultFuture&lt;CRow&gt; resultFuture, Exception e, Object sourceData) {</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 278 -        LOG.debug(&quot;source data {} join side table error &quot;, sourceData);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 279 -        LOG.debug(&quot;async buid row error..{}&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 280 -        parseErrorRecords.inc();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 281 -        resultFuture.complete(Collections.emptyList());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +            dealMissKey(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +        }</span>
 284      }
 285  
 286      @Override
 287      public void close() throws Exception {
 288          super.close();
 289      }
 290  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            