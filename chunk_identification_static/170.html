<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>170</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    170
                    <a href="169.html">prev</a>
                    <a href="171.html">next</a>
                    <a href="170_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_f3b83d347352a2bc71ea8543a5fe93d8d9d52c77_common/src/main/java/org/broadleafcommerce/common/copy/MultiTenantCopier.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;f3b83d347352a2bc71ea8543a5fe93d8d9d52c77:common/src/main/java/org/broadleafcommerce/common/copy/MultiTenantCopier.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;f3b83d347352a2bc71ea8543a5fe93d8d9d52c77^1:common/src/main/java/org/broadleafcommerce/common/copy/MultiTenantCopier.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;f3b83d347352a2bc71ea8543a5fe93d8d9d52c77^2:common/src/main/java/org/broadleafcommerce/common/copy/MultiTenantCopier.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;ac0e9fad0e533cee585bebc82a58a18aa38a05cf:common/src/main/java/org/broadleafcommerce/common/copy/MultiTenantCopier.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Common Libraries
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.common.copy;
  19 
  20 import org.apache.commons.logging.Log;
  21 import org.apache.commons.logging.LogFactory;
  22 import org.broadleafcommerce.common.exception.ExceptionHelper;
  23 import org.broadleafcommerce.common.exception.ServiceException;
  24 import org.broadleafcommerce.common.sandbox.domain.SandBox;
  25 import org.broadleafcommerce.common.service.GenericEntityService;
  26 import org.broadleafcommerce.common.site.domain.Catalog;
  27 import org.broadleafcommerce.common.site.domain.Site;
  28 import org.broadleafcommerce.common.util.StreamCapableTransactionalOperationAdapter;
  29 import org.broadleafcommerce.common.util.StreamingTransactionCapableUtil;
  30 import org.broadleafcommerce.common.util.tenant.IdentityExecutionUtils;
  31 import org.broadleafcommerce.common.util.tenant.IdentityOperation;
  32 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  33 import org.broadleafcommerce.common.web.DeployState;
  34 import org.broadleafcommerce.common.web.EnforceEnterpriseCollectionBehaviorState;
  35 import org.springframework.core.Ordered;
  36 
  37 import java.lang.reflect.Field;
  38 import java.lang.reflect.Modifier;
  39 import java.util.ArrayList;
  40 import java.util.Collection;
  41 import java.util.HashSet;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.Set;
  45 import java.util.regex.Matcher;
  46 import java.util.regex.Pattern;
  47 
  48 import javax.annotation.Resource;
  49 import javax.persistence.Embeddable;
  50 import javax.persistence.ManyToMany;
  51 import javax.persistence.ManyToOne;
  52 import javax.persistence.OneToMany;
  53 import javax.persistence.OneToOne;
  54 
  55 /**
<abbr title="  56  * Abstract class for copying entities to a new catalog as required during derived catalog propagation. Subclasses generally">  56  * Abstract class for copying entities to a new catalog as required during derived catalog propagation. SðŸ”µ</abbr>
<abbr title="  57  * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcommerce.common.site.domain.Catalog, MultiTenantCopyContext)}">  57  * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcomðŸ”µ</abbr>
<abbr title="  58  * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clone and persist">  58  * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clonðŸ”µ</abbr>
  59  * an entity object tree.
  60  * 
  61  * @author Andre Azzolini (apazzolini)
  62  * @author Jeff Fischer
  63  */
  64 public abstract class MultiTenantCopier implements Ordered {
  65     protected static final Log LOG = LogFactory.getLog(MultiTenantCopier.class);
  66     
  67     @Resource(name = &quot;blGenericEntityService&quot;)
  68     protected GenericEntityService genericEntityService;
  69     
  70     @Resource(name = &quot;blMultiTenantCopierExtensionManager&quot;)
  71     protected MultiTenantCopierExtensionManager extensionManager;
  72 
  73     @Resource(name=&quot;blStreamingTransactionCapableUtil&quot;)
  74     protected StreamingTransactionCapableUtil transUtil;
  75     
  76     protected int order = 0;
  77 
  78     /**
  79      * To add elements use {@link #addPattern(Pattern)}
  80      */
  81     protected List&lt;Pattern&gt; classExcludeRegexPatternList = new ArrayList&lt;&gt;();
  82 
  83     /**
  84      * Main method that should be implemented by each {@link MultiTenantCopier} to drive the logic of
  85      * copying that particular entity to the new derived catalog.
  86      *
  87      * @param context
  88      */
  89     public abstract void copyEntities(MultiTenantCopyContext context) throws Exception;
  90 
  91     /**
  92      *
  93      * @return the order of this {@link MultiTenantCopier}
  94      */
  95     @Override
  96     public int getOrder() {
  97         return order;
  98     }
  99 
 100     public void setOrder(int order) {
 101         this.order = order;
 102     }
 103 
<abbr title=" 104     protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, Class&lt;T&gt; clazz, T original, MultiTenantCopyContext context) throws G {"> 104     protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, ClassðŸ”µ</abbr>
 105         try {
 106             //don&#x27;t persist if there is already an equivalent present
<abbr title=" 107             if (context.getEquivalentId(clazz.getName(), genericEntityService.getIdentifier(original)) != null) {"> 107             if (context.getEquivalentId(clazz.getName(), genericEntityService.getIdentifier(original)) !=ðŸ”µ</abbr>
 108                 return;
 109             }
 110 
 111             context.clearOriginalIdentifiers();
 112             genericEntityService.clearAutoFlushMode();
 113             Object copy = copyOperation.execute(original);
 114             SandBox sandBox = BroadleafRequestContext.getBroadleafRequestContext().getSandBox();
<abbr title=" 115             DeployState deployState = BroadleafRequestContext.getBroadleafRequestContext().getDeployState();"> 115             DeployState deployState = BroadleafRequestContext.getBroadleafRequestContext().getDeployStateðŸ”µ</abbr>
 116             BroadleafRequestContext.getBroadleafRequestContext().setDeployState(DeployState.PRODUCTION);
 117             BroadleafRequestContext.getBroadleafRequestContext().setSandBox(null);
<abbr title=" 118             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.FALSE);"> 118             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorStðŸ”µ</abbr>
 119             persistCopyObjectTreeInternal(copy, new HashSet&lt;Integer&gt;(), context);
 120             genericEntityService.flush();
 121             BroadleafRequestContext.getBroadleafRequestContext().setSandBox(sandBox);
 122             BroadleafRequestContext.getBroadleafRequestContext().setDeployState(deployState);
 123         } catch (Exception e) {
 124             LOG.error(&quot;Unable to persist the copy object tree&quot;, e);
 125             throw ExceptionHelper.refineException(e);
 126         } finally {
<abbr title=" 127             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.TRUE);"> 127             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorStðŸ”µ</abbr>
 128             context.clearOriginalIdentifiers();
 129             genericEntityService.enableAutoFlushMode();
 130         }
 131     }
 132 
<abbr title=" 133     protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContext context) {"> 133     protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContexðŸ”µ</abbr>
 134         if (library.contains(System.identityHashCode(copy)) || !(copy instanceof MultiTenantCloneable)
 135                 || this.excludeFromCopyRegexPattern(copy)) {
 136             return;
 137         }
 138         library.add(System.identityHashCode(copy));
 139         List&lt;Object[]&gt; collections = new ArrayList&lt;Object[]&gt;();
 140         Field[] allFields = context.getAllFields(copy.getClass());
 141         for (Field field : allFields) {
 142             if (field.getName().equals(&quot;embeddableSiteDiscriminator&quot;)) {
 143                 continue;
 144             }
 145             if (!Modifier.isStatic(field.getModifiers())) {
 146                 field.setAccessible(true);
 147                 Object newTarget;
 148                 try {
 149                     newTarget = field.get(copy);
 150                 } catch (IllegalAccessException e) {
 151                     throw ExceptionHelper.refineException(e);
 152                 }
 153                 if (newTarget != null) {
<abbr title=" 154                     if (field.getAnnotation(ManyToOne.class) != null || field.getAnnotation(OneToOne.class) != null) {"> 154                     if (field.getAnnotation(ManyToOne.class) != null || field.getAnnotation(OneToOne.clasðŸ”µ</abbr>
 155                         if (library.contains(System.identityHashCode(newTarget))) {
 156                             persistNode(newTarget, context);
 157                             continue;
 158                         }
 159                         persistCopyObjectTreeInternal(newTarget, library, context);
<abbr title=" 160                     } else if (field.getAnnotation(ManyToMany.class) != null || field.getAnnotation(OneToMany.class) != null) {"> 160                     } else if (field.getAnnotation(ManyToMany.class) != null || field.getAnnotation(OneToðŸ”µ</abbr>
 161                         collections.add(new Object[]{field, newTarget});
<abbr title=" 162                     } else if (field.getType().getAnnotation(Embeddable.class) != null &amp;&amp; MultiTenantCloneable.class.isAssignableFrom(field.getType())) {"> 162                     } else if (field.getType().getAnnotation(Embeddable.class) != null &amp;&amp; MultiTenantClonðŸ”µ</abbr>
 163                         persistCopyObjectTreeInternal(newTarget, library, context);
 164                     }
 165                 }
 166             }
 167         }
 168         if (copy.getClass().getAnnotation(Embeddable.class) == null) {
 169             persistNode(copy, context);
 170         }
 171         for (Object[] collectionItem : collections) {
 172             if (collectionItem[1] instanceof Collection) {
 173                 Collection newCollection = (Collection) collectionItem[1];
 174                 for (Object member : newCollection) {
 175                     persistCopyObjectTreeInternal(member, library, context);
 176                 }
 177             } else if (collectionItem[1] instanceof Map) {
 178                 Map newMap = (Map) collectionItem[1];
 179                 for (Object key : newMap.keySet()) {
 180                     persistCopyObjectTreeInternal(newMap.get(key), library, context);
 181                 }
 182             } else {
 183                 throw new IllegalArgumentException(String.format(&quot;During copy object persistence, &quot; +
<abbr title=" 184                         &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The system currently only &quot; +"> 184                         &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The systeðŸ”µ</abbr>
<abbr title=" 185                         &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) collectionItem[0]).getName()));"> 185                         &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) colðŸ”µ</abbr>
 186             }
 187         }
 188     }
 189 
 190     /**
 191 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 192 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 193                         &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The system currently only &quot; +"> 193                         &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The systeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 194                         &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) collectionItem[0]).getName()));"> 194                         &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) colðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200      * @deprecated Please use `excludeFromCopyRegexPattern()`</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201      * @param copy Copy object</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202      * @return excluded or not in Regex</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204     @Deprecated</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205     protected Boolean excludeFromCopyRegex(final Object copy) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206         boolean match = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207         if (this.classExcludeRegexPatternList.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208             LOG.warn(&quot;classExcludeRegexPatternList is empty, deprecated classExcludeRegexList is used&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209             for (Matcher regex : this.classExcludeRegexList) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210                 if (regex.reset(copy.getClass().toString()).matches()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211                     match = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212                     break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216            match = this.excludeFromCopyRegexPattern(copy);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218         return match;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221     /**</span>
 222 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 223      * @deprecated Please use `excludeFromCopyRegexPattern()`</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 224      * @param copy Copy object</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225      * @return excluded or not in Regex</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 226      */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 227     @Deprecated</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 228     protected Boolean excludeFromCopyRegex(final Object copy) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 229         boolean match = false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 230         if (this.classExcludeRegexPatternList.isEmpty() &amp;&amp; this.classExcludeRegexList!=null &amp;&amp; !this.classExcludeRegexList.isEmpty()) {"> 230         if (this.classExcludeRegexPatternList.isEmpty() &amp;&amp; this.classExcludeRegexList!=null &amp;&amp; !this.clasðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 231             LOG.warn(&quot;classExcludeRegexList is deprecated, please use excludeFromCopyRegexPattern&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 232             for (Matcher regex : this.classExcludeRegexList) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 233                 if (regex.reset(copy.getClass().toString()).matches()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 234                     match = true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 235                     break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 236                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 237             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 238         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 239            match = this.excludeFromCopyRegexPattern(copy);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 240         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 241         return match;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 242     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 243 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 244     /**</span>
 245 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 246      *
 247      * @param copy Copy object
 248      * @return excluded or not in patterns
 249      */
 250     protected Boolean excludeFromCopyRegexPattern(final Object copy) {
 251         boolean match = false;
 252         for (final Pattern pattern : this.classExcludeRegexPatternList) {
 253             final Matcher matcher = pattern.matcher(copy.getClass().toString());
 254             if (matcher.matches()) {
 255                 match = true;
 256                 break;
 257             }
 258         }
 259         return match;
 260     }
 261 
 262     protected void persistNode(final Object copy, final MultiTenantCopyContext context) {
 263         if (!genericEntityService.sessionContains(copy) &amp;&amp; !genericEntityService.idAssigned(copy)) {
<abbr title=" 264             final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), context.removeOriginalIdentifier(copy));"> 264             final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), conðŸ”µ</abbr>
 265             extensionManager.getProxy().transformCopy(context, original, copy);
 266             extensionManager.getProxy().prepareForSave(context, original, copy);
 267 
<abbr title=" 268             IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Void, RuntimeException&gt;() {"> 268             IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Void, RuntimeException&gt;ðŸ”µ</abbr>
 269                 @Override
 270                 public Void execute() {
 271                     genericEntityService.persist(copy);
 272                     extensionManager.getProxy().postSave(context, original, copy);
 273                     return null;
 274                 }
 275             }, context.getToSite(), context.getToSite(), context.getToCatalog());
 276 
<abbr title=" 277             context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original), context.getIdentifier(copy));"> 277             context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original)ðŸ”µ</abbr>
 278         }
 279     }
 280 
 281     /**
<abbr title=" 282      * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} implementation."> 282      * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} ðŸ”µ</abbr>
 283      *
 284      * @param clazz
 285      * @param fromSite
 286      * @param fromCatalog
 287      * @param context
 288      * @param &lt;T&gt;
 289      * @throws ServiceException
 290      * @throws CloneNotSupportedException
 291      */
<abbr title=" 292     protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fromSite, final Catalog fromCatalog, final MultiTenantCopyContext context)"> 292     protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fðŸ”µ</abbr>
 293             throws ServiceException, CloneNotSupportedException {
 294         genericEntityService.flush();
 295         genericEntityService.clear();
 296         transUtil.runStreamingTransactionalOperation(new StreamCapableTransactionalOperationAdapter() {
 297             @Override
 298             public Object[] retrievePage(int startPos, int pageSize) {
 299                 try {
 300                     Object[] temp = new Object[1];
 301                     List&lt;T&gt; results = readAll(clazz, pageSize, startPos, fromSite, fromCatalog);
 302                     temp[0] = results;
 303                     return temp;
 304                 } catch (ServiceException e) {
 305                     throw ExceptionHelper.refineException(e);
 306                 }
 307             }
 308 
 309             @Override
 310             public void pagedExecute(Object[] param) throws Throwable {
 311                 try {
 312                     List&lt;T&gt; results = (List&lt;T&gt;) param[0];
 313                     for (T result : results) {
 314                         persistCopyObjectTree(new CopyOperation&lt;T, CloneNotSupportedException&gt;() {
 315                             @Override
 316                             public T execute(T original) throws CloneNotSupportedException {
 317                                 return (T) original.createOrRetrieveCopyInstance(context).getClone();
 318                             }
 319                         }, clazz, result, context);
 320                     }
 321                 } finally {
 322                     genericEntityService.clear();
 323                 }
 324             }
 325 
 326             @Override
 327             public Long retrieveTotalCount() {
 328                 try {
 329                     return readCount(clazz, fromSite, fromCatalog);
 330                 } catch (ServiceException e) {
 331                     throw ExceptionHelper.refineException(e);
 332                 }
 333             }
 334 
 335             @Override
 336             public boolean shouldRetryOnTransactionLockAcquisitionFailure() {
 337                 return true;
 338             }
 339         }, RuntimeException.class);
 340     }
 341     
 342     /**
 343      * Saves the specified object in the toSite and toCatalog of the given context.
 344      * 
 345      * @param context
 346      * @param object
 347      * @return the saved entity
 348      * @throws ServiceException
 349      */
 350     protected &lt;T&gt; T save(MultiTenantCopyContext context, final T object) throws ServiceException {
<abbr title=" 351         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;T, ServiceException&gt;() {"> 351         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;T, ServiceException&gt;ðŸ”µ</abbr>
 352             @Override
 353             public T execute() throws ServiceException {
 354                 return genericEntityService.save(object);
 355             }
 356         }, context.getToSite(), context.getToSite(), context.getToCatalog());
 357     }
 358     
 359     /**
 360      * Returns the count of the given entity class for the specified site and catalog
 361      * 
 362      * @param clazz
 363      * @param site
 364      * @param catalog
 365      * @return the count
 366      * @throws ServiceException
 367      */
<abbr title=" 368     protected &lt;T&gt; Long readCount(final Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {"> 368     protected &lt;T&gt; Long readCount(final Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceExceptioðŸ”µ</abbr>
<abbr title=" 369         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Long, ServiceException&gt;() {"> 369         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Long, ServiceExceptiðŸ”µ</abbr>
 370             @Override
 371             public Long execute() throws ServiceException {
 372                 return genericEntityService.readCountGenericEntity(clazz);
 373             }
 374         }, site, site, catalog);
 375     }
 376     
 377     /**
 378      * @see #readAll(Class, int, int, Site, Catalog)
 379      * 
 380      * @param clazz
 381      * @param site
 382      * @param catalog
 383      * @return the list of entities for the specified parameters
 384      * @throws ServiceException
 385      */
 386     protected &lt;T&gt; List&lt;T&gt; readAll(Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {
 387         return readAll(clazz, Integer.MAX_VALUE, 0, site, catalog);
 388     }
 389 
 390     /**
 391      * Returns the primary key values for all entities of the specified type in the site or catalog.
 392      *
 393      * @param clazz
 394      * @param site
 395      * @param catalog
 396      * @return
 397      * @throws ServiceException
 398      */
<abbr title=" 399     protected List&lt;Long&gt; readAllIds(final Class&lt;?&gt; clazz, Site site, Catalog catalog) throws ServiceException {"> 399     protected List&lt;Long&gt; readAllIds(final Class&lt;?&gt; clazz, Site site, Catalog catalog) throws ServiceExcepðŸ”µ</abbr>
<abbr title=" 400         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceException&gt;() {"> 400         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceEðŸ”µ</abbr>
 401             @Override
 402             public List&lt;Long&gt; execute() throws ServiceException {
 403                 return genericEntityService.readAllGenericEntityId(clazz);
 404             }
 405         }, site, site, catalog);
 406     }
 407 
 408     /**
 409      * Returns a list of all entities in the system for the given class, site, and catalog. Additionally,
 410      * this method supports pagination.
 411      * 
 412      * @param clazz
 413      * @param limit
 414      * @param offset
 415      * @param site
 416      * @param catalog
 417      * @return the list of entities for the specified parameters
 418      * @throws ServiceException
 419      */
 420     protected &lt;T&gt; List&lt;T&gt; readAll(final Class&lt;T&gt; clazz, final int limit, final int offset, Site site, 
 421             Catalog catalog) throws ServiceException {
<abbr title=" 422         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceException&gt;() {"> 422         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceExceðŸ”µ</abbr>
 423             @Override
 424             public List&lt;T&gt; execute() throws ServiceException {
 425                 return genericEntityService.readAllGenericEntity(clazz, limit, offset);
 426             }
 427         }, site, site, catalog);
 428     }
 429 
 430     /**
 431      * Checks for similar items before adding to avoid duplication
 432      *
 433      * @param pattern input pattern
 434      */
 435     protected void addPattern(final Pattern pattern) {
 436         if (this.needToAdd(pattern)) {
 437             this.classExcludeRegexPatternList.add(pattern);
 438         }
 439     }
 440 
 441     protected boolean needToAdd(final Pattern pattern) {
 442         boolean exist = false;
 443         for (Pattern item : this.classExcludeRegexPatternList) {
 444             if (item.pattern().equals(pattern.pattern())) {
 445                 exist = true;
 446                 break;
 447             }
 448         }
 449         return !exist;
 450     }
 451 
 452 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Common Libraries
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.common.copy;
  19 
  20 import org.apache.commons.logging.Log;
  21 import org.apache.commons.logging.LogFactory;
  22 import org.broadleafcommerce.common.exception.ExceptionHelper;
  23 import org.broadleafcommerce.common.exception.ServiceException;
  24 import org.broadleafcommerce.common.sandbox.domain.SandBox;
  25 import org.broadleafcommerce.common.service.GenericEntityService;
  26 import org.broadleafcommerce.common.site.domain.Catalog;
  27 import org.broadleafcommerce.common.site.domain.Site;
  28 import org.broadleafcommerce.common.util.StreamCapableTransactionalOperationAdapter;
  29 import org.broadleafcommerce.common.util.StreamingTransactionCapableUtil;
  30 import org.broadleafcommerce.common.util.tenant.IdentityExecutionUtils;
  31 import org.broadleafcommerce.common.util.tenant.IdentityOperation;
  32 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  33 import org.broadleafcommerce.common.web.DeployState;
  34 import org.broadleafcommerce.common.web.EnforceEnterpriseCollectionBehaviorState;
  35 import org.springframework.core.Ordered;
  36 
  37 import java.lang.reflect.Field;
  38 import java.lang.reflect.Modifier;
  39 import java.util.ArrayList;
  40 import java.util.Collection;
  41 import java.util.HashSet;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.Set;
  45 import java.util.regex.Matcher;
  46 import java.util.regex.Pattern;
  47 
  48 import javax.annotation.Resource;
  49 import javax.persistence.Embeddable;
  50 import javax.persistence.ManyToMany;
  51 import javax.persistence.ManyToOne;
  52 import javax.persistence.OneToMany;
  53 import javax.persistence.OneToOne;
  54 
  55 /**
<abbr title="  56  * Abstract class for copying entities to a new catalog as required during derived catalog propagation. Subclasses generally">  56  * Abstract class for copying entities to a new catalog as required during derived catalog propagation. SðŸ”µ</abbr>
<abbr title="  57  * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcommerce.common.site.domain.Catalog, MultiTenantCopyContext)}">  57  * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcomðŸ”µ</abbr>
<abbr title="  58  * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clone and persist">  58  * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clonðŸ”µ</abbr>
  59  * an entity object tree.
  60  *
  61  * @author Andre Azzolini (apazzolini)
  62  * @author Jeff Fischer
  63  */
  64 public abstract class MultiTenantCopier implements Ordered {
  65     protected static final Log LOG = LogFactory.getLog(MultiTenantCopier.class);
  66 
  67     @Resource(name = &quot;blGenericEntityService&quot;)
  68     protected GenericEntityService genericEntityService;
  69 
  70     @Resource(name = &quot;blMultiTenantCopierExtensionManager&quot;)
  71     protected MultiTenantCopierExtensionManager extensionManager;
  72 
  73     @Resource(name=&quot;blStreamingTransactionCapableUtil&quot;)
  74     protected StreamingTransactionCapableUtil transUtil;
  75 
  76     protected int order = 0;
  77 
  78     /**
  79      * To add elements use {@link #addPattern(Pattern)}
  80      */
  81     protected List&lt;Pattern&gt; classExcludeRegexPatternList = new ArrayList&lt;&gt;();
  82 
  83     /**
  84      * Main method that should be implemented by each {@link MultiTenantCopier} to drive the logic of
  85      * copying that particular entity to the new derived catalog.
  86      *
  87      * @param context
  88      */
  89     public abstract void copyEntities(MultiTenantCopyContext context) throws Exception;
  90 
  91     /**
  92      *
  93      * @return the order of this {@link MultiTenantCopier}
  94      */
  95     @Override
  96     public int getOrder() {
  97         return order;
  98     }
  99 
 100     public void setOrder(int order) {
 101         this.order = order;
 102     }
 103 
<abbr title=" 104     protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, Class&lt;T&gt; clazz, T original, MultiTenantCopyContext context) throws G {"> 104     protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, ClassðŸ”µ</abbr>
 105         try {
 106             //don&#x27;t persist if there is already an equivalent present
<abbr title=" 107             if (context.getEquivalentId(clazz.getName(), genericEntityService.getIdentifier(original)) != null) {"> 107             if (context.getEquivalentId(clazz.getName(), genericEntityService.getIdentifier(original)) !=ðŸ”µ</abbr>
 108                 return;
 109             }
 110 
 111             context.clearOriginalIdentifiers();
 112             genericEntityService.clearAutoFlushMode();
 113             Object copy = copyOperation.execute(original);
 114             SandBox sandBox = BroadleafRequestContext.getBroadleafRequestContext().getSandBox();
<abbr title=" 115             DeployState deployState = BroadleafRequestContext.getBroadleafRequestContext().getDeployState();"> 115             DeployState deployState = BroadleafRequestContext.getBroadleafRequestContext().getDeployStateðŸ”µ</abbr>
 116             BroadleafRequestContext.getBroadleafRequestContext().setDeployState(DeployState.PRODUCTION);
 117             BroadleafRequestContext.getBroadleafRequestContext().setSandBox(null);
<abbr title=" 118             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.FALSE);"> 118             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorStðŸ”µ</abbr>
 119             persistCopyObjectTreeInternal(copy, new HashSet&lt;Integer&gt;(), context);
 120             genericEntityService.flush();
 121             BroadleafRequestContext.getBroadleafRequestContext().setSandBox(sandBox);
 122             BroadleafRequestContext.getBroadleafRequestContext().setDeployState(deployState);
 123         } catch (Exception e) {
 124             LOG.error(&quot;Unable to persist the copy object tree&quot;, e);
 125             throw ExceptionHelper.refineException(e);
 126         } finally {
<abbr title=" 127             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.TRUE);"> 127             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorStðŸ”µ</abbr>
 128             context.clearOriginalIdentifiers();
 129             genericEntityService.enableAutoFlushMode();
 130         }
 131     }
 132 
<abbr title=" 133     protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContext context) {"> 133     protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContexðŸ”µ</abbr>
 134         if (library.contains(System.identityHashCode(copy)) || !(copy instanceof MultiTenantCloneable)
 135                 || this.excludeFromCopyRegexPattern(copy)) {
 136             return;
 137         }
 138         library.add(System.identityHashCode(copy));
 139         List&lt;Object[]&gt; collections = new ArrayList&lt;Object[]&gt;();
 140         Field[] allFields = context.getAllFields(copy.getClass());
 141         for (Field field : allFields) {
 142             if (field.getName().equals(&quot;embeddableSiteDiscriminator&quot;)) {
 143                 continue;
 144             }
 145             if (!Modifier.isStatic(field.getModifiers())) {
 146                 field.setAccessible(true);
 147                 Object newTarget;
 148                 try {
 149                     newTarget = field.get(copy);
 150                 } catch (IllegalAccessException e) {
 151                     throw ExceptionHelper.refineException(e);
 152                 }
 153                 if (newTarget != null) {
<abbr title=" 154                     if (field.getAnnotation(ManyToOne.class) != null || field.getAnnotation(OneToOne.class) != null) {"> 154                     if (field.getAnnotation(ManyToOne.class) != null || field.getAnnotation(OneToOne.clasðŸ”µ</abbr>
 155                         if (library.contains(System.identityHashCode(newTarget))) {
 156                             persistNode(newTarget, context);
 157                             continue;
 158                         }
 159                         persistCopyObjectTreeInternal(newTarget, library, context);
<abbr title=" 160                     } else if (field.getAnnotation(ManyToMany.class) != null || field.getAnnotation(OneToMany.class) != null) {"> 160                     } else if (field.getAnnotation(ManyToMany.class) != null || field.getAnnotation(OneToðŸ”µ</abbr>
 161                         collections.add(new Object[]{field, newTarget});
<abbr title=" 162                     } else if (field.getType().getAnnotation(Embeddable.class) != null &amp;&amp; MultiTenantCloneable.class.isAssignableFrom(field.getType())) {"> 162                     } else if (field.getType().getAnnotation(Embeddable.class) != null &amp;&amp; MultiTenantClonðŸ”µ</abbr>
 163                         persistCopyObjectTreeInternal(newTarget, library, context);
 164                     }
 165                 }
 166             }
 167         }
 168         if (copy.getClass().getAnnotation(Embeddable.class) == null) {
 169             persistNode(copy, context);
 170         }
 171         for (Object[] collectionItem : collections) {
 172             if (collectionItem[1] instanceof Collection) {
 173                 Collection newCollection = (Collection) collectionItem[1];
 174                 for (Object member : newCollection) {
 175                     persistCopyObjectTreeInternal(member, library, context);
 176                 }
 177             } else if (collectionItem[1] instanceof Map) {
 178                 Map newMap = (Map) collectionItem[1];
 179                 for (Object key : newMap.keySet()) {
 180                     persistCopyObjectTreeInternal(newMap.get(key), library, context);
 181                 }
 182             } else {
 183                 throw new IllegalArgumentException(String.format(&quot;During copy object persistence, &quot; +
<abbr title=" 184                         &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The system currently only &quot; +"> 184                         &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The systeðŸ”µ</abbr>
<abbr title=" 185                         &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) collectionItem[0]).getName()));"> 185                         &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) colðŸ”µ</abbr>
 186             }
 187         }
 188     }
 189 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 190 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191 @Deprecated</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192     protected Boolean excludeFromCopyRegex(final Object copy) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193         boolean match = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194         if (this.classExcludeRegexPatternList.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195             LOG.warn(&quot;classExcludeRegexPatternList is empty, deprecated classExcludeRegexList is used&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196             for (Matcher regex : this.classExcludeRegexList) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197                 if (regex.reset(copy.getClass().toString()).matches()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198                     match = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199                     break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203            match = this.excludeFromCopyRegexPattern(copy);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205         return match;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206     }</span>
 207 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 208 @Deprecated</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 209     protected Boolean excludeFromCopyRegex(final Object copy) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 210         boolean match = false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 211         if (this.classExcludeRegexPatternList.isEmpty() &amp;&amp; this.classExcludeRegexList!=null &amp;&amp; !this.classExcludeRegexList.isEmpty()) {"> 211         if (this.classExcludeRegexPatternList.isEmpty() &amp;&amp; this.classExcludeRegexList!=null &amp;&amp; !this.clasðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 212             LOG.warn(&quot;classExcludeRegexList is deprecated, please use excludeFromCopyRegexPattern&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 213             for (Matcher regex : this.classExcludeRegexList) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 214                 if (regex.reset(copy.getClass().toString()).matches()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 215                     match = true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 216                     break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 217                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 218             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 219         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 220            match = this.excludeFromCopyRegexPattern(copy);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 221         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 222         return match;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 223     }</span>
 224 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 225 
 226 
 227     /**
 228      *
 229      * @param copy Copy object
 230      * @return excluded or not in patterns
 231      */
 232     protected Boolean excludeFromCopyRegexPattern(final Object copy) {
 233         boolean match = false;
 234         for (final Pattern pattern : this.classExcludeRegexPatternList) {
 235             final Matcher matcher = pattern.matcher(copy.getClass().toString());
 236             if (matcher.matches()) {
 237                 match = true;
 238                 break;
 239             }
 240         }
 241         return match;
 242     }
 243 
 244     protected void persistNode(final Object copy, final MultiTenantCopyContext context) {
 245         if (!genericEntityService.sessionContains(copy) &amp;&amp; !genericEntityService.idAssigned(copy)) {
<abbr title=" 246             final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), context.removeOriginalIdentifier(copy));"> 246             final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), conðŸ”µ</abbr>
 247             extensionManager.getProxy().transformCopy(context, original, copy);
 248             extensionManager.getProxy().prepareForSave(context, original, copy);
 249 
<abbr title=" 250             IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Void, RuntimeException&gt;() {"> 250             IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Void, RuntimeException&gt;ðŸ”µ</abbr>
 251                 @Override
 252                 public Void execute() {
 253                     genericEntityService.persist(copy);
 254                     extensionManager.getProxy().postSave(context, original, copy);
 255                     return null;
 256                 }
 257             }, context.getToSite(), context.getToSite(), context.getToCatalog());
 258 
<abbr title=" 259             context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original), context.getIdentifier(copy));"> 259             context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original)ðŸ”µ</abbr>
 260         }
 261     }
 262 
 263     /**
<abbr title=" 264      * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} implementation."> 264      * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} ðŸ”µ</abbr>
 265      *
 266      * @param clazz
 267      * @param fromSite
 268      * @param fromCatalog
 269      * @param context
 270      * @param &lt;T&gt;
 271      * @throws ServiceException
 272      * @throws CloneNotSupportedException
 273      */
<abbr title=" 274     protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fromSite, final Catalog fromCatalog, final MultiTenantCopyContext context)"> 274     protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fðŸ”µ</abbr>
 275             throws ServiceException, CloneNotSupportedException {
 276         genericEntityService.flush();
 277         genericEntityService.clear();
 278         transUtil.runStreamingTransactionalOperation(new StreamCapableTransactionalOperationAdapter() {
 279             @Override
 280             public Object[] retrievePage(int startPos, int pageSize) {
 281                 try {
 282                     Object[] temp = new Object[1];
 283                     List&lt;T&gt; results = readAll(clazz, pageSize, startPos, fromSite, fromCatalog);
 284                     temp[0] = results;
 285                     return temp;
 286                 } catch (ServiceException e) {
 287                     throw ExceptionHelper.refineException(e);
 288                 }
 289             }
 290 
 291             @Override
 292             public void pagedExecute(Object[] param) throws Throwable {
 293                 try {
 294                     List&lt;T&gt; results = (List&lt;T&gt;) param[0];
 295                     for (T result : results) {
 296                         persistCopyObjectTree(new CopyOperation&lt;T, CloneNotSupportedException&gt;() {
 297                             @Override
 298                             public T execute(T original) throws CloneNotSupportedException {
 299                                 return (T) original.createOrRetrieveCopyInstance(context).getClone();
 300                             }
 301                         }, clazz, result, context);
 302                     }
 303                 } finally {
 304                     genericEntityService.clear();
 305                 }
 306             }
 307 
 308             @Override
 309             public Long retrieveTotalCount() {
 310                 try {
 311                     return readCount(clazz, fromSite, fromCatalog);
 312                 } catch (ServiceException e) {
 313                     throw ExceptionHelper.refineException(e);
 314                 }
 315             }
 316 
 317             @Override
 318             public boolean shouldRetryOnTransactionLockAcquisitionFailure() {
 319                 return true;
 320             }
 321         }, RuntimeException.class);
 322     }
 323 
 324     /**
 325      * Saves the specified object in the toSite and toCatalog of the given context.
 326      *
 327      * @param context
 328      * @param object
 329      * @return the saved entity
 330      * @throws ServiceException
 331      */
 332     protected &lt;T&gt; T save(MultiTenantCopyContext context, final T object) throws ServiceException {
<abbr title=" 333         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;T, ServiceException&gt;() {"> 333         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;T, ServiceException&gt;ðŸ”µ</abbr>
 334             @Override
 335             public T execute() throws ServiceException {
 336                 return genericEntityService.save(object);
 337             }
 338         }, context.getToSite(), context.getToSite(), context.getToCatalog());
 339     }
 340 
 341     /**
 342      * Returns the count of the given entity class for the specified site and catalog
 343      *
 344      * @param clazz
 345      * @param site
 346      * @param catalog
 347      * @return the count
 348      * @throws ServiceException
 349      */
<abbr title=" 350     protected &lt;T&gt; Long readCount(final Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {"> 350     protected &lt;T&gt; Long readCount(final Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceExceptioðŸ”µ</abbr>
<abbr title=" 351         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Long, ServiceException&gt;() {"> 351         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Long, ServiceExceptiðŸ”µ</abbr>
 352             @Override
 353             public Long execute() throws ServiceException {
 354                 return genericEntityService.readCountGenericEntity(clazz);
 355             }
 356         }, site, site, catalog);
 357     }
 358 
 359     /**
 360      * @see #readAll(Class, int, int, Site, Catalog)
 361      *
 362      * @param clazz
 363      * @param site
 364      * @param catalog
 365      * @return the list of entities for the specified parameters
 366      * @throws ServiceException
 367      */
 368     protected &lt;T&gt; List&lt;T&gt; readAll(Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {
 369         return readAll(clazz, Integer.MAX_VALUE, 0, site, catalog);
 370     }
 371 
 372     /**
 373      * Returns the primary key values for all entities of the specified type in the site or catalog.
 374      *
 375      * @param clazz
 376      * @param site
 377      * @param catalog
 378      * @return
 379      * @throws ServiceException
 380      */
<abbr title=" 381     protected List&lt;Long&gt; readAllIds(final Class&lt;?&gt; clazz, Site site, Catalog catalog) throws ServiceException {"> 381     protected List&lt;Long&gt; readAllIds(final Class&lt;?&gt; clazz, Site site, Catalog catalog) throws ServiceExcepðŸ”µ</abbr>
<abbr title=" 382         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceException&gt;() {"> 382         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceEðŸ”µ</abbr>
 383             @Override
 384             public List&lt;Long&gt; execute() throws ServiceException {
 385                 return genericEntityService.readAllGenericEntityId(clazz);
 386             }
 387         }, site, site, catalog);
 388     }
 389 
 390     /**
 391      * Returns a list of all entities in the system for the given class, site, and catalog. Additionally,
 392      * this method supports pagination.
 393      *
 394      * @param clazz
 395      * @param limit
 396      * @param offset
 397      * @param site
 398      * @param catalog
 399      * @return the list of entities for the specified parameters
 400      * @throws ServiceException
 401      */
 402     protected &lt;T&gt; List&lt;T&gt; readAll(final Class&lt;T&gt; clazz, final int limit, final int offset, Site site,
 403             Catalog catalog) throws ServiceException {
<abbr title=" 404         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceException&gt;() {"> 404         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceExceðŸ”µ</abbr>
 405             @Override
 406             public List&lt;T&gt; execute() throws ServiceException {
 407                 return genericEntityService.readAllGenericEntity(clazz, limit, offset);
 408             }
 409         }, site, site, catalog);
 410     }
 411 
 412     /**
 413      * Checks for similar items before adding to avoid duplication
 414      *
 415      * @param pattern input pattern
 416      */
 417     protected void addPattern(final Pattern pattern) {
 418         if (this.needToAdd(pattern)) {
 419             this.classExcludeRegexPatternList.add(pattern);
 420         }
 421     }
 422 
 423     protected boolean needToAdd(final Pattern pattern) {
 424         boolean exist = false;
 425         for (Pattern item : this.classExcludeRegexPatternList) {
 426             if (item.pattern().equals(pattern.pattern())) {
 427                 exist = true;
 428                 break;
 429             }
 430         }
 431         return !exist;
 432     }
 433 
 434 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Common Libraries
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.common.copy;
  19 
  20 import java.lang.reflect.Field;
  21 import java.lang.reflect.Modifier;
  22 import java.util.ArrayList;
  23 import java.util.Collection;
  24 import java.util.HashSet;
  25 import java.util.List;
  26 import java.util.Map;
  27 import java.util.Set;
  28 import java.util.regex.Matcher;
  29 import java.util.regex.Pattern;
  30 import javax.annotation.Resource;
  31 import javax.persistence.Embeddable;
  32 import javax.persistence.ManyToMany;
  33 import javax.persistence.ManyToOne;
  34 import javax.persistence.OneToMany;
  35 import javax.persistence.OneToOne;
  36 import org.apache.commons.logging.Log;
  37 import org.apache.commons.logging.LogFactory;
  38 import org.broadleafcommerce.common.exception.ExceptionHelper;
  39 import org.broadleafcommerce.common.exception.ServiceException;
  40 import org.broadleafcommerce.common.sandbox.domain.SandBox;
  41 import org.broadleafcommerce.common.service.GenericEntityService;
  42 import org.broadleafcommerce.common.site.domain.Catalog;
  43 import org.broadleafcommerce.common.site.domain.Site;
  44 import org.broadleafcommerce.common.util.StreamCapableTransactionalOperationAdapter;
  45 import org.broadleafcommerce.common.util.StreamingTransactionCapableUtil;
  46 import org.broadleafcommerce.common.util.tenant.IdentityExecutionUtils;
  47 import org.broadleafcommerce.common.util.tenant.IdentityOperation;
  48 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  49 import org.broadleafcommerce.common.web.DeployState;
  50 import org.broadleafcommerce.common.web.EnforceEnterpriseCollectionBehaviorState;
  51 import org.springframework.core.Ordered;
  52 
  53 
  54 /**
<abbr title="  55  * Abstract class for copying entities to a new catalog as required during derived catalog propagation. Subclasses generally">  55  * Abstract class for copying entities to a new catalog as required during derived catalog propagation. SðŸ”µ</abbr>
<abbr title="  56  * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcommerce.common.site.domain.Catalog, MultiTenantCopyContext)}">  56  * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcomðŸ”µ</abbr>
<abbr title="  57  * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clone and persist">  57  * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clonðŸ”µ</abbr>
  58  * an entity object tree.
  59  *
  60  * @author Andre Azzolini (apazzolini)
  61  * @author Jeff Fischer
  62  */
  63 public abstract class MultiTenantCopier implements Ordered {
  64     protected static final Log LOG = LogFactory.getLog(MultiTenantCopier.class);
  65 
  66     @Resource(name = &quot;blGenericEntityService&quot;)
  67     protected GenericEntityService genericEntityService;
  68 
  69     @Resource(name = &quot;blMultiTenantCopierExtensionManager&quot;)
  70     protected MultiTenantCopierExtensionManager extensionManager;
  71 
  72     @Resource(name=&quot;blStreamingTransactionCapableUtil&quot;)
  73     protected StreamingTransactionCapableUtil transUtil;
  74 
  75     protected int order = 0;
  76 
  77     /**
  78      * To add elements use {@link #addPattern(Pattern)}
  79      */
  80     protected List&lt;Pattern&gt; classExcludeRegexPatternList = new ArrayList&lt;&gt;();
  81 
  82     /**
  83      * Main method that should be implemented by each {@link MultiTenantCopier} to drive the logic of
  84      * copying that particular entity to the new derived catalog.
  85      *
  86      * @param context
  87      */
  88     public abstract void copyEntities(MultiTenantCopyContext context) throws Exception;
  89 
  90     /**
  91      *
  92      * @return the order of this {@link MultiTenantCopier}
  93      */
  94     @Override
  95     public int getOrder() {
  96         return order;
  97     }
  98 
  99     public void setOrder(int order) {
 100         this.order = order;
 101     }
 102 
<abbr title=" 103     protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, Class&lt;T&gt; clazz, T original, MultiTenantCopyContext context) throws G {"> 103     protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, ClassðŸ”µ</abbr>
 104         try {
 105             //don&#x27;t persist if there is already an equivalent present
<abbr title=" 106             if (context.getEquivalentId(clazz.getName(), genericEntityService.getIdentifier(original)) != null) {"> 106             if (context.getEquivalentId(clazz.getName(), genericEntityService.getIdentifier(original)) !=ðŸ”µ</abbr>
 107                 return;
 108             }
 109 
 110             context.clearOriginalIdentifiers();
 111             genericEntityService.clearAutoFlushMode();
 112             Object copy = copyOperation.execute(original);
 113             SandBox sandBox = BroadleafRequestContext.getBroadleafRequestContext().getSandBox();
<abbr title=" 114             DeployState deployState = BroadleafRequestContext.getBroadleafRequestContext().getDeployState();"> 114             DeployState deployState = BroadleafRequestContext.getBroadleafRequestContext().getDeployStateðŸ”µ</abbr>
 115             BroadleafRequestContext.getBroadleafRequestContext().setDeployState(DeployState.PRODUCTION);
 116             BroadleafRequestContext.getBroadleafRequestContext().setSandBox(null);
<abbr title=" 117             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.FALSE);"> 117             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorStðŸ”µ</abbr>
 118             persistCopyObjectTreeInternal(copy, new HashSet&lt;Integer&gt;(), context);
 119             genericEntityService.flush();
 120             BroadleafRequestContext.getBroadleafRequestContext().setSandBox(sandBox);
 121             BroadleafRequestContext.getBroadleafRequestContext().setDeployState(deployState);
 122         } catch (Exception e) {
 123             LOG.error(&quot;Unable to persist the copy object tree&quot;, e);
 124             throw ExceptionHelper.refineException(e);
 125         } finally {
<abbr title=" 126             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.TRUE);"> 126             BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorStðŸ”µ</abbr>
 127             context.clearOriginalIdentifiers();
 128             genericEntityService.enableAutoFlushMode();
 129         }
 130     }
 131 
<abbr title=" 132     protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContext context) {"> 132     protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContexðŸ”µ</abbr>
<abbr title=" 133         if ((library.contains(System.identityHashCode(copy)) || (!(copy instanceof MultiTenantCloneable))) || this.excludeFromCopyRegexPattern(copy)) {"> 133         if ((library.contains(System.identityHashCode(copy)) || (!(copy instanceof MultiTenantCloneable))ðŸ”µ</abbr>
 134             return;
 135         }
 136         library.add(System.identityHashCode(copy));
 137         List&lt;Object[]&gt; collections = new ArrayList&lt;Object[]&gt;();
 138         Field[] allFields = context.getAllFields(copy.getClass());
 139         for (Field field : allFields) {
 140             if (field.getName().equals(&quot;embeddableSiteDiscriminator&quot;)) {
 141                 continue;
 142             }
 143             if (!Modifier.isStatic(field.getModifiers())) {
 144                 field.setAccessible(true);
 145                 Object newTarget;
 146                 try {
 147                     newTarget = field.get(copy);
 148                 } catch (java.lang.IllegalAccessException e) {
 149                     throw ExceptionHelper.refineException(e);
 150                 }
 151                 if (newTarget != null) {
<abbr title=" 152                     if ((field.getAnnotation(ManyToOne.class) != null) || (field.getAnnotation(OneToOne.class) != null)) {"> 152                     if ((field.getAnnotation(ManyToOne.class) != null) || (field.getAnnotation(OneToOne.cðŸ”µ</abbr>
 153                         if (library.contains(System.identityHashCode(newTarget))) {
 154                             persistNode(newTarget, context);
 155                             continue;
 156                         }
 157                         persistCopyObjectTreeInternal(newTarget, library, context);
<abbr title=" 158                     } else if ((field.getAnnotation(ManyToMany.class) != null) || (field.getAnnotation(OneToMany.class) != null)) {"> 158                     } else if ((field.getAnnotation(ManyToMany.class) != null) || (field.getAnnotation(OnðŸ”µ</abbr>
 159                         collections.add(new Object[]{ field, newTarget });
<abbr title=" 160                     } else if ((field.getType().getAnnotation(Embeddable.class) != null) &amp;&amp; MultiTenantCloneable.class.isAssignableFrom(field.getType())) {"> 160                     } else if ((field.getType().getAnnotation(Embeddable.class) != null) &amp;&amp; MultiTenantClðŸ”µ</abbr>
 161                         persistCopyObjectTreeInternal(newTarget, library, context);
 162                     }
 163                 }
 164             }
 165         }
 166         if (copy.getClass().getAnnotation(Embeddable.class) == null) {
 167             persistNode(copy, context);
 168         }
 169         for (Object[] collectionItem : collections) {
 170             if (collectionItem[1] instanceof Collection) {
 171                 Collection newCollection = ((Collection) (collectionItem[1]));
 172                 for (Object member : newCollection) {
 173                     persistCopyObjectTreeInternal(member, library, context);
 174                 }
 175             } else if (collectionItem[1] instanceof Map) {
 176                 Map newMap = ((Map) (collectionItem[1]));
 177                 for (Object key : newMap.keySet()) {
 178                     persistCopyObjectTreeInternal(newMap.get(key), library, context);
 179                 }
 180             } else {
<abbr title=" 181                 throw new IllegalArgumentException(String.format(&quot;During copy object persistence, &quot; + (&quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The system currently only &quot; + &quot;recognizes Collection and Map. (%s.%s)&quot;), copy.getClass().getName(), ((Field) (collectionItem[0])).getName()));"> 181                 throw new IllegalArgumentException(String.format(&quot;During copy object persistence, &quot; + (&quot;aðŸ”µ</abbr>
 182             }
 183         }
 184     }
 185 
 186     /**
 187      *
 188      * @param copy Copy object
 189      * @return excluded or not in patterns
 190      */
 191     protected Boolean excludeFromCopyRegexPattern(final Object copy) {
 192         boolean match = false;
 193         for (final Pattern pattern : this.classExcludeRegexPatternList) {
 194             final Matcher matcher = pattern.matcher(copy.getClass().toString());
 195             if (matcher.matches()) {
 196                 match = true;
 197                 break;
 198             }
 199         }
 200         return match;
 201     }
 202 
 203     protected void persistNode(final Object copy, final MultiTenantCopyContext context) {
 204         if (!genericEntityService.sessionContains(copy) &amp;&amp; !genericEntityService.idAssigned(copy)) {
<abbr title=" 205             final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), context.removeOriginalIdentifier(copy));"> 205             final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), conðŸ”µ</abbr>
 206             extensionManager.getProxy().transformCopy(context, original, copy);
 207             extensionManager.getProxy().prepareForSave(context, original, copy);
 208 
<abbr title=" 209             IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Void, RuntimeException&gt;() {"> 209             IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Void, RuntimeException&gt;ðŸ”µ</abbr>
 210                 @Override
 211                 public Void execute() {
 212                     genericEntityService.persist(copy);
 213                     extensionManager.getProxy().postSave(context, original, copy);
 214                     return null;
 215                 }
 216             }, context.getToSite(), context.getToSite(), context.getToCatalog());
 217 
<abbr title=" 218             context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original), context.getIdentifier(copy));"> 218             context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original)ðŸ”µ</abbr>
 219         }
 220     }
 221 
 222     /**
<abbr title=" 223      * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} implementation."> 223      * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} ðŸ”µ</abbr>
 224      *
 225      * @param clazz
 226      * @param fromSite
 227      * @param fromCatalog
 228      * @param context
 229      * @param &lt;T&gt;
 230      * @throws ServiceException
 231      * @throws CloneNotSupportedException
 232      */
<abbr title=" 233     protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fromSite, final Catalog fromCatalog, final MultiTenantCopyContext context)"> 233     protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fðŸ”µ</abbr>
 234             throws ServiceException, CloneNotSupportedException {
 235         genericEntityService.flush();
 236         genericEntityService.clear();
 237         transUtil.runStreamingTransactionalOperation(new StreamCapableTransactionalOperationAdapter() {
 238             @Override
 239             public Object[] retrievePage(int startPos, int pageSize) {
 240                 try {
 241                     Object[] temp = new Object[1];
 242                     List&lt;T&gt; results = readAll(clazz, pageSize, startPos, fromSite, fromCatalog);
 243                     temp[0] = results;
 244                     return temp;
 245                 } catch (ServiceException e) {
 246                     throw ExceptionHelper.refineException(e);
 247                 }
 248             }
 249 
 250             @Override
 251             public void pagedExecute(Object[] param) throws Throwable {
 252                 try {
 253                     List&lt;T&gt; results = (List&lt;T&gt;) param[0];
 254                     for (T result : results) {
 255                         persistCopyObjectTree(new CopyOperation&lt;T, CloneNotSupportedException&gt;() {
 256                             @Override
 257                             public T execute(T original) throws CloneNotSupportedException {
 258                                 return (T) original.createOrRetrieveCopyInstance(context).getClone();
 259                             }
 260                         }, clazz, result, context);
 261                     }
 262                 } finally {
 263                     genericEntityService.clear();
 264                 }
 265             }
 266 
 267             @Override
 268             public Long retrieveTotalCount() {
 269                 try {
 270                     return readCount(clazz, fromSite, fromCatalog);
 271                 } catch (ServiceException e) {
 272                     throw ExceptionHelper.refineException(e);
 273                 }
 274             }
 275 
 276             @Override
 277             public boolean shouldRetryOnTransactionLockAcquisitionFailure() {
 278                 return true;
 279             }
 280         }, RuntimeException.class);
 281     }
 282 
 283     /**
 284      * Saves the specified object in the toSite and toCatalog of the given context.
 285      *
 286      * @param context
 287      * @param object
 288      * @return the saved entity
 289      * @throws ServiceException
 290      */
 291     protected &lt;T&gt; T save(MultiTenantCopyContext context, final T object) throws ServiceException {
<abbr title=" 292         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;T, ServiceException&gt;() {"> 292         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;T, ServiceException&gt;ðŸ”µ</abbr>
 293             @Override
 294             public T execute() throws ServiceException {
 295                 return genericEntityService.save(object);
 296             }
 297         }, context.getToSite(), context.getToSite(), context.getToCatalog());
 298     }
 299 
 300     /**
 301      * Returns the count of the given entity class for the specified site and catalog
 302      *
 303      * @param clazz
 304      * @param site
 305      * @param catalog
 306      * @return the count
 307      * @throws ServiceException
 308      */
<abbr title=" 309     protected &lt;T&gt; Long readCount(final Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {"> 309     protected &lt;T&gt; Long readCount(final Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceExceptioðŸ”µ</abbr>
<abbr title=" 310         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Long, ServiceException&gt;() {"> 310         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Long, ServiceExceptiðŸ”µ</abbr>
 311             @Override
 312             public Long execute() throws ServiceException {
 313                 return genericEntityService.readCountGenericEntity(clazz);
 314             }
 315         }, site, site, catalog);
 316     }
 317 
 318     /**
 319      * @see #readAll(Class, int, int, Site, Catalog)
 320      *
 321      * @param clazz
 322      * @param site
 323      * @param catalog
 324      * @return the list of entities for the specified parameters
 325      * @throws ServiceException
 326      */
 327     protected &lt;T&gt; List&lt;T&gt; readAll(Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {
 328         return readAll(clazz, Integer.MAX_VALUE, 0, site, catalog);
 329     }
 330 
 331     /**
 332      * Returns the primary key values for all entities of the specified type in the site or catalog.
 333      *
 334      * @param clazz
 335      * @param site
 336      * @param catalog
 337      * @return
 338      * @throws ServiceException
 339      */
<abbr title=" 340     protected List&lt;Long&gt; readAllIds(final Class&lt;?&gt; clazz, Site site, Catalog catalog) throws ServiceException {"> 340     protected List&lt;Long&gt; readAllIds(final Class&lt;?&gt; clazz, Site site, Catalog catalog) throws ServiceExcepðŸ”µ</abbr>
<abbr title=" 341         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceException&gt;() {"> 341         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceEðŸ”µ</abbr>
 342             @Override
 343             public List&lt;Long&gt; execute() throws ServiceException {
 344                 return genericEntityService.readAllGenericEntityId(clazz);
 345             }
 346         }, site, site, catalog);
 347     }
 348 
 349     /**
 350      * Returns a list of all entities in the system for the given class, site, and catalog. Additionally,
 351      * this method supports pagination.
 352      *
 353      * @param clazz
 354      * @param limit
 355      * @param offset
 356      * @param site
 357      * @param catalog
 358      * @return the list of entities for the specified parameters
 359      * @throws ServiceException
 360      */
 361     protected &lt;T&gt; List&lt;T&gt; readAll(final Class&lt;T&gt; clazz, final int limit, final int offset, Site site,
 362             Catalog catalog) throws ServiceException {
<abbr title=" 363         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceException&gt;() {"> 363         return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceExceðŸ”µ</abbr>
 364             @Override
 365             public List&lt;T&gt; execute() throws ServiceException {
 366                 return genericEntityService.readAllGenericEntity(clazz, limit, offset);
 367             }
 368         }, site, site, catalog);
 369     }
 370 
 371     /**
 372      * Checks for similar items before adding to avoid duplication
 373      *
 374      * @param pattern input pattern
 375      */
 376     protected void addPattern(final Pattern pattern) {
 377         if (this.needToAdd(pattern)) {
 378             this.classExcludeRegexPatternList.add(pattern);
 379         }
 380     }
 381 
 382     protected boolean needToAdd(final Pattern pattern) {
 383         boolean exist = false;
 384         for (Pattern item : this.classExcludeRegexPatternList) {
 385             if (item.pattern().equals(pattern.pattern())) {
 386                 exist = true;
 387                 break;
 388             }
 389         }
 390         return !exist;
 391     }
 392 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Common Libraries
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.common.copy;
  19  
  20  import org.apache.commons.logging.Log;
  21  import org.apache.commons.logging.LogFactory;
  22  import org.broadleafcommerce.common.exception.ExceptionHelper;
  23  import org.broadleafcommerce.common.exception.ServiceException;
  24  import org.broadleafcommerce.common.sandbox.domain.SandBox;
  25  import org.broadleafcommerce.common.service.GenericEntityService;
  26  import org.broadleafcommerce.common.site.domain.Catalog;
  27  import org.broadleafcommerce.common.site.domain.Site;
  28  import org.broadleafcommerce.common.util.StreamCapableTransactionalOperationAdapter;
  29  import org.broadleafcommerce.common.util.StreamingTransactionCapableUtil;
  30  import org.broadleafcommerce.common.util.tenant.IdentityExecutionUtils;
  31  import org.broadleafcommerce.common.util.tenant.IdentityOperation;
  32  import org.broadleafcommerce.common.web.BroadleafRequestContext;
  33  import org.broadleafcommerce.common.web.DeployState;
  34  import org.broadleafcommerce.common.web.EnforceEnterpriseCollectionBehaviorState;
  35  import org.springframework.core.Ordered;
  36  
  37  import java.lang.reflect.Field;
  38  import java.lang.reflect.Modifier;
  39  import java.util.ArrayList;
  40  import java.util.Collection;
  41  import java.util.HashSet;
  42  import java.util.List;
  43  import java.util.Map;
  44  import java.util.Set;
  45  import java.util.regex.Matcher;
  46  import java.util.regex.Pattern;
  47  
  48  import javax.annotation.Resource;
  49  import javax.persistence.Embeddable;
  50  import javax.persistence.ManyToMany;
  51  import javax.persistence.ManyToOne;
  52  import javax.persistence.OneToMany;
  53  import javax.persistence.OneToOne;
  54  
  55  /**
<abbr title="  56   * Abstract class for copying entities to a new catalog as required during derived catalog propagation. Subclasses generally">  56   * Abstract class for copying entities to a new catalog as required during derived catalog propagation. SubclassesðŸ”µ</abbr>
<abbr title="  57   * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcommerce.common.site.domain.Catalog, MultiTenantCopyContext)}">  57   * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcommerce.comðŸ”µ</abbr>
<abbr title="  58   * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clone and persist">  58   * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clone and perðŸ”µ</abbr>
  59   * an entity object tree.
  60   *
  61   * @author Andre Azzolini (apazzolini)
  62   * @author Jeff Fischer
  63   */
  64  public abstract class MultiTenantCopier implements Ordered {
  65      protected static final Log LOG = LogFactory.getLog(MultiTenantCopier.class);
  66  
  67      @Resource(name = &quot;blGenericEntityService&quot;)
  68      protected GenericEntityService genericEntityService;
  69  
  70      @Resource(name = &quot;blMultiTenantCopierExtensionManager&quot;)
  71      protected MultiTenantCopierExtensionManager extensionManager;
  72  
  73      @Resource(name=&quot;blStreamingTransactionCapableUtil&quot;)
  74      protected StreamingTransactionCapableUtil transUtil;
  75  
  76      protected int order = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  77 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -     * @deprecated Please use `classExcludeRegexPatternList`</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -    protected List&lt;Matcher&gt; classExcludeRegexList = new ArrayList&lt;&gt;();</span>
  83  
  84      /**
  85       * To add elements use {@link #addPattern(Pattern)}
  86       */
  87      protected List&lt;Pattern&gt; classExcludeRegexPatternList = new ArrayList&lt;&gt;();
  88  
  89      /**
  90       * Main method that should be implemented by each {@link MultiTenantCopier} to drive the logic of
  91       * copying that particular entity to the new derived catalog.
  92       *
  93       * @param context
  94       */
  95      public abstract void copyEntities(MultiTenantCopyContext context) throws Exception;
  96  
  97      /**
  98       *
  99       * @return the order of this {@link MultiTenantCopier}
 100       */
 101      @Override
 102      public int getOrder() {
 103          return order;
 104      }
 105  
 106      public void setOrder(int order) {
 107          this.order = order;
 108      }
 109  
<abbr title=" 110      protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, Class&lt;T&gt; clazz, T original, MultiTenantCopyContext context) throws G {"> 110      protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, Class&lt;T&gt; clazzðŸ”µ</abbr>
 111          try {
 112              //don&#x27;t persist if there is already an equivalent present
 113              if (context.getEquivalentId(clazz.getName(), genericEntityService.getIdentifier(original)) != null) {
 114                  return;
 115              }
 116  
 117              context.clearOriginalIdentifiers();
 118              genericEntityService.clearAutoFlushMode();
 119              Object copy = copyOperation.execute(original);
 120              SandBox sandBox = BroadleafRequestContext.getBroadleafRequestContext().getSandBox();
 121              DeployState deployState = BroadleafRequestContext.getBroadleafRequestContext().getDeployState();
 122              BroadleafRequestContext.getBroadleafRequestContext().setDeployState(DeployState.PRODUCTION);
 123              BroadleafRequestContext.getBroadleafRequestContext().setSandBox(null);
<abbr title=" 124              BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.FALSE);"> 124              BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforðŸ”µ</abbr>
 125              persistCopyObjectTreeInternal(copy, new HashSet&lt;Integer&gt;(), context);
 126              genericEntityService.flush();
 127              BroadleafRequestContext.getBroadleafRequestContext().setSandBox(sandBox);
 128              BroadleafRequestContext.getBroadleafRequestContext().setDeployState(deployState);
 129          } catch (Exception e) {
 130              LOG.error(&quot;Unable to persist the copy object tree&quot;, e);
 131              throw ExceptionHelper.refineException(e);
 132          } finally {
<abbr title=" 133              BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.TRUE);"> 133              BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforðŸ”µ</abbr>
 134              context.clearOriginalIdentifiers();
 135              genericEntityService.enableAutoFlushMode();
 136          }
 137      }
 138  
<abbr title=" 139      protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContext context) {"> 139      protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContext contextðŸ”µ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 140 -        // TODO: 1/19/2022 replace excludeFromCopyRegex() with excludeFromCopyRegexPattern() after remove property classExcludeRegexList"> 140 -        // TODO: 1/19/2022 replace excludeFromCopyRegex() with excludeFromCopyRegexPattern() after remove propertyðŸ”µ</abbr></span>
 141          if (library.contains(System.identityHashCode(copy)) || !(copy instanceof MultiTenantCloneable)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -                || excludeFromCopyRegex(copy)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +                || this.excludeFromCopyRegexPattern(copy)) {</span>
 144              return;
 145          }
 146          library.add(System.identityHashCode(copy));
 147          List&lt;Object[]&gt; collections = new ArrayList&lt;Object[]&gt;();
 148          Field[] allFields = context.getAllFields(copy.getClass());
 149          for (Field field : allFields) {
 150              if (field.getName().equals(&quot;embeddableSiteDiscriminator&quot;)) {
 151                  continue;
 152              }
 153              if (!Modifier.isStatic(field.getModifiers())) {
 154                  field.setAccessible(true);
 155                  Object newTarget;
 156                  try {
 157                      newTarget = field.get(copy);
 158                  } catch (IllegalAccessException e) {
 159                      throw ExceptionHelper.refineException(e);
 160                  }
 161                  if (newTarget != null) {
<abbr title=" 162                      if (field.getAnnotation(ManyToOne.class) != null || field.getAnnotation(OneToOne.class) != null) {"> 162                      if (field.getAnnotation(ManyToOne.class) != null || field.getAnnotation(OneToOne.class) != nulðŸ”µ</abbr>
 163                          if (library.contains(System.identityHashCode(newTarget))) {
 164                              persistNode(newTarget, context);
 165                              continue;
 166                          }
 167                          persistCopyObjectTreeInternal(newTarget, library, context);
<abbr title=" 168                      } else if (field.getAnnotation(ManyToMany.class) != null || field.getAnnotation(OneToMany.class) != null) {"> 168                      } else if (field.getAnnotation(ManyToMany.class) != null || field.getAnnotation(OneToMany.clasðŸ”µ</abbr>
 169                          collections.add(new Object[]{field, newTarget});
<abbr title=" 170                      } else if (field.getType().getAnnotation(Embeddable.class) != null &amp;&amp; MultiTenantCloneable.class.isAssignableFrom(field.getType())) {"> 170                      } else if (field.getType().getAnnotation(Embeddable.class) != null &amp;&amp; MultiTenantCloneable.claðŸ”µ</abbr>
 171                          persistCopyObjectTreeInternal(newTarget, library, context);
 172                      }
 173                  }
 174              }
 175          }
 176          if (copy.getClass().getAnnotation(Embeddable.class) == null) {
 177              persistNode(copy, context);
 178          }
 179          for (Object[] collectionItem : collections) {
 180              if (collectionItem[1] instanceof Collection) {
 181                  Collection newCollection = (Collection) collectionItem[1];
 182                  for (Object member : newCollection) {
 183                      persistCopyObjectTreeInternal(member, library, context);
 184                  }
 185              } else if (collectionItem[1] instanceof Map) {
 186                  Map newMap = (Map) collectionItem[1];
 187                  for (Object key : newMap.keySet()) {
 188                      persistCopyObjectTreeInternal(newMap.get(key), library, context);
 189                  }
 190              } else {
 191                  throw new IllegalArgumentException(String.format(&quot;During copy object persistence, &quot; +
<abbr title=" 192                          &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The system currently only &quot; +"> 192                          &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The system currentðŸ”µ</abbr>
<abbr title=" 193                          &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) collectionItem[0]).getName()));"> 193                          &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) collectionItðŸ”µ</abbr>
 194              }
 195          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -     * @deprecated Please use `excludeFromCopyRegexPattern()`</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -     * @param copy Copy object</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -     * @return excluded or not in Regex</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -    protected Boolean excludeFromCopyRegex(final Object copy) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -        boolean match = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -        if (this.classExcludeRegexPatternList.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -            LOG.warn(&quot;classExcludeRegexPatternList is empty, deprecated classExcludeRegexList is used&quot;);</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -            for (Matcher regex : this.classExcludeRegexList) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -                if (regex.reset(copy.getClass().toString()).matches()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 210 -                    match = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 211 -                    break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 214 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 215 -           match = this.excludeFromCopyRegexPattern(copy);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 216 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 217 -        return match;</span>
 218      }
 219  
 220      /**
 221       *
 222       * @param copy Copy object
 223       * @return excluded or not in patterns
 224       */
 225      protected Boolean excludeFromCopyRegexPattern(final Object copy) {
 226          boolean match = false;
 227          for (final Pattern pattern : this.classExcludeRegexPatternList) {
 228              final Matcher matcher = pattern.matcher(copy.getClass().toString());
 229              if (matcher.matches()) {
 230                  match = true;
 231                  break;
 232              }
 233          }
 234          return match;
 235      }
 236  
 237      protected void persistNode(final Object copy, final MultiTenantCopyContext context) {
 238          if (!genericEntityService.sessionContains(copy) &amp;&amp; !genericEntityService.idAssigned(copy)) {
<abbr title=" 239              final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), context.removeOriginalIdentifier(copy));"> 239              final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), context.remoðŸ”µ</abbr>
 240              extensionManager.getProxy().transformCopy(context, original, copy);
 241              extensionManager.getProxy().prepareForSave(context, original, copy);
 242  
 243              IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Void, RuntimeException&gt;() {
 244                  @Override
 245                  public Void execute() {
 246                      genericEntityService.persist(copy);
 247                      extensionManager.getProxy().postSave(context, original, copy);
 248                      return null;
 249                  }
 250              }, context.getToSite(), context.getToSite(), context.getToCatalog());
 251  
<abbr title=" 252              context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original), context.getIdentifier(copy));"> 252              context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original), contextðŸ”µ</abbr>
 253          }
 254      }
 255  
 256      /**
<abbr title=" 257       * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} implementation."> 257       * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} implementðŸ”µ</abbr>
 258       *
 259       * @param clazz
 260       * @param fromSite
 261       * @param fromCatalog
 262       * @param context
 263       * @param &lt;T&gt;
 264       * @throws ServiceException
 265       * @throws CloneNotSupportedException
 266       */
<abbr title=" 267      protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fromSite, final Catalog fromCatalog, final MultiTenantCopyContext context)"> 267      protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fromSite, ðŸ”µ</abbr>
 268              throws ServiceException, CloneNotSupportedException {
 269          genericEntityService.flush();
 270          genericEntityService.clear();
 271          transUtil.runStreamingTransactionalOperation(new StreamCapableTransactionalOperationAdapter() {
 272              @Override
 273              public Object[] retrievePage(int startPos, int pageSize) {
 274                  try {
 275                      Object[] temp = new Object[1];
 276                      List&lt;T&gt; results = readAll(clazz, pageSize, startPos, fromSite, fromCatalog);
 277                      temp[0] = results;
 278                      return temp;
 279                  } catch (ServiceException e) {
 280                      throw ExceptionHelper.refineException(e);
 281                  }
 282              }
 283  
 284              @Override
 285              public void pagedExecute(Object[] param) throws Throwable {
 286                  try {
 287                      List&lt;T&gt; results = (List&lt;T&gt;) param[0];
 288                      for (T result : results) {
 289                          persistCopyObjectTree(new CopyOperation&lt;T, CloneNotSupportedException&gt;() {
 290                              @Override
 291                              public T execute(T original) throws CloneNotSupportedException {
 292                                  return (T) original.createOrRetrieveCopyInstance(context).getClone();
 293                              }
 294                          }, clazz, result, context);
 295                      }
 296                  } finally {
 297                      genericEntityService.clear();
 298                  }
 299              }
 300  
 301              @Override
 302              public Long retrieveTotalCount() {
 303                  try {
 304                      return readCount(clazz, fromSite, fromCatalog);
 305                  } catch (ServiceException e) {
 306                      throw ExceptionHelper.refineException(e);
 307                  }
 308              }
 309  
 310              @Override
 311              public boolean shouldRetryOnTransactionLockAcquisitionFailure() {
 312                  return true;
 313              }
 314          }, RuntimeException.class);
 315      }
 316  
 317      /**
 318       * Saves the specified object in the toSite and toCatalog of the given context.
 319       *
 320       * @param context
 321       * @param object
 322       * @return the saved entity
 323       * @throws ServiceException
 324       */
 325      protected &lt;T&gt; T save(MultiTenantCopyContext context, final T object) throws ServiceException {
 326          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;T, ServiceException&gt;() {
 327              @Override
 328              public T execute() throws ServiceException {
 329                  return genericEntityService.save(object);
 330              }
 331          }, context.getToSite(), context.getToSite(), context.getToCatalog());
 332      }
 333  
 334      /**
 335       * Returns the count of the given entity class for the specified site and catalog
 336       *
 337       * @param clazz
 338       * @param site
 339       * @param catalog
 340       * @return the count
 341       * @throws ServiceException
 342       */
 343      protected &lt;T&gt; Long readCount(final Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {
 344          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Long, ServiceException&gt;() {
 345              @Override
 346              public Long execute() throws ServiceException {
 347                  return genericEntityService.readCountGenericEntity(clazz);
 348              }
 349          }, site, site, catalog);
 350      }
 351  
 352      /**
 353       * @see #readAll(Class, int, int, Site, Catalog)
 354       *
 355       * @param clazz
 356       * @param site
 357       * @param catalog
 358       * @return the list of entities for the specified parameters
 359       * @throws ServiceException
 360       */
 361      protected &lt;T&gt; List&lt;T&gt; readAll(Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {
 362          return readAll(clazz, Integer.MAX_VALUE, 0, site, catalog);
 363      }
 364  
 365      /**
 366       * Returns the primary key values for all entities of the specified type in the site or catalog.
 367       *
 368       * @param clazz
 369       * @param site
 370       * @param catalog
 371       * @return
 372       * @throws ServiceException
 373       */
 374      protected List&lt;Long&gt; readAllIds(final Class&lt;?&gt; clazz, Site site, Catalog catalog) throws ServiceException {
<abbr title=" 375          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceException&gt;() {"> 375          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceException&gt;ðŸ”µ</abbr>
 376              @Override
 377              public List&lt;Long&gt; execute() throws ServiceException {
 378                  return genericEntityService.readAllGenericEntityId(clazz);
 379              }
 380          }, site, site, catalog);
 381      }
 382  
 383      /**
 384       * Returns a list of all entities in the system for the given class, site, and catalog. Additionally,
 385       * this method supports pagination.
 386       *
 387       * @param clazz
 388       * @param limit
 389       * @param offset
 390       * @param site
 391       * @param catalog
 392       * @return the list of entities for the specified parameters
 393       * @throws ServiceException
 394       */
 395      protected &lt;T&gt; List&lt;T&gt; readAll(final Class&lt;T&gt; clazz, final int limit, final int offset, Site site,
 396              Catalog catalog) throws ServiceException {
<abbr title=" 397          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceException&gt;() {"> 397          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceException&gt;() ðŸ”µ</abbr>
 398              @Override
 399              public List&lt;T&gt; execute() throws ServiceException {
 400                  return genericEntityService.readAllGenericEntity(clazz, limit, offset);
 401              }
 402          }, site, site, catalog);
 403      }
 404  
 405      /**
 406       * Checks for similar items before adding to avoid duplication
 407       *
 408       * @param pattern input pattern
 409       */
 410      protected void addPattern(final Pattern pattern) {
 411          if (this.needToAdd(pattern)) {
 412              this.classExcludeRegexPatternList.add(pattern);
 413          }
 414      }
 415  
 416      protected boolean needToAdd(final Pattern pattern) {
 417          boolean exist = false;
 418          for (Pattern item : this.classExcludeRegexPatternList) {
 419              if (item.pattern().equals(pattern.pattern())) {
 420                  exist = true;
 421                  break;
 422              }
 423          }
 424          return !exist;
 425      }
 426  
 427  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Common Libraries
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.common.copy;
  19  
  20  import org.apache.commons.logging.Log;
  21  import org.apache.commons.logging.LogFactory;
  22  import org.broadleafcommerce.common.exception.ExceptionHelper;
  23  import org.broadleafcommerce.common.exception.ServiceException;
  24  import org.broadleafcommerce.common.sandbox.domain.SandBox;
  25  import org.broadleafcommerce.common.service.GenericEntityService;
  26  import org.broadleafcommerce.common.site.domain.Catalog;
  27  import org.broadleafcommerce.common.site.domain.Site;
  28  import org.broadleafcommerce.common.util.StreamCapableTransactionalOperationAdapter;
  29  import org.broadleafcommerce.common.util.StreamingTransactionCapableUtil;
  30  import org.broadleafcommerce.common.util.tenant.IdentityExecutionUtils;
  31  import org.broadleafcommerce.common.util.tenant.IdentityOperation;
  32  import org.broadleafcommerce.common.web.BroadleafRequestContext;
  33  import org.broadleafcommerce.common.web.DeployState;
  34  import org.broadleafcommerce.common.web.EnforceEnterpriseCollectionBehaviorState;
  35  import org.springframework.core.Ordered;
  36  
  37  import java.lang.reflect.Field;
  38  import java.lang.reflect.Modifier;
  39  import java.util.ArrayList;
  40  import java.util.Collection;
  41  import java.util.HashSet;
  42  import java.util.List;
  43  import java.util.Map;
  44  import java.util.Set;
  45  import java.util.regex.Matcher;
  46  import java.util.regex.Pattern;
  47  
  48  import javax.annotation.Resource;
  49  import javax.persistence.Embeddable;
  50  import javax.persistence.ManyToMany;
  51  import javax.persistence.ManyToOne;
  52  import javax.persistence.OneToMany;
  53  import javax.persistence.OneToOne;
  54  
  55  /**
<abbr title="  56   * Abstract class for copying entities to a new catalog as required during derived catalog propagation. Subclasses generally">  56   * Abstract class for copying entities to a new catalog as required during derived catalog propagation. SubclassesðŸ”µ</abbr>
<abbr title="  57   * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcommerce.common.site.domain.Catalog, MultiTenantCopyContext)}">  57   * call {@link #copyEntitiesOfType(Class, org.broadleafcommerce.common.site.domain.Site, org.broadleafcommerce.comðŸ”µ</abbr>
<abbr title="  58   * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clone and persist">  58   * one or more times inside of their {@link #copyEntities(MultiTenantCopyContext)} implementation to clone and perðŸ”µ</abbr>
  59   * an entity object tree.
  60   *
  61   * @author Andre Azzolini (apazzolini)
  62   * @author Jeff Fischer
  63   */
  64  public abstract class MultiTenantCopier implements Ordered {
  65      protected static final Log LOG = LogFactory.getLog(MultiTenantCopier.class);
  66  
  67      @Resource(name = &quot;blGenericEntityService&quot;)
  68      protected GenericEntityService genericEntityService;
  69  
  70      @Resource(name = &quot;blMultiTenantCopierExtensionManager&quot;)
  71      protected MultiTenantCopierExtensionManager extensionManager;
  72  
  73      @Resource(name=&quot;blStreamingTransactionCapableUtil&quot;)
  74      protected StreamingTransactionCapableUtil transUtil;
  75  
  76      protected int order = 0;
  77  
  78      /**
  79       * @deprecated Please use `classExcludeRegexPatternList`
  80       */
  81      @Deprecated
  82      protected List&lt;Matcher&gt; classExcludeRegexList = new ArrayList&lt;&gt;();
  83  
  84      /**
  85       * To add elements use {@link #addPattern(Pattern)}
  86       */
  87      protected List&lt;Pattern&gt; classExcludeRegexPatternList = new ArrayList&lt;&gt;();
  88  
  89      /**
  90       * Main method that should be implemented by each {@link MultiTenantCopier} to drive the logic of
  91       * copying that particular entity to the new derived catalog.
  92       *
  93       * @param context
  94       */
  95      public abstract void copyEntities(MultiTenantCopyContext context) throws Exception;
  96  
  97      /**
  98       *
  99       * @return the order of this {@link MultiTenantCopier}
 100       */
 101      @Override
 102      public int getOrder() {
 103          return order;
 104      }
 105  
 106      public void setOrder(int order) {
 107          this.order = order;
 108      }
 109  
<abbr title=" 110      protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, Class&lt;T&gt; clazz, T original, MultiTenantCopyContext context) throws G {"> 110      protected &lt;T, G extends Exception&gt; void persistCopyObjectTree(CopyOperation&lt;T,G&gt; copyOperation, Class&lt;T&gt; clazzðŸ”µ</abbr>
 111          try {
 112              //don&#x27;t persist if there is already an equivalent present
 113              if (context.getEquivalentId(clazz.getName(), genericEntityService.getIdentifier(original)) != null) {
 114                  return;
 115              }
 116  
 117              context.clearOriginalIdentifiers();
 118              genericEntityService.clearAutoFlushMode();
 119              Object copy = copyOperation.execute(original);
 120              SandBox sandBox = BroadleafRequestContext.getBroadleafRequestContext().getSandBox();
 121              DeployState deployState = BroadleafRequestContext.getBroadleafRequestContext().getDeployState();
 122              BroadleafRequestContext.getBroadleafRequestContext().setDeployState(DeployState.PRODUCTION);
 123              BroadleafRequestContext.getBroadleafRequestContext().setSandBox(null);
<abbr title=" 124              BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.FALSE);"> 124              BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforðŸ”µ</abbr>
 125              persistCopyObjectTreeInternal(copy, new HashSet&lt;Integer&gt;(), context);
 126              genericEntityService.flush();
 127              BroadleafRequestContext.getBroadleafRequestContext().setSandBox(sandBox);
 128              BroadleafRequestContext.getBroadleafRequestContext().setDeployState(deployState);
 129          } catch (Exception e) {
 130              LOG.error(&quot;Unable to persist the copy object tree&quot;, e);
 131              throw ExceptionHelper.refineException(e);
 132          } finally {
<abbr title=" 133              BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforceEnterpriseCollectionBehaviorState.TRUE);"> 133              BroadleafRequestContext.getBroadleafRequestContext().setEnforceEnterpriseCollectionBehaviorState(EnforðŸ”µ</abbr>
 134              context.clearOriginalIdentifiers();
 135              genericEntityService.enableAutoFlushMode();
 136          }
 137      }
 138  
<abbr title=" 139      protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContext context) {"> 139      protected void persistCopyObjectTreeInternal(Object copy, Set&lt;Integer&gt; library, MultiTenantCopyContext contextðŸ”µ</abbr>
<abbr title=" 140          // TODO: 1/19/2022 replace excludeFromCopyRegex() with excludeFromCopyRegexPattern() after remove property classExcludeRegexList"> 140          // TODO: 1/19/2022 replace excludeFromCopyRegex() with excludeFromCopyRegexPattern() after remove propertyðŸ”µ</abbr>
 141          if (library.contains(System.identityHashCode(copy)) || !(copy instanceof MultiTenantCloneable)
 142                  || excludeFromCopyRegex(copy)) {

 143              return;
 144          }
 145          library.add(System.identityHashCode(copy));
 146          List&lt;Object[]&gt; collections = new ArrayList&lt;Object[]&gt;();
 147          Field[] allFields = context.getAllFields(copy.getClass());
 148          for (Field field : allFields) {
 149              if (field.getName().equals(&quot;embeddableSiteDiscriminator&quot;)) {
 150                  continue;
 151              }
 152              if (!Modifier.isStatic(field.getModifiers())) {
 153                  field.setAccessible(true);
 154                  Object newTarget;
 155                  try {
 156                      newTarget = field.get(copy);
 157                  } catch (IllegalAccessException e) {
 158                      throw ExceptionHelper.refineException(e);
 159                  }
 160                  if (newTarget != null) {
<abbr title=" 161                      if (field.getAnnotation(ManyToOne.class) != null || field.getAnnotation(OneToOne.class) != null) {"> 161                      if (field.getAnnotation(ManyToOne.class) != null || field.getAnnotation(OneToOne.class) != nulðŸ”µ</abbr>
 162                          if (library.contains(System.identityHashCode(newTarget))) {
 163                              persistNode(newTarget, context);
 164                              continue;
 165                          }
 166                          persistCopyObjectTreeInternal(newTarget, library, context);
<abbr title=" 167                      } else if (field.getAnnotation(ManyToMany.class) != null || field.getAnnotation(OneToMany.class) != null) {"> 167                      } else if (field.getAnnotation(ManyToMany.class) != null || field.getAnnotation(OneToMany.clasðŸ”µ</abbr>
 168                          collections.add(new Object[]{field, newTarget});
<abbr title=" 169                      } else if (field.getType().getAnnotation(Embeddable.class) != null &amp;&amp; MultiTenantCloneable.class.isAssignableFrom(field.getType())) {"> 169                      } else if (field.getType().getAnnotation(Embeddable.class) != null &amp;&amp; MultiTenantCloneable.claðŸ”µ</abbr>
 170                          persistCopyObjectTreeInternal(newTarget, library, context);
 171                      }
 172                  }
 173              }
 174          }
 175          if (copy.getClass().getAnnotation(Embeddable.class) == null) {
 176              persistNode(copy, context);
 177          }
 178          for (Object[] collectionItem : collections) {
 179              if (collectionItem[1] instanceof Collection) {
 180                  Collection newCollection = (Collection) collectionItem[1];
 181                  for (Object member : newCollection) {
 182                      persistCopyObjectTreeInternal(member, library, context);
 183                  }
 184              } else if (collectionItem[1] instanceof Map) {
 185                  Map newMap = (Map) collectionItem[1];
 186                  for (Object key : newMap.keySet()) {
 187                      persistCopyObjectTreeInternal(newMap.get(key), library, context);
 188                  }
 189              } else {
 190                  throw new IllegalArgumentException(String.format(&quot;During copy object persistence, &quot; +
<abbr title=" 191                          &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The system currently only &quot; +"> 191                          &quot;an unrecognized type was detected for a OneToMany or ManyToMany field. The system currentðŸ”µ</abbr>
<abbr title=" 192                          &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) collectionItem[0]).getName()));"> 192                          &quot;recognizes Collection and Map. (%s.%s)&quot;, copy.getClass().getName(), ((Field) collectionItðŸ”µ</abbr>
 193              }
 194          }
 195      }
 196  
 197      /**
 198       * @deprecated Please use `excludeFromCopyRegexPattern()`
 199       * @param copy Copy object
 200       * @return excluded or not in Regex
 201       */
 202      @Deprecated
 203      protected Boolean excludeFromCopyRegex(final Object copy) {
 204          boolean match = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -        if (this.classExcludeRegexPatternList.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -            LOG.warn(&quot;classExcludeRegexPatternList is empty, deprecated classExcludeRegexList is used&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 207 +        if (this.classExcludeRegexPatternList.isEmpty() &amp;&amp; this.classExcludeRegexList!=null &amp;&amp; !this.classExcludeRegexList.isEmpty()) {"> 207 +        if (this.classExcludeRegexPatternList.isEmpty() &amp;&amp; this.classExcludeRegexList!=null &amp;&amp; !this.classExcludeRðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +            LOG.warn(&quot;classExcludeRegexList is deprecated, please use excludeFromCopyRegexPattern&quot;);</span>
 209              for (Matcher regex : this.classExcludeRegexList) {
 210                  if (regex.reset(copy.getClass().toString()).matches()) {
 211                      match = true;
 212                      break;
 213                  }
 214              }
 215          } else {
 216             match = this.excludeFromCopyRegexPattern(copy);
 217          }
 218          return match;
 219      }
 220  
 221      /**
 222       *
 223       * @param copy Copy object
 224       * @return excluded or not in patterns
 225       */
 226      protected Boolean excludeFromCopyRegexPattern(final Object copy) {
 227          boolean match = false;
 228          for (final Pattern pattern : this.classExcludeRegexPatternList) {
 229              final Matcher matcher = pattern.matcher(copy.getClass().toString());
 230              if (matcher.matches()) {
 231                  match = true;
 232                  break;
 233              }
 234          }
 235          return match;
 236      }
 237  
 238      protected void persistNode(final Object copy, final MultiTenantCopyContext context) {
 239          if (!genericEntityService.sessionContains(copy) &amp;&amp; !genericEntityService.idAssigned(copy)) {
<abbr title=" 240              final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), context.removeOriginalIdentifier(copy));"> 240              final Object original = genericEntityService.readGenericEntity(copy.getClass().getName(), context.remoðŸ”µ</abbr>
 241              extensionManager.getProxy().transformCopy(context, original, copy);
 242              extensionManager.getProxy().prepareForSave(context, original, copy);
 243  
 244              IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Void, RuntimeException&gt;() {
 245                  @Override
 246                  public Void execute() {
 247                      genericEntityService.persist(copy);
 248                      extensionManager.getProxy().postSave(context, original, copy);
 249                      return null;
 250                  }
 251              }, context.getToSite(), context.getToSite(), context.getToCatalog());
 252  
<abbr title=" 253              context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original), context.getIdentifier(copy));"> 253              context.storeEquivalentMapping(original.getClass().getName(), context.getIdentifier(original), contextðŸ”µ</abbr>
 254          }
 255      }
 256  
 257      /**
<abbr title=" 258       * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} implementation."> 258       * Subclasses will generally call this method in their {@link #copyEntities(MultiTenantCopyContext)} implementðŸ”µ</abbr>
 259       *
 260       * @param clazz
 261       * @param fromSite
 262       * @param fromCatalog
 263       * @param context
 264       * @param &lt;T&gt;
 265       * @throws ServiceException
 266       * @throws CloneNotSupportedException
 267       */
<abbr title=" 268      protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fromSite, final Catalog fromCatalog, final MultiTenantCopyContext context)"> 268      protected &lt;T extends MultiTenantCloneable&gt; void copyEntitiesOfType(final Class&lt;T&gt; clazz, final Site fromSite, ðŸ”µ</abbr>
 269              throws ServiceException, CloneNotSupportedException {
 270          genericEntityService.flush();
 271          genericEntityService.clear();
 272          transUtil.runStreamingTransactionalOperation(new StreamCapableTransactionalOperationAdapter() {
 273              @Override
 274              public Object[] retrievePage(int startPos, int pageSize) {
 275                  try {
 276                      Object[] temp = new Object[1];
 277                      List&lt;T&gt; results = readAll(clazz, pageSize, startPos, fromSite, fromCatalog);
 278                      temp[0] = results;
 279                      return temp;
 280                  } catch (ServiceException e) {
 281                      throw ExceptionHelper.refineException(e);
 282                  }
 283              }
 284  
 285              @Override
 286              public void pagedExecute(Object[] param) throws Throwable {
 287                  try {
 288                      List&lt;T&gt; results = (List&lt;T&gt;) param[0];
 289                      for (T result : results) {
 290                          persistCopyObjectTree(new CopyOperation&lt;T, CloneNotSupportedException&gt;() {
 291                              @Override
 292                              public T execute(T original) throws CloneNotSupportedException {
 293                                  return (T) original.createOrRetrieveCopyInstance(context).getClone();
 294                              }
 295                          }, clazz, result, context);
 296                      }
 297                  } finally {
 298                      genericEntityService.clear();
 299                  }
 300              }
 301  
 302              @Override
 303              public Long retrieveTotalCount() {
 304                  try {
 305                      return readCount(clazz, fromSite, fromCatalog);
 306                  } catch (ServiceException e) {
 307                      throw ExceptionHelper.refineException(e);
 308                  }
 309              }
 310  
 311              @Override
 312              public boolean shouldRetryOnTransactionLockAcquisitionFailure() {
 313                  return true;
 314              }
 315          }, RuntimeException.class);
 316      }
 317  
 318      /**
 319       * Saves the specified object in the toSite and toCatalog of the given context.
 320       *
 321       * @param context
 322       * @param object
 323       * @return the saved entity
 324       * @throws ServiceException
 325       */
 326      protected &lt;T&gt; T save(MultiTenantCopyContext context, final T object) throws ServiceException {
 327          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;T, ServiceException&gt;() {
 328              @Override
 329              public T execute() throws ServiceException {
 330                  return genericEntityService.save(object);
 331              }
 332          }, context.getToSite(), context.getToSite(), context.getToCatalog());
 333      }
 334  
 335      /**
 336       * Returns the count of the given entity class for the specified site and catalog
 337       *
 338       * @param clazz
 339       * @param site
 340       * @param catalog
 341       * @return the count
 342       * @throws ServiceException
 343       */
 344      protected &lt;T&gt; Long readCount(final Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {
 345          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;Long, ServiceException&gt;() {
 346              @Override
 347              public Long execute() throws ServiceException {
 348                  return genericEntityService.readCountGenericEntity(clazz);
 349              }
 350          }, site, site, catalog);
 351      }
 352  
 353      /**
 354       * @see #readAll(Class, int, int, Site, Catalog)
 355       *
 356       * @param clazz
 357       * @param site
 358       * @param catalog
 359       * @return the list of entities for the specified parameters
 360       * @throws ServiceException
 361       */
 362      protected &lt;T&gt; List&lt;T&gt; readAll(Class&lt;T&gt; clazz, Site site, Catalog catalog) throws ServiceException {
 363          return readAll(clazz, Integer.MAX_VALUE, 0, site, catalog);
 364      }
 365  
 366      /**
 367       * Returns the primary key values for all entities of the specified type in the site or catalog.
 368       *
 369       * @param clazz
 370       * @param site
 371       * @param catalog
 372       * @return
 373       * @throws ServiceException
 374       */
 375      protected List&lt;Long&gt; readAllIds(final Class&lt;?&gt; clazz, Site site, Catalog catalog) throws ServiceException {
<abbr title=" 376          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceException&gt;() {"> 376          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;Long&gt;, ServiceException&gt;ðŸ”µ</abbr>
 377              @Override
 378              public List&lt;Long&gt; execute() throws ServiceException {
 379                  return genericEntityService.readAllGenericEntityId(clazz);
 380              }
 381          }, site, site, catalog);
 382      }
 383  
 384      /**
 385       * Returns a list of all entities in the system for the given class, site, and catalog. Additionally,
 386       * this method supports pagination.
 387       *
 388       * @param clazz
 389       * @param limit
 390       * @param offset
 391       * @param site
 392       * @param catalog
 393       * @return the list of entities for the specified parameters
 394       * @throws ServiceException
 395       */
 396      protected &lt;T&gt; List&lt;T&gt; readAll(final Class&lt;T&gt; clazz, final int limit, final int offset, Site site,
 397              Catalog catalog) throws ServiceException {
<abbr title=" 398          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceException&gt;() {"> 398          return IdentityExecutionUtils.runOperationByIdentifier(new IdentityOperation&lt;List&lt;T&gt;, ServiceException&gt;() ðŸ”µ</abbr>
 399              @Override
 400              public List&lt;T&gt; execute() throws ServiceException {
 401                  return genericEntityService.readAllGenericEntity(clazz, limit, offset);
 402              }
 403          }, site, site, catalog);
 404      }
 405  
 406      /**
 407       * Checks for similar items before adding to avoid duplication
 408       *
 409       * @param pattern input pattern
 410       */
 411      protected void addPattern(final Pattern pattern) {
 412          if (this.needToAdd(pattern)) {
 413              this.classExcludeRegexPatternList.add(pattern);
 414          }
 415      }
 416  
 417      protected boolean needToAdd(final Pattern pattern) {
 418          boolean exist = false;
 419          for (Pattern item : this.classExcludeRegexPatternList) {
 420              if (item.pattern().equals(pattern.pattern())) {
 421                  exist = true;
 422                  break;
 423              }
 424          }
 425          return !exist;
 426      }
 427  
 428  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            