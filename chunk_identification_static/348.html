<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>348</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    348
                    <a href="347.html">prev</a>
                    <a href="349.html">next</a>
                    <a href="348_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_c82b9ccdf1393af88048eae80a098a6a0901d157_redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c82b9ccdf1393af88048eae80a098a6a0901d157:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c82b9ccdf1393af88048eae80a098a6a0901d157^1:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c82b9ccdf1393af88048eae80a098a6a0901d157^2:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;8cb6d5aea72f25034c7f3626ec6ef98783b1bee5:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.dtstack.flink.sql.side.CacheMissVal;
  24 import com.dtstack.flink.sql.side.FieldInfo;
  25 import com.dtstack.flink.sql.side.JoinInfo;
  26 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  27 import org.apache.flink.configuration.Configuration;
  28 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  29 import org.apache.flink.table.runtime.types.CRow;
  30 import org.apache.flink.types.Row;
  31 
  32 import com.dtstack.flink.sql.enums.ECacheContentType;
  33 import com.dtstack.flink.sql.side.cache.CacheObj;
  34 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  35 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  37 import io.lettuce.core.RedisClient;
  38 import io.lettuce.core.RedisFuture;
  39 import io.lettuce.core.api.StatefulRedisConnection;
  40 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  41 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  42 import io.lettuce.core.cluster.RedisClusterClient;
  43 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  44 import org.apache.commons.collections.MapUtils;
  45 import org.apache.commons.lang.StringUtils;
  46 import com.google.common.collect.Maps;
  47 
  48 import java.util.Collections;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.function.Consumer;
  52 /**
  53  * @author yanxi
  54  */
  55 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  56 
  57     private static final long serialVersionUID = -2079908694523987738L;
  58 
  59     private RedisClient redisClient;
  60 
  61     private StatefulRedisConnection&lt;String, String&gt; connection;
  62 
  63     private RedisClusterClient clusterClient;
  64 
  65     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  66 
  67     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  68 
  69     private RedisSideTableInfo redisSideTableInfo;
  70 
  71     private RedisSideReqRow redisSideReqRow;
  72 
<abbr title="  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  74         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  75         redisSideReqRow = new RedisSideReqRow(super.sideInfo, (RedisSideTableInfo) sideTableInfo);
  76     }
  77 
  78     @Override
  79     public void open(Configuration parameters) throws Exception {
  80         super.open(parameters);
  81         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  82         buildRedisClient(redisSideTableInfo);
  83     }
  84 
  85     private void buildRedisClient(RedisSideTableInfo tableInfo){
  86         String url = redisSideTableInfo.getUrl();
  87         String password = redisSideTableInfo.getPassword();
  88         if (password != null){
  89             password = password + &quot;@&quot;;
  90         } else {
  91             password = &quot;&quot;;
  92         }
  93         String database = redisSideTableInfo.getDatabase();
  94         if (database == null){
  95             database = &quot;0&quot;;
  96         }
  97         switch (RedisType.parse(tableInfo.getRedisType())){
  98             case STANDALONE:
  99                 StringBuilder redisUri = new StringBuilder();
 100                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 101                 redisClient = RedisClient.create(redisUri.toString());
 102                 connection = redisClient.connect();
 103                 async = connection.async();
 104                 break;
 105             case SENTINEL:
 106                 StringBuilder sentinelUri = new StringBuilder();
 107                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 109                 redisClient = RedisClient.create(sentinelUri.toString());
 110                 connection = redisClient.connect();
 111                 async = connection.async();
 112                 break;
 113             case CLUSTER:
 114                 StringBuilder clusterUri = new StringBuilder();
 115                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 116                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 117                 clusterConnection = clusterClient.connect();
 118                 async = clusterConnection.async();
 119             default:
 120                 break;
 121         }
 122     }
 123 
 124     @Override
 125     public Row fillData(Row input, Object sideInput) {
 126         return redisSideReqRow.fillData(input, sideInput);
 127     }
 128 
 129     @Override
<abbr title=" 130     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 130     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 131 
 132         String key = buildCacheKey(inputParams);
 133         if(StringUtils.isBlank(key)){
 134             return;
 135         }
 136         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 137         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 138             @Override
 139             public void accept(Map&lt;String, String&gt; values) {
 140                 if (MapUtils.isNotEmpty(values)) {
 141                     try {
 142                         Row row = fillData(input.row(), values);
 143 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 144                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, values));</span>
 145 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 146                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 147                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
 148 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 149                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, row));</span>
 150 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 151                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 152                     } catch (Exception e) {
 153                         dealFillDataError(input, resultFuture, e);
 154                     }
 155                 } else {
 156                     dealMissKey(input, resultFuture);
 157                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 158                 }
 159             }
 160         });
 161     }
 162 
 163     @Override
 164     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 165         return redisSideReqRow.buildCacheKey(refData);
 166     }
 167 
 168     @Override
 169     public void close() throws Exception {
 170         super.close();
 171         if (connection != null){
 172             connection.close();
 173         }
 174         if (redisClient != null){
 175             redisClient.shutdown();
 176         }
 177         if (clusterConnection != null){
 178             clusterConnection.close();
 179         }
 180         if (clusterClient != null){
 181             clusterClient.shutdown();
 182         }
 183     }
 184 
 185 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  24 import org.apache.flink.configuration.Configuration;
  25 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  26 import org.apache.flink.table.runtime.types.CRow;
  27 import org.apache.flink.types.Row;
  28 
  29 import com.dtstack.flink.sql.enums.ECacheContentType;
  30 import com.dtstack.flink.sql.side.CacheMissVal;
  31 import com.dtstack.flink.sql.side.FieldInfo;
  32 import com.dtstack.flink.sql.side.JoinInfo;
  33 import com.dtstack.flink.sql.side.cache.CacheObj;
  34 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  35 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  37 import io.lettuce.core.RedisClient;
  38 import io.lettuce.core.RedisFuture;
  39 import io.lettuce.core.api.StatefulRedisConnection;
  40 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  41 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  42 import io.lettuce.core.cluster.RedisClusterClient;
  43 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  44 import org.apache.commons.collections.MapUtils;
  45 import org.apache.commons.lang.StringUtils;
  46 import com.google.common.collect.Maps;
  47 
  48 import java.util.Collections;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.function.Consumer;
  52 /**
  53  * @author yanxi
  54  */
  55 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  56 
  57     private static final long serialVersionUID = -2079908694523987738L;
  58 
  59     private RedisClient redisClient;
  60 
  61     private StatefulRedisConnection&lt;String, String&gt; connection;
  62 
  63     private RedisClusterClient clusterClient;
  64 
  65     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  66 
  67     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  68 
  69     private RedisSideTableInfo redisSideTableInfo;
  70 
  71     private RedisSideReqRow redisSideReqRow;
  72 
<abbr title="  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  74         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  75         redisSideReqRow = new RedisSideReqRow(super.sideInfo, (RedisSideTableInfo) sideTableInfo);
  76     }
  77 
  78     @Override
  79     public void open(Configuration parameters) throws Exception {
  80         super.open(parameters);
  81         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  82         buildRedisClient(redisSideTableInfo);
  83     }
  84 
  85     private void buildRedisClient(RedisSideTableInfo tableInfo){
  86         String url = redisSideTableInfo.getUrl();
  87         String password = redisSideTableInfo.getPassword();
  88         if (password != null){
  89             password = password + &quot;@&quot;;
  90         } else {
  91             password = &quot;&quot;;
  92         }
  93         String database = redisSideTableInfo.getDatabase();
  94         if (database == null){
  95             database = &quot;0&quot;;
  96         }
  97         switch (RedisType.parse(tableInfo.getRedisType())){
  98             case STANDALONE:
  99                 StringBuilder redisUri = new StringBuilder();
 100                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 101                 redisClient = RedisClient.create(redisUri.toString());
 102                 connection = redisClient.connect();
 103                 async = connection.async();
 104                 break;
 105             case SENTINEL:
 106                 StringBuilder sentinelUri = new StringBuilder();
 107                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 109                 redisClient = RedisClient.create(sentinelUri.toString());
 110                 connection = redisClient.connect();
 111                 async = connection.async();
 112                 break;
 113             case CLUSTER:
 114                 StringBuilder clusterUri = new StringBuilder();
 115                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 116                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 117                 clusterConnection = clusterClient.connect();
 118                 async = clusterConnection.async();
 119             default:
 120                 break;
 121         }
 122     }
 123 
 124     @Override
 125     public Row fillData(Row input, Object sideInput) {
 126         return redisSideReqRow.fillData(input, sideInput);
 127     }
 128 
 129     @Override
<abbr title=" 130     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 130     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 131 
 132         String key = buildCacheKey(inputParams);
 133         if(StringUtils.isBlank(key)){
 134             return;
 135         }
 136         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 137         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 138             @Override
 139             public void accept(Map&lt;String, String&gt; values) {
 140                 if (MapUtils.isNotEmpty(values)) {
 141                     try {
 142                         Row row = fillData(input.row(), values);
 143 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 144                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, values));</span>
 145 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 146                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 147                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
 148 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 149                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, row));</span>
 150 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 151                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 152                     } catch (Exception e) {
 153                         dealFillDataError(input, resultFuture, e);
 154                     }
 155                 } else {
 156                     dealMissKey(input, resultFuture);
 157                     dealCacheData(key,CacheMissVal.getMissKeyObj());
 158                 }
 159             }
 160         });
 161     }
 162 
 163     @Override
 164     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 165         return redisSideReqRow.buildCacheKey(refData);
 166     }
 167 
 168     @Override
 169     public void close() throws Exception {
 170         super.close();
 171         if (connection != null){
 172             connection.close();
 173         }
 174         if (redisClient != null){
 175             redisClient.shutdown();
 176         }
 177         if (clusterConnection != null){
 178             clusterConnection.close();
 179         }
 180         if (clusterClient != null){
 181             clusterClient.shutdown();
 182         }
 183     }
 184 
 185 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.redis;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.dtstack.flink.sql.side.CacheMissVal;
  24 import com.dtstack.flink.sql.side.FieldInfo;
  25 import com.dtstack.flink.sql.side.JoinInfo;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  28 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  29 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  30 import com.google.common.collect.Maps;
  31 import io.lettuce.core.RedisClient;
  32 import io.lettuce.core.RedisFuture;
  33 import io.lettuce.core.api.StatefulRedisConnection;
  34 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  35 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  36 import io.lettuce.core.cluster.RedisClusterClient;
  37 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  38 import java.util.Collections;
  39 import java.util.List;
  40 import java.util.Map;
  41 import java.util.function.Consumer;
  42 import org.apache.commons.collections.MapUtils;
  43 import org.apache.commons.lang.StringUtils;
  44 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  45 import org.apache.flink.configuration.Configuration;
  46 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  47 import org.apache.flink.table.runtime.types.CRow;
  48 import org.apache.flink.types.Row;
  49 
  50 
  51 /**
  52  * @author yanxi
  53  */
  54 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  55     private static final long serialVersionUID = -2079908694523987738L;
  56 
  57     private RedisClient redisClient;
  58 
  59     private StatefulRedisConnection&lt;String, String&gt; connection;
  60 
  61     private RedisClusterClient clusterClient;
  62 
  63     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  64 
  65     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  66 
  67     private RedisSideTableInfo redisSideTableInfo;
  68 
  69     private RedisSideReqRow redisSideReqRow;
  70 
<abbr title="  71     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  71     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  72         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  73         redisSideReqRow = new RedisSideReqRow(super.sideInfo, ((RedisSideTableInfo) (sideTableInfo)));
  74     }
  75 
  76     @Override
  77     public void open(Configuration parameters) throws Exception {
  78         super.open(parameters);
  79         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  80         buildRedisClient(redisSideTableInfo);
  81     }
  82 
  83     private void buildRedisClient(RedisSideTableInfo tableInfo){
  84         String url = redisSideTableInfo.getUrl();
  85         String password = redisSideTableInfo.getPassword();
  86         if (password != null){
  87             password = password + &quot;@&quot;;
  88         } else {
  89             password = &quot;&quot;;
  90         }
  91         String database = redisSideTableInfo.getDatabase();
  92         if (database == null){
  93             database = &quot;0&quot;;
  94         }
  95         switch (RedisType.parse(tableInfo.getRedisType())){
  96             case STANDALONE:
  97                 StringBuilder redisUri = new StringBuilder();
  98                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
  99                 redisClient = RedisClient.create(redisUri.toString());
 100                 connection = redisClient.connect();
 101                 async = connection.async();
 102                 break;
 103             case SENTINEL:
 104                 StringBuilder sentinelUri = new StringBuilder();
 105                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 106                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 106                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 107                 redisClient = RedisClient.create(sentinelUri.toString());
 108                 connection = redisClient.connect();
 109                 async = connection.async();
 110                 break;
 111             case CLUSTER:
 112                 StringBuilder clusterUri = new StringBuilder();
 113                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 114                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 115                 clusterConnection = clusterClient.connect();
 116                 async = clusterConnection.async();
 117             default:
 118                 break;
 119         }
 120     }
 121 
 122     @Override
 123     public Row fillData(Row input, Object sideInput) {
 124         return redisSideReqRow.fillData(input, sideInput);
 125     }
 126 
 127     @Override
<abbr title=" 128     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 128     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 129         String key = buildCacheKey(inputParams);
 130         if (StringUtils.isBlank(key)) {
 131             return;
 132         }
 133         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) (async)).hgetall(key);
 134         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 135             @Override
 136             public void accept(Map&lt;String, String&gt; values) {
 137                 if (MapUtils.isNotEmpty(values)) {
 138                     try {
 139                         Row row = fillData(input.row(), values);
 140                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.SingleLine, row));
 141                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 142                     } catch (java.lang.Exception e) {
 143                         dealFillDataError(input, resultFuture, e);
 144                     }
 145                 } else {
 146                     dealMissKey(input, resultFuture);
 147                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 148                 }
 149             }
 150         });
 151     }
 152 
 153     @Override
 154     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 155         return redisSideReqRow.buildCacheKey(refData);
 156     }
 157 
 158     @Override
 159     public void close() throws Exception {
 160         super.close();
 161         if (connection != null){
 162             connection.close();
 163         }
 164         if (redisClient != null){
 165             redisClient.shutdown();
 166         }
 167         if (clusterConnection != null){
 168             clusterConnection.close();
 169         }
 170         if (clusterClient != null){
 171             clusterClient.shutdown();
 172         }
 173     }
 174 }
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
  21  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import io.lettuce.core.KeyValue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import io.lettuce.core.api.async.RedisStringAsyncCommands;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import com.dtstack.flink.sql.side.CacheMissVal;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import com.dtstack.flink.sql.side.FieldInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import com.dtstack.flink.sql.side.JoinInfo;</span>
  28  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  29  import org.apache.flink.configuration.Configuration;
  30  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  31  import org.apache.flink.table.runtime.types.CRow;
  32  import org.apache.flink.types.Row;
  33  
  34  import com.dtstack.flink.sql.enums.ECacheContentType;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import com.dtstack.flink.sql.side.CacheMissVal;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  36 -import com.dtstack.flink.sql.side.FieldInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import com.dtstack.flink.sql.side.JoinInfo;</span>
  38  import com.dtstack.flink.sql.side.cache.CacheObj;
  39  import com.dtstack.flink.sql.side.redis.enums.RedisType;
  40  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  41  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  42  import io.lettuce.core.RedisClient;
  43  import io.lettuce.core.RedisFuture;
  44  import io.lettuce.core.api.StatefulRedisConnection;
  45  import io.lettuce.core.api.async.RedisHashAsyncCommands;
  46  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  47  import io.lettuce.core.cluster.RedisClusterClient;
  48  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  49  import org.apache.commons.collections.MapUtils;
  50  import org.apache.commons.lang.StringUtils;
  51  import com.google.common.collect.Maps;
  52  
  53  import java.util.Collections;
  54  import java.util.List;
  55  import java.util.Map;
  56  import java.util.function.Consumer;
  57  /**
  58   * @author yanxi
  59   */
  60  public class RedisAsyncReqRow extends BaseAsyncReqRow {
  61  
  62      private static final long serialVersionUID = -2079908694523987738L;
  63  
  64      private RedisClient redisClient;
  65  
  66      private StatefulRedisConnection&lt;String, String&gt; connection;
  67  
  68      private RedisClusterClient clusterClient;
  69  
  70      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  71  
  72      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  73  
  74      private RedisSideTableInfo redisSideTableInfo;
  75  
  76      private RedisSideReqRow redisSideReqRow;
  77  
<abbr title="  78      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  78      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  79          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -        redisSideReqRow = new RedisSideReqRow(super.sideInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +        redisSideReqRow = new RedisSideReqRow(super.sideInfo, (RedisSideTableInfo) sideTableInfo);</span>
  82      }
  83  
  84      @Override
  85      public void open(Configuration parameters) throws Exception {
  86          super.open(parameters);
  87          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  88          buildRedisClient(redisSideTableInfo);
  89      }
  90  
  91      private void buildRedisClient(RedisSideTableInfo tableInfo){
  92          String url = redisSideTableInfo.getUrl();
  93          String password = redisSideTableInfo.getPassword();
  94          if (password != null){
  95              password = password + &quot;@&quot;;
  96          } else {
  97              password = &quot;&quot;;
  98          }
  99          String database = redisSideTableInfo.getDatabase();
 100          if (database == null){
 101              database = &quot;0&quot;;
 102          }
 103          switch (RedisType.parse(tableInfo.getRedisType())){
 104              case STANDALONE:
 105                  StringBuilder redisUri = new StringBuilder();
 106                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 107                  redisClient = RedisClient.create(redisUri.toString());
 108                  connection = redisClient.connect();
 109                  async = connection.async();
 110                  break;
 111              case SENTINEL:
 112                  StringBuilder sentinelUri = new StringBuilder();
 113                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 114                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 114                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterNðŸ”µ</abbr>
 115                  redisClient = RedisClient.create(sentinelUri.toString());
 116                  connection = redisClient.connect();
 117                  async = connection.async();
 118                  break;
 119              case CLUSTER:
 120                  StringBuilder clusterUri = new StringBuilder();
 121                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 122                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 123                  clusterConnection = clusterClient.connect();
 124                  async = clusterConnection.async();
 125              default:
 126                  break;
 127          }
 128      }
 129  
 130      @Override
 131      public Row fillData(Row input, Object sideInput) {
 132          return redisSideReqRow.fillData(input, sideInput);
 133      }
 134  
 135      @Override
<abbr title=" 136      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 136      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +</span>
 138          String key = buildCacheKey(inputParams);
 139          if(StringUtils.isBlank(key)){
 140              return;
 141          }
 142          RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 143          future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 144              @Override
 145              public void accept(Map&lt;String, String&gt; values) {
 146                  if (MapUtils.isNotEmpty(values)) {
 147                      try {
 148                          Row row = fillData(input.row(), values);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, values));</span>
 151                          resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 152                      } catch (Exception e) {
 153                          dealFillDataError(input, resultFuture, e);
 154                      }
 155                  } else {
 156                      dealMissKey(input, resultFuture);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -                    dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +                    dealCacheData(key, CacheMissVal.getMissKeyObj());</span>
 159                  }
 160              }
 161          });
 162      }
 163  
 164      @Override
 165      public String buildCacheKey(Map&lt;String, Object&gt; refData) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -        StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -        List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -        for(String primaryKey : primaryKeys){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -            if(!refData.containsKey(primaryKey)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -                return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -            keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 174 -        return keyBuilder.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +        return redisSideReqRow.buildCacheKey(refData);</span>
 176      }
 177  
 178      @Override
 179      public void close() throws Exception {
 180          super.close();
 181          if (connection != null){
 182              connection.close();
 183          }
 184          if (redisClient != null){
 185              redisClient.shutdown();
 186          }
 187          if (clusterConnection != null){
 188              clusterConnection.close();
 189          }
 190          if (clusterClient != null){
 191              clusterClient.shutdown();
 192          }
 193      }
 194  
 195  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
  21  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23  import io.lettuce.core.KeyValue;
  24  import io.lettuce.core.api.async.RedisStringAsyncCommands;



  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26  import org.apache.flink.configuration.Configuration;
  27  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  28  import org.apache.flink.table.runtime.types.CRow;
  29  import org.apache.flink.types.Row;
  30  
  31  import com.dtstack.flink.sql.enums.ECacheContentType;
  32  import com.dtstack.flink.sql.side.CacheMissVal;
  33  import com.dtstack.flink.sql.side.FieldInfo;
  34  import com.dtstack.flink.sql.side.JoinInfo;
  35  import com.dtstack.flink.sql.side.cache.CacheObj;
  36  import com.dtstack.flink.sql.side.redis.enums.RedisType;
  37  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  38  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  39  import io.lettuce.core.RedisClient;
  40  import io.lettuce.core.RedisFuture;
  41  import io.lettuce.core.api.StatefulRedisConnection;
  42  import io.lettuce.core.api.async.RedisHashAsyncCommands;
  43  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  44  import io.lettuce.core.cluster.RedisClusterClient;
  45  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  46  import org.apache.commons.collections.MapUtils;
  47  import org.apache.commons.lang.StringUtils;
  48  import com.google.common.collect.Maps;
  49  
  50  import java.util.Collections;
  51  import java.util.List;
  52  import java.util.Map;
  53  import java.util.function.Consumer;
  54  /**
  55   * @author yanxi
  56   */
  57  public class RedisAsyncReqRow extends BaseAsyncReqRow {
  58  
  59      private static final long serialVersionUID = -2079908694523987738L;
  60  
  61      private RedisClient redisClient;
  62  
  63      private StatefulRedisConnection&lt;String, String&gt; connection;
  64  
  65      private RedisClusterClient clusterClient;
  66  
  67      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  68  
  69      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  70  
  71      private RedisSideTableInfo redisSideTableInfo;
  72  
  73      private RedisSideReqRow redisSideReqRow;
  74  
<abbr title="  75      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  75      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  76          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  77          redisSideReqRow = new RedisSideReqRow(super.sideInfo);

  78      }
  79  
  80      @Override
  81      public void open(Configuration parameters) throws Exception {
  82          super.open(parameters);
  83          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  84          buildRedisClient(redisSideTableInfo);
  85      }
  86  
  87      private void buildRedisClient(RedisSideTableInfo tableInfo){
  88          String url = redisSideTableInfo.getUrl();
  89          String password = redisSideTableInfo.getPassword();
  90          if (password != null){
  91              password = password + &quot;@&quot;;
  92          } else {
  93              password = &quot;&quot;;
  94          }
  95          String database = redisSideTableInfo.getDatabase();
  96          if (database == null){
  97              database = &quot;0&quot;;
  98          }
  99          switch (RedisType.parse(tableInfo.getRedisType())){
 100              case STANDALONE:
 101                  StringBuilder redisUri = new StringBuilder();
 102                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 103                  redisClient = RedisClient.create(redisUri.toString());
 104                  connection = redisClient.connect();
 105                  async = connection.async();
 106                  break;
 107              case SENTINEL:
 108                  StringBuilder sentinelUri = new StringBuilder();
 109                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 110                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 110                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterNðŸ”µ</abbr>
 111                  redisClient = RedisClient.create(sentinelUri.toString());
 112                  connection = redisClient.connect();
 113                  async = connection.async();
 114                  break;
 115              case CLUSTER:
 116                  StringBuilder clusterUri = new StringBuilder();
 117                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 118                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 119                  clusterConnection = clusterClient.connect();
 120                  async = clusterConnection.async();
 121              default:
 122                  break;
 123          }
 124      }
 125  
 126      @Override
 127      public Row fillData(Row input, Object sideInput) {
 128          return redisSideReqRow.fillData(input, sideInput);
 129      }
 130  
 131      @Override
<abbr title=" 132      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 132      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr>

 133          String key = buildCacheKey(inputParams);
 134          if(StringUtils.isBlank(key)){
 135              return;
 136          }
 137          RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 138          future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 139              @Override
 140              public void accept(Map&lt;String, String&gt; values) {
 141                  if (MapUtils.isNotEmpty(values)) {
 142                      try {
 143                          Row row = fillData(input.row(), values);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, row));</span>
 146                          resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 147                      } catch (Exception e) {
 148                          dealFillDataError(input, resultFuture, e);
 149                      }
 150                  } else {
 151                      dealMissKey(input, resultFuture);
 152                      dealCacheData(key,CacheMissVal.getMissKeyObj());

 153                  }
 154              }
 155          });
 156      }
 157  
 158      @Override
 159      public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 160          StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 161          List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 162          for(String primaryKey : primaryKeys){
 163              if(!refData.containsKey(primaryKey)){
 164                  return null;
 165              }
 166              keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 167          }
 168          return keyBuilder.toString();

 169      }
 170  
 171      @Override
 172      public void close() throws Exception {
 173          super.close();
 174          if (connection != null){
 175              connection.close();
 176          }
 177          if (redisClient != null){
 178              redisClient.shutdown();
 179          }
 180          if (clusterConnection != null){
 181              clusterConnection.close();
 182          }
 183          if (clusterClient != null){
 184              clusterClient.shutdown();
 185          }
 186      }
 187  
 188  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            