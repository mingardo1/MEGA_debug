<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>571</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    571
                    <a href="570.html">prev</a>
                    <a href="572.html">next</a>
                    <a href="571_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_d3f904d1d764e0acb7127ddbeb050c2b3ff060b3_redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3^1:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3^2:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d124305ffe07b66f8eee430b3c0ac1072281dc14:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [bj], [bj], [b], [j]], subset: [[bj], [bj], [bj], [bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import org.apache.flink.api.java.tuple.Tuple2;
  24 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  25 import org.apache.flink.configuration.Configuration;
  26 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  27 import org.apache.flink.types.Row;
  28 
  29 import com.dtstack.flink.sql.enums.ECacheContentType;
  30 import com.dtstack.flink.sql.side.CacheMissVal;
  31 import com.dtstack.flink.sql.side.FieldInfo;
  32 import com.dtstack.flink.sql.side.JoinInfo;
  33 import com.dtstack.flink.sql.side.cache.CacheObj;
  34 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  35 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  37 import io.lettuce.core.RedisClient;
  38 import io.lettuce.core.RedisFuture;
  39 import io.lettuce.core.api.StatefulRedisConnection;
  40 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  41 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  42 import io.lettuce.core.cluster.RedisClusterClient;
  43 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  44 import org.apache.commons.collections.MapUtils;
  45 import org.apache.commons.lang.StringUtils;
  46 import com.google.common.collect.Maps;
  47 
  48 import java.util.Collections;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.function.Consumer;
  52 /**
  53  * @author yanxi
  54  */
  55 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  56 
  57     private static final long serialVersionUID = -2079908694523987738L;
  58 
  59     private RedisClient redisClient;
  60 
  61     private StatefulRedisConnection&lt;String, String&gt; connection;
  62 
  63     private RedisClusterClient clusterClient;
  64 
  65     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  66 
  67     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  68 
  69     private RedisSideTableInfo redisSideTableInfo;
  70 
  71     private RedisSideReqRow redisSideReqRow;
  72 
<abbr title="  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  74         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  75         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  76     }
  77 
  78     @Override
  79     public void open(Configuration parameters) throws Exception {
  80         super.open(parameters);
  81         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  82         buildRedisClient(redisSideTableInfo);
  83     }
  84 
  85     private void buildRedisClient(RedisSideTableInfo tableInfo){
  86         String url = redisSideTableInfo.getUrl();
  87         String password = redisSideTableInfo.getPassword();
  88         if (password != null){
  89             password = password + &quot;@&quot;;
  90         } else {
  91             password = &quot;&quot;;
  92         }
  93         String database = redisSideTableInfo.getDatabase();
  94         if (database == null){
  95             database = &quot;0&quot;;
  96         }
  97         switch (RedisType.parse(tableInfo.getRedisType())){
  98             case STANDALONE:
  99                 StringBuilder redisUri = new StringBuilder();
 100                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 101                 redisClient = RedisClient.create(redisUri.toString());
 102                 connection = redisClient.connect();
 103                 async = connection.async();
 104                 break;
 105             case SENTINEL:
 106                 StringBuilder sentinelUri = new StringBuilder();
 107                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 109                 redisClient = RedisClient.create(sentinelUri.toString());
 110                 connection = redisClient.connect();
 111                 async = connection.async();
 112                 break;
 113             case CLUSTER:
 114                 StringBuilder clusterUri = new StringBuilder();
 115                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 116                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 117                 clusterConnection = clusterClient.connect();
 118                 async = clusterConnection.async();
 119             default:
 120                 break;
 121         }
 122     }
 123 
 124     @Override
 125     public Row fillData(Row input, Object sideInput) {
 126         return redisSideReqRow.fillData(input, sideInput);
 127     }
 128 
 129     @Override
 130 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 131     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 131     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) thðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132         Tuple2&lt;Boolean, Row&gt; inputCopy = Tuple2.of(input.f0, input.f1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133         List&lt;String&gt; keyData = Lists.newLinkedList();</span>
 134 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136         CRow inputCopy = new CRow(input.row(),input.change());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137         List&lt;String&gt; keyData = Lists.newLinkedList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 138         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {</span>
 139 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 140     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 141         CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 142         Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
 143 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 144         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 145             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 146 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147             Object equalObj = inputCopy.f1.getField(conValIndex);</span>
 148 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 149             Object equalObj = inputCopy.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 150             if(equalObj == null){</span>
 151 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 152             Object equalObj = input.row().getField(conValIndex);</span>
 153 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 154             if(equalObj == null){
 155                 dealMissKey(inputCopy, resultFuture);
 156                 return;
 157             }
 158             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 159         }
 160 
 161         String key = buildCacheKey(refData);
 162         if(StringUtils.isBlank(key)){
 163             return;
 164         }
 165         if(openCache()){
 166             CacheObj val = getFromCache(key);
 167             if(val != null){
 168                 if(ECacheContentType.MissVal == val.getType()){
 169                     dealMissKey(inputCopy, resultFuture);
 170                     return;
 171                 }else if(ECacheContentType.MultiLine == val.getType()){
 172                     try {
 173 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 174                         Row row = fillData(inputCopy.f1, val.getContent());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 175                         resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));</span>
 176 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177                         Row row = fillData(inputCopy.row(), val.getContent());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 179                     } catch (Exception e) {</span>
 180 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 181                         Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 182                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
 183 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 184                     } catch (Exception e) {
 185                         dealFillDataError(resultFuture, e, inputCopy);
 186                     }
 187                 }else{
<abbr title=" 188                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 188                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + valðŸ”µ</abbr>
 189                     resultFuture.completeExceptionally(exception);
 190                 }
 191                 return;
 192             }
 193         }
 194 
 195 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 196         Map&lt;String, String&gt; keyValue = Maps.newHashMap();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 197         List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 198         String[] values = value.toArray(new String[value.size()]);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 199         if (values.length == 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 200             dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 201         } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 202             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 202             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 203             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 204                 @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 205                 public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 206                     if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 207                         for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 208                             String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 209                             keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 210                             keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 211                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 212                         try {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 213                             Row row = fillData(inputCopy.f1, keyValue);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 214                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));"> 214                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 215                             resultFuture.complete(Collections.singleton(Tuple2.of(inputCopy.f0, row)));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 216                         } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 217                             dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 218                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 219                     } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 220                         dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 221                         dealCacheData(key, CacheMissVal.getMissKeyObj());</span>
 222 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223         Map&lt;String, String&gt; keyValue = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 224         List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 225         String[] values = value.toArray(new String[value.size()]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 226         if (values.length == 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 227             dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 228         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 229             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 229             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 230             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232                 public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 233                     if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234                         for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 235                             String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 236                             keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 237                             keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 238                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 239                         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 240                             Row row = fillData(inputCopy.row(), keyValue);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 241                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));"> 241                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 242                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));"> 242                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 243                         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 244                             dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 245                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 246                     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 247                         dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 248                         dealCacheData(key, CacheMissVal.getMissKeyObj());</span>
 249 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 250         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 251         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 252             @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 253             public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 254                 if (MapUtils.isNotEmpty(values)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 255                     try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 256                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 257                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 258                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 259                     } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 260                         dealFillDataError(resultFuture, e, inputCopy);</span>
 261 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 262                     }
 263                 } else {
 264                     dealMissKey(inputCopy, resultFuture);
 265                     dealCacheData(key,CacheMissVal.getMissKeyObj());
 266                 }
 267             }
 268         });
 269     }
 270 
 271     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 272         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 273         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 274         for(String primaryKey : primaryKeys){
 275             if(!refData.containsKey(primaryKey)){
 276                 return null;
 277             }
 278             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 279         }
 280         return keyBuilder.toString();
 281     }
 282 
 283     @Override
 284     public void close() throws Exception {
 285         super.close();
 286         if (connection != null){
 287             connection.close();
 288         }
 289         if (redisClient != null){
 290             redisClient.shutdown();
 291         }
 292         if (clusterConnection != null){
 293             clusterConnection.close();
 294         }
 295         if (clusterClient != null){
 296             clusterClient.shutdown();
 297         }
 298     }
 299 
 300 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import org.apache.flink.api.java.tuple.Tuple2;
  24 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  25 import org.apache.flink.configuration.Configuration;
  26 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  27 import org.apache.flink.types.Row;
  28 
  29 import com.dtstack.flink.sql.enums.ECacheContentType;
  30 import com.dtstack.flink.sql.side.CacheMissVal;
  31 import com.dtstack.flink.sql.side.FieldInfo;
  32 import com.dtstack.flink.sql.side.JoinInfo;
  33 import com.dtstack.flink.sql.side.cache.CacheObj;
  34 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  35 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  37 import io.lettuce.core.RedisClient;
  38 import io.lettuce.core.RedisFuture;
  39 import io.lettuce.core.api.StatefulRedisConnection;
  40 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  41 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  42 import io.lettuce.core.cluster.RedisClusterClient;
  43 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  44 import org.apache.commons.collections.MapUtils;
  45 import org.apache.commons.lang.StringUtils;
  46 import com.google.common.collect.Maps;
  47 
  48 import java.util.Collections;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.function.Consumer;
  52 /**
  53  * @author yanxi
  54  */
  55 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  56 
  57     private static final long serialVersionUID = -2079908694523987738L;
  58 
  59     private RedisClient redisClient;
  60 
  61     private StatefulRedisConnection&lt;String, String&gt; connection;
  62 
  63     private RedisClusterClient clusterClient;
  64 
  65     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  66 
  67     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  68 
  69     private RedisSideTableInfo redisSideTableInfo;
  70 
  71     private RedisSideReqRow redisSideReqRow;
  72 
<abbr title="  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  74         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  75         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  76     }
  77 
  78     @Override
  79     public void open(Configuration parameters) throws Exception {
  80         super.open(parameters);
  81         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  82         buildRedisClient(redisSideTableInfo);
  83     }
  84 
  85     private void buildRedisClient(RedisSideTableInfo tableInfo){
  86         String url = redisSideTableInfo.getUrl();
  87         String password = redisSideTableInfo.getPassword();
  88         if (password != null){
  89             password = password + &quot;@&quot;;
  90         } else {
  91             password = &quot;&quot;;
  92         }
  93         String database = redisSideTableInfo.getDatabase();
  94         if (database == null){
  95             database = &quot;0&quot;;
  96         }
  97         switch (RedisType.parse(tableInfo.getRedisType())){
  98             case STANDALONE:
  99                 StringBuilder redisUri = new StringBuilder();
 100                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 101                 redisClient = RedisClient.create(redisUri.toString());
 102                 connection = redisClient.connect();
 103                 async = connection.async();
 104                 break;
 105             case SENTINEL:
 106                 StringBuilder sentinelUri = new StringBuilder();
 107                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 109                 redisClient = RedisClient.create(sentinelUri.toString());
 110                 connection = redisClient.connect();
 111                 async = connection.async();
 112                 break;
 113             case CLUSTER:
 114                 StringBuilder clusterUri = new StringBuilder();
 115                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 116                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 117                 clusterConnection = clusterClient.connect();
 118                 async = clusterConnection.async();
 119             default:
 120                 break;
 121         }
 122     }
 123 
 124     @Override
 125     public Row fillData(Row input, Object sideInput) {
 126         return redisSideReqRow.fillData(input, sideInput);
 127     }
 128 
 129     @Override
 130 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 131     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 131     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) thðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132         Tuple2&lt;Boolean, Row&gt; inputCopy = Tuple2.of(input.f0, input.f1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133         List&lt;String&gt; keyData = Lists.newLinkedList();</span>
 134 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136         CRow inputCopy = new CRow(input.row(),input.change());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137         List&lt;String&gt; keyData = Lists.newLinkedList();</span>
 138 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 139     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 140         CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 141         Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
 142 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 143         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 144             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 145 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146             Object equalObj = inputCopy.f1.getField(conValIndex);</span>
 147 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 148             Object equalObj = inputCopy.row().getField(conValIndex);</span>
 149 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 150             Object equalObj = input.row().getField(conValIndex);</span>
 151 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 152             if(equalObj == null){
 153                 dealMissKey(inputCopy, resultFuture);
 154                 return;
 155             }
 156             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 157         }
 158 
 159         String key = buildCacheKey(refData);
 160         if(StringUtils.isBlank(key)){
 161             return;
 162         }
 163         if(openCache()){
 164             CacheObj val = getFromCache(key);
 165             if(val != null){
 166                 if(ECacheContentType.MissVal == val.getType()){
 167                     dealMissKey(inputCopy, resultFuture);
 168                     return;
 169                 }else if(ECacheContentType.MultiLine == val.getType()){
 170                     try {
 171 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 172                         Row row = fillData(inputCopy.f1, val.getContent());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 173                         resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));</span>
 174 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175                         Row row = fillData(inputCopy.row(), val.getContent());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
 177 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 178                         Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 179                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
 180 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 181                     } catch (Exception e) {
 182                         dealFillDataError(resultFuture, e, inputCopy);
 183                     }
 184                 }else{
<abbr title=" 185                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 185                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + valðŸ”µ</abbr>
 186                     resultFuture.completeExceptionally(exception);
 187                 }
 188                 return;
 189             }
 190         }
 191 
 192         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 193         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 194                 @Override
 195             public void accept(Map&lt;String, String&gt; values) {
 196                 if (MapUtils.isNotEmpty(values)) {
 197                         try {
 198 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 199                             Row row = fillData(inputCopy.f1, keyValue);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 200                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));"> 200                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 201                             resultFuture.complete(Collections.singleton(Tuple2.of(inputCopy.f0, row)));</span>
 202 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 203             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 203             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206                 public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207                     if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208                         for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209                             String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210                             keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211                             keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213                         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214                             Row row = fillData(inputCopy.row(), keyValue);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 215                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));"> 215                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 216                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));"> 216                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())ðŸ”µ</abbr></span>
 217 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 218                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 219                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 220                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
 221 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 222                         } catch (Exception e) {
 223                             dealFillDataError(resultFuture, e, inputCopy);
 224                         }
 225                     } else {
 226                         dealMissKey(inputCopy, resultFuture);
 227                         dealCacheData(key, CacheMissVal.getMissKeyObj());
 228                     }
 229                 }
 230             });
 231         }
 232 
 233     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 234         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 235         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 236         for(String primaryKey : primaryKeys){
 237             if(!refData.containsKey(primaryKey)){
 238                 return null;
 239             }
 240             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 241         }
 242         return keyBuilder.toString();
 243     }
 244 
 245     @Override
 246     public void close() throws Exception {
 247         super.close();
 248         if (connection != null){
 249             connection.close();
 250         }
 251         if (redisClient != null){
 252             redisClient.shutdown();
 253         }
 254         if (clusterConnection != null){
 255             clusterConnection.close();
 256         }
 257         if (clusterClient != null){
 258             clusterClient.shutdown();
 259         }
 260     }
 261 
 262 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.redis;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.dtstack.flink.sql.side.CacheMissVal;
  24 import com.dtstack.flink.sql.side.FieldInfo;
  25 import com.dtstack.flink.sql.side.JoinInfo;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  28 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  29 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  30 import com.google.common.collect.Maps;
  31 import io.lettuce.core.RedisClient;
  32 import io.lettuce.core.RedisFuture;
  33 import io.lettuce.core.api.StatefulRedisConnection;
  34 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  35 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  36 import io.lettuce.core.cluster.RedisClusterClient;
  37 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  38 import java.util.Collections;
  39 import java.util.List;
  40 import java.util.Map;
  41 import java.util.function.Consumer;
  42 import org.apache.commons.collections.MapUtils;
  43 import org.apache.commons.lang.StringUtils;
  44 import org.apache.flink.api.java.tuple.Tuple2;
  45 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  46 import org.apache.flink.configuration.Configuration;
  47 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  48 import org.apache.flink.types.Row;
  49 
  50 
  51 /**
  52  * @author yanxi
  53  */
  54 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  55     private static final long serialVersionUID = -2079908694523987738L;
  56 
  57     private RedisClient redisClient;
  58 
  59     private StatefulRedisConnection&lt;String, String&gt; connection;
  60 
  61     private RedisClusterClient clusterClient;
  62 
  63     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  64 
  65     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  66 
  67     private RedisSideTableInfo redisSideTableInfo;
  68 
  69     private RedisSideReqRow redisSideReqRow;
  70 
<abbr title="  71     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  71     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  72         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  73         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  74     }
  75 
  76     @Override
  77     public void open(Configuration parameters) throws Exception {
  78         super.open(parameters);
  79         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  80         buildRedisClient(redisSideTableInfo);
  81     }
  82 
  83     private void buildRedisClient(RedisSideTableInfo tableInfo) {
  84         String url = redisSideTableInfo.getUrl();
  85         String password = redisSideTableInfo.getPassword();
  86         if (password != null) {
  87             password = password + &quot;@&quot;;
  88         } else {
  89             password = &quot;&quot;;
  90         }
  91         String database = redisSideTableInfo.getDatabase();
  92         if (database == null) {
  93             database = &quot;0&quot;;
  94         }
  95         switch (RedisType.parse(tableInfo.getRedisType())) {
  96             case STANDALONE :
  97                 StringBuilder redisUri = new StringBuilder();
  98                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
  99                 redisClient = RedisClient.create(redisUri.toString());
 100                 connection = redisClient.connect();
 101                 async = connection.async();
 102                 break;
 103             case SENTINEL :
 104                 StringBuilder sentinelUri = new StringBuilder();
<abbr title=" 105                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password).append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 105                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password).append(url).append(&quot;/&quot;).append(dðŸ”µ</abbr>
 106                 redisClient = RedisClient.create(sentinelUri.toString());
 107                 connection = redisClient.connect();
 108                 async = connection.async();
 109                 break;
 110             case CLUSTER :
 111                 StringBuilder clusterUri = new StringBuilder();
 112                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 113                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 114                 clusterConnection = clusterClient.connect();
 115                 async = clusterConnection.async();
 116             default :
 117                 break;
 118         }
 119     }
 120 
 121     @Override
 122     public Row fillData(Row input, Object sideInput) {
 123         return redisSideReqRow.fillData(input, sideInput);
 124     }
 125 
 126     @Override
<abbr title=" 127     public void asyncInvoke(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 127     public void asyncInvoke(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) ðŸ”µ</abbr>
 128         Tuple2&lt;Boolean, Row&gt; inputCopy = Tuple2.of(input.f0, input.f1);
 129         Map&lt;String, Object&gt; refData = Maps.newHashMap();
 130         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 131             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 132             Object equalObj = inputCopy.f1.getField(conValIndex);
 133             if (equalObj == null) {
 134                 dealMissKey(inputCopy, resultFuture);
 135                 return;
 136             }
 137             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 138         }
 139         String key = buildCacheKey(refData);
 140         if (StringUtils.isBlank(key)) {
 141             return;
 142         }
 143         if (openCache()) {
 144             CacheObj val = getFromCache(key);
 145             if (val != null) {
 146                 if (ECacheContentType.MissVal == val.getType()) {
 147                     dealMissKey(inputCopy, resultFuture);
 148                     return;
 149                 } else if (ECacheContentType.MultiLine == val.getType()) {
 150                     try {
 151                         Row row = fillData(inputCopy.f1, val.getContent());
 152                         resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));
 153                     } catch (java.lang.Exception e) {
 154                         dealFillDataError(resultFuture, e, inputCopy);
 155                     }
 156                 } else {
<abbr title=" 157                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 157                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + valðŸ”µ</abbr>
 158                     resultFuture.completeExceptionally(exception);
 159                 }
 160                 return;
 161             }
 162         }
 163         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) (async)).hgetall(key);
 164         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 165             @Override
 166             public void accept(Map&lt;String, String&gt; values) {
 167                 if (MapUtils.isNotEmpty(values)) {
 168                     try {
 169                         Row row = fillData(inputCopy.f1, values);
 170                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
 171                         resultFuture.complete(Collections.singleton(Tuple2.of(inputCopy.f0, row)));
 172                     } catch (java.lang.Exception e) {
 173                         dealFillDataError(resultFuture, e, inputCopy);
 174                     }
 175                 } else {
 176                     dealMissKey(inputCopy, resultFuture);
 177                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 178                 }
 179             }
 180         });
 181     }
 182 
 183     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 184         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 185         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 186         for (String primaryKey : primaryKeys) {
 187             if (!refData.containsKey(primaryKey)) {
 188                 return null;
 189             }
 190             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 191         }
 192         return keyBuilder.toString();
 193     }
 194 
 195     @Override
 196     public void close() throws Exception {
 197         super.close();
 198         if (connection != null){
 199             connection.close();
 200         }
 201         if (redisClient != null){
 202             redisClient.shutdown();
 203         }
 204         if (clusterConnection != null){
 205             clusterConnection.close();
 206         }
 207         if (clusterClient != null){
 208             clusterClient.shutdown();
 209         }
 210     }
 211 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
  21  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import org.apache.flink.api.java.tuple.Tuple2;</span>
  24  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  25  import org.apache.flink.configuration.Configuration;
  26  import org.apache.flink.streaming.api.functions.async.ResultFuture;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import org.apache.flink.table.runtime.types.CRow;</span>
  28  import org.apache.flink.types.Row;
  29  
  30  import com.dtstack.flink.sql.enums.ECacheContentType;
  31  import com.dtstack.flink.sql.side.CacheMissVal;
  32  import com.dtstack.flink.sql.side.FieldInfo;
  33  import com.dtstack.flink.sql.side.JoinInfo;
  34  import com.dtstack.flink.sql.side.cache.CacheObj;

  35  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  37  import com.google.common.collect.Lists;
  38  import com.google.common.collect.Maps;
  39  import io.lettuce.core.KeyValue;
  40  import io.lettuce.core.RedisClient;
  41  import io.lettuce.core.RedisFuture;
  42  import io.lettuce.core.api.StatefulRedisConnection;

  43  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  44  import io.lettuce.core.api.async.RedisStringAsyncCommands;
  45  import io.lettuce.core.cluster.RedisClusterClient;
  46  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  47  import org.apache.commons.lang3.StringUtils;



  48  
  49  import java.util.Collections;
  50  import java.util.List;
  51  import java.util.Map;
  52  import java.util.function.Consumer;
  53  /**
  54   * @author yanxi
  55   */
  56  public class RedisAsyncReqRow extends BaseAsyncReqRow {
  57  
  58      private static final long serialVersionUID = -2079908694523987738L;
  59  
  60      private RedisClient redisClient;
  61  
  62      private StatefulRedisConnection&lt;String, String&gt; connection;
  63  
  64      private RedisClusterClient clusterClient;
  65  
  66      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  67  
  68      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  69  
  70      private RedisSideTableInfo redisSideTableInfo;
  71  
  72      private RedisSideReqRow redisSideReqRow;
  73  
<abbr title="  74      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  74      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  75          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  76          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  77      }
  78  
  79      @Override
  80      public void open(Configuration parameters) throws Exception {
  81          super.open(parameters);
  82          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  83          buildRedisClient(redisSideTableInfo);
  84      }
  85  
  86      private void buildRedisClient(RedisSideTableInfo tableInfo){
  87          String url = redisSideTableInfo.getUrl();
  88          String password = redisSideTableInfo.getPassword();
  89          if (password != null){
  90              password = password + &quot;@&quot;;
  91          } else {
  92              password = &quot;&quot;;
  93          }
  94          String database = redisSideTableInfo.getDatabase();
  95          if (database == null){
  96              database = &quot;0&quot;;
  97          }
  98          switch (tableInfo.getRedisType()){
  99              case 1:


 100                  StringBuilder redisUri = new StringBuilder();
 101                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 102                  redisClient = RedisClient.create(redisUri.toString());
 103                  connection = redisClient.connect();
 104                  async = connection.async();
 105                  break;
 106              case 2:

 107                  StringBuilder sentinelUri = new StringBuilder();
 108                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 109                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 109                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterNðŸ”µ</abbr>
 110                  redisClient = RedisClient.create(sentinelUri.toString());
 111                  connection = redisClient.connect();
 112                  async = connection.async();
 113                  break;
 114              case 3:

 115                  StringBuilder clusterUri = new StringBuilder();
 116                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 117                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 118                  clusterConnection = clusterClient.connect();
 119                  async = clusterConnection.async();
 120              default:

 121          }
 122      }
 123  
 124      @Override
 125      public Row fillData(Row input, Object sideInput) {
 126          return redisSideReqRow.fillData(input, sideInput);
 127      }
 128  
 129      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -    public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -        CRow inputCopy = new CRow(input.row(),input.change());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 132 +    public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 132 +    public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws ExceðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +        Tuple2&lt;Boolean, Row&gt; inputCopy = Tuple2.of(input.f0, input.f1);</span>
 134          List&lt;String&gt; keyData = Lists.newLinkedList();


 135          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 136              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -            Object equalObj = inputCopy.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +            Object equalObj = inputCopy.f1.getField(conValIndex);</span>
 139              if(equalObj == null){
 140                  dealMissKey(inputCopy, resultFuture);
 141                  return;
 142              }
 143              String value = equalObj.toString();
 144              keyData.add(sideInfo.getEqualFieldList().get(i));
 145              keyData.add(value);
 146          }
 147  
 148          String key = buildCacheKey(keyData);
 149  







 150          if(openCache()){
 151              CacheObj val = getFromCache(key);
 152              if(val != null){
 153                  if(ECacheContentType.MissVal == val.getType()){
 154                      dealMissKey(inputCopy, resultFuture);
 155                      return;
 156                  }else if(ECacheContentType.MultiLine == val.getType()){
 157                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -                        Row row = fillData(inputCopy.row(), val.getContent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +                        Row row = fillData(inputCopy.f1, val.getContent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +                        resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));</span>
 162                      } catch (Exception e) {
 163                          dealFillDataError(resultFuture, e, inputCopy);
 164                      }
 165                  }else{
<abbr title=" 166                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 166                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType(ðŸ”µ</abbr>
 167                      resultFuture.completeExceptionally(exception);
 168                  }
 169                  return;
 170              }
 171          }
 172  
 173          Map&lt;String, String&gt; keyValue = Maps.newHashMap();
 174          List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();
 175          String[] values = value.toArray(new String[value.size()]);
 176          if (values.length == 0) {
 177              dealMissKey(inputCopy, resultFuture);
 178          } else {
 179              RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);
 180              future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {
 181                  @Override
 182                  public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {
 183                      if (keyValues.size() != 0) {
 184                          for (int i = 0; i &lt; keyValues.size(); i++) {
 185                              String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);
 186                              keyValue.put(splitKeys[1], splitKeys[2]);
 187                              keyValue.put(splitKeys[3], keyValues.get(i).getValue());
 188                          }
 189                          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -                            Row row = fillData(inputCopy.row(), keyValue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +                            Row row = fillData(inputCopy.f1, keyValue);</span>
 192                              dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -                            resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +                            resultFuture.complete(Collections.singleton(Tuple2.of(inputCopy.f0, row)));</span>
 195                          } catch (Exception e) {
 196                              dealFillDataError(resultFuture, e, inputCopy);
 197                          }
 198                      } else {
 199                          dealMissKey(inputCopy, resultFuture);
 200                          dealCacheData(key, CacheMissVal.getMissKeyObj());











 201                      }



 202                  }
 203              });
 204          }
 205      }
 206  
 207      private String buildCacheKey(List&lt;String&gt; keyData) {
 208          String kv = String.join(&quot;:&quot;, keyData);
 209          String tableName = redisSideTableInfo.getTableName();
 210          StringBuilder preKey =  new StringBuilder();
 211          preKey.append(tableName).append(&quot;:&quot;).append(kv);
 212          return preKey.toString();














 213      }
 214  
 215      @Override
 216      public void close() throws Exception {
 217          super.close();
 218          if (connection != null){
 219              connection.close();
 220          }
 221          if (redisClient != null){
 222              redisClient.shutdown();
 223          }
 224          if (clusterConnection != null){
 225              clusterConnection.close();
 226          }
 227          if (clusterClient != null){
 228              clusterClient.shutdown();
 229          }
 230      }
 231  
 232  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
  21  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22  import com.dtstack.flink.sql.side.BaseAsyncReqRow;

  23  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  24  import org.apache.flink.configuration.Configuration;
  25  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  26  import org.apache.flink.table.runtime.types.CRow;
  27  import org.apache.flink.types.Row;
  28  
  29  import com.dtstack.flink.sql.enums.ECacheContentType;
  30  import com.dtstack.flink.sql.side.CacheMissVal;
  31  import com.dtstack.flink.sql.side.FieldInfo;
  32  import com.dtstack.flink.sql.side.JoinInfo;
  33  import com.dtstack.flink.sql.side.cache.CacheObj;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import com.dtstack.flink.sql.side.redis.enums.RedisType;</span>
  35  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  38 -import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import io.lettuce.core.KeyValue;</span>
  40  import io.lettuce.core.RedisClient;
  41  import io.lettuce.core.RedisFuture;
  42  import io.lettuce.core.api.StatefulRedisConnection;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  43 +import io.lettuce.core.api.async.RedisHashAsyncCommands;</span>
  44  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -import io.lettuce.core.api.async.RedisStringAsyncCommands;</span>
  46  import io.lettuce.core.cluster.RedisClusterClient;
  47  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import org.apache.commons.lang3.StringUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import org.apache.commons.collections.MapUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import org.apache.commons.lang.StringUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +import com.google.common.collect.Maps;</span>
  52  
  53  import java.util.Collections;
  54  import java.util.List;
  55  import java.util.Map;
  56  import java.util.function.Consumer;
  57  /**
  58   * @author yanxi
  59   */
  60  public class RedisAsyncReqRow extends BaseAsyncReqRow {
  61  
  62      private static final long serialVersionUID = -2079908694523987738L;
  63  
  64      private RedisClient redisClient;
  65  
  66      private StatefulRedisConnection&lt;String, String&gt; connection;
  67  
  68      private RedisClusterClient clusterClient;
  69  
  70      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  71  
  72      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  73  
  74      private RedisSideTableInfo redisSideTableInfo;
  75  
  76      private RedisSideReqRow redisSideReqRow;
  77  
<abbr title="  78      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  78      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  79          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  80          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  81      }
  82  
  83      @Override
  84      public void open(Configuration parameters) throws Exception {
  85          super.open(parameters);
  86          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  87          buildRedisClient(redisSideTableInfo);
  88      }
  89  
  90      private void buildRedisClient(RedisSideTableInfo tableInfo){
  91          String url = redisSideTableInfo.getUrl();
  92          String password = redisSideTableInfo.getPassword();
  93          if (password != null){
  94              password = password + &quot;@&quot;;
  95          } else {
  96              password = &quot;&quot;;
  97          }
  98          String database = redisSideTableInfo.getDatabase();
  99          if (database == null){
 100              database = &quot;0&quot;;
 101          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -        switch (tableInfo.getRedisType()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -            case 1:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +        switch (RedisType.parse(tableInfo.getRedisType())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +            case STANDALONE:</span>
 106                  StringBuilder redisUri = new StringBuilder();
 107                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 108                  redisClient = RedisClient.create(redisUri.toString());
 109                  connection = redisClient.connect();
 110                  async = connection.async();
 111                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -            case 2:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +            case SENTINEL:</span>
 114                  StringBuilder sentinelUri = new StringBuilder();
 115                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 116                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 116                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterNðŸ”µ</abbr>
 117                  redisClient = RedisClient.create(sentinelUri.toString());
 118                  connection = redisClient.connect();
 119                  async = connection.async();
 120                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 121 -            case 3:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +            case CLUSTER:</span>
 123                  StringBuilder clusterUri = new StringBuilder();
 124                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 125                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 126                  clusterConnection = clusterClient.connect();
 127                  async = clusterConnection.async();
 128              default:
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +                break;</span>
 130          }
 131      }
 132  
 133      @Override
 134      public Row fillData(Row input, Object sideInput) {
 135          return redisSideReqRow.fillData(input, sideInput);
 136      }
 137  
 138      @Override
 139      public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -        CRow inputCopy = new CRow(input.row(),input.change());</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -        List&lt;String&gt; keyData = Lists.newLinkedList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +        CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +        Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
 144          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 145              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -            Object equalObj = inputCopy.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +            Object equalObj = input.row().getField(conValIndex);</span>
 148              if(equalObj == null){
 149                  dealMissKey(inputCopy, resultFuture);
 150                  return;
 151              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -            String value = equalObj.toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -            keyData.add(sideInfo.getEqualFieldList().get(i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -            keyData.add(value);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -        String key = buildCacheKey(keyData);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +            refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +        String key = buildCacheKey(refData);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +        if(StringUtils.isBlank(key)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +        }</span>
 166          if(openCache()){
 167              CacheObj val = getFromCache(key);
 168              if(val != null){
 169                  if(ECacheContentType.MissVal == val.getType()){
 170                      dealMissKey(inputCopy, resultFuture);
 171                      return;
 172                  }else if(ECacheContentType.MultiLine == val.getType()){
 173                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 174 -                        Row row = fillData(inputCopy.row(), val.getContent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 175 -                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +                        Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +                        resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
 178                      } catch (Exception e) {
 179                          dealFillDataError(resultFuture, e, inputCopy);
 180                      }
 181                  }else{
<abbr title=" 182                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 182                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType(ðŸ”µ</abbr>
 183                      resultFuture.completeExceptionally(exception);
 184                  }
 185                  return;
 186              }
 187          }
 188  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -        Map&lt;String, String&gt; keyValue = Maps.newHashMap();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -        List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -        String[] values = value.toArray(new String[value.size()]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 192 -        if (values.length == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -            dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 194 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -            RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -            future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -                public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -                    if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -                        for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -                            String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -                            keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -                            keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -                        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -                            Row row = fillData(inputCopy.row(), keyValue);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -                            dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -                            resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -                        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 210 -                            dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 211 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -                    } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -                        dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 214 -                        dealCacheData(key, CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +        RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +        future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +            public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +                if (MapUtils.isNotEmpty(values)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +                        Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +                        resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +                    } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +                        dealFillDataError(resultFuture, e, inputCopy);</span>
 226                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +                    dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +                    dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
 230                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -    private String buildCacheKey(List&lt;String&gt; keyData) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -        String kv = String.join(&quot;:&quot;, keyData);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 237 -        String tableName = redisSideTableInfo.getTableName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -        StringBuilder preKey =  new StringBuilder();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -        preKey.append(tableName).append(&quot;:&quot;).append(kv);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -        return preKey.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +    private String buildCacheKey(Map&lt;String, Object&gt; refData) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +        StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +        List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +        for(String primaryKey : primaryKeys){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +            if(!refData.containsKey(primaryKey)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +                return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +            keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +        return keyBuilder.toString();</span>
 255      }
 256  
 257      @Override
 258      public void close() throws Exception {
 259          super.close();
 260          if (connection != null){
 261              connection.close();
 262          }
 263          if (redisClient != null){
 264              redisClient.shutdown();
 265          }
 266          if (clusterConnection != null){
 267              clusterConnection.close();
 268          }
 269          if (clusterClient != null){
 270              clusterClient.shutdown();
 271          }
 272      }
 273  
 274  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            