<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>572</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    572
                    <a href="571.html">prev</a>
                    <a href="573.html">next</a>
                    <a href="572_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_d3f904d1d764e0acb7127ddbeb050c2b3ff060b3_core/src/main/java/com/dtstack/flink/sql/exec/ExecuteProcessHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3:core/src/main/java/com/dtstack/flink/sql/exec/ExecuteProcessHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3^1:core/src/main/java/com/dtstack/flink/sql/exec/ExecuteProcessHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3^2:core/src/main/java/com/dtstack/flink/sql/exec/ExecuteProcessHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d124305ffe07b66f8eee430b3c0ac1072281dc14:core/src/main/java/com/dtstack/flink/sql/exec/ExecuteProcessHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [b]], subset: [[bj], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.exec;
  20 
  21 import com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;
  22 import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  23 import com.dtstack.flink.sql.config.CalciteConfig;
  24 import com.dtstack.flink.sql.constrant.ConfigConstrant;
  25 import com.dtstack.flink.sql.enums.ClusterMode;
  26 import com.dtstack.flink.sql.enums.ECacheType;
  27 import com.dtstack.flink.sql.enums.EPluginLoadMode;
  28 import com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;
  29 import com.dtstack.flink.sql.environment.StreamEnvConfigManager;
  30 import com.dtstack.flink.sql.function.FunctionManager;
  31 import com.dtstack.flink.sql.option.OptionParser;
  32 import com.dtstack.flink.sql.option.Options;
  33 import com.dtstack.flink.sql.parser.CreateFuncParser;
  34 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  35 import com.dtstack.flink.sql.parser.InsertSqlParser;
  36 import com.dtstack.flink.sql.parser.SqlParser;
  37 import com.dtstack.flink.sql.parser.SqlTree;
  38 import com.dtstack.flink.sql.side.SideSqlExec;
  39 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  40 import com.dtstack.flink.sql.sink.StreamSinkFactory;
  41 import com.dtstack.flink.sql.source.StreamSourceFactory;
  42 import com.dtstack.flink.sql.table.AbstractSourceTableInfo;
  43 import com.dtstack.flink.sql.table.AbstractTableInfo;
  44 import com.dtstack.flink.sql.table.AbstractTargetTableInfo;
  45 import com.dtstack.flink.sql.util.DtStringUtil;
  46 import com.dtstack.flink.sql.util.PluginUtil;
  47 import com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;
  48 import com.fasterxml.jackson.databind.ObjectMapper;
  49 import com.google.common.base.Preconditions;
  50 import com.google.common.base.Strings;
  51 import com.google.common.collect.Lists;
  52 import com.google.common.collect.Maps;
  53 import com.google.common.collect.Sets;
  54 import org.apache.calcite.sql.SqlInsert;
  55 import org.apache.calcite.sql.SqlNode;
  56 import org.apache.commons.io.Charsets;
  57 import org.apache.commons.lang3.StringUtils;
  58 import org.apache.flink.api.common.typeinfo.TypeInformation;
  59 import org.apache.flink.api.java.tuple.Tuple2;
  60 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  61 import org.apache.flink.streaming.api.datastream.DataStream;
  62 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  63 import org.apache.flink.table.api.EnvironmentSettings;
  64 import org.apache.flink.table.api.Table;
  65 import org.apache.flink.table.api.TableEnvironment;
  66 import org.apache.flink.table.api.java.StreamTableEnvironment;
  67 import org.apache.flink.table.sinks.TableSink;
  68 import org.apache.flink.types.Row;
  69 import org.slf4j.Logger;
  70 import org.slf4j.LoggerFactory;
  71 
  72 import java.io.File;
  73 import java.lang.reflect.InvocationTargetException;
  74 import java.net.URL;
  75 import java.net.URLClassLoader;
  76 import java.net.URLDecoder;
  77 import java.util.Arrays;
  78 import java.util.List;
  79 import java.util.Map;
  80 import java.util.Properties;
  81 import java.util.Set;
  82 
  83 /**
  84  *  ‰ªªÂä°ÊâßË°åÊó∂ÁöÑÊµÅÁ®ãÊñπÊ≥ï
  85  * Date: 2020/2/17
  86  * Company: www.dtstack.com
  87  * @author maqi
  88  */
  89 public class ExecuteProcessHelper {
  90 
  91     private static final String CLASS_FILE_NAME_FMT = &quot;class_path_%d&quot;;
  92     private static final Logger LOG = LoggerFactory.getLogger(ExecuteProcessHelper.class);
  93     private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  94 
  95 
  96     public static ParamsInfo parseParams(String[] args) throws Exception {
  97         LOG.info(&quot;------------program params-------------------------&quot;);
  98         Arrays.stream(args).forEach(arg -&gt; LOG.info(&quot;{}&quot;, arg));
  99         LOG.info(&quot;-------------------------------------------&quot;);
 100 
 101         OptionParser optionParser = new OptionParser(args);
 102         Options options = optionParser.getOptions();
 103 
 104         String sql = URLDecoder.decode(options.getSql(), Charsets.UTF_8.name());
 105         String name = options.getName();
 106         String localSqlPluginPath = options.getLocalSqlPluginPath();
 107         String remoteSqlPluginPath = options.getRemoteSqlPluginPath();
 108         String pluginLoadMode = options.getPluginLoadMode();
 109         String deployMode = options.getMode();
 110         String logLevel = options.getLogLevel();
 111 
<abbr title=" 112         Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, deployMode, pluginLoadMode),"> 112         Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, deployMode, pluginLoadMüîµ</abbr>
 113                 &quot;Non-local mode or shipfile deployment mode, remoteSqlPluginPath is required&quot;);
 114         String confProp = URLDecoder.decode(options.getConfProp(), Charsets.UTF_8.toString());
 115         Properties confProperties = PluginUtil.jsonStrToObject(confProp, Properties.class);
 116 
 117         List&lt;URL&gt; jarUrlList = getExternalJarUrls(options.getAddjar());
 118 
 119         return ParamsInfo.builder()
 120                 .setSql(sql)
 121                 .setName(name)
 122                 .setLocalSqlPluginPath(localSqlPluginPath)
 123                 .setRemoteSqlPluginPath(remoteSqlPluginPath)
 124                 .setPluginLoadMode(pluginLoadMode)
 125                 .setDeployMode(deployMode)
 126                 .setConfProp(confProperties)
 127                 .setJarUrlList(jarUrlList)
 128                 .build();
 129 
 130     }
 131 
 132     /**
 133      *   ÈùûlocalÊ®°ÂºèÊàñËÄÖshipfileÈÉ®ÁΩ≤Ê®°ÂºèÔºåremoteSqlPluginPathÂøÖÂ°´
 134      * @param remoteSqlPluginPath
 135      * @param deployMode
 136      * @param pluginLoadMode
 137      * @return
 138      */
<abbr title=" 139     public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String pluginLoadMode) {"> 139     public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String üîµ</abbr>
 140         if (StringUtils.isEmpty(remoteSqlPluginPath)) {
 141             return StringUtils.equalsIgnoreCase(pluginLoadMode, EPluginLoadMode.SHIPFILE.name())
 142                     || StringUtils.equalsIgnoreCase(deployMode, ClusterMode.local.name());
 143         }
 144         return true;
 145     }
 146 
 147 
 148     public static StreamExecutionEnvironment getStreamExecution(ParamsInfo paramsInfo) throws Exception {
<abbr title=" 149         StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), paramsInfo.getDeployMode());"> 149         StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), püîµ</abbr>
 150         StreamTableEnvironment tableEnv = getStreamTableEnv(env,paramsInfo.getConfProp());
 151 
 152         SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());
 153         SqlTree sqlTree = SqlParser.parseSql(paramsInfo.getSql());
 154 
 155         Map&lt;String, AbstractSideTableInfo&gt; sideTableMap = Maps.newHashMap();
 156         Map&lt;String, Table&gt; registerTableCache = Maps.newHashMap();
 157 
 158         //register udf
 159         ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, paramsInfo.getJarUrlList(), tableEnv);
 160         //register table schema
<abbr title=" 161         Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.getLocalSqlPluginPath(),"> 161         Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.geüîµ</abbr>
<abbr title=" 162                 paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registerTableCache);"> 162                 paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registüîµ</abbr>
 163         // cache classPathSets
 164         ExecuteProcessHelper.registerPluginUrlToCachedFile(env, classPathSets);
 165 
<abbr title=" 166         ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, registerTableCache);"> 166         ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTaüîµ</abbr>
 167 
 168         if (env instanceof MyLocalStreamEnvironment) {
 169             ((MyLocalStreamEnvironment) env).setClasspaths(ClassLoaderManager.getClassPath());
 170         }
 171         return env;
 172     }
 173 
 174 
 175     public static List&lt;URL&gt; getExternalJarUrls(String addJarListStr) throws java.io.IOException {
 176         List&lt;URL&gt; jarUrlList = Lists.newArrayList();
 177         if (Strings.isNullOrEmpty(addJarListStr)) {
 178             return jarUrlList;
 179         }
 180 
<abbr title=" 181         List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.UTF_8.name()), List.class);"> 181         List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.Uüîµ</abbr>
 182         //Get External jar to load
 183         for (String addJarPath : addJarFileList) {
 184             jarUrlList.add(new File(addJarPath).toURI().toURL());
 185         }
 186         return jarUrlList;
 187     }
 188 
 189     private static void sqlTranslation(String localSqlPluginPath,
 190                                        StreamTableEnvironment tableEnv,
 191                                        SqlTree sqlTree,Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 192                                        Map&lt;String, Table&gt; registerTableCache) throws Exception {
 193 
 194         SideSqlExec sideSqlExec = new SideSqlExec();
 195         sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);
 196         for (CreateTmpTableParser.SqlParserResult result : sqlTree.getTmpSqlList()) {
 197             sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, result);
 198         }
 199 
 200         for (InsertSqlParser.SqlParseResult result : sqlTree.getExecSqlList()) {
 201             if (LOG.isInfoEnabled()) {
 202                 LOG.info(&quot;exe-sql:\n&quot; + result.getExecSql());
 203             }
 204             boolean isSide = false;
 205             for (String tableName : result.getTargetTableList()) {
 206                 if (sqlTree.getTmpTableMap().containsKey(tableName)) {
 207                     CreateTmpTableParser.SqlParserResult tmp = sqlTree.getTmpTableMap().get(tableName);
 208                     String realSql = DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &quot;`&quot;, &quot;&quot;);
 209 
<abbr title=" 210                     SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();"> 210                     SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfüîµ</abbr>
 211                     String tmpSql = ((SqlInsert) sqlNode).getSource().toString();
 212                     tmp.setExecSql(tmpSql);
 213                     sideSqlExec.exec(tmp.getExecSql(), sideTableMap, tableEnv, registerTableCache, tmp);
 214                 } else {
 215                     for (String sourceTable : result.getSourceTableList()) {
 216                         if (sideTableMap.containsKey(sourceTable)) {
 217                             isSide = true;
 218                             break;
 219                         }
 220                     }
 221                     if (isSide) {
 222                         //sql-dimensional table contains the dimension table of execution
<abbr title=" 223                         sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, null);"> 223                         sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache,üîµ</abbr>
 224                     } else {
 225 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 226                         System.out.println(&quot;----------exec sql without dimension join-----------&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 227                         System.out.println(&quot;----------real sql exec is--------------------------&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 228                         System.out.println(result.getExecSql());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 229                         FlinkSQLExec.sqlUpdate(tableEnv, result.getExecSql());</span>
 230 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231                     if (isSide) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232                         //sql-dimensional table contains the dimension table of execution</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 233                         sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, null);"> 233                         sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache,üîµ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234                     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 235                         System.out.println(&quot;----------exec sql without dimension join-----------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 236                         System.out.println(&quot;----------real sql exec is--------------------------&quot;);</span>
 237 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 238                         LOG.info(&quot;----------exec sql without dimension join-----------&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 239                         LOG.info(&quot;----------real sql exec is--------------------------\n{}&quot;, result.getExecSql());"> 239                         LOG.info(&quot;----------real sql exec is--------------------------\n{}&quot;, result.getExüîµ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 240                         FlinkSQLExec.sqlUpdate(tableEnv, result.getExecSql(), queryConfig);</span>
 241 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 242                         if (LOG.isInfoEnabled()) {
 243                             LOG.info(&quot;exec sql: &quot; + result.getExecSql());
 244                         }
 245                     }
 246                 }
 247             }
 248         }
 249     }
 250 
<abbr title=" 251     public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)"> 251     public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironmenüîµ</abbr>
 252             throws IllegalAccessException, InvocationTargetException {
 253         // udfÂíåtableEnvÈ°ªÁî±Âêå‰∏Ä‰∏™Á±ªÂä†ËΩΩÂô®Âä†ËΩΩ
 254         ClassLoader levelClassLoader = tableEnv.getClass().getClassLoader();
 255         URLClassLoader classLoader = null;
 256         List&lt;CreateFuncParser.SqlParserResult&gt; funcList = sqlTree.getFunctionList();
 257         for (CreateFuncParser.SqlParserResult funcInfo : funcList) {
 258             //classloader
 259             if (classLoader == null) {
<abbr title=" 260                 classLoader = ClassLoaderManager.loadExtraJar(jarUrlList, (URLClassLoader) levelClassLoader);"> 260                 classLoader = ClassLoaderManager.loadExtraJar(jarUrlList, (URLClassLoader) levelClassLoadüîµ</abbr>
 261             }
<abbr title=" 262             FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), tableEnv, classLoader);"> 262             FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), üîµ</abbr>
 263         }
 264     }
 265 
 266     /**
 267      *    ÂêëFlinkÊ≥®ÂÜåÊ∫êË°®ÂíåÁªìÊûúË°®ÔºåËøîÂõûÊâßË°åÊó∂Êèí‰ª∂ÂåÖÁöÑÂÖ®Ë∑ØÂæÑ
 268      * @param sqlTree
 269      * @param env
 270      * @param tableEnv
 271      * @param localSqlPluginPath
 272      * @param remoteSqlPluginPath
 273      * @param pluginLoadMode   Êèí‰ª∂Âä†ËΩΩÊ®°Âºè classpath or shipfile
 274      * @param sideTableMap
 275      * @param registerTableCache
 276      * @return
 277      * @throws Exception
 278      */
<abbr title=" 279     public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnvironment tableEnv, String localSqlPluginPath,"> 279     public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnviüîµ</abbr>
<abbr title=" 280                                          String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, Map&lt;String, Table&gt; registerTableCache) throws Exception {"> 280                                          String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, Aüîµ</abbr>
 281         Set&lt;URL&gt; pluginClassPatshSets = Sets.newHashSet();
 282         WaterMarkerAssigner waterMarkerAssigner = new WaterMarkerAssigner();
 283         for (AbstractTableInfo tableInfo : sqlTree.getTableInfoMap().values()) {
 284 
 285             if (tableInfo instanceof AbstractSourceTableInfo) {
 286 
 287                 AbstractSourceTableInfo sourceTableInfo = (AbstractSourceTableInfo) tableInfo;
<abbr title=" 288                 Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqlPluginPath);"> 288                 Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqüîµ</abbr>
 289                 tableEnv.registerTable(sourceTableInfo.getAdaptName(), table);
<abbr title=" 290                 //Note --- parameter conversion function can not be used inside a function of the type of polymerization"> 290                 //Note --- parameter conversion function can not be used inside a function of the type ofüîµ</abbr>
 291                 //Create table in which the function is arranged only need adaptation sql
 292                 String adaptSql = sourceTableInfo.getAdaptSelectSql();
 293                 Table adaptTable = adaptSql == null ? table : tableEnv.sqlQuery(adaptSql);
 294 
<abbr title=" 295                 RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTable.getSchema().getFieldNames());"> 295                 RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTableüîµ</abbr>
 296                 DataStream adaptStream = tableEnv.toAppendStream(adaptTable, typeInfo);
 297 
 298                 String fields = String.join(&quot;,&quot;, typeInfo.getFieldNames());
 299 
 300                 if (waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) {
<abbr title=" 301                     adaptStream = waterMarkerAssigner.assignWaterMarker(adaptStream, typeInfo, sourceTableInfo);"> 301                     adaptStream = waterMarkerAssigner.assignWaterMarker(adaptStream, typeInfo, sourceTablüîµ</abbr>
 302                     fields += &quot;,ROWTIME.ROWTIME&quot;;
 303                 } else {
 304                     fields += &quot;,PROCTIME.PROCTIME&quot;;
 305                 }
 306 
 307                 Table regTable = tableEnv.fromDataStream(adaptStream, fields);
 308                 tableEnv.registerTable(tableInfo.getName(), regTable);
 309                 if (LOG.isInfoEnabled()) {
 310                     LOG.info(&quot;registe table {} success.&quot;, tableInfo.getName());
 311                 }
 312                 registerTableCache.put(tableInfo.getName(), regTable);
 313 
<abbr title=" 314                 URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractSourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 314                 URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(),üîµ</abbr>
 315                 pluginClassPatshSets.add(sourceTablePathUrl);
 316             } else if (tableInfo instanceof AbstractTargetTableInfo) {
 317 
<abbr title=" 318                 TableSink tableSink = StreamSinkFactory.getTableSink((AbstractTargetTableInfo) tableInfo, localSqlPluginPath);"> 318                 TableSink tableSink = StreamSinkFactory.getTableSink((AbstractTargetTableInfo) tableInfo,üîµ</abbr>
<abbr title=" 319                 TypeInformation[] flinkTypes = FunctionManager.transformTypes(tableInfo.getFieldClasses());"> 319                 TypeInformation[] flinkTypes = FunctionManager.transformTypes(tableInfo.getFieldClasses()üîµ</abbr>
<abbr title=" 320                 tableEnv.registerTableSink(tableInfo.getName(), tableInfo.getFields(), flinkTypes, tableSink);"> 320                 tableEnv.registerTableSink(tableInfo.getName(), tableInfo.getFields(), flinkTypes, tableSüîµ</abbr>
 321 
<abbr title=" 322                 URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractTargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 322                 URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), Aüîµ</abbr>
 323                 pluginClassPatshSets.add(sinkTablePathUrl);
 324             } else if (tableInfo instanceof AbstractSideTableInfo) {
<abbr title=" 325                 String sideOperator = ECacheType.ALL.name().equals(((AbstractSideTableInfo) tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;"> 325                 String sideOperator = ECacheType.ALL.name().equals(((AbstractSideTableInfo) tableInfo).geüîµ</abbr>
 326                 sideTableMap.put(tableInfo.getName(), (AbstractSideTableInfo) tableInfo);
 327 
<abbr title=" 328                 URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperator, AbstractSideTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 328                 URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperatüîµ</abbr>
 329                 pluginClassPatshSets.add(sideTablePathUrl);
 330             } else {
 331                 throw new RuntimeException(&quot;not support table type:&quot; + tableInfo.getType());
 332             }
 333         }
 334         return pluginClassPatshSets;
 335     }
 336 
 337     /**
 338      *   perjobÊ®°ÂºèÂ∞Üjob‰æùËµñÁöÑÊèí‰ª∂ÂåÖË∑ØÂæÑÂ≠òÂÇ®Âà∞cacheFileÔºåÂú®Â§ñÂõ¥Â∞ÜÊèí‰ª∂ÂåÖË∑ØÂæÑ‰º†ÈÄíÁªôjobgraph
 339      * @param env
 340      * @param classPathSet
 341      */
<abbr title=" 342     public static void registerPluginUrlToCachedFile(StreamExecutionEnvironment env, Set&lt;URL&gt; classPathSet) {"> 342     public static void registerPluginUrlToCachedFile(StreamExecutionEnvironment env, Set&lt;URL&gt; classPathSeüîµ</abbr>
 343         int i = 0;
 344         for (URL url : classPathSet) {
 345             String classFileName = String.format(CLASS_FILE_NAME_FMT, i);
 346             env.registerCachedFile(url.getPath(), classFileName, true);
 347             i++;
 348         }
 349     }
 350 
<abbr title=" 351     public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployMode) throws Exception {"> 351     public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployModeüîµ</abbr>
 352         StreamExecutionEnvironment env = !ClusterMode.local.name().equals(deployMode) ?
 353                 StreamExecutionEnvironment.getExecutionEnvironment() :
 354                 new MyLocalStreamEnvironment();
 355 
 356         StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, confProperties);
 357         return env;
 358     }
 359 
 360 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 361     private static StreamTableEnvironment getStreamTableEnv(StreamExecutionEnvironment env, Properties confProperties) {"> 361     private static StreamTableEnvironment getStreamTableEnv(StreamExecutionEnvironment env, Properties coüîµ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 362         // use blink and streammode</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 363         EnvironmentSettings settings = EnvironmentSettings.newInstance()</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 364                 .useBlinkPlanner()</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 365                 .inStreamingMode()</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 366                 .build();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 367 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 368         StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env, settings);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 369         StreamEnvConfigManager.streamTableEnvironmentStateTTLConfig(tableEnv, confProperties);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 370         return tableEnv;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 371     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 372 </span>
 373 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 374                 new MyLocalStreamEnvironment();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 375 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 376         StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, confProperties);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 377         return env;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 378     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 379 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 380     public static void setLogLevel(ParamsInfo paramsInfo){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 381         String logLevel = paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 382         if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 383             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 384         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 385         ChangeLogLevelProcess logLevelProcess = new ChangeLogLevelProcess();</span>
 386 =======
 387 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 388 
 389     public static void setLogLevel(ParamsInfo paramsInfo){
 390         String logLevel = paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);
 391         if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){
 392             return;
 393         }
 394         ChangeLogLevelProcess logLevelProcess = new ChangeLogLevelProcess();
 395         logLevelProcess.process(logLevel);
 396     }
 397 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.exec;
  20 
  21 import com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;
  22 import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  23 import com.dtstack.flink.sql.config.CalciteConfig;
  24 import com.dtstack.flink.sql.constrant.ConfigConstrant;
  25 import com.dtstack.flink.sql.enums.ClusterMode;
  26 import com.dtstack.flink.sql.enums.ECacheType;
  27 import com.dtstack.flink.sql.enums.EPluginLoadMode;
  28 import com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;
  29 import com.dtstack.flink.sql.environment.StreamEnvConfigManager;
  30 import com.dtstack.flink.sql.function.FunctionManager;
  31 import com.dtstack.flink.sql.option.OptionParser;
  32 import com.dtstack.flink.sql.option.Options;
  33 import com.dtstack.flink.sql.parser.CreateFuncParser;
  34 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  35 import com.dtstack.flink.sql.parser.InsertSqlParser;
  36 import com.dtstack.flink.sql.parser.SqlParser;
  37 import com.dtstack.flink.sql.parser.SqlTree;
  38 import com.dtstack.flink.sql.side.SideSqlExec;
  39 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  40 import com.dtstack.flink.sql.sink.StreamSinkFactory;
  41 import com.dtstack.flink.sql.source.StreamSourceFactory;
  42 import com.dtstack.flink.sql.table.AbstractSourceTableInfo;
  43 import com.dtstack.flink.sql.table.AbstractTableInfo;
  44 import com.dtstack.flink.sql.table.AbstractTargetTableInfo;
  45 import com.dtstack.flink.sql.util.DtStringUtil;
  46 import com.dtstack.flink.sql.util.PluginUtil;
  47 import com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;
  48 import com.fasterxml.jackson.databind.ObjectMapper;
  49 import com.google.common.base.Preconditions;
  50 import com.google.common.base.Strings;
  51 import com.google.common.collect.Lists;
  52 import com.google.common.collect.Maps;
  53 import com.google.common.collect.Sets;
  54 import org.apache.calcite.sql.SqlInsert;
  55 import org.apache.calcite.sql.SqlNode;
  56 import org.apache.commons.io.Charsets;
  57 import org.apache.commons.lang3.StringUtils;
  58 import org.apache.flink.api.common.typeinfo.TypeInformation;
  59 import org.apache.flink.api.java.tuple.Tuple2;
  60 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  61 import org.apache.flink.streaming.api.datastream.DataStream;
  62 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  63 import org.apache.flink.table.api.EnvironmentSettings;
  64 import org.apache.flink.table.api.Table;
  65 import org.apache.flink.table.api.TableEnvironment;
  66 import org.apache.flink.table.api.java.StreamTableEnvironment;
  67 import org.apache.flink.table.sinks.TableSink;
  68 import org.apache.flink.types.Row;
  69 import org.slf4j.Logger;
  70 import org.slf4j.LoggerFactory;
  71 
  72 import java.io.File;
  73 import java.lang.reflect.InvocationTargetException;
  74 import java.net.URL;
  75 import java.net.URLClassLoader;
  76 import java.net.URLDecoder;
  77 import java.util.Arrays;
  78 import java.util.List;
  79 import java.util.Map;
  80 import java.util.Properties;
  81 import java.util.Set;
  82 
  83 /**
  84  *  ‰ªªÂä°ÊâßË°åÊó∂ÁöÑÊµÅÁ®ãÊñπÊ≥ï
  85  * Date: 2020/2/17
  86  * Company: www.dtstack.com
  87  * @author maqi
  88  */
  89 public class ExecuteProcessHelper {
  90 
  91     private static final String CLASS_FILE_NAME_FMT = &quot;class_path_%d&quot;;
  92     private static final Logger LOG = LoggerFactory.getLogger(ExecuteProcessHelper.class);
  93     private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  94 
  95 
  96     public static ParamsInfo parseParams(String[] args) throws Exception {
  97         LOG.info(&quot;------------program params-------------------------&quot;);
  98         Arrays.stream(args).forEach(arg -&gt; LOG.info(&quot;{}&quot;, arg));
  99         LOG.info(&quot;-------------------------------------------&quot;);
 100 
 101         OptionParser optionParser = new OptionParser(args);
 102         Options options = optionParser.getOptions();
 103 
 104         String sql = URLDecoder.decode(options.getSql(), Charsets.UTF_8.name());
 105         String name = options.getName();
 106         String localSqlPluginPath = options.getLocalSqlPluginPath();
 107         String remoteSqlPluginPath = options.getRemoteSqlPluginPath();
 108         String pluginLoadMode = options.getPluginLoadMode();
 109         String deployMode = options.getMode();
 110         String logLevel = options.getLogLevel();
 111 
<abbr title=" 112         Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, deployMode, pluginLoadMode),"> 112         Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, deployMode, pluginLoadMüîµ</abbr>
 113                 &quot;Non-local mode or shipfile deployment mode, remoteSqlPluginPath is required&quot;);
 114         String confProp = URLDecoder.decode(options.getConfProp(), Charsets.UTF_8.toString());
 115         Properties confProperties = PluginUtil.jsonStrToObject(confProp, Properties.class);
 116 
 117         List&lt;URL&gt; jarUrlList = getExternalJarUrls(options.getAddjar());
 118 
 119         return ParamsInfo.builder()
 120                 .setSql(sql)
 121                 .setName(name)
 122                 .setLocalSqlPluginPath(localSqlPluginPath)
 123                 .setRemoteSqlPluginPath(remoteSqlPluginPath)
 124                 .setPluginLoadMode(pluginLoadMode)
 125                 .setDeployMode(deployMode)
 126                 .setConfProp(confProperties)
 127                 .setJarUrlList(jarUrlList)
 128                 .build();
 129 
 130     }
 131 
 132     /**
 133      *   ÈùûlocalÊ®°ÂºèÊàñËÄÖshipfileÈÉ®ÁΩ≤Ê®°ÂºèÔºåremoteSqlPluginPathÂøÖÂ°´
 134      * @param remoteSqlPluginPath
 135      * @param deployMode
 136      * @param pluginLoadMode
 137      * @return
 138      */
<abbr title=" 139     public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String pluginLoadMode) {"> 139     public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String üîµ</abbr>
 140         if (StringUtils.isEmpty(remoteSqlPluginPath)) {
 141             return StringUtils.equalsIgnoreCase(pluginLoadMode, EPluginLoadMode.SHIPFILE.name())
 142                     || StringUtils.equalsIgnoreCase(deployMode, ClusterMode.local.name());
 143         }
 144         return true;
 145     }
 146 
 147 
 148     public static StreamExecutionEnvironment getStreamExecution(ParamsInfo paramsInfo) throws Exception {
<abbr title=" 149         StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), paramsInfo.getDeployMode());"> 149         StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), püîµ</abbr>
 150         StreamTableEnvironment tableEnv = getStreamTableEnv(env,paramsInfo.getConfProp());
 151 
 152         SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());
 153         SqlTree sqlTree = SqlParser.parseSql(paramsInfo.getSql());
 154 
 155         Map&lt;String, AbstractSideTableInfo&gt; sideTableMap = Maps.newHashMap();
 156         Map&lt;String, Table&gt; registerTableCache = Maps.newHashMap();
 157 
 158         //register udf
 159         ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, paramsInfo.getJarUrlList(), tableEnv);
 160         //register table schema
<abbr title=" 161         Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.getLocalSqlPluginPath(),"> 161         Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.geüîµ</abbr>
<abbr title=" 162                 paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registerTableCache);"> 162                 paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registüîµ</abbr>
 163         // cache classPathSets
 164         ExecuteProcessHelper.registerPluginUrlToCachedFile(env, classPathSets);
 165 
<abbr title=" 166         ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, registerTableCache);"> 166         ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTaüîµ</abbr>
 167 
 168         if (env instanceof MyLocalStreamEnvironment) {
 169             ((MyLocalStreamEnvironment) env).setClasspaths(ClassLoaderManager.getClassPath());
 170         }
 171         return env;
 172     }
 173 
 174 
 175     public static List&lt;URL&gt; getExternalJarUrls(String addJarListStr) throws java.io.IOException {
 176         List&lt;URL&gt; jarUrlList = Lists.newArrayList();
 177         if (Strings.isNullOrEmpty(addJarListStr)) {
 178             return jarUrlList;
 179         }
 180 
<abbr title=" 181         List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.UTF_8.name()), List.class);"> 181         List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.Uüîµ</abbr>
 182         //Get External jar to load
 183         for (String addJarPath : addJarFileList) {
 184             jarUrlList.add(new File(addJarPath).toURI().toURL());
 185         }
 186         return jarUrlList;
 187     }
 188 
 189     private static void sqlTranslation(String localSqlPluginPath,
 190                                        StreamTableEnvironment tableEnv,
 191                                        SqlTree sqlTree,Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 192                                        Map&lt;String, Table&gt; registerTableCache) throws Exception {
 193 
 194         SideSqlExec sideSqlExec = new SideSqlExec();
 195         sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);
 196         for (CreateTmpTableParser.SqlParserResult result : sqlTree.getTmpSqlList()) {
 197             sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, result);
 198         }
 199 
 200         for (InsertSqlParser.SqlParseResult result : sqlTree.getExecSqlList()) {
 201             if (LOG.isInfoEnabled()) {
 202                 LOG.info(&quot;exe-sql:\n&quot; + result.getExecSql());
 203             }
 204             boolean isSide = false;
 205             for (String tableName : result.getTargetTableList()) {
 206                 if (sqlTree.getTmpTableMap().containsKey(tableName)) {
 207                     CreateTmpTableParser.SqlParserResult tmp = sqlTree.getTmpTableMap().get(tableName);
 208                     String realSql = DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &quot;`&quot;, &quot;&quot;);
 209 
<abbr title=" 210                     SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();"> 210                     SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfüîµ</abbr>
 211                     String tmpSql = ((SqlInsert) sqlNode).getSource().toString();
 212                     tmp.setExecSql(tmpSql);
 213                     sideSqlExec.exec(tmp.getExecSql(), sideTableMap, tableEnv, registerTableCache, tmp);
 214                 } else {
 215                     for (String sourceTable : result.getSourceTableList()) {
 216                         if (sideTableMap.containsKey(sourceTable)) {
 217                             isSide = true;
 218                             break;
 219                         }
 220                     }
 221                     if (isSide) {
 222                         //sql-dimensional table contains the dimension table of execution
<abbr title=" 223                         sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, null);"> 223                         sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache,üîµ</abbr>
 224                     } else {
 225 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 226                         System.out.println(&quot;----------exec sql without dimension join-----------&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 227                         System.out.println(&quot;----------real sql exec is--------------------------&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 228                         System.out.println(result.getExecSql());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 229                         FlinkSQLExec.sqlUpdate(tableEnv, result.getExecSql());</span>
 230 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231                     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232                         System.out.println(&quot;----------exec sql without dimension join-----------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 233                         System.out.println(&quot;----------real sql exec is--------------------------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234                         System.out.println(result.getExecSql());</span>
 235 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 236                         LOG.info(&quot;----------exec sql without dimension join-----------&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 237                         LOG.info(&quot;----------real sql exec is--------------------------\n{}&quot;, result.getExecSql());"> 237                         LOG.info(&quot;----------real sql exec is--------------------------\n{}&quot;, result.getExüîµ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 238                         FlinkSQLExec.sqlUpdate(tableEnv, result.getExecSql(), queryConfig);</span>
 239 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 240                         if (LOG.isInfoEnabled()) {
 241                             LOG.info(&quot;exec sql: &quot; + result.getExecSql());
 242                         }
 243                     }
 244                 }
 245             }
 246         }
 247     }
 248 
<abbr title=" 249     public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)"> 249     public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironmenüîµ</abbr>
 250             throws IllegalAccessException, InvocationTargetException {
 251         // udfÂíåtableEnvÈ°ªÁî±Âêå‰∏Ä‰∏™Á±ªÂä†ËΩΩÂô®Âä†ËΩΩ
 252         ClassLoader levelClassLoader = tableEnv.getClass().getClassLoader();
 253         URLClassLoader classLoader = null;
 254         List&lt;CreateFuncParser.SqlParserResult&gt; funcList = sqlTree.getFunctionList();
 255         for (CreateFuncParser.SqlParserResult funcInfo : funcList) {
 256             //classloader
 257             if (classLoader == null) {
<abbr title=" 258                 classLoader = ClassLoaderManager.loadExtraJar(jarUrlList, (URLClassLoader) levelClassLoader);"> 258                 classLoader = ClassLoaderManager.loadExtraJar(jarUrlList, (URLClassLoader) levelClassLoadüîµ</abbr>
 259             }
<abbr title=" 260             FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), tableEnv, classLoader);"> 260             FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), üîµ</abbr>
 261         }
 262     }
 263 
 264     /**
 265      *    ÂêëFlinkÊ≥®ÂÜåÊ∫êË°®ÂíåÁªìÊûúË°®ÔºåËøîÂõûÊâßË°åÊó∂Êèí‰ª∂ÂåÖÁöÑÂÖ®Ë∑ØÂæÑ
 266      * @param sqlTree
 267      * @param env
 268      * @param tableEnv
 269      * @param localSqlPluginPath
 270      * @param remoteSqlPluginPath
 271      * @param pluginLoadMode   Êèí‰ª∂Âä†ËΩΩÊ®°Âºè classpath or shipfile
 272      * @param sideTableMap
 273      * @param registerTableCache
 274      * @return
 275      * @throws Exception
 276      */
<abbr title=" 277     public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnvironment tableEnv, String localSqlPluginPath,"> 277     public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnviüîµ</abbr>
<abbr title=" 278                                          String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, Map&lt;String, Table&gt; registerTableCache) throws Exception {"> 278                                          String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, Aüîµ</abbr>
 279         Set&lt;URL&gt; pluginClassPatshSets = Sets.newHashSet();
 280         WaterMarkerAssigner waterMarkerAssigner = new WaterMarkerAssigner();
 281         for (AbstractTableInfo tableInfo : sqlTree.getTableInfoMap().values()) {
 282 
 283             if (tableInfo instanceof AbstractSourceTableInfo) {
 284 
 285                 AbstractSourceTableInfo sourceTableInfo = (AbstractSourceTableInfo) tableInfo;
<abbr title=" 286                 Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqlPluginPath);"> 286                 Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqüîµ</abbr>
 287                 tableEnv.registerTable(sourceTableInfo.getAdaptName(), table);
<abbr title=" 288                 //Note --- parameter conversion function can not be used inside a function of the type of polymerization"> 288                 //Note --- parameter conversion function can not be used inside a function of the type ofüîµ</abbr>
 289                 //Create table in which the function is arranged only need adaptation sql
 290                 String adaptSql = sourceTableInfo.getAdaptSelectSql();
 291                 Table adaptTable = adaptSql == null ? table : tableEnv.sqlQuery(adaptSql);
 292 
<abbr title=" 293                 RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTable.getSchema().getFieldNames());"> 293                 RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTableüîµ</abbr>
 294                 DataStream adaptStream = tableEnv.toAppendStream(adaptTable, typeInfo);
 295 
 296                 String fields = String.join(&quot;,&quot;, typeInfo.getFieldNames());
 297 
 298                 if (waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) {
<abbr title=" 299                     adaptStream = waterMarkerAssigner.assignWaterMarker(adaptStream, typeInfo, sourceTableInfo);"> 299                     adaptStream = waterMarkerAssigner.assignWaterMarker(adaptStream, typeInfo, sourceTablüîµ</abbr>
 300                     fields += &quot;,ROWTIME.ROWTIME&quot;;
 301                 } else {
 302                     fields += &quot;,PROCTIME.PROCTIME&quot;;
 303                 }
 304 
 305                 Table regTable = tableEnv.fromDataStream(adaptStream, fields);
 306                 tableEnv.registerTable(tableInfo.getName(), regTable);
 307                 if (LOG.isInfoEnabled()) {
 308                     LOG.info(&quot;registe table {} success.&quot;, tableInfo.getName());
 309                 }
 310                 registerTableCache.put(tableInfo.getName(), regTable);
 311 
<abbr title=" 312                 URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractSourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 312                 URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(),üîµ</abbr>
 313                 pluginClassPatshSets.add(sourceTablePathUrl);
 314             } else if (tableInfo instanceof AbstractTargetTableInfo) {
 315 
<abbr title=" 316                 TableSink tableSink = StreamSinkFactory.getTableSink((AbstractTargetTableInfo) tableInfo, localSqlPluginPath);"> 316                 TableSink tableSink = StreamSinkFactory.getTableSink((AbstractTargetTableInfo) tableInfo,üîµ</abbr>
<abbr title=" 317                 TypeInformation[] flinkTypes = FunctionManager.transformTypes(tableInfo.getFieldClasses());"> 317                 TypeInformation[] flinkTypes = FunctionManager.transformTypes(tableInfo.getFieldClasses()üîµ</abbr>
<abbr title=" 318                 tableEnv.registerTableSink(tableInfo.getName(), tableInfo.getFields(), flinkTypes, tableSink);"> 318                 tableEnv.registerTableSink(tableInfo.getName(), tableInfo.getFields(), flinkTypes, tableSüîµ</abbr>
 319 
<abbr title=" 320                 URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractTargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 320                 URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), Aüîµ</abbr>
 321                 pluginClassPatshSets.add(sinkTablePathUrl);
 322             } else if (tableInfo instanceof AbstractSideTableInfo) {
<abbr title=" 323                 String sideOperator = ECacheType.ALL.name().equals(((AbstractSideTableInfo) tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;"> 323                 String sideOperator = ECacheType.ALL.name().equals(((AbstractSideTableInfo) tableInfo).geüîµ</abbr>
 324                 sideTableMap.put(tableInfo.getName(), (AbstractSideTableInfo) tableInfo);
 325 
<abbr title=" 326                 URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperator, AbstractSideTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 326                 URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperatüîµ</abbr>
 327                 pluginClassPatshSets.add(sideTablePathUrl);
 328             } else {
 329                 throw new RuntimeException(&quot;not support table type:&quot; + tableInfo.getType());
 330             }
 331         }
 332         return pluginClassPatshSets;
 333     }
 334 
 335     /**
 336      *   perjobÊ®°ÂºèÂ∞Üjob‰æùËµñÁöÑÊèí‰ª∂ÂåÖË∑ØÂæÑÂ≠òÂÇ®Âà∞cacheFileÔºåÂú®Â§ñÂõ¥Â∞ÜÊèí‰ª∂ÂåÖË∑ØÂæÑ‰º†ÈÄíÁªôjobgraph
 337      * @param env
 338      * @param classPathSet
 339      */
<abbr title=" 340     public static void registerPluginUrlToCachedFile(StreamExecutionEnvironment env, Set&lt;URL&gt; classPathSet) {"> 340     public static void registerPluginUrlToCachedFile(StreamExecutionEnvironment env, Set&lt;URL&gt; classPathSeüîµ</abbr>
 341         int i = 0;
 342         for (URL url : classPathSet) {
 343             String classFileName = String.format(CLASS_FILE_NAME_FMT, i);
 344             env.registerCachedFile(url.getPath(), classFileName, true);
 345             i++;
 346         }
 347     }
 348 
<abbr title=" 349     public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployMode) throws Exception {"> 349     public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployModeüîµ</abbr>
 350         StreamExecutionEnvironment env = !ClusterMode.local.name().equals(deployMode) ?
 351                 StreamExecutionEnvironment.getExecutionEnvironment() :
 352                 new MyLocalStreamEnvironment();
 353 
 354         StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, confProperties);
 355         return env;
 356     }
 357 
<abbr title=" 358     private static StreamTableEnvironment getStreamTableEnv(StreamExecutionEnvironment env, Properties confProperties) {"> 358     private static StreamTableEnvironment getStreamTableEnv(StreamExecutionEnvironment env, Properties coüîµ</abbr>
 359         // use blink and streammode
 360         EnvironmentSettings settings = EnvironmentSettings.newInstance()
 361                 .useBlinkPlanner()
 362                 .inStreamingMode()
 363                 .build();
 364 
 365         StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env, settings);
 366         StreamEnvConfigManager.streamTableEnvironmentStateTTLConfig(tableEnv, confProperties);
 367         return tableEnv;
 368     }
 369 
 370 
 371     public static void setLogLevel(ParamsInfo paramsInfo){
 372         String logLevel = paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);
 373         if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){
 374             return;
 375         }
 376         ChangeLogLevelProcess logLevelProcess = new ChangeLogLevelProcess();
 377         logLevelProcess.process(logLevel);
 378     }
 379 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.exec;
  19 
  20 import com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;
  21 import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  22 import com.dtstack.flink.sql.config.CalciteConfig;
  23 import com.dtstack.flink.sql.constrant.ConfigConstrant;
  24 import com.dtstack.flink.sql.enums.ClusterMode;
  25 import com.dtstack.flink.sql.enums.ECacheType;
  26 import com.dtstack.flink.sql.enums.EPluginLoadMode;
  27 import com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;
  28 import com.dtstack.flink.sql.environment.StreamEnvConfigManager;
  29 import com.dtstack.flink.sql.function.FunctionManager;
  30 import com.dtstack.flink.sql.option.OptionParser;
  31 import com.dtstack.flink.sql.option.Options;
  32 import com.dtstack.flink.sql.parser.CreateFuncParser;
  33 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  34 import com.dtstack.flink.sql.parser.InsertSqlParser;
  35 import com.dtstack.flink.sql.parser.SqlParser;
  36 import com.dtstack.flink.sql.parser.SqlTree;
  37 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  38 import com.dtstack.flink.sql.side.SideSqlExec;
  39 import com.dtstack.flink.sql.sink.StreamSinkFactory;
  40 import com.dtstack.flink.sql.source.StreamSourceFactory;
  41 import com.dtstack.flink.sql.table.AbstractSourceTableInfo;
  42 import com.dtstack.flink.sql.table.AbstractTableInfo;
  43 import com.dtstack.flink.sql.table.AbstractTargetTableInfo;
  44 import com.dtstack.flink.sql.util.DtStringUtil;
  45 import com.dtstack.flink.sql.util.PluginUtil;
  46 import com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;
  47 import com.fasterxml.jackson.databind.ObjectMapper;
  48 import com.google.common.base.Preconditions;
  49 import com.google.common.base.Strings;
  50 import com.google.common.collect.Lists;
  51 import com.google.common.collect.Maps;
  52 import com.google.common.collect.Sets;
  53 import java.io.File;
  54 import java.lang.reflect.InvocationTargetException;
  55 import java.net.URL;
  56 import java.net.URLClassLoader;
  57 import java.net.URLDecoder;
  58 import java.util.Arrays;
  59 import java.util.List;
  60 import java.util.Map;
  61 import java.util.Properties;
  62 import java.util.Set;
  63 import org.apache.calcite.sql.SqlInsert;
  64 import org.apache.calcite.sql.SqlNode;
  65 import org.apache.commons.io.Charsets;
  66 import org.apache.commons.lang3.StringUtils;
  67 import org.apache.flink.api.common.typeinfo.TypeInformation;
  68 import org.apache.flink.api.java.tuple.Tuple2;
  69 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  70 import org.apache.flink.streaming.api.datastream.DataStream;
  71 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  72 import org.apache.flink.table.api.EnvironmentSettings;
  73 import org.apache.flink.table.api.Table;
  74 import org.apache.flink.table.api.TableEnvironment;
  75 import org.apache.flink.table.api.java.StreamTableEnvironment;
  76 import org.apache.flink.table.sinks.TableSink;
  77 import org.apache.flink.types.Row;
  78 import org.slf4j.Logger;
  79 import org.slf4j.LoggerFactory;
  80 
  81 
  82 /**
  83  *  ‰ªªÂä°ÊâßË°åÊó∂ÁöÑÊµÅÁ®ãÊñπÊ≥ï
  84  * Date: 2020/2/17
  85  * Company: www.dtstack.com
  86  * @author maqi
  87  */
  88 public class ExecuteProcessHelper {
  89     private static final String CLASS_FILE_NAME_FMT = &quot;class_path_%d&quot;;
  90 
  91     private static final Logger LOG = LoggerFactory.getLogger(ExecuteProcessHelper.class);
  92 
  93     private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  94 
  95     public static ParamsInfo parseParams(String[] args) throws Exception {
  96         LOG.info(&quot;------------program params-------------------------&quot;);
  97         Arrays.stream(args).forEach(( arg) -&gt; LOG.info(&quot;{}&quot;, arg));
  98         LOG.info(&quot;-------------------------------------------&quot;);
  99         OptionParser optionParser = new OptionParser(args);
 100         Options options = optionParser.getOptions();
 101         String sql = URLDecoder.decode(options.getSql(), Charsets.UTF_8.name());
 102         String name = options.getName();
 103         String localSqlPluginPath = options.getLocalSqlPluginPath();
 104         String remoteSqlPluginPath = options.getRemoteSqlPluginPath();
 105         String pluginLoadMode = options.getPluginLoadMode();
 106         String deployMode = options.getMode();
 107         String logLevel = options.getLogLevel();
<abbr title=" 108         Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, deployMode, pluginLoadMode), &quot;Non-local mode or shipfile deployment mode, remoteSqlPluginPath is required&quot;);"> 108         Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, deployMode, pluginLoadMüîµ</abbr>
 109         String confProp = URLDecoder.decode(options.getConfProp(), Charsets.UTF_8.toString());
 110         Properties confProperties = PluginUtil.jsonStrToObject(confProp, Properties.class);
 111         List&lt;URL&gt; jarUrlList = getExternalJarUrls(options.getAddjar());
<abbr title=" 112         return ParamsInfo.builder().setSql(sql).setName(name).setLocalSqlPluginPath(localSqlPluginPath).setRemoteSqlPluginPath(remoteSqlPluginPath).setPluginLoadMode(pluginLoadMode).setDeployMode(deployMode).setConfProp(confProperties).setJarUrlList(jarUrlList).build();"> 112         return ParamsInfo.builder().setSql(sql).setName(name).setLocalSqlPluginPath(localSqlPluginPath).süîµ</abbr>
 113     }
 114 
 115     /**
 116      *   ÈùûlocalÊ®°ÂºèÊàñËÄÖshipfileÈÉ®ÁΩ≤Ê®°ÂºèÔºåremoteSqlPluginPathÂøÖÂ°´
 117      * @param remoteSqlPluginPath
 118      * @param deployMode
 119      * @param pluginLoadMode
 120      * @return
 121      */
<abbr title=" 122     public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String pluginLoadMode) {"> 122     public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String üîµ</abbr>
 123         if (StringUtils.isEmpty(remoteSqlPluginPath)) {
 124             return StringUtils.equalsIgnoreCase(pluginLoadMode, EPluginLoadMode.SHIPFILE.name())
 125                     || StringUtils.equalsIgnoreCase(deployMode, ClusterMode.local.name());
 126         }
 127         return true;
 128     }
 129 
 130     public static StreamExecutionEnvironment getStreamExecution(ParamsInfo paramsInfo) throws Exception {
<abbr title=" 131         StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), paramsInfo.getDeployMode());"> 131         StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), püîµ</abbr>
 132         StreamTableEnvironment tableEnv = getStreamTableEnv(env, paramsInfo.getConfProp());
 133         SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());
 134         SqlTree sqlTree = SqlParser.parseSql(paramsInfo.getSql());
 135         Map&lt;String, AbstractSideTableInfo&gt; sideTableMap = Maps.newHashMap();
 136         Map&lt;String, Table&gt; registerTableCache = Maps.newHashMap();
 137         // register udf
 138         ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, paramsInfo.getJarUrlList(), tableEnv);
 139         // register table schema
<abbr title=" 140         Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.getLocalSqlPluginPath(), paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registerTableCache);"> 140         Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.geüîµ</abbr>
 141         // cache classPathSets
 142         ExecuteProcessHelper.registerPluginUrlToCachedFile(env, classPathSets);
<abbr title=" 143         ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, registerTableCache);"> 143         ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTaüîµ</abbr>
 144         if (env instanceof MyLocalStreamEnvironment) {
 145             ((MyLocalStreamEnvironment) (env)).setClasspaths(ClassLoaderManager.getClassPath());
 146         }
 147         return env;
 148     }
 149 
 150     public static List&lt;URL&gt; getExternalJarUrls(String addJarListStr) throws java.io.IOException {
 151         List&lt;URL&gt; jarUrlList = Lists.newArrayList();
 152         if (Strings.isNullOrEmpty(addJarListStr)) {
 153             return jarUrlList;
 154         }
 155 
<abbr title=" 156         List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.UTF_8.name()), List.class);"> 156         List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.Uüîµ</abbr>
 157         //Get External jar to load
 158         for (String addJarPath : addJarFileList) {
 159             jarUrlList.add(new File(addJarPath).toURI().toURL());
 160         }
 161         return jarUrlList;
 162     }
 163 
<abbr title=" 164     private static void sqlTranslation(String localSqlPluginPath, StreamTableEnvironment tableEnv, SqlTree sqlTree, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, Map&lt;String, Table&gt; registerTableCache) throws Exception {"> 164     private static void sqlTranslation(String localSqlPluginPath, StreamTableEnvironment tableEnv, SqlTreüîµ</abbr>
 165         SideSqlExec sideSqlExec = new SideSqlExec();
 166         sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);
 167         for (CreateTmpTableParser.SqlParserResult result : sqlTree.getTmpSqlList()) {
 168             sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, result);
 169         }
 170         for (InsertSqlParser.SqlParseResult result : sqlTree.getExecSqlList()) {
 171             if (LOG.isInfoEnabled()) {
 172                 LOG.info(&quot;exe-sql:\n&quot; + result.getExecSql());
 173             }
 174             boolean isSide = false;
 175             for (String tableName : result.getTargetTableList()) {
 176                 if (sqlTree.getTmpTableMap().containsKey(tableName)) {
 177                     CreateTmpTableParser.SqlParserResult tmp = sqlTree.getTmpTableMap().get(tableName);
 178                     String realSql = DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &quot;`&quot;, &quot;&quot;);
<abbr title=" 179                     SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();"> 179                     SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfüîµ</abbr>
 180                     String tmpSql = ((SqlInsert) (sqlNode)).getSource().toString();
 181                     tmp.setExecSql(tmpSql);
 182                     sideSqlExec.exec(tmp.getExecSql(), sideTableMap, tableEnv, registerTableCache, tmp);
 183                 } else {
 184                     for (String sourceTable : result.getSourceTableList()) {
 185                         if (sideTableMap.containsKey(sourceTable)) {
 186                             isSide = true;
 187                             break;
 188                         }
 189                     }
 190                     if (isSide) {
 191                         //sql-dimensional table contains the dimension table of execution
<abbr title=" 192                         sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, null);"> 192                         sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache,üîµ</abbr>
 193                     } else {
 194                         LOG.info(&quot;----------exec sql without dimension join-----------&quot;);
<abbr title=" 195                         LOG.info(&quot;----------real sql exec is--------------------------\n{}&quot;, result.getExecSql());"> 195                         LOG.info(&quot;----------real sql exec is--------------------------\n{}&quot;, result.getExüîµ</abbr>
 196                         FlinkSQLExec.sqlUpdate(tableEnv, result.getExecSql());
 197                         if (LOG.isInfoEnabled()) {
 198                             LOG.info(&quot;exec sql: &quot; + result.getExecSql());
 199                         }
 200                     }
 201                 }
 202             }
 203         }
 204     }
 205 
<abbr title=" 206     public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)"> 206     public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironmenüîµ</abbr>
 207             throws IllegalAccessException, InvocationTargetException {
 208         // udfÂíåtableEnvÈ°ªÁî±Âêå‰∏Ä‰∏™Á±ªÂä†ËΩΩÂô®Âä†ËΩΩ
 209         ClassLoader levelClassLoader = tableEnv.getClass().getClassLoader();
 210         URLClassLoader classLoader = null;
 211         List&lt;CreateFuncParser.SqlParserResult&gt; funcList = sqlTree.getFunctionList();
 212         for (CreateFuncParser.SqlParserResult funcInfo : funcList) {
 213             //classloader
 214             if (classLoader == null) {
<abbr title=" 215                 classLoader = ClassLoaderManager.loadExtraJar(jarUrlList, (URLClassLoader) levelClassLoader);"> 215                 classLoader = ClassLoaderManager.loadExtraJar(jarUrlList, (URLClassLoader) levelClassLoadüîµ</abbr>
 216             }
<abbr title=" 217             FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), tableEnv, classLoader);"> 217             FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), üîµ</abbr>
 218         }
 219     }
 220 
 221     /**
 222      *    ÂêëFlinkÊ≥®ÂÜåÊ∫êË°®ÂíåÁªìÊûúË°®ÔºåËøîÂõûÊâßË°åÊó∂Êèí‰ª∂ÂåÖÁöÑÂÖ®Ë∑ØÂæÑ
 223      * @param sqlTree
 224      * @param env
 225      * @param tableEnv
 226      * @param localSqlPluginPath
 227      * @param remoteSqlPluginPath
 228      * @param pluginLoadMode   Êèí‰ª∂Âä†ËΩΩÊ®°Âºè classpath or shipfile
 229      * @param sideTableMap
 230      * @param registerTableCache
 231      * @return
 232      * @throws Exception
 233      */
<abbr title=" 234     public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnvironment tableEnv, String localSqlPluginPath, String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, Map&lt;String, Table&gt; registerTableCache) throws Exception {"> 234     public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnviüîµ</abbr>
 235         Set&lt;URL&gt; pluginClassPatshSets = Sets.newHashSet();
 236         WaterMarkerAssigner waterMarkerAssigner = new WaterMarkerAssigner();
 237         for (AbstractTableInfo tableInfo : sqlTree.getTableInfoMap().values()) {
 238             if (tableInfo instanceof AbstractSourceTableInfo) {
 239                 AbstractSourceTableInfo sourceTableInfo = ((AbstractSourceTableInfo) (tableInfo));
<abbr title=" 240                 Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqlPluginPath);"> 240                 Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqüîµ</abbr>
 241                 tableEnv.registerTable(sourceTableInfo.getAdaptName(), table);
<abbr title=" 242                 // Note --- parameter conversion function can not be used inside a function of the type of polymerization"> 242                 // Note --- parameter conversion function can not be used inside a function of the type oüîµ</abbr>
 243                 // Create table in which the function is arranged only need adaptation sql
 244                 String adaptSql = sourceTableInfo.getAdaptSelectSql();
 245                 Table adaptTable = (adaptSql == null) ? table : tableEnv.sqlQuery(adaptSql);
<abbr title=" 246                 RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTable.getSchema().getFieldNames());"> 246                 RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTableüîµ</abbr>
 247                 DataStream adaptStream = tableEnv.toAppendStream(adaptTable, typeInfo);
 248                 String fields = String.join(&quot;,&quot;, typeInfo.getFieldNames());
 249                 if (waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) {
<abbr title=" 250                     adaptStream = waterMarkerAssigner.assignWaterMarker(adaptStream, typeInfo, sourceTableInfo);"> 250                     adaptStream = waterMarkerAssigner.assignWaterMarker(adaptStream, typeInfo, sourceTablüîµ</abbr>
 251                     fields += &quot;,ROWTIME.ROWTIME&quot;;
 252                 } else {
 253                     fields += &quot;,PROCTIME.PROCTIME&quot;;
 254                 }
 255                 Table regTable = tableEnv.fromDataStream(adaptStream, fields);
 256                 tableEnv.registerTable(tableInfo.getName(), regTable);
 257                 if (LOG.isInfoEnabled()) {
 258                     LOG.info(&quot;registe table {} success.&quot;, tableInfo.getName());
 259                 }
 260                 registerTableCache.put(tableInfo.getName(), regTable);
<abbr title=" 261                 URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractSourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 261                 URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(),üîµ</abbr>
 262                 pluginClassPatshSets.add(sourceTablePathUrl);
 263             } else if (tableInfo instanceof AbstractTargetTableInfo) {
<abbr title=" 264                 TableSink tableSink = StreamSinkFactory.getTableSink(((AbstractTargetTableInfo) (tableInfo)), localSqlPluginPath);"> 264                 TableSink tableSink = StreamSinkFactory.getTableSink(((AbstractTargetTableInfo) (tableInfüîµ</abbr>
<abbr title=" 265                 TypeInformation[] flinkTypes = FunctionManager.transformTypes(tableInfo.getFieldClasses());"> 265                 TypeInformation[] flinkTypes = FunctionManager.transformTypes(tableInfo.getFieldClasses()üîµ</abbr>
<abbr title=" 266                 tableEnv.registerTableSink(tableInfo.getName(), tableInfo.getFields(), flinkTypes, tableSink);"> 266                 tableEnv.registerTableSink(tableInfo.getName(), tableInfo.getFields(), flinkTypes, tableSüîµ</abbr>
<abbr title=" 267                 URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractTargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 267                 URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), Aüîµ</abbr>
 268                 pluginClassPatshSets.add(sinkTablePathUrl);
 269             } else if (tableInfo instanceof AbstractSideTableInfo) {
<abbr title=" 270                 String sideOperator = (ECacheType.ALL.name().equals(((AbstractSideTableInfo) (tableInfo)).getCacheType())) ? &quot;all&quot; : &quot;async&quot;;"> 270                 String sideOperator = (ECacheType.ALL.name().equals(((AbstractSideTableInfo) (tableInfo))üîµ</abbr>
 271                 sideTableMap.put(tableInfo.getName(), ((AbstractSideTableInfo) (tableInfo)));
<abbr title=" 272                 URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperator, AbstractSideTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 272                 URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperatüîµ</abbr>
 273                 pluginClassPatshSets.add(sideTablePathUrl);
 274             } else {
 275                 throw new RuntimeException(&quot;not support table type:&quot; + tableInfo.getType());
 276             }
 277         }
 278         return pluginClassPatshSets;
 279     }
 280 
 281     /**
 282      *   perjobÊ®°ÂºèÂ∞Üjob‰æùËµñÁöÑÊèí‰ª∂ÂåÖË∑ØÂæÑÂ≠òÂÇ®Âà∞cacheFileÔºåÂú®Â§ñÂõ¥Â∞ÜÊèí‰ª∂ÂåÖË∑ØÂæÑ‰º†ÈÄíÁªôjobgraph
 283      * @param env
 284      * @param classPathSet
 285      */
<abbr title=" 286     public static void registerPluginUrlToCachedFile(StreamExecutionEnvironment env, Set&lt;URL&gt; classPathSet) {"> 286     public static void registerPluginUrlToCachedFile(StreamExecutionEnvironment env, Set&lt;URL&gt; classPathSeüîµ</abbr>
 287         int i = 0;
 288         for (URL url : classPathSet) {
 289             String classFileName = String.format(CLASS_FILE_NAME_FMT, i);
 290             env.registerCachedFile(url.getPath(), classFileName, true);
 291             i++;
 292         }
 293     }
 294 
<abbr title=" 295     public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployMode) throws Exception {"> 295     public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployModeüîµ</abbr>
 296         StreamExecutionEnvironment env = !ClusterMode.local.name().equals(deployMode) ?
 297                 StreamExecutionEnvironment.getExecutionEnvironment() :
 298                 new MyLocalStreamEnvironment();
 299 
 300         StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, confProperties);
 301         return env;
 302     }
 303 
<abbr title=" 304     private static StreamTableEnvironment getStreamTableEnv(StreamExecutionEnvironment env, Properties confProperties) {"> 304     private static StreamTableEnvironment getStreamTableEnv(StreamExecutionEnvironment env, Properties coüîµ</abbr>
 305         // use blink and streammode
 306         EnvironmentSettings settings = EnvironmentSettings.newInstance()
 307                 .useBlinkPlanner()
 308                 .inStreamingMode()
 309                 .build();
 310 
 311         StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env, settings);
 312         StreamEnvConfigManager.streamTableEnvironmentStateTTLConfig(tableEnv, confProperties);
 313         return tableEnv;
 314     }
 315 
 316     public static void setLogLevel(ParamsInfo paramsInfo){
 317         String logLevel = paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);
 318         if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){
 319             return;
 320         }
 321         ChangeLogLevelProcess logLevelProcess = new ChangeLogLevelProcess();
 322         logLevelProcess.process(logLevel);
 323     }
 324 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.exec;
  20  
  21  import com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;
  22  import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  23  import com.dtstack.flink.sql.config.CalciteConfig;
  24  import com.dtstack.flink.sql.constrant.ConfigConstrant;
  25  import com.dtstack.flink.sql.enums.ClusterMode;
  26  import com.dtstack.flink.sql.enums.ECacheType;
  27  import com.dtstack.flink.sql.enums.EPluginLoadMode;
  28  import com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;
  29  import com.dtstack.flink.sql.environment.StreamEnvConfigManager;
  30  import com.dtstack.flink.sql.function.FunctionManager;
  31  import com.dtstack.flink.sql.option.OptionParser;
  32  import com.dtstack.flink.sql.option.Options;
  33  import com.dtstack.flink.sql.parser.CreateFuncParser;
  34  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  35  import com.dtstack.flink.sql.parser.InsertSqlParser;
  36  import com.dtstack.flink.sql.parser.SqlParser;
  37  import com.dtstack.flink.sql.parser.SqlTree;
  38  import com.dtstack.flink.sql.side.SideSqlExec;
  39  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  40  import com.dtstack.flink.sql.sink.StreamSinkFactory;
  41  import com.dtstack.flink.sql.source.StreamSourceFactory;
  42  import com.dtstack.flink.sql.table.AbstractSourceTableInfo;
  43  import com.dtstack.flink.sql.table.AbstractTableInfo;
  44  import com.dtstack.flink.sql.table.AbstractTargetTableInfo;
  45  import com.dtstack.flink.sql.util.DtStringUtil;
  46  import com.dtstack.flink.sql.util.PluginUtil;
  47  import com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;
  48  import com.fasterxml.jackson.databind.ObjectMapper;
  49  import com.google.common.base.Preconditions;
  50  import com.google.common.base.Strings;
  51  import com.google.common.collect.Lists;
  52  import com.google.common.collect.Maps;
  53  import com.google.common.collect.Sets;
  54  import org.apache.calcite.sql.SqlInsert;
  55  import org.apache.calcite.sql.SqlNode;
  56  import org.apache.commons.io.Charsets;
  57  import org.apache.commons.lang3.StringUtils;
  58  import org.apache.flink.api.common.typeinfo.TypeInformation;
  59  import org.apache.flink.api.java.tuple.Tuple2;
  60  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  61  import org.apache.flink.streaming.api.datastream.DataStream;
  62  import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  63 -import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import org.apache.flink.table.api.EnvironmentSettings;</span>
  65  import org.apache.flink.table.api.Table;
  66  import org.apache.flink.table.api.TableEnvironment;
  67  import org.apache.flink.table.api.java.StreamTableEnvironment;
  68  import org.apache.flink.table.sinks.TableSink;
  69  import org.apache.flink.types.Row;
  70  import org.slf4j.Logger;
  71  import org.slf4j.LoggerFactory;
  72  
  73  import java.io.File;
  74  import java.lang.reflect.InvocationTargetException;
  75  import java.net.URL;
  76  import java.net.URLClassLoader;
  77  import java.net.URLDecoder;
  78  import java.util.Arrays;
  79  import java.util.List;
  80  import java.util.Map;
  81  import java.util.Properties;
  82  import java.util.Set;
  83  
  84  /**
  85   *  ‰ªªÂä°ÊâßË°åÊó∂ÁöÑÊµÅÁ®ãÊñπÊ≥ï
  86   * Date: 2020/2/17
  87   * Company: www.dtstack.com
  88   * @author maqi
  89   */
  90  public class ExecuteProcessHelper {
  91  
  92      private static final String CLASS_FILE_NAME_FMT = &quot;class_path_%d&quot;;
  93      private static final Logger LOG = LoggerFactory.getLogger(ExecuteProcessHelper.class);
  94      private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  95  
  96  
  97      public static ParamsInfo parseParams(String[] args) throws Exception {
  98          LOG.info(&quot;------------program params-------------------------&quot;);
  99          System.out.println(&quot;------------program params-------------------------&quot;);
 100          Arrays.stream(args).forEach(arg -&gt; LOG.info(&quot;{}&quot;, arg));
 101          Arrays.stream(args).forEach(System.out::println);
 102          LOG.info(&quot;-------------------------------------------&quot;);
 103          System.out.println(&quot;----------------------------------------&quot;);
 104  
 105          OptionParser optionParser = new OptionParser(args);
 106          Options options = optionParser.getOptions();
 107  
 108          String sql = URLDecoder.decode(options.getSql(), Charsets.UTF_8.name());
 109          String name = options.getName();
 110          String localSqlPluginPath = options.getLocalSqlPluginPath();
 111          String remoteSqlPluginPath = options.getRemoteSqlPluginPath();
 112          String pluginLoadMode = options.getPluginLoadMode();
 113          String deployMode = options.getMode();
 114          String logLevel = options.getLogLevel();
 115  
 116          Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, deployMode, pluginLoadMode),
 117                  &quot;Non-local mode or shipfile deployment mode, remoteSqlPluginPath is required&quot;);
 118          String confProp = URLDecoder.decode(options.getConfProp(), Charsets.UTF_8.toString());
 119          Properties confProperties = PluginUtil.jsonStrToObject(confProp, Properties.class);
 120  
 121          List&lt;URL&gt; jarUrlList = getExternalJarUrls(options.getAddjar());
 122  
 123          return ParamsInfo.builder()
 124                  .setSql(sql)
 125                  .setName(name)
 126                  .setLocalSqlPluginPath(localSqlPluginPath)
 127                  .setRemoteSqlPluginPath(remoteSqlPluginPath)
 128                  .setPluginLoadMode(pluginLoadMode)
 129                  .setDeployMode(deployMode)
 130                  .setConfProp(confProperties)
 131                  .setJarUrlList(jarUrlList)
 132                  .build();
 133  
 134      }
 135  
 136      /**
 137       *   ÈùûlocalÊ®°ÂºèÊàñËÄÖshipfileÈÉ®ÁΩ≤Ê®°ÂºèÔºåremoteSqlPluginPathÂøÖÂ°´
 138       * @param remoteSqlPluginPath
 139       * @param deployMode
 140       * @param pluginLoadMode
 141       * @return
 142       */
<abbr title=" 143      public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String pluginLoadMode) {"> 143      public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String pluginLoaüîµ</abbr>
 144          if (StringUtils.isEmpty(remoteSqlPluginPath)) {
 145              return StringUtils.equalsIgnoreCase(pluginLoadMode, EPluginLoadMode.SHIPFILE.name())
 146                      || StringUtils.equalsIgnoreCase(deployMode, ClusterMode.local.name());
 147          }
 148          return true;
 149      }
 150  
 151  
 152      public static StreamExecutionEnvironment getStreamExecution(ParamsInfo paramsInfo) throws Exception {
<abbr title=" 153          StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), paramsInfo.getDeployMode());"> 153          StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), paramsInfoüîµ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 155 -        StreamQueryConfig streamQueryConfig = StreamEnvConfigManager.getStreamQueryConfig(tableEnv, paramsInfo.getConfProp());"> 155 -        StreamQueryConfig streamQueryConfig = StreamEnvConfigManager.getStreamQueryConfig(tableEnv, paramsInfo.getüîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +        StreamTableEnvironment tableEnv = getStreamTableEnv(env,paramsInfo.getConfProp());</span>
 157  
 158          SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());
 159          SqlTree sqlTree = SqlParser.parseSql(paramsInfo.getSql());
 160  
 161          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap = Maps.newHashMap();
 162          Map&lt;String, Table&gt; registerTableCache = Maps.newHashMap();
 163  
 164          //register udf
 165          ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, paramsInfo.getJarUrlList(), tableEnv);
 166          //register table schema
<abbr title=" 167          Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.getLocalSqlPluginPath(),"> 167          Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.getLocalSqlüîµ</abbr>
<abbr title=" 168                  paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registerTableCache);"> 168                  paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registerTableCaüîµ</abbr>
 169          // cache classPathSets
 170          ExecuteProcessHelper.registerPluginUrlToCachedFile(env, classPathSets);
 171  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 172 -        ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, registerTableCache, streamQueryConfig);"> 172 -        ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, rüîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 173 +        ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, registerTableCache);"> 173 +        ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, rüîµ</abbr></span>
 174  
 175          if (env instanceof MyLocalStreamEnvironment) {
 176              ((MyLocalStreamEnvironment) env).setClasspaths(ClassLoaderManager.getClassPath());
 177          }
 178          return env;
 179      }
 180  
 181  
 182      public static List&lt;URL&gt; getExternalJarUrls(String addJarListStr) throws java.io.IOException {
 183          List&lt;URL&gt; jarUrlList = Lists.newArrayList();
 184          if (Strings.isNullOrEmpty(addJarListStr)) {
 185              return jarUrlList;
 186          }
 187  
<abbr title=" 188          List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.UTF_8.name()), List.class);"> 188          List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.UTF_8.nameüîµ</abbr>
 189          //Get External jar to load
 190          for (String addJarPath : addJarFileList) {
 191              jarUrlList.add(new File(addJarPath).toURI().toURL());
 192          }
 193          return jarUrlList;
 194      }
 195  
 196      private static void sqlTranslation(String localSqlPluginPath,
 197                                         StreamTableEnvironment tableEnv,
 198                                         SqlTree sqlTree,Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -                                       Map&lt;String, Table&gt; registerTableCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -                                       StreamQueryConfig queryConfig) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +                                       Map&lt;String, Table&gt; registerTableCache) throws Exception {</span>
 202  
 203          SideSqlExec sideSqlExec = new SideSqlExec();
 204          sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);
 205          for (CreateTmpTableParser.SqlParserResult result : sqlTree.getTmpSqlList()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 206 -            sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, result);"> 206 -            sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, result)üîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +            sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, result);</span>
 208          }
 209  
 210          for (InsertSqlParser.SqlParseResult result : sqlTree.getExecSqlList()) {
 211              if (LOG.isInfoEnabled()) {
 212                  LOG.info(&quot;exe-sql:\n&quot; + result.getExecSql());
 213              }
 214  
 215              boolean isSide = false;
 216              for (String tableName : result.getTargetTableList()) {
 217                  if (sqlTree.getTmpTableMap().containsKey(tableName)) {
 218                      CreateTmpTableParser.SqlParserResult tmp = sqlTree.getTmpTableMap().get(tableName);
 219                      String realSql = DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &quot;`&quot;, &quot;&quot;);
 220  
<abbr title=" 221                      SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();"> 221                      SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfig.MYSQL_üîµ</abbr>
 222                      String tmpSql = ((SqlInsert) sqlNode).getSource().toString();
 223                      tmp.setExecSql(tmpSql);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 224 -                    sideSqlExec.exec(tmp.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, tmp);"> 224 -                    sideSqlExec.exec(tmp.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, tmüîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +                    sideSqlExec.exec(tmp.getExecSql(), sideTableMap, tableEnv, registerTableCache, tmp);</span>
 226                  } else {
 227                      for (String sourceTable : result.getSourceTableList()) {
 228                          if (sideTableMap.containsKey(sourceTable)) {
 229                              isSide = true;
 230                              break;
 231                          }
 232                      }
 233                      if (isSide) {
 234                          //sql-dimensional table contains the dimension table of execution
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 235 -                        sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, null);"> 235 -                        sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConüîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +                        sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, null);</span>
 237                      } else {
 238                          System.out.println(&quot;----------exec sql without dimension join-----------&quot;);
 239                          System.out.println(&quot;----------real sql exec is--------------------------&quot;);
 240                          System.out.println(result.getExecSql());


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 241 -                        FlinkSQLExec.sqlUpdate(tableEnv, result.getExecSql(), queryConfig);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +                        FlinkSQLExec.sqlUpdate(tableEnv, result.getExecSql());</span>
 243                          if (LOG.isInfoEnabled()) {
 244                              System.out.println();
 245                              LOG.info(&quot;exec sql: &quot; + result.getExecSql());
 246                          }
 247                      }
 248                  }
 249              }
 250          }
 251      }
 252  
<abbr title=" 253      public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)"> 253      public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironment tableEnüîµ</abbr>
 254              throws IllegalAccessException, InvocationTargetException {
 255          // udfÂíåtableEnvÈ°ªÁî±Âêå‰∏Ä‰∏™Á±ªÂä†ËΩΩÂô®Âä†ËΩΩ
 256          ClassLoader levelClassLoader = tableEnv.getClass().getClassLoader();
 257          URLClassLoader classLoader = null;
 258          List&lt;CreateFuncParser.SqlParserResult&gt; funcList = sqlTree.getFunctionList();
 259          for (CreateFuncParser.SqlParserResult funcInfo : funcList) {
 260              //classloader
 261              if (classLoader == null) {
 262                  classLoader = ClassLoaderManager.loadExtraJar(jarUrlList, (URLClassLoader) levelClassLoader);
 263              }
<abbr title=" 264              FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), tableEnv, classLoader);"> 264              FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), tableEnv,üîµ</abbr>
 265          }
 266      }
 267  
 268      /**
 269       *    ÂêëFlinkÊ≥®ÂÜåÊ∫êË°®ÂíåÁªìÊûúË°®ÔºåËøîÂõûÊâßË°åÊó∂Êèí‰ª∂ÂåÖÁöÑÂÖ®Ë∑ØÂæÑ
 270       * @param sqlTree
 271       * @param env
 272       * @param tableEnv
 273       * @param localSqlPluginPath
 274       * @param remoteSqlPluginPath
 275       * @param pluginLoadMode   Êèí‰ª∂Âä†ËΩΩÊ®°Âºè classpath or shipfile
 276       * @param sideTableMap
 277       * @param registerTableCache
 278       * @return
 279       * @throws Exception
 280       */
<abbr title=" 281      public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnvironment tableEnv, String localSqlPluginPath,"> 281      public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnvironment tüîµ</abbr>
<abbr title=" 282                                           String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, Map&lt;String, Table&gt; registerTableCache) throws Exception {"> 282                                           String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, AbstractSiüîµ</abbr>
 283          Set&lt;URL&gt; pluginClassPatshSets = Sets.newHashSet();
 284          WaterMarkerAssigner waterMarkerAssigner = new WaterMarkerAssigner();
 285          for (AbstractTableInfo tableInfo : sqlTree.getTableInfoMap().values()) {
 286  
 287              if (tableInfo instanceof AbstractSourceTableInfo) {
 288  
 289                  AbstractSourceTableInfo sourceTableInfo = (AbstractSourceTableInfo) tableInfo;
<abbr title=" 290                  Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqlPluginPath);"> 290                  Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqlPluginPaüîµ</abbr>
 291                  tableEnv.registerTable(sourceTableInfo.getAdaptName(), table);
<abbr title=" 292                  //Note --- parameter conversion function can not be used inside a function of the type of polymerization"> 292                  //Note --- parameter conversion function can not be used inside a function of the type of polymeriüîµ</abbr>
 293                  //Create table in which the function is arranged only need adaptation sql
 294                  String adaptSql = sourceTableInfo.getAdaptSelectSql();
 295                  Table adaptTable = adaptSql == null ? table : tableEnv.sqlQuery(adaptSql);
 296  
<abbr title=" 297                  RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTable.getSchema().getFieldNames());"> 297                  RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTable.getSchemüîµ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 298 -                DataStream adaptStream = tableEnv.toRetractStream(adaptTable, typeInfo)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 299 -                        .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 300 -                            return f0.f1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -                        })</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -                        .returns(typeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 303 +                DataStream adaptStream = tableEnv.toAppendStream(adaptTable, typeInfo);</span>
 304  
 305                  String fields = String.join(&quot;,&quot;, typeInfo.getFieldNames());
 306  
 307                  if (waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) {
 308                      adaptStream = waterMarkerAssigner.assignWaterMarker(adaptStream, typeInfo, sourceTableInfo);
 309                      fields += &quot;,ROWTIME.ROWTIME&quot;;
 310                  } else {
 311                      fields += &quot;,PROCTIME.PROCTIME&quot;;
 312                  }
 313  
 314                  Table regTable = tableEnv.fromDataStream(adaptStream, fields);
 315                  tableEnv.registerTable(tableInfo.getName(), regTable);
 316                  if (LOG.isInfoEnabled()) {
 317                      LOG.info(&quot;registe table {} success.&quot;, tableInfo.getName());
 318                  }
 319                  registerTableCache.put(tableInfo.getName(), regTable);
 320  
<abbr title=" 321                  URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractSourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 321                  URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), Abstractüîµ</abbr>
 322                  pluginClassPatshSets.add(sourceTablePathUrl);
 323              } else if (tableInfo instanceof AbstractTargetTableInfo) {
 324  
<abbr title=" 325                  TableSink tableSink = StreamSinkFactory.getTableSink((AbstractTargetTableInfo) tableInfo, localSqlPluginPath);"> 325                  TableSink tableSink = StreamSinkFactory.getTableSink((AbstractTargetTableInfo) tableInfo, localSqlüîµ</abbr>
 326                  TypeInformation[] flinkTypes = FunctionManager.transformTypes(tableInfo.getFieldClasses());
 327                  tableEnv.registerTableSink(tableInfo.getName(), tableInfo.getFields(), flinkTypes, tableSink);
 328  
<abbr title=" 329                  URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractTargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 329                  URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractTaüîµ</abbr>
 330                  pluginClassPatshSets.add(sinkTablePathUrl);
 331              } else if (tableInfo instanceof AbstractSideTableInfo) {
<abbr title=" 332                  String sideOperator = ECacheType.ALL.name().equals(((AbstractSideTableInfo) tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;"> 332                  String sideOperator = ECacheType.ALL.name().equals(((AbstractSideTableInfo) tableInfo).getCacheTypüîµ</abbr>
 333                  sideTableMap.put(tableInfo.getName(), (AbstractSideTableInfo) tableInfo);
 334  
<abbr title=" 335                  URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperator, AbstractSideTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 335                  URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperator, Abstrüîµ</abbr>
 336                  pluginClassPatshSets.add(sideTablePathUrl);
 337              } else {
 338                  throw new RuntimeException(&quot;not support table type:&quot; + tableInfo.getType());
 339              }
 340          }
 341          return pluginClassPatshSets;
 342      }
 343  
 344      /**
 345       *   perjobÊ®°ÂºèÂ∞Üjob‰æùËµñÁöÑÊèí‰ª∂ÂåÖË∑ØÂæÑÂ≠òÂÇ®Âà∞cacheFileÔºåÂú®Â§ñÂõ¥Â∞ÜÊèí‰ª∂ÂåÖË∑ØÂæÑ‰º†ÈÄíÁªôjobgraph
 346       * @param env
 347       * @param classPathSet
 348       */
 349      public static void registerPluginUrlToCachedFile(StreamExecutionEnvironment env, Set&lt;URL&gt; classPathSet) {
 350          int i = 0;
 351          for (URL url : classPathSet) {
 352              String classFileName = String.format(CLASS_FILE_NAME_FMT, i);
 353              env.registerCachedFile(url.getPath(), classFileName, true);
 354              i++;
 355          }
 356      }
 357  
<abbr title=" 358      public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployMode) throws Exception {"> 358      public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployMode) throws üîµ</abbr>
 359          StreamExecutionEnvironment env = !ClusterMode.local.name().equals(deployMode) ?
 360                  StreamExecutionEnvironment.getExecutionEnvironment() :
 361                  new MyLocalStreamEnvironment();
 362  
 363          StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, confProperties);
 364          return env;
 365      }
 366  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 367 +    private static StreamTableEnvironment getStreamTableEnv(StreamExecutionEnvironment env, Properties confProperties) {"> 367 +    private static StreamTableEnvironment getStreamTableEnv(StreamExecutionEnvironment env, Properties confPropertüîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 368 +        // use blink and streammode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 369 +        EnvironmentSettings settings = EnvironmentSettings.newInstance()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 370 +                .useBlinkPlanner()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 371 +                .inStreamingMode()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +                .build();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 373 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 374 +        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env, settings);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 375 +        StreamEnvConfigManager.streamTableEnvironmentStateTTLConfig(tableEnv, confProperties);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +        return tableEnv;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +</span>
 380      public static void setLogLevel(ParamsInfo paramsInfo){
 381          String logLevel = paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);
 382          if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){
 383              return;
 384          }
 385          ChangeLogLevelProcess logLevelProcess = new ChangeLogLevelProcess();
 386          logLevelProcess.process(logLevel);
 387      }
 388  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.exec;
  20  
  21  import com.aiweiergou.tool.logger.api.ChangeLogLevelProcess;
  22  import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  23  import com.dtstack.flink.sql.config.CalciteConfig;
  24  import com.dtstack.flink.sql.constrant.ConfigConstrant;
  25  import com.dtstack.flink.sql.enums.ClusterMode;
  26  import com.dtstack.flink.sql.enums.ECacheType;
  27  import com.dtstack.flink.sql.enums.EPluginLoadMode;
  28  import com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;
  29  import com.dtstack.flink.sql.environment.StreamEnvConfigManager;
  30  import com.dtstack.flink.sql.function.FunctionManager;
  31  import com.dtstack.flink.sql.option.OptionParser;
  32  import com.dtstack.flink.sql.option.Options;
  33  import com.dtstack.flink.sql.parser.CreateFuncParser;
  34  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  35  import com.dtstack.flink.sql.parser.InsertSqlParser;
  36  import com.dtstack.flink.sql.parser.SqlParser;
  37  import com.dtstack.flink.sql.parser.SqlTree;
  38  import com.dtstack.flink.sql.side.SideSqlExec;
  39  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  40  import com.dtstack.flink.sql.sink.StreamSinkFactory;
  41  import com.dtstack.flink.sql.source.StreamSourceFactory;
  42  import com.dtstack.flink.sql.table.AbstractSourceTableInfo;
  43  import com.dtstack.flink.sql.table.AbstractTableInfo;
  44  import com.dtstack.flink.sql.table.AbstractTargetTableInfo;
  45  import com.dtstack.flink.sql.util.DtStringUtil;
  46  import com.dtstack.flink.sql.util.PluginUtil;
  47  import com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;
  48  import com.fasterxml.jackson.databind.ObjectMapper;
  49  import com.google.common.base.Preconditions;
  50  import com.google.common.base.Strings;
  51  import com.google.common.collect.Lists;
  52  import com.google.common.collect.Maps;
  53  import com.google.common.collect.Sets;
  54  import org.apache.calcite.sql.SqlInsert;
  55  import org.apache.calcite.sql.SqlNode;
  56  import org.apache.commons.io.Charsets;
  57  import org.apache.commons.lang3.StringUtils;
  58  import org.apache.flink.api.common.typeinfo.TypeInformation;
  59  import org.apache.flink.api.java.tuple.Tuple2;
  60  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  61  import org.apache.flink.streaming.api.datastream.DataStream;
  62  import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  63  import org.apache.flink.table.api.StreamQueryConfig;

  64  import org.apache.flink.table.api.Table;
  65  import org.apache.flink.table.api.TableEnvironment;
  66  import org.apache.flink.table.api.java.StreamTableEnvironment;
  67  import org.apache.flink.table.sinks.TableSink;
  68  import org.apache.flink.types.Row;
  69  import org.slf4j.Logger;
  70  import org.slf4j.LoggerFactory;
  71  
  72  import java.io.File;
  73  import java.lang.reflect.InvocationTargetException;
  74  import java.net.URL;
  75  import java.net.URLClassLoader;
  76  import java.net.URLDecoder;
  77  import java.util.Arrays;
  78  import java.util.List;
  79  import java.util.Map;
  80  import java.util.Properties;
  81  import java.util.Set;
  82  
  83  /**
  84   *  ‰ªªÂä°ÊâßË°åÊó∂ÁöÑÊµÅÁ®ãÊñπÊ≥ï
  85   * Date: 2020/2/17
  86   * Company: www.dtstack.com
  87   * @author maqi
  88   */
  89  public class ExecuteProcessHelper {
  90  
  91      private static final String CLASS_FILE_NAME_FMT = &quot;class_path_%d&quot;;
  92      private static final Logger LOG = LoggerFactory.getLogger(ExecuteProcessHelper.class);
  93      private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  94  
  95  
  96      public static ParamsInfo parseParams(String[] args) throws Exception {
  97          LOG.info(&quot;------------program params-------------------------&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -        System.out.println(&quot;------------program params-------------------------&quot;);</span>
  99          Arrays.stream(args).forEach(arg -&gt; LOG.info(&quot;{}&quot;, arg));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -        Arrays.stream(args).forEach(System.out::println);</span>
 101          LOG.info(&quot;-------------------------------------------&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -        System.out.println(&quot;----------------------------------------&quot;);</span>
 103  
 104          OptionParser optionParser = new OptionParser(args);
 105          Options options = optionParser.getOptions();
 106  
 107          String sql = URLDecoder.decode(options.getSql(), Charsets.UTF_8.name());
 108          String name = options.getName();
 109          String localSqlPluginPath = options.getLocalSqlPluginPath();
 110          String remoteSqlPluginPath = options.getRemoteSqlPluginPath();
 111          String pluginLoadMode = options.getPluginLoadMode();
 112          String deployMode = options.getMode();
 113          String logLevel = options.getLogLevel();
 114  
 115          Preconditions.checkArgument(checkRemoteSqlPluginPath(remoteSqlPluginPath, deployMode, pluginLoadMode),
 116                  &quot;Non-local mode or shipfile deployment mode, remoteSqlPluginPath is required&quot;);
 117          String confProp = URLDecoder.decode(options.getConfProp(), Charsets.UTF_8.toString());
 118          Properties confProperties = PluginUtil.jsonStrToObject(confProp, Properties.class);
 119  
 120          List&lt;URL&gt; jarUrlList = getExternalJarUrls(options.getAddjar());
 121  
 122          return ParamsInfo.builder()
 123                  .setSql(sql)
 124                  .setName(name)
 125                  .setLocalSqlPluginPath(localSqlPluginPath)
 126                  .setRemoteSqlPluginPath(remoteSqlPluginPath)
 127                  .setPluginLoadMode(pluginLoadMode)
 128                  .setDeployMode(deployMode)
 129                  .setConfProp(confProperties)
 130                  .setJarUrlList(jarUrlList)
 131                  .build();
 132  
 133      }
 134  
 135      /**
 136       *   ÈùûlocalÊ®°ÂºèÊàñËÄÖshipfileÈÉ®ÁΩ≤Ê®°ÂºèÔºåremoteSqlPluginPathÂøÖÂ°´
 137       * @param remoteSqlPluginPath
 138       * @param deployMode
 139       * @param pluginLoadMode
 140       * @return
 141       */
<abbr title=" 142      public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String pluginLoadMode) {"> 142      public static boolean checkRemoteSqlPluginPath(String remoteSqlPluginPath, String deployMode, String pluginLoaüîµ</abbr>
 143          if (StringUtils.isEmpty(remoteSqlPluginPath)) {
 144              return StringUtils.equalsIgnoreCase(pluginLoadMode, EPluginLoadMode.SHIPFILE.name())
 145                      || StringUtils.equalsIgnoreCase(deployMode, ClusterMode.local.name());
 146          }
 147          return true;
 148      }
 149  
 150  
 151      public static StreamExecutionEnvironment getStreamExecution(ParamsInfo paramsInfo) throws Exception {
<abbr title=" 152          StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), paramsInfo.getDeployMode());"> 152          StreamExecutionEnvironment env = ExecuteProcessHelper.getStreamExeEnv(paramsInfo.getConfProp(), paramsInfoüîµ</abbr>
 153          StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);
<abbr title=" 154          StreamQueryConfig streamQueryConfig = StreamEnvConfigManager.getStreamQueryConfig(tableEnv, paramsInfo.getConfProp());"> 154          StreamQueryConfig streamQueryConfig = StreamEnvConfigManager.getStreamQueryConfig(tableEnv, paramsInfo.getüîµ</abbr>

 155  
 156          SqlParser.setLocalSqlPluginRoot(paramsInfo.getLocalSqlPluginPath());
 157          SqlTree sqlTree = SqlParser.parseSql(paramsInfo.getSql());
 158  
 159          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap = Maps.newHashMap();
 160          Map&lt;String, Table&gt; registerTableCache = Maps.newHashMap();
 161  
 162          //register udf
 163          ExecuteProcessHelper.registerUserDefinedFunction(sqlTree, paramsInfo.getJarUrlList(), tableEnv);
 164          //register table schema
<abbr title=" 165          Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.getLocalSqlPluginPath(),"> 165          Set&lt;URL&gt; classPathSets = ExecuteProcessHelper.registerTable(sqlTree, env, tableEnv, paramsInfo.getLocalSqlüîµ</abbr>
<abbr title=" 166                  paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registerTableCache);"> 166                  paramsInfo.getRemoteSqlPluginPath(), paramsInfo.getPluginLoadMode(), sideTableMap, registerTableCaüîµ</abbr>
 167          // cache classPathSets
 168          ExecuteProcessHelper.registerPluginUrlToCachedFile(env, classPathSets);
 169  
<abbr title=" 170          ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, registerTableCache, streamQueryConfig);"> 170          ExecuteProcessHelper.sqlTranslation(paramsInfo.getLocalSqlPluginPath(), tableEnv, sqlTree, sideTableMap, rüîµ</abbr>

 171  
 172          if (env instanceof MyLocalStreamEnvironment) {
 173              ((MyLocalStreamEnvironment) env).setClasspaths(ClassLoaderManager.getClassPath());
 174          }
 175          return env;
 176      }
 177  
 178  
 179      public static List&lt;URL&gt; getExternalJarUrls(String addJarListStr) throws java.io.IOException {
 180          List&lt;URL&gt; jarUrlList = Lists.newArrayList();
 181          if (Strings.isNullOrEmpty(addJarListStr)) {
 182              return jarUrlList;
 183          }
 184  
<abbr title=" 185          List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.UTF_8.name()), List.class);"> 185          List&lt;String&gt; addJarFileList = OBJECT_MAPPER.readValue(URLDecoder.decode(addJarListStr, Charsets.UTF_8.nameüîµ</abbr>
 186          //Get External jar to load
 187          for (String addJarPath : addJarFileList) {
 188              jarUrlList.add(new File(addJarPath).toURI().toURL());
 189          }
 190          return jarUrlList;
 191      }
 192  
 193      private static void sqlTranslation(String localSqlPluginPath,
 194                                         StreamTableEnvironment tableEnv,
 195                                         SqlTree sqlTree,Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 196                                         Map&lt;String, Table&gt; registerTableCache,
 197                                         StreamQueryConfig queryConfig) throws Exception {

 198  
 199          SideSqlExec sideSqlExec = new SideSqlExec();
 200          sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);
 201          for (CreateTmpTableParser.SqlParserResult result : sqlTree.getTmpSqlList()) {
<abbr title=" 202              sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, result);"> 202              sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, result)üîµ</abbr>

 203          }
 204  
 205          for (InsertSqlParser.SqlParseResult result : sqlTree.getExecSqlList()) {
 206              if (LOG.isInfoEnabled()) {
 207                  LOG.info(&quot;exe-sql:\n&quot; + result.getExecSql());
 208              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -</span>
 210              boolean isSide = false;
 211              for (String tableName : result.getTargetTableList()) {
 212                  if (sqlTree.getTmpTableMap().containsKey(tableName)) {
 213                      CreateTmpTableParser.SqlParserResult tmp = sqlTree.getTmpTableMap().get(tableName);
 214                      String realSql = DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &quot;`&quot;, &quot;&quot;);
 215  
<abbr title=" 216                      SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfig.MYSQL_LEX_CONFIG).parseStmt();"> 216                      SqlNode sqlNode = org.apache.calcite.sql.parser.SqlParser.create(realSql, CalciteConfig.MYSQL_üîµ</abbr>
 217                      String tmpSql = ((SqlInsert) sqlNode).getSource().toString();
 218                      tmp.setExecSql(tmpSql);
<abbr title=" 219                      sideSqlExec.exec(tmp.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, tmp);"> 219                      sideSqlExec.exec(tmp.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, tmüîµ</abbr>

 220                  } else {
 221                      for (String sourceTable : result.getSourceTableList()) {
 222                          if (sideTableMap.containsKey(sourceTable)) {
 223                              isSide = true;
 224                              break;
 225                          }
 226                      }
 227                      if (isSide) {
 228                          //sql-dimensional table contains the dimension table of execution
<abbr title=" 229                          sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConfig, null);"> 229                          sideSqlExec.exec(result.getExecSql(), sideTableMap, tableEnv, registerTableCache, queryConüîµ</abbr>

 230                      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -                        System.out.println(&quot;----------exec sql without dimension join-----------&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -                        System.out.println(&quot;----------real sql exec is--------------------------&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -                        System.out.println(result.getExecSql());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +                        LOG.info(&quot;----------exec sql without dimension join-----------&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +                        LOG.info(&quot;----------real sql exec is--------------------------\n{}&quot;, result.getExecSql());</span>
 236                          FlinkSQLExec.sqlUpdate(tableEnv, result.getExecSql(), queryConfig);

 237                          if (LOG.isInfoEnabled()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -                            System.out.println();</span>
 239                              LOG.info(&quot;exec sql: &quot; + result.getExecSql());
 240                          }
 241                      }
 242                  }
 243              }
 244          }
 245      }
 246  
<abbr title=" 247      public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironment tableEnv)"> 247      public static void registerUserDefinedFunction(SqlTree sqlTree, List&lt;URL&gt; jarUrlList, TableEnvironment tableEnüîµ</abbr>
 248              throws IllegalAccessException, InvocationTargetException {
 249          // udfÂíåtableEnvÈ°ªÁî±Âêå‰∏Ä‰∏™Á±ªÂä†ËΩΩÂô®Âä†ËΩΩ
 250          ClassLoader levelClassLoader = tableEnv.getClass().getClassLoader();
 251          URLClassLoader classLoader = null;
 252          List&lt;CreateFuncParser.SqlParserResult&gt; funcList = sqlTree.getFunctionList();
 253          for (CreateFuncParser.SqlParserResult funcInfo : funcList) {
 254              //classloader
 255              if (classLoader == null) {
 256                  classLoader = ClassLoaderManager.loadExtraJar(jarUrlList, (URLClassLoader) levelClassLoader);
 257              }
<abbr title=" 258              FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), tableEnv, classLoader);"> 258              FunctionManager.registerUDF(funcInfo.getType(), funcInfo.getClassName(), funcInfo.getName(), tableEnv,üîµ</abbr>
 259          }
 260      }
 261  
 262      /**
 263       *    ÂêëFlinkÊ≥®ÂÜåÊ∫êË°®ÂíåÁªìÊûúË°®ÔºåËøîÂõûÊâßË°åÊó∂Êèí‰ª∂ÂåÖÁöÑÂÖ®Ë∑ØÂæÑ
 264       * @param sqlTree
 265       * @param env
 266       * @param tableEnv
 267       * @param localSqlPluginPath
 268       * @param remoteSqlPluginPath
 269       * @param pluginLoadMode   Êèí‰ª∂Âä†ËΩΩÊ®°Âºè classpath or shipfile
 270       * @param sideTableMap
 271       * @param registerTableCache
 272       * @return
 273       * @throws Exception
 274       */
<abbr title=" 275      public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnvironment tableEnv, String localSqlPluginPath,"> 275      public static Set&lt;URL&gt; registerTable(SqlTree sqlTree, StreamExecutionEnvironment env, StreamTableEnvironment tüîµ</abbr>
<abbr title=" 276                                           String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, Map&lt;String, Table&gt; registerTableCache) throws Exception {"> 276                                           String remoteSqlPluginPath, String pluginLoadMode, Map&lt;String, AbstractSiüîµ</abbr>
 277          Set&lt;URL&gt; pluginClassPatshSets = Sets.newHashSet();
 278          WaterMarkerAssigner waterMarkerAssigner = new WaterMarkerAssigner();
 279          for (AbstractTableInfo tableInfo : sqlTree.getTableInfoMap().values()) {
 280  
 281              if (tableInfo instanceof AbstractSourceTableInfo) {
 282  
 283                  AbstractSourceTableInfo sourceTableInfo = (AbstractSourceTableInfo) tableInfo;
<abbr title=" 284                  Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqlPluginPath);"> 284                  Table table = StreamSourceFactory.getStreamSource(sourceTableInfo, env, tableEnv, localSqlPluginPaüîµ</abbr>
 285                  tableEnv.registerTable(sourceTableInfo.getAdaptName(), table);
<abbr title=" 286                  //Note --- parameter conversion function can not be used inside a function of the type of polymerization"> 286                  //Note --- parameter conversion function can not be used inside a function of the type of polymeriüîµ</abbr>
 287                  //Create table in which the function is arranged only need adaptation sql
 288                  String adaptSql = sourceTableInfo.getAdaptSelectSql();
 289                  Table adaptTable = adaptSql == null ? table : tableEnv.sqlQuery(adaptSql);
 290  
<abbr title=" 291                  RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTable.getSchema().getFieldNames());"> 291                  RowTypeInfo typeInfo = new RowTypeInfo(adaptTable.getSchema().getFieldTypes(), adaptTable.getSchemüîµ</abbr>
 292                  DataStream adaptStream = tableEnv.toRetractStream(adaptTable, typeInfo)
 293                          .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; {
 294                              return f0.f1;
 295                          })
 296                          .returns(typeInfo);

 297  
 298                  String fields = String.join(&quot;,&quot;, typeInfo.getFieldNames());
 299  
 300                  if (waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) {
 301                      adaptStream = waterMarkerAssigner.assignWaterMarker(adaptStream, typeInfo, sourceTableInfo);
 302                      fields += &quot;,ROWTIME.ROWTIME&quot;;
 303                  } else {
 304                      fields += &quot;,PROCTIME.PROCTIME&quot;;
 305                  }
 306  
 307                  Table regTable = tableEnv.fromDataStream(adaptStream, fields);
 308                  tableEnv.registerTable(tableInfo.getName(), regTable);
 309                  if (LOG.isInfoEnabled()) {
 310                      LOG.info(&quot;registe table {} success.&quot;, tableInfo.getName());
 311                  }
 312                  registerTableCache.put(tableInfo.getName(), regTable);
 313  
<abbr title=" 314                  URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractSourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 314                  URL sourceTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), Abstractüîµ</abbr>
 315                  pluginClassPatshSets.add(sourceTablePathUrl);
 316              } else if (tableInfo instanceof AbstractTargetTableInfo) {
 317  
<abbr title=" 318                  TableSink tableSink = StreamSinkFactory.getTableSink((AbstractTargetTableInfo) tableInfo, localSqlPluginPath);"> 318                  TableSink tableSink = StreamSinkFactory.getTableSink((AbstractTargetTableInfo) tableInfo, localSqlüîµ</abbr>
 319                  TypeInformation[] flinkTypes = FunctionManager.transformTypes(tableInfo.getFieldClasses());
 320                  tableEnv.registerTableSink(tableInfo.getName(), tableInfo.getFields(), flinkTypes, tableSink);
 321  
<abbr title=" 322                  URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractTargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 322                  URL sinkTablePathUrl = PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), AbstractTaüîµ</abbr>
 323                  pluginClassPatshSets.add(sinkTablePathUrl);
 324              } else if (tableInfo instanceof AbstractSideTableInfo) {
<abbr title=" 325                  String sideOperator = ECacheType.ALL.name().equals(((AbstractSideTableInfo) tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;"> 325                  String sideOperator = ECacheType.ALL.name().equals(((AbstractSideTableInfo) tableInfo).getCacheTypüîµ</abbr>
 326                  sideTableMap.put(tableInfo.getName(), (AbstractSideTableInfo) tableInfo);
 327  
<abbr title=" 328                  URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperator, AbstractSideTableInfo.TARGET_SUFFIX, localSqlPluginPath, remoteSqlPluginPath, pluginLoadMode);"> 328                  URL sideTablePathUrl = PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), sideOperator, Abstrüîµ</abbr>
 329                  pluginClassPatshSets.add(sideTablePathUrl);
 330              } else {
 331                  throw new RuntimeException(&quot;not support table type:&quot; + tableInfo.getType());
 332              }
 333          }
 334          return pluginClassPatshSets;
 335      }
 336  
 337      /**
 338       *   perjobÊ®°ÂºèÂ∞Üjob‰æùËµñÁöÑÊèí‰ª∂ÂåÖË∑ØÂæÑÂ≠òÂÇ®Âà∞cacheFileÔºåÂú®Â§ñÂõ¥Â∞ÜÊèí‰ª∂ÂåÖË∑ØÂæÑ‰º†ÈÄíÁªôjobgraph
 339       * @param env
 340       * @param classPathSet
 341       */
 342      public static void registerPluginUrlToCachedFile(StreamExecutionEnvironment env, Set&lt;URL&gt; classPathSet) {
 343          int i = 0;
 344          for (URL url : classPathSet) {
 345              String classFileName = String.format(CLASS_FILE_NAME_FMT, i);
 346              env.registerCachedFile(url.getPath(), classFileName, true);
 347              i++;
 348          }
 349      }
 350  
<abbr title=" 351      public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployMode) throws Exception {"> 351      public static StreamExecutionEnvironment getStreamExeEnv(Properties confProperties, String deployMode) throws üîµ</abbr>
 352          StreamExecutionEnvironment env = !ClusterMode.local.name().equals(deployMode) ?
 353                  StreamExecutionEnvironment.getExecutionEnvironment() :
 354                  new MyLocalStreamEnvironment();
 355  
 356          StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, confProperties);
 357          return env;
 358      }
 359  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +</span>












 361      public static void setLogLevel(ParamsInfo paramsInfo){
 362          String logLevel = paramsInfo.getConfProp().getProperty(ConfigConstrant.LOG_LEVEL_KEY);
 363          if(org.apache.commons.lang3.StringUtils.isBlank(logLevel)){
 364              return;
 365          }
 366          ChangeLogLevelProcess logLevelProcess = new ChangeLogLevelProcess();
 367          logLevelProcess.process(logLevel);
 368      }
 369  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            