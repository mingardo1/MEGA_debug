<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>73 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.content.Context;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import android.util.SparseArray;\n&#x27;
                         &#x27;import com.arialyy.aria.core.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.concurrent.ExecutorService;\n&#x27;
                         &#x27;import java.util.concurrent.Executors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2015/8/25.\n&#x27;
                         &#x27; * 下载工具类\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class DownloadUtil implements IDownloadUtil, &#x27;
                         &#x27;Runnable {\n&#x27;
                         &#x27;  private static final String TAG = &quot;DownloadUtil&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 线程数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private final int THREAD_NUM;\n&#x27;
                         &#x27;  //下载监听\n&#x27;
                         &#x27;  private IDownloadListener mListener;\n&#x27;
                         &#x27;  private int mConnectTimeOut = 5000 * 4; //连接超时时间\n&#x27;
                         &#x27;  private int mReadTimeOut = 5000 * 20; //流读取的超时时间\n&#x27;
                         &#x27;  private boolean isNewTask = true;\n&#x27;
                         &#x27;  private boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;  private Context mContext;\n&#x27;
                         &#x27;  private DownloadEntity mDownloadEntity;\n&#x27;
                         &#x27;  private ExecutorService mFixedThreadPool;\n&#x27;
                         &#x27;  private File mDownloadFile; //下载的文件\n&#x27;
                         &#x27;  private File mConfigFile;//下载信息配置文件\n&#x27;
                         &#x27;  private SparseArray&lt;Runnable&gt; mTask = new &#x27;
                         &#x27;SparseArray&lt;&gt;();\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public DownloadUtil(Context context, &#x27;
                         &#x27;DownloadEntity entity, IDownloadListener &#x27;
                         &#x27;downloadListener) {\n&#x27;
                         &#x27;    this(context, entity, downloadListener, 3);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  DownloadUtil(Context context, DownloadEntity &#x27;
                         &#x27;entity, IDownloadListener downloadListener,\n&#x27;
                         &#x27;      int threadNum) {\n&#x27;
                         &#x27;    mContext = context.getApplicationContext();\n&#x27;
                         &#x27;    mDownloadEntity = entity;\n&#x27;
                         &#x27;    mListener = downloadListener;\n&#x27;
                         &#x27;    THREAD_NUM = threadNum;\n&#x27;
                         &#x27;    mFixedThreadPool = &#x27;
                         &#x27;Executors.newFixedThreadPool(Integer.MAX_VALUE);\n&#x27;
                         &#x27;    mConstance = new &#x27;
                         &#x27;DownloadStateConstance(THREAD_NUM);\n&#x27;
                         &#x27;    init();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void init() {\n&#x27;
                         &#x27;    mDownloadFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;    //读取已完成的线程数\n&#x27;
                         &#x27;    mConfigFile = new File(\n&#x27;
                         &#x27;        mContext.getFilesDir().getPath() + &quot;/temp/&quot; &#x27;
                         &#x27;+ mDownloadFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      if (!mConfigFile.exists()) { //记录文件被删除，则重新下载\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;CommonUtil.createFile(mConfigFile.getPath());\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = !mDownloadFile.exists();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      e.printStackTrace();\n&#x27;
                         &#x27;      failDownload(&quot;下载失败，记录文件被删除&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public IDownloadListener getListener() {\n&#x27;
                         &#x27;    return mListener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置连接超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setConnectTimeOut(int timeOut) {\n&#x27;
                         &#x27;    mConnectTimeOut = timeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置流读取的超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setReadTimeOut(int readTimeOut) {\n&#x27;
                         &#x27;    mReadTimeOut = readTimeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前下载位置\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public long getCurrentLocation() {\n&#x27;
                         &#x27;    return mConstance.CURRENT_LOCATION;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean isDownloading() {\n&#x27;
                         &#x27;    return mConstance.isDownloading;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void cancelDownload() {\n&#x27;
                         &#x27;    mConstance.isCancel = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.cancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void stopDownload() {\n&#x27;
                         &#x27;    mConstance.isStop = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.stop();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除下载记录文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delConfigFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      File config =\n&#x27;
                         &#x27;          new File(mContext.getFilesDir().getPath() &#x27;
                         &#x27;+ &quot;/temp/&quot; + dFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;      if (config.exists()) {\n&#x27;
                         &#x27;        config.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除temp文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delTempFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      if (dFile.exists()) {\n&#x27;
                         &#x27;        dFile.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 多线程断点续传下载文件，开始下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void startDownload() {\n&#x27;
                         &#x27;    mConstance.cleanState();\n&#x27;
                         &#x27;    mListener.onPre();\n&#x27;
                         &#x27;    new Thread(this).start();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void resumeDownload() {\n&#x27;
                         &#x27;    startDownload();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void failDownload(String msg) {\n&#x27;
                         &#x27;    Log.e(TAG, msg);\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    stopDownload();\n&#x27;
                         &#x27;    mListener.onFail();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mDownloadEntity.getDownloadUrl());\n&#x27;
                         &#x27;      HttpURLConnection conn = &#x27;
                         &#x27;ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                         &#x27;+ &quot;-&quot;);\n&#x27;
                         &#x27;      conn.setConnectTimeout(mConnectTimeOut * 4);\n&#x27;
                         &#x27;      conn.connect();\n&#x27;
                         &#x27;      int len = conn.getContentLength();\n&#x27;
                         &#x27;      //if (len &lt; 0) {  //网络被劫持时会出现这个问题\n&#x27;
                         &#x27;      //  failDownload(&quot;下载失败，网络被劫持&quot;);\n&#x27;
                         &#x27;      //  return;\n&#x27;
                         &#x27;      //}\n&#x27;
                         &#x27;      int code = conn.getResponseCode();\n&#x27;
                         &#x27;      &#x27;
                         &#x27;//https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\n&#x27;
                         &#x27;      //206支持断点\n&#x27;
                         &#x27;      if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                         &#x27;        isSupportBreakpoint = true;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(true);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == HttpURLConnection.HTTP_OK &#x27;
                         &#x27;|| len &lt; 0) {\n&#x27;
                         &#x27;        //在conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; &#x27;
                         &#x27;+ 0 + &quot;-&quot;);下，200为不支持断点状态\n&#x27;
                         &#x27;        if (len &lt; 0) {\n&#x27;
                         &#x27;          failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，文件长度小于0&quot;);\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        isSupportBreakpoint = false;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(false);\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载链接不支持断点下载&quot;);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == &#x27;
                         &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，错误码：404&quot;);\n&#x27;
                         &#x27;        //mListener.onCancel();\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &quot;】下载失败，错误码：&quot; + &#x27;
                         &#x27;code);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      failDownload(&quot;下载失败【downloadUrl:&quot;\n&#x27;
                         &#x27;          + mDownloadEntity.getDownloadUrl()\n&#x27;
                         &#x27;          + &quot;】\\n【filePath:&quot;\n&#x27;
                         &#x27;          + mDownloadFile.getPath()\n&#x27;
                         &#x27;          + &quot;】&quot;\n&#x27;
                         &#x27;          + CommonUtil.getPrintException(e));\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理断点\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBreakpoint(HttpURLConnection &#x27;
                         &#x27;conn) throws IOException {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    //不支持断点只能单线程下载\n&#x27;
                         &#x27;    if (!isSupportBreakpoint) {\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      long len = conn.getContentLength();;\n&#x27;
                         &#x27;      entity.FILE_SIZE = len;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = 0;\n&#x27;
                         &#x27;      entity.START_LOCATION = 0;\n&#x27;
                         &#x27;      entity.END_LOCATION = entity.FILE_SIZE;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      mListener.onPostPre(len);\n&#x27;
                         &#x27;      mListener.onStart(0);\n&#x27;
                         &#x27;      return;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int fileLength = conn.getContentLength();\n&#x27;
                         &#x27;    //必须建一个文件\n&#x27;
                         &#x27;    CommonUtil.createFile(mDownloadFile.getPath());\n&#x27;
                         &#x27;    //RandomAccessFile file = new &#x27;
                         &#x27;RandomAccessFile(mDownloadFile.getPath(), &quot;rwd&quot;);\n&#x27;
                         &#x27;    ////设置文件长度\n&#x27;
                         &#x27;    //file.setLength(fileLength);\n&#x27;
                         &#x27;    BufferedRandomAccessFile file =\n&#x27;
                         &#x27;        new &#x27;
                         &#x27;BufferedRandomAccessFile(mDownloadFile.getPath(), &#x27;
                         &#x27;&quot;rwd&quot;, 8192);\n&#x27;
                         &#x27;    //设置文件长度\n&#x27;
                         &#x27;    file.setLength(fileLength);\n&#x27;
                         &#x27;    mListener.onPostPre(fileLength);\n&#x27;
                         &#x27;    //分配每条线程的下载区间\n&#x27;
                         &#x27;    Properties pro = null;\n&#x27;
                         &#x27;    pro = CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;    if (pro.isEmpty()) {\n&#x27;
                         &#x27;      isNewTask = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;        if (pro.getProperty(mDownloadFile.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + i) == null) {\n&#x27;
                         &#x27;          Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;          if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(state + &quot;&quot;) == 1) {\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          isNewTask = true;\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int blockSize = fileLength / THREAD_NUM;\n&#x27;
                         &#x27;    int[] recordL = new int[THREAD_NUM];\n&#x27;
                         &#x27;    int rl = 0;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      recordL[i] = -1;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      if (state != null &amp;&amp; Integer.parseInt(state + &#x27;
                         &#x27;&quot;&quot;) == 1) {  //该线程已经完成\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += endL - &#x27;
                         &#x27;startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_已经下载完成 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        mConstance.STOP_NUM++;\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          if (mConfigFile.exists()) {\n&#x27;
                         &#x27;            mConfigFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        continue;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //分配下载位置\n&#x27;
                         &#x27;      Object record = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_record_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      //如果有记录，则恢复下载\n&#x27;
                         &#x27;      if (!isNewTask &amp;&amp; record != null &amp;&amp; &#x27;
                         &#x27;Long.parseLong(record + &quot;&quot;) &gt; 0) {\n&#x27;
                         &#x27;        Long r = Long.parseLong(record + &quot;&quot;);\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += r - startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_恢复下载 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mListener.onChildResume(r);\n&#x27;
                         &#x27;        startL = r;\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (isNewTask) {\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (i == (THREAD_NUM - 1)) {\n&#x27;
                         &#x27;        //如果整个文件的大小不为线程个数的整数倍，则最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        endL = fileLength;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      entity.FILE_SIZE = fileLength;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = i;\n&#x27;
                         &#x27;      entity.START_LOCATION = startL;\n&#x27;
                         &#x27;      entity.END_LOCATION = endL;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mTask.put(i, task);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mConstance.CURRENT_LOCATION &gt; 0) {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onResume(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onStart(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int l : recordL) {\n&#x27;
                         &#x27;      if (l == -1) continue;\n&#x27;
                         &#x27;      Runnable task = mTask.get(l);\n&#x27;
                         &#x27;      if (task != null &amp;&amp; &#x27;
                         &#x27;!mFixedThreadPool.isShutdown()) {\n&#x27;
                         &#x27;        mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 子线程下载信息类\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  final static class ConfigEntity {\n&#x27;
                         &#x27;    //文件大小\n&#x27;
                         &#x27;    long FILE_SIZE;\n&#x27;
                         &#x27;    String DOWNLOAD_URL;\n&#x27;
                         &#x27;    int THREAD_ID;\n&#x27;
                         &#x27;    long START_LOCATION;\n&#x27;
                         &#x27;    long END_LOCATION;\n&#x27;
                         &#x27;    File TEMP_FILE;\n&#x27;
                         &#x27;    boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;    String CONFIG_FILE_PATH;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.content.Context;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import android.util.SparseArray;\n&#x27;
                         &#x27;import com.arialyy.aria.core.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.concurrent.ExecutorService;\n&#x27;
                         &#x27;import java.util.concurrent.Executors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2015/8/25.\n&#x27;
                         &#x27; * 下载工具类\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class DownloadUtil implements IDownloadUtil, &#x27;
                         &#x27;Runnable {\n&#x27;
                         &#x27;  private static final String TAG = &quot;DownloadUtil&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 线程数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private final int THREAD_NUM;\n&#x27;
                         &#x27;  //下载监听\n&#x27;
                         &#x27;  private IDownloadListener mListener;\n&#x27;
                         &#x27;  private int mConnectTimeOut = 5000 * 4; //连接超时时间\n&#x27;
                         &#x27;  private int mReadTimeOut = 5000 * 20; //流读取的超时时间\n&#x27;
                         &#x27;  private boolean isNewTask = true;\n&#x27;
                         &#x27;  private boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;  private Context mContext;\n&#x27;
                         &#x27;  private DownloadEntity mDownloadEntity;\n&#x27;
                         &#x27;  private ExecutorService mFixedThreadPool;\n&#x27;
                         &#x27;  private File mDownloadFile; //下载的文件\n&#x27;
                         &#x27;  private File mConfigFile;//下载信息配置文件\n&#x27;
                         &#x27;  private SparseArray&lt;Runnable&gt; mTask = new &#x27;
                         &#x27;SparseArray&lt;&gt;();\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public DownloadUtil(Context context, &#x27;
                         &#x27;DownloadEntity entity, IDownloadListener &#x27;
                         &#x27;downloadListener) {\n&#x27;
                         &#x27;    this(context, entity, downloadListener, 3);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  DownloadUtil(Context context, DownloadEntity &#x27;
                         &#x27;entity, IDownloadListener downloadListener,\n&#x27;
                         &#x27;      int threadNum) {\n&#x27;
                         &#x27;    mContext = context.getApplicationContext();\n&#x27;
                         &#x27;    mDownloadEntity = entity;\n&#x27;
                         &#x27;    mListener = downloadListener;\n&#x27;
                         &#x27;    THREAD_NUM = threadNum;\n&#x27;
                         &#x27;    mFixedThreadPool = &#x27;
                         &#x27;Executors.newFixedThreadPool(Integer.MAX_VALUE);\n&#x27;
                         &#x27;    mConstance = new &#x27;
                         &#x27;DownloadStateConstance(THREAD_NUM);\n&#x27;
                         &#x27;    init();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void init() {\n&#x27;
                         &#x27;    mDownloadFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;    //读取已完成的线程数\n&#x27;
                         &#x27;    mConfigFile = new File(\n&#x27;
                         &#x27;        mContext.getFilesDir().getPath() + &quot;/temp/&quot; &#x27;
                         &#x27;+ mDownloadFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      if (!mConfigFile.exists()) { //记录文件被删除，则重新下载\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;CommonUtil.createFile(mConfigFile.getPath());\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = !mDownloadFile.exists();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      e.printStackTrace();\n&#x27;
                         &#x27;      failDownload(&quot;下载失败，记录文件被删除&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public IDownloadListener getListener() {\n&#x27;
                         &#x27;    return mListener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置连接超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setConnectTimeOut(int timeOut) {\n&#x27;
                         &#x27;    mConnectTimeOut = timeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置流读取的超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setReadTimeOut(int readTimeOut) {\n&#x27;
                         &#x27;    mReadTimeOut = readTimeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前下载位置\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public long getCurrentLocation() {\n&#x27;
                         &#x27;    return mConstance.CURRENT_LOCATION;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean isDownloading() {\n&#x27;
                         &#x27;    return mConstance.isDownloading;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void cancelDownload() {\n&#x27;
                         &#x27;    mConstance.isCancel = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.cancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void stopDownload() {\n&#x27;
                         &#x27;    mConstance.isStop = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.stop();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除下载记录文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delConfigFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      File config =\n&#x27;
                         &#x27;          new File(mContext.getFilesDir().getPath() &#x27;
                         &#x27;+ &quot;/temp/&quot; + dFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;      if (config.exists()) {\n&#x27;
                         &#x27;        config.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除temp文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delTempFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      if (dFile.exists()) {\n&#x27;
                         &#x27;        dFile.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 多线程断点续传下载文件，开始下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void startDownload() {\n&#x27;
                         &#x27;    mConstance.cleanState();\n&#x27;
                         &#x27;    mListener.onPre();\n&#x27;
                         &#x27;    new Thread(this).start();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void resumeDownload() {\n&#x27;
                         &#x27;    startDownload();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void failDownload(String msg) {\n&#x27;
                         &#x27;    Log.e(TAG, msg);\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    stopDownload();\n&#x27;
                         &#x27;    mListener.onFail();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mDownloadEntity.getDownloadUrl());\n&#x27;
                         &#x27;      HttpURLConnection conn = &#x27;
                         &#x27;ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                         &#x27;+ &quot;-&quot;);\n&#x27;
                         &#x27;      conn.setConnectTimeout(mConnectTimeOut * 4);\n&#x27;
                         &#x27;      conn.connect();\n&#x27;
                         &#x27;      int len = conn.getContentLength();\n&#x27;
                         &#x27;      //if (len &lt; 0) {  //网络被劫持时会出现这个问题\n&#x27;
                         &#x27;      //  failDownload(&quot;下载失败，网络被劫持&quot;);\n&#x27;
                         &#x27;      //  return;\n&#x27;
                         &#x27;      //}\n&#x27;
                         &#x27;      int code = conn.getResponseCode();\n&#x27;
                         &#x27;      &#x27;
                         &#x27;//https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\n&#x27;
                         &#x27;      //206支持断点\n&#x27;
                         &#x27;      if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                         &#x27;        isSupportBreakpoint = true;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(true);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == HttpURLConnection.HTTP_OK &#x27;
                         &#x27;|| len &lt; 0) {\n&#x27;
                         &#x27;        //在conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; &#x27;
                         &#x27;+ 0 + &quot;-&quot;);下，200为不支持断点状态\n&#x27;
                         &#x27;        if (len &lt; 0) {\n&#x27;
                         &#x27;          failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，文件长度小于0&quot;);\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        isSupportBreakpoint = false;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(false);\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载链接不支持断点下载&quot;);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == &#x27;
                         &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，错误码：404&quot;);\n&#x27;
                         &#x27;        //mListener.onCancel();\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &quot;】下载失败，错误码：&quot; + &#x27;
                         &#x27;code);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      failDownload(&quot;下载失败【downloadUrl:&quot;\n&#x27;
                         &#x27;          + mDownloadEntity.getDownloadUrl()\n&#x27;
                         &#x27;          + &quot;】\\n【filePath:&quot;\n&#x27;
                         &#x27;          + mDownloadFile.getPath()\n&#x27;
                         &#x27;          + &quot;】&quot;\n&#x27;
                         &#x27;          + CommonUtil.getPrintException(e));\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理断点\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBreakpoint(HttpURLConnection &#x27;
                         &#x27;conn) throws IOException {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    //不支持断点只能单线程下载\n&#x27;
                         &#x27;    if (!isSupportBreakpoint) {\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      long len = conn.getContentLength();;\n&#x27;
                         &#x27;      entity.FILE_SIZE = len;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = 0;\n&#x27;
                         &#x27;      entity.START_LOCATION = 0;\n&#x27;
                         &#x27;      entity.END_LOCATION = entity.FILE_SIZE;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      mListener.onPostPre(len);\n&#x27;
                         &#x27;      mListener.onStart(0);\n&#x27;
                         &#x27;      return;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int fileLength = conn.getContentLength();\n&#x27;
                         &#x27;    //必须建一个文件\n&#x27;
                         &#x27;    CommonUtil.createFile(mDownloadFile.getPath());\n&#x27;
                         &#x27;    //RandomAccessFile file = new &#x27;
                         &#x27;RandomAccessFile(mDownloadFile.getPath(), &quot;rwd&quot;);\n&#x27;
                         &#x27;    ////设置文件长度\n&#x27;
                         &#x27;    //file.setLength(fileLength);\n&#x27;
                         &#x27;    BufferedRandomAccessFile file =\n&#x27;
                         &#x27;        new &#x27;
                         &#x27;BufferedRandomAccessFile(mDownloadFile.getPath(), &#x27;
                         &#x27;&quot;rwd&quot;, 8192);\n&#x27;
                         &#x27;    //设置文件长度\n&#x27;
                         &#x27;    file.setLength(fileLength);\n&#x27;
                         &#x27;    mListener.onPostPre(fileLength);\n&#x27;
                         &#x27;    //分配每条线程的下载区间\n&#x27;
                         &#x27;    Properties pro = null;\n&#x27;
                         &#x27;    pro = CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;    if (pro.isEmpty()) {\n&#x27;
                         &#x27;      isNewTask = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;        if (pro.getProperty(mDownloadFile.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + i) == null) {\n&#x27;
                         &#x27;          Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;          if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(state + &quot;&quot;) == 1) {\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          isNewTask = true;\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int blockSize = fileLength / THREAD_NUM;\n&#x27;
                         &#x27;    int[] recordL = new int[THREAD_NUM];\n&#x27;
                         &#x27;    int rl = 0;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      recordL[i] = -1;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      if (state != null &amp;&amp; Integer.parseInt(state + &#x27;
                         &#x27;&quot;&quot;) == 1) {  //该线程已经完成\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += endL - &#x27;
                         &#x27;startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_已经下载完成 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        mConstance.STOP_NUM++;\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          if (mConfigFile.exists()) {\n&#x27;
                         &#x27;            mConfigFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        continue;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //分配下载位置\n&#x27;
                         &#x27;      Object record = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_record_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      //如果有记录，则恢复下载\n&#x27;
                         &#x27;      if (!isNewTask &amp;&amp; record != null &amp;&amp; &#x27;
                         &#x27;Long.parseLong(record + &quot;&quot;) &gt; 0) {\n&#x27;
                         &#x27;        Long r = Long.parseLong(record + &quot;&quot;);\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += r - startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_恢复下载 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mListener.onChildResume(r);\n&#x27;
                         &#x27;        startL = r;\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (isNewTask) {\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (i == (THREAD_NUM - 1)) {\n&#x27;
                         &#x27;        //如果整个文件的大小不为线程个数的整数倍，则最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        endL = fileLength;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      entity.FILE_SIZE = fileLength;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = i;\n&#x27;
                         &#x27;      entity.START_LOCATION = startL;\n&#x27;
                         &#x27;      entity.END_LOCATION = endL;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mTask.put(i, task);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mConstance.CURRENT_LOCATION &gt; 0) {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onResume(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onStart(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int l : recordL) {\n&#x27;
                         &#x27;      if (l == -1) continue;\n&#x27;
                         &#x27;      Runnable task = mTask.get(l);\n&#x27;
                         &#x27;      if (task != null &amp;&amp; &#x27;
                         &#x27;!mFixedThreadPool.isShutdown()) {\n&#x27;
                         &#x27;        mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 子线程下载信息类\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  final static class ConfigEntity {\n&#x27;
                         &#x27;    //文件大小\n&#x27;
                         &#x27;    long FILE_SIZE;\n&#x27;
                         &#x27;    String DOWNLOAD_URL;\n&#x27;
                         &#x27;    int THREAD_ID;\n&#x27;
                         &#x27;    long START_LOCATION;\n&#x27;
                         &#x27;    long END_LOCATION;\n&#x27;
                         &#x27;    File TEMP_FILE;\n&#x27;
                         &#x27;    boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;    String CONFIG_FILE_PATH;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.content.Context;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import android.util.SparseArray;\n&#x27;
                         &#x27;import com.arialyy.aria.core.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.concurrent.ExecutorService;\n&#x27;
                         &#x27;import java.util.concurrent.Executors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2015/8/25.\n&#x27;
                         &#x27; * 下载工具类\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class DownloadUtil implements IDownloadUtil, &#x27;
                         &#x27;Runnable {\n&#x27;
                         &#x27;  private static final String TAG = &quot;DownloadUtil&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 线程数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private final int THREAD_NUM;\n&#x27;
                         &#x27;  //下载监听\n&#x27;
                         &#x27;  private IDownloadListener mListener;\n&#x27;
                         &#x27;  private int mConnectTimeOut = 5000 * 4; //连接超时时间\n&#x27;
                         &#x27;  private int mReadTimeOut = 5000 * 20; //流读取的超时时间\n&#x27;
                         &#x27;  private boolean isNewTask = true;\n&#x27;
                         &#x27;  private boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;  private Context mContext;\n&#x27;
                         &#x27;  private DownloadEntity mDownloadEntity;\n&#x27;
                         &#x27;  private ExecutorService mFixedThreadPool;\n&#x27;
                         &#x27;  private File mDownloadFile; //下载的文件\n&#x27;
                         &#x27;  private File mConfigFile;//下载信息配置文件\n&#x27;
                         &#x27;  private SparseArray&lt;Runnable&gt; mTask = new &#x27;
                         &#x27;SparseArray&lt;&gt;();\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public DownloadUtil(Context context, &#x27;
                         &#x27;DownloadEntity entity, IDownloadListener &#x27;
                         &#x27;downloadListener) {\n&#x27;
                         &#x27;    this(context, entity, downloadListener, 3);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  DownloadUtil(Context context, DownloadEntity &#x27;
                         &#x27;entity, IDownloadListener downloadListener,\n&#x27;
                         &#x27;      int threadNum) {\n&#x27;
                         &#x27;    mContext = context.getApplicationContext();\n&#x27;
                         &#x27;    mDownloadEntity = entity;\n&#x27;
                         &#x27;    mListener = downloadListener;\n&#x27;
                         &#x27;    THREAD_NUM = threadNum;\n&#x27;
                         &#x27;    mFixedThreadPool = &#x27;
                         &#x27;Executors.newFixedThreadPool(Integer.MAX_VALUE);\n&#x27;
                         &#x27;    mConstance = new &#x27;
                         &#x27;DownloadStateConstance(THREAD_NUM);\n&#x27;
                         &#x27;    init();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void init() {\n&#x27;
                         &#x27;    mDownloadFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;    //读取已完成的线程数\n&#x27;
                         &#x27;    mConfigFile = new File(\n&#x27;
                         &#x27;        mContext.getFilesDir().getPath() + &quot;/temp/&quot; &#x27;
                         &#x27;+ mDownloadFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      if (!mConfigFile.exists()) { //记录文件被删除，则重新下载\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;CommonUtil.createFile(mConfigFile.getPath());\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = !mDownloadFile.exists();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      e.printStackTrace();\n&#x27;
                         &#x27;      failDownload(&quot;下载失败，记录文件被删除&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public IDownloadListener getListener() {\n&#x27;
                         &#x27;    return mListener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置连接超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setConnectTimeOut(int timeOut) {\n&#x27;
                         &#x27;    mConnectTimeOut = timeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置流读取的超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setReadTimeOut(int readTimeOut) {\n&#x27;
                         &#x27;    mReadTimeOut = readTimeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前下载位置\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public long getCurrentLocation() {\n&#x27;
                         &#x27;    return mConstance.CURRENT_LOCATION;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean isDownloading() {\n&#x27;
                         &#x27;    return mConstance.isDownloading;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void cancelDownload() {\n&#x27;
                         &#x27;    mConstance.isCancel = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.cancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void stopDownload() {\n&#x27;
                         &#x27;    mConstance.isStop = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.stop();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除下载记录文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delConfigFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      File config =\n&#x27;
                         &#x27;          new File(mContext.getFilesDir().getPath() &#x27;
                         &#x27;+ &quot;/temp/&quot; + dFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;      if (config.exists()) {\n&#x27;
                         &#x27;        config.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除temp文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delTempFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      if (dFile.exists()) {\n&#x27;
                         &#x27;        dFile.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 多线程断点续传下载文件，开始下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void startDownload() {\n&#x27;
                         &#x27;    mConstance.cleanState();\n&#x27;
                         &#x27;    mListener.onPre();\n&#x27;
                         &#x27;    new Thread(this).start();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void resumeDownload() {\n&#x27;
                         &#x27;    startDownload();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void failDownload(String msg) {\n&#x27;
                         &#x27;    Log.e(TAG, msg);\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    stopDownload();\n&#x27;
                         &#x27;    mListener.onFail();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mDownloadEntity.getDownloadUrl());\n&#x27;
                         &#x27;      HttpURLConnection conn = &#x27;
                         &#x27;ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                         &#x27;+ &quot;-&quot;);\n&#x27;
                         &#x27;      conn.setConnectTimeout(mConnectTimeOut * 4);\n&#x27;
                         &#x27;      conn.connect();\n&#x27;
                         &#x27;      int len = conn.getContentLength();\n&#x27;
                         &#x27;      //if (len &lt; 0) {  //网络被劫持时会出现这个问题\n&#x27;
                         &#x27;      //  failDownload(&quot;下载失败，网络被劫持&quot;);\n&#x27;
                         &#x27;      //  return;\n&#x27;
                         &#x27;      //}\n&#x27;
                         &#x27;      int code = conn.getResponseCode();\n&#x27;
                         &#x27;      &#x27;
                         &#x27;//https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\n&#x27;
                         &#x27;      //206支持断点\n&#x27;
                         &#x27;      if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                         &#x27;        isSupportBreakpoint = true;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(true);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == HttpURLConnection.HTTP_OK &#x27;
                         &#x27;|| len &lt; 0) {\n&#x27;
                         &#x27;        //在conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; &#x27;
                         &#x27;+ 0 + &quot;-&quot;);下，200为不支持断点状态\n&#x27;
                         &#x27;        if (len &lt; 0) {\n&#x27;
                         &#x27;          failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，文件长度小于0&quot;);\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        isSupportBreakpoint = false;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(false);\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载链接不支持断点下载&quot;);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == &#x27;
                         &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，错误码：404&quot;);\n&#x27;
                         &#x27;        //mListener.onCancel();\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &quot;】下载失败，错误码：&quot; + &#x27;
                         &#x27;code);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      failDownload(&quot;下载失败【downloadUrl:&quot;\n&#x27;
                         &#x27;          + mDownloadEntity.getDownloadUrl()\n&#x27;
                         &#x27;          + &quot;】\\n【filePath:&quot;\n&#x27;
                         &#x27;          + mDownloadFile.getPath()\n&#x27;
                         &#x27;          + &quot;】&quot;\n&#x27;
                         &#x27;          + CommonUtil.getPrintException(e));\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理断点\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBreakpoint(HttpURLConnection &#x27;
                         &#x27;conn) throws IOException {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    //不支持断点只能单线程下载\n&#x27;
                         &#x27;    if (!isSupportBreakpoint) {\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      long len = conn.getContentLength();;\n&#x27;
                         &#x27;      entity.FILE_SIZE = len;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = 0;\n&#x27;
                         &#x27;      entity.START_LOCATION = 0;\n&#x27;
                         &#x27;      entity.END_LOCATION = entity.FILE_SIZE;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      mListener.onPostPre(len);\n&#x27;
                         &#x27;      mListener.onStart(0);\n&#x27;
                         &#x27;      return;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int fileLength = conn.getContentLength();\n&#x27;
                         &#x27;    //必须建一个文件\n&#x27;
                         &#x27;    CommonUtil.createFile(mDownloadFile.getPath());\n&#x27;
                         &#x27;    //RandomAccessFile file = new &#x27;
                         &#x27;RandomAccessFile(mDownloadFile.getPath(), &quot;rwd&quot;);\n&#x27;
                         &#x27;    ////设置文件长度\n&#x27;
                         &#x27;    //file.setLength(fileLength);\n&#x27;
                         &#x27;    BufferedRandomAccessFile file =\n&#x27;
                         &#x27;        new &#x27;
                         &#x27;BufferedRandomAccessFile(mDownloadFile.getPath(), &#x27;
                         &#x27;&quot;rwd&quot;, 8192);\n&#x27;
                         &#x27;    //设置文件长度\n&#x27;
                         &#x27;    file.setLength(fileLength);\n&#x27;
                         &#x27;    mListener.onPostPre(fileLength);\n&#x27;
                         &#x27;    //分配每条线程的下载区间\n&#x27;
                         &#x27;    Properties pro = null;\n&#x27;
                         &#x27;    pro = CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;    if (pro.isEmpty()) {\n&#x27;
                         &#x27;      isNewTask = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;        if (pro.getProperty(mDownloadFile.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + i) == null) {\n&#x27;
                         &#x27;          Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;          if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(state + &quot;&quot;) == 1) {\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          isNewTask = true;\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int blockSize = fileLength / THREAD_NUM;\n&#x27;
                         &#x27;    int[] recordL = new int[THREAD_NUM];\n&#x27;
                         &#x27;    int rl = 0;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      recordL[i] = -1;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      if (state != null &amp;&amp; Integer.parseInt(state + &#x27;
                         &#x27;&quot;&quot;) == 1) {  //该线程已经完成\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += endL - &#x27;
                         &#x27;startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_已经下载完成 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        mConstance.STOP_NUM++;\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          if (mConfigFile.exists()) {\n&#x27;
                         &#x27;            mConfigFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        continue;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //分配下载位置\n&#x27;
                         &#x27;      Object record = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_record_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      //如果有记录，则恢复下载\n&#x27;
                         &#x27;      if (!isNewTask &amp;&amp; record != null &amp;&amp; &#x27;
                         &#x27;Long.parseLong(record + &quot;&quot;) &gt; 0) {\n&#x27;
                         &#x27;        Long r = Long.parseLong(record + &quot;&quot;);\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += r - startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_恢复下载 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mListener.onChildResume(r);\n&#x27;
                         &#x27;        startL = r;\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (isNewTask) {\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (i == (THREAD_NUM - 1)) {\n&#x27;
                         &#x27;        //如果整个文件的大小不为线程个数的整数倍，则最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        endL = fileLength;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      entity.FILE_SIZE = fileLength;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = i;\n&#x27;
                         &#x27;      entity.START_LOCATION = startL;\n&#x27;
                         &#x27;      entity.END_LOCATION = endL;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mTask.put(i, task);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mConstance.CURRENT_LOCATION &gt; 0) {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onResume(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onStart(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int l : recordL) {\n&#x27;
                         &#x27;      if (l == -1) continue;\n&#x27;
                         &#x27;      Runnable task = mTask.get(l);\n&#x27;
                         &#x27;      if (task != null &amp;&amp; &#x27;
                         &#x27;!mFixedThreadPool.isShutdown()) {\n&#x27;
                         &#x27;        mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 子线程下载信息类\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  final static class ConfigEntity {\n&#x27;
                         &#x27;    //文件大小\n&#x27;
                         &#x27;    long FILE_SIZE;\n&#x27;
                         &#x27;    String DOWNLOAD_URL;\n&#x27;
                         &#x27;    int THREAD_ID;\n&#x27;
                         &#x27;    long START_LOCATION;\n&#x27;
                         &#x27;    long END_LOCATION;\n&#x27;
                         &#x27;    File TEMP_FILE;\n&#x27;
                         &#x27;    boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;    String CONFIG_FILE_PATH;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.content.Context;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import android.util.SparseArray;\n&#x27;
                         &#x27;import com.arialyy.aria.core.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.concurrent.ExecutorService;\n&#x27;
                         &#x27;import java.util.concurrent.Executors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2015/8/25.\n&#x27;
                         &#x27; * 下载工具类\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class DownloadUtil implements IDownloadUtil, &#x27;
                         &#x27;Runnable {\n&#x27;
                         &#x27;  private static final String TAG = &quot;DownloadUtil&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 线程数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private final int THREAD_NUM;\n&#x27;
                         &#x27;  //下载监听\n&#x27;
                         &#x27;  private IDownloadListener mListener;\n&#x27;
                         &#x27;  private int mConnectTimeOut = 5000 * 4; //连接超时时间\n&#x27;
                         &#x27;  private int mReadTimeOut = 5000 * 20; //流读取的超时时间\n&#x27;
                         &#x27;  private boolean isNewTask = true;\n&#x27;
                         &#x27;  private boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;  private Context mContext;\n&#x27;
                         &#x27;  private DownloadEntity mDownloadEntity;\n&#x27;
                         &#x27;  private ExecutorService mFixedThreadPool;\n&#x27;
                         &#x27;  private File mDownloadFile; //下载的文件\n&#x27;
                         &#x27;  private File mConfigFile;//下载信息配置文件\n&#x27;
                         &#x27;  private SparseArray&lt;Runnable&gt; mTask = new &#x27;
                         &#x27;SparseArray&lt;&gt;();\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public DownloadUtil(Context context, &#x27;
                         &#x27;DownloadEntity entity, IDownloadListener &#x27;
                         &#x27;downloadListener) {\n&#x27;
                         &#x27;    this(context, entity, downloadListener, 3);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  DownloadUtil(Context context, DownloadEntity &#x27;
                         &#x27;entity, IDownloadListener downloadListener,\n&#x27;
                         &#x27;      int threadNum) {\n&#x27;
                         &#x27;    mContext = context.getApplicationContext();\n&#x27;
                         &#x27;    mDownloadEntity = entity;\n&#x27;
                         &#x27;    mListener = downloadListener;\n&#x27;
                         &#x27;    THREAD_NUM = threadNum;\n&#x27;
                         &#x27;    mFixedThreadPool = &#x27;
                         &#x27;Executors.newFixedThreadPool(Integer.MAX_VALUE);\n&#x27;
                         &#x27;    mConstance = new &#x27;
                         &#x27;DownloadStateConstance(THREAD_NUM);\n&#x27;
                         &#x27;    init();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void init() {\n&#x27;
                         &#x27;    mDownloadFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;    //读取已完成的线程数\n&#x27;
                         &#x27;    mConfigFile = new File(\n&#x27;
                         &#x27;        mContext.getFilesDir().getPath() + &quot;/temp/&quot; &#x27;
                         &#x27;+ mDownloadFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      if (!mConfigFile.exists()) { //记录文件被删除，则重新下载\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;CommonUtil.createFile(mConfigFile.getPath());\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = !mDownloadFile.exists();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      e.printStackTrace();\n&#x27;
                         &#x27;      failDownload(&quot;下载失败，记录文件被删除&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public IDownloadListener getListener() {\n&#x27;
                         &#x27;    return mListener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置连接超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setConnectTimeOut(int timeOut) {\n&#x27;
                         &#x27;    mConnectTimeOut = timeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置流读取的超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setReadTimeOut(int readTimeOut) {\n&#x27;
                         &#x27;    mReadTimeOut = readTimeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前下载位置\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public long getCurrentLocation() {\n&#x27;
                         &#x27;    return mConstance.CURRENT_LOCATION;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean isDownloading() {\n&#x27;
                         &#x27;    return mConstance.isDownloading;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void cancelDownload() {\n&#x27;
                         &#x27;    mConstance.isCancel = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.cancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void stopDownload() {\n&#x27;
                         &#x27;    mConstance.isStop = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.stop();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除下载记录文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delConfigFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      File config =\n&#x27;
                         &#x27;          new File(mContext.getFilesDir().getPath() &#x27;
                         &#x27;+ &quot;/temp/&quot; + dFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;      if (config.exists()) {\n&#x27;
                         &#x27;        config.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除temp文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delTempFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      if (dFile.exists()) {\n&#x27;
                         &#x27;        dFile.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 多线程断点续传下载文件，开始下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void startDownload() {\n&#x27;
                         &#x27;    mConstance.cleanState();\n&#x27;
                         &#x27;    mListener.onPre();\n&#x27;
                         &#x27;    new Thread(this).start();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void resumeDownload() {\n&#x27;
                         &#x27;    startDownload();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void failDownload(String msg) {\n&#x27;
                         &#x27;    Log.e(TAG, msg);\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    stopDownload();\n&#x27;
                         &#x27;    mListener.onFail();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mDownloadEntity.getDownloadUrl());\n&#x27;
                         &#x27;      HttpURLConnection conn = &#x27;
                         &#x27;ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                         &#x27;+ &quot;-&quot;);\n&#x27;
                         &#x27;      conn.setConnectTimeout(mConnectTimeOut * 4);\n&#x27;
                         &#x27;      conn.connect();\n&#x27;
                         &#x27;      int len = conn.getContentLength();\n&#x27;
                         &#x27;      //if (len &lt; 0) {  //网络被劫持时会出现这个问题\n&#x27;
                         &#x27;      //  failDownload(&quot;下载失败，网络被劫持&quot;);\n&#x27;
                         &#x27;      //  return;\n&#x27;
                         &#x27;      //}\n&#x27;
                         &#x27;      int code = conn.getResponseCode();\n&#x27;
                         &#x27;      &#x27;
                         &#x27;//https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\n&#x27;
                         &#x27;      //206支持断点\n&#x27;
                         &#x27;      if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                         &#x27;        isSupportBreakpoint = true;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(true);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == HttpURLConnection.HTTP_OK &#x27;
                         &#x27;|| len &lt; 0) {\n&#x27;
                         &#x27;        //在conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; &#x27;
                         &#x27;+ 0 + &quot;-&quot;);下，200为不支持断点状态\n&#x27;
                         &#x27;        if (len &lt; 0) {\n&#x27;
                         &#x27;          failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，文件长度小于0&quot;);\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        isSupportBreakpoint = false;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(false);\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载链接不支持断点下载&quot;);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == &#x27;
                         &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，错误码：404&quot;);\n&#x27;
                         &#x27;        //mListener.onCancel();\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &quot;】下载失败，错误码：&quot; + &#x27;
                         &#x27;code);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      failDownload(&quot;下载失败【downloadUrl:&quot;\n&#x27;
                         &#x27;          + mDownloadEntity.getDownloadUrl()\n&#x27;
                         &#x27;          + &quot;】\\n【filePath:&quot;\n&#x27;
                         &#x27;          + mDownloadFile.getPath()\n&#x27;
                         &#x27;          + &quot;】&quot;\n&#x27;
                         &#x27;          + CommonUtil.getPrintException(e));\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理断点\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBreakpoint(HttpURLConnection &#x27;
                         &#x27;conn) throws IOException {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    //不支持断点只能单线程下载\n&#x27;
                         &#x27;    if (!isSupportBreakpoint) {\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      long len = conn.getContentLength();;\n&#x27;
                         &#x27;      entity.FILE_SIZE = len;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = 0;\n&#x27;
                         &#x27;      entity.START_LOCATION = 0;\n&#x27;
                         &#x27;      entity.END_LOCATION = entity.FILE_SIZE;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      mListener.onPostPre(len);\n&#x27;
                         &#x27;      mListener.onStart(0);\n&#x27;
                         &#x27;      return;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int fileLength = conn.getContentLength();\n&#x27;
                         &#x27;    //必须建一个文件\n&#x27;
                         &#x27;    CommonUtil.createFile(mDownloadFile.getPath());\n&#x27;
                         &#x27;    //RandomAccessFile file = new &#x27;
                         &#x27;RandomAccessFile(mDownloadFile.getPath(), &quot;rwd&quot;);\n&#x27;
                         &#x27;    ////设置文件长度\n&#x27;
                         &#x27;    //file.setLength(fileLength);\n&#x27;
                         &#x27;    BufferedRandomAccessFile file =\n&#x27;
                         &#x27;        new &#x27;
                         &#x27;BufferedRandomAccessFile(mDownloadFile.getPath(), &#x27;
                         &#x27;&quot;rwd&quot;, 8192);\n&#x27;
                         &#x27;    //设置文件长度\n&#x27;
                         &#x27;    file.setLength(fileLength);\n&#x27;
                         &#x27;    mListener.onPostPre(fileLength);\n&#x27;
                         &#x27;    //分配每条线程的下载区间\n&#x27;
                         &#x27;    Properties pro = null;\n&#x27;
                         &#x27;    pro = CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;    if (pro.isEmpty()) {\n&#x27;
                         &#x27;      isNewTask = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;        if (pro.getProperty(mDownloadFile.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + i) == null) {\n&#x27;
                         &#x27;          Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;          if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(state + &quot;&quot;) == 1) {\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          isNewTask = true;\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int blockSize = fileLength / THREAD_NUM;\n&#x27;
                         &#x27;    int[] recordL = new int[THREAD_NUM];\n&#x27;
                         &#x27;    int rl = 0;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      recordL[i] = -1;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      if (state != null &amp;&amp; Integer.parseInt(state + &#x27;
                         &#x27;&quot;&quot;) == 1) {  //该线程已经完成\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += endL - &#x27;
                         &#x27;startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_已经下载完成 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        mConstance.STOP_NUM++;\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          if (mConfigFile.exists()) {\n&#x27;
                         &#x27;            mConfigFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        continue;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //分配下载位置\n&#x27;
                         &#x27;      Object record = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_record_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      //如果有记录，则恢复下载\n&#x27;
                         &#x27;      if (!isNewTask &amp;&amp; record != null &amp;&amp; &#x27;
                         &#x27;Long.parseLong(record + &quot;&quot;) &gt; 0) {\n&#x27;
                         &#x27;        Long r = Long.parseLong(record + &quot;&quot;);\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += r - startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_恢复下载 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mListener.onChildResume(r);\n&#x27;
                         &#x27;        startL = r;\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (isNewTask) {\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (i == (THREAD_NUM - 1)) {\n&#x27;
                         &#x27;        //如果整个文件的大小不为线程个数的整数倍，则最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        endL = fileLength;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      entity.FILE_SIZE = fileLength;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = i;\n&#x27;
                         &#x27;      entity.START_LOCATION = startL;\n&#x27;
                         &#x27;      entity.END_LOCATION = endL;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mTask.put(i, task);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mConstance.CURRENT_LOCATION &gt; 0) {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onResume(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onStart(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int l : recordL) {\n&#x27;
                         &#x27;      if (l == -1) continue;\n&#x27;
                         &#x27;      Runnable task = mTask.get(l);\n&#x27;
                         &#x27;      if (task != null &amp;&amp; &#x27;
                         &#x27;!mFixedThreadPool.isShutdown()) {\n&#x27;
                         &#x27;        mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 子线程下载信息类\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  final static class ConfigEntity {\n&#x27;
                         &#x27;    //文件大小\n&#x27;
                         &#x27;    long FILE_SIZE;\n&#x27;
                         &#x27;    String DOWNLOAD_URL;\n&#x27;
                         &#x27;    int THREAD_ID;\n&#x27;
                         &#x27;    long START_LOCATION;\n&#x27;
                         &#x27;    long END_LOCATION;\n&#x27;
                         &#x27;    File TEMP_FILE;\n&#x27;
                         &#x27;    boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;    String CONFIG_FILE_PATH;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.content.Context;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import android.util.SparseArray;\n&#x27;
                         &#x27;import com.arialyy.aria.core.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.concurrent.ExecutorService;\n&#x27;
                         &#x27;import java.util.concurrent.Executors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2015/8/25.\n&#x27;
                         &#x27; * 下载工具类\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class DownloadUtil implements IDownloadUtil, &#x27;
                         &#x27;Runnable {\n&#x27;
                         &#x27;  private static final String TAG = &quot;DownloadUtil&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 线程数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private final int THREAD_NUM;\n&#x27;
                         &#x27;  //下载监听\n&#x27;
                         &#x27;  private IDownloadListener mListener;\n&#x27;
                         &#x27;  private int mConnectTimeOut = 5000 * 4; //连接超时时间\n&#x27;
                         &#x27;  private int mReadTimeOut = 5000 * 20; //流读取的超时时间\n&#x27;
                         &#x27;  private boolean isNewTask = true;\n&#x27;
                         &#x27;  private boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;  private Context mContext;\n&#x27;
                         &#x27;  private DownloadEntity mDownloadEntity;\n&#x27;
                         &#x27;  private ExecutorService mFixedThreadPool;\n&#x27;
                         &#x27;  private File mDownloadFile; //下载的文件\n&#x27;
                         &#x27;  private File mConfigFile;//下载信息配置文件\n&#x27;
                         &#x27;  private SparseArray&lt;Runnable&gt; mTask = new &#x27;
                         &#x27;SparseArray&lt;&gt;();\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public DownloadUtil(Context context, &#x27;
                         &#x27;DownloadEntity entity, IDownloadListener &#x27;
                         &#x27;downloadListener) {\n&#x27;
                         &#x27;    this(context, entity, downloadListener, 3);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  DownloadUtil(Context context, DownloadEntity &#x27;
                         &#x27;entity, IDownloadListener downloadListener,\n&#x27;
                         &#x27;      int threadNum) {\n&#x27;
                         &#x27;    mContext = context.getApplicationContext();\n&#x27;
                         &#x27;    mDownloadEntity = entity;\n&#x27;
                         &#x27;    mListener = downloadListener;\n&#x27;
                         &#x27;    THREAD_NUM = threadNum;\n&#x27;
                         &#x27;    mFixedThreadPool = &#x27;
                         &#x27;Executors.newFixedThreadPool(Integer.MAX_VALUE);\n&#x27;
                         &#x27;    mConstance = new &#x27;
                         &#x27;DownloadStateConstance(THREAD_NUM);\n&#x27;
                         &#x27;    init();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void init() {\n&#x27;
                         &#x27;    mDownloadFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;    //读取已完成的线程数\n&#x27;
                         &#x27;    mConfigFile = new File(\n&#x27;
                         &#x27;        mContext.getFilesDir().getPath() + &quot;/temp/&quot; &#x27;
                         &#x27;+ mDownloadFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      if (!mConfigFile.exists()) { //记录文件被删除，则重新下载\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;CommonUtil.createFile(mConfigFile.getPath());\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = !mDownloadFile.exists();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      e.printStackTrace();\n&#x27;
                         &#x27;      failDownload(&quot;下载失败，记录文件被删除&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public IDownloadListener getListener() {\n&#x27;
                         &#x27;    return mListener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置连接超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setConnectTimeOut(int timeOut) {\n&#x27;
                         &#x27;    mConnectTimeOut = timeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置流读取的超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setReadTimeOut(int readTimeOut) {\n&#x27;
                         &#x27;    mReadTimeOut = readTimeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前下载位置\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public long getCurrentLocation() {\n&#x27;
                         &#x27;    return mConstance.CURRENT_LOCATION;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean isDownloading() {\n&#x27;
                         &#x27;    return mConstance.isDownloading;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void cancelDownload() {\n&#x27;
                         &#x27;    mConstance.isCancel = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.cancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void stopDownload() {\n&#x27;
                         &#x27;    mConstance.isStop = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.stop();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除下载记录文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delConfigFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      File config =\n&#x27;
                         &#x27;          new File(mContext.getFilesDir().getPath() &#x27;
                         &#x27;+ &quot;/temp/&quot; + dFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;      if (config.exists()) {\n&#x27;
                         &#x27;        config.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除temp文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delTempFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      if (dFile.exists()) {\n&#x27;
                         &#x27;        dFile.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 多线程断点续传下载文件，开始下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void startDownload() {\n&#x27;
                         &#x27;    mConstance.cleanState();\n&#x27;
                         &#x27;    mListener.onPre();\n&#x27;
                         &#x27;    new Thread(this).start();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void resumeDownload() {\n&#x27;
                         &#x27;    startDownload();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void failDownload(String msg) {\n&#x27;
                         &#x27;    Log.e(TAG, msg);\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    stopDownload();\n&#x27;
                         &#x27;    mListener.onFail();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mDownloadEntity.getDownloadUrl());\n&#x27;
                         &#x27;      HttpURLConnection conn = &#x27;
                         &#x27;ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                         &#x27;+ &quot;-&quot;);\n&#x27;
                         &#x27;      conn.setConnectTimeout(mConnectTimeOut * 4);\n&#x27;
                         &#x27;      conn.connect();\n&#x27;
                         &#x27;      int len = conn.getContentLength();\n&#x27;
                         &#x27;      //if (len &lt; 0) {  //网络被劫持时会出现这个问题\n&#x27;
                         &#x27;      //  failDownload(&quot;下载失败，网络被劫持&quot;);\n&#x27;
                         &#x27;      //  return;\n&#x27;
                         &#x27;      //}\n&#x27;
                         &#x27;      int code = conn.getResponseCode();\n&#x27;
                         &#x27;      &#x27;
                         &#x27;//https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\n&#x27;
                         &#x27;      //206支持断点\n&#x27;
                         &#x27;      if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                         &#x27;        isSupportBreakpoint = true;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(true);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == HttpURLConnection.HTTP_OK &#x27;
                         &#x27;|| len &lt; 0) {\n&#x27;
                         &#x27;        //在conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; &#x27;
                         &#x27;+ 0 + &quot;-&quot;);下，200为不支持断点状态\n&#x27;
                         &#x27;        if (len &lt; 0) {\n&#x27;
                         &#x27;          failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，文件长度小于0&quot;);\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        isSupportBreakpoint = false;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(false);\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载链接不支持断点下载&quot;);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == &#x27;
                         &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，错误码：404&quot;);\n&#x27;
                         &#x27;        //mListener.onCancel();\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &quot;】下载失败，错误码：&quot; + &#x27;
                         &#x27;code);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      failDownload(&quot;下载失败【downloadUrl:&quot;\n&#x27;
                         &#x27;          + mDownloadEntity.getDownloadUrl()\n&#x27;
                         &#x27;          + &quot;】\\n【filePath:&quot;\n&#x27;
                         &#x27;          + mDownloadFile.getPath()\n&#x27;
                         &#x27;          + &quot;】&quot;\n&#x27;
                         &#x27;          + CommonUtil.getPrintException(e));\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理断点\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBreakpoint(HttpURLConnection &#x27;
                         &#x27;conn) throws IOException {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    //不支持断点只能单线程下载\n&#x27;
                         &#x27;    if (!isSupportBreakpoint) {\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      long len = conn.getContentLength();;\n&#x27;
                         &#x27;      entity.FILE_SIZE = len;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = 0;\n&#x27;
                         &#x27;      entity.START_LOCATION = 0;\n&#x27;
                         &#x27;      entity.END_LOCATION = entity.FILE_SIZE;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      mListener.onPostPre(len);\n&#x27;
                         &#x27;      mListener.onStart(0);\n&#x27;
                         &#x27;      return;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int fileLength = conn.getContentLength();\n&#x27;
                         &#x27;    //必须建一个文件\n&#x27;
                         &#x27;    CommonUtil.createFile(mDownloadFile.getPath());\n&#x27;
                         &#x27;    //RandomAccessFile file = new &#x27;
                         &#x27;RandomAccessFile(mDownloadFile.getPath(), &quot;rwd&quot;);\n&#x27;
                         &#x27;    ////设置文件长度\n&#x27;
                         &#x27;    //file.setLength(fileLength);\n&#x27;
                         &#x27;    BufferedRandomAccessFile file =\n&#x27;
                         &#x27;        new &#x27;
                         &#x27;BufferedRandomAccessFile(mDownloadFile.getPath(), &#x27;
                         &#x27;&quot;rwd&quot;, 8192);\n&#x27;
                         &#x27;    //设置文件长度\n&#x27;
                         &#x27;    file.setLength(fileLength);\n&#x27;
                         &#x27;    mListener.onPostPre(fileLength);\n&#x27;
                         &#x27;    //分配每条线程的下载区间\n&#x27;
                         &#x27;    Properties pro = null;\n&#x27;
                         &#x27;    pro = CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;    if (pro.isEmpty()) {\n&#x27;
                         &#x27;      isNewTask = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;        if (pro.getProperty(mDownloadFile.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + i) == null) {\n&#x27;
                         &#x27;          Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;          if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(state + &quot;&quot;) == 1) {\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          isNewTask = true;\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int blockSize = fileLength / THREAD_NUM;\n&#x27;
                         &#x27;    int[] recordL = new int[THREAD_NUM];\n&#x27;
                         &#x27;    int rl = 0;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      recordL[i] = -1;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      if (state != null &amp;&amp; Integer.parseInt(state + &#x27;
                         &#x27;&quot;&quot;) == 1) {  //该线程已经完成\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += endL - &#x27;
                         &#x27;startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_已经下载完成 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        mConstance.STOP_NUM++;\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          if (mConfigFile.exists()) {\n&#x27;
                         &#x27;            mConfigFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        continue;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //分配下载位置\n&#x27;
                         &#x27;      Object record = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_record_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      //如果有记录，则恢复下载\n&#x27;
                         &#x27;      if (!isNewTask &amp;&amp; record != null &amp;&amp; &#x27;
                         &#x27;Long.parseLong(record + &quot;&quot;) &gt; 0) {\n&#x27;
                         &#x27;        Long r = Long.parseLong(record + &quot;&quot;);\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += r - startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_恢复下载 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mListener.onChildResume(r);\n&#x27;
                         &#x27;        startL = r;\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (isNewTask) {\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (i == (THREAD_NUM - 1)) {\n&#x27;
                         &#x27;        //如果整个文件的大小不为线程个数的整数倍，则最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        endL = fileLength;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      entity.FILE_SIZE = fileLength;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = i;\n&#x27;
                         &#x27;      entity.START_LOCATION = startL;\n&#x27;
                         &#x27;      entity.END_LOCATION = endL;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mTask.put(i, task);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mConstance.CURRENT_LOCATION &gt; 0) {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onResume(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onStart(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int l : recordL) {\n&#x27;
                         &#x27;      if (l == -1) continue;\n&#x27;
                         &#x27;      Runnable task = mTask.get(l);\n&#x27;
                         &#x27;      if (task != null &amp;&amp; &#x27;
                         &#x27;!mFixedThreadPool.isShutdown()) {\n&#x27;
                         &#x27;        mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 子线程下载信息类\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  final static class ConfigEntity {\n&#x27;
                         &#x27;    //文件大小\n&#x27;
                         &#x27;    long FILE_SIZE;\n&#x27;
                         &#x27;    String DOWNLOAD_URL;\n&#x27;
                         &#x27;    int THREAD_ID;\n&#x27;
                         &#x27;    long START_LOCATION;\n&#x27;
                         &#x27;    long END_LOCATION;\n&#x27;
                         &#x27;    File TEMP_FILE;\n&#x27;
                         &#x27;    boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;    String CONFIG_FILE_PATH;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.content.Context;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import android.util.SparseArray;\n&#x27;
                         &#x27;import com.arialyy.aria.core.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.concurrent.ExecutorService;\n&#x27;
                         &#x27;import java.util.concurrent.Executors;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2015/8/25.\n&#x27;
                         &#x27; * 下载工具类\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class DownloadUtil implements IDownloadUtil, &#x27;
                         &#x27;Runnable {\n&#x27;
                         &#x27;  private static final String TAG = &quot;DownloadUtil&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 线程数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private final int THREAD_NUM;\n&#x27;
                         &#x27;  //下载监听\n&#x27;
                         &#x27;  private IDownloadListener mListener;\n&#x27;
                         &#x27;  private int mConnectTimeOut = 5000 * 4; //连接超时时间\n&#x27;
                         &#x27;  private int mReadTimeOut = 5000 * 20; //流读取的超时时间\n&#x27;
                         &#x27;  private boolean isNewTask = true;\n&#x27;
                         &#x27;  private boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;  private Context mContext;\n&#x27;
                         &#x27;  private DownloadEntity mDownloadEntity;\n&#x27;
                         &#x27;  private ExecutorService mFixedThreadPool;\n&#x27;
                         &#x27;  private File mDownloadFile; //下载的文件\n&#x27;
                         &#x27;  private File mConfigFile;//下载信息配置文件\n&#x27;
                         &#x27;  private SparseArray&lt;Runnable&gt; mTask = new &#x27;
                         &#x27;SparseArray&lt;&gt;();\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public DownloadUtil(Context context, &#x27;
                         &#x27;DownloadEntity entity, IDownloadListener &#x27;
                         &#x27;downloadListener) {\n&#x27;
                         &#x27;    this(context, entity, downloadListener, 3);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  DownloadUtil(Context context, DownloadEntity &#x27;
                         &#x27;entity, IDownloadListener downloadListener,\n&#x27;
                         &#x27;      int threadNum) {\n&#x27;
                         &#x27;    mContext = context.getApplicationContext();\n&#x27;
                         &#x27;    mDownloadEntity = entity;\n&#x27;
                         &#x27;    mListener = downloadListener;\n&#x27;
                         &#x27;    THREAD_NUM = threadNum;\n&#x27;
                         &#x27;    mFixedThreadPool = &#x27;
                         &#x27;Executors.newFixedThreadPool(Integer.MAX_VALUE);\n&#x27;
                         &#x27;    mConstance = new &#x27;
                         &#x27;DownloadStateConstance(THREAD_NUM);\n&#x27;
                         &#x27;    init();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void init() {\n&#x27;
                         &#x27;    mDownloadFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;    //读取已完成的线程数\n&#x27;
                         &#x27;    mConfigFile = new File(\n&#x27;
                         &#x27;        mContext.getFilesDir().getPath() + &quot;/temp/&quot; &#x27;
                         &#x27;+ mDownloadFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      if (!mConfigFile.exists()) { //记录文件被删除，则重新下载\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;CommonUtil.createFile(mConfigFile.getPath());\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = !mDownloadFile.exists();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      e.printStackTrace();\n&#x27;
                         &#x27;      failDownload(&quot;下载失败，记录文件被删除&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public IDownloadListener getListener() {\n&#x27;
                         &#x27;    return mListener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置连接超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setConnectTimeOut(int timeOut) {\n&#x27;
                         &#x27;    mConnectTimeOut = timeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 设置流读取的超时时间\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public void setReadTimeOut(int readTimeOut) {\n&#x27;
                         &#x27;    mReadTimeOut = readTimeOut;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前下载位置\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public long getCurrentLocation() {\n&#x27;
                         &#x27;    return mConstance.CURRENT_LOCATION;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean isDownloading() {\n&#x27;
                         &#x27;    return mConstance.isDownloading;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void cancelDownload() {\n&#x27;
                         &#x27;    mConstance.isCancel = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.cancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void stopDownload() {\n&#x27;
                         &#x27;    mConstance.isStop = true;\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    mFixedThreadPool.shutdown();\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      SingleThreadTask task = (SingleThreadTask) &#x27;
                         &#x27;mTask.get(i);\n&#x27;
                         &#x27;      if (task != null) {\n&#x27;
                         &#x27;        task.stop();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除下载记录文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delConfigFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      File config =\n&#x27;
                         &#x27;          new File(mContext.getFilesDir().getPath() &#x27;
                         &#x27;+ &quot;/temp/&quot; + dFile.getName() + &quot;.properties&quot;);\n&#x27;
                         &#x27;      if (config.exists()) {\n&#x27;
                         &#x27;        config.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 删除temp文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void delTempFile() {\n&#x27;
                         &#x27;    if (mContext != null &amp;&amp; mDownloadEntity != null) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      File dFile = new &#x27;
                         &#x27;File(mDownloadEntity.getDownloadPath());\n&#x27;
                         &#x27;      if (dFile.exists()) {\n&#x27;
                         &#x27;        dFile.delete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 多线程断点续传下载文件，开始下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override public void startDownload() {\n&#x27;
                         &#x27;    mConstance.cleanState();\n&#x27;
                         &#x27;    mListener.onPre();\n&#x27;
                         &#x27;    new Thread(this).start();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void resumeDownload() {\n&#x27;
                         &#x27;    startDownload();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void failDownload(String msg) {\n&#x27;
                         &#x27;    Log.e(TAG, msg);\n&#x27;
                         &#x27;    mConstance.isDownloading = false;\n&#x27;
                         &#x27;    stopDownload();\n&#x27;
                         &#x27;    mListener.onFail();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mDownloadEntity.getDownloadUrl());\n&#x27;
                         &#x27;      HttpURLConnection conn = &#x27;
                         &#x27;ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                         &#x27;+ &quot;-&quot;);\n&#x27;
                         &#x27;      conn.setConnectTimeout(mConnectTimeOut * 4);\n&#x27;
                         &#x27;      conn.connect();\n&#x27;
                         &#x27;      int len = conn.getContentLength();\n&#x27;
                         &#x27;      //if (len &lt; 0) {  //网络被劫持时会出现这个问题\n&#x27;
                         &#x27;      //  failDownload(&quot;下载失败，网络被劫持&quot;);\n&#x27;
                         &#x27;      //  return;\n&#x27;
                         &#x27;      //}\n&#x27;
                         &#x27;      int code = conn.getResponseCode();\n&#x27;
                         &#x27;      &#x27;
                         &#x27;//https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\n&#x27;
                         &#x27;      //206支持断点\n&#x27;
                         &#x27;      if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                         &#x27;        isSupportBreakpoint = true;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(true);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == HttpURLConnection.HTTP_OK &#x27;
                         &#x27;|| len &lt; 0) {\n&#x27;
                         &#x27;        //在conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; &#x27;
                         &#x27;+ 0 + &quot;-&quot;);下，200为不支持断点状态\n&#x27;
                         &#x27;        if (len &lt; 0) {\n&#x27;
                         &#x27;          failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，文件长度小于0&quot;);\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        isSupportBreakpoint = false;\n&#x27;
                         &#x27;        mListener.supportBreakpoint(false);\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载链接不支持断点下载&quot;);\n&#x27;
                         &#x27;        handleBreakpoint(conn);\n&#x27;
                         &#x27;      } else if (code == &#x27;
                         &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &#x27;
                         &#x27;&quot;】下载失败，错误码：404&quot;);\n&#x27;
                         &#x27;        //mListener.onCancel();\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        failDownload(&quot;任务【&quot; + &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl() + &quot;】下载失败，错误码：&quot; + &#x27;
                         &#x27;code);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      failDownload(&quot;下载失败【downloadUrl:&quot;\n&#x27;
                         &#x27;          + mDownloadEntity.getDownloadUrl()\n&#x27;
                         &#x27;          + &quot;】\\n【filePath:&quot;\n&#x27;
                         &#x27;          + mDownloadFile.getPath()\n&#x27;
                         &#x27;          + &quot;】&quot;\n&#x27;
                         &#x27;          + CommonUtil.getPrintException(e));\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理断点\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBreakpoint(HttpURLConnection &#x27;
                         &#x27;conn) throws IOException {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    //不支持断点只能单线程下载\n&#x27;
                         &#x27;    if (!isSupportBreakpoint) {\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      long len = conn.getContentLength();;\n&#x27;
                         &#x27;      entity.FILE_SIZE = len;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = 0;\n&#x27;
                         &#x27;      entity.START_LOCATION = 0;\n&#x27;
                         &#x27;      entity.END_LOCATION = entity.FILE_SIZE;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      mListener.onPostPre(len);\n&#x27;
                         &#x27;      mListener.onStart(0);\n&#x27;
                         &#x27;      return;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int fileLength = conn.getContentLength();\n&#x27;
                         &#x27;    //必须建一个文件\n&#x27;
                         &#x27;    CommonUtil.createFile(mDownloadFile.getPath());\n&#x27;
                         &#x27;    //RandomAccessFile file = new &#x27;
                         &#x27;RandomAccessFile(mDownloadFile.getPath(), &quot;rwd&quot;);\n&#x27;
                         &#x27;    ////设置文件长度\n&#x27;
                         &#x27;    //file.setLength(fileLength);\n&#x27;
                         &#x27;    BufferedRandomAccessFile file =\n&#x27;
                         &#x27;        new &#x27;
                         &#x27;BufferedRandomAccessFile(mDownloadFile.getPath(), &#x27;
                         &#x27;&quot;rwd&quot;, 8192);\n&#x27;
                         &#x27;    //设置文件长度\n&#x27;
                         &#x27;    file.setLength(fileLength);\n&#x27;
                         &#x27;    mListener.onPostPre(fileLength);\n&#x27;
                         &#x27;    //分配每条线程的下载区间\n&#x27;
                         &#x27;    Properties pro = null;\n&#x27;
                         &#x27;    pro = CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;    if (pro.isEmpty()) {\n&#x27;
                         &#x27;      isNewTask = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;        if (pro.getProperty(mDownloadFile.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + i) == null) {\n&#x27;
                         &#x27;          Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;          if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(state + &quot;&quot;) == 1) {\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          isNewTask = true;\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    int blockSize = fileLength / THREAD_NUM;\n&#x27;
                         &#x27;    int[] recordL = new int[THREAD_NUM];\n&#x27;
                         &#x27;    int rl = 0;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      recordL[i] = -1;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int i = 0; i &lt; THREAD_NUM; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      Object state = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_state_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      if (state != null &amp;&amp; Integer.parseInt(state + &#x27;
                         &#x27;&quot;&quot;) == 1) {  //该线程已经完成\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += endL - &#x27;
                         &#x27;startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_已经下载完成 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        mConstance.STOP_NUM++;\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          if (mConfigFile.exists()) {\n&#x27;
                         &#x27;            mConfigFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        continue;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //分配下载位置\n&#x27;
                         &#x27;      Object record = &#x27;
                         &#x27;pro.getProperty(mDownloadFile.getName() + &quot;_record_&quot; &#x27;
                         &#x27;+ i);\n&#x27;
                         &#x27;      //如果有记录，则恢复下载\n&#x27;
                         &#x27;      if (!isNewTask &amp;&amp; record != null &amp;&amp; &#x27;
                         &#x27;Long.parseLong(record + &quot;&quot;) &gt; 0) {\n&#x27;
                         &#x27;        Long r = Long.parseLong(record + &quot;&quot;);\n&#x27;
                         &#x27;        mConstance.CURRENT_LOCATION += r - startL;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ 线程_&quot; + i + &quot;_恢复下载 &#x27;
                         &#x27;++++++++++&quot;);\n&#x27;
                         &#x27;        mListener.onChildResume(r);\n&#x27;
                         &#x27;        startL = r;\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        isNewTask = true;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (isNewTask) {\n&#x27;
                         &#x27;        recordL[rl] = i;\n&#x27;
                         &#x27;        rl++;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      if (i == (THREAD_NUM - 1)) {\n&#x27;
                         &#x27;        //如果整个文件的大小不为线程个数的整数倍，则最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        endL = fileLength;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      ConfigEntity entity = new ConfigEntity();\n&#x27;
                         &#x27;      entity.FILE_SIZE = fileLength;\n&#x27;
                         &#x27;      entity.DOWNLOAD_URL = &#x27;
                         &#x27;mDownloadEntity.getDownloadUrl();\n&#x27;
                         &#x27;      entity.TEMP_FILE = mDownloadFile;\n&#x27;
                         &#x27;      entity.THREAD_ID = i;\n&#x27;
                         &#x27;      entity.START_LOCATION = startL;\n&#x27;
                         &#x27;      entity.END_LOCATION = endL;\n&#x27;
                         &#x27;      entity.CONFIG_FILE_PATH = &#x27;
                         &#x27;mConfigFile.getPath();\n&#x27;
                         &#x27;      entity.isSupportBreakpoint = &#x27;
                         &#x27;isSupportBreakpoint;\n&#x27;
                         &#x27;      SingleThreadTask task = new &#x27;
                         &#x27;SingleThreadTask(mConstance, mListener, entity);\n&#x27;
                         &#x27;      mTask.put(i, task);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mConstance.CURRENT_LOCATION &gt; 0) {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onResume(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onStart(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    for (int l : recordL) {\n&#x27;
                         &#x27;      if (l == -1) continue;\n&#x27;
                         &#x27;      Runnable task = mTask.get(l);\n&#x27;
                         &#x27;      if (task != null &amp;&amp; &#x27;
                         &#x27;!mFixedThreadPool.isShutdown()) {\n&#x27;
                         &#x27;        mFixedThreadPool.execute(task);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 子线程下载信息类\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  final static class ConfigEntity {\n&#x27;
                         &#x27;    //文件大小\n&#x27;
                         &#x27;    long FILE_SIZE;\n&#x27;
                         &#x27;    String DOWNLOAD_URL;\n&#x27;
                         &#x27;    int THREAD_ID;\n&#x27;
                         &#x27;    long START_LOCATION;\n&#x27;
                         &#x27;    long END_LOCATION;\n&#x27;
                         &#x27;    File TEMP_FILE;\n&#x27;
                         &#x27;    boolean isSupportBreakpoint = true;\n&#x27;
                         &#x27;    String CONFIG_FILE_PATH;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        