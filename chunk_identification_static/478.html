<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>478</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    478
                    <a href="477.html">prev</a>
                    <a href="479.html">next</a>
                    <a href="478_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_71556d41e236b5f2060c133cec30dbe28aef0974_core/src/main/java/com/dtstack/flink/sql/util/DateUtil.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;71556d41e236b5f2060c133cec30dbe28aef0974:core/src/main/java/com/dtstack/flink/sql/util/DateUtil.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;71556d41e236b5f2060c133cec30dbe28aef0974^1:core/src/main/java/com/dtstack/flink/sql/util/DateUtil.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;71556d41e236b5f2060c133cec30dbe28aef0974^2:core/src/main/java/com/dtstack/flink/sql/util/DateUtil.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;210b9c3cb61e84b04c5f09f8f0fccec9c746acb0:core/src/main/java/com/dtstack/flink/sql/util/DateUtil.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19  
  20 
  21 package com.dtstack.flink.sql.util;
  22 
  23 import java.sql.Timestamp;
  24 import java.text.ParseException;
  25 import java.text.SimpleDateFormat;
  26 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  27 import java.time.LocalDate;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  28 import java.time.LocalDateTime;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  29 import java.time.LocalTime;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  30 import java.time.ZoneId;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  31 import java.time.format.DateTimeFormatter;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  32 import java.time.format.DateTimeParseException;</span>
  33 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  34 import java.util.Calendar;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  35 import java.util.Date;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  36 import java.util.Locale;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  37 import java.util.SimpleTimeZone;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  38 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  39 </span>
  40 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  41 import java.time.Instant;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  42 import java.time.LocalDate;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  43 import java.time.LocalTime;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  44 import java.time.ZoneOffset;</span>
  45 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  46 import java.util.Calendar;
  47 import java.util.Date;
  48 import java.util.Locale;
  49 import java.util.SimpleTimeZone;
  50 import java.util.TimeZone;
  51 import java.util.regex.Pattern;
  52 
  53 import static java.time.format.DateTimeFormatter.ISO_INSTANT;
  54 
  55 
  56 /**
  57  * 
  58  * Reason: TODO ADD REASON(ÂèØÈÄâ)
  59  * Date: 2017Âπ¥03Êúà10Êó• ‰∏ãÂçà1:16:37
  60  * Company: www.dtstack.com
  61  * @author sishu.yss
  62  *
  63  */
  64 public class DateUtil {
  65 
<abbr title="  66     static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);">  66     static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ssüîµ</abbr>
  67     static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);
  68     static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;);
  69 
<abbr title="  70     private static final Pattern DATETIME = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3,9})?Z$&quot;);">  70     private static final Pattern DATETIME = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}T\\d{2}:\\üîµ</abbr>
  71     private static final Pattern DATE = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}$&quot;);
  72 
  73     private static final int MILLIS_PER_SECOND = 1000;
  74 
  75 
  76     public static java.sql.Date columnToDate(Object column) {
  77         if(column instanceof String) {
  78             return new java.sql.Date(stringToDate((String)column).getTime());
  79         } else if (column instanceof Integer) {
  80             Integer rawData = (Integer) column;
  81             return new java.sql.Date(rawData.longValue());
  82         } else if (column instanceof Long) {
  83             Long rawData = (Long) column;
  84             return new java.sql.Date(rawData.longValue());
  85         } else if (column instanceof java.sql.Date) {
  86             return (java.sql.Date) column;
  87         } else if(column instanceof Timestamp) {
  88             Timestamp ts = (Timestamp) column;
  89             return new java.sql.Date(ts.getTime());
  90         }
  91         throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
  92     }
  93 
  94     public static Date stringToDate(String strDate)  {
  95         if(strDate == null){
  96             return null;
  97         }
  98         try {
  99             ;
 100             return localDateTimetoDate(LocalDateTime.parse(strDate, DATE_TIME_FORMATTER));
 101         } catch (DateTimeParseException ignored) {
 102         }
 103 
 104         try {
 105             return localDateTimetoDate(LocalDate.parse(strDate, DATE_FORMATTER).atStartOfDay());
 106         } catch (DateTimeParseException ignored) {
 107         }
 108 
 109         try {
<abbr title=" 110             return localDateTimetoDate(LocalDateTime.of(LocalDate.now(), LocalTime.parse(strDate, TIME_FORMATTER)));"> 110             return localDateTimetoDate(LocalDateTime.of(LocalDate.now(), LocalTime.parse(strDate, TIME_FOüîµ</abbr>
 111         } catch (DateTimeParseException ignored) {
 112         }
 113 
 114         throw new RuntimeException(&quot;can&#x27;t parse date&quot;);
 115     }
 116 
 117     public static Date localDateTimetoDate(LocalDateTime localDateTime){
 118         return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
 119     }
 120 
 121     public static LocalDateTime dateToLocalDateTime(Date date){
 122         return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
 123     }
 124 
 125     /**
 126      *
 127      * 
 128      * @param day Long Êó∂Èó¥
 129      * @return long
 130      */
 131     public static long getTodayStart(long day) {
 132         long firstDay = 0L;
 133         Calendar cal = Calendar.getInstance();
 134         if ((&quot;&quot; + day).length() &gt; 10) {
 135             cal.setTime(new Date(day));
 136         } else {
 137             cal.setTime(new Date(day * 1000));
 138         }
 139         cal.set(Calendar.HOUR_OF_DAY, 0);
 140         cal.set(Calendar.MINUTE, 0);
 141         cal.set(Calendar.SECOND, 0);
 142         cal.set(Calendar.MILLISECOND, 0);
 143         firstDay = cal.getTimeInMillis() / 1000;
 144         return firstDay;
 145     }
 146 
 147     /**
 148      *
 149      * @param day Long Êó∂Èó¥
 150      * @param scope
 151      * @return
 152      */
 153     public static long getTodayStart(long day,String scope) {
 154     	if(&quot;MS&quot;.equals(scope)){
 155     		return getTodayStart(day)*1000;
 156     	}else if(&quot;S&quot;.equals(scope)){
 157     		return getTodayStart(day);
 158     	}else{
 159     		return getTodayStart(day);
 160     	}
 161     }
 162 
 163     /**
 164      *
 165      * @param day Long Êó∂Èó¥
 166      * @return long
 167      */
 168     public static long getNextDayStart(long day) {
 169         long daySpanMill = 86400000L;
 170         long nextDay = 0L;
 171         Calendar cal = Calendar.getInstance();
 172         if ((&quot;&quot; + day).length() &gt; 10) {
 173             cal.setTime(new Date(day));
 174         } else {
 175             cal.setTime(new Date(day * 1000));
 176         }
 177         cal.set(Calendar.HOUR_OF_DAY, 0);
 178         cal.set(Calendar.MINUTE, 0);
 179         cal.set(Calendar.SECOND, 0);
 180         cal.set(Calendar.MILLISECOND, 0);
 181         nextDay = (cal.getTimeInMillis() + daySpanMill) / 1000;
 182         return nextDay;
 183     }
 184     
 185     /**
 186      *
 187      * @param day Long Êó∂Èó¥
 188      * @param scope String Á∫ßÂà´&lt;br&gt;&quot;MS&quot;ÔºöÊØ´ÁßíÁ∫ß&lt;br&gt;&quot;S&quot;:ÁßíÁ∫ß
 189      * @return
 190      */
 191     public static long getNextDayStart(long day,String scope) {
 192     	if(&quot;MS&quot;.equals(scope)){
 193     		return getNextDayStart(day)*1000;
 194     	}else if(&quot;S&quot;.equals(scope)){
 195     		return getNextDayStart(day);
 196     	}else{
 197     		return getNextDayStart(day);
 198     	}
 199     }
 200     
 201 
 202     /**
 203      *
 204      * @param day
 205      * @return
 206      */
 207     public static long getMonthFirst(long day) {
 208         long firstDay = 0L;
 209         Calendar cal = Calendar.getInstance();
 210         cal.setTime(new Date(day * 1000));
 211         cal.set(Calendar.DAY_OF_MONTH, 1);
 212         cal.set(Calendar.HOUR_OF_DAY, 0);
 213         cal.set(Calendar.MINUTE, 0);
 214         cal.set(Calendar.SECOND, 0);
 215         cal.set(Calendar.MILLISECOND, 0);
 216         firstDay = cal.getTimeInMillis() / 1000;
 217         return firstDay;
 218     }
 219 
 220     /**
 221      * @param day
 222      * @return
 223      */
 224     public static int getMonth(long day) {
 225         Calendar cal = Calendar.getInstance();
 226         cal.setTime(new Date(day * 1000));
 227         return cal.get(Calendar.MONTH) + 1;
 228     }
 229 
 230     /**
 231      *
 232      * @author yumo.lck
 233      */
 234     public static int getYear(long day) {
 235         Calendar cal = Calendar.getInstance();
 236         cal.setTime(new Date(day * 1000));
 237         return cal.get(Calendar.YEAR);
 238     }
 239 
 240     /**
 241      *
 242      * @param day
 243      * @return
 244      */
 245     public static long getWeekFirst(long day) {
 246         long firstDay = 0L;
 247         Calendar cal = Calendar.getInstance();
 248         cal.setTime(new Date(day * 1000));
 249         cal.setFirstDayOfWeek(Calendar.MONDAY);
 250         cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
 251         cal.set(Calendar.HOUR_OF_DAY, 0);
 252         cal.set(Calendar.MINUTE, 0);
 253         cal.set(Calendar.SECOND, 0);
 254         cal.set(Calendar.MILLISECOND, 0);
 255         firstDay = cal.getTimeInMillis() / 1000;
 256         return firstDay;
 257     }
 258 
 259     /**
 260      * Ê†πÊçÆÊüê‰∏™Êó•ÊúüÊó∂Èó¥Êà≥ÁßíÂÄºÔºåËé∑ÂèñÊâÄÂú®Âë®Âú®‰∏ÄÂπ¥‰∏≠ÊòØÁ¨¨Âá†Âë®.
 261      * 
 262      * @param day
 263      * @return
 264      */
 265     public static int getWeekOfYear(long day) {
 266         Calendar cal = Calendar.getInstance();
 267         cal.setTime(new Date(day * 1000));
 268         return cal.get(Calendar.WEEK_OF_YEAR);
 269     }
 270 
 271     /**
 272      *
 273      * @param day
 274      * @param inFormat
 275      * @param outFormat
 276      * @return String
 277      * @throws ParseException
 278      */
 279     public static String getYesterdayByString(String day, String inFormat, String outFormat){
 280         try {
 281 			SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 282 			Date date = sdf.parse(day);
 283 			Calendar calendar = Calendar.getInstance();
 284 			calendar.setTime(date);
 285 			int calendarDay = calendar.get(Calendar.DATE);
 286 			calendar.set(Calendar.DATE, calendarDay - 1);
 287 			String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 288 			return dayBefore;
 289 		} catch (ParseException e) {
 290 			return null;
 291 		}
 292     }
 293 
 294     /**
 295      *
 296      * @param day
 297      * @param inFormat
 298      * @param outFormat
 299      * @return String
 300      * @throws ParseException
 301      */
<abbr title=" 302     public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseException {"> 302     public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseEüîµ</abbr>
 303         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 304         Date date = sdf.parse(day);
 305         Calendar calendar = Calendar.getInstance();
 306         calendar.setTime(date);
 307         int calendarDay = calendar.get(Calendar.DATE);
 308         calendar.set(Calendar.DATE, calendarDay + 1);
 309         String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 310         return dayBefore;
 311     }
 312     
 313     /**
 314      *
 315      * @param date
 316      * @return Date
 317      * @throws ParseException
 318      */
 319     public static Date getTomorrowByDate(Date date) throws ParseException {
 320         Calendar calendar = Calendar.getInstance();
 321         calendar.setTime(date);
 322         int calendarDay = calendar.get(Calendar.DATE);
 323         calendar.set(Calendar.DATE, calendarDay + 1);
 324         return calendar.getTime();
 325     }
 326 
 327     /**
 328      *
 329      * @param day
 330      * @param inFormat
 331      * @param outFormat
 332      * @return String
 333      * @throws ParseException
 334      */
<abbr title=" 335     public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws ParseException {"> 335     public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws Paüîµ</abbr>
 336         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 337         Date date = sdf.parse(day);
 338         Calendar calendar = Calendar.getInstance();
 339         calendar.setTime(date);
 340         int calendarDay = calendar.get(Calendar.DATE);
 341         calendar.set(Calendar.DATE, calendarDay - 30);
 342         return new SimpleDateFormat(outFormat).format(calendar.getTime());
 343     }
 344     
 345     /**
 346      *
 347      * @param day
 348      * @param inFormat
 349      * @param outFormat
 350      * @return String
 351      * @throws ParseException
 352      */
<abbr title=" 353     public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws ParseException {"> 353     public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws Parüîµ</abbr>
 354     	SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 355     	Date date = sdf.parse(day);
 356     	Calendar calendar = Calendar.getInstance();
 357     	calendar.setTime(date);
 358     	int calendarDay = calendar.get(Calendar.DATE);
 359     	calendar.set(Calendar.DATE, calendarDay + 30);
 360     	String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 361     	return dayBefore;
 362     }
 363 
 364 
 365     /**
 366      *
 367      * @param day
 368      * @param inFormat
 369      * @param outFormat
 370      * @return String
 371      * @throws ParseException
 372      */
<abbr title=" 373     public static String getDateStrToFormat(String day, String inFormat, String outFormat) throws ParseException {"> 373     public static String getDateStrToFormat(String day, String inFormat, String outFormat) throws ParseExüîµ</abbr>
 374         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 375         Date date = sdf.parse(day);
 376         Calendar calendar = Calendar.getInstance();
 377         calendar.setTime(date);
 378         String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 379         return dayBefore;
 380     }
 381     
 382     public static long getDateMillToFormat(String day, String inFormat) throws ParseException {
 383         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 384         Date date = sdf.parse(day);
 385         Calendar calendar = Calendar.getInstance();
 386         calendar.setTime(date);
 387         return calendar.getTimeInMillis()/1000;
 388     }
 389 
 390     /**
 391      *
 392      * @author sishu.yss
 393      * @param year
 394      * @param month
 395      * @return
 396      */
 397     public static long getFirstDay4Month(int year, int month) {
 398         long firstDay = 0L;
 399         Calendar cal = Calendar.getInstance();
 400         cal.set(Calendar.YEAR, year);
 401         cal.set(Calendar.MONTH, month - 1);
 402         cal.set(Calendar.DAY_OF_MONTH, 1);
 403         cal.set(Calendar.HOUR_OF_DAY, 0);
 404         cal.set(Calendar.MINUTE, 0);
 405         cal.set(Calendar.SECOND, 0);
 406         cal.set(Calendar.MILLISECOND, 0);
 407         firstDay = cal.getTimeInMillis() / 1000;
 408         return firstDay;
 409     }
 410 
 411     /**
 412      *
 413      * @author yumo.lck
 414      * @param year
 415      * @param month
 416      * @return
 417      */
 418     public static long getLastDay4Month(int year, int month) {
 419         long lastDay = 0L;
 420         Calendar cal = Calendar.getInstance();
 421         cal.set(Calendar.YEAR, year);
 422         cal.set(Calendar.MONTH, month);
<abbr title=" 423         //1 represents a zero next month, can be seen as the end of the first day of the month most one day, but the data table on the last day of the zero point on the line"> 423         //1 represents a zero next month, can be seen as the end of the first day of the month most one düîµ</abbr>
 424         cal.set(Calendar.DAY_OF_MONTH, 0);
 425         cal.set(Calendar.HOUR_OF_DAY, 0);
 426         cal.set(Calendar.MINUTE, 0);
 427         cal.set(Calendar.SECOND, 0);
 428         cal.set(Calendar.MILLISECOND, 0);
 429         lastDay = cal.getTimeInMillis() / 1000;
 430         return lastDay;
 431     }
 432 
 433     /**
 434      *
 435      * @author yumo.lck
 436      * @param chooseFirstDay
 437      */
 438 
 439     public static long getBeforeMonthDay(long day, boolean chooseFirstDay) {
 440         long chooseDay = 0L;
 441         int currentMonth = getMonth(day);
 442         int currentYear = getYear(day);
 443         if (currentMonth &gt; 1) {
 444             currentMonth--;
 445         } else {
 446             currentYear--;
 447             currentMonth = 12;
 448         }
 449         if (chooseFirstDay) {
 450             chooseDay = getFirstDay4Month(currentYear, currentMonth);
 451             return chooseDay;
 452         } else {
 453             chooseDay = getLastDay4Month(currentYear, currentMonth);
 454             return chooseDay;
 455         }
 456 
 457     }
 458 
 459     /**
 460      * @return long
 461      */
 462     public static long getMillByOneDay() {
 463         Calendar cal = Calendar.getInstance();
 464         cal.set(Calendar.HOUR_OF_DAY, 0);
 465         cal.set(Calendar.MINUTE, 0);
 466         cal.set(Calendar.SECOND, 0);
 467         cal.set(Calendar.MILLISECOND, 0);
 468         return cal.getTimeInMillis() / 1000;
 469     }
 470 
 471     /**
 472      *
 473      * @return long
 474      */
 475     public static long getMillByYesDay() {
 476         Calendar cal = Calendar.getInstance();
 477         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 1);
 478         cal.set(Calendar.HOUR_OF_DAY, 0);
 479         cal.set(Calendar.MINUTE, 0);
 480         cal.set(Calendar.SECOND, 0);
 481         cal.set(Calendar.MILLISECOND, 0);
 482         return cal.getTimeInMillis() / 1000;
 483     }
 484 
 485     /**
 486      *
 487      * @return
 488      */
 489     public static long getMillByLastWeekDay() {
 490         Calendar cal = Calendar.getInstance();
 491         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 7);
 492         cal.set(Calendar.HOUR_OF_DAY, 0);
 493         cal.set(Calendar.MINUTE, 0);
 494         cal.set(Calendar.SECOND, 0);
 495         cal.set(Calendar.MILLISECOND, 0);
 496         return cal.getTimeInMillis() / 1000;
 497     }
 498     
 499    /**
 500     * @return long
 501     */
 502     public static long getMillByDay(int severalDays,String condition) {
 503     	int dateT=0;
 504         Calendar cal = Calendar.getInstance();
 505     	if(condition==null){
 506     		return getMillToDay(cal,dateT);
 507     	}
 508         if(&quot;-&quot;.equals(condition)){
 509         	dateT = (cal.get(Calendar.DATE) - severalDays);
 510         	return getMillToDay(cal,dateT);
 511         }
 512         if(&quot;+&quot;.equals(condition)){
 513         	dateT = (cal.get(Calendar.DATE) + severalDays);
 514         	return getMillToDay(cal,dateT);
 515         }
 516 		return getMillToDay(cal,dateT);
 517   }
 518     
 519     /**
 520      * @return long
 521      */
 522     public static long getStampByDay(int severalDays,String condition) {
 523     	int dateT=0;
 524     	Calendar cal = Calendar.getInstance();
 525     	if(condition==null){
 526     		return getStampToDay(cal,dateT);
 527     	}
 528     	if(&quot;-&quot;.equals(condition)){
 529     		dateT = (cal.get(Calendar.DATE) - severalDays);
 530     		return getStampToDay(cal,dateT);
 531     	}
 532     	if(&quot;+&quot;.equals(condition)){
 533     		dateT = (cal.get(Calendar.DATE) + severalDays);
 534     		return getStampToDay(cal,dateT);
 535     	}
 536     	return getStampToDay(cal,dateT);
 537     }
 538     /**
 539      * @return long
 540      */
 541     public static long getMillByDay(){
 542 		return getMillByDay(0,null);
 543     }
 544     
 545     /**
 546      * @param cal  Calendar
 547      * @param dateT Integer 
 548      * @return  long
 549      */
 550     public static long getMillToDay(Calendar cal,int dateT){
 551 		   if(dateT!=0){
 552 			   cal.set(Calendar.DATE, dateT);
 553 		   }
 554 	       cal.set(Calendar.HOUR_OF_DAY, 0);
 555 	       cal.set(Calendar.MINUTE, 0);
 556 	       cal.set(Calendar.SECOND, 0);
 557 	       cal.set(Calendar.MILLISECOND, 0);
 558 	       return cal.getTimeInMillis()/1000;
 559 	}
 560     
 561     /**
 562      * @param cal  Calendar
 563      * @param dateT Integer 
 564      * @return  long
 565      */
 566     public static long getStampToDay(Calendar cal,int dateT){
 567     	if(dateT!=0){
 568     		cal.set(Calendar.DATE, dateT);
 569     	}
 570     	return cal.getTimeInMillis();
 571     }
 572 
 573     public static String getToday() {
 574         Calendar cal = Calendar.getInstance();
 575         return cal.get(1) + &quot;Âπ¥&quot; + cal.get(2) + &quot;Êúà&quot; + cal.get(3) + &quot;Êó•&quot;;
 576     }
 577 
 578     /**
 579      * @param day
 580      * @return format time
 581      */
 582     public static String getDate(long day, String format) {
 583         Calendar cal = Calendar.getInstance();
 584         if ((&quot;&quot; + day).length() &gt; 10) {
 585             cal.setTime(new Date(day));
 586         } else {
 587             cal.setTime(new Date(day * 1000));
 588         }
 589         SimpleDateFormat sf = new SimpleDateFormat(format);
 590         return sf.format(cal.getTime());
 591     }
 592     
 593     /**
 594      *
 595      * @param  date
 596      * @return
 597      */
 598     public static String getDate(Date date, String format) {
 599         SimpleDateFormat sf = new SimpleDateFormat(format);
 600         return sf.format(date);
 601     }
 602     
 603     
 604     /**
 605      *
 606      * @param day
 607      * @param format
 608      * @return long
 609      * @throws ParseException 
 610      */
 611     public static long stringToLong(String day, String format) throws ParseException {
 612     	SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 613         long date = dateFormat.parse(day).getTime();
 614     	return date;
 615     }
 616     
 617     /**
 618      * @param day
 619      * @param format
 620      * @return Date
 621      * @throws ParseException
 622      */
 623     public static Date stringToDate(String day, String format)  {
 624     	try {
 625 			SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 626 			 Date date = dateFormat.parse(day);
 627 			return date;
 628 		} catch (ParseException e) {
 629 			return new Date();
 630 		}
 631     }
 632     
 633     
 634     /**
 635      * longÂûãÊó∂Èó¥Êà≥ËΩ¨‰∏∫StringÂûã
 636      * 
 637      * @param day Áßí
 638      * @return Ê†ºÂºèÂåñÂêéÁöÑÊó•Êúü
 639      * @throws ParseException 
 640      */
 641     public static String longToString(long day, String format) throws ParseException {
 642     	if ((&quot;&quot; + day).length() &lt;= 10){
 643             day=day*1000;
 644         }
 645     	SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 646 	    String date = dateFormat.format(day);
 647     	return date;
 648     }
 649 
 650     /**
 651      *
 652      * @param day Áßí
 653      * @param minusDay ÈúÄË¶ÅÂáèÊéâÁöÑÂ§©Êï∞
 654      * @return Áßí
 655      */
 656     public static int getMinusDate(int day, int minusDay) {
 657         Calendar cal = Calendar.getInstance();
 658         cal.setTime(new Date(day * 1000));
 659         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - minusDay);
 660         cal.set(Calendar.HOUR_OF_DAY, 0);
 661         cal.set(Calendar.MINUTE, 0);
 662         cal.set(Calendar.SECOND, 0);
 663         cal.set(Calendar.MILLISECOND, 0);
 664         return (int) cal.getTimeInMillis() / 1000;
 665     }
 666 
 667     /**
 668      *
 669      * @return long
 670      */
 671     public static long getMillByNow() {
 672         Calendar cal = Calendar.getInstance();
 673         cal.setTime(new Date());
 674         return cal.getTimeInMillis();
 675     }
 676 
 677 	public static int getWeeksBetweenTwoDates(long startDay, long endDay) {
 678 		int week = getWeekOfYear(endDay) - getWeekOfYear(startDay) + 1;
 679 		if(week&lt;1){
 680 			week = getWeekOfYear(endDay) + getMaxWeekOfYear(startDay) - getWeekOfYear(startDay) + 1;
 681 		}
 682 		return week;
 683 	}
 684 
 685 	public static int getMaxWeekOfYear(long startDay) {
 686 		Calendar cal = Calendar.getInstance();
 687         cal.setTime(new Date(startDay * 1000));
 688         return cal.getMaximum(Calendar.WEEK_OF_YEAR);
 689 	}
 690 	
 691 	public static int getMonthsBetweenTwoDates(long startDay, long endDay) {
 692 		int month = DateUtil.getMonth(endDay) - DateUtil.getMonth(startDay) + 1;
 693 		if(month&lt;1){
 694 			month = getMonth(endDay) + 12 - getMonth(startDay) +1;
 695 		}
 696 		return month;
 697 	}
 698 	
 699 	public static Date parseDate(String dateStr, String pattern){
 700 		SimpleDateFormat sdf = new SimpleDateFormat();
 701 		sdf.applyPattern(pattern);
 702 		try {
 703 			return sdf.parse(dateStr);
 704 		} catch (ParseException e) {
 705 			return null;
 706 		}
 707 	}
 708 	
 709 	/**
 710      *
 711      * @param time Long Êó∂Èó¥
 712      * @return long
 713      */
 714     public static long getMinuteStart(long time) {
 715         long firstDay = 0L;
 716         Calendar cal = Calendar.getInstance();
 717         if ((&quot;&quot; + time).length() &gt; 10) {
 718             cal.setTime(new Date(time));
 719         } else {
 720             cal.setTime(new Date(time * 1000));
 721         }
 722         cal.set(Calendar.SECOND, 0);
 723         cal.set(Calendar.MILLISECOND, 0);
 724         firstDay = cal.getTimeInMillis() / 1000;
 725         return firstDay;
 726     }
 727     
 728     /**
 729      * @param time Long
 730      * @return long
 731      */
 732     public static long getHourStart(long time) {
 733         long firstDay = 0L;
 734         Calendar cal = Calendar.getInstance();
 735         if ((&quot;&quot; + time).length() &gt; 10) {
 736             cal.setTime(new Date(time));
 737         } else {
 738             cal.setTime(new Date(time * 1000));
 739         }
 740         cal.set(Calendar.SECOND, 0);
 741         cal.set(Calendar.MILLISECOND, 0);
 742         cal.set(Calendar.MINUTE, 0);
 743         firstDay = cal.getTimeInMillis() / 1000;
 744         return firstDay;
 745     }
 746 
 747     /**
 748      * @param time
 749      * @return Date
 750      */
 751     public static Date getDateByLong(long time){
 752         Date date = new Date();
 753         date.setTime(time);
 754         return date;
 755     }
 756     
 757 
 758     public static Date parseDate(String dateStr, String pattern, Locale locale){
 759     	SimpleDateFormat df = new SimpleDateFormat(
 760 				pattern, locale);
 761 
 762 		df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 763 		try {
 764 			return df.parse(dateStr);
 765 		} catch (ParseException e) {
 766 			return null;
 767 		}
 768 	}
 769     
 770     public static String getDate(Date date, String format, Locale locale) {
 771     	SimpleDateFormat df = new SimpleDateFormat(
 772     			format, locale);
 773     	df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 774         return df.format(date);
 775     }
 776 
 777     public static java.sql.Timestamp columnToTimestamp(Object column) {
 778         if (column == null) {
 779             return null;
 780         } else if(column instanceof String) {
 781             return new java.sql.Timestamp(stringToDate((String)column).getTime());
 782         } else if (column instanceof Integer) {
 783             Integer rawData = (Integer) column;
 784             return new java.sql.Timestamp(rawData.longValue());
 785         } else if (column instanceof Long) {
 786             Long rawData = (Long) column;
 787             return new java.sql.Timestamp(rawData.longValue());
 788         } else if (column instanceof java.sql.Date) {
 789             return (java.sql.Timestamp) column;
 790         } else if(column instanceof Timestamp) {
 791             return (Timestamp) column;
 792         } else if(column instanceof Date) {
 793             Date d = (Date)column;
 794             return new java.sql.Timestamp(d.getTime());
 795         }
 796 
 797         throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
 798     }
 799 
 800     public static String dateToString(Date date) {
 801         LocalDateTime localDateTime = dateToLocalDateTime(date);
 802         return localDateTime.format(DATE_FORMATTER);
 803     }
 804 
 805     public static String timestampToString(Date date) {
 806         LocalDateTime localDateTime = dateToLocalDateTime(date);
 807         return localDateTime.format(DATE_TIME_FORMATTER);
 808     }
 809 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 810 ||||||| GitAnalyzerPlus_base
 811 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 812 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 813 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 814     public static Timestamp getTimestampFromStr(String timeStr) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 815         if (DATETIME.matcher(timeStr).matches()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 816             Instant instant = Instant.from(ISO_INSTANT.parse(timeStr));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 817             return new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 818         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 819             java.sql.Date date = null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 820             try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 821                 date = new java.sql.Date(datetimeFormatter.parse(timeStr).getTime());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 822             } catch (ParseException e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 823                 throw new RuntimeException(&quot;getTimestampFromStr error data is &quot; + timeStr);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 824             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 825             return new Timestamp(date.getTime());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 826         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 827     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 828 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 829     public static java.sql.Date getDateFromStr(String dateStr) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 830         // 2020-01-01 format</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 831         if (DATE.matcher(dateStr).matches()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 832             // convert from local date to instant</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 833             Instant instant = LocalDate.parse(dateStr).atTime(LocalTime.of(0, 0, 0, 0)).toInstant(ZoneOffset.UTC);"> 833             Instant instant = LocalDate.parse(dateStr).atTime(LocalTime.of(0, 0, 0, 0)).toInstant(ZoneOffüîµ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 834             // calculate the timezone offset in millis</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 835             int offset = TimeZone.getDefault().getOffset(instant.toEpochMilli());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 836             // need to remove the offset since time has no TZ component</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 837             return new java.sql.Date(instant.toEpochMilli() - offset);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 838         } else if (DATETIME.matcher(dateStr).matches()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 839             // 2020-01-01T12:12:12Z format</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 840             Instant instant = Instant.from(ISO_INSTANT.parse(dateStr));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 841             return new java.sql.Date(instant.toEpochMilli());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 842         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 843             try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 844                 // 2020-01-01 12:12:12.0 format</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 845                 return new java.sql.Date(datetimeFormatter.parse(dateStr).getTime());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 846             } catch (ParseException e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 847                 throw new RuntimeException(&quot;String convert to Date fail.&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 848             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 849         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 850     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 851 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 852 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 853     public static String getStringFromTimestamp(Timestamp timestamp) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 854         return datetimeFormatter.format(timestamp);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 855     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 856 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 857     public static String getStringFromDate(java.sql.Date date) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 858         return dateFormatter.format(date);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 859     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 860 </span>
 861 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 862 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.util;
  22 
  23 import java.sql.Timestamp;
  24 import java.text.ParseException;
  25 import java.text.SimpleDateFormat;
  26 import java.time.Instant;
  27 import java.time.LocalDate;
  28 import java.time.LocalDateTime;
  29 import java.time.LocalTime;
  30 import java.time.ZoneId;
  31 import java.time.format.DateTimeFormatter;
  32 import java.time.format.DateTimeParseException;
  33 import java.time.ZoneOffset;
  34 import java.util.Calendar;
  35 import java.util.Date;
  36 import java.util.Locale;
  37 import java.util.SimpleTimeZone;
  38 import java.util.TimeZone;
  39 import java.util.regex.Pattern;
  40 
  41 import static java.time.format.DateTimeFormatter.ISO_INSTANT;
  42 
  43 
  44 /**
  45  *
  46  * Reason: TODO ADD REASON(ÂèØÈÄâ)
  47  * Date: 2017Âπ¥03Êúà10Êó• ‰∏ãÂçà1:16:37
  48  * Company: www.dtstack.com
  49  * @author sishu.yss
  50  *
  51  */
  52 public class DateUtil {
  53 
<abbr title="  54     static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);">  54     static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ssüîµ</abbr>
  55     static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);
  56     static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;);
  57 
<abbr title="  58     private static final Pattern DATETIME = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3,9})?Z$&quot;);">  58     private static final Pattern DATETIME = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}T\\d{2}:\\üîµ</abbr>
  59     private static final Pattern DATE = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}$&quot;);
  60 
  61     private static final int MILLIS_PER_SECOND = 1000;
  62 
  63 
  64     public static java.sql.Date columnToDate(Object column) {
  65         if(column instanceof String) {
  66             return new java.sql.Date(stringToDate((String)column).getTime());
  67         } else if (column instanceof Integer) {
  68             Integer rawData = (Integer) column;
  69             return new java.sql.Date(rawData.longValue());
  70         } else if (column instanceof Long) {
  71             Long rawData = (Long) column;
  72             return new java.sql.Date(rawData.longValue());
  73         } else if (column instanceof java.sql.Date) {
  74             return (java.sql.Date) column;
  75         } else if(column instanceof Timestamp) {
  76             Timestamp ts = (Timestamp) column;
  77             return new java.sql.Date(ts.getTime());
  78         }
  79         throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
  80     }
  81 
  82     public static Date stringToDate(String strDate)  {
  83         if(strDate == null){
  84             return null;
  85         }
  86         try {
  87             ;
  88             return localDateTimetoDate(LocalDateTime.parse(strDate, DATE_TIME_FORMATTER));
  89         } catch (DateTimeParseException ignored) {
  90         }
  91 
  92         try {
  93             return localDateTimetoDate(LocalDate.parse(strDate, DATE_FORMATTER).atStartOfDay());
  94         } catch (DateTimeParseException ignored) {
  95         }
  96 
  97         try {
<abbr title="  98             return localDateTimetoDate(LocalDateTime.of(LocalDate.now(), LocalTime.parse(strDate, TIME_FORMATTER)));">  98             return localDateTimetoDate(LocalDateTime.of(LocalDate.now(), LocalTime.parse(strDate, TIME_FOüîµ</abbr>
  99         } catch (DateTimeParseException ignored) {
 100         }
 101 
 102         throw new RuntimeException(&quot;can&#x27;t parse date&quot;);
 103     }
 104 
 105     public static Date localDateTimetoDate(LocalDateTime localDateTime){
 106         return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
 107     }
 108 
 109     public static LocalDateTime dateToLocalDateTime(Date date){
 110         return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
 111     }
 112 
 113     /**
 114      *
 115      *
 116      * @param day Long Êó∂Èó¥
 117      * @return long
 118      */
 119     public static long getTodayStart(long day) {
 120         long firstDay = 0L;
 121         Calendar cal = Calendar.getInstance();
 122         if ((&quot;&quot; + day).length() &gt; 10) {
 123             cal.setTime(new Date(day));
 124         } else {
 125             cal.setTime(new Date(day * 1000));
 126         }
 127         cal.set(Calendar.HOUR_OF_DAY, 0);
 128         cal.set(Calendar.MINUTE, 0);
 129         cal.set(Calendar.SECOND, 0);
 130         cal.set(Calendar.MILLISECOND, 0);
 131         firstDay = cal.getTimeInMillis() / 1000;
 132         return firstDay;
 133     }
 134 
 135     /**
 136      *
 137      * @param day Long Êó∂Èó¥
 138      * @param scope
 139      * @return
 140      */
 141     public static long getTodayStart(long day,String scope) {
 142     	if(&quot;MS&quot;.equals(scope)){
 143     		return getTodayStart(day)*1000;
 144     	}else if(&quot;S&quot;.equals(scope)){
 145     		return getTodayStart(day);
 146     	}else{
 147     		return getTodayStart(day);
 148     	}
 149     }
 150 
 151     /**
 152      *
 153      * @param day Long Êó∂Èó¥
 154      * @return long
 155      */
 156     public static long getNextDayStart(long day) {
 157         long daySpanMill = 86400000L;
 158         long nextDay = 0L;
 159         Calendar cal = Calendar.getInstance();
 160         if ((&quot;&quot; + day).length() &gt; 10) {
 161             cal.setTime(new Date(day));
 162         } else {
 163             cal.setTime(new Date(day * 1000));
 164         }
 165         cal.set(Calendar.HOUR_OF_DAY, 0);
 166         cal.set(Calendar.MINUTE, 0);
 167         cal.set(Calendar.SECOND, 0);
 168         cal.set(Calendar.MILLISECOND, 0);
 169         nextDay = (cal.getTimeInMillis() + daySpanMill) / 1000;
 170         return nextDay;
 171     }
 172 
 173     /**
 174      *
 175      * @param day Long Êó∂Èó¥
 176      * @param scope String Á∫ßÂà´&lt;br&gt;&quot;MS&quot;ÔºöÊØ´ÁßíÁ∫ß&lt;br&gt;&quot;S&quot;:ÁßíÁ∫ß
 177      * @return
 178      */
 179     public static long getNextDayStart(long day,String scope) {
 180     	if(&quot;MS&quot;.equals(scope)){
 181     		return getNextDayStart(day)*1000;
 182     	}else if(&quot;S&quot;.equals(scope)){
 183     		return getNextDayStart(day);
 184     	}else{
 185     		return getNextDayStart(day);
 186     	}
 187     }
 188 
 189 
 190     /**
 191      *
 192      * @param day
 193      * @return
 194      */
 195     public static long getMonthFirst(long day) {
 196         long firstDay = 0L;
 197         Calendar cal = Calendar.getInstance();
 198         cal.setTime(new Date(day * 1000));
 199         cal.set(Calendar.DAY_OF_MONTH, 1);
 200         cal.set(Calendar.HOUR_OF_DAY, 0);
 201         cal.set(Calendar.MINUTE, 0);
 202         cal.set(Calendar.SECOND, 0);
 203         cal.set(Calendar.MILLISECOND, 0);
 204         firstDay = cal.getTimeInMillis() / 1000;
 205         return firstDay;
 206     }
 207 
 208     /**
 209      * @param day
 210      * @return
 211      */
 212     public static int getMonth(long day) {
 213         Calendar cal = Calendar.getInstance();
 214         cal.setTime(new Date(day * 1000));
 215         return cal.get(Calendar.MONTH) + 1;
 216     }
 217 
 218     /**
 219      *
 220      * @author yumo.lck
 221      */
 222     public static int getYear(long day) {
 223         Calendar cal = Calendar.getInstance();
 224         cal.setTime(new Date(day * 1000));
 225         return cal.get(Calendar.YEAR);
 226     }
 227 
 228     /**
 229      *
 230      * @param day
 231      * @return
 232      */
 233     public static long getWeekFirst(long day) {
 234         long firstDay = 0L;
 235         Calendar cal = Calendar.getInstance();
 236         cal.setTime(new Date(day * 1000));
 237         cal.setFirstDayOfWeek(Calendar.MONDAY);
 238         cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
 239         cal.set(Calendar.HOUR_OF_DAY, 0);
 240         cal.set(Calendar.MINUTE, 0);
 241         cal.set(Calendar.SECOND, 0);
 242         cal.set(Calendar.MILLISECOND, 0);
 243         firstDay = cal.getTimeInMillis() / 1000;
 244         return firstDay;
 245     }
 246 
 247     /**
 248      * Ê†πÊçÆÊüê‰∏™Êó•ÊúüÊó∂Èó¥Êà≥ÁßíÂÄºÔºåËé∑ÂèñÊâÄÂú®Âë®Âú®‰∏ÄÂπ¥‰∏≠ÊòØÁ¨¨Âá†Âë®.
 249      *
 250      * @param day
 251      * @return
 252      */
 253     public static int getWeekOfYear(long day) {
 254         Calendar cal = Calendar.getInstance();
 255         cal.setTime(new Date(day * 1000));
 256         return cal.get(Calendar.WEEK_OF_YEAR);
 257     }
 258 
 259     /**
 260      *
 261      * @param day
 262      * @param inFormat
 263      * @param outFormat
 264      * @return String
 265      * @throws ParseException
 266      */
 267     public static String getYesterdayByString(String day, String inFormat, String outFormat){
 268         try {
 269 			SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 270 			Date date = sdf.parse(day);
 271 			Calendar calendar = Calendar.getInstance();
 272 			calendar.setTime(date);
 273 			int calendarDay = calendar.get(Calendar.DATE);
 274 			calendar.set(Calendar.DATE, calendarDay - 1);
 275 			String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 276 			return dayBefore;
 277 		} catch (ParseException e) {
 278 			return null;
 279 		}
 280     }
 281 
 282     /**
 283      *
 284      * @param day
 285      * @param inFormat
 286      * @param outFormat
 287      * @return String
 288      * @throws ParseException
 289      */
<abbr title=" 290     public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseException {"> 290     public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseEüîµ</abbr>
 291         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 292         Date date = sdf.parse(day);
 293         Calendar calendar = Calendar.getInstance();
 294         calendar.setTime(date);
 295         int calendarDay = calendar.get(Calendar.DATE);
 296         calendar.set(Calendar.DATE, calendarDay + 1);
 297         String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 298         return dayBefore;
 299     }
 300 
 301     /**
 302      *
 303      * @param date
 304      * @return Date
 305      * @throws ParseException
 306      */
 307     public static Date getTomorrowByDate(Date date) throws ParseException {
 308         Calendar calendar = Calendar.getInstance();
 309         calendar.setTime(date);
 310         int calendarDay = calendar.get(Calendar.DATE);
 311         calendar.set(Calendar.DATE, calendarDay + 1);
 312         return calendar.getTime();
 313     }
 314 
 315     /**
 316      *
 317      * @param day
 318      * @param inFormat
 319      * @param outFormat
 320      * @return String
 321      * @throws ParseException
 322      */
<abbr title=" 323     public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws ParseException {"> 323     public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws Paüîµ</abbr>
 324         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 325         Date date = sdf.parse(day);
 326         Calendar calendar = Calendar.getInstance();
 327         calendar.setTime(date);
 328         int calendarDay = calendar.get(Calendar.DATE);
 329         calendar.set(Calendar.DATE, calendarDay - 30);
 330         return new SimpleDateFormat(outFormat).format(calendar.getTime());
 331     }
 332 
 333     /**
 334      *
 335      * @param day
 336      * @param inFormat
 337      * @param outFormat
 338      * @return String
 339      * @throws ParseException
 340      */
<abbr title=" 341     public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws ParseException {"> 341     public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws Parüîµ</abbr>
 342     	SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 343     	Date date = sdf.parse(day);
 344     	Calendar calendar = Calendar.getInstance();
 345     	calendar.setTime(date);
 346     	int calendarDay = calendar.get(Calendar.DATE);
 347     	calendar.set(Calendar.DATE, calendarDay + 30);
 348     	String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 349     	return dayBefore;
 350     }
 351 
 352 
 353     /**
 354      *
 355      * @param day
 356      * @param inFormat
 357      * @param outFormat
 358      * @return String
 359      * @throws ParseException
 360      */
<abbr title=" 361     public static String getDateStrToFormat(String day, String inFormat, String outFormat) throws ParseException {"> 361     public static String getDateStrToFormat(String day, String inFormat, String outFormat) throws ParseExüîµ</abbr>
 362         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 363         Date date = sdf.parse(day);
 364         Calendar calendar = Calendar.getInstance();
 365         calendar.setTime(date);
 366         String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 367         return dayBefore;
 368     }
 369 
 370     public static long getDateMillToFormat(String day, String inFormat) throws ParseException {
 371         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 372         Date date = sdf.parse(day);
 373         Calendar calendar = Calendar.getInstance();
 374         calendar.setTime(date);
 375         return calendar.getTimeInMillis()/1000;
 376     }
 377 
 378     /**
 379      *
 380      * @author sishu.yss
 381      * @param year
 382      * @param month
 383      * @return
 384      */
 385     public static long getFirstDay4Month(int year, int month) {
 386         long firstDay = 0L;
 387         Calendar cal = Calendar.getInstance();
 388         cal.set(Calendar.YEAR, year);
 389         cal.set(Calendar.MONTH, month - 1);
 390         cal.set(Calendar.DAY_OF_MONTH, 1);
 391         cal.set(Calendar.HOUR_OF_DAY, 0);
 392         cal.set(Calendar.MINUTE, 0);
 393         cal.set(Calendar.SECOND, 0);
 394         cal.set(Calendar.MILLISECOND, 0);
 395         firstDay = cal.getTimeInMillis() / 1000;
 396         return firstDay;
 397     }
 398 
 399     /**
 400      *
 401      * @author yumo.lck
 402      * @param year
 403      * @param month
 404      * @return
 405      */
 406     public static long getLastDay4Month(int year, int month) {
 407         long lastDay = 0L;
 408         Calendar cal = Calendar.getInstance();
 409         cal.set(Calendar.YEAR, year);
 410         cal.set(Calendar.MONTH, month);
<abbr title=" 411         //1 represents a zero next month, can be seen as the end of the first day of the month most one day, but the data table on the last day of the zero point on the line"> 411         //1 represents a zero next month, can be seen as the end of the first day of the month most one düîµ</abbr>
 412         cal.set(Calendar.DAY_OF_MONTH, 0);
 413         cal.set(Calendar.HOUR_OF_DAY, 0);
 414         cal.set(Calendar.MINUTE, 0);
 415         cal.set(Calendar.SECOND, 0);
 416         cal.set(Calendar.MILLISECOND, 0);
 417         lastDay = cal.getTimeInMillis() / 1000;
 418         return lastDay;
 419     }
 420 
 421     /**
 422      *
 423      * @author yumo.lck
 424      * @param chooseFirstDay
 425      */
 426 
 427     public static long getBeforeMonthDay(long day, boolean chooseFirstDay) {
 428         long chooseDay = 0L;
 429         int currentMonth = getMonth(day);
 430         int currentYear = getYear(day);
 431         if (currentMonth &gt; 1) {
 432             currentMonth--;
 433         } else {
 434             currentYear--;
 435             currentMonth = 12;
 436         }
 437         if (chooseFirstDay) {
 438             chooseDay = getFirstDay4Month(currentYear, currentMonth);
 439             return chooseDay;
 440         } else {
 441             chooseDay = getLastDay4Month(currentYear, currentMonth);
 442             return chooseDay;
 443         }
 444 
 445     }
 446 
 447     /**
 448      * @return long
 449      */
 450     public static long getMillByOneDay() {
 451         Calendar cal = Calendar.getInstance();
 452         cal.set(Calendar.HOUR_OF_DAY, 0);
 453         cal.set(Calendar.MINUTE, 0);
 454         cal.set(Calendar.SECOND, 0);
 455         cal.set(Calendar.MILLISECOND, 0);
 456         return cal.getTimeInMillis() / 1000;
 457     }
 458 
 459     /**
 460      *
 461      * @return long
 462      */
 463     public static long getMillByYesDay() {
 464         Calendar cal = Calendar.getInstance();
 465         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 1);
 466         cal.set(Calendar.HOUR_OF_DAY, 0);
 467         cal.set(Calendar.MINUTE, 0);
 468         cal.set(Calendar.SECOND, 0);
 469         cal.set(Calendar.MILLISECOND, 0);
 470         return cal.getTimeInMillis() / 1000;
 471     }
 472 
 473     /**
 474      *
 475      * @return
 476      */
 477     public static long getMillByLastWeekDay() {
 478         Calendar cal = Calendar.getInstance();
 479         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 7);
 480         cal.set(Calendar.HOUR_OF_DAY, 0);
 481         cal.set(Calendar.MINUTE, 0);
 482         cal.set(Calendar.SECOND, 0);
 483         cal.set(Calendar.MILLISECOND, 0);
 484         return cal.getTimeInMillis() / 1000;
 485     }
 486 
 487    /**
 488     * @return long
 489     */
 490     public static long getMillByDay(int severalDays,String condition) {
 491     	int dateT=0;
 492         Calendar cal = Calendar.getInstance();
 493     	if(condition==null){
 494     		return getMillToDay(cal,dateT);
 495     	}
 496         if(&quot;-&quot;.equals(condition)){
 497         	dateT = (cal.get(Calendar.DATE) - severalDays);
 498         	return getMillToDay(cal,dateT);
 499         }
 500         if(&quot;+&quot;.equals(condition)){
 501         	dateT = (cal.get(Calendar.DATE) + severalDays);
 502         	return getMillToDay(cal,dateT);
 503         }
 504 		return getMillToDay(cal,dateT);
 505   }
 506 
 507     /**
 508      * @return long
 509      */
 510     public static long getStampByDay(int severalDays,String condition) {
 511     	int dateT=0;
 512     	Calendar cal = Calendar.getInstance();
 513     	if(condition==null){
 514     		return getStampToDay(cal,dateT);
 515     	}
 516     	if(&quot;-&quot;.equals(condition)){
 517     		dateT = (cal.get(Calendar.DATE) - severalDays);
 518     		return getStampToDay(cal,dateT);
 519     	}
 520     	if(&quot;+&quot;.equals(condition)){
 521     		dateT = (cal.get(Calendar.DATE) + severalDays);
 522     		return getStampToDay(cal,dateT);
 523     	}
 524     	return getStampToDay(cal,dateT);
 525     }
 526     /**
 527      * @return long
 528      */
 529     public static long getMillByDay(){
 530 		return getMillByDay(0,null);
 531     }
 532 
 533     /**
 534      * @param cal  Calendar
 535      * @param dateT Integer
 536      * @return  long
 537      */
 538     public static long getMillToDay(Calendar cal,int dateT){
 539 		   if(dateT!=0){
 540 			   cal.set(Calendar.DATE, dateT);
 541 		   }
 542 	       cal.set(Calendar.HOUR_OF_DAY, 0);
 543 	       cal.set(Calendar.MINUTE, 0);
 544 	       cal.set(Calendar.SECOND, 0);
 545 	       cal.set(Calendar.MILLISECOND, 0);
 546 	       return cal.getTimeInMillis()/1000;
 547 	}
 548 
 549     /**
 550      * @param cal  Calendar
 551      * @param dateT Integer
 552      * @return  long
 553      */
 554     public static long getStampToDay(Calendar cal,int dateT){
 555     	if(dateT!=0){
 556     		cal.set(Calendar.DATE, dateT);
 557     	}
 558     	return cal.getTimeInMillis();
 559     }
 560 
 561     public static String getToday() {
 562         Calendar cal = Calendar.getInstance();
 563         return cal.get(1) + &quot;Âπ¥&quot; + cal.get(2) + &quot;Êúà&quot; + cal.get(3) + &quot;Êó•&quot;;
 564     }
 565 
 566     /**
 567      * @param day
 568      * @return format time
 569      */
 570     public static String getDate(long day, String format) {
 571         Calendar cal = Calendar.getInstance();
 572         if ((&quot;&quot; + day).length() &gt; 10) {
 573             cal.setTime(new Date(day));
 574         } else {
 575             cal.setTime(new Date(day * 1000));
 576         }
 577         SimpleDateFormat sf = new SimpleDateFormat(format);
 578         return sf.format(cal.getTime());
 579     }
 580 
 581     /**
 582      *
 583      * @param  date
 584      * @return
 585      */
 586     public static String getDate(Date date, String format) {
 587         SimpleDateFormat sf = new SimpleDateFormat(format);
 588         return sf.format(date);
 589     }
 590 
 591 
 592     /**
 593      *
 594      * @param day
 595      * @param format
 596      * @return long
 597      * @throws ParseException
 598      */
 599     public static long stringToLong(String day, String format) throws ParseException {
 600     	SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 601         long date = dateFormat.parse(day).getTime();
 602     	return date;
 603     }
 604 
 605     /**
 606      * @param day
 607      * @param format
 608      * @return Date
 609      * @throws ParseException
 610      */
 611     public static Date stringToDate(String day, String format)  {
 612     	try {
 613 			SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 614 			 Date date = dateFormat.parse(day);
 615 			return date;
 616 		} catch (ParseException e) {
 617 			return new Date();
 618 		}
 619     }
 620 
 621 
 622     /**
 623      * longÂûãÊó∂Èó¥Êà≥ËΩ¨‰∏∫StringÂûã
 624      *
 625      * @param day Áßí
 626      * @return Ê†ºÂºèÂåñÂêéÁöÑÊó•Êúü
 627      * @throws ParseException
 628      */
 629     public static String longToString(long day, String format) throws ParseException {
 630     	if ((&quot;&quot; + day).length() &lt;= 10){
 631             day=day*1000;
 632         }
 633     	SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 634 	    String date = dateFormat.format(day);
 635     	return date;
 636     }
 637 
 638     /**
 639      *
 640      * @param day Áßí
 641      * @param minusDay ÈúÄË¶ÅÂáèÊéâÁöÑÂ§©Êï∞
 642      * @return Áßí
 643      */
 644     public static int getMinusDate(int day, int minusDay) {
 645         Calendar cal = Calendar.getInstance();
 646         cal.setTime(new Date(day * 1000));
 647         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - minusDay);
 648         cal.set(Calendar.HOUR_OF_DAY, 0);
 649         cal.set(Calendar.MINUTE, 0);
 650         cal.set(Calendar.SECOND, 0);
 651         cal.set(Calendar.MILLISECOND, 0);
 652         return (int) cal.getTimeInMillis() / 1000;
 653     }
 654 
 655     /**
 656      *
 657      * @return long
 658      */
 659     public static long getMillByNow() {
 660         Calendar cal = Calendar.getInstance();
 661         cal.setTime(new Date());
 662         return cal.getTimeInMillis();
 663     }
 664 
 665 	public static int getWeeksBetweenTwoDates(long startDay, long endDay) {
 666 		int week = getWeekOfYear(endDay) - getWeekOfYear(startDay) + 1;
 667 		if(week&lt;1){
 668 			week = getWeekOfYear(endDay) + getMaxWeekOfYear(startDay) - getWeekOfYear(startDay) + 1;
 669 		}
 670 		return week;
 671 	}
 672 
 673 	public static int getMaxWeekOfYear(long startDay) {
 674 		Calendar cal = Calendar.getInstance();
 675         cal.setTime(new Date(startDay * 1000));
 676         return cal.getMaximum(Calendar.WEEK_OF_YEAR);
 677 	}
 678 
 679 	public static int getMonthsBetweenTwoDates(long startDay, long endDay) {
 680 		int month = DateUtil.getMonth(endDay) - DateUtil.getMonth(startDay) + 1;
 681 		if(month&lt;1){
 682 			month = getMonth(endDay) + 12 - getMonth(startDay) +1;
 683 		}
 684 		return month;
 685 	}
 686 
 687 	public static Date parseDate(String dateStr, String pattern){
 688 		SimpleDateFormat sdf = new SimpleDateFormat();
 689 		sdf.applyPattern(pattern);
 690 		try {
 691 			return sdf.parse(dateStr);
 692 		} catch (ParseException e) {
 693 			return null;
 694 		}
 695 	}
 696 
 697 	/**
 698      *
 699      * @param time Long Êó∂Èó¥
 700      * @return long
 701      */
 702     public static long getMinuteStart(long time) {
 703         long firstDay = 0L;
 704         Calendar cal = Calendar.getInstance();
 705         if ((&quot;&quot; + time).length() &gt; 10) {
 706             cal.setTime(new Date(time));
 707         } else {
 708             cal.setTime(new Date(time * 1000));
 709         }
 710         cal.set(Calendar.SECOND, 0);
 711         cal.set(Calendar.MILLISECOND, 0);
 712         firstDay = cal.getTimeInMillis() / 1000;
 713         return firstDay;
 714     }
 715 
 716     /**
 717      * @param time Long
 718      * @return long
 719      */
 720     public static long getHourStart(long time) {
 721         long firstDay = 0L;
 722         Calendar cal = Calendar.getInstance();
 723         if ((&quot;&quot; + time).length() &gt; 10) {
 724             cal.setTime(new Date(time));
 725         } else {
 726             cal.setTime(new Date(time * 1000));
 727         }
 728         cal.set(Calendar.SECOND, 0);
 729         cal.set(Calendar.MILLISECOND, 0);
 730         cal.set(Calendar.MINUTE, 0);
 731         firstDay = cal.getTimeInMillis() / 1000;
 732         return firstDay;
 733     }
 734 
 735     /**
 736      * @param time
 737      * @return Date
 738      */
 739     public static Date getDateByLong(long time){
 740         Date date = new Date();
 741         date.setTime(time);
 742         return date;
 743     }
 744 
 745 
 746     public static Date parseDate(String dateStr, String pattern, Locale locale){
 747     	SimpleDateFormat df = new SimpleDateFormat(
 748 				pattern, locale);
 749 
 750 		df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 751 		try {
 752 			return df.parse(dateStr);
 753 		} catch (ParseException e) {
 754 			return null;
 755 		}
 756 	}
 757 
 758     public static String getDate(Date date, String format, Locale locale) {
 759     	SimpleDateFormat df = new SimpleDateFormat(
 760     			format, locale);
 761     	df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 762         return df.format(date);
 763     }
 764 
 765     public static java.sql.Timestamp columnToTimestamp(Object column) {
 766         if (column == null) {
 767             return null;
 768         } else if(column instanceof String) {
 769             return new java.sql.Timestamp(stringToDate((String)column).getTime());
 770         } else if (column instanceof Integer) {
 771             Integer rawData = (Integer) column;
 772             return new java.sql.Timestamp(rawData.longValue());
 773         } else if (column instanceof Long) {
 774             Long rawData = (Long) column;
 775             return new java.sql.Timestamp(rawData.longValue());
 776         } else if (column instanceof java.sql.Date) {
 777             return (java.sql.Timestamp) column;
 778         } else if(column instanceof Timestamp) {
 779             return (Timestamp) column;
 780         } else if(column instanceof Date) {
 781             Date d = (Date)column;
 782             return new java.sql.Timestamp(d.getTime());
 783         }
 784 
 785         throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
 786     }
 787 
 788     public static String dateToString(Date date) {
 789         LocalDateTime localDateTime = dateToLocalDateTime(date);
 790         return localDateTime.format(DATE_FORMATTER);
 791     }
 792 
 793     public static String timestampToString(Date date) {
 794         LocalDateTime localDateTime = dateToLocalDateTime(date);
 795         return localDateTime.format(DATE_TIME_FORMATTER);
 796     }
 797 
 798 
 799     public static Timestamp getTimestampFromStr(String timeStr) {
 800         if (DATETIME.matcher(timeStr).matches()) {
 801             Instant instant = Instant.from(ISO_INSTANT.parse(timeStr));
 802             return new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);
 803         } else {
 804             java.sql.Date date = null;
 805             try {
 806                 date = new java.sql.Date(datetimeFormatter.parse(timeStr).getTime());
 807             } catch (ParseException e) {
 808                 throw new RuntimeException(&quot;getTimestampFromStr error data is &quot; + timeStr);
 809             }
 810             return new Timestamp(date.getTime());
 811         }
 812     }
 813 
 814     public static java.sql.Date getDateFromStr(String dateStr) {
 815         // 2020-01-01 format
 816         if (DATE.matcher(dateStr).matches()) {
 817             // convert from local date to instant
<abbr title=" 818             Instant instant = LocalDate.parse(dateStr).atTime(LocalTime.of(0, 0, 0, 0)).toInstant(ZoneOffset.UTC);"> 818             Instant instant = LocalDate.parse(dateStr).atTime(LocalTime.of(0, 0, 0, 0)).toInstant(ZoneOffüîµ</abbr>
 819             // calculate the timezone offset in millis
 820             int offset = TimeZone.getDefault().getOffset(instant.toEpochMilli());
 821             // need to remove the offset since time has no TZ component
 822             return new java.sql.Date(instant.toEpochMilli() - offset);
 823         } else if (DATETIME.matcher(dateStr).matches()) {
 824             // 2020-01-01T12:12:12Z format
 825             Instant instant = Instant.from(ISO_INSTANT.parse(dateStr));
 826             return new java.sql.Date(instant.toEpochMilli());
 827         } else {
 828             try {
 829                 // 2020-01-01 12:12:12.0 format
 830                 return new java.sql.Date(datetimeFormatter.parse(dateStr).getTime());
 831             } catch (ParseException e) {
 832                 throw new RuntimeException(&quot;String convert to Date fail.&quot;);
 833             }
 834         }
 835     }
 836 
 837 
 838     public static String getStringFromTimestamp(Timestamp timestamp) {
 839         return datetimeFormatter.format(timestamp);
 840     }
 841 
 842     public static String getStringFromDate(java.sql.Date date) {
 843         return dateFormatter.format(date);
 844     }
 845 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.util;
  19 
  20 import java.sql.Timestamp;
  21 import java.text.ParseException;
  22 import java.text.SimpleDateFormat;
  23 import java.time.Instant;
  24 import java.time.LocalDate;
  25 import java.time.LocalDateTime;
  26 import java.time.LocalTime;
  27 import java.time.ZoneId;
  28 import java.time.ZoneOffset;
  29 import java.time.format.DateTimeFormatter;
  30 import java.time.format.DateTimeParseException;
  31 import java.util.Calendar;
  32 import java.util.Date;
  33 import java.util.Locale;
  34 import java.util.SimpleTimeZone;
  35 import java.util.TimeZone;
  36 import java.util.regex.Pattern;
  37 import static java.time.format.DateTimeFormatter.ISO_INSTANT;
  38 
  39 
  40 /**
  41  *
  42  * Reason: TODO ADD REASON(ÂèØÈÄâ)
  43  * Date: 2017Âπ¥03Êúà10Êó• ‰∏ãÂçà1:16:37
  44  * Company: www.dtstack.com
  45  * @author sishu.yss
  46  *
  47  */
  48 public class DateUtil {
<abbr title="  49     static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);">  49     static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ssüîµ</abbr>
  50 
  51     static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);
  52 
  53     static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;);
  54 
  55     public static java.sql.Date columnToDate(Object column) {
  56         if(column instanceof String) {
  57             return new java.sql.Date(stringToDate((String)column).getTime());
  58         } else if (column instanceof Integer) {
  59             Integer rawData = (Integer) column;
  60             return new java.sql.Date(rawData.longValue());
  61         } else if (column instanceof Long) {
  62             Long rawData = (Long) column;
  63             return new java.sql.Date(rawData.longValue());
  64         } else if (column instanceof java.sql.Date) {
  65             return (java.sql.Date) column;
  66         } else if(column instanceof Timestamp) {
  67             Timestamp ts = (Timestamp) column;
  68             return new java.sql.Date(ts.getTime());
  69         }
  70         throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
  71     }
  72 
  73     public static Date stringToDate(String strDate) {
  74         if (strDate == null) {
  75             return null;
  76         }
  77         try {
  78             return localDateTimetoDate(LocalDateTime.parse(strDate, DATE_TIME_FORMATTER));
  79         } catch (DateTimeParseException ignored) {
  80         }
  81         try {
  82             return localDateTimetoDate(LocalDate.parse(strDate, DATE_FORMATTER).atStartOfDay());
  83         } catch (DateTimeParseException ignored) {
  84         }
  85         try {
<abbr title="  86             return localDateTimetoDate(LocalDateTime.of(LocalDate.now(), LocalTime.parse(strDate, TIME_FORMATTER)));">  86             return localDateTimetoDate(LocalDateTime.of(LocalDate.now(), LocalTime.parse(strDate, TIME_FOüîµ</abbr>
  87         } catch (DateTimeParseException ignored) {
  88         }
  89         throw new RuntimeException(&quot;can&#x27;t parse date&quot;);
  90     }
  91 
  92     public static Date localDateTimetoDate(LocalDateTime localDateTime){
  93         return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
  94     }
  95 
  96     public static LocalDateTime dateToLocalDateTime(Date date){
  97         return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
  98     }
  99 
 100     /**
 101      *
 102      *
 103      * @param day Long Êó∂Èó¥
 104      * @return long
 105      */
 106     public static long getTodayStart(long day) {
 107         long firstDay = 0L;
 108         Calendar cal = Calendar.getInstance();
 109         if ((&quot;&quot; + day).length() &gt; 10) {
 110             cal.setTime(new Date(day));
 111         } else {
 112             cal.setTime(new Date(day * 1000));
 113         }
 114         cal.set(Calendar.HOUR_OF_DAY, 0);
 115         cal.set(Calendar.MINUTE, 0);
 116         cal.set(Calendar.SECOND, 0);
 117         cal.set(Calendar.MILLISECOND, 0);
 118         firstDay = cal.getTimeInMillis() / 1000;
 119         return firstDay;
 120     }
 121 
 122     /**
 123      *
 124      * @param day Long Êó∂Èó¥
 125      * @param scope
 126      * @return
 127      */
 128     public static long getTodayStart(long day, String scope) {
 129         if (&quot;MS&quot;.equals(scope)) {
 130             return getTodayStart(day) * 1000;
 131         } else if (&quot;S&quot;.equals(scope)) {
 132             return getTodayStart(day);
 133         } else {
 134             return getTodayStart(day);
 135         }
 136     }
 137 
 138     /**
 139      *
 140      * @param day Long Êó∂Èó¥
 141      * @return long
 142      */
 143     public static long getNextDayStart(long day) {
 144         long daySpanMill = 86400000L;
 145         long nextDay = 0L;
 146         Calendar cal = Calendar.getInstance();
 147         if ((&quot;&quot; + day).length() &gt; 10) {
 148             cal.setTime(new Date(day));
 149         } else {
 150             cal.setTime(new Date(day * 1000));
 151         }
 152         cal.set(Calendar.HOUR_OF_DAY, 0);
 153         cal.set(Calendar.MINUTE, 0);
 154         cal.set(Calendar.SECOND, 0);
 155         cal.set(Calendar.MILLISECOND, 0);
 156         nextDay = (cal.getTimeInMillis() + daySpanMill) / 1000;
 157         return nextDay;
 158     }
 159 
 160     /**
 161      *
 162      * @param day Long Êó∂Èó¥
 163      * @param scope String Á∫ßÂà´&lt;br&gt;&quot;MS&quot;ÔºöÊØ´ÁßíÁ∫ß&lt;br&gt;&quot;S&quot;:ÁßíÁ∫ß
 164      * @return
 165      */
 166     public static long getNextDayStart(long day, String scope) {
 167         if (&quot;MS&quot;.equals(scope)) {
 168             return getNextDayStart(day) * 1000;
 169         } else if (&quot;S&quot;.equals(scope)) {
 170             return getNextDayStart(day);
 171         } else {
 172             return getNextDayStart(day);
 173         }
 174     }
 175 
 176     /**
 177      *
 178      * @param day
 179      * @return
 180      */
 181     public static long getMonthFirst(long day) {
 182         long firstDay = 0L;
 183         Calendar cal = Calendar.getInstance();
 184         cal.setTime(new Date(day * 1000));
 185         cal.set(Calendar.DAY_OF_MONTH, 1);
 186         cal.set(Calendar.HOUR_OF_DAY, 0);
 187         cal.set(Calendar.MINUTE, 0);
 188         cal.set(Calendar.SECOND, 0);
 189         cal.set(Calendar.MILLISECOND, 0);
 190         firstDay = cal.getTimeInMillis() / 1000;
 191         return firstDay;
 192     }
 193 
 194     /**
 195      * @param day
 196      * @return
 197      */
 198     public static int getMonth(long day) {
 199         Calendar cal = Calendar.getInstance();
 200         cal.setTime(new Date(day * 1000));
 201         return cal.get(Calendar.MONTH) + 1;
 202     }
 203 
 204     /**
 205      *
 206      * @author yumo.lck
 207      */
 208     public static int getYear(long day) {
 209         Calendar cal = Calendar.getInstance();
 210         cal.setTime(new Date(day * 1000));
 211         return cal.get(Calendar.YEAR);
 212     }
 213 
 214     /**
 215      *
 216      * @param day
 217      * @return
 218      */
 219     public static long getWeekFirst(long day) {
 220         long firstDay = 0L;
 221         Calendar cal = Calendar.getInstance();
 222         cal.setTime(new Date(day * 1000));
 223         cal.setFirstDayOfWeek(Calendar.MONDAY);
 224         cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
 225         cal.set(Calendar.HOUR_OF_DAY, 0);
 226         cal.set(Calendar.MINUTE, 0);
 227         cal.set(Calendar.SECOND, 0);
 228         cal.set(Calendar.MILLISECOND, 0);
 229         firstDay = cal.getTimeInMillis() / 1000;
 230         return firstDay;
 231     }
 232 
 233     /**
 234      * Ê†πÊçÆÊüê‰∏™Êó•ÊúüÊó∂Èó¥Êà≥ÁßíÂÄºÔºåËé∑ÂèñÊâÄÂú®Âë®Âú®‰∏ÄÂπ¥‰∏≠ÊòØÁ¨¨Âá†Âë®.
 235      *
 236      * @param day
 237      * @return
 238      */
 239     public static int getWeekOfYear(long day) {
 240         Calendar cal = Calendar.getInstance();
 241         cal.setTime(new Date(day * 1000));
 242         return cal.get(Calendar.WEEK_OF_YEAR);
 243     }
 244 
 245     /**
 246      *
 247      * @param day
 248      * @param inFormat
 249      * @param outFormat
 250      * @return String
 251      * @throws ParseException
 252      */
 253     public static String getYesterdayByString(String day, String inFormat, String outFormat){
 254         try {
 255     			SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 256     			Date date = sdf.parse(day);
 257     			Calendar calendar = Calendar.getInstance();
 258     			calendar.setTime(date);
 259     			int calendarDay = calendar.get(Calendar.DATE);
 260     			calendar.set(Calendar.DATE, calendarDay - 1);
 261     			String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 262     			return dayBefore;
 263     		} catch (ParseException e) {
 264     			return null;
 265     		}
 266     }
 267 
 268     /**
 269      *
 270      * @param day
 271      * @param inFormat
 272      * @param outFormat
 273      * @return String
 274      * @throws ParseException
 275      */
<abbr title=" 276     public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseException {"> 276     public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseEüîµ</abbr>
 277         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 278         Date date = sdf.parse(day);
 279         Calendar calendar = Calendar.getInstance();
 280         calendar.setTime(date);
 281         int calendarDay = calendar.get(Calendar.DATE);
 282         calendar.set(Calendar.DATE, calendarDay + 1);
 283         String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 284         return dayBefore;
 285     }
 286 
 287     /**
 288      *
 289      * @param date
 290      * @return Date
 291      * @throws ParseException
 292      */
 293     public static Date getTomorrowByDate(Date date) throws ParseException {
 294         Calendar calendar = Calendar.getInstance();
 295         calendar.setTime(date);
 296         int calendarDay = calendar.get(Calendar.DATE);
 297         calendar.set(Calendar.DATE, calendarDay + 1);
 298         return calendar.getTime();
 299     }
 300 
 301     /**
 302      *
 303      * @param day
 304      * @param inFormat
 305      * @param outFormat
 306      * @return String
 307      * @throws ParseException
 308      */
<abbr title=" 309     public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws ParseException {"> 309     public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws Paüîµ</abbr>
 310         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 311         Date date = sdf.parse(day);
 312         Calendar calendar = Calendar.getInstance();
 313         calendar.setTime(date);
 314         int calendarDay = calendar.get(Calendar.DATE);
 315         calendar.set(Calendar.DATE, calendarDay - 30);
 316         return new SimpleDateFormat(outFormat).format(calendar.getTime());
 317     }
 318 
 319     /**
 320      *
 321      * @param day
 322      * @param inFormat
 323      * @param outFormat
 324      * @return String
 325      * @throws ParseException
 326      */
<abbr title=" 327     public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws ParseException {"> 327     public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws Parüîµ</abbr>
 328     	SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 329     	Date date = sdf.parse(day);
 330     	Calendar calendar = Calendar.getInstance();
 331     	calendar.setTime(date);
 332     	int calendarDay = calendar.get(Calendar.DATE);
 333     	calendar.set(Calendar.DATE, calendarDay + 30);
 334     	String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 335     	return dayBefore;
 336     }
 337 
 338     /**
 339      *
 340      * @param day
 341      * @param inFormat
 342      * @param outFormat
 343      * @return String
 344      * @throws ParseException
 345      */
<abbr title=" 346     public static String getDateStrToFormat(String day, String inFormat, String outFormat) throws ParseException {"> 346     public static String getDateStrToFormat(String day, String inFormat, String outFormat) throws ParseExüîµ</abbr>
 347         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 348         Date date = sdf.parse(day);
 349         Calendar calendar = Calendar.getInstance();
 350         calendar.setTime(date);
 351         String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 352         return dayBefore;
 353     }
 354 
 355     public static long getDateMillToFormat(String day, String inFormat) throws ParseException {
 356         SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 357         Date date = sdf.parse(day);
 358         Calendar calendar = Calendar.getInstance();
 359         calendar.setTime(date);
 360         return calendar.getTimeInMillis() / 1000;
 361     }
 362 
 363     /**
 364      *
 365      * @author sishu.yss
 366      * @param year
 367      * @param month
 368      * @return
 369      */
 370     public static long getFirstDay4Month(int year, int month) {
 371         long firstDay = 0L;
 372         Calendar cal = Calendar.getInstance();
 373         cal.set(Calendar.YEAR, year);
 374         cal.set(Calendar.MONTH, month - 1);
 375         cal.set(Calendar.DAY_OF_MONTH, 1);
 376         cal.set(Calendar.HOUR_OF_DAY, 0);
 377         cal.set(Calendar.MINUTE, 0);
 378         cal.set(Calendar.SECOND, 0);
 379         cal.set(Calendar.MILLISECOND, 0);
 380         firstDay = cal.getTimeInMillis() / 1000;
 381         return firstDay;
 382     }
 383 
 384     /**
 385      *
 386      * @author yumo.lck
 387      * @param year
 388      * @param month
 389      * @return
 390      */
 391     public static long getLastDay4Month(int year, int month) {
 392         long lastDay = 0L;
 393         Calendar cal = Calendar.getInstance();
 394         cal.set(Calendar.YEAR, year);
 395         cal.set(Calendar.MONTH, month);
<abbr title=" 396         //1 represents a zero next month, can be seen as the end of the first day of the month most one day, but the data table on the last day of the zero point on the line"> 396         //1 represents a zero next month, can be seen as the end of the first day of the month most one düîµ</abbr>
 397         cal.set(Calendar.DAY_OF_MONTH, 0);
 398         cal.set(Calendar.HOUR_OF_DAY, 0);
 399         cal.set(Calendar.MINUTE, 0);
 400         cal.set(Calendar.SECOND, 0);
 401         cal.set(Calendar.MILLISECOND, 0);
 402         lastDay = cal.getTimeInMillis() / 1000;
 403         return lastDay;
 404     }
 405 
 406     /**
 407      *
 408      * @author yumo.lck
 409      * @param chooseFirstDay
 410      */
 411 
 412     public static long getBeforeMonthDay(long day, boolean chooseFirstDay) {
 413         long chooseDay = 0L;
 414         int currentMonth = getMonth(day);
 415         int currentYear = getYear(day);
 416         if (currentMonth &gt; 1) {
 417             currentMonth--;
 418         } else {
 419             currentYear--;
 420             currentMonth = 12;
 421         }
 422         if (chooseFirstDay) {
 423             chooseDay = getFirstDay4Month(currentYear, currentMonth);
 424             return chooseDay;
 425         } else {
 426             chooseDay = getLastDay4Month(currentYear, currentMonth);
 427             return chooseDay;
 428         }
 429 
 430     }
 431 
 432     /**
 433      * @return long
 434      */
 435     public static long getMillByOneDay() {
 436         Calendar cal = Calendar.getInstance();
 437         cal.set(Calendar.HOUR_OF_DAY, 0);
 438         cal.set(Calendar.MINUTE, 0);
 439         cal.set(Calendar.SECOND, 0);
 440         cal.set(Calendar.MILLISECOND, 0);
 441         return cal.getTimeInMillis() / 1000;
 442     }
 443 
 444     /**
 445      *
 446      * @return long
 447      */
 448     public static long getMillByYesDay() {
 449         Calendar cal = Calendar.getInstance();
 450         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 1);
 451         cal.set(Calendar.HOUR_OF_DAY, 0);
 452         cal.set(Calendar.MINUTE, 0);
 453         cal.set(Calendar.SECOND, 0);
 454         cal.set(Calendar.MILLISECOND, 0);
 455         return cal.getTimeInMillis() / 1000;
 456     }
 457 
 458     /**
 459      *
 460      * @return
 461      */
 462     public static long getMillByLastWeekDay() {
 463         Calendar cal = Calendar.getInstance();
 464         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 7);
 465         cal.set(Calendar.HOUR_OF_DAY, 0);
 466         cal.set(Calendar.MINUTE, 0);
 467         cal.set(Calendar.SECOND, 0);
 468         cal.set(Calendar.MILLISECOND, 0);
 469         return cal.getTimeInMillis() / 1000;
 470     }
 471 
 472 /**
 473  * @return long
 474  */
 475     public static long getMillByDay(int severalDays, String condition) {
 476         int dateT = 0;
 477         Calendar cal = Calendar.getInstance();
 478         if (condition == null) {
 479             return getMillToDay(cal, dateT);
 480         }
 481         if (&quot;-&quot;.equals(condition)) {
 482             dateT = cal.get(Calendar.DATE) - severalDays;
 483             return getMillToDay(cal, dateT);
 484         }
 485         if (&quot;+&quot;.equals(condition)) {
 486             dateT = cal.get(Calendar.DATE) + severalDays;
 487             return getMillToDay(cal, dateT);
 488         }
 489         return getMillToDay(cal, dateT);
 490     }
 491 
 492     /**
 493      * @return long
 494      */
 495     public static long getStampByDay(int severalDays, String condition) {
 496         int dateT = 0;
 497         Calendar cal = Calendar.getInstance();
 498         if (condition == null) {
 499             return getStampToDay(cal, dateT);
 500         }
 501         if (&quot;-&quot;.equals(condition)) {
 502             dateT = cal.get(Calendar.DATE) - severalDays;
 503             return getStampToDay(cal, dateT);
 504         }
 505         if (&quot;+&quot;.equals(condition)) {
 506             dateT = cal.get(Calendar.DATE) + severalDays;
 507             return getStampToDay(cal, dateT);
 508         }
 509         return getStampToDay(cal, dateT);
 510     }
 511 
 512     /**
 513      * @return long
 514      */
 515     public static long getMillByDay(){
 516     		return getMillByDay(0,null);
 517     }
 518 
 519     /**
 520      * @param cal  Calendar
 521      * @param dateT Integer
 522      * @return  long
 523      */
 524     public static long getMillToDay(Calendar cal,int dateT){
 525      if(dateT!=0){
 526       cal.set(Calendar.DATE, dateT);
 527      }
 528         cal.set(Calendar.HOUR_OF_DAY, 0);
 529         cal.set(Calendar.MINUTE, 0);
 530         cal.set(Calendar.SECOND, 0);
 531         cal.set(Calendar.MILLISECOND, 0);
 532         return cal.getTimeInMillis()/1000;
 533     	}
 534 
 535     /**
 536      * @param cal  Calendar
 537      * @param dateT Integer
 538      * @return  long
 539      */
 540     public static long getStampToDay(Calendar cal,int dateT){
 541     	if(dateT!=0){
 542     		cal.set(Calendar.DATE, dateT);
 543     	}
 544     	return cal.getTimeInMillis();
 545     }
 546 
 547     public static String getToday() {
 548         Calendar cal = Calendar.getInstance();
 549         return cal.get(1) + &quot;Âπ¥&quot; + cal.get(2) + &quot;Êúà&quot; + cal.get(3) + &quot;Êó•&quot;;
 550     }
 551 
 552     /**
 553      * @param day
 554      * @return format time
 555      */
 556     public static String getDate(long day, String format) {
 557         Calendar cal = Calendar.getInstance();
 558         if ((&quot;&quot; + day).length() &gt; 10) {
 559             cal.setTime(new Date(day));
 560         } else {
 561             cal.setTime(new Date(day * 1000));
 562         }
 563         SimpleDateFormat sf = new SimpleDateFormat(format);
 564         return sf.format(cal.getTime());
 565     }
 566 
 567     /**
 568      *
 569      * @param  date
 570      * @return
 571      */
 572     public static String getDate(Date date, String format) {
 573         SimpleDateFormat sf = new SimpleDateFormat(format);
 574         return sf.format(date);
 575     }
 576 
 577     /**
 578      *
 579      * @param day
 580      * @param format
 581      * @return long
 582      * @throws ParseException
 583      */
 584     public static long stringToLong(String day, String format) throws ParseException {
 585         SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 586         long date = dateFormat.parse(day).getTime();
 587         return date;
 588     }
 589 
 590     /**
 591      * @param day
 592      * @param format
 593      * @return Date
 594      * @throws ParseException
 595      */
 596     public static Date stringToDate(String day, String format) {
 597         try {
 598             SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 599             Date date = dateFormat.parse(day);
 600             return date;
 601         } catch (ParseException e) {
 602             return new Date();
 603         }
 604     }
 605 
 606     /**
 607      * longÂûãÊó∂Èó¥Êà≥ËΩ¨‰∏∫StringÂûã
 608      *
 609      * @param day Áßí
 610      * @return Ê†ºÂºèÂåñÂêéÁöÑÊó•Êúü
 611      * @throws ParseException
 612      */
 613     public static String longToString(long day, String format) throws ParseException {
 614         if ((&quot;&quot; + day).length() &lt;= 10) {
 615             day = day * 1000;
 616         }
 617         SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 618         String date = dateFormat.format(day);
 619         return date;
 620     }
 621 
 622     /**
 623      *
 624      * @param day Áßí
 625      * @param minusDay ÈúÄË¶ÅÂáèÊéâÁöÑÂ§©Êï∞
 626      * @return Áßí
 627      */
 628     public static int getMinusDate(int day, int minusDay) {
 629         Calendar cal = Calendar.getInstance();
 630         cal.setTime(new Date(day * 1000));
 631         cal.set(Calendar.DATE, cal.get(Calendar.DATE) - minusDay);
 632         cal.set(Calendar.HOUR_OF_DAY, 0);
 633         cal.set(Calendar.MINUTE, 0);
 634         cal.set(Calendar.SECOND, 0);
 635         cal.set(Calendar.MILLISECOND, 0);
 636         return (int) cal.getTimeInMillis() / 1000;
 637     }
 638 
 639     /**
 640      *
 641      * @return long
 642      */
 643     public static long getMillByNow() {
 644         Calendar cal = Calendar.getInstance();
 645         cal.setTime(new Date());
 646         return cal.getTimeInMillis();
 647     }
 648 
 649 public static int getWeeksBetweenTwoDates(long startDay, long endDay) {
 650 	int week = getWeekOfYear(endDay) - getWeekOfYear(startDay) + 1;
 651 	if(week&lt;1){
 652 		week = getWeekOfYear(endDay) + getMaxWeekOfYear(startDay) - getWeekOfYear(startDay) + 1;
 653 	}
 654 	return week;
 655 }
 656 
 657 public static int getMaxWeekOfYear(long startDay) {
 658 	Calendar cal = Calendar.getInstance();
 659        cal.setTime(new Date(startDay * 1000));
 660        return cal.getMaximum(Calendar.WEEK_OF_YEAR);
 661 }
 662 
 663 public static int getMonthsBetweenTwoDates(long startDay, long endDay) {
 664 	int month = DateUtil.getMonth(endDay) - DateUtil.getMonth(startDay) + 1;
 665 	if(month&lt;1){
 666 		month = getMonth(endDay) + 12 - getMonth(startDay) +1;
 667 	}
 668 	return month;
 669 }
 670 
 671 public static Date parseDate(String dateStr, String pattern){
 672 	SimpleDateFormat sdf = new SimpleDateFormat();
 673 	sdf.applyPattern(pattern);
 674 	try {
 675 		return sdf.parse(dateStr);
 676 	} catch (ParseException e) {
 677 		return null;
 678 	}
 679 }
 680 
 681 /**
 682     *
 683     * @param time Long Êó∂Èó¥
 684     * @return long
 685     */
 686    public static long getMinuteStart(long time) {
 687        long firstDay = 0L;
 688        Calendar cal = Calendar.getInstance();
 689        if ((&quot;&quot; + time).length() &gt; 10) {
 690            cal.setTime(new Date(time));
 691        } else {
 692            cal.setTime(new Date(time * 1000));
 693        }
 694        cal.set(Calendar.SECOND, 0);
 695        cal.set(Calendar.MILLISECOND, 0);
 696        firstDay = cal.getTimeInMillis() / 1000;
 697        return firstDay;
 698    }
 699 
 700     /**
 701      * @param time Long
 702      * @return long
 703      */
 704     public static long getHourStart(long time) {
 705         long firstDay = 0L;
 706         Calendar cal = Calendar.getInstance();
 707         if ((&quot;&quot; + time).length() &gt; 10) {
 708             cal.setTime(new Date(time));
 709         } else {
 710             cal.setTime(new Date(time * 1000));
 711         }
 712         cal.set(Calendar.SECOND, 0);
 713         cal.set(Calendar.MILLISECOND, 0);
 714         cal.set(Calendar.MINUTE, 0);
 715         firstDay = cal.getTimeInMillis() / 1000;
 716         return firstDay;
 717     }
 718 
 719     /**
 720      * @param time
 721      * @return Date
 722      */
 723     public static Date getDateByLong(long time){
 724         Date date = new Date();
 725         date.setTime(time);
 726         return date;
 727     }
 728 
 729     public static Date parseDate(String dateStr, String pattern, Locale locale){
 730     	SimpleDateFormat df = new SimpleDateFormat(
 731     pattern, locale);
 732 
 733     		df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 734     		try {
 735     			return df.parse(dateStr);
 736     		} catch (ParseException e) {
 737     			return null;
 738     		}
 739     	}
 740 
 741     public static String getDate(Date date, String format, Locale locale) {
 742     	SimpleDateFormat df = new SimpleDateFormat(
 743     			format, locale);
 744     	df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 745         return df.format(date);
 746     }
 747 
 748     public static java.sql.Timestamp columnToTimestamp(Object column) {
 749         if (column == null) {
 750             return null;
 751         } else if(column instanceof String) {
 752             return new java.sql.Timestamp(stringToDate((String)column).getTime());
 753         } else if (column instanceof Integer) {
 754             Integer rawData = (Integer) column;
 755             return new java.sql.Timestamp(rawData.longValue());
 756         } else if (column instanceof Long) {
 757             Long rawData = (Long) column;
 758             return new java.sql.Timestamp(rawData.longValue());
 759         } else if (column instanceof java.sql.Date) {
 760             return (java.sql.Timestamp) column;
 761         } else if(column instanceof Timestamp) {
 762             return (Timestamp) column;
 763         } else if(column instanceof Date) {
 764             Date d = (Date)column;
 765             return new java.sql.Timestamp(d.getTime());
 766         }
 767 
 768         throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
 769     }
 770 
 771     public static String dateToString(Date date) {
 772         LocalDateTime localDateTime = dateToLocalDateTime(date);
 773         return localDateTime.format(DATE_FORMATTER);
 774     }
 775 
 776     public static String timestampToString(Date date) {
 777         LocalDateTime localDateTime = dateToLocalDateTime(date);
 778         return localDateTime.format(DATE_TIME_FORMATTER);
 779     }
 780 
 781     public static Timestamp getTimestampFromStr(String timeStr) {
 782         if (DATETIME.matcher(timeStr).matches()) {
 783             Instant instant = Instant.from(ISO_INSTANT.parse(timeStr));
 784             return new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);
 785         } else {
 786             java.sql.Date date = null;
 787             try {
 788                 date = new java.sql.Date(datetimeFormatter.parse(timeStr).getTime());
 789             } catch (ParseException e) {
 790                 throw new RuntimeException(&quot;getTimestampFromStr error data is &quot; + timeStr);
 791             }
 792             return new Timestamp(date.getTime());
 793         }
 794     }
 795 
 796     public static java.sql.Date getDateFromStr(String dateStr) {
 797         // 2020-01-01 format
 798         if (DATE.matcher(dateStr).matches()) {
 799             // convert from local date to instant
<abbr title=" 800             Instant instant = LocalDate.parse(dateStr).atTime(LocalTime.of(0, 0, 0, 0)).toInstant(ZoneOffset.UTC);"> 800             Instant instant = LocalDate.parse(dateStr).atTime(LocalTime.of(0, 0, 0, 0)).toInstant(ZoneOffüîµ</abbr>
 801             // calculate the timezone offset in millis
 802             int offset = TimeZone.getDefault().getOffset(instant.toEpochMilli());
 803             // need to remove the offset since time has no TZ component
 804             return new java.sql.Date(instant.toEpochMilli() - offset);
 805         } else if (DATETIME.matcher(dateStr).matches()) {
 806             // 2020-01-01T12:12:12Z format
 807             Instant instant = Instant.from(ISO_INSTANT.parse(dateStr));
 808             return new java.sql.Date(instant.toEpochMilli());
 809         } else {
 810             try {
 811                 // 2020-01-01 12:12:12.0 format
 812                 return new java.sql.Date(datetimeFormatter.parse(dateStr).getTime());
 813             } catch (ParseException e) {
 814                 throw new RuntimeException(&quot;String convert to Date fail.&quot;);
 815             }
 816         }
 817     }
 818 
 819     public static String getStringFromTimestamp(Timestamp timestamp) {
 820         return datetimeFormatter.format(timestamp);
 821     }
 822 
 823     public static String getStringFromDate(java.sql.Date date) {
 824         return dateFormatter.format(date);
 825     }
 826 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.util;
  22  
  23  import java.sql.Timestamp;
  24  import java.text.ParseException;
  25  import java.text.SimpleDateFormat;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import java.time.LocalDate;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import java.time.LocalDateTime;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import java.time.LocalTime;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import java.time.ZoneId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import java.time.format.DateTimeFormatter;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import java.time.format.DateTimeParseException;</span>
  32  import java.util.Calendar;
  33  import java.util.Date;
  34  import java.util.Locale;
  35  import java.util.SimpleTimeZone;




  36  
  37  
  38  /**
  39   *
  40   * Reason: TODO ADD REASON(ÂèØÈÄâ)
  41   * Date: 2017Âπ¥03Êúà10Êó• ‰∏ãÂçà1:16:37
  42   * Company: www.dtstack.com
  43   * @author sishu.yss
  44   *
  45   */
  46  public class DateUtil {
  47  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -    static final String timeZone = &quot;GMT+8&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -    static final String datetimeFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -    static final String dateFormat = &quot;yyyy-MM-dd&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -    static final String timeFormat = &quot;HH:mm:ss&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -    static final SimpleDateFormat datetimeFormatter = new SimpleDateFormat(datetimeFormat);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -    static final SimpleDateFormat dateFormatter = new SimpleDateFormat(dateFormat);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -    static final SimpleDateFormat timeFormatter = new SimpleDateFormat(timeFormat);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +    static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +    static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +    static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;);</span>



  58  
  59      public static java.sql.Date columnToDate(Object column) {
  60          if(column instanceof String) {
  61              return new java.sql.Date(stringToDate((String)column).getTime());
  62          } else if (column instanceof Integer) {
  63              Integer rawData = (Integer) column;
  64              return new java.sql.Date(rawData.longValue());
  65          } else if (column instanceof Long) {
  66              Long rawData = (Long) column;
  67              return new java.sql.Date(rawData.longValue());
  68          } else if (column instanceof java.sql.Date) {
  69              return (java.sql.Date) column;
  70          } else if(column instanceof Timestamp) {
  71              Timestamp ts = (Timestamp) column;
  72              return new java.sql.Date(ts.getTime());
  73          }
  74          throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
  75      }
  76  
  77      public static Date stringToDate(String strDate)  {
  78          if(strDate == null){
  79              return null;
  80          }
  81          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -            return datetimeFormatter.parse(strDate);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -        } catch (ParseException ignored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +            ;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +            return localDateTimetoDate(LocalDateTime.parse(strDate, DATE_TIME_FORMATTER));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +        } catch (DateTimeParseException ignored) {</span>
  87          }
  88  
  89          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -            return dateFormatter.parse(strDate);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -        } catch (ParseException ignored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +            return localDateTimetoDate(LocalDate.parse(strDate, DATE_FORMATTER).atStartOfDay());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +        } catch (DateTimeParseException ignored) {</span>
  94          }
  95  
  96          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -            return timeFormatter.parse(strDate);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -        } catch (ParseException ignored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  99 +            return localDateTimetoDate(LocalDateTime.of(LocalDate.now(), LocalTime.parse(strDate, TIME_FORMATTER)));">  99 +            return localDateTimetoDate(LocalDateTime.of(LocalDate.now(), LocalTime.parse(strDate, TIME_FORMATTER))üîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +        } catch (DateTimeParseException ignored) {</span>
 101          }
 102  
 103          throw new RuntimeException(&quot;can&#x27;t parse date&quot;);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +    public static Date localDateTimetoDate(LocalDateTime localDateTime){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 107 +        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 108 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +    public static LocalDateTime dateToLocalDateTime(Date date){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span>
 112      }
 113  
 114      /**
 115       *
 116       *
 117       * @param day Long Êó∂Èó¥
 118       * @return long
 119       */
 120      public static long getTodayStart(long day) {
 121          long firstDay = 0L;
 122          Calendar cal = Calendar.getInstance();
 123          if ((&quot;&quot; + day).length() &gt; 10) {
 124              cal.setTime(new Date(day));
 125          } else {
 126              cal.setTime(new Date(day * 1000));
 127          }
 128          cal.set(Calendar.HOUR_OF_DAY, 0);
 129          cal.set(Calendar.MINUTE, 0);
 130          cal.set(Calendar.SECOND, 0);
 131          cal.set(Calendar.MILLISECOND, 0);
 132          firstDay = cal.getTimeInMillis() / 1000;
 133          return firstDay;
 134      }
 135  
 136      /**
 137       *
 138       * @param day Long Êó∂Èó¥
 139       * @param scope
 140       * @return
 141       */
 142      public static long getTodayStart(long day,String scope) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -    	if(scope.equals(&quot;MS&quot;)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +    	if(&quot;MS&quot;.equals(scope)){</span>
 145      		return getTodayStart(day)*1000;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -    	}else if(scope.equals(&quot;S&quot;)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +    	}else if(&quot;S&quot;.equals(scope)){</span>
 148      		return getTodayStart(day);
 149      	}else{
 150      		return getTodayStart(day);
 151      	}
 152      }
 153  
 154      /**
 155       *
 156       * @param day Long Êó∂Èó¥
 157       * @return long
 158       */
 159      public static long getNextDayStart(long day) {
 160          long daySpanMill = 86400000L;
 161          long nextDay = 0L;
 162          Calendar cal = Calendar.getInstance();
 163          if ((&quot;&quot; + day).length() &gt; 10) {
 164              cal.setTime(new Date(day));
 165          } else {
 166              cal.setTime(new Date(day * 1000));
 167          }
 168          cal.set(Calendar.HOUR_OF_DAY, 0);
 169          cal.set(Calendar.MINUTE, 0);
 170          cal.set(Calendar.SECOND, 0);
 171          cal.set(Calendar.MILLISECOND, 0);
 172          nextDay = (cal.getTimeInMillis() + daySpanMill) / 1000;
 173          return nextDay;
 174      }
 175  
 176      /**
 177       *
 178       * @param day Long Êó∂Èó¥
 179       * @param scope String Á∫ßÂà´&lt;br&gt;&quot;MS&quot;ÔºöÊØ´ÁßíÁ∫ß&lt;br&gt;&quot;S&quot;:ÁßíÁ∫ß
 180       * @return
 181       */
 182      public static long getNextDayStart(long day,String scope) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -    	if(scope.equals(&quot;MS&quot;)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +    	if(&quot;MS&quot;.equals(scope)){</span>
 185      		return getNextDayStart(day)*1000;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -    	}else if(scope.equals(&quot;S&quot;)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +    	}else if(&quot;S&quot;.equals(scope)){</span>
 188      		return getNextDayStart(day);
 189      	}else{
 190      		return getNextDayStart(day);
 191      	}
 192      }
 193  
 194  
 195      /**
 196       *
 197       * @param day
 198       * @return
 199       */
 200      public static long getMonthFirst(long day) {
 201          long firstDay = 0L;
 202          Calendar cal = Calendar.getInstance();
 203          cal.setTime(new Date(day * 1000));
 204          cal.set(Calendar.DAY_OF_MONTH, 1);
 205          cal.set(Calendar.HOUR_OF_DAY, 0);
 206          cal.set(Calendar.MINUTE, 0);
 207          cal.set(Calendar.SECOND, 0);
 208          cal.set(Calendar.MILLISECOND, 0);
 209          firstDay = cal.getTimeInMillis() / 1000;
 210          return firstDay;
 211      }
 212  
 213      /**
 214       * @param day
 215       * @return
 216       */
 217      public static int getMonth(long day) {
 218          Calendar cal = Calendar.getInstance();
 219          cal.setTime(new Date(day * 1000));
 220          return cal.get(Calendar.MONTH) + 1;
 221      }
 222  
 223      /**
 224       *
 225       * @author yumo.lck
 226       */
 227      public static int getYear(long day) {
 228          Calendar cal = Calendar.getInstance();
 229          cal.setTime(new Date(day * 1000));
 230          return cal.get(Calendar.YEAR);
 231      }
 232  
 233      /**
 234       *
 235       * @param day
 236       * @return
 237       */
 238      public static long getWeekFirst(long day) {
 239          long firstDay = 0L;
 240          Calendar cal = Calendar.getInstance();
 241          cal.setTime(new Date(day * 1000));
 242          cal.setFirstDayOfWeek(Calendar.MONDAY);
 243          cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
 244          cal.set(Calendar.HOUR_OF_DAY, 0);
 245          cal.set(Calendar.MINUTE, 0);
 246          cal.set(Calendar.SECOND, 0);
 247          cal.set(Calendar.MILLISECOND, 0);
 248          firstDay = cal.getTimeInMillis() / 1000;
 249          return firstDay;
 250      }
 251  
 252      /**
 253       * Ê†πÊçÆÊüê‰∏™Êó•ÊúüÊó∂Èó¥Êà≥ÁßíÂÄºÔºåËé∑ÂèñÊâÄÂú®Âë®Âú®‰∏ÄÂπ¥‰∏≠ÊòØÁ¨¨Âá†Âë®.
 254       *
 255       * @param day
 256       * @return
 257       */
 258      public static int getWeekOfYear(long day) {
 259          Calendar cal = Calendar.getInstance();
 260          cal.setTime(new Date(day * 1000));
 261          return cal.get(Calendar.WEEK_OF_YEAR);
 262      }
 263  
 264      /**
 265       *
 266       * @param day
 267       * @param inFormat
 268       * @param outFormat
 269       * @return String
 270       * @throws ParseException
 271       */
 272      public static String getYesterdayByString(String day, String inFormat, String outFormat){
 273          try {
 274  			SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 275  			Date date = sdf.parse(day);
 276  			Calendar calendar = Calendar.getInstance();
 277  			calendar.setTime(date);
 278  			int calendarDay = calendar.get(Calendar.DATE);
 279  			calendar.set(Calendar.DATE, calendarDay - 1);
 280  			String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 281  			return dayBefore;
 282  		} catch (ParseException e) {
 283  			return null;
 284  		}
 285      }
 286  
 287      /**
 288       *
 289       * @param day
 290       * @param inFormat
 291       * @param outFormat
 292       * @return String
 293       * @throws ParseException
 294       */
<abbr title=" 295      public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseException {"> 295      public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseException üîµ</abbr>
 296          SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 297          Date date = sdf.parse(day);
 298          Calendar calendar = Calendar.getInstance();
 299          calendar.setTime(date);
 300          int calendarDay = calendar.get(Calendar.DATE);
 301          calendar.set(Calendar.DATE, calendarDay + 1);
 302          String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 303          return dayBefore;
 304      }
 305  
 306      /**
 307       *
 308       * @param date
 309       * @return Date
 310       * @throws ParseException
 311       */
 312      public static Date getTomorrowByDate(Date date) throws ParseException {
 313          Calendar calendar = Calendar.getInstance();
 314          calendar.setTime(date);
 315          int calendarDay = calendar.get(Calendar.DATE);
 316          calendar.set(Calendar.DATE, calendarDay + 1);
 317          return calendar.getTime();
 318      }
 319  
 320      /**
 321       *
 322       * @param day
 323       * @param inFormat
 324       * @param outFormat
 325       * @return String
 326       * @throws ParseException
 327       */
<abbr title=" 328      public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws ParseException {"> 328      public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws ParseExceptüîµ</abbr>
 329          SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 330          Date date = sdf.parse(day);
 331          Calendar calendar = Calendar.getInstance();
 332          calendar.setTime(date);
 333          int calendarDay = calendar.get(Calendar.DATE);
 334          calendar.set(Calendar.DATE, calendarDay - 30);
 335          return new SimpleDateFormat(outFormat).format(calendar.getTime());
 336      }
 337  
 338      /**
 339       *
 340       * @param day
 341       * @param inFormat
 342       * @param outFormat
 343       * @return String
 344       * @throws ParseException
 345       */
<abbr title=" 346      public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws ParseException {"> 346      public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws ParseExceptiüîµ</abbr>
 347      	SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 348      	Date date = sdf.parse(day);
 349      	Calendar calendar = Calendar.getInstance();
 350      	calendar.setTime(date);
 351      	int calendarDay = calendar.get(Calendar.DATE);
 352      	calendar.set(Calendar.DATE, calendarDay + 30);
 353      	String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 354      	return dayBefore;
 355      }
 356  
 357  
 358      /**
 359       *
 360       * @param day
 361       * @param inFormat
 362       * @param outFormat
 363       * @return String
 364       * @throws ParseException
 365       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 366 -    public static String getDateStrTOFormat(String day, String inFormat, String outFormat) throws ParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 367 +    public static String getDateStrToFormat(String day, String inFormat, String outFormat) throws ParseException {</span>
 368          SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 369          Date date = sdf.parse(day);
 370          Calendar calendar = Calendar.getInstance();
 371          calendar.setTime(date);
 372          String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 373          return dayBefore;
 374      }
 375  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 376 -    public static long getDateMillTOFormat(String day, String inFormat) throws ParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +    public static long getDateMillToFormat(String day, String inFormat) throws ParseException {</span>
 378          SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 379          Date date = sdf.parse(day);
 380          Calendar calendar = Calendar.getInstance();
 381          calendar.setTime(date);
 382          return calendar.getTimeInMillis()/1000;
 383      }
 384  
 385      /**
 386       *
 387       * @author sishu.yss
 388       * @param year
 389       * @param month
 390       * @return
 391       */
 392      public static long getFirstDay4Month(int year, int month) {
 393          long firstDay = 0L;
 394          Calendar cal = Calendar.getInstance();
 395          cal.set(Calendar.YEAR, year);
 396          cal.set(Calendar.MONTH, month - 1);
 397          cal.set(Calendar.DAY_OF_MONTH, 1);
 398          cal.set(Calendar.HOUR_OF_DAY, 0);
 399          cal.set(Calendar.MINUTE, 0);
 400          cal.set(Calendar.SECOND, 0);
 401          cal.set(Calendar.MILLISECOND, 0);
 402          firstDay = cal.getTimeInMillis() / 1000;
 403          return firstDay;
 404      }
 405  
 406      /**
 407       *
 408       * @author yumo.lck
 409       * @param year
 410       * @param month
 411       * @return
 412       */
 413      public static long getLastDay4Month(int year, int month) {
 414          long lastDay = 0L;
 415          Calendar cal = Calendar.getInstance();
 416          cal.set(Calendar.YEAR, year);
 417          cal.set(Calendar.MONTH, month);
<abbr title=" 418          //1 represents a zero next month, can be seen as the end of the first day of the month most one day, but the data table on the last day of the zero point on the line"> 418          //1 represents a zero next month, can be seen as the end of the first day of the month most one day, but tüîµ</abbr>
 419          cal.set(Calendar.DAY_OF_MONTH, 0);
 420          cal.set(Calendar.HOUR_OF_DAY, 0);
 421          cal.set(Calendar.MINUTE, 0);
 422          cal.set(Calendar.SECOND, 0);
 423          cal.set(Calendar.MILLISECOND, 0);
 424          lastDay = cal.getTimeInMillis() / 1000;
 425          return lastDay;
 426      }
 427  
 428      /**
 429       *
 430       * @author yumo.lck
 431       * @param chooseFirstDay
 432       */
 433  
 434      public static long getBeforeMonthDay(long day, boolean chooseFirstDay) {
 435          long chooseDay = 0L;
 436          int currentMonth = getMonth(day);
 437          int currentYear = getYear(day);
 438          if (currentMonth &gt; 1) {
 439              currentMonth--;
 440          } else {
 441              currentYear--;
 442              currentMonth = 12;
 443          }
 444          if (chooseFirstDay) {
 445              chooseDay = getFirstDay4Month(currentYear, currentMonth);
 446              return chooseDay;
 447          } else {
 448              chooseDay = getLastDay4Month(currentYear, currentMonth);
 449              return chooseDay;
 450          }
 451  
 452      }
 453  
 454      /**
 455       * @return long
 456       */
 457      public static long getMillByOneDay() {
 458          Calendar cal = Calendar.getInstance();
 459          cal.set(Calendar.HOUR_OF_DAY, 0);
 460          cal.set(Calendar.MINUTE, 0);
 461          cal.set(Calendar.SECOND, 0);
 462          cal.set(Calendar.MILLISECOND, 0);
 463          return cal.getTimeInMillis() / 1000;
 464      }
 465  
 466      /**
 467       *
 468       * @return long
 469       */
 470      public static long getMillByYesDay() {
 471          Calendar cal = Calendar.getInstance();
 472          cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 1);
 473          cal.set(Calendar.HOUR_OF_DAY, 0);
 474          cal.set(Calendar.MINUTE, 0);
 475          cal.set(Calendar.SECOND, 0);
 476          cal.set(Calendar.MILLISECOND, 0);
 477          return cal.getTimeInMillis() / 1000;
 478      }
 479  
 480      /**
 481       *
 482       * @return
 483       */
 484      public static long getMillByLastWeekDay() {
 485          Calendar cal = Calendar.getInstance();
 486          cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 7);
 487          cal.set(Calendar.HOUR_OF_DAY, 0);
 488          cal.set(Calendar.MINUTE, 0);
 489          cal.set(Calendar.SECOND, 0);
 490          cal.set(Calendar.MILLISECOND, 0);
 491          return cal.getTimeInMillis() / 1000;
 492      }
 493  
 494     /**
 495      * @return long
 496      */
 497      public static long getMillByDay(int severalDays,String condition) {
 498      	int dateT=0;
 499          Calendar cal = Calendar.getInstance();
 500      	if(condition==null){
 501      		return getMillToDay(cal,dateT);
 502      	}
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 503 -        if(condition.equals(&quot;-&quot;)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 504 +        if(&quot;-&quot;.equals(condition)){</span>
 505          	dateT = (cal.get(Calendar.DATE) - severalDays);
 506          	return getMillToDay(cal,dateT);
 507          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 508 -        if(condition.equals(&quot;+&quot;)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 509 +        if(&quot;+&quot;.equals(condition)){</span>
 510          	dateT = (cal.get(Calendar.DATE) + severalDays);
 511          	return getMillToDay(cal,dateT);
 512          }
 513  		return getMillToDay(cal,dateT);
 514    }
 515  
 516      /**
 517       * @return long
 518       */
 519      public static long getStampByDay(int severalDays,String condition) {
 520      	int dateT=0;
 521      	Calendar cal = Calendar.getInstance();
 522      	if(condition==null){
 523      		return getStampToDay(cal,dateT);
 524      	}
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 525 -    	if(condition.equals(&quot;-&quot;)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 526 +    	if(&quot;-&quot;.equals(condition)){</span>
 527      		dateT = (cal.get(Calendar.DATE) - severalDays);
 528      		return getStampToDay(cal,dateT);
 529      	}
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 530 -    	if(condition.equals(&quot;+&quot;)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 531 +    	if(&quot;+&quot;.equals(condition)){</span>
 532      		dateT = (cal.get(Calendar.DATE) + severalDays);
 533      		return getStampToDay(cal,dateT);
 534      	}
 535      	return getStampToDay(cal,dateT);
 536      }
 537      /**
 538       * @return long
 539       */
 540      public static long getMillByDay(){
 541  		return getMillByDay(0,null);
 542      }
 543  
 544      /**
 545       * @param cal  Calendar
 546       * @param dateT Integer
 547       * @return  long
 548       */
 549      public static long getMillToDay(Calendar cal,int dateT){
 550  		   if(dateT!=0){
 551  			   cal.set(Calendar.DATE, dateT);
 552  		   }
 553  	       cal.set(Calendar.HOUR_OF_DAY, 0);
 554  	       cal.set(Calendar.MINUTE, 0);
 555  	       cal.set(Calendar.SECOND, 0);
 556  	       cal.set(Calendar.MILLISECOND, 0);
 557  	       return cal.getTimeInMillis()/1000;
 558  	}
 559  
 560      /**
 561       * @param cal  Calendar
 562       * @param dateT Integer
 563       * @return  long
 564       */
 565      public static long getStampToDay(Calendar cal,int dateT){
 566      	if(dateT!=0){
 567      		cal.set(Calendar.DATE, dateT);
 568      	}
 569      	return cal.getTimeInMillis();
 570      }
 571  
 572      public static String getToday() {
 573          Calendar cal = Calendar.getInstance();
 574          return cal.get(1) + &quot;Âπ¥&quot; + cal.get(2) + &quot;Êúà&quot; + cal.get(3) + &quot;Êó•&quot;;
 575      }
 576  
 577      /**
 578       * @param day
 579       * @return format time
 580       */
 581      public static String getDate(long day, String format) {
 582          Calendar cal = Calendar.getInstance();
 583          if ((&quot;&quot; + day).length() &gt; 10) {
 584              cal.setTime(new Date(day));
 585          } else {
 586              cal.setTime(new Date(day * 1000));
 587          }
 588          SimpleDateFormat sf = new SimpleDateFormat(format);
 589          return sf.format(cal.getTime());
 590      }
 591  
 592      /**
 593       *
 594       * @param  date
 595       * @return
 596       */
 597      public static String getDate(Date date, String format) {
 598          SimpleDateFormat sf = new SimpleDateFormat(format);
 599          return sf.format(date);
 600      }
 601  
 602  
 603      /**
 604       *
 605       * @param day
 606       * @param format
 607       * @return long
 608       * @throws ParseException
 609       */
 610      public static long stringToLong(String day, String format) throws ParseException {
 611      	SimpleDateFormat dateFormat = new SimpleDateFormat(format);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 612 -        long Date = dateFormat.parse(day).getTime();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 613 -    	return Date;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 614 +        long date = dateFormat.parse(day).getTime();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 615 +    	return date;</span>
 616      }
 617  
 618      /**
 619       * @param day
 620       * @param format
 621       * @return Date
 622       * @throws ParseException
 623       */
 624      public static Date stringToDate(String day, String format)  {
 625      	try {
 626  			SimpleDateFormat dateFormat = new SimpleDateFormat(format);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -			 Date Date = dateFormat.parse(day);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -			return Date;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 629 +			 Date date = dateFormat.parse(day);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 630 +			return date;</span>
 631  		} catch (ParseException e) {
 632  			return new Date();
 633  		}
 634      }
 635  
 636  
 637      /**
 638       * longÂûãÊó∂Èó¥Êà≥ËΩ¨‰∏∫StringÂûã
 639       *
 640       * @param day Áßí
 641       * @return Ê†ºÂºèÂåñÂêéÁöÑÊó•Êúü
 642       * @throws ParseException
 643       */
 644      public static String longToString(long day, String format) throws ParseException {
 645      	if ((&quot;&quot; + day).length() &lt;= 10){
 646              day=day*1000;
 647          }
 648      	SimpleDateFormat dateFormat = new SimpleDateFormat(format);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -	    String Date = dateFormat.format(day);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -    	return Date;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +	    String date = dateFormat.format(day);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +    	return date;</span>
 653      }
 654  
 655      /**
 656       *
 657       * @param day Áßí
 658       * @param minusDay ÈúÄË¶ÅÂáèÊéâÁöÑÂ§©Êï∞
 659       * @return Áßí
 660       */
 661      public static int getMinusDate(int day, int minusDay) {
 662          Calendar cal = Calendar.getInstance();
 663          cal.setTime(new Date(day * 1000));
 664          cal.set(Calendar.DATE, cal.get(Calendar.DATE) - minusDay);
 665          cal.set(Calendar.HOUR_OF_DAY, 0);
 666          cal.set(Calendar.MINUTE, 0);
 667          cal.set(Calendar.SECOND, 0);
 668          cal.set(Calendar.MILLISECOND, 0);
 669          return (int) cal.getTimeInMillis() / 1000;
 670      }
 671  
 672      /**
 673       *
 674       * @return long
 675       */
 676      public static long getMillByNow() {
 677          Calendar cal = Calendar.getInstance();
 678          cal.setTime(new Date());
 679          return cal.getTimeInMillis();
 680      }
 681  
 682  	public static int getWeeksBetweenTwoDates(long startDay, long endDay) {
 683  		int week = getWeekOfYear(endDay) - getWeekOfYear(startDay) + 1;
 684  		if(week&lt;1){
 685  			week = getWeekOfYear(endDay) + getMaxWeekOfYear(startDay) - getWeekOfYear(startDay) + 1;
 686  		}
 687  		return week;
 688  	}
 689  
 690  	public static int getMaxWeekOfYear(long startDay) {
 691  		Calendar cal = Calendar.getInstance();
 692          cal.setTime(new Date(startDay * 1000));
 693          return cal.getMaximum(Calendar.WEEK_OF_YEAR);
 694  	}
 695  
 696  	public static int getMonthsBetweenTwoDates(long startDay, long endDay) {
 697  		int month = DateUtil.getMonth(endDay) - DateUtil.getMonth(startDay) + 1;
 698  		if(month&lt;1){
 699  			month = getMonth(endDay) + 12 - getMonth(startDay) +1;
 700  		}
 701  		return month;
 702  	}
 703  
 704  	public static Date parseDate(String dateStr, String pattern){
 705  		SimpleDateFormat sdf = new SimpleDateFormat();
 706  		sdf.applyPattern(pattern);
 707  		try {
 708  			return sdf.parse(dateStr);
 709  		} catch (ParseException e) {
 710  			return null;
 711  		}
 712  	}
 713  
 714  	/**
 715       *
 716       * @param time Long Êó∂Èó¥
 717       * @return long
 718       */
 719      public static long getMinuteStart(long time) {
 720          long firstDay = 0L;
 721          Calendar cal = Calendar.getInstance();
 722          if ((&quot;&quot; + time).length() &gt; 10) {
 723              cal.setTime(new Date(time));
 724          } else {
 725              cal.setTime(new Date(time * 1000));
 726          }
 727          cal.set(Calendar.SECOND, 0);
 728          cal.set(Calendar.MILLISECOND, 0);
 729          firstDay = cal.getTimeInMillis() / 1000;
 730          return firstDay;
 731      }
 732  
 733      /**
 734       * @param time Long
 735       * @return long
 736       */
 737      public static long getHourStart(long time) {
 738          long firstDay = 0L;
 739          Calendar cal = Calendar.getInstance();
 740          if ((&quot;&quot; + time).length() &gt; 10) {
 741              cal.setTime(new Date(time));
 742          } else {
 743              cal.setTime(new Date(time * 1000));
 744          }
 745          cal.set(Calendar.SECOND, 0);
 746          cal.set(Calendar.MILLISECOND, 0);
 747          cal.set(Calendar.MINUTE, 0);
 748          firstDay = cal.getTimeInMillis() / 1000;
 749          return firstDay;
 750      }
 751  
 752      /**
 753       * @param time
 754       * @return Date
 755       */
 756      public static Date getDateByLong(long time){
 757          Date date = new Date();
 758          date.setTime(time);
 759          return date;
 760      }
 761  
 762  
 763      public static Date parseDate(String dateStr, String pattern, Locale locale){
 764      	SimpleDateFormat df = new SimpleDateFormat(
 765  				pattern, locale);
 766  
 767  		df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 768  		try {
 769  			return df.parse(dateStr);
 770  		} catch (ParseException e) {
 771  			return null;
 772  		}
 773  	}
 774  
 775      public static String getDate(Date date, String format, Locale locale) {
 776      	SimpleDateFormat df = new SimpleDateFormat(
 777      			format, locale);
 778      	df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 779          return df.format(date);
 780      }
 781  
 782      public static java.sql.Timestamp columnToTimestamp(Object column) {
 783          if (column == null) {
 784              return null;
 785          } else if(column instanceof String) {
 786              return new java.sql.Timestamp(stringToDate((String)column).getTime());
 787          } else if (column instanceof Integer) {
 788              Integer rawData = (Integer) column;
 789              return new java.sql.Timestamp(rawData.longValue());
 790          } else if (column instanceof Long) {
 791              Long rawData = (Long) column;
 792              return new java.sql.Timestamp(rawData.longValue());
 793          } else if (column instanceof java.sql.Date) {
 794              return (java.sql.Timestamp) column;
 795          } else if(column instanceof Timestamp) {
 796              return (Timestamp) column;
 797          } else if(column instanceof Date) {
 798              Date d = (Date)column;
 799              return new java.sql.Timestamp(d.getTime());
 800          }
 801  
 802          throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
 803      }
 804  
 805      public static String dateToString(Date date) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 806 -        return dateFormatter.format(date);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 807 +        LocalDateTime localDateTime = dateToLocalDateTime(date);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 808 +        return localDateTime.format(DATE_FORMATTER);</span>
 809      }
 810  
 811      public static String timestampToString(Date date) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 812 -        return datetimeFormatter.format(date);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 813 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 814 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 815 +        LocalDateTime localDateTime = dateToLocalDateTime(date);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 816 +        return localDateTime.format(DATE_TIME_FORMATTER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 817 +    }</span>













































 818  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.util;
  22  
  23  import java.sql.Timestamp;
  24  import java.text.ParseException;
  25  import java.text.SimpleDateFormat;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import java.time.Instant;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import java.time.LocalDate;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import java.time.LocalTime;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import java.time.ZoneOffset;</span>


  30  import java.util.Calendar;
  31  import java.util.Date;
  32  import java.util.Locale;
  33  import java.util.SimpleTimeZone;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import java.util.TimeZone;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import java.util.regex.Pattern;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import static java.time.format.DateTimeFormatter.ISO_INSTANT;</span>
  38  
  39  
  40  /**
  41   *
  42   * Reason: TODO ADD REASON(ÂèØÈÄâ)
  43   * Date: 2017Âπ¥03Êúà10Êó• ‰∏ãÂçà1:16:37
  44   * Company: www.dtstack.com
  45   * @author sishu.yss
  46   *
  47   */
  48  public class DateUtil {
  49  
  50      static final String timeZone = &quot;GMT+8&quot;;
  51      static final String datetimeFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;;
  52      static final String dateFormat = &quot;yyyy-MM-dd&quot;;
  53      static final String timeFormat = &quot;HH:mm:ss&quot;;
  54      static final SimpleDateFormat datetimeFormatter = new SimpleDateFormat(datetimeFormat);
  55      static final SimpleDateFormat dateFormatter = new SimpleDateFormat(dateFormat);
  56      static final SimpleDateFormat timeFormatter = new SimpleDateFormat(timeFormat);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  58 +    private static final Pattern DATETIME = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3,9})?Z$&quot;);">  58 +    private static final Pattern DATETIME = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}T\\d{2}:\\d{2}:\\d{üîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +    private static final Pattern DATE = Pattern.compile(&quot;^\\d{4}-(?:0[0-9]|1[0-2])-[0-9]{2}$&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +    private static final int MILLIS_PER_SECOND = 1000;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +</span>
  63  
  64      public static java.sql.Date columnToDate(Object column) {
  65          if(column instanceof String) {
  66              return new java.sql.Date(stringToDate((String)column).getTime());
  67          } else if (column instanceof Integer) {
  68              Integer rawData = (Integer) column;
  69              return new java.sql.Date(rawData.longValue());
  70          } else if (column instanceof Long) {
  71              Long rawData = (Long) column;
  72              return new java.sql.Date(rawData.longValue());
  73          } else if (column instanceof java.sql.Date) {
  74              return (java.sql.Date) column;
  75          } else if(column instanceof Timestamp) {
  76              Timestamp ts = (Timestamp) column;
  77              return new java.sql.Date(ts.getTime());
  78          }
  79          throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
  80      }
  81  
  82      public static Date stringToDate(String strDate)  {
  83          if(strDate == null){
  84              return null;
  85          }
  86          try {
  87              return datetimeFormatter.parse(strDate);
  88          } catch (ParseException ignored) {



  89          }
  90  
  91          try {
  92              return dateFormatter.parse(strDate);
  93          } catch (ParseException ignored) {


  94          }
  95  
  96          try {
  97              return timeFormatter.parse(strDate);
  98          } catch (ParseException ignored) {


  99          }
 100  
 101          throw new RuntimeException(&quot;can&#x27;t parse date&quot;);








 102      }
 103  
 104      /**
 105       *
 106       *
 107       * @param day Long Êó∂Èó¥
 108       * @return long
 109       */
 110      public static long getTodayStart(long day) {
 111          long firstDay = 0L;
 112          Calendar cal = Calendar.getInstance();
 113          if ((&quot;&quot; + day).length() &gt; 10) {
 114              cal.setTime(new Date(day));
 115          } else {
 116              cal.setTime(new Date(day * 1000));
 117          }
 118          cal.set(Calendar.HOUR_OF_DAY, 0);
 119          cal.set(Calendar.MINUTE, 0);
 120          cal.set(Calendar.SECOND, 0);
 121          cal.set(Calendar.MILLISECOND, 0);
 122          firstDay = cal.getTimeInMillis() / 1000;
 123          return firstDay;
 124      }
 125  
 126      /**
 127       *
 128       * @param day Long Êó∂Èó¥
 129       * @param scope
 130       * @return
 131       */
 132      public static long getTodayStart(long day,String scope) {
 133      	if(scope.equals(&quot;MS&quot;)){

 134      		return getTodayStart(day)*1000;
 135      	}else if(scope.equals(&quot;S&quot;)){

 136      		return getTodayStart(day);
 137      	}else{
 138      		return getTodayStart(day);
 139      	}
 140      }
 141  
 142      /**
 143       *
 144       * @param day Long Êó∂Èó¥
 145       * @return long
 146       */
 147      public static long getNextDayStart(long day) {
 148          long daySpanMill = 86400000L;
 149          long nextDay = 0L;
 150          Calendar cal = Calendar.getInstance();
 151          if ((&quot;&quot; + day).length() &gt; 10) {
 152              cal.setTime(new Date(day));
 153          } else {
 154              cal.setTime(new Date(day * 1000));
 155          }
 156          cal.set(Calendar.HOUR_OF_DAY, 0);
 157          cal.set(Calendar.MINUTE, 0);
 158          cal.set(Calendar.SECOND, 0);
 159          cal.set(Calendar.MILLISECOND, 0);
 160          nextDay = (cal.getTimeInMillis() + daySpanMill) / 1000;
 161          return nextDay;
 162      }
 163  
 164      /**
 165       *
 166       * @param day Long Êó∂Èó¥
 167       * @param scope String Á∫ßÂà´&lt;br&gt;&quot;MS&quot;ÔºöÊØ´ÁßíÁ∫ß&lt;br&gt;&quot;S&quot;:ÁßíÁ∫ß
 168       * @return
 169       */
 170      public static long getNextDayStart(long day,String scope) {
 171      	if(scope.equals(&quot;MS&quot;)){

 172      		return getNextDayStart(day)*1000;
 173      	}else if(scope.equals(&quot;S&quot;)){

 174      		return getNextDayStart(day);
 175      	}else{
 176      		return getNextDayStart(day);
 177      	}
 178      }
 179  
 180  
 181      /**
 182       *
 183       * @param day
 184       * @return
 185       */
 186      public static long getMonthFirst(long day) {
 187          long firstDay = 0L;
 188          Calendar cal = Calendar.getInstance();
 189          cal.setTime(new Date(day * 1000));
 190          cal.set(Calendar.DAY_OF_MONTH, 1);
 191          cal.set(Calendar.HOUR_OF_DAY, 0);
 192          cal.set(Calendar.MINUTE, 0);
 193          cal.set(Calendar.SECOND, 0);
 194          cal.set(Calendar.MILLISECOND, 0);
 195          firstDay = cal.getTimeInMillis() / 1000;
 196          return firstDay;
 197      }
 198  
 199      /**
 200       * @param day
 201       * @return
 202       */
 203      public static int getMonth(long day) {
 204          Calendar cal = Calendar.getInstance();
 205          cal.setTime(new Date(day * 1000));
 206          return cal.get(Calendar.MONTH) + 1;
 207      }
 208  
 209      /**
 210       *
 211       * @author yumo.lck
 212       */
 213      public static int getYear(long day) {
 214          Calendar cal = Calendar.getInstance();
 215          cal.setTime(new Date(day * 1000));
 216          return cal.get(Calendar.YEAR);
 217      }
 218  
 219      /**
 220       *
 221       * @param day
 222       * @return
 223       */
 224      public static long getWeekFirst(long day) {
 225          long firstDay = 0L;
 226          Calendar cal = Calendar.getInstance();
 227          cal.setTime(new Date(day * 1000));
 228          cal.setFirstDayOfWeek(Calendar.MONDAY);
 229          cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
 230          cal.set(Calendar.HOUR_OF_DAY, 0);
 231          cal.set(Calendar.MINUTE, 0);
 232          cal.set(Calendar.SECOND, 0);
 233          cal.set(Calendar.MILLISECOND, 0);
 234          firstDay = cal.getTimeInMillis() / 1000;
 235          return firstDay;
 236      }
 237  
 238      /**
 239       * Ê†πÊçÆÊüê‰∏™Êó•ÊúüÊó∂Èó¥Êà≥ÁßíÂÄºÔºåËé∑ÂèñÊâÄÂú®Âë®Âú®‰∏ÄÂπ¥‰∏≠ÊòØÁ¨¨Âá†Âë®.
 240       *
 241       * @param day
 242       * @return
 243       */
 244      public static int getWeekOfYear(long day) {
 245          Calendar cal = Calendar.getInstance();
 246          cal.setTime(new Date(day * 1000));
 247          return cal.get(Calendar.WEEK_OF_YEAR);
 248      }
 249  
 250      /**
 251       *
 252       * @param day
 253       * @param inFormat
 254       * @param outFormat
 255       * @return String
 256       * @throws ParseException
 257       */
 258      public static String getYesterdayByString(String day, String inFormat, String outFormat){
 259          try {
 260  			SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 261  			Date date = sdf.parse(day);
 262  			Calendar calendar = Calendar.getInstance();
 263  			calendar.setTime(date);
 264  			int calendarDay = calendar.get(Calendar.DATE);
 265  			calendar.set(Calendar.DATE, calendarDay - 1);
 266  			String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 267  			return dayBefore;
 268  		} catch (ParseException e) {
 269  			return null;
 270  		}
 271      }
 272  
 273      /**
 274       *
 275       * @param day
 276       * @param inFormat
 277       * @param outFormat
 278       * @return String
 279       * @throws ParseException
 280       */
<abbr title=" 281      public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseException {"> 281      public static String getTomorrowByString(String day, String inFormat, String outFormat) throws ParseException üîµ</abbr>
 282          SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 283          Date date = sdf.parse(day);
 284          Calendar calendar = Calendar.getInstance();
 285          calendar.setTime(date);
 286          int calendarDay = calendar.get(Calendar.DATE);
 287          calendar.set(Calendar.DATE, calendarDay + 1);
 288          String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 289          return dayBefore;
 290      }
 291  
 292      /**
 293       *
 294       * @param date
 295       * @return Date
 296       * @throws ParseException
 297       */
 298      public static Date getTomorrowByDate(Date date) throws ParseException {
 299          Calendar calendar = Calendar.getInstance();
 300          calendar.setTime(date);
 301          int calendarDay = calendar.get(Calendar.DATE);
 302          calendar.set(Calendar.DATE, calendarDay + 1);
 303          return calendar.getTime();
 304      }
 305  
 306      /**
 307       *
 308       * @param day
 309       * @param inFormat
 310       * @param outFormat
 311       * @return String
 312       * @throws ParseException
 313       */
<abbr title=" 314      public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws ParseException {"> 314      public static String get30DaysBeforeByString(String day, String inFormat, String outFormat) throws ParseExceptüîµ</abbr>
 315          SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 316          Date date = sdf.parse(day);
 317          Calendar calendar = Calendar.getInstance();
 318          calendar.setTime(date);
 319          int calendarDay = calendar.get(Calendar.DATE);
 320          calendar.set(Calendar.DATE, calendarDay - 30);
 321          return new SimpleDateFormat(outFormat).format(calendar.getTime());
 322      }
 323  
 324      /**
 325       *
 326       * @param day
 327       * @param inFormat
 328       * @param outFormat
 329       * @return String
 330       * @throws ParseException
 331       */
<abbr title=" 332      public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws ParseException {"> 332      public static String get30DaysLaterByString(String day, String inFormat, String outFormat) throws ParseExceptiüîµ</abbr>
 333      	SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 334      	Date date = sdf.parse(day);
 335      	Calendar calendar = Calendar.getInstance();
 336      	calendar.setTime(date);
 337      	int calendarDay = calendar.get(Calendar.DATE);
 338      	calendar.set(Calendar.DATE, calendarDay + 30);
 339      	String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 340      	return dayBefore;
 341      }
 342  
 343  
 344      /**
 345       *
 346       * @param day
 347       * @param inFormat
 348       * @param outFormat
 349       * @return String
 350       * @throws ParseException
 351       */
 352      public static String getDateStrTOFormat(String day, String inFormat, String outFormat) throws ParseException {

 353          SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 354          Date date = sdf.parse(day);
 355          Calendar calendar = Calendar.getInstance();
 356          calendar.setTime(date);
 357          String dayBefore = new SimpleDateFormat(outFormat).format(calendar.getTime());
 358          return dayBefore;
 359      }
 360  
 361      public static long getDateMillTOFormat(String day, String inFormat) throws ParseException {

 362          SimpleDateFormat sdf = new SimpleDateFormat(inFormat);
 363          Date date = sdf.parse(day);
 364          Calendar calendar = Calendar.getInstance();
 365          calendar.setTime(date);
 366          return calendar.getTimeInMillis()/1000;
 367      }
 368  
 369      /**
 370       *
 371       * @author sishu.yss
 372       * @param year
 373       * @param month
 374       * @return
 375       */
 376      public static long getFirstDay4Month(int year, int month) {
 377          long firstDay = 0L;
 378          Calendar cal = Calendar.getInstance();
 379          cal.set(Calendar.YEAR, year);
 380          cal.set(Calendar.MONTH, month - 1);
 381          cal.set(Calendar.DAY_OF_MONTH, 1);
 382          cal.set(Calendar.HOUR_OF_DAY, 0);
 383          cal.set(Calendar.MINUTE, 0);
 384          cal.set(Calendar.SECOND, 0);
 385          cal.set(Calendar.MILLISECOND, 0);
 386          firstDay = cal.getTimeInMillis() / 1000;
 387          return firstDay;
 388      }
 389  
 390      /**
 391       *
 392       * @author yumo.lck
 393       * @param year
 394       * @param month
 395       * @return
 396       */
 397      public static long getLastDay4Month(int year, int month) {
 398          long lastDay = 0L;
 399          Calendar cal = Calendar.getInstance();
 400          cal.set(Calendar.YEAR, year);
 401          cal.set(Calendar.MONTH, month);
<abbr title=" 402          //1 represents a zero next month, can be seen as the end of the first day of the month most one day, but the data table on the last day of the zero point on the line"> 402          //1 represents a zero next month, can be seen as the end of the first day of the month most one day, but tüîµ</abbr>
 403          cal.set(Calendar.DAY_OF_MONTH, 0);
 404          cal.set(Calendar.HOUR_OF_DAY, 0);
 405          cal.set(Calendar.MINUTE, 0);
 406          cal.set(Calendar.SECOND, 0);
 407          cal.set(Calendar.MILLISECOND, 0);
 408          lastDay = cal.getTimeInMillis() / 1000;
 409          return lastDay;
 410      }
 411  
 412      /**
 413       *
 414       * @author yumo.lck
 415       * @param chooseFirstDay
 416       */
 417  
 418      public static long getBeforeMonthDay(long day, boolean chooseFirstDay) {
 419          long chooseDay = 0L;
 420          int currentMonth = getMonth(day);
 421          int currentYear = getYear(day);
 422          if (currentMonth &gt; 1) {
 423              currentMonth--;
 424          } else {
 425              currentYear--;
 426              currentMonth = 12;
 427          }
 428          if (chooseFirstDay) {
 429              chooseDay = getFirstDay4Month(currentYear, currentMonth);
 430              return chooseDay;
 431          } else {
 432              chooseDay = getLastDay4Month(currentYear, currentMonth);
 433              return chooseDay;
 434          }
 435  
 436      }
 437  
 438      /**
 439       * @return long
 440       */
 441      public static long getMillByOneDay() {
 442          Calendar cal = Calendar.getInstance();
 443          cal.set(Calendar.HOUR_OF_DAY, 0);
 444          cal.set(Calendar.MINUTE, 0);
 445          cal.set(Calendar.SECOND, 0);
 446          cal.set(Calendar.MILLISECOND, 0);
 447          return cal.getTimeInMillis() / 1000;
 448      }
 449  
 450      /**
 451       *
 452       * @return long
 453       */
 454      public static long getMillByYesDay() {
 455          Calendar cal = Calendar.getInstance();
 456          cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 1);
 457          cal.set(Calendar.HOUR_OF_DAY, 0);
 458          cal.set(Calendar.MINUTE, 0);
 459          cal.set(Calendar.SECOND, 0);
 460          cal.set(Calendar.MILLISECOND, 0);
 461          return cal.getTimeInMillis() / 1000;
 462      }
 463  
 464      /**
 465       *
 466       * @return
 467       */
 468      public static long getMillByLastWeekDay() {
 469          Calendar cal = Calendar.getInstance();
 470          cal.set(Calendar.DATE, cal.get(Calendar.DATE) - 7);
 471          cal.set(Calendar.HOUR_OF_DAY, 0);
 472          cal.set(Calendar.MINUTE, 0);
 473          cal.set(Calendar.SECOND, 0);
 474          cal.set(Calendar.MILLISECOND, 0);
 475          return cal.getTimeInMillis() / 1000;
 476      }
 477  
 478     /**
 479      * @return long
 480      */
 481      public static long getMillByDay(int severalDays,String condition) {
 482      	int dateT=0;
 483          Calendar cal = Calendar.getInstance();
 484      	if(condition==null){
 485      		return getMillToDay(cal,dateT);
 486      	}
 487          if(condition.equals(&quot;-&quot;)){

 488          	dateT = (cal.get(Calendar.DATE) - severalDays);
 489          	return getMillToDay(cal,dateT);
 490          }
 491          if(condition.equals(&quot;+&quot;)){

 492          	dateT = (cal.get(Calendar.DATE) + severalDays);
 493          	return getMillToDay(cal,dateT);
 494          }
 495  		return getMillToDay(cal,dateT);
 496    }
 497  
 498      /**
 499       * @return long
 500       */
 501      public static long getStampByDay(int severalDays,String condition) {
 502      	int dateT=0;
 503      	Calendar cal = Calendar.getInstance();
 504      	if(condition==null){
 505      		return getStampToDay(cal,dateT);
 506      	}
 507      	if(condition.equals(&quot;-&quot;)){

 508      		dateT = (cal.get(Calendar.DATE) - severalDays);
 509      		return getStampToDay(cal,dateT);
 510      	}
 511      	if(condition.equals(&quot;+&quot;)){

 512      		dateT = (cal.get(Calendar.DATE) + severalDays);
 513      		return getStampToDay(cal,dateT);
 514      	}
 515      	return getStampToDay(cal,dateT);
 516      }
 517      /**
 518       * @return long
 519       */
 520      public static long getMillByDay(){
 521  		return getMillByDay(0,null);
 522      }
 523  
 524      /**
 525       * @param cal  Calendar
 526       * @param dateT Integer
 527       * @return  long
 528       */
 529      public static long getMillToDay(Calendar cal,int dateT){
 530  		   if(dateT!=0){
 531  			   cal.set(Calendar.DATE, dateT);
 532  		   }
 533  	       cal.set(Calendar.HOUR_OF_DAY, 0);
 534  	       cal.set(Calendar.MINUTE, 0);
 535  	       cal.set(Calendar.SECOND, 0);
 536  	       cal.set(Calendar.MILLISECOND, 0);
 537  	       return cal.getTimeInMillis()/1000;
 538  	}
 539  
 540      /**
 541       * @param cal  Calendar
 542       * @param dateT Integer
 543       * @return  long
 544       */
 545      public static long getStampToDay(Calendar cal,int dateT){
 546      	if(dateT!=0){
 547      		cal.set(Calendar.DATE, dateT);
 548      	}
 549      	return cal.getTimeInMillis();
 550      }
 551  
 552      public static String getToday() {
 553          Calendar cal = Calendar.getInstance();
 554          return cal.get(1) + &quot;Âπ¥&quot; + cal.get(2) + &quot;Êúà&quot; + cal.get(3) + &quot;Êó•&quot;;
 555      }
 556  
 557      /**
 558       * @param day
 559       * @return format time
 560       */
 561      public static String getDate(long day, String format) {
 562          Calendar cal = Calendar.getInstance();
 563          if ((&quot;&quot; + day).length() &gt; 10) {
 564              cal.setTime(new Date(day));
 565          } else {
 566              cal.setTime(new Date(day * 1000));
 567          }
 568          SimpleDateFormat sf = new SimpleDateFormat(format);
 569          return sf.format(cal.getTime());
 570      }
 571  
 572      /**
 573       *
 574       * @param  date
 575       * @return
 576       */
 577      public static String getDate(Date date, String format) {
 578          SimpleDateFormat sf = new SimpleDateFormat(format);
 579          return sf.format(date);
 580      }
 581  
 582  
 583      /**
 584       *
 585       * @param day
 586       * @param format
 587       * @return long
 588       * @throws ParseException
 589       */
 590      public static long stringToLong(String day, String format) throws ParseException {
 591      	SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 592          long Date = dateFormat.parse(day).getTime();
 593      	return Date;


 594      }
 595  
 596      /**
 597       * @param day
 598       * @param format
 599       * @return Date
 600       * @throws ParseException
 601       */
 602      public static Date stringToDate(String day, String format)  {
 603      	try {
 604  			SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 605  			 Date Date = dateFormat.parse(day);
 606  			return Date;


 607  		} catch (ParseException e) {
 608  			return new Date();
 609  		}
 610      }
 611  
 612  
 613      /**
 614       * longÂûãÊó∂Èó¥Êà≥ËΩ¨‰∏∫StringÂûã
 615       *
 616       * @param day Áßí
 617       * @return Ê†ºÂºèÂåñÂêéÁöÑÊó•Êúü
 618       * @throws ParseException
 619       */
 620      public static String longToString(long day, String format) throws ParseException {
 621      	if ((&quot;&quot; + day).length() &lt;= 10){
 622              day=day*1000;
 623          }
 624      	SimpleDateFormat dateFormat = new SimpleDateFormat(format);
 625  	    String Date = dateFormat.format(day);
 626      	return Date;


 627      }
 628  
 629      /**
 630       *
 631       * @param day Áßí
 632       * @param minusDay ÈúÄË¶ÅÂáèÊéâÁöÑÂ§©Êï∞
 633       * @return Áßí
 634       */
 635      public static int getMinusDate(int day, int minusDay) {
 636          Calendar cal = Calendar.getInstance();
 637          cal.setTime(new Date(day * 1000));
 638          cal.set(Calendar.DATE, cal.get(Calendar.DATE) - minusDay);
 639          cal.set(Calendar.HOUR_OF_DAY, 0);
 640          cal.set(Calendar.MINUTE, 0);
 641          cal.set(Calendar.SECOND, 0);
 642          cal.set(Calendar.MILLISECOND, 0);
 643          return (int) cal.getTimeInMillis() / 1000;
 644      }
 645  
 646      /**
 647       *
 648       * @return long
 649       */
 650      public static long getMillByNow() {
 651          Calendar cal = Calendar.getInstance();
 652          cal.setTime(new Date());
 653          return cal.getTimeInMillis();
 654      }
 655  
 656  	public static int getWeeksBetweenTwoDates(long startDay, long endDay) {
 657  		int week = getWeekOfYear(endDay) - getWeekOfYear(startDay) + 1;
 658  		if(week&lt;1){
 659  			week = getWeekOfYear(endDay) + getMaxWeekOfYear(startDay) - getWeekOfYear(startDay) + 1;
 660  		}
 661  		return week;
 662  	}
 663  
 664  	public static int getMaxWeekOfYear(long startDay) {
 665  		Calendar cal = Calendar.getInstance();
 666          cal.setTime(new Date(startDay * 1000));
 667          return cal.getMaximum(Calendar.WEEK_OF_YEAR);
 668  	}
 669  
 670  	public static int getMonthsBetweenTwoDates(long startDay, long endDay) {
 671  		int month = DateUtil.getMonth(endDay) - DateUtil.getMonth(startDay) + 1;
 672  		if(month&lt;1){
 673  			month = getMonth(endDay) + 12 - getMonth(startDay) +1;
 674  		}
 675  		return month;
 676  	}
 677  
 678  	public static Date parseDate(String dateStr, String pattern){
 679  		SimpleDateFormat sdf = new SimpleDateFormat();
 680  		sdf.applyPattern(pattern);
 681  		try {
 682  			return sdf.parse(dateStr);
 683  		} catch (ParseException e) {
 684  			return null;
 685  		}
 686  	}
 687  
 688  	/**
 689       *
 690       * @param time Long Êó∂Èó¥
 691       * @return long
 692       */
 693      public static long getMinuteStart(long time) {
 694          long firstDay = 0L;
 695          Calendar cal = Calendar.getInstance();
 696          if ((&quot;&quot; + time).length() &gt; 10) {
 697              cal.setTime(new Date(time));
 698          } else {
 699              cal.setTime(new Date(time * 1000));
 700          }
 701          cal.set(Calendar.SECOND, 0);
 702          cal.set(Calendar.MILLISECOND, 0);
 703          firstDay = cal.getTimeInMillis() / 1000;
 704          return firstDay;
 705      }
 706  
 707      /**
 708       * @param time Long
 709       * @return long
 710       */
 711      public static long getHourStart(long time) {
 712          long firstDay = 0L;
 713          Calendar cal = Calendar.getInstance();
 714          if ((&quot;&quot; + time).length() &gt; 10) {
 715              cal.setTime(new Date(time));
 716          } else {
 717              cal.setTime(new Date(time * 1000));
 718          }
 719          cal.set(Calendar.SECOND, 0);
 720          cal.set(Calendar.MILLISECOND, 0);
 721          cal.set(Calendar.MINUTE, 0);
 722          firstDay = cal.getTimeInMillis() / 1000;
 723          return firstDay;
 724      }
 725  
 726      /**
 727       * @param time
 728       * @return Date
 729       */
 730      public static Date getDateByLong(long time){
 731          Date date = new Date();
 732          date.setTime(time);
 733          return date;
 734      }
 735  
 736  
 737      public static Date parseDate(String dateStr, String pattern, Locale locale){
 738      	SimpleDateFormat df = new SimpleDateFormat(
 739  				pattern, locale);
 740  
 741  		df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 742  		try {
 743  			return df.parse(dateStr);
 744  		} catch (ParseException e) {
 745  			return null;
 746  		}
 747  	}
 748  
 749      public static String getDate(Date date, String format, Locale locale) {
 750      	SimpleDateFormat df = new SimpleDateFormat(
 751      			format, locale);
 752      	df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
 753          return df.format(date);
 754      }
 755  
 756      public static java.sql.Timestamp columnToTimestamp(Object column) {
 757          if (column == null) {
 758              return null;
 759          } else if(column instanceof String) {
 760              return new java.sql.Timestamp(stringToDate((String)column).getTime());
 761          } else if (column instanceof Integer) {
 762              Integer rawData = (Integer) column;
 763              return new java.sql.Timestamp(rawData.longValue());
 764          } else if (column instanceof Long) {
 765              Long rawData = (Long) column;
 766              return new java.sql.Timestamp(rawData.longValue());
 767          } else if (column instanceof java.sql.Date) {
 768              return (java.sql.Timestamp) column;
 769          } else if(column instanceof Timestamp) {
 770              return (Timestamp) column;
 771          } else if(column instanceof Date) {
 772              Date d = (Date)column;
 773              return new java.sql.Timestamp(d.getTime());
 774          }
 775  
 776          throw new IllegalArgumentException(&quot;Can&#x27;t convert &quot; + column.getClass().getName() + &quot; to Date&quot;);
 777      }
 778  
 779      public static String dateToString(Date date) {
 780          return dateFormatter.format(date);


 781      }
 782  
 783      public static String timestampToString(Date date) {
 784          return datetimeFormatter.format(date);
 785      }
 786  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 787 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 788 +    public static Timestamp getTimestampFromStr(String timeStr) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 789 +        if (DATETIME.matcher(timeStr).matches()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 790 +            Instant instant = Instant.from(ISO_INSTANT.parse(timeStr));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 791 +            return new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 792 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 793 +            java.sql.Date date = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 794 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 795 +                date = new java.sql.Date(datetimeFormatter.parse(timeStr).getTime());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 796 +            } catch (ParseException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 797 +                throw new RuntimeException(&quot;getTimestampFromStr error data is &quot; + timeStr);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 798 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 799 +            return new Timestamp(date.getTime());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 800 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 801 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 802 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 803 +    public static java.sql.Date getDateFromStr(String dateStr) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 804 +        // 2020-01-01 format</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 805 +        if (DATE.matcher(dateStr).matches()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 806 +            // convert from local date to instant</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 807 +            Instant instant = LocalDate.parse(dateStr).atTime(LocalTime.of(0, 0, 0, 0)).toInstant(ZoneOffset.UTC);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 808 +            // calculate the timezone offset in millis</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 809 +            int offset = TimeZone.getDefault().getOffset(instant.toEpochMilli());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 810 +            // need to remove the offset since time has no TZ component</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 811 +            return new java.sql.Date(instant.toEpochMilli() - offset);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 812 +        } else if (DATETIME.matcher(dateStr).matches()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 813 +            // 2020-01-01T12:12:12Z format</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 814 +            Instant instant = Instant.from(ISO_INSTANT.parse(dateStr));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 815 +            return new java.sql.Date(instant.toEpochMilli());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 816 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 817 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 818 +                // 2020-01-01 12:12:12.0 format</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 819 +                return new java.sql.Date(datetimeFormatter.parse(dateStr).getTime());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 820 +            } catch (ParseException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 821 +                throw new RuntimeException(&quot;String convert to Date fail.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 822 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 823 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 824 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 825 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 826 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 827 +    public static String getStringFromTimestamp(Timestamp timestamp) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 828 +        return datetimeFormatter.format(timestamp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 829 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 831 +    public static String getStringFromDate(java.sql.Date date) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 832 +        return dateFormatter.format(date);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 833 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 834 +</span>
 835  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            