<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>446 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void exec(String sql, Map&lt;String, &#x27;
                         &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                         &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                         &#x27;                     Map&lt;String, Table&gt; tableCache, &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                         &#x27;throws Exception {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void exec(String sql,\n&#x27;
                           &#x27;                     Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;                     StreamTableEnvironment &#x27;
                           &#x27;tableEnv,\n&#x27;
                           &#x27;                     Map&lt;String, Table&gt; &#x27;
                           &#x27;tableCache,\n&#x27;
                           &#x27;                     StreamQueryConfig &#x27;
                           &#x27;queryConfig,\n&#x27;
                           &#x27;                     &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult createView,\n&#x27;
                           &#x27;                     String scope) throws &#x27;
                           &#x27;Exception {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        Queue&lt;Object&gt; exeQueue = &#x27;
                         &#x27;sideSQLParser.getExeQueue(sql, &#x27;
                         &#x27;sideTableMap.keySet());\n&#x27;
                         &#x27;        Object pollObj;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        Queue&lt;Object&gt; exeQueue = &#x27;
                           &#x27;sideSQLParser.getExeQueue(sql, &#x27;
                           &#x27;sideTableMap.keySet(), scope);\n&#x27;
                           &#x27;        Object pollObj = null;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        &#x27;
                         &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;ON condition &#x27;
                         &#x27;must contain all equal fields!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        &#x27;
                         &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;ON condition &#x27;
                         &#x27;must contain all equal fields!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                                &#x27;
                         &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                         &#x27;                                    throw new &#x27;
                         &#x27;RuntimeException(&quot;ON condition must contain all &#x27;
                         &#x27;equal fields!!!&quot;);\n&#x27;
                         &#x27;                                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        HashBasedTable&lt;String, String, String&gt; &#x27;
                         &#x27;mappingTable = HashBasedTable.create();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        HashBasedTable&lt;String, String, String&gt; &#x27;
                         &#x27;mappingTable = HashBasedTable.create();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                                &#x27;
                         &#x27;HashBasedTable&lt;String, String, String&gt; mappingTable &#x27;
                         &#x27;= HashBasedTable.create();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点\n&#x27;
                         &#x27;        for(FieldReplaceInfo tmp : &#x27;
                         &#x27;replaceInfoList){\n&#x27;
                         &#x27;            &#x27;
                         &#x27;if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())\n&#x27;
                         &#x27;            &#x27;
                         &#x27;||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){\n&#x27;
                         &#x27;                replaceInfo.setPreNode(tmp);\n&#x27;
                         &#x27;                break;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        replaceInfoList.add(replaceInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; registeredTableName = &#x27;
                         &#x27;Arrays.asList(tableEnv.listTables());\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!registeredTableName.contains(joinInfo.getNewTableName())){\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if &#x27;
                           &#x27;(!tableEnv.isRegistered(targetTableName)){\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点\n&#x27;
                         &#x27;        for(FieldReplaceInfo tmp : &#x27;
                         &#x27;replaceInfoList){\n&#x27;
                         &#x27;            &#x27;
                         &#x27;if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())\n&#x27;
                         &#x27;            &#x27;
                         &#x27;||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){\n&#x27;
                         &#x27;                replaceInfo.setPreNode(tmp);\n&#x27;
                         &#x27;                break;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        replaceInfoList.add(replaceInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; registeredTableName = &#x27;
                         &#x27;Arrays.asList(tableEnv.listTables());\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!registeredTableName.contains(joinInfo.getNewTableName())){\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if &#x27;
                           &#x27;(!tableEnv.isRegistered(targetTableName)){\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                                &#x27;
                         &#x27;//判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点\n&#x27;
                         &#x27;                                for(FieldReplaceInfo &#x27;
                         &#x27;tmp : replaceInfoList){\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){\n&#x27;
                         &#x27;                                        &#x27;
                         &#x27;replaceInfo.setPreNode(tmp);\n&#x27;
                         &#x27;                                        break;\n&#x27;
                         &#x27;                                    }\n&#x27;
                         &#x27;                                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;replaceInfoList.add(replaceInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                                List&lt;String&gt; &#x27;
                         &#x27;registeredTableName = &#x27;
                         &#x27;Arrays.asList(tableEnv.listTables());\n&#x27;
                         &#x27;                                if &#x27;
                         &#x27;(!registeredTableName.contains(joinInfo.getNewTableName())){\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;                                if &#x27;
                           &#x27;(!tableEnv.isRegistered(targetTableName)){\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void exec(String sql, Map&lt;String, &#x27;
                         &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                         &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                         &#x27;                     Map&lt;String, Table&gt; tableCache, &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;        if(localSqlPluginPath == null){\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;need to set &#x27;
                         &#x27;localSqlPluginPath&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        localTableCache.putAll(tableCache);\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;sidePredicatesParser.fillPredicatesForSideTable(sql, &#x27;
                         &#x27;sideTableMap);\n&#x27;
                         &#x27;        } catch (Exception e) {\n&#x27;
                         &#x27;            LOG.error(&quot;fill predicates for sideTable &#x27;
                         &#x27;fail &quot;, e);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if(createView != null){\n&#x27;
                         &#x27;            LOG.warn(&quot;create view info\\n&quot;);\n&#x27;
                         &#x27;            LOG.warn(createView.getExecSql());\n&#x27;
                         &#x27;            LOG.warn(&quot;-----------------&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        SideSQLParser sideSQLParser = new &#x27;
                         &#x27;SideSQLParser();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;sideSQLParser.setLocalTableCache(localTableCache);\n&#x27;
                         &#x27;        Queue&lt;Object&gt; exeQueue = &#x27;
                         &#x27;sideSQLParser.getExeQueue(sql, &#x27;
                         &#x27;sideTableMap.keySet());\n&#x27;
                         &#x27;        Object pollObj;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //need clean\n&#x27;
                         &#x27;        boolean preIsSideJoin = false;\n&#x27;
                         &#x27;        List&lt;FieldReplaceInfo&gt; replaceInfoList = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        while((pollObj = exeQueue.poll()) != null){\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if(pollObj instanceof SqlNode){\n&#x27;
                         &#x27;                SqlNode pollSqlNode = (SqlNode) &#x27;
                         &#x27;pollObj;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                if(preIsSideJoin){\n&#x27;
                         &#x27;                    preIsSideJoin = false;\n&#x27;
                         &#x27;                    List&lt;String&gt; fieldNames = null;\n&#x27;
                         &#x27;                    for(FieldReplaceInfo replaceInfo &#x27;
                         &#x27;: replaceInfoList){\n&#x27;
                         &#x27;                        fieldNames = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;replaceFieldName(pollSqlNode, replaceInfo);\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;addAliasForFieldNode(pollSqlNode, fieldNames, &#x27;
                         &#x27;replaceInfo.getMappingTable());\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                if(pollSqlNode.getKind() == &#x27;
                         &#x27;INSERT){\n&#x27;
                         &#x27;                    FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                         &#x27;pollSqlNode.toString());\n&#x27;
                         &#x27;                    if(LOG.isInfoEnabled()){\n&#x27;
                         &#x27;                        LOG.info(&quot;----------real &#x27;
                         &#x27;exec sql-----------\\n{}&quot;, pollSqlNode.toString());\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                }else if(pollSqlNode.getKind() == &#x27;
                         &#x27;AS){\n&#x27;
                         &#x27;                    dealAsSourceTable(tableEnv, &#x27;
                         &#x27;pollSqlNode, tableCache, replaceInfoList);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                } else if (pollSqlNode.getKind() == &#x27;
                         &#x27;WITH_ITEM) {\n&#x27;
                         &#x27;                    SqlWithItem sqlWithItem = &#x27;
                         &#x27;(SqlWithItem) pollSqlNode;\n&#x27;
                         &#x27;                    String TableAlias = &#x27;
                         &#x27;sqlWithItem.name.toString();\n&#x27;
                         &#x27;                    Table table = &#x27;
                         &#x27;tableEnv.sqlQuery(sqlWithItem.query.toString());\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;tableEnv.registerTable(TableAlias, table);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                } else if (pollSqlNode.getKind() == &#x27;
                         &#x27;SELECT){\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;Preconditions.checkState(createView != null, &quot;select &#x27;
                         &#x27;sql must included by create view&quot;);\n&#x27;
                         &#x27;                    Table table = &#x27;
                         &#x27;tableEnv.sqlQuery(pollObj.toString());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(createView.getFieldsInfoStr() == null){\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;tableEnv.registerTable(createView.getTableName(), &#x27;
                         &#x27;table);\n&#x27;
                         &#x27;                    } else {\n&#x27;
                         &#x27;                        if &#x27;
                         &#x27;(checkFieldsInfo(createView, table)){\n&#x27;
                         &#x27;                            table = &#x27;
                         &#x27;table.as(tmpFields);\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;tableEnv.registerTable(createView.getTableName(), &#x27;
                         &#x27;table);\n&#x27;
                         &#x27;                        } else {\n&#x27;
                         &#x27;                            throw new &#x27;
                         &#x27;RuntimeException(&quot;Fields mismatch&quot;);\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;localTableCache.put(createView.getTableName(), &#x27;
                         &#x27;table);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            }else if (pollObj instanceof JoinInfo){\n&#x27;
                         &#x27;                LOG.info(&quot;----------exec join &#x27;
                         &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                         &#x27;                preIsSideJoin = true;\n&#x27;
                         &#x27;                joinFun(pollObj, localTableCache, &#x27;
                         &#x27;sideTableMap, tableEnv, replaceInfoList);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void exec(String sql,\n&#x27;
                           &#x27;                     Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;                     StreamTableEnvironment &#x27;
                           &#x27;tableEnv,\n&#x27;
                           &#x27;                     Map&lt;String, Table&gt; &#x27;
                           &#x27;tableCache,\n&#x27;
                           &#x27;                     StreamQueryConfig &#x27;
                           &#x27;queryConfig,\n&#x27;
                           &#x27;                     &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult createView,\n&#x27;
                           &#x27;                     String scope) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;        if(localSqlPluginPath == null){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;need to &#x27;
                           &#x27;set localSqlPluginPath&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        localTableCache.putAll(tableCache);\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;sidePredicatesParser.fillPredicatesForSideTable(sql, &#x27;
                           &#x27;sideTableMap);\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            LOG.error(&quot;fill predicates for &#x27;
                           &#x27;sideTable fail &quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(createView != null){\n&#x27;
                           &#x27;            LOG.warn(&quot;create view info\\n&quot;);\n&#x27;
                           &#x27;            LOG.warn(createView.getExecSql());\n&#x27;
                           &#x27;            LOG.warn(&quot;-----------------&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SideSQLParser sideSQLParser = new &#x27;
                           &#x27;SideSQLParser();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;sideSQLParser.setLocalTableCache(localTableCache);\n&#x27;
                           &#x27;        Queue&lt;Object&gt; exeQueue = &#x27;
                           &#x27;sideSQLParser.getExeQueue(sql, &#x27;
                           &#x27;sideTableMap.keySet(), scope);\n&#x27;
                           &#x27;        Object pollObj = null;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        while((pollObj = exeQueue.poll()) != &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(pollObj instanceof SqlNode){\n&#x27;
                           &#x27;                SqlNode pollSqlNode = (SqlNode) &#x27;
                           &#x27;pollObj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(pollSqlNode.getKind() == &#x27;
                           &#x27;INSERT){\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                           &#x27;pollSqlNode.toString(), queryConfig);\n&#x27;
                           &#x27;                    if(LOG.isInfoEnabled()){\n&#x27;
                           &#x27;                        LOG.info(&quot;----------real &#x27;
                           &#x27;exec sql-----------\\n{}&quot;, &#x27;
                           &#x27;pollSqlNode.toString());\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                }else if(pollSqlNode.getKind() == &#x27;
                           &#x27;AS){\n&#x27;
                           &#x27;                    dealAsSourceTable(tableEnv, &#x27;
                           &#x27;pollSqlNode, tableCache);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                } else if (pollSqlNode.getKind() &#x27;
                           &#x27;== WITH_ITEM) {\n&#x27;
                           &#x27;                    SqlWithItem sqlWithItem = &#x27;
                           &#x27;(SqlWithItem) pollSqlNode;\n&#x27;
                           &#x27;                    String TableAlias = &#x27;
                           &#x27;sqlWithItem.name.toString();\n&#x27;
                           &#x27;                    Table table = &#x27;
                           &#x27;tableEnv.sqlQuery(sqlWithItem.query.toString());\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;tableEnv.registerTable(TableAlias, table);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                } else if (pollSqlNode.getKind() &#x27;
                           &#x27;== SELECT){\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;Preconditions.checkState(createView != null, &#x27;
                           &#x27;&quot;select sql must included by create view&quot;);\n&#x27;
                           &#x27;                    Table table = &#x27;
                           &#x27;tableEnv.sqlQuery(pollObj.toString());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    if &#x27;
                           &#x27;(createView.getFieldsInfoStr() == null){\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;tableEnv.registerTable(createView.getTableName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                    } else {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(checkFieldsInfo(createView, table)){\n&#x27;
                           &#x27;                            table = &#x27;
                           &#x27;table.as(tmpFields);\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;tableEnv.registerTable(createView.getTableName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                        } else {\n&#x27;
                           &#x27;                            throw new &#x27;
                           &#x27;RuntimeException(&quot;Fields mismatch&quot;);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;localTableCache.put(createView.getTableName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            }else if (pollObj instanceof &#x27;
                           &#x27;JoinInfo){\n&#x27;
                           &#x27;                LOG.info(&quot;----------exec join &#x27;
                           &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                           &#x27;                joinFun(pollObj, localTableCache, &#x27;
                           &#x27;sideTableMap, tableEnv);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void exec(String sql, Map&lt;String, &#x27;
                         &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                         &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                         &#x27;                     Map&lt;String, Table&gt; tableCache, &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                         &#x27;throws Exception {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void exec(String sql,\n&#x27;
                           &#x27;                     Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;                     StreamTableEnvironment &#x27;
                           &#x27;tableEnv,\n&#x27;
                           &#x27;                     Map&lt;String, Table&gt; &#x27;
                           &#x27;tableCache,\n&#x27;
                           &#x27;                     StreamQueryConfig &#x27;
                           &#x27;queryConfig,\n&#x27;
                           &#x27;                     &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult createView,\n&#x27;
                           &#x27;                     String scope) throws &#x27;
                           &#x27;Exception {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void exec(String sql, Map&lt;String, &#x27;
                         &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                         &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                         &#x27;                     Map&lt;String, Table&gt; tableCache, &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;        if(localSqlPluginPath == null){\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;need to set &#x27;
                         &#x27;localSqlPluginPath&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        localTableCache.putAll(tableCache);\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;sidePredicatesParser.fillPredicatesForSideTable(sql, &#x27;
                         &#x27;sideTableMap);\n&#x27;
                         &#x27;        } catch (Exception e) {\n&#x27;
                         &#x27;            LOG.error(&quot;fill predicates for sideTable &#x27;
                         &#x27;fail &quot;, e);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if(createView != null){\n&#x27;
                         &#x27;            LOG.warn(&quot;create view info\\n&quot;);\n&#x27;
                         &#x27;            LOG.warn(createView.getExecSql());\n&#x27;
                         &#x27;            LOG.warn(&quot;-----------------&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        SideSQLParser sideSQLParser = new &#x27;
                         &#x27;SideSQLParser();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;sideSQLParser.setLocalTableCache(localTableCache);\n&#x27;
                         &#x27;        Queue&lt;Object&gt; exeQueue = &#x27;
                         &#x27;sideSQLParser.getExeQueue(sql, &#x27;
                         &#x27;sideTableMap.keySet());\n&#x27;
                         &#x27;        Object pollObj;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //need clean\n&#x27;
                         &#x27;        boolean preIsSideJoin = false;\n&#x27;
                         &#x27;        List&lt;FieldReplaceInfo&gt; replaceInfoList = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        while((pollObj = exeQueue.poll()) != null){\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            if(pollObj instanceof SqlNode){\n&#x27;
                         &#x27;                SqlNode pollSqlNode = (SqlNode) &#x27;
                         &#x27;pollObj;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                if(preIsSideJoin){\n&#x27;
                         &#x27;                    preIsSideJoin = false;\n&#x27;
                         &#x27;                    List&lt;String&gt; fieldNames = null;\n&#x27;
                         &#x27;                    for(FieldReplaceInfo replaceInfo &#x27;
                         &#x27;: replaceInfoList){\n&#x27;
                         &#x27;                        fieldNames = &#x27;
                         &#x27;Lists.newArrayList();\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;replaceFieldName(pollSqlNode, replaceInfo);\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;addAliasForFieldNode(pollSqlNode, fieldNames, &#x27;
                         &#x27;replaceInfo.getMappingTable());\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                if(pollSqlNode.getKind() == &#x27;
                         &#x27;INSERT){\n&#x27;
                         &#x27;                    FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                         &#x27;pollSqlNode.toString());\n&#x27;
                         &#x27;                    if(LOG.isInfoEnabled()){\n&#x27;
                         &#x27;                        LOG.info(&quot;----------real &#x27;
                         &#x27;exec sql-----------\\n{}&quot;, pollSqlNode.toString());\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                }else if(pollSqlNode.getKind() == &#x27;
                         &#x27;AS){\n&#x27;
                         &#x27;                    dealAsSourceTable(tableEnv, &#x27;
                         &#x27;pollSqlNode, tableCache, replaceInfoList);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                } else if (pollSqlNode.getKind() == &#x27;
                         &#x27;WITH_ITEM) {\n&#x27;
                         &#x27;                    SqlWithItem sqlWithItem = &#x27;
                         &#x27;(SqlWithItem) pollSqlNode;\n&#x27;
                         &#x27;                    String TableAlias = &#x27;
                         &#x27;sqlWithItem.name.toString();\n&#x27;
                         &#x27;                    Table table = &#x27;
                         &#x27;tableEnv.sqlQuery(sqlWithItem.query.toString());\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;tableEnv.registerTable(TableAlias, table);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                } else if (pollSqlNode.getKind() == &#x27;
                         &#x27;SELECT){\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;Preconditions.checkState(createView != null, &quot;select &#x27;
                         &#x27;sql must included by create view&quot;);\n&#x27;
                         &#x27;                    Table table = &#x27;
                         &#x27;tableEnv.sqlQuery(pollObj.toString());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                    if &#x27;
                         &#x27;(createView.getFieldsInfoStr() == null){\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;tableEnv.registerTable(createView.getTableName(), &#x27;
                         &#x27;table);\n&#x27;
                         &#x27;                    } else {\n&#x27;
                         &#x27;                        if &#x27;
                         &#x27;(checkFieldsInfo(createView, table)){\n&#x27;
                         &#x27;                            table = &#x27;
                         &#x27;table.as(tmpFields);\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;tableEnv.registerTable(createView.getTableName(), &#x27;
                         &#x27;table);\n&#x27;
                         &#x27;                        } else {\n&#x27;
                         &#x27;                            throw new &#x27;
                         &#x27;RuntimeException(&quot;Fields mismatch&quot;);\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;localTableCache.put(createView.getTableName(), &#x27;
                         &#x27;table);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            }else if (pollObj instanceof JoinInfo){\n&#x27;
                         &#x27;                LOG.info(&quot;----------exec join &#x27;
                         &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                         &#x27;                preIsSideJoin = true;\n&#x27;
                         &#x27;                joinFun(pollObj, localTableCache, &#x27;
                         &#x27;sideTableMap, tableEnv, replaceInfoList);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void exec(String sql,\n&#x27;
                           &#x27;                     Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;                     StreamTableEnvironment &#x27;
                           &#x27;tableEnv,\n&#x27;
                           &#x27;                     Map&lt;String, Table&gt; &#x27;
                           &#x27;tableCache,\n&#x27;
                           &#x27;                     StreamQueryConfig &#x27;
                           &#x27;queryConfig,\n&#x27;
                           &#x27;                     &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult createView,\n&#x27;
                           &#x27;                     String scope) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;        if(localSqlPluginPath == null){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;need to &#x27;
                           &#x27;set localSqlPluginPath&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        localTableCache.putAll(tableCache);\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;sidePredicatesParser.fillPredicatesForSideTable(sql, &#x27;
                           &#x27;sideTableMap);\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            LOG.error(&quot;fill predicates for &#x27;
                           &#x27;sideTable fail &quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(createView != null){\n&#x27;
                           &#x27;            LOG.warn(&quot;create view info\\n&quot;);\n&#x27;
                           &#x27;            LOG.warn(createView.getExecSql());\n&#x27;
                           &#x27;            LOG.warn(&quot;-----------------&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SideSQLParser sideSQLParser = new &#x27;
                           &#x27;SideSQLParser();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;sideSQLParser.setLocalTableCache(localTableCache);\n&#x27;
                           &#x27;        Queue&lt;Object&gt; exeQueue = &#x27;
                           &#x27;sideSQLParser.getExeQueue(sql, &#x27;
                           &#x27;sideTableMap.keySet(), scope);\n&#x27;
                           &#x27;        Object pollObj = null;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        while((pollObj = exeQueue.poll()) != &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(pollObj instanceof SqlNode){\n&#x27;
                           &#x27;                SqlNode pollSqlNode = (SqlNode) &#x27;
                           &#x27;pollObj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(pollSqlNode.getKind() == &#x27;
                           &#x27;INSERT){\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                           &#x27;pollSqlNode.toString(), queryConfig);\n&#x27;
                           &#x27;                    if(LOG.isInfoEnabled()){\n&#x27;
                           &#x27;                        LOG.info(&quot;----------real &#x27;
                           &#x27;exec sql-----------\\n{}&quot;, &#x27;
                           &#x27;pollSqlNode.toString());\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                }else if(pollSqlNode.getKind() == &#x27;
                           &#x27;AS){\n&#x27;
                           &#x27;                    dealAsSourceTable(tableEnv, &#x27;
                           &#x27;pollSqlNode, tableCache);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                } else if (pollSqlNode.getKind() &#x27;
                           &#x27;== WITH_ITEM) {\n&#x27;
                           &#x27;                    SqlWithItem sqlWithItem = &#x27;
                           &#x27;(SqlWithItem) pollSqlNode;\n&#x27;
                           &#x27;                    String TableAlias = &#x27;
                           &#x27;sqlWithItem.name.toString();\n&#x27;
                           &#x27;                    Table table = &#x27;
                           &#x27;tableEnv.sqlQuery(sqlWithItem.query.toString());\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;tableEnv.registerTable(TableAlias, table);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                } else if (pollSqlNode.getKind() &#x27;
                           &#x27;== SELECT){\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;Preconditions.checkState(createView != null, &#x27;
                           &#x27;&quot;select sql must included by create view&quot;);\n&#x27;
                           &#x27;                    Table table = &#x27;
                           &#x27;tableEnv.sqlQuery(pollObj.toString());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    if &#x27;
                           &#x27;(createView.getFieldsInfoStr() == null){\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;tableEnv.registerTable(createView.getTableName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                    } else {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(checkFieldsInfo(createView, table)){\n&#x27;
                           &#x27;                            table = &#x27;
                           &#x27;table.as(tmpFields);\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;tableEnv.registerTable(createView.getTableName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                        } else {\n&#x27;
                           &#x27;                            throw new &#x27;
                           &#x27;RuntimeException(&quot;Fields mismatch&quot;);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;localTableCache.put(createView.getTableName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            }else if (pollObj instanceof &#x27;
                           &#x27;JoinInfo){\n&#x27;
                           &#x27;                LOG.info(&quot;----------exec join &#x27;
                           &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                           &#x27;                joinFun(pollObj, localTableCache, &#x27;
                           &#x27;sideTableMap, tableEnv);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        Queue&lt;Object&gt; exeQueue = &#x27;
                         &#x27;sideSQLParser.getExeQueue(sql, &#x27;
                         &#x27;sideTableMap.keySet());\n&#x27;
                         &#x27;        Object pollObj;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        Queue&lt;Object&gt; exeQueue = &#x27;
                           &#x27;sideSQLParser.getExeQueue(sql, &#x27;
                           &#x27;sideTableMap.keySet(), scope);\n&#x27;
                           &#x27;        Object pollObj = null;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        &#x27;
                         &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;ON condition &#x27;
                         &#x27;must contain all equal fields!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        &#x27;
                         &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;ON condition &#x27;
                         &#x27;must contain all equal fields!!!&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                                &#x27;
                         &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                         &#x27;                                    throw new &#x27;
                         &#x27;RuntimeException(&quot;ON condition must contain all &#x27;
                         &#x27;equal fields!!!&quot;);\n&#x27;
                         &#x27;                                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        HashBasedTable&lt;String, String, String&gt; &#x27;
                         &#x27;mappingTable = HashBasedTable.create();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        HashBasedTable&lt;String, String, String&gt; &#x27;
                         &#x27;mappingTable = HashBasedTable.create();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                                &#x27;
                         &#x27;HashBasedTable&lt;String, String, String&gt; mappingTable &#x27;
                         &#x27;= HashBasedTable.create();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点\n&#x27;
                         &#x27;        for(FieldReplaceInfo tmp : &#x27;
                         &#x27;replaceInfoList){\n&#x27;
                         &#x27;            &#x27;
                         &#x27;if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())\n&#x27;
                         &#x27;            &#x27;
                         &#x27;||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){\n&#x27;
                         &#x27;                replaceInfo.setPreNode(tmp);\n&#x27;
                         &#x27;                break;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        replaceInfoList.add(replaceInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; registeredTableName = &#x27;
                         &#x27;Arrays.asList(tableEnv.listTables());\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!registeredTableName.contains(joinInfo.getNewTableName())){\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if &#x27;
                           &#x27;(!tableEnv.isRegistered(targetTableName)){\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点\n&#x27;
                         &#x27;        for(FieldReplaceInfo tmp : &#x27;
                         &#x27;replaceInfoList){\n&#x27;
                         &#x27;            &#x27;
                         &#x27;if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())\n&#x27;
                         &#x27;            &#x27;
                         &#x27;||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){\n&#x27;
                         &#x27;                replaceInfo.setPreNode(tmp);\n&#x27;
                         &#x27;                break;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        replaceInfoList.add(replaceInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        List&lt;String&gt; registeredTableName = &#x27;
                         &#x27;Arrays.asList(tableEnv.listTables());\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!registeredTableName.contains(joinInfo.getNewTableName())){\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if &#x27;
                           &#x27;(!tableEnv.isRegistered(targetTableName)){\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                                &#x27;
                         &#x27;//判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点\n&#x27;
                         &#x27;                                for(FieldReplaceInfo &#x27;
                         &#x27;tmp : replaceInfoList){\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){\n&#x27;
                         &#x27;                                        &#x27;
                         &#x27;replaceInfo.setPreNode(tmp);\n&#x27;
                         &#x27;                                        break;\n&#x27;
                         &#x27;                                    }\n&#x27;
                         &#x27;                                }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;replaceInfoList.add(replaceInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;                                List&lt;String&gt; &#x27;
                         &#x27;registeredTableName = &#x27;
                         &#x27;Arrays.asList(tableEnv.listTables());\n&#x27;
                         &#x27;                                if &#x27;
                         &#x27;(!registeredTableName.contains(joinInfo.getNewTableName())){\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;                                if &#x27;
                           &#x27;(!tableEnv.isRegistered(targetTableName)){\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        