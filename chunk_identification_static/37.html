<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>37</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    37
                    <a href="36.html">prev</a>
                    <a href="38.html">next</a>
                    <a href="37_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_4e1fa0199c788f410832032e7aff720f0bc7c32d_Simplenote/src/main/java/com/automattic/simplenote/models/Note.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;4e1fa0199c788f410832032e7aff720f0bc7c32d:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;4e1fa0199c788f410832032e7aff720f0bc7c32d^1:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;4e1fa0199c788f410832032e7aff720f0bc7c32d^2:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;3a764d7c3f78240be2e14be35d5bf4517e6f794e:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import android.content.Context;
   4 import android.text.TextUtils;
   5 
   6 import androidx.annotation.NonNull;
   7 
   8 import com.automattic.simplenote.R;
   9 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  10 import com.automattic.simplenote.utils.DateTimeUtils;</span>
  11 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  12 import com.simperium.client.Bucket;</span>
  13 =======
  14 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  15 import com.automattic.simplenote.utils.TagUtils;
  16 import com.simperium.client.Bucket;
  17 import com.simperium.client.BucketObject;
  18 import com.simperium.client.BucketSchema;
  19 import com.simperium.client.Query;
  20 import com.simperium.client.Query.ComparisonType;
  21 import com.simperium.util.Uuid;
  22 
  23 import org.json.JSONArray;
  24 import org.json.JSONException;
  25 import org.json.JSONObject;
  26 
  27 import java.math.BigDecimal;
  28 import java.text.DateFormat;
  29 import java.text.ParseException;
  30 import java.text.SimpleDateFormat;
  31 import java.util.ArrayList;
  32 import java.util.Calendar;
  33 import java.util.List;
  34 import java.util.Locale;
  35 import java.util.TimeZone;
  36 import java.util.regex.Matcher;
  37 import java.util.regex.Pattern;
  38 
  39 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  40 
  41 public class Note extends BucketObject {
  42 
  43     public static final String BUCKET_NAME = &quot;note&quot;;
  44     public static final String MARKDOWN_TAG = &quot;markdown&quot;;
  45     public static final String PINNED_TAG = &quot;pinned&quot;;
  46     public static final String PREVIEW_TAG = &quot;preview&quot;;
  47     public static final String PUBLISHED_TAG = &quot;published&quot;;
  48     public static final String NEW_LINE = &quot;\n&quot;;
  49     public static final String CONTENT_PROPERTY = &quot;content&quot;;
  50     public static final String KEY_PROPERTY = &quot;key&quot;;
  51     public static final String TAGS_PROPERTY = &quot;tags&quot;;
  52     public static final String SYSTEM_TAGS_PROPERTY = &quot;systemTags&quot;;
  53     public static final String CREATION_DATE_PROPERTY = &quot;creationDate&quot;;
  54     public static final String MODIFICATION_DATE_PROPERTY = &quot;modificationDate&quot;;
  55     public static final String SHARE_URL_PROPERTY = &quot;shareURL&quot;;
  56     public static final String PUBLISH_URL_PROPERTY = &quot;publishURL&quot;;
  57     public static final String DELETED_PROPERTY = &quot;deleted&quot;;
  58     public static final String TITLE_INDEX_NAME = &quot;title&quot;;
  59     public static final String CONTENT_PREVIEW_INDEX_NAME = &quot;contentPreview&quot;;
  60     public static final String PINNED_INDEX_NAME = &quot;pinned&quot;;
  61     public static final String MODIFIED_INDEX_NAME = &quot;modified&quot;;
  62     public static final String CREATED_INDEX_NAME = &quot;created&quot;;
  63     public static final String MATCHED_TITLE_INDEX_NAME = &quot;matchedTitle&quot;;
  64     public static final String MATCHED_CONTENT_INDEX_NAME = &quot;matchedContent&quot;;
  65     public static final String PUBLISH_URL = &quot;http://simp.ly/p/&quot;;
  66     static public final String[] FULL_TEXT_INDEXES = new String[]{
  67             Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY};
  68     private static final String BLANK_CONTENT = &quot;&quot;;
  69     private static final String SPACE = &quot; &quot;;
  70     private static final int MAX_PREVIEW_CHARS = 300;
  71     protected String mTitle = null;
  72     protected String mContentPreview = null;
  73 
  74     public Note() {
  75         this(Uuid.uuid());
  76     }
  77 
  78     public Note(String key) {
  79         this(key, new JSONObject());
  80     }
  81 
  82     public Note(String key, JSONObject properties) {
  83         super(key, properties);
  84     }
  85 
  86     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket) {
  87         return noteBucket.query()
  88                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  89     }
  90 
  91     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket) {
  92         return noteBucket.query()
  93                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
  94     }
  95 
  96     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString) {
  97         return noteBucket.query()
  98                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
  99                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 100     }
 101 
 102     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag) {
 103         return noteBucket.query()
 104                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 105                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 106     }
 107 
 108     public static Query&lt;Note&gt; allWithNoTag(Bucket&lt;Note&gt; noteBucket) {
 109         return noteBucket.query()
 110                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 111                 .where(TAGS_PROPERTY, ComparisonType.EQUAL_TO, null);
 112     }
 113 
 114     public static Note fromContent(Bucket&lt;Note&gt; notesBucket, String content) {
 115         Note note = notesBucket.newObject();
 116         note.setContent(content);
 117         note.setCreationDate(Calendar.getInstance());
 118         note.setModificationDate(note.getCreationDate());
 119 
 120         return note;
 121     }
 122 
<abbr title=" 123     public static Note fromExportedJson(Bucket&lt;Note&gt; notesBucket, JSONObject noteJson) throws JSONException, ParseException {"> 123     public static Note fromExportedJson(Bucket&lt;Note&gt; notesBucket, JSONObject noteJson) throws JSONExceptiðŸ”µ</abbr>
 124         Note note = notesBucket.newObject();
 125         note.setContent(noteJson.optString(&quot;content&quot;, &quot;&quot;));
<abbr title=" 126         note.setCreationDate(noteJson.has(&quot;creationDate&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;creationDate&quot;)) : Calendar.getInstance());"> 126         note.setCreationDate(noteJson.has(&quot;creationDate&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getStrðŸ”µ</abbr>
<abbr title=" 127         note.setModificationDate(noteJson.has(&quot;lastModified&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;lastModified&quot;)) : Calendar.getInstance());"> 127         note.setModificationDate(noteJson.has(&quot;lastModified&quot;) ? DateTimeUtils.getDateCalendar(noteJson.geðŸ”µ</abbr>
 128         note.setTags(noteJson.has(&quot;tags&quot;) ? noteJson.getJSONArray(&quot;tags&quot;) : new JSONArray());
 129         note.setPinned(noteJson.optBoolean(&quot;pinned&quot;, false));
 130         note.setMarkdownEnabled(noteJson.optBoolean(&quot;markdown&quot;, false));
 131 
 132         return note;
 133     }
 134 
 135     @SuppressWarnings(&quot;unused&quot;)
 136     public static String dateString(Number time, boolean useShortFormat, Context context) {
 137         Calendar c = numberToDate(time);
 138         return dateString(c, useShortFormat, context);
 139     }
 140 
 141     public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 142         int year, month, day;
 143 
 144         String time, date, retVal;
 145 
 146         Calendar diff = Calendar.getInstance();
 147         diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 148 
 149         year = diff.get(Calendar.YEAR);
 150         month = diff.get(Calendar.MONTH);
 151         day = diff.get(Calendar.DAY_OF_MONTH);
 152 
 153         diff.setTimeInMillis(0); // starting time
 154         time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 155         if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 155         if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(ðŸ”µ</abbr>
 156             date = context.getResources().getString(R.string.today);
 157             if (useShortFormat)
 158                 retVal = time;
 159             else
 160                 retVal = date + &quot;, &quot; + time;
<abbr title=" 161         } else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {"> 161         } else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)ðŸ”µ</abbr>
 162             date = context.getResources().getString(R.string.yesterday);
 163             if (useShortFormat)
 164                 retVal = date;
 165             else
 166                 retVal = date + &quot;, &quot; + time;
 167         } else {
 168             date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 169             retVal = date + &quot;, &quot; + time;
 170         }
 171 
 172         return retVal;
 173     }
 174 
 175     private static int getReferenceCount(String key, String content) {
 176         Pattern pattern = Pattern.compile(SIMPLENOTE_LINK_PREFIX + key);
 177         Matcher matcher = pattern.matcher(content);
 178         int count = 0;
 179 
 180         while (matcher.find()) {
 181             count++;
 182         }
 183 
 184         return count;
 185     }
 186 
 187     public static List&lt;Reference&gt; getReferences(Bucket&lt;Note&gt; bucket, String key) {
 188         List&lt;Reference&gt; references = new ArrayList&lt;&gt;();
 189         Bucket.ObjectCursor&lt;Note&gt; cursor = Note.search(bucket, SIMPLENOTE_LINK_PREFIX + key).execute();
 190 
 191         while (cursor.moveToNext()) {
 192             Note note = cursor.getObject();
 193             references.add(
 194                 new Reference(
 195                     note.getSimperiumKey(),
 196                     note.getTitle(),
 197                     note.getModificationDate(),
 198                     getReferenceCount(key, note.getContent())
 199                 )
 200             );
 201         }
 202 
 203         return references;
 204     }
 205 
 206     public static Calendar numberToDate(Number time) {
 207         Calendar date = Calendar.getInstance();
 208         if (time != null) {
 209             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 210             // since we only deal with create and modify timestamps, they should all have occurred
 211             // at the present time or in the past.
 212             float now = (float) date.getTimeInMillis() / 1000;
 213             float magnitude = time.floatValue() / now;
 214             if (magnitude &gt;= 2.f) time = time.longValue() / 1000;
 215             date.setTimeInMillis(time.longValue() * 1000);
 216         }
 217         return date;
 218     }
 219 
 220     public static String numberToDateString(@NonNull Number number) {
 221         long milliseconds = new BigDecimal(number.toString()).multiply(new BigDecimal(1000)).longValue();
 222         Calendar calendar = Calendar.getInstance();
 223         calendar.setTimeInMillis(milliseconds);
 224         SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, Locale.US);
 225         date.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));
 226         return date.format(calendar.getTime());
 227     }
 228 
 229     protected void updateTitleAndPreview() {
 230         // try to build a title and preview property out of content
 231         String content = getContent().trim();
 232         if (content.length() &gt; MAX_PREVIEW_CHARS) {
 233             content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 234         }
 235 
 236         int firstNewLinePosition = content.indexOf(NEW_LINE);
 237         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 238             mTitle = content.substring(0, firstNewLinePosition).trim();
 239 
 240             if (firstNewLinePosition &lt; content.length()) {
 241                 mContentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 242                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE + SPACE, SPACE).trim();"> 242                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE + SPACE, SPACE).ðŸ”µ</abbr>
 243             } else {
 244                 mContentPreview = content;
 245             }
 246         } else {
 247             mTitle = content;
 248             mContentPreview = content;
 249         }
 250     }
 251 
 252     public String getTitle() {
 253         if (mTitle == null) {
 254             updateTitleAndPreview();
 255         }
 256         return mTitle;
 257     }
 258 
 259     public String getContent() {
 260         Object content = getProperty(CONTENT_PROPERTY);
 261         if (content == null) {
 262             return BLANK_CONTENT;
 263         }
 264         return (String) content;
 265     }
 266 
 267     public void setContent(String content) {
 268         mTitle = null;
 269         mContentPreview = null;
 270         setProperty(CONTENT_PROPERTY, content);
 271     }
 272 
 273     public String getContentPreview() {
 274         if (mContentPreview == null) {
 275             updateTitleAndPreview();
 276         }
 277         return mContentPreview;
 278     }
 279 
 280     public Calendar getCreationDate() {
 281         return numberToDate((Number) getProperty(CREATION_DATE_PROPERTY));
 282     }
 283 
 284     public String getCreationDateString() {
 285         return numberToDateString((Number) getProperty(CREATION_DATE_PROPERTY));
 286     }
 287 
 288     public void setCreationDate(Calendar creationDate) {
 289         setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis() / 1000);
 290     }
 291 
 292     public Calendar getModificationDate() {
 293         return numberToDate((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 294     }
 295 
 296     public String getModificationDateString() {
 297         return numberToDateString((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 298     }
 299 
 300     public void setModificationDate(Calendar modificationDate) {
 301         setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis() / 1000);
 302     }
 303 
 304     public String getPublishedUrl() {
 305         String urlCode = (String) getProperty(PUBLISH_URL_PROPERTY);
 306         if (TextUtils.isEmpty(urlCode)) {
 307             return &quot;&quot;;
 308         }
 309 
 310         return PUBLISH_URL + urlCode;
 311     }
 312 
 313     public boolean hasTag(String tag) {
 314         List&lt;String&gt; tags = getTags();
 315         String tagLower = tag.toLowerCase();
 316         for (String tagName : tags) {
 317             if (tagLower.equals(tagName.toLowerCase())) return true;
 318         }
 319         return false;
 320     }
 321 
 322     public boolean hasTag(Tag tag) {
 323         return hasTag(tag.getSimperiumKey());
 324     }
 325 
 326     public List&lt;String&gt; getTags() {
 327 
 328         JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 329 
 330         if (tags == null) {
 331             tags = new JSONArray();
 332             setProperty(TAGS_PROPERTY, &quot;&quot;);
 333         }
 334 
 335         int length = tags.length();
 336 
 337         List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);
 338 
 339         if (length == 0) return tagList;
 340 
 341         for (int i = 0; i &lt; length; i++) {
 342             String tag = tags.optString(i);
 343             if (!tag.equals(&quot;&quot;))
 344                 tagList.add(tag);
 345         }
 346 
 347         return tagList;
 348     }
 349 
 350     public void removeTag(String tagName) {
 351         List&lt;String&gt; tags = getTags();
 352 
 353         List&lt;String&gt; tagsMatched = TagUtils.findTagsMatch(tags, tagName);
 354         tags.removeAll(tagsMatched);
 355 
 356         setTags(tags);
 357         save();
 358     }
 359 
 360     public void setTags(List&lt;String&gt; tags) {
 361         setProperty(TAGS_PROPERTY, new JSONArray(tags));
 362     }
 363 
 364     public void setTags(JSONArray tags) {
 365         setProperty(TAGS_PROPERTY, tags);
 366     }
 367 
 368     /**
 369      * String of tags delimited by a space
 370      */
 371     public CharSequence getTagString() {
 372         StringBuilder tagString = new StringBuilder();
 373         List&lt;String&gt; tags = getTags();
 374         for (String tag : tags) {
 375             if (tagString.length() &gt; 0) {
 376                 tagString.append(SPACE);
 377             }
 378             tagString.append(tag);
 379         }
 380         return tagString;
 381     }
 382 
 383     /**
 384      * Sets the note&#x27;s tags by providing it with a {@link String} of space separated tags.
 385      * Filters out duplicate tags.
 386      *
 387      * @param tagString a space delimited list of tags
 388      */
 389     public void setTagString(String tagString) {
 390         List&lt;String&gt; tags = getTags();
 391         tags.clear();
 392 
 393         if (tagString == null) {
 394             setTags(tags);
 395             return;
 396         }
 397 
 398         // Make sure string has a trailing space
 399         if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 400             tagString = tagString + SPACE;
 401         // for comparing case-insensitive strings, would like to find a way to
 402         // do this without allocating a new list and strings
 403         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();
 404         // remove all current tags
 405         int start = 0;
 406         int next;
 407         String possible;
 408         String possibleUpperCase;
 409         // search tag string for space characters and pull out individual tags
 410         do {
 411             next = tagString.indexOf(SPACE, start);
 412             if (next &gt; start) {
 413                 possible = tagString.substring(start, next);
 414                 possibleUpperCase = possible.toUpperCase();
 415                 if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 416                     tagsUpperCase.add(possibleUpperCase);
 417                     tags.add(possible);
 418                 }
 419             }
 420             start = next + 1;
 421         } while (next &gt; -1);
 422         setTags(tags);
 423     }
 424 
 425     public JSONArray getSystemTags() {
 426         JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 427         if (tags == null) {
 428             tags = new JSONArray();
 429             setProperty(SYSTEM_TAGS_PROPERTY, tags);
 430         }
 431         return tags;
 432     }
 433 
 434     public Boolean isDeleted() {
 435         Object deleted = getProperty(DELETED_PROPERTY);
 436         if (deleted == null) {
 437             return false;
 438         }
 439         if (deleted instanceof Boolean) {
 440             return (Boolean) deleted;
 441         } else {
 442             // Simperium-iOS sets booleans as integer values (0 or 1)
 443             return deleted instanceof Number &amp;&amp; ((Number) deleted).intValue() != 0;
 444         }
 445     }
 446 
 447     public void setDeleted(boolean deleted) {
 448         setProperty(DELETED_PROPERTY, deleted);
 449     }
 450 
 451     public boolean isMarkdownEnabled() {
 452         return hasSystemTag(MARKDOWN_TAG);
 453     }
 454 
 455     public void enableMarkdown() {
 456         setMarkdownEnabled(true);
 457     }
 458 
 459     public void setMarkdownEnabled(boolean isMarkdownEnabled) {
 460         if (isMarkdownEnabled) {
 461             addSystemTag(MARKDOWN_TAG);
 462         } else {
 463             removeSystemTag(MARKDOWN_TAG);
 464         }
 465     }
 466 
 467     public boolean isPinned() {
 468         return hasSystemTag(PINNED_TAG);
 469     }
 470 
 471     public void setPinned(boolean isPinned) {
 472         if (isPinned) {
 473             addSystemTag(PINNED_TAG);
 474         } else {
 475             removeSystemTag(PINNED_TAG);
 476         }
 477     }
 478 
 479     public boolean isPreviewEnabled() {
 480         return hasSystemTag(PREVIEW_TAG);
 481     }
 482 
 483     public void setPreviewEnabled(boolean isPreviewEnabled) {
 484         if (isPreviewEnabled) {
 485             addSystemTag(PREVIEW_TAG);
 486         } else {
 487             removeSystemTag(PREVIEW_TAG);
 488         }
 489     }
 490 
 491     public boolean isPublished() {
 492         return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 493     }
 494 
 495     public void setPublished(boolean isPublished) {
 496         if (isPublished) {
 497             addSystemTag(PUBLISHED_TAG);
 498         } else {
 499             removeSystemTag(PUBLISHED_TAG);
 500         }
 501     }
 502 
 503     public void removeTag(String tagName) {
 504         List&lt;String&gt; tags = getTags();
 505 
 506         List&lt;String&gt; tagsMatched = TagUtils.findTagsMatch(tags, tagName);
 507         tags.removeAll(tagsMatched);
 508 
 509         setTags(tags);
 510         save();
 511     }
 512 
 513     private boolean hasSystemTag(String tag) {
 514         if (TextUtils.isEmpty(tag))
 515             return false;
 516 
 517         JSONArray tags = getSystemTags();
 518         int length = tags.length();
 519         for (int i = 0; i &lt; length; i++) {
 520             if (tags.optString(i).equals(tag)) {
 521                 return true;
 522             }
 523         }
 524 
 525         return false;
 526     }
 527 
 528     private void addSystemTag(String tag) {
 529         if (TextUtils.isEmpty(tag)) {
 530             return;
 531         }
 532 
 533         // Ensure we don&#x27;t add the same tag again
 534         if (!hasSystemTag(tag)) {
 535             getSystemTags().put(tag);
 536         }
 537     }
 538 
 539     private void removeSystemTag(String tag) {
 540         if (!hasSystemTag(tag)) {
 541             return;
 542         }
 543 
 544         JSONArray tags = getSystemTags();
 545         JSONArray newTags = new JSONArray();
 546         int length = tags.length();
 547         try {
 548             for (int i = 0; i &lt; length; i++) {
 549                 Object val = tags.get(i);
 550                 if (!val.equals(tag))
 551                     newTags.put(val);
 552             }
 553         } catch (JSONException e) {
 554             // could not update pinned setting
 555         }
 556 
 557         setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 558     }
 559 
 560     /**
 561      * Check if the note has any changes
 562      *
 563      * @param content           the new note content
 564      * @param tagString         space separated tags
 565      * @param isPinned          note is pinned
 566      * @param isMarkdownEnabled note has markdown enabled
 567      * @param isPreviewEnabled  note has preview enabled
 568      * @return true if note has changes, false if it is unchanged.
 569      */
<abbr title=" 570     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 570     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnablðŸ”µ</abbr>
 571         return !content.equals(this.getContent())
 572                 || !tagString.equals(this.getTagString().toString())
 573                 || this.isPinned() != isPinned
 574                 || this.isMarkdownEnabled() != isMarkdownEnabled
 575                 || this.isPreviewEnabled() != isPreviewEnabled;
 576     }
 577 
 578     public static class Schema extends BucketSchema&lt;Note&gt; {
 579 
 580         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
 581         protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
 582 
 583         public Schema() {
 584             autoIndex();
 585             addIndex(sNoteIndexer);
 586             setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
 587             setDefault(CONTENT_PROPERTY, &quot;&quot;);
 588             setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
 589             setDefault(TAGS_PROPERTY, new JSONArray());
 590             setDefault(DELETED_PROPERTY, false);
 591             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
 592             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
 593         }
 594 
 595         public String getRemoteName() {
 596             return Note.BUCKET_NAME;
 597         }
 598 
 599         public Note build(String key, JSONObject properties) {
 600             return new Note(key, properties);
 601         }
 602 
 603         public void update(Note note, JSONObject properties) {
 604             note.setProperties(properties);
 605             note.mTitle = null;
 606             note.mContentPreview = null;
 607         }
 608     }
 609 }</pre></td>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import android.content.Context;
   4 import android.text.TextUtils;
   5 
   6 import androidx.annotation.NonNull;
   7 
   8 import com.automattic.simplenote.R;
   9 import com.automattic.simplenote.utils.DateTimeUtils;
  10 import com.automattic.simplenote.utils.TagUtils;
  11 import com.simperium.client.Bucket;
  12 import com.simperium.client.BucketObject;
  13 import com.simperium.client.BucketSchema;
  14 import com.simperium.client.Query;
  15 import com.simperium.client.Query.ComparisonType;
  16 import com.simperium.util.Uuid;
  17 
  18 import org.json.JSONArray;
  19 import org.json.JSONException;
  20 import org.json.JSONObject;
  21 
  22 import java.math.BigDecimal;
  23 import java.text.DateFormat;
  24 import java.text.ParseException;
  25 import java.text.SimpleDateFormat;
  26 import java.util.ArrayList;
  27 import java.util.Calendar;
  28 import java.util.List;
  29 import java.util.Locale;
  30 import java.util.TimeZone;
  31 import java.util.regex.Matcher;
  32 import java.util.regex.Pattern;
  33 
  34 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  35 
  36 public class Note extends BucketObject {
  37 
  38     public static final String BUCKET_NAME = &quot;note&quot;;
  39     public static final String MARKDOWN_TAG = &quot;markdown&quot;;
  40     public static final String PINNED_TAG = &quot;pinned&quot;;
  41     public static final String PREVIEW_TAG = &quot;preview&quot;;
  42     public static final String PUBLISHED_TAG = &quot;published&quot;;
  43     public static final String NEW_LINE = &quot;\n&quot;;
  44     public static final String CONTENT_PROPERTY = &quot;content&quot;;
  45     public static final String KEY_PROPERTY = &quot;key&quot;;
  46     public static final String TAGS_PROPERTY = &quot;tags&quot;;
  47     public static final String SYSTEM_TAGS_PROPERTY = &quot;systemTags&quot;;
  48     public static final String CREATION_DATE_PROPERTY = &quot;creationDate&quot;;
  49     public static final String MODIFICATION_DATE_PROPERTY = &quot;modificationDate&quot;;
  50     public static final String SHARE_URL_PROPERTY = &quot;shareURL&quot;;
  51     public static final String PUBLISH_URL_PROPERTY = &quot;publishURL&quot;;
  52     public static final String DELETED_PROPERTY = &quot;deleted&quot;;
  53     public static final String TITLE_INDEX_NAME = &quot;title&quot;;
  54     public static final String CONTENT_PREVIEW_INDEX_NAME = &quot;contentPreview&quot;;
  55     public static final String PINNED_INDEX_NAME = &quot;pinned&quot;;
  56     public static final String MODIFIED_INDEX_NAME = &quot;modified&quot;;
  57     public static final String CREATED_INDEX_NAME = &quot;created&quot;;
  58     public static final String MATCHED_TITLE_INDEX_NAME = &quot;matchedTitle&quot;;
  59     public static final String MATCHED_CONTENT_INDEX_NAME = &quot;matchedContent&quot;;
  60     public static final String PUBLISH_URL = &quot;http://simp.ly/p/&quot;;
  61     static public final String[] FULL_TEXT_INDEXES = new String[]{
  62             Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY};
  63     private static final String BLANK_CONTENT = &quot;&quot;;
  64     private static final String SPACE = &quot; &quot;;
  65     private static final int MAX_PREVIEW_CHARS = 300;
  66     protected String mTitle = null;
  67     protected String mContentPreview = null;
  68 
  69     public Note() {
  70         this(Uuid.uuid());
  71     }
  72 
  73     public Note(String key) {
  74         this(key, new JSONObject());
  75     }
  76 
  77     public Note(String key, JSONObject properties) {
  78         super(key, properties);
  79     }
  80 
  81     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket) {
  82         return noteBucket.query()
  83                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  84     }
  85 
  86     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket) {
  87         return noteBucket.query()
  88                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
  89     }
  90 
  91     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString) {
  92         return noteBucket.query()
  93                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
  94                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
  95     }
  96 
  97     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag) {
  98         return noteBucket.query()
  99                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 100                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 101     }
 102 
 103     public static Query&lt;Note&gt; allWithNoTag(Bucket&lt;Note&gt; noteBucket) {
 104         return noteBucket.query()
 105                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 106                 .where(TAGS_PROPERTY, ComparisonType.EQUAL_TO, null);
 107     }
 108 
 109     public static Note fromContent(Bucket&lt;Note&gt; notesBucket, String content) {
 110         Note note = notesBucket.newObject();
 111         note.setContent(content);
 112         note.setCreationDate(Calendar.getInstance());
 113         note.setModificationDate(note.getCreationDate());
 114 
 115         return note;
 116     }
 117 
<abbr title=" 118     public static Note fromExportedJson(Bucket&lt;Note&gt; notesBucket, JSONObject noteJson) throws JSONException, ParseException {"> 118     public static Note fromExportedJson(Bucket&lt;Note&gt; notesBucket, JSONObject noteJson) throws JSONExceptiðŸ”µ</abbr>
 119         Note note = notesBucket.newObject();
 120         note.setContent(noteJson.optString(&quot;content&quot;, &quot;&quot;));
<abbr title=" 121         note.setCreationDate(noteJson.has(&quot;creationDate&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;creationDate&quot;)) : Calendar.getInstance());"> 121         note.setCreationDate(noteJson.has(&quot;creationDate&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getStrðŸ”µ</abbr>
<abbr title=" 122         note.setModificationDate(noteJson.has(&quot;lastModified&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;lastModified&quot;)) : Calendar.getInstance());"> 122         note.setModificationDate(noteJson.has(&quot;lastModified&quot;) ? DateTimeUtils.getDateCalendar(noteJson.geðŸ”µ</abbr>
 123         note.setTags(noteJson.has(&quot;tags&quot;) ? noteJson.getJSONArray(&quot;tags&quot;) : new JSONArray());
 124         note.setPinned(noteJson.optBoolean(&quot;pinned&quot;, false));
 125         note.setMarkdownEnabled(noteJson.optBoolean(&quot;markdown&quot;, false));
 126 
 127         return note;
 128     }
 129 
 130     @SuppressWarnings(&quot;unused&quot;)
 131     public static String dateString(Number time, boolean useShortFormat, Context context) {
 132         Calendar c = numberToDate(time);
 133         return dateString(c, useShortFormat, context);
 134     }
 135 
 136     public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 137         int year, month, day;
 138 
 139         String time, date, retVal;
 140 
 141         Calendar diff = Calendar.getInstance();
 142         diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 143 
 144         year = diff.get(Calendar.YEAR);
 145         month = diff.get(Calendar.MONTH);
 146         day = diff.get(Calendar.DAY_OF_MONTH);
 147 
 148         diff.setTimeInMillis(0); // starting time
 149         time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 150         if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 150         if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(ðŸ”µ</abbr>
 151             date = context.getResources().getString(R.string.today);
 152             if (useShortFormat)
 153                 retVal = time;
 154             else
 155                 retVal = date + &quot;, &quot; + time;
<abbr title=" 156         } else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {"> 156         } else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)ðŸ”µ</abbr>
 157             date = context.getResources().getString(R.string.yesterday);
 158             if (useShortFormat)
 159                 retVal = date;
 160             else
 161                 retVal = date + &quot;, &quot; + time;
 162         } else {
 163             date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 164             retVal = date + &quot;, &quot; + time;
 165         }
 166 
 167         return retVal;
 168     }
 169 
 170     private static int getReferenceCount(String key, String content) {
 171         Pattern pattern = Pattern.compile(SIMPLENOTE_LINK_PREFIX + key);
 172         Matcher matcher = pattern.matcher(content);
 173         int count = 0;
 174 
 175         while (matcher.find()) {
 176             count++;
 177         }
 178 
 179         return count;
 180     }
 181 
 182     public static List&lt;Reference&gt; getReferences(Bucket&lt;Note&gt; bucket, String key) {
 183         List&lt;Reference&gt; references = new ArrayList&lt;&gt;();
 184         Bucket.ObjectCursor&lt;Note&gt; cursor = Note.search(bucket, SIMPLENOTE_LINK_PREFIX + key).execute();
 185 
 186         while (cursor.moveToNext()) {
 187             Note note = cursor.getObject();
 188             references.add(
 189                 new Reference(
 190                     note.getSimperiumKey(),
 191                     note.getTitle(),
 192                     note.getModificationDate(),
 193                     getReferenceCount(key, note.getContent())
 194                 )
 195             );
 196         }
 197 
 198         return references;
 199     }
 200 
 201     public static Calendar numberToDate(Number time) {
 202         Calendar date = Calendar.getInstance();
 203         if (time != null) {
 204             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 205             // since we only deal with create and modify timestamps, they should all have occurred
 206             // at the present time or in the past.
 207             float now = (float) date.getTimeInMillis() / 1000;
 208             float magnitude = time.floatValue() / now;
 209             if (magnitude &gt;= 2.f) time = time.longValue() / 1000;
 210             date.setTimeInMillis(time.longValue() * 1000);
 211         }
 212         return date;
 213     }
 214 
 215     public static String numberToDateString(@NonNull Number number) {
 216         long milliseconds = new BigDecimal(number.toString()).multiply(new BigDecimal(1000)).longValue();
 217         Calendar calendar = Calendar.getInstance();
 218         calendar.setTimeInMillis(milliseconds);
 219         SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, Locale.US);
 220         date.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));
 221         return date.format(calendar.getTime());
 222     }
 223 
 224     protected void updateTitleAndPreview() {
 225         // try to build a title and preview property out of content
 226         String content = getContent().trim();
 227         if (content.length() &gt; MAX_PREVIEW_CHARS) {
 228             content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 229         }
 230 
 231         int firstNewLinePosition = content.indexOf(NEW_LINE);
 232         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 233             mTitle = content.substring(0, firstNewLinePosition).trim();
 234 
 235             if (firstNewLinePosition &lt; content.length()) {
 236                 mContentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 237                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE + SPACE, SPACE).trim();"> 237                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE + SPACE, SPACE).ðŸ”µ</abbr>
 238             } else {
 239                 mContentPreview = content;
 240             }
 241         } else {
 242             mTitle = content;
 243             mContentPreview = content;
 244         }
 245     }
 246 
 247     public String getTitle() {
 248         if (mTitle == null) {
 249             updateTitleAndPreview();
 250         }
 251         return mTitle;
 252     }
 253 
 254     public String getContent() {
 255         Object content = getProperty(CONTENT_PROPERTY);
 256         if (content == null) {
 257             return BLANK_CONTENT;
 258         }
 259         return (String) content;
 260     }
 261 
 262     public void setContent(String content) {
 263         mTitle = null;
 264         mContentPreview = null;
 265         setProperty(CONTENT_PROPERTY, content);
 266     }
 267 
 268     public String getContentPreview() {
 269         if (mContentPreview == null) {
 270             updateTitleAndPreview();
 271         }
 272         return mContentPreview;
 273     }
 274 
 275     public Calendar getCreationDate() {
 276         return numberToDate((Number) getProperty(CREATION_DATE_PROPERTY));
 277     }
 278 
 279     public String getCreationDateString() {
 280         return numberToDateString((Number) getProperty(CREATION_DATE_PROPERTY));
 281     }
 282 
 283     public void setCreationDate(Calendar creationDate) {
 284         setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis() / 1000);
 285     }
 286 
 287     public Calendar getModificationDate() {
 288         return numberToDate((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 289     }
 290 
 291     public String getModificationDateString() {
 292         return numberToDateString((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 293     }
 294 
 295     public void setModificationDate(Calendar modificationDate) {
 296         setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis() / 1000);
 297     }
 298 
 299     public String getPublishedUrl() {
 300         String urlCode = (String) getProperty(PUBLISH_URL_PROPERTY);
 301         if (TextUtils.isEmpty(urlCode)) {
 302             return &quot;&quot;;
 303         }
 304 
 305         return PUBLISH_URL + urlCode;
 306     }
 307 
 308     public boolean hasTag(String tag) {
 309         List&lt;String&gt; tags = getTags();
 310         String tagLower = tag.toLowerCase();
 311         for (String tagName : tags) {
 312             if (tagLower.equals(tagName.toLowerCase())) return true;
 313         }
 314         return false;
 315     }
 316 
 317     public boolean hasTag(Tag tag) {
 318         return hasTag(tag.getSimperiumKey());
 319     }
 320 
 321     public List&lt;String&gt; getTags() {
 322 
 323         JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 324 
 325         if (tags == null) {
 326             tags = new JSONArray();
 327             setProperty(TAGS_PROPERTY, &quot;&quot;);
 328         }
 329 
 330         int length = tags.length();
 331 
 332         List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);
 333 
 334         if (length == 0) return tagList;
 335 
 336         for (int i = 0; i &lt; length; i++) {
 337             String tag = tags.optString(i);
 338             if (!tag.equals(&quot;&quot;))
 339                 tagList.add(tag);
 340         }
 341 
 342         return tagList;
 343     }
 344 
 345     public void setTags(List&lt;String&gt; tags) {
 346         setProperty(TAGS_PROPERTY, new JSONArray(tags));
 347     }
 348 
 349     public void setTags(JSONArray tags) {
 350         setProperty(TAGS_PROPERTY, tags);
 351     }
 352 
 353     /**
 354      * String of tags delimited by a space
 355      */
 356     public CharSequence getTagString() {
 357         StringBuilder tagString = new StringBuilder();
 358         List&lt;String&gt; tags = getTags();
 359         for (String tag : tags) {
 360             if (tagString.length() &gt; 0) {
 361                 tagString.append(SPACE);
 362             }
 363             tagString.append(tag);
 364         }
 365         return tagString;
 366     }
 367 
 368     /**
 369      * Sets the note&#x27;s tags by providing it with a {@link String} of space separated tags.
 370      * Filters out duplicate tags.
 371      *
 372      * @param tagString a space delimited list of tags
 373      */
 374     public void setTagString(String tagString) {
 375         List&lt;String&gt; tags = getTags();
 376         tags.clear();
 377 
 378         if (tagString == null) {
 379             setTags(tags);
 380             return;
 381         }
 382 
 383         // Make sure string has a trailing space
 384         if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 385             tagString = tagString + SPACE;
 386         // for comparing case-insensitive strings, would like to find a way to
 387         // do this without allocating a new list and strings
 388         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();
 389         // remove all current tags
 390         int start = 0;
 391         int next;
 392         String possible;
 393         String possibleUpperCase;
 394         // search tag string for space characters and pull out individual tags
 395         do {
 396             next = tagString.indexOf(SPACE, start);
 397             if (next &gt; start) {
 398                 possible = tagString.substring(start, next);
 399                 possibleUpperCase = possible.toUpperCase();
 400                 if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 401                     tagsUpperCase.add(possibleUpperCase);
 402                     tags.add(possible);
 403                 }
 404             }
 405             start = next + 1;
 406         } while (next &gt; -1);
 407         setTags(tags);
 408     }
 409 
 410     public JSONArray getSystemTags() {
 411         JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 412         if (tags == null) {
 413             tags = new JSONArray();
 414             setProperty(SYSTEM_TAGS_PROPERTY, tags);
 415         }
 416         return tags;
 417     }
 418 
 419     public Boolean isDeleted() {
 420         Object deleted = getProperty(DELETED_PROPERTY);
 421         if (deleted == null) {
 422             return false;
 423         }
 424         if (deleted instanceof Boolean) {
 425             return (Boolean) deleted;
 426         } else {
 427             // Simperium-iOS sets booleans as integer values (0 or 1)
 428             return deleted instanceof Number &amp;&amp; ((Number) deleted).intValue() != 0;
 429         }
 430     }
 431 
 432     public void setDeleted(boolean deleted) {
 433         setProperty(DELETED_PROPERTY, deleted);
 434     }
 435 
 436     public boolean isMarkdownEnabled() {
 437         return hasSystemTag(MARKDOWN_TAG);
 438     }
 439 
 440     public void enableMarkdown() {
 441         setMarkdownEnabled(true);
 442     }
 443 
 444     public void setMarkdownEnabled(boolean isMarkdownEnabled) {
 445         if (isMarkdownEnabled) {
 446             addSystemTag(MARKDOWN_TAG);
 447         } else {
 448             removeSystemTag(MARKDOWN_TAG);
 449         }
 450     }
 451 
 452     public boolean isPinned() {
 453         return hasSystemTag(PINNED_TAG);
 454     }
 455 
 456     public void setPinned(boolean isPinned) {
 457         if (isPinned) {
 458             addSystemTag(PINNED_TAG);
 459         } else {
 460             removeSystemTag(PINNED_TAG);
 461         }
 462     }
 463 
 464     public boolean isPreviewEnabled() {
 465         return hasSystemTag(PREVIEW_TAG);
 466     }
 467 
 468     public void setPreviewEnabled(boolean isPreviewEnabled) {
 469         if (isPreviewEnabled) {
 470             addSystemTag(PREVIEW_TAG);
 471         } else {
 472             removeSystemTag(PREVIEW_TAG);
 473         }
 474     }
 475 
 476     public boolean isPublished() {
 477         return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 478     }
 479 
 480     public void setPublished(boolean isPublished) {
 481         if (isPublished) {
 482             addSystemTag(PUBLISHED_TAG);
 483         } else {
 484             removeSystemTag(PUBLISHED_TAG);
 485         }
 486     }
 487 
 488     public void removeTag(String tagName) {
 489         List&lt;String&gt; tags = getTags();
 490 
 491         List&lt;String&gt; tagsMatched = TagUtils.findTagsMatch(tags, tagName);
 492         tags.removeAll(tagsMatched);
 493 
 494         setTags(tags);
 495         save();
 496     }
 497 
 498     private boolean hasSystemTag(String tag) {
 499         if (TextUtils.isEmpty(tag))
 500             return false;
 501 
 502         JSONArray tags = getSystemTags();
 503         int length = tags.length();
 504         for (int i = 0; i &lt; length; i++) {
 505             if (tags.optString(i).equals(tag)) {
 506                 return true;
 507             }
 508         }
 509 
 510         return false;
 511     }
 512 
 513     private void addSystemTag(String tag) {
 514         if (TextUtils.isEmpty(tag)) {
 515             return;
 516         }
 517 
 518         // Ensure we don&#x27;t add the same tag again
 519         if (!hasSystemTag(tag)) {
 520             getSystemTags().put(tag);
 521         }
 522     }
 523 
 524     private void removeSystemTag(String tag) {
 525         if (!hasSystemTag(tag)) {
 526             return;
 527         }
 528 
 529         JSONArray tags = getSystemTags();
 530         JSONArray newTags = new JSONArray();
 531         int length = tags.length();
 532         try {
 533             for (int i = 0; i &lt; length; i++) {
 534                 Object val = tags.get(i);
 535                 if (!val.equals(tag))
 536                     newTags.put(val);
 537             }
 538         } catch (JSONException e) {
 539             // could not update pinned setting
 540         }
 541 
 542         setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 543     }
 544 
 545     /**
 546      * Check if the note has any changes
 547      *
 548      * @param content           the new note content
 549      * @param tagString         space separated tags
 550      * @param isPinned          note is pinned
 551      * @param isMarkdownEnabled note has markdown enabled
 552      * @param isPreviewEnabled  note has preview enabled
 553      * @return true if note has changes, false if it is unchanged.
 554      */
<abbr title=" 555     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 555     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnablðŸ”µ</abbr>
 556         return !content.equals(this.getContent())
 557                 || !tagString.equals(this.getTagString().toString())
 558                 || this.isPinned() != isPinned
 559                 || this.isMarkdownEnabled() != isMarkdownEnabled
 560                 || this.isPreviewEnabled() != isPreviewEnabled;
 561     }
 562 
 563     public static class Schema extends BucketSchema&lt;Note&gt; {
 564 
 565         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
 566         protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
 567 
 568         public Schema() {
 569             autoIndex();
 570             addIndex(sNoteIndexer);
 571             setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
 572             setDefault(CONTENT_PROPERTY, &quot;&quot;);
 573             setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
 574             setDefault(TAGS_PROPERTY, new JSONArray());
 575             setDefault(DELETED_PROPERTY, false);
 576             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
 577             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
 578         }
 579 
 580         public String getRemoteName() {
 581             return Note.BUCKET_NAME;
 582         }
 583 
 584         public Note build(String key, JSONObject properties) {
 585             return new Note(key, properties);
 586         }
 587 
 588         public void update(Note note, JSONObject properties) {
 589             note.setProperties(properties);
 590             note.mTitle = null;
 591             note.mContentPreview = null;
 592         }
 593     }
 594 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import android.content.Context;
   4 import android.text.TextUtils;
   5 import androidx.annotation.NonNull;
   6 import com.automattic.simplenote.R;
   7 import com.automattic.simplenote.utils.DateTimeUtils;
   8 import com.automattic.simplenote.utils.TagUtils;
   9 import com.simperium.client.Bucket;
  10 import com.simperium.client.BucketObject;
  11 import com.simperium.client.BucketSchema;
  12 import com.simperium.client.Query.ComparisonType;
  13 import com.simperium.client.Query;
  14 import com.simperium.util.Uuid;
  15 import java.math.BigDecimal;
  16 import java.text.DateFormat;
  17 import java.text.ParseException;
  18 import java.text.SimpleDateFormat;
  19 import java.util.ArrayList;
  20 import java.util.Calendar;
  21 import java.util.List;
  22 import java.util.Locale;
  23 import java.util.TimeZone;
  24 import java.util.regex.Matcher;
  25 import java.util.regex.Pattern;
  26 import org.json.JSONArray;
  27 import org.json.JSONException;
  28 import org.json.JSONObject;
  29 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  30 
  31 
  32 public class Note extends BucketObject {
  33 
  34     public static final String BUCKET_NAME = &quot;note&quot;;
  35     public static final String MARKDOWN_TAG = &quot;markdown&quot;;
  36     public static final String PINNED_TAG = &quot;pinned&quot;;
  37     public static final String PREVIEW_TAG = &quot;preview&quot;;
  38     public static final String PUBLISHED_TAG = &quot;published&quot;;
  39     public static final String NEW_LINE = &quot;\n&quot;;
  40     public static final String CONTENT_PROPERTY = &quot;content&quot;;
  41     public static final String KEY_PROPERTY = &quot;key&quot;;
  42     public static final String TAGS_PROPERTY = &quot;tags&quot;;
  43     public static final String SYSTEM_TAGS_PROPERTY = &quot;systemTags&quot;;
  44     public static final String CREATION_DATE_PROPERTY = &quot;creationDate&quot;;
  45     public static final String MODIFICATION_DATE_PROPERTY = &quot;modificationDate&quot;;
  46     public static final String SHARE_URL_PROPERTY = &quot;shareURL&quot;;
  47     public static final String PUBLISH_URL_PROPERTY = &quot;publishURL&quot;;
  48     public static final String DELETED_PROPERTY = &quot;deleted&quot;;
  49     public static final String TITLE_INDEX_NAME = &quot;title&quot;;
  50     public static final String CONTENT_PREVIEW_INDEX_NAME = &quot;contentPreview&quot;;
  51     public static final String PINNED_INDEX_NAME = &quot;pinned&quot;;
  52     public static final String MODIFIED_INDEX_NAME = &quot;modified&quot;;
  53     public static final String CREATED_INDEX_NAME = &quot;created&quot;;
  54     public static final String MATCHED_TITLE_INDEX_NAME = &quot;matchedTitle&quot;;
  55     public static final String MATCHED_CONTENT_INDEX_NAME = &quot;matchedContent&quot;;
  56     public static final String PUBLISH_URL = &quot;http://simp.ly/p/&quot;;
  57     static public final String[] FULL_TEXT_INDEXES = new String[]{
  58             Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY};
  59     private static final String BLANK_CONTENT = &quot;&quot;;
  60     private static final String SPACE = &quot; &quot;;
  61     private static final int MAX_PREVIEW_CHARS = 300;
  62     protected String mTitle = null;
  63     protected String mContentPreview = null;
  64 
  65     public Note() {
  66         this(Uuid.uuid());
  67     }
  68 
  69     public Note(String key) {
  70         this(key, new JSONObject());
  71     }
  72 
  73     public Note(String key, JSONObject properties) {
  74         super(key, properties);
  75     }
  76 
  77     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket) {
  78         return noteBucket.query()
  79                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  80     }
  81 
  82     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket) {
  83         return noteBucket.query()
  84                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
  85     }
  86 
  87     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString) {
  88         return noteBucket.query()
  89                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
  90                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
  91     }
  92 
  93     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag) {
  94         return noteBucket.query()
  95                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
  96                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
  97     }
  98 
  99     public static Query&lt;Note&gt; allWithNoTag(Bucket&lt;Note&gt; noteBucket) {
 100         return noteBucket.query()
 101                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 102                 .where(TAGS_PROPERTY, ComparisonType.EQUAL_TO, null);
 103     }
 104 
 105     public static Note fromContent(Bucket&lt;Note&gt; notesBucket, String content) {
 106         Note note = notesBucket.newObject();
 107         note.setContent(content);
 108         note.setCreationDate(Calendar.getInstance());
 109         note.setModificationDate(note.getCreationDate());
 110 
 111         return note;
 112     }
 113 
<abbr title=" 114     public static Note fromExportedJson(Bucket&lt;Note&gt; notesBucket, JSONObject noteJson) throws JSONException, ParseException {"> 114     public static Note fromExportedJson(Bucket&lt;Note&gt; notesBucket, JSONObject noteJson) throws JSONExceptiðŸ”µ</abbr>
 115         Note note = notesBucket.newObject();
 116         note.setContent(noteJson.optString(&quot;content&quot;, &quot;&quot;));
<abbr title=" 117         note.setCreationDate(noteJson.has(&quot;creationDate&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;creationDate&quot;)) : Calendar.getInstance());"> 117         note.setCreationDate(noteJson.has(&quot;creationDate&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getStrðŸ”µ</abbr>
<abbr title=" 118         note.setModificationDate(noteJson.has(&quot;lastModified&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;lastModified&quot;)) : Calendar.getInstance());"> 118         note.setModificationDate(noteJson.has(&quot;lastModified&quot;) ? DateTimeUtils.getDateCalendar(noteJson.geðŸ”µ</abbr>
 119         note.setTags(noteJson.has(&quot;tags&quot;) ? noteJson.getJSONArray(&quot;tags&quot;) : new JSONArray());
 120         note.setPinned(noteJson.optBoolean(&quot;pinned&quot;, false));
 121         note.setMarkdownEnabled(noteJson.optBoolean(&quot;markdown&quot;, false));
 122 
 123         return note;
 124     }
 125 
 126     @SuppressWarnings(&quot;unused&quot;)
 127     public static String dateString(Number time, boolean useShortFormat, Context context) {
 128         Calendar c = numberToDate(time);
 129         return dateString(c, useShortFormat, context);
 130     }
 131 
 132     public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 133         int year, month, day;
 134 
 135         String time, date, retVal;
 136 
 137         Calendar diff = Calendar.getInstance();
 138         diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 139 
 140         year = diff.get(Calendar.YEAR);
 141         month = diff.get(Calendar.MONTH);
 142         day = diff.get(Calendar.DAY_OF_MONTH);
 143 
 144         diff.setTimeInMillis(0); // starting time
 145         time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 146         if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 146         if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(ðŸ”µ</abbr>
 147             date = context.getResources().getString(R.string.today);
 148             if (useShortFormat)
 149                 retVal = time;
 150             else
 151                 retVal = date + &quot;, &quot; + time;
<abbr title=" 152         } else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {"> 152         } else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)ðŸ”µ</abbr>
 153             date = context.getResources().getString(R.string.yesterday);
 154             if (useShortFormat)
 155                 retVal = date;
 156             else
 157                 retVal = date + &quot;, &quot; + time;
 158         } else {
 159             date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 160             retVal = date + &quot;, &quot; + time;
 161         }
 162 
 163         return retVal;
 164     }
 165 
 166     private static int getReferenceCount(String key, String content) {
 167         Pattern pattern = Pattern.compile(SIMPLENOTE_LINK_PREFIX + key);
 168         Matcher matcher = pattern.matcher(content);
 169         int count = 0;
 170 
 171         while (matcher.find()) {
 172             count++;
 173         }
 174 
 175         return count;
 176     }
 177 
 178     public static List&lt;Reference&gt; getReferences(Bucket&lt;Note&gt; bucket, String key) {
 179         List&lt;Reference&gt; references = new ArrayList&lt;&gt;();
 180         Bucket.ObjectCursor&lt;Note&gt; cursor = Note.search(bucket, SIMPLENOTE_LINK_PREFIX + key).execute();
 181 
 182         while (cursor.moveToNext()) {
 183             Note note = cursor.getObject();
 184             references.add(
 185                 new Reference(
 186                     note.getSimperiumKey(),
 187                     note.getTitle(),
 188                     note.getModificationDate(),
 189                     getReferenceCount(key, note.getContent())
 190                 )
 191             );
 192         }
 193 
 194         return references;
 195     }
 196 
 197     public static Calendar numberToDate(Number time) {
 198         Calendar date = Calendar.getInstance();
 199         if (time != null) {
 200             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 201             // since we only deal with create and modify timestamps, they should all have occurred
 202             // at the present time or in the past.
 203             float now = (float) date.getTimeInMillis() / 1000;
 204             float magnitude = time.floatValue() / now;
 205             if (magnitude &gt;= 2.f) time = time.longValue() / 1000;
 206             date.setTimeInMillis(time.longValue() * 1000);
 207         }
 208         return date;
 209     }
 210 
 211     public static String numberToDateString(@NonNull Number number) {
 212         long milliseconds = new BigDecimal(number.toString()).multiply(new BigDecimal(1000)).longValue();
 213         Calendar calendar = Calendar.getInstance();
 214         calendar.setTimeInMillis(milliseconds);
 215         SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, Locale.US);
 216         date.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));
 217         return date.format(calendar.getTime());
 218     }
 219 
 220     protected void updateTitleAndPreview() {
 221         // try to build a title and preview property out of content
 222         String content = getContent().trim();
 223         if (content.length() &gt; MAX_PREVIEW_CHARS) {
 224             content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 225         }
 226 
 227         int firstNewLinePosition = content.indexOf(NEW_LINE);
 228         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 229             mTitle = content.substring(0, firstNewLinePosition).trim();
 230 
 231             if (firstNewLinePosition &lt; content.length()) {
 232                 mContentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 233                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE + SPACE, SPACE).trim();"> 233                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE + SPACE, SPACE).ðŸ”µ</abbr>
 234             } else {
 235                 mContentPreview = content;
 236             }
 237         } else {
 238             mTitle = content;
 239             mContentPreview = content;
 240         }
 241     }
 242 
 243     public String getTitle() {
 244         if (mTitle == null) {
 245             updateTitleAndPreview();
 246         }
 247         return mTitle;
 248     }
 249 
 250     public String getContent() {
 251         Object content = getProperty(CONTENT_PROPERTY);
 252         if (content == null) {
 253             return BLANK_CONTENT;
 254         }
 255         return (String) content;
 256     }
 257 
 258     public void setContent(String content) {
 259         mTitle = null;
 260         mContentPreview = null;
 261         setProperty(CONTENT_PROPERTY, content);
 262     }
 263 
 264     public String getContentPreview() {
 265         if (mContentPreview == null) {
 266             updateTitleAndPreview();
 267         }
 268         return mContentPreview;
 269     }
 270 
 271     public Calendar getCreationDate() {
 272         return numberToDate((Number) getProperty(CREATION_DATE_PROPERTY));
 273     }
 274 
 275     public String getCreationDateString() {
 276         return numberToDateString((Number) getProperty(CREATION_DATE_PROPERTY));
 277     }
 278 
 279     public void setCreationDate(Calendar creationDate) {
 280         setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis() / 1000);
 281     }
 282 
 283     public Calendar getModificationDate() {
 284         return numberToDate((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 285     }
 286 
 287     public String getModificationDateString() {
 288         return numberToDateString((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 289     }
 290 
 291     public void setModificationDate(Calendar modificationDate) {
 292         setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis() / 1000);
 293     }
 294 
 295     public String getPublishedUrl() {
 296         String urlCode = (String) getProperty(PUBLISH_URL_PROPERTY);
 297         if (TextUtils.isEmpty(urlCode)) {
 298             return &quot;&quot;;
 299         }
 300 
 301         return PUBLISH_URL + urlCode;
 302     }
 303 
 304     public boolean hasTag(String tag) {
 305         List&lt;String&gt; tags = getTags();
 306         String tagLower = tag.toLowerCase();
 307         for (String tagName : tags) {
 308             if (tagLower.equals(tagName.toLowerCase())) return true;
 309         }
 310         return false;
 311     }
 312 
 313     public boolean hasTag(Tag tag) {
 314         return hasTag(tag.getSimperiumKey());
 315     }
 316 
 317     public List&lt;String&gt; getTags() {
 318 
 319         JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 320 
 321         if (tags == null) {
 322             tags = new JSONArray();
 323             setProperty(TAGS_PROPERTY, &quot;&quot;);
 324         }
 325 
 326         int length = tags.length();
 327 
 328         List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);
 329 
 330         if (length == 0) return tagList;
 331 
 332         for (int i = 0; i &lt; length; i++) {
 333             String tag = tags.optString(i);
 334             if (!tag.equals(&quot;&quot;))
 335                 tagList.add(tag);
 336         }
 337 
 338         return tagList;
 339     }
 340 
 341     public void removeTag(String tagName) {
 342         List&lt;String&gt; tags = getTags();
 343 
 344         List&lt;String&gt; tagsMatched = TagUtils.findTagsMatch(tags, tagName);
 345         tags.removeAll(tagsMatched);
 346 
 347         setTags(tags);
 348         save();
 349     }
 350 
 351     public void setTags(List&lt;String&gt; tags) {
 352         setProperty(TAGS_PROPERTY, new JSONArray(tags));
 353     }
 354 
 355     public void setTags(JSONArray tags) {
 356         setProperty(TAGS_PROPERTY, tags);
 357     }
 358 
 359     /**
 360      * String of tags delimited by a space
 361      */
 362     public CharSequence getTagString() {
 363         StringBuilder tagString = new StringBuilder();
 364         List&lt;String&gt; tags = getTags();
 365         for (String tag : tags) {
 366             if (tagString.length() &gt; 0) {
 367                 tagString.append(SPACE);
 368             }
 369             tagString.append(tag);
 370         }
 371         return tagString;
 372     }
 373 
 374     /**
 375      * Sets the note&#x27;s tags by providing it with a {@link String} of space separated tags.
 376      * Filters out duplicate tags.
 377      *
 378      * @param tagString a space delimited list of tags
 379      */
 380     public void setTagString(String tagString) {
 381         List&lt;String&gt; tags = getTags();
 382         tags.clear();
 383 
 384         if (tagString == null) {
 385             setTags(tags);
 386             return;
 387         }
 388 
 389         // Make sure string has a trailing space
 390         if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 391             tagString = tagString + SPACE;
 392         // for comparing case-insensitive strings, would like to find a way to
 393         // do this without allocating a new list and strings
 394         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();
 395         // remove all current tags
 396         int start = 0;
 397         int next;
 398         String possible;
 399         String possibleUpperCase;
 400         // search tag string for space characters and pull out individual tags
 401         do {
 402             next = tagString.indexOf(SPACE, start);
 403             if (next &gt; start) {
 404                 possible = tagString.substring(start, next);
 405                 possibleUpperCase = possible.toUpperCase();
 406                 if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 407                     tagsUpperCase.add(possibleUpperCase);
 408                     tags.add(possible);
 409                 }
 410             }
 411             start = next + 1;
 412         } while (next &gt; -1);
 413         setTags(tags);
 414     }
 415 
 416     public JSONArray getSystemTags() {
 417         JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 418         if (tags == null) {
 419             tags = new JSONArray();
 420             setProperty(SYSTEM_TAGS_PROPERTY, tags);
 421         }
 422         return tags;
 423     }
 424 
 425     public Boolean isDeleted() {
 426         Object deleted = getProperty(DELETED_PROPERTY);
 427         if (deleted == null) {
 428             return false;
 429         }
 430         if (deleted instanceof Boolean) {
 431             return (Boolean) deleted;
 432         } else {
 433             // Simperium-iOS sets booleans as integer values (0 or 1)
 434             return deleted instanceof Number &amp;&amp; ((Number) deleted).intValue() != 0;
 435         }
 436     }
 437 
 438     public void setDeleted(boolean deleted) {
 439         setProperty(DELETED_PROPERTY, deleted);
 440     }
 441 
 442     public boolean isMarkdownEnabled() {
 443         return hasSystemTag(MARKDOWN_TAG);
 444     }
 445 
 446     public void enableMarkdown() {
 447         setMarkdownEnabled(true);
 448     }
 449 
 450     public void setMarkdownEnabled(boolean isMarkdownEnabled) {
 451         if (isMarkdownEnabled) {
 452             addSystemTag(MARKDOWN_TAG);
 453         } else {
 454             removeSystemTag(MARKDOWN_TAG);
 455         }
 456     }
 457 
 458     public boolean isPinned() {
 459         return hasSystemTag(PINNED_TAG);
 460     }
 461 
 462     public void setPinned(boolean isPinned) {
 463         if (isPinned) {
 464             addSystemTag(PINNED_TAG);
 465         } else {
 466             removeSystemTag(PINNED_TAG);
 467         }
 468     }
 469 
 470     public boolean isPreviewEnabled() {
 471         return hasSystemTag(PREVIEW_TAG);
 472     }
 473 
 474     public void setPreviewEnabled(boolean isPreviewEnabled) {
 475         if (isPreviewEnabled) {
 476             addSystemTag(PREVIEW_TAG);
 477         } else {
 478             removeSystemTag(PREVIEW_TAG);
 479         }
 480     }
 481 
 482     public boolean isPublished() {
 483         return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 484     }
 485 
 486     public void setPublished(boolean isPublished) {
 487         if (isPublished) {
 488             addSystemTag(PUBLISHED_TAG);
 489         } else {
 490             removeSystemTag(PUBLISHED_TAG);
 491         }
 492     }
 493 
 494     public void removeTag(String tagName) {
 495         List&lt;String&gt; tags = getTags();
 496 
 497         List&lt;String&gt; tagsMatched = TagUtils.findTagsMatch(tags, tagName);
 498         tags.removeAll(tagsMatched);
 499 
 500         setTags(tags);
 501         save();
 502     }
 503 
 504     private boolean hasSystemTag(String tag) {
 505         if (TextUtils.isEmpty(tag))
 506             return false;
 507 
 508         JSONArray tags = getSystemTags();
 509         int length = tags.length();
 510         for (int i = 0; i &lt; length; i++) {
 511             if (tags.optString(i).equals(tag)) {
 512                 return true;
 513             }
 514         }
 515 
 516         return false;
 517     }
 518 
 519     private void addSystemTag(String tag) {
 520         if (TextUtils.isEmpty(tag)) {
 521             return;
 522         }
 523 
 524         // Ensure we don&#x27;t add the same tag again
 525         if (!hasSystemTag(tag)) {
 526             getSystemTags().put(tag);
 527         }
 528     }
 529 
 530     private void removeSystemTag(String tag) {
 531         if (!hasSystemTag(tag)) {
 532             return;
 533         }
 534 
 535         JSONArray tags = getSystemTags();
 536         JSONArray newTags = new JSONArray();
 537         int length = tags.length();
 538         try {
 539             for (int i = 0; i &lt; length; i++) {
 540                 Object val = tags.get(i);
 541                 if (!val.equals(tag))
 542                     newTags.put(val);
 543             }
 544         } catch (JSONException e) {
 545             // could not update pinned setting
 546         }
 547 
 548         setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 549     }
 550 
 551     /**
 552      * Check if the note has any changes
 553      *
 554      * @param content           the new note content
 555      * @param tagString         space separated tags
 556      * @param isPinned          note is pinned
 557      * @param isMarkdownEnabled note has markdown enabled
 558      * @param isPreviewEnabled  note has preview enabled
 559      * @return true if note has changes, false if it is unchanged.
 560      */
<abbr title=" 561     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 561     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnablðŸ”µ</abbr>
 562         return !content.equals(this.getContent())
 563                 || !tagString.equals(this.getTagString().toString())
 564                 || this.isPinned() != isPinned
 565                 || this.isMarkdownEnabled() != isMarkdownEnabled
 566                 || this.isPreviewEnabled() != isPreviewEnabled;
 567     }
 568 
 569     public static class Schema extends BucketSchema&lt;Note&gt; {
 570 
 571         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
 572         protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
 573 
 574         public Schema() {
 575             autoIndex();
 576             addIndex(sNoteIndexer);
 577             setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
 578             setDefault(CONTENT_PROPERTY, &quot;&quot;);
 579             setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
 580             setDefault(TAGS_PROPERTY, new JSONArray());
 581             setDefault(DELETED_PROPERTY, false);
 582             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
 583             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
 584         }
 585 
 586         public String getRemoteName() {
 587             return Note.BUCKET_NAME;
 588         }
 589 
 590         public Note build(String key, JSONObject properties) {
 591             return new Note(key, properties);
 592         }
 593 
 594         public void update(Note note, JSONObject properties) {
 595             note.setProperties(properties);
 596             note.mTitle = null;
 597             note.mContentPreview = null;
 598         }
 599     }
 600 }
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote.models;
   2  
   3  import android.content.Context;
   4  import android.text.TextUtils;
   5  
   6  import androidx.annotation.NonNull;
   7  
   8  import com.automattic.simplenote.R;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   9 +import com.automattic.simplenote.utils.DateTimeUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  10 +import com.automattic.simplenote.utils.TagUtils;</span>
  11  import com.simperium.client.Bucket;
  12  import com.simperium.client.BucketObject;
  13  import com.simperium.client.BucketSchema;
  14  import com.simperium.client.Query;
  15  import com.simperium.client.Query.ComparisonType;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  16 +import com.simperium.util.Uuid;</span>
  17  
  18  import org.json.JSONArray;
  19  import org.json.JSONException;
  20  import org.json.JSONObject;
  21  
  22  import java.math.BigDecimal;
  23  import java.text.DateFormat;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import java.text.ParseException;</span>
  25  import java.text.SimpleDateFormat;
  26  import java.util.ArrayList;
  27  import java.util.Calendar;
  28  import java.util.List;
  29  import java.util.Locale;
  30  import java.util.TimeZone;
  31  import java.util.regex.Matcher;
  32  import java.util.regex.Pattern;
  33  
  34  import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  35  
  36  public class Note extends BucketObject {
  37  
  38      public static final String BUCKET_NAME = &quot;note&quot;;
  39      public static final String MARKDOWN_TAG = &quot;markdown&quot;;
  40      public static final String PINNED_TAG = &quot;pinned&quot;;
  41      public static final String PREVIEW_TAG = &quot;preview&quot;;
  42      public static final String PUBLISHED_TAG = &quot;published&quot;;
  43      public static final String NEW_LINE = &quot;\n&quot;;
  44      public static final String CONTENT_PROPERTY = &quot;content&quot;;
  45      public static final String KEY_PROPERTY = &quot;key&quot;;
  46      public static final String TAGS_PROPERTY = &quot;tags&quot;;
  47      public static final String SYSTEM_TAGS_PROPERTY = &quot;systemTags&quot;;
  48      public static final String CREATION_DATE_PROPERTY = &quot;creationDate&quot;;
  49      public static final String MODIFICATION_DATE_PROPERTY = &quot;modificationDate&quot;;
  50      public static final String SHARE_URL_PROPERTY = &quot;shareURL&quot;;
  51      public static final String PUBLISH_URL_PROPERTY = &quot;publishURL&quot;;
  52      public static final String DELETED_PROPERTY = &quot;deleted&quot;;
  53      public static final String TITLE_INDEX_NAME = &quot;title&quot;;
  54      public static final String CONTENT_PREVIEW_INDEX_NAME = &quot;contentPreview&quot;;
  55      public static final String PINNED_INDEX_NAME = &quot;pinned&quot;;
  56      public static final String MODIFIED_INDEX_NAME = &quot;modified&quot;;
  57      public static final String CREATED_INDEX_NAME = &quot;created&quot;;
  58      public static final String MATCHED_TITLE_INDEX_NAME = &quot;matchedTitle&quot;;
  59      public static final String MATCHED_CONTENT_INDEX_NAME = &quot;matchedContent&quot;;
  60      public static final String PUBLISH_URL = &quot;http://simp.ly/p/&quot;;
  61      static public final String[] FULL_TEXT_INDEXES = new String[]{
  62              Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY};
  63      private static final String BLANK_CONTENT = &quot;&quot;;
  64      private static final String SPACE = &quot; &quot;;
  65      private static final int MAX_PREVIEW_CHARS = 300;
  66      protected String mTitle = null;
  67      protected String mContentPreview = null;
  68  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +    public Note() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +        this(Uuid.uuid());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +    }</span>
  72  
  73      public Note(String key) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -        super(key, new JSONObject());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +        this(key, new JSONObject());</span>
  76      }
  77  
  78      public Note(String key, JSONObject properties) {
  79          super(key, properties);
  80      }
  81  
  82      public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket) {
  83          return noteBucket.query()
  84                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  85      }
  86  
  87      public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket) {
  88          return noteBucket.query()
  89                  .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
  90      }
  91  
  92      public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString) {
  93          return noteBucket.query()
  94                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
  95                  .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
  96      }
  97  
  98      public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag) {
  99          return noteBucket.query()
 100                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 101                  .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 102      }
 103  
 104      public static Query&lt;Note&gt; allWithNoTag(Bucket&lt;Note&gt; noteBucket) {
 105          return noteBucket.query()
 106                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 107                  .where(TAGS_PROPERTY, ComparisonType.EQUAL_TO, null);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 108 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +    public static Note fromContent(Bucket&lt;Note&gt; notesBucket, String content) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +        Note note = notesBucket.newObject();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +        note.setContent(content);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +        note.setCreationDate(Calendar.getInstance());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +        note.setModificationDate(note.getCreationDate());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +        return note;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 119 +    public static Note fromExportedJson(Bucket&lt;Note&gt; notesBucket, JSONObject noteJson) throws JSONException, ParseException {"> 119 +    public static Note fromExportedJson(Bucket&lt;Note&gt; notesBucket, JSONObject noteJson) throws JSONException, ParseðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +        Note note = notesBucket.newObject();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +        note.setContent(noteJson.optString(&quot;content&quot;, &quot;&quot;));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 122 +        note.setCreationDate(noteJson.has(&quot;creationDate&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;creationDate&quot;)) : Calendar.getInstance());"> 122 +        note.setCreationDate(noteJson.has(&quot;creationDate&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;creaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 123 +        note.setModificationDate(noteJson.has(&quot;lastModified&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;lastModified&quot;)) : Calendar.getInstance());"> 123 +        note.setModificationDate(noteJson.has(&quot;lastModified&quot;) ? DateTimeUtils.getDateCalendar(noteJson.getString(&quot;ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +        note.setTags(noteJson.has(&quot;tags&quot;) ? noteJson.getJSONArray(&quot;tags&quot;) : new JSONArray());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +        note.setPinned(noteJson.optBoolean(&quot;pinned&quot;, false));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +        note.setMarkdownEnabled(noteJson.optBoolean(&quot;markdown&quot;, false));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +        return note;</span>
 129      }
 130  
 131      @SuppressWarnings(&quot;unused&quot;)
 132      public static String dateString(Number time, boolean useShortFormat, Context context) {
 133          Calendar c = numberToDate(time);
 134          return dateString(c, useShortFormat, context);
 135      }
 136  
 137      public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 138          int year, month, day;
 139  
 140          String time, date, retVal;
 141  
 142          Calendar diff = Calendar.getInstance();
 143          diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 144  
 145          year = diff.get(Calendar.YEAR);
 146          month = diff.get(Calendar.MONTH);
 147          day = diff.get(Calendar.DAY_OF_MONTH);
 148  
 149          diff.setTimeInMillis(0); // starting time
 150          time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 151          if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 151          if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.ðŸ”µ</abbr>
 152              date = context.getResources().getString(R.string.today);
 153              if (useShortFormat)
 154                  retVal = time;
 155              else
 156                  retVal = date + &quot;, &quot; + time;
 157          } else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 158              date = context.getResources().getString(R.string.yesterday);
 159              if (useShortFormat)
 160                  retVal = date;
 161              else
 162                  retVal = date + &quot;, &quot; + time;
 163          } else {
 164              date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 165              retVal = date + &quot;, &quot; + time;
 166          }
 167  
 168          return retVal;
 169      }
 170  
 171      private static int getReferenceCount(String key, String content) {
 172          Pattern pattern = Pattern.compile(SIMPLENOTE_LINK_PREFIX + key);
 173          Matcher matcher = pattern.matcher(content);
 174          int count = 0;
 175  
 176          while (matcher.find()) {
 177              count++;
 178          }
 179  
 180          return count;
 181      }
 182  
 183      public static List&lt;Reference&gt; getReferences(Bucket&lt;Note&gt; bucket, String key) {
 184          List&lt;Reference&gt; references = new ArrayList&lt;&gt;();
 185          Bucket.ObjectCursor&lt;Note&gt; cursor = Note.search(bucket, SIMPLENOTE_LINK_PREFIX + key).execute();
 186  
 187          while (cursor.moveToNext()) {
 188              Note note = cursor.getObject();
 189              references.add(
 190                  new Reference(
 191                      note.getSimperiumKey(),
 192                      note.getTitle(),
 193                      note.getModificationDate(),
 194                      getReferenceCount(key, note.getContent())
 195                  )
 196              );
 197          }
 198  
 199          return references;
 200      }
 201  
 202      public static Calendar numberToDate(Number time) {
 203          Calendar date = Calendar.getInstance();
 204          if (time != null) {
 205              // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 206              // since we only deal with create and modify timestamps, they should all have occurred
 207              // at the present time or in the past.
 208              float now = (float) date.getTimeInMillis() / 1000;
 209              float magnitude = time.floatValue() / now;
 210              if (magnitude &gt;= 2.f) time = time.longValue() / 1000;
 211              date.setTimeInMillis(time.longValue() * 1000);
 212          }
 213          return date;
 214      }
 215  
 216      public static String numberToDateString(@NonNull Number number) {
 217          long milliseconds = new BigDecimal(number.toString()).multiply(new BigDecimal(1000)).longValue();
 218          Calendar calendar = Calendar.getInstance();
 219          calendar.setTimeInMillis(milliseconds);
 220          SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, Locale.US);
 221          date.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));
 222          return date.format(calendar.getTime());
 223      }
 224  
 225      protected void updateTitleAndPreview() {
 226          // try to build a title and preview property out of content
 227          String content = getContent().trim();
 228          if (content.length() &gt; MAX_PREVIEW_CHARS) {
 229              content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 230          }
 231  
 232          int firstNewLinePosition = content.indexOf(NEW_LINE);
 233          if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 234              mTitle = content.substring(0, firstNewLinePosition).trim();
 235  
 236              if (firstNewLinePosition &lt; content.length()) {
 237                  mContentPreview = content.substring(firstNewLinePosition, content.length());
 238                  mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE + SPACE, SPACE).trim();
 239              } else {
 240                  mContentPreview = content;
 241              }
 242          } else {
 243              mTitle = content;
 244              mContentPreview = content;
 245          }
 246      }
 247  
 248      public String getTitle() {
 249          if (mTitle == null) {
 250              updateTitleAndPreview();
 251          }
 252          return mTitle;
 253      }
 254  
 255      public String getContent() {
 256          Object content = getProperty(CONTENT_PROPERTY);
 257          if (content == null) {
 258              return BLANK_CONTENT;
 259          }
 260          return (String) content;
 261      }
 262  
 263      public void setContent(String content) {
 264          mTitle = null;
 265          mContentPreview = null;
 266          setProperty(CONTENT_PROPERTY, content);
 267      }
 268  
 269      public String getContentPreview() {
 270          if (mContentPreview == null) {
 271              updateTitleAndPreview();
 272          }
 273          return mContentPreview;
 274      }
 275  
 276      public Calendar getCreationDate() {
 277          return numberToDate((Number) getProperty(CREATION_DATE_PROPERTY));
 278      }
 279  
 280      public String getCreationDateString() {
 281          return numberToDateString((Number) getProperty(CREATION_DATE_PROPERTY));
 282      }
 283  
 284      public void setCreationDate(Calendar creationDate) {
 285          setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis() / 1000);
 286      }
 287  
 288      public Calendar getModificationDate() {
 289          return numberToDate((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 290      }
 291  
 292      public String getModificationDateString() {
 293          return numberToDateString((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 294      }
 295  
 296      public void setModificationDate(Calendar modificationDate) {
 297          setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis() / 1000);
 298      }
 299  
 300      public String getPublishedUrl() {
 301          String urlCode = (String) getProperty(PUBLISH_URL_PROPERTY);
 302          if (TextUtils.isEmpty(urlCode)) {
 303              return &quot;&quot;;
 304          }
 305  
 306          return PUBLISH_URL + urlCode;
 307      }
 308  
 309      public boolean hasTag(String tag) {
 310          List&lt;String&gt; tags = getTags();
 311          String tagLower = tag.toLowerCase();
 312          for (String tagName : tags) {
 313              if (tagLower.equals(tagName.toLowerCase())) return true;
 314          }
 315          return false;
 316      }
 317  
 318      public boolean hasTag(Tag tag) {
 319          return hasTag(tag.getSimperiumKey());
 320      }
 321  
 322      public List&lt;String&gt; getTags() {
 323  
 324          JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 325  
 326          if (tags == null) {
 327              tags = new JSONArray();
 328              setProperty(TAGS_PROPERTY, &quot;&quot;);
 329          }
 330  
 331          int length = tags.length();
 332  
 333          List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);
 334  
 335          if (length == 0) return tagList;
 336  
 337          for (int i = 0; i &lt; length; i++) {
 338              String tag = tags.optString(i);
 339              if (!tag.equals(&quot;&quot;))
 340                  tagList.add(tag);
 341          }
 342  
 343          return tagList;
 344      }
 345  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +    public void removeTag(String tagName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +        List&lt;String&gt; tags = getTags();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +        List&lt;String&gt; tagsMatched = TagUtils.findTagsMatch(tags, tagName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +        tags.removeAll(tagsMatched);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 351 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 352 +        setTags(tags);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 353 +        save();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +</span>
 356      public void setTags(List&lt;String&gt; tags) {
 357          setProperty(TAGS_PROPERTY, new JSONArray(tags));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 358 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 359 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +    public void setTags(JSONArray tags) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +        setProperty(TAGS_PROPERTY, tags);</span>
 362      }
 363  
 364      /**
 365       * String of tags delimited by a space
 366       */
 367      public CharSequence getTagString() {
 368          StringBuilder tagString = new StringBuilder();
 369          List&lt;String&gt; tags = getTags();
 370          for (String tag : tags) {
 371              if (tagString.length() &gt; 0) {
 372                  tagString.append(SPACE);
 373              }
 374              tagString.append(tag);
 375          }
 376          return tagString;
 377      }
 378  
 379      /**
 380       * Sets the note&#x27;s tags by providing it with a {@link String} of space separated tags.
 381       * Filters out duplicate tags.
 382       *
 383       * @param tagString a space delimited list of tags
 384       */
 385      public void setTagString(String tagString) {
 386          List&lt;String&gt; tags = getTags();
 387          tags.clear();
 388  
 389          if (tagString == null) {
 390              setTags(tags);
 391              return;
 392          }
 393  
 394          // Make sure string has a trailing space
 395          if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 396              tagString = tagString + SPACE;
 397          // for comparing case-insensitive strings, would like to find a way to
 398          // do this without allocating a new list and strings
 399          List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();
 400          // remove all current tags
 401          int start = 0;
 402          int next;
 403          String possible;
 404          String possibleUpperCase;
 405          // search tag string for space characters and pull out individual tags
 406          do {
 407              next = tagString.indexOf(SPACE, start);
 408              if (next &gt; start) {
 409                  possible = tagString.substring(start, next);
 410                  possibleUpperCase = possible.toUpperCase();
 411                  if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 412                      tagsUpperCase.add(possibleUpperCase);
 413                      tags.add(possible);
 414                  }
 415              }
 416              start = next + 1;
 417          } while (next &gt; -1);
 418          setTags(tags);
 419      }
 420  
 421      public JSONArray getSystemTags() {
 422          JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 423          if (tags == null) {
 424              tags = new JSONArray();
 425              setProperty(SYSTEM_TAGS_PROPERTY, tags);
 426          }
 427          return tags;
 428      }
 429  
 430      public Boolean isDeleted() {
 431          Object deleted = getProperty(DELETED_PROPERTY);
 432          if (deleted == null) {
 433              return false;
 434          }
 435          if (deleted instanceof Boolean) {
 436              return (Boolean) deleted;
 437          } else {
 438              // Simperium-iOS sets booleans as integer values (0 or 1)
 439              return deleted instanceof Number &amp;&amp; ((Number) deleted).intValue() != 0;
 440          }
 441      }
 442  
 443      public void setDeleted(boolean deleted) {
 444          setProperty(DELETED_PROPERTY, deleted);
 445      }
 446  
 447      public boolean isMarkdownEnabled() {
 448          return hasSystemTag(MARKDOWN_TAG);
 449      }
 450  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 451 +    public void enableMarkdown() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 452 +        setMarkdownEnabled(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 453 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 454 +</span>
 455      public void setMarkdownEnabled(boolean isMarkdownEnabled) {
 456          if (isMarkdownEnabled) {
 457              addSystemTag(MARKDOWN_TAG);
 458          } else {
 459              removeSystemTag(MARKDOWN_TAG);
 460          }
 461      }
 462  
 463      public boolean isPinned() {
 464          return hasSystemTag(PINNED_TAG);
 465      }
 466  
 467      public void setPinned(boolean isPinned) {
 468          if (isPinned) {
 469              addSystemTag(PINNED_TAG);
 470          } else {
 471              removeSystemTag(PINNED_TAG);
 472          }
 473      }
 474  
 475      public boolean isPreviewEnabled() {
 476          return hasSystemTag(PREVIEW_TAG);
 477      }
 478  
 479      public void setPreviewEnabled(boolean isPreviewEnabled) {
 480          if (isPreviewEnabled) {
 481              addSystemTag(PREVIEW_TAG);
 482          } else {
 483              removeSystemTag(PREVIEW_TAG);
 484          }
 485      }
 486  
 487      public boolean isPublished() {
 488          return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 489      }
 490  
 491      public void setPublished(boolean isPublished) {
 492          if (isPublished) {
 493              addSystemTag(PUBLISHED_TAG);
 494          } else {
 495              removeSystemTag(PUBLISHED_TAG);
 496          }
 497      }
 498  










 499      private boolean hasSystemTag(String tag) {
 500          if (TextUtils.isEmpty(tag))
 501              return false;
 502  
 503          JSONArray tags = getSystemTags();
 504          int length = tags.length();
 505          for (int i = 0; i &lt; length; i++) {
 506              if (tags.optString(i).equals(tag)) {
 507                  return true;
 508              }
 509          }
 510  
 511          return false;
 512      }
 513  
 514      private void addSystemTag(String tag) {
 515          if (TextUtils.isEmpty(tag)) {
 516              return;
 517          }
 518  
 519          // Ensure we don&#x27;t add the same tag again
 520          if (!hasSystemTag(tag)) {
 521              getSystemTags().put(tag);
 522          }
 523      }
 524  
 525      private void removeSystemTag(String tag) {
 526          if (!hasSystemTag(tag)) {
 527              return;
 528          }
 529  
 530          JSONArray tags = getSystemTags();
 531          JSONArray newTags = new JSONArray();
 532          int length = tags.length();
 533          try {
 534              for (int i = 0; i &lt; length; i++) {
 535                  Object val = tags.get(i);
 536                  if (!val.equals(tag))
 537                      newTags.put(val);
 538              }
 539          } catch (JSONException e) {
 540              // could not update pinned setting
 541          }
 542  
 543          setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 544      }
 545  
 546      /**
 547       * Check if the note has any changes
 548       *
 549       * @param content           the new note content
 550       * @param tagString         space separated tags
 551       * @param isPinned          note is pinned
 552       * @param isMarkdownEnabled note has markdown enabled
 553       * @param isPreviewEnabled  note has preview enabled
 554       * @return true if note has changes, false if it is unchanged.
 555       */
<abbr title=" 556      public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 556      public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled, booleðŸ”µ</abbr>
 557          return !content.equals(this.getContent())
 558                  || !tagString.equals(this.getTagString().toString())
 559                  || this.isPinned() != isPinned
 560                  || this.isMarkdownEnabled() != isMarkdownEnabled
 561                  || this.isPreviewEnabled() != isPreviewEnabled;
 562      }
 563  
 564      public static class Schema extends BucketSchema&lt;Note&gt; {
 565  
 566          protected static NoteIndexer sNoteIndexer = new NoteIndexer();
 567          protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
 568  
 569          public Schema() {
 570              autoIndex();
 571              addIndex(sNoteIndexer);
 572              setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
 573              setDefault(CONTENT_PROPERTY, &quot;&quot;);
 574              setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
 575              setDefault(TAGS_PROPERTY, new JSONArray());
 576              setDefault(DELETED_PROPERTY, false);
 577              setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
 578              setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
 579          }
 580  
 581          public String getRemoteName() {
 582              return Note.BUCKET_NAME;
 583          }
 584  
 585          public Note build(String key, JSONObject properties) {
 586              return new Note(key, properties);
 587          }
 588  
 589          public void update(Note note, JSONObject properties) {
 590              note.setProperties(properties);
 591              note.mTitle = null;
 592              note.mContentPreview = null;
 593          }
 594      }
 595  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote.models;
   2  
   3  import android.content.Context;
   4  import android.text.TextUtils;
   5  
   6  import androidx.annotation.NonNull;
   7  
   8  import com.automattic.simplenote.R;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   9 +import com.automattic.simplenote.utils.TagUtils;</span>

  10  import com.simperium.client.Bucket;
  11  import com.simperium.client.BucketObject;
  12  import com.simperium.client.BucketSchema;
  13  import com.simperium.client.Query;
  14  import com.simperium.client.Query.ComparisonType;

  15  
  16  import org.json.JSONArray;
  17  import org.json.JSONException;
  18  import org.json.JSONObject;
  19  
  20  import java.math.BigDecimal;
  21  import java.text.DateFormat;

  22  import java.text.SimpleDateFormat;
  23  import java.util.ArrayList;
  24  import java.util.Calendar;
  25  import java.util.List;
  26  import java.util.Locale;
  27  import java.util.TimeZone;
  28  import java.util.regex.Matcher;
  29  import java.util.regex.Pattern;
  30  
  31  import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  32  
  33  public class Note extends BucketObject {
  34  
  35      public static final String BUCKET_NAME = &quot;note&quot;;
  36      public static final String MARKDOWN_TAG = &quot;markdown&quot;;
  37      public static final String PINNED_TAG = &quot;pinned&quot;;
  38      public static final String PREVIEW_TAG = &quot;preview&quot;;
  39      public static final String PUBLISHED_TAG = &quot;published&quot;;
  40      public static final String NEW_LINE = &quot;\n&quot;;
  41      public static final String CONTENT_PROPERTY = &quot;content&quot;;
  42      public static final String KEY_PROPERTY = &quot;key&quot;;
  43      public static final String TAGS_PROPERTY = &quot;tags&quot;;
  44      public static final String SYSTEM_TAGS_PROPERTY = &quot;systemTags&quot;;
  45      public static final String CREATION_DATE_PROPERTY = &quot;creationDate&quot;;
  46      public static final String MODIFICATION_DATE_PROPERTY = &quot;modificationDate&quot;;
  47      public static final String SHARE_URL_PROPERTY = &quot;shareURL&quot;;
  48      public static final String PUBLISH_URL_PROPERTY = &quot;publishURL&quot;;
  49      public static final String DELETED_PROPERTY = &quot;deleted&quot;;
  50      public static final String TITLE_INDEX_NAME = &quot;title&quot;;
  51      public static final String CONTENT_PREVIEW_INDEX_NAME = &quot;contentPreview&quot;;
  52      public static final String PINNED_INDEX_NAME = &quot;pinned&quot;;
  53      public static final String MODIFIED_INDEX_NAME = &quot;modified&quot;;
  54      public static final String CREATED_INDEX_NAME = &quot;created&quot;;
  55      public static final String MATCHED_TITLE_INDEX_NAME = &quot;matchedTitle&quot;;
  56      public static final String MATCHED_CONTENT_INDEX_NAME = &quot;matchedContent&quot;;
  57      public static final String PUBLISH_URL = &quot;http://simp.ly/p/&quot;;
  58      static public final String[] FULL_TEXT_INDEXES = new String[]{
  59              Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY};
  60      private static final String BLANK_CONTENT = &quot;&quot;;
  61      private static final String SPACE = &quot; &quot;;
  62      private static final int MAX_PREVIEW_CHARS = 300;
  63      protected String mTitle = null;
  64      protected String mContentPreview = null;
  65  



  66  
  67      public Note(String key) {
  68          super(key, new JSONObject());

  69      }
  70  
  71      public Note(String key, JSONObject properties) {
  72          super(key, properties);
  73      }
  74  
  75      public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket) {
  76          return noteBucket.query()
  77                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  78      }
  79  
  80      public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket) {
  81          return noteBucket.query()
  82                  .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
  83      }
  84  
  85      public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString) {
  86          return noteBucket.query()
  87                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
  88                  .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
  89      }
  90  
  91      public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag) {
  92          return noteBucket.query()
  93                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
  94                  .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
  95      }
  96  
  97      public static Query&lt;Note&gt; allWithNoTag(Bucket&lt;Note&gt; noteBucket) {
  98          return noteBucket.query()
  99                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 100                  .where(TAGS_PROPERTY, ComparisonType.EQUAL_TO, null);





















 101      }
 102  
 103      @SuppressWarnings(&quot;unused&quot;)
 104      public static String dateString(Number time, boolean useShortFormat, Context context) {
 105          Calendar c = numberToDate(time);
 106          return dateString(c, useShortFormat, context);
 107      }
 108  
 109      public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 110          int year, month, day;
 111  
 112          String time, date, retVal;
 113  
 114          Calendar diff = Calendar.getInstance();
 115          diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 116  
 117          year = diff.get(Calendar.YEAR);
 118          month = diff.get(Calendar.MONTH);
 119          day = diff.get(Calendar.DAY_OF_MONTH);
 120  
 121          diff.setTimeInMillis(0); // starting time
 122          time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 123          if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 123          if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.ðŸ”µ</abbr>
 124              date = context.getResources().getString(R.string.today);
 125              if (useShortFormat)
 126                  retVal = time;
 127              else
 128                  retVal = date + &quot;, &quot; + time;
 129          } else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 130              date = context.getResources().getString(R.string.yesterday);
 131              if (useShortFormat)
 132                  retVal = date;
 133              else
 134                  retVal = date + &quot;, &quot; + time;
 135          } else {
 136              date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 137              retVal = date + &quot;, &quot; + time;
 138          }
 139  
 140          return retVal;
 141      }
 142  
 143      private static int getReferenceCount(String key, String content) {
 144          Pattern pattern = Pattern.compile(SIMPLENOTE_LINK_PREFIX + key);
 145          Matcher matcher = pattern.matcher(content);
 146          int count = 0;
 147  
 148          while (matcher.find()) {
 149              count++;
 150          }
 151  
 152          return count;
 153      }
 154  
 155      public static List&lt;Reference&gt; getReferences(Bucket&lt;Note&gt; bucket, String key) {
 156          List&lt;Reference&gt; references = new ArrayList&lt;&gt;();
 157          Bucket.ObjectCursor&lt;Note&gt; cursor = Note.search(bucket, SIMPLENOTE_LINK_PREFIX + key).execute();
 158  
 159          while (cursor.moveToNext()) {
 160              Note note = cursor.getObject();
 161              references.add(
 162                  new Reference(
 163                      note.getSimperiumKey(),
 164                      note.getTitle(),
 165                      note.getModificationDate(),
 166                      getReferenceCount(key, note.getContent())
 167                  )
 168              );
 169          }
 170  
 171          return references;
 172      }
 173  
 174      public static Calendar numberToDate(Number time) {
 175          Calendar date = Calendar.getInstance();
 176          if (time != null) {
 177              // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 178              // since we only deal with create and modify timestamps, they should all have occurred
 179              // at the present time or in the past.
 180              float now = (float) date.getTimeInMillis() / 1000;
 181              float magnitude = time.floatValue() / now;
 182              if (magnitude &gt;= 2.f) time = time.longValue() / 1000;
 183              date.setTimeInMillis(time.longValue() * 1000);
 184          }
 185          return date;
 186      }
 187  
 188      public static String numberToDateString(@NonNull Number number) {
 189          long milliseconds = new BigDecimal(number.toString()).multiply(new BigDecimal(1000)).longValue();
 190          Calendar calendar = Calendar.getInstance();
 191          calendar.setTimeInMillis(milliseconds);
 192          SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, Locale.US);
 193          date.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));
 194          return date.format(calendar.getTime());
 195      }
 196  
 197      protected void updateTitleAndPreview() {
 198          // try to build a title and preview property out of content
 199          String content = getContent().trim();
 200          if (content.length() &gt; MAX_PREVIEW_CHARS) {
 201              content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 202          }
 203  
 204          int firstNewLinePosition = content.indexOf(NEW_LINE);
 205          if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 206              mTitle = content.substring(0, firstNewLinePosition).trim();
 207  
 208              if (firstNewLinePosition &lt; content.length()) {
 209                  mContentPreview = content.substring(firstNewLinePosition, content.length());
 210                  mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE + SPACE, SPACE).trim();
 211              } else {
 212                  mContentPreview = content;
 213              }
 214          } else {
 215              mTitle = content;
 216              mContentPreview = content;
 217          }
 218      }
 219  
 220      public String getTitle() {
 221          if (mTitle == null) {
 222              updateTitleAndPreview();
 223          }
 224          return mTitle;
 225      }
 226  
 227      public String getContent() {
 228          Object content = getProperty(CONTENT_PROPERTY);
 229          if (content == null) {
 230              return BLANK_CONTENT;
 231          }
 232          return (String) content;
 233      }
 234  
 235      public void setContent(String content) {
 236          mTitle = null;
 237          mContentPreview = null;
 238          setProperty(CONTENT_PROPERTY, content);
 239      }
 240  
 241      public String getContentPreview() {
 242          if (mContentPreview == null) {
 243              updateTitleAndPreview();
 244          }
 245          return mContentPreview;
 246      }
 247  
 248      public Calendar getCreationDate() {
 249          return numberToDate((Number) getProperty(CREATION_DATE_PROPERTY));
 250      }
 251  
 252      public String getCreationDateString() {
 253          return numberToDateString((Number) getProperty(CREATION_DATE_PROPERTY));
 254      }
 255  
 256      public void setCreationDate(Calendar creationDate) {
 257          setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis() / 1000);
 258      }
 259  
 260      public Calendar getModificationDate() {
 261          return numberToDate((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 262      }
 263  
 264      public String getModificationDateString() {
 265          return numberToDateString((Number) getProperty(MODIFICATION_DATE_PROPERTY));
 266      }
 267  
 268      public void setModificationDate(Calendar modificationDate) {
 269          setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis() / 1000);
 270      }
 271  
 272      public String getPublishedUrl() {
 273          String urlCode = (String) getProperty(PUBLISH_URL_PROPERTY);
 274          if (TextUtils.isEmpty(urlCode)) {
 275              return &quot;&quot;;
 276          }
 277  
 278          return PUBLISH_URL + urlCode;
 279      }
 280  
 281      public boolean hasTag(String tag) {
 282          List&lt;String&gt; tags = getTags();
 283          String tagLower = tag.toLowerCase();
 284          for (String tagName : tags) {
 285              if (tagLower.equals(tagName.toLowerCase())) return true;
 286          }
 287          return false;
 288      }
 289  
 290      public boolean hasTag(Tag tag) {
 291          return hasTag(tag.getSimperiumKey());
 292      }
 293  
 294      public List&lt;String&gt; getTags() {
 295  
 296          JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 297  
 298          if (tags == null) {
 299              tags = new JSONArray();
 300              setProperty(TAGS_PROPERTY, &quot;&quot;);
 301          }
 302  
 303          int length = tags.length();
 304  
 305          List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);
 306  
 307          if (length == 0) return tagList;
 308  
 309          for (int i = 0; i &lt; length; i++) {
 310              String tag = tags.optString(i);
 311              if (!tag.equals(&quot;&quot;))
 312                  tagList.add(tag);
 313          }
 314  
 315          return tagList;
 316      }
 317  










 318      public void setTags(List&lt;String&gt; tags) {
 319          setProperty(TAGS_PROPERTY, new JSONArray(tags));




 320      }
 321  
 322      /**
 323       * String of tags delimited by a space
 324       */
 325      public CharSequence getTagString() {
 326          StringBuilder tagString = new StringBuilder();
 327          List&lt;String&gt; tags = getTags();
 328          for (String tag : tags) {
 329              if (tagString.length() &gt; 0) {
 330                  tagString.append(SPACE);
 331              }
 332              tagString.append(tag);
 333          }
 334          return tagString;
 335      }
 336  
 337      /**
 338       * Sets the note&#x27;s tags by providing it with a {@link String} of space separated tags.
 339       * Filters out duplicate tags.
 340       *
 341       * @param tagString a space delimited list of tags
 342       */
 343      public void setTagString(String tagString) {
 344          List&lt;String&gt; tags = getTags();
 345          tags.clear();
 346  
 347          if (tagString == null) {
 348              setTags(tags);
 349              return;
 350          }
 351  
 352          // Make sure string has a trailing space
 353          if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 354              tagString = tagString + SPACE;
 355          // for comparing case-insensitive strings, would like to find a way to
 356          // do this without allocating a new list and strings
 357          List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();
 358          // remove all current tags
 359          int start = 0;
 360          int next;
 361          String possible;
 362          String possibleUpperCase;
 363          // search tag string for space characters and pull out individual tags
 364          do {
 365              next = tagString.indexOf(SPACE, start);
 366              if (next &gt; start) {
 367                  possible = tagString.substring(start, next);
 368                  possibleUpperCase = possible.toUpperCase();
 369                  if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 370                      tagsUpperCase.add(possibleUpperCase);
 371                      tags.add(possible);
 372                  }
 373              }
 374              start = next + 1;
 375          } while (next &gt; -1);
 376          setTags(tags);
 377      }
 378  
 379      public JSONArray getSystemTags() {
 380          JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 381          if (tags == null) {
 382              tags = new JSONArray();
 383              setProperty(SYSTEM_TAGS_PROPERTY, tags);
 384          }
 385          return tags;
 386      }
 387  
 388      public Boolean isDeleted() {
 389          Object deleted = getProperty(DELETED_PROPERTY);
 390          if (deleted == null) {
 391              return false;
 392          }
 393          if (deleted instanceof Boolean) {
 394              return (Boolean) deleted;
 395          } else {
 396              // Simperium-iOS sets booleans as integer values (0 or 1)
 397              return deleted instanceof Number &amp;&amp; ((Number) deleted).intValue() != 0;
 398          }
 399      }
 400  
 401      public void setDeleted(boolean deleted) {
 402          setProperty(DELETED_PROPERTY, deleted);
 403      }
 404  
 405      public boolean isMarkdownEnabled() {
 406          return hasSystemTag(MARKDOWN_TAG);
 407      }
 408  




 409      public void setMarkdownEnabled(boolean isMarkdownEnabled) {
 410          if (isMarkdownEnabled) {
 411              addSystemTag(MARKDOWN_TAG);
 412          } else {
 413              removeSystemTag(MARKDOWN_TAG);
 414          }
 415      }
 416  
 417      public boolean isPinned() {
 418          return hasSystemTag(PINNED_TAG);
 419      }
 420  
 421      public void setPinned(boolean isPinned) {
 422          if (isPinned) {
 423              addSystemTag(PINNED_TAG);
 424          } else {
 425              removeSystemTag(PINNED_TAG);
 426          }
 427      }
 428  
 429      public boolean isPreviewEnabled() {
 430          return hasSystemTag(PREVIEW_TAG);
 431      }
 432  
 433      public void setPreviewEnabled(boolean isPreviewEnabled) {
 434          if (isPreviewEnabled) {
 435              addSystemTag(PREVIEW_TAG);
 436          } else {
 437              removeSystemTag(PREVIEW_TAG);
 438          }
 439      }
 440  
 441      public boolean isPublished() {
 442          return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 443      }
 444  
 445      public void setPublished(boolean isPublished) {
 446          if (isPublished) {
 447              addSystemTag(PUBLISHED_TAG);
 448          } else {
 449              removeSystemTag(PUBLISHED_TAG);
 450          }
 451      }
 452  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 453 +    public void removeTag(String tagName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 454 +        List&lt;String&gt; tags = getTags();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 455 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 456 +        List&lt;String&gt; tagsMatched = TagUtils.findTagsMatch(tags, tagName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 457 +        tags.removeAll(tagsMatched);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 458 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 459 +        setTags(tags);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 460 +        save();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 461 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 462 +</span>
 463      private boolean hasSystemTag(String tag) {
 464          if (TextUtils.isEmpty(tag))
 465              return false;
 466  
 467          JSONArray tags = getSystemTags();
 468          int length = tags.length();
 469          for (int i = 0; i &lt; length; i++) {
 470              if (tags.optString(i).equals(tag)) {
 471                  return true;
 472              }
 473          }
 474  
 475          return false;
 476      }
 477  
 478      private void addSystemTag(String tag) {
 479          if (TextUtils.isEmpty(tag)) {
 480              return;
 481          }
 482  
 483          // Ensure we don&#x27;t add the same tag again
 484          if (!hasSystemTag(tag)) {
 485              getSystemTags().put(tag);
 486          }
 487      }
 488  
 489      private void removeSystemTag(String tag) {
 490          if (!hasSystemTag(tag)) {
 491              return;
 492          }
 493  
 494          JSONArray tags = getSystemTags();
 495          JSONArray newTags = new JSONArray();
 496          int length = tags.length();
 497          try {
 498              for (int i = 0; i &lt; length; i++) {
 499                  Object val = tags.get(i);
 500                  if (!val.equals(tag))
 501                      newTags.put(val);
 502              }
 503          } catch (JSONException e) {
 504              // could not update pinned setting
 505          }
 506  
 507          setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 508      }
 509  
 510      /**
 511       * Check if the note has any changes
 512       *
 513       * @param content           the new note content
 514       * @param tagString         space separated tags
 515       * @param isPinned          note is pinned
 516       * @param isMarkdownEnabled note has markdown enabled
 517       * @param isPreviewEnabled  note has preview enabled
 518       * @return true if note has changes, false if it is unchanged.
 519       */
<abbr title=" 520      public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 520      public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled, booleðŸ”µ</abbr>
 521          return !content.equals(this.getContent())
 522                  || !tagString.equals(this.getTagString().toString())
 523                  || this.isPinned() != isPinned
 524                  || this.isMarkdownEnabled() != isMarkdownEnabled
 525                  || this.isPreviewEnabled() != isPreviewEnabled;
 526      }
 527  
 528      public static class Schema extends BucketSchema&lt;Note&gt; {
 529  
 530          protected static NoteIndexer sNoteIndexer = new NoteIndexer();
 531          protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
 532  
 533          public Schema() {
 534              autoIndex();
 535              addIndex(sNoteIndexer);
 536              setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
 537              setDefault(CONTENT_PROPERTY, &quot;&quot;);
 538              setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
 539              setDefault(TAGS_PROPERTY, new JSONArray());
 540              setDefault(DELETED_PROPERTY, false);
 541              setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
 542              setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
 543          }
 544  
 545          public String getRemoteName() {
 546              return Note.BUCKET_NAME;
 547          }
 548  
 549          public Note build(String key, JSONObject properties) {
 550              return new Note(key, properties);
 551          }
 552  
 553          public void update(Note note, JSONObject properties) {
 554              note.setProperties(properties);
 555              note.mTitle = null;
 556              note.mContentPreview = null;
 557          }
 558      }
 559  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            