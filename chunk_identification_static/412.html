<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>412</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    412
                    <a href="411.html">prev</a>
                    <a href="413.html">next</a>
                    <a href="412_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_e408d12c730a7397701e361d52cac823c1694111_kudu/kudu-side/kudu-all-side/src/main/java/com/dtstack/flink/sql/side/kudu/KuduAllReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111:kudu/kudu-side/kudu-all-side/src/main/java/com/dtstack/flink/sql/side/kudu/KuduAllReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111^1:kudu/kudu-side/kudu-all-side/src/main/java/com/dtstack/flink/sql/side/kudu/KuduAllReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111^2:kudu/kudu-side/kudu-all-side/src/main/java/com/dtstack/flink/sql/side/kudu/KuduAllReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;09a8d23c2b8c9e6955f6f68bed4a2fe16cc7fbd3:kudu/kudu-side/kudu-all-side/src/main/java/com/dtstack/flink/sql/side/kudu/KuduAllReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.dtstack.flink.sql.side.kudu;
   2 
   3 import com.dtstack.flink.sql.side.BaseAllReqRow;
   4 import com.dtstack.flink.sql.side.FieldInfo;
   5 import com.dtstack.flink.sql.side.JoinInfo;
   6 import com.dtstack.flink.sql.side.PredicateInfo;
   7 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
   8 import com.dtstack.flink.sql.side.kudu.table.KuduSideTableInfo;
   9 import com.dtstack.flink.sql.side.kudu.utils.KuduUtil;
  10 import com.dtstack.flink.sql.util.RowDataComplete;
  11 import com.google.common.base.Preconditions;
  12 import com.google.common.collect.Lists;
  13 import com.google.common.collect.Maps;
  14 import org.apache.calcite.sql.JoinType;
  15 import org.apache.commons.collections.CollectionUtils;
  16 import org.apache.commons.lang3.StringUtils;
  17 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  18 import org.apache.flink.table.dataformat.BaseRow;
  19 import org.apache.flink.types.Row;
  20 import org.apache.flink.util.Collector;
  21 import org.apache.kudu.ColumnSchema;
  22 import org.apache.kudu.Schema;
  23 import org.apache.kudu.client.KuduClient;
  24 import org.apache.kudu.client.KuduException;
  25 import org.apache.kudu.client.KuduPredicate;
  26 import org.apache.kudu.client.KuduScanner;
  27 import org.apache.kudu.client.KuduTable;
  28 import org.apache.kudu.client.PartialRow;
  29 import org.apache.kudu.client.RowResult;
  30 import org.apache.kudu.client.RowResultIterator;
  31 import org.slf4j.Logger;
  32 import org.slf4j.LoggerFactory;
  33 
  34 import java.sql.SQLException;
  35 import java.util.Arrays;
  36 import java.util.Calendar;
  37 import java.util.HashMap;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.concurrent.atomic.AtomicReference;
  41 
  42 public class KuduAllReqRow extends BaseAllReqRow {
  43 
  44     private static final long serialVersionUID = 6051774809356082219L;
  45 
  46     private static final Logger LOG = LoggerFactory.getLogger(KuduAllReqRow.class);
  47     /**
  48      * Ëé∑ÂèñËøûÊé•ÁöÑÂ∞ùËØïÊ¨°Êï∞
  49      */
  50     private static final int CONN_RETRY_NUM = 3;
  51     /**
  52      * ÁºìÂ≠òÊù°Êï∞
  53      */
  54     private static final Long FETCH_SIZE = 1000L;
  55 
  56     private KuduClient client;
  57 
  58     private KuduTable table;
  59 
  60 
  61     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  62 
<abbr title="  63     public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  63     public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, Abüîµ</abbr>
  64         super(new KuduAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  65     }
  66 
  67 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  68 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  69     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  70     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  71         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  72         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  73         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  74             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  75             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  76             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  77         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  78 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  79         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  80             if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  81                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  82             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  83                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  84             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  85         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  86 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  87         return row;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  88     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  89 </span>
  90 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  91 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  92 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  98             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  99             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  99             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoüîµ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 100 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 101             //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 101             //Type information for indicating event or processing time. However, it behaves like a regulaüîµ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 102             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103                 //ÂéªÈô§‰∏ä‰∏ÄÂ±ÇOutputRowtimeProcessFunction Ë∞ÉÁî®Êó∂Âå∫ÂØºËá¥ÁöÑÂΩ±Âìç</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 104                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());"> 104                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime())üîµ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 105             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 106 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 107             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 109 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 110         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111             if (cacheInfo == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112                 row.setField(entry.getKey(), null);</span>
 113 =======
 114 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 115     @Override
 116     protected void initCache() throws SQLException {
 117         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 118         cacheRef.set(newCache);
 119         loadData(newCache);
 120     }
 121 
 122 
 123     @Override
 124     protected void reloadCache() {
 125         //reload cacheRef and replace to old cacheRef
 126         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 127         loadData(newCache);
 128 
 129         cacheRef.set(newCache);
 130         LOG.info(&quot;----- kudu all cacheRef reload end:{}&quot;, Calendar.getInstance());
 131     }
 132 
 133 
 134     @Override
 135     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
 136         List&lt;Object&gt; inputParams = Lists.newArrayList();
 137         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 138             Object equalObj = input.getField(conValIndex);
 139             if (equalObj == null) {
 140                 out.collect(null);
 141             }
 142             inputParams.add(equalObj);
 143         }
 144 
 145         String key = buildKey(inputParams);
 146         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 147         if (CollectionUtils.isEmpty(cacheList)) {
 148             if (sideInfo.getJoinType() == JoinType.LEFT) {
 149                 Row row = fillData(input, null);
 150                 RowDataComplete.collectRow(out, row);
 151             }
 152             return;
 153         }
 154 
 155         for (Map&lt;String, Object&gt; one : cacheList) {
 156             Row row = fillData(input, one);
 157             RowDataComplete.collectRow(out, row);
 158         }
 159     }
 160 
 161     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) {
 162         KuduSideTableInfo tableInfo = (KuduSideTableInfo) sideInfo.getSideTableInfo();
 163         KuduScanner scanner = null;
 164         try {
 165             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 166                 try {
 167                     scanner = getConn(tableInfo);
 168                     break;
 169                 } catch (Exception e) {
 170                     if (i == CONN_RETRY_NUM - 1) {
 171                         throw new RuntimeException(&quot;&quot;, e);
 172                     }
 173                     try {
<abbr title=" 174                         String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tableInfo.getTableName();"> 174                         String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tüîµ</abbr>
 175                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 176                         Thread.sleep(5 * 1000);
 177                     } catch (InterruptedException e1) {
 178                         LOG.error(&quot;&quot;,e1);
 179                     }
 180                 }
 181             }
 182             //load data from table
 183             assert scanner != null;
 184             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 185 
 186 
 187             while (scanner.hasMoreRows()) {
 188                 RowResultIterator results = scanner.nextRows();
 189                 while (results.hasNext()) {
 190                     RowResult result = results.next();
 191                     Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 192                     for (String sideFieldName1 : sideFieldNames) {
 193                         String sideFieldName = sideFieldName1.trim();
 194                         ColumnSchema columnSchema = table.getSchema().getColumn(sideFieldName);
 195                         if (null != columnSchema) {
 196                             KuduUtil.setMapValue(columnSchema.getType(), oneRow, sideFieldName, result);
 197                         }
 198                     }
 199                     String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 200                     List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 200                     List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newAüîµ</abbr>
 201                     list.add(oneRow);
 202                 }
 203             }
 204 
 205         } catch (Exception e) {
 206             LOG.error(&quot;&quot;, e);
 207         } finally {
 208             if (null != scanner) {
 209                 try {
 210                     scanner.close();
 211                 } catch (KuduException e) {
 212                     LOG.error(&quot;Error while closing scanner.&quot;, e);
 213                 }
 214             }
 215         }
 216 
 217 
 218     }
 219 
 220     private String buildKey(List&lt;Object&gt; equalValList) {
 221         StringBuilder sb = new StringBuilder(&quot;&quot;);
 222         for (Object equalVal : equalValList) {
 223             sb.append(equalVal).append(&quot;_&quot;);
 224         }
 225 
 226         return sb.toString();
 227     }
 228 
 229     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 230         StringBuilder sb = new StringBuilder(&quot;&quot;);
 231         for (String equalField : equalFieldList) {
 232             sb.append(val.get(equalField)).append(&quot;_&quot;);
 233         }
 234         return sb.toString();
 235     }
 236 
 237     private KuduScanner getConn(KuduSideTableInfo tableInfo) {
 238         try {
 239             if (client == null) {
 240                 String kuduMasters = tableInfo.getKuduMasters();
 241                 String tableName = tableInfo.getTableName();
 242                 Integer workerCount = tableInfo.getWorkerCount();
 243                 Integer defaultSocketReadTimeoutMs = tableInfo.getDefaultSocketReadTimeoutMs();
 244                 Integer defaultOperationTimeoutMs = tableInfo.getDefaultOperationTimeoutMs();
 245 
 246                 Preconditions.checkNotNull(kuduMasters, &quot;kuduMasters could not be null&quot;);
 247 
<abbr title=" 248                 KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMasters);"> 248                 KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMasüîµ</abbr>
 249                 if (null != workerCount) {
 250                     kuduClientBuilder.workerCount(workerCount);
 251                 }
 252 
 253                 if (null != defaultOperationTimeoutMs) {
 254                     kuduClientBuilder.defaultOperationTimeoutMs(defaultOperationTimeoutMs);
 255                 }
 256                 client = kuduClientBuilder.build();
 257 
 258                 if (!client.tableExists(tableName)) {
 259                     throw new IllegalArgumentException(&quot;Table Open Failed , please check table exists&quot;);
 260                 }
 261                 table = client.openTable(tableName);
 262             }
 263             Schema schema = table.getSchema();
 264             KuduScanner.KuduScannerBuilder tokenBuilder = client.newScannerBuilder(table);
 265             return buildScanner(tokenBuilder, schema, tableInfo);
 266         } catch (Exception e) {
 267             LOG.error(&quot;connect kudu is error:&quot; + e.getMessage());
 268             throw new RuntimeException(e);
 269         }
 270     }
 271 
 272 
 273     /**
 274      * @param builder   ÂàõÂª∫AsyncKuduScannerÂØπË±°
 275      * @param schema    kudu‰∏≠Ë°®Á∫¶Êùü
 276      * @param tableInfo AsyncKuduScannerÁöÑÈÖçÁΩÆ‰ø°ÊÅØ
 277      * @return
 278      */
<abbr title=" 279     private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableInfo tableInfo) {"> 279     private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableüîµ</abbr>
 280         Integer batchSizeBytes = tableInfo.getBatchSizeBytes();
 281         Long limitNum = tableInfo.getLimitNum();
 282         Boolean isFaultTolerant = tableInfo.getFaultTolerant();
 283         //Êü•ËØ¢ÈúÄË¶ÅÁöÑÂ≠óÊÆµ
 284         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 285         //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ∞èÂÄº
 286         String lowerBoundPrimaryKey = tableInfo.getLowerBoundPrimaryKey();
 287         //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ§ßÂÄº
 288         String upperBoundPrimaryKey = tableInfo.getUpperBoundPrimaryKey();
 289         //‰∏ªÈîÆÂ≠óÊÆµ
 290         String primaryKeys = tableInfo.getPrimaryKey();
 291         if (null == limitNum || limitNum &lt;= 0) {
 292             builder.limit(FETCH_SIZE);
 293         } else {
 294             builder.limit(limitNum);
 295         }
 296         if (null != batchSizeBytes) {
 297             builder.batchSizeBytes(batchSizeBytes);
 298         }
 299         if (null != isFaultTolerant) {
 300             builder.setFaultTolerant(isFaultTolerant);
 301         }
 302         //  Â°´ÂÖÖË∞ìËØç‰ø°ÊÅØ
 303         List&lt;PredicateInfo&gt; predicateInfoes = sideInfo.getSideTableInfo().getPredicateInfoes();
 304         if (predicateInfoes.size() &gt; 0) {
 305             predicateInfoes.stream().map(info -&gt; {
 306                 KuduPredicate kuduPredicate = KuduUtil.buildKuduPredicate(schema, info);
 307                 if (null != kuduPredicate) {
 308                     builder.addPredicate(kuduPredicate);
 309                 }
 310                 return info;
 311             }).count();
 312         }
 313 
 314         if (null != lowerBoundPrimaryKey &amp;&amp; null != upperBoundPrimaryKey &amp;&amp; null != primaryKeys) {
 315             List&lt;ColumnSchema&gt; columnSchemas = schema.getPrimaryKeyColumns();
 316             Map&lt;String, Integer&gt; columnName = new HashMap&lt;String, Integer&gt;(columnSchemas.size());
 317             for (int i = 0; i &lt; columnSchemas.size(); i++) {
 318                 columnName.put(columnSchemas.get(i).getName(), i);
 319             }
 320             String[] primaryKey = splitString(primaryKeys);
 321             String[] lowerBounds = splitString(lowerBoundPrimaryKey);
 322             String[] upperBounds = splitString(upperBoundPrimaryKey);
 323             PartialRow lowerPartialRow = schema.newPartialRow();
 324             PartialRow upperPartialRow = schema.newPartialRow();
 325             for (int i = 0; i &lt; primaryKey.length; i++) {
 326                 Integer index = columnName.get(primaryKey[i]);
<abbr title=" 327                 KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[i], lowerBounds[i]);"> 327                 KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[üîµ</abbr>
<abbr title=" 328                 KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[i], upperBounds[i]);"> 328                 KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[üîµ</abbr>
 329             }
 330             builder.lowerBound(lowerPartialRow);
 331             builder.exclusiveUpperBound(upperPartialRow);
 332         }
 333         List&lt;String&gt; projectColumns = Arrays.asList(sideFieldNames);
 334         return builder.setProjectedColumnNames(projectColumns).build();
 335     }
 336 
 337     private String[] splitString(String data) {
 338         return StringUtils.split(data, &quot;,&quot;);
 339     }
 340 
 341     @Override
 342     public void close() throws Exception {
 343         //ÂÖ¨Áî®‰∏Ä‰∏™client  Â¶ÇÊûúÊØèÊ¨°Âà∑Êñ∞Èó¥ÈöîÊó∂Èó¥ËæÉÈïøÂèØ‰ª•ÊØèÊ¨°Ëé∑Âèñ‰∏Ä‰∏™
 344         super.close();
 345         if (null != client) {
 346             try {
 347                 client.close();
 348             } catch (Exception e) {
 349                 LOG.error(&quot;Error while closing client.&quot;, e);
 350             }
 351         }
 352     }
 353 }
 
 
 </pre></td>
                            <td><pre>   1 package com.dtstack.flink.sql.side.kudu;
   2 
   3 import com.dtstack.flink.sql.side.BaseAllReqRow;
   4 import com.dtstack.flink.sql.side.FieldInfo;
   5 import com.dtstack.flink.sql.side.JoinInfo;
   6 import com.dtstack.flink.sql.side.PredicateInfo;
   7 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
   8 import com.dtstack.flink.sql.side.kudu.table.KuduSideTableInfo;
   9 import com.dtstack.flink.sql.side.kudu.utils.KuduUtil;
  10 import com.dtstack.flink.sql.util.RowDataComplete;
  11 import com.google.common.base.Preconditions;
  12 import com.google.common.collect.Lists;
  13 import com.google.common.collect.Maps;
  14 import org.apache.calcite.sql.JoinType;
  15 import org.apache.commons.collections.CollectionUtils;
  16 import org.apache.commons.lang3.StringUtils;
  17 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  18 import org.apache.flink.table.dataformat.BaseRow;
  19 import org.apache.flink.types.Row;
  20 import org.apache.flink.util.Collector;
  21 import org.apache.kudu.ColumnSchema;
  22 import org.apache.kudu.Schema;
  23 import org.apache.kudu.client.KuduClient;
  24 import org.apache.kudu.client.KuduException;
  25 import org.apache.kudu.client.KuduPredicate;
  26 import org.apache.kudu.client.KuduScanner;
  27 import org.apache.kudu.client.KuduTable;
  28 import org.apache.kudu.client.PartialRow;
  29 import org.apache.kudu.client.RowResult;
  30 import org.apache.kudu.client.RowResultIterator;
  31 import org.slf4j.Logger;
  32 import org.slf4j.LoggerFactory;
  33 
  34 import java.sql.SQLException;
  35 import java.util.Arrays;
  36 import java.util.Calendar;
  37 import java.util.HashMap;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.concurrent.atomic.AtomicReference;
  41 
  42 public class KuduAllReqRow extends BaseAllReqRow {
  43 
  44     private static final long serialVersionUID = 6051774809356082219L;
  45 
  46     private static final Logger LOG = LoggerFactory.getLogger(KuduAllReqRow.class);
  47     /**
  48      * Ëé∑ÂèñËøûÊé•ÁöÑÂ∞ùËØïÊ¨°Êï∞
  49      */
  50     private static final int CONN_RETRY_NUM = 3;
  51     /**
  52      * ÁºìÂ≠òÊù°Êï∞
  53      */
  54     private static final Long FETCH_SIZE = 1000L;
  55 
  56     private KuduClient client;
  57 
  58     private KuduTable table;
  59 
  60 
  61     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  62 
<abbr title="  63     public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  63     public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, Abüîµ</abbr>
  64         super(new KuduAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  65     }
  66 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  67 @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  68     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  69         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  70         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  71         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  72             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  73             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  74             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  75         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  76 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  77         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  78             if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  79                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  80             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  81                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  82             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  83         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  84 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  85         return row;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  86     }</span>
  87 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  88 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  89     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  90         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  91         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  92         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  94             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  94             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoüîµ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  96             //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  96             //Type information for indicating event or processing time. However, it behaves like a regulaüîµ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  98                 //ÂéªÈô§‰∏ä‰∏ÄÂ±ÇOutputRowtimeProcessFunction Ë∞ÉÁî®Êó∂Âå∫ÂØºËá¥ÁöÑÂΩ±Âìç</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  99                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());">  99                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime())üîµ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 100             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 101 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 102             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 104 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 105         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 106             if (cacheInfo == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 107                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 109                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 110             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113         return row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 114     }</span>
 115 =======
 116 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 117 
 118 
 119     @Override
 120     protected void initCache() throws SQLException {
 121         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 122         cacheRef.set(newCache);
 123         loadData(newCache);
 124     }
 125 
 126 
 127     @Override
 128     protected void reloadCache() {
 129         //reload cacheRef and replace to old cacheRef
 130         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 131         loadData(newCache);
 132 
 133         cacheRef.set(newCache);
 134         LOG.info(&quot;----- kudu all cacheRef reload end:{}&quot;, Calendar.getInstance());
 135     }
 136 
 137 
 138     @Override
 139     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
 140         List&lt;Object&gt; inputParams = Lists.newArrayList();
 141         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 142             Object equalObj = input.getField(conValIndex);
 143             if (equalObj == null) {
 144                 out.collect(null);
 145             }
 146             inputParams.add(equalObj);
 147         }
 148 
 149         String key = buildKey(inputParams);
 150         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 151         if (CollectionUtils.isEmpty(cacheList)) {
 152             if (sideInfo.getJoinType() == JoinType.LEFT) {
 153                 Row row = fillData(input, null);
 154                 RowDataComplete.collectRow(out, row);
 155             }
 156             return;
 157         }
 158 
 159         for (Map&lt;String, Object&gt; one : cacheList) {
 160             Row row = fillData(input, one);
 161             RowDataComplete.collectRow(out, row);
 162         }
 163     }
 164 
 165     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) {
 166         KuduSideTableInfo tableInfo = (KuduSideTableInfo) sideInfo.getSideTableInfo();
 167         KuduScanner scanner = null;
 168         try {
 169             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 170                 try {
 171                     scanner = getConn(tableInfo);
 172                     break;
 173                 } catch (Exception e) {
 174                     if (i == CONN_RETRY_NUM - 1) {
 175                         throw new RuntimeException(&quot;&quot;, e);
 176                     }
 177                     try {
<abbr title=" 178                         String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tableInfo.getTableName();"> 178                         String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tüîµ</abbr>
 179                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 180                         Thread.sleep(5 * 1000);
 181                     } catch (InterruptedException e1) {
 182                         LOG.error(&quot;&quot;,e1);
 183                     }
 184                 }
 185             }
 186             //load data from table
 187             assert scanner != null;
 188             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 189 
 190 
 191             while (scanner.hasMoreRows()) {
 192                 RowResultIterator results = scanner.nextRows();
 193                 while (results.hasNext()) {
 194                     RowResult result = results.next();
 195                     Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 196                     for (String sideFieldName1 : sideFieldNames) {
 197                         String sideFieldName = sideFieldName1.trim();
 198                         ColumnSchema columnSchema = table.getSchema().getColumn(sideFieldName);
 199                         if (null != columnSchema) {
 200                             KuduUtil.setMapValue(columnSchema.getType(), oneRow, sideFieldName, result);
 201                         }
 202                     }
 203                     String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 204                     List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 204                     List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newAüîµ</abbr>
 205                     list.add(oneRow);
 206                 }
 207             }
 208 
 209         } catch (Exception e) {
 210             LOG.error(&quot;&quot;, e);
 211         } finally {
 212             if (null != scanner) {
 213                 try {
 214                     scanner.close();
 215                 } catch (KuduException e) {
 216                     LOG.error(&quot;Error while closing scanner.&quot;, e);
 217                 }
 218             }
 219         }
 220 
 221 
 222     }
 223 
 224     private String buildKey(List&lt;Object&gt; equalValList) {
 225         StringBuilder sb = new StringBuilder(&quot;&quot;);
 226         for (Object equalVal : equalValList) {
 227             sb.append(equalVal).append(&quot;_&quot;);
 228         }
 229 
 230         return sb.toString();
 231     }
 232 
 233     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 234         StringBuilder sb = new StringBuilder(&quot;&quot;);
 235         for (String equalField : equalFieldList) {
 236             sb.append(val.get(equalField)).append(&quot;_&quot;);
 237         }
 238         return sb.toString();
 239     }
 240 
 241     private KuduScanner getConn(KuduSideTableInfo tableInfo) {
 242         try {
 243             if (client == null) {
 244                 String kuduMasters = tableInfo.getKuduMasters();
 245                 String tableName = tableInfo.getTableName();
 246                 Integer workerCount = tableInfo.getWorkerCount();
 247                 Integer defaultSocketReadTimeoutMs = tableInfo.getDefaultSocketReadTimeoutMs();
 248                 Integer defaultOperationTimeoutMs = tableInfo.getDefaultOperationTimeoutMs();
 249 
 250                 Preconditions.checkNotNull(kuduMasters, &quot;kuduMasters could not be null&quot;);
 251 
<abbr title=" 252                 KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMasters);"> 252                 KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMasüîµ</abbr>
 253                 if (null != workerCount) {
 254                     kuduClientBuilder.workerCount(workerCount);
 255                 }
 256 
 257                 if (null != defaultOperationTimeoutMs) {
 258                     kuduClientBuilder.defaultOperationTimeoutMs(defaultOperationTimeoutMs);
 259                 }
 260                 client = kuduClientBuilder.build();
 261 
 262                 if (!client.tableExists(tableName)) {
 263                     throw new IllegalArgumentException(&quot;Table Open Failed , please check table exists&quot;);
 264                 }
 265                 table = client.openTable(tableName);
 266             }
 267             Schema schema = table.getSchema();
 268             KuduScanner.KuduScannerBuilder tokenBuilder = client.newScannerBuilder(table);
 269             return buildScanner(tokenBuilder, schema, tableInfo);
 270         } catch (Exception e) {
 271             LOG.error(&quot;connect kudu is error:&quot; + e.getMessage());
 272             throw new RuntimeException(e);
 273         }
 274     }
 275 
 276 
 277     /**
 278      * @param builder   ÂàõÂª∫AsyncKuduScannerÂØπË±°
 279      * @param schema    kudu‰∏≠Ë°®Á∫¶Êùü
 280      * @param tableInfo AsyncKuduScannerÁöÑÈÖçÁΩÆ‰ø°ÊÅØ
 281      * @return
 282      */
<abbr title=" 283     private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableInfo tableInfo) {"> 283     private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableüîµ</abbr>
 284         Integer batchSizeBytes = tableInfo.getBatchSizeBytes();
 285         Long limitNum = tableInfo.getLimitNum();
 286         Boolean isFaultTolerant = tableInfo.getFaultTolerant();
 287         //Êü•ËØ¢ÈúÄË¶ÅÁöÑÂ≠óÊÆµ
 288         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 289         //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ∞èÂÄº
 290         String lowerBoundPrimaryKey = tableInfo.getLowerBoundPrimaryKey();
 291         //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ§ßÂÄº
 292         String upperBoundPrimaryKey = tableInfo.getUpperBoundPrimaryKey();
 293         //‰∏ªÈîÆÂ≠óÊÆµ
 294         String primaryKeys = tableInfo.getPrimaryKey();
 295         if (null == limitNum || limitNum &lt;= 0) {
 296             builder.limit(FETCH_SIZE);
 297         } else {
 298             builder.limit(limitNum);
 299         }
 300         if (null != batchSizeBytes) {
 301             builder.batchSizeBytes(batchSizeBytes);
 302         }
 303         if (null != isFaultTolerant) {
 304             builder.setFaultTolerant(isFaultTolerant);
 305         }
 306         //  Â°´ÂÖÖË∞ìËØç‰ø°ÊÅØ
 307         List&lt;PredicateInfo&gt; predicateInfoes = sideInfo.getSideTableInfo().getPredicateInfoes();
 308         if (predicateInfoes.size() &gt; 0) {
 309             predicateInfoes.stream().map(info -&gt; {
 310                 KuduPredicate kuduPredicate = KuduUtil.buildKuduPredicate(schema, info);
 311                 if (null != kuduPredicate) {
 312                     builder.addPredicate(kuduPredicate);
 313                 }
 314                 return info;
 315             }).count();
 316         }
 317 
 318         if (null != lowerBoundPrimaryKey &amp;&amp; null != upperBoundPrimaryKey &amp;&amp; null != primaryKeys) {
 319             List&lt;ColumnSchema&gt; columnSchemas = schema.getPrimaryKeyColumns();
 320             Map&lt;String, Integer&gt; columnName = new HashMap&lt;String, Integer&gt;(columnSchemas.size());
 321             for (int i = 0; i &lt; columnSchemas.size(); i++) {
 322                 columnName.put(columnSchemas.get(i).getName(), i);
 323             }
 324             String[] primaryKey = splitString(primaryKeys);
 325             String[] lowerBounds = splitString(lowerBoundPrimaryKey);
 326             String[] upperBounds = splitString(upperBoundPrimaryKey);
 327             PartialRow lowerPartialRow = schema.newPartialRow();
 328             PartialRow upperPartialRow = schema.newPartialRow();
 329             for (int i = 0; i &lt; primaryKey.length; i++) {
 330                 Integer index = columnName.get(primaryKey[i]);
<abbr title=" 331                 KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[i], lowerBounds[i]);"> 331                 KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[üîµ</abbr>
<abbr title=" 332                 KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[i], upperBounds[i]);"> 332                 KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[üîµ</abbr>
 333             }
 334             builder.lowerBound(lowerPartialRow);
 335             builder.exclusiveUpperBound(upperPartialRow);
 336         }
 337         List&lt;String&gt; projectColumns = Arrays.asList(sideFieldNames);
 338         return builder.setProjectedColumnNames(projectColumns).build();
 339     }
 340 
 341     private String[] splitString(String data) {
 342         return StringUtils.split(data, &quot;,&quot;);
 343     }
 344 
 345     @Override
 346     public void close() throws Exception {
 347         //ÂÖ¨Áî®‰∏Ä‰∏™client  Â¶ÇÊûúÊØèÊ¨°Âà∑Êñ∞Èó¥ÈöîÊó∂Èó¥ËæÉÈïøÂèØ‰ª•ÊØèÊ¨°Ëé∑Âèñ‰∏Ä‰∏™
 348         super.close();
 349         if (null != client) {
 350             try {
 351                 client.close();
 352             } catch (Exception e) {
 353                 LOG.error(&quot;Error while closing client.&quot;, e);
 354             }
 355         }
 356     }
 357 }</pre></td>
                            <td><pre>   1 package com.dtstack.flink.sql.side.kudu;
   2 
   3 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
   4 import com.dtstack.flink.sql.side.BaseAllReqRow;
   5 import com.dtstack.flink.sql.side.FieldInfo;
   6 import com.dtstack.flink.sql.side.JoinInfo;
   7 import com.dtstack.flink.sql.side.PredicateInfo;
   8 import com.dtstack.flink.sql.side.kudu.table.KuduSideTableInfo;
   9 import com.dtstack.flink.sql.side.kudu.utils.KuduUtil;
  10 import com.dtstack.flink.sql.util.RowDataComplete;
  11 import com.google.common.base.Preconditions;
  12 import com.google.common.collect.Lists;
  13 import com.google.common.collect.Maps;
  14 import java.sql.SQLException;
  15 import java.util.Arrays;
  16 import java.util.Calendar;
  17 import java.util.HashMap;
  18 import java.util.List;
  19 import java.util.Map;
  20 import java.util.concurrent.atomic.AtomicReference;
  21 import org.apache.calcite.sql.JoinType;
  22 import org.apache.commons.collections.CollectionUtils;
  23 import org.apache.commons.lang3.StringUtils;
  24 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  25 import org.apache.flink.table.dataformat.BaseRow;
  26 import org.apache.flink.types.Row;
  27 import org.apache.flink.util.Collector;
  28 import org.apache.kudu.ColumnSchema;
  29 import org.apache.kudu.Schema;
  30 import org.apache.kudu.client.KuduClient;
  31 import org.apache.kudu.client.KuduException;
  32 import org.apache.kudu.client.KuduPredicate;
  33 import org.apache.kudu.client.KuduScanner;
  34 import org.apache.kudu.client.KuduTable;
  35 import org.apache.kudu.client.PartialRow;
  36 import org.apache.kudu.client.RowResult;
  37 import org.apache.kudu.client.RowResultIterator;
  38 import org.slf4j.Logger;
  39 import org.slf4j.LoggerFactory;
  40 
  41 
  42 public class KuduAllReqRow extends BaseAllReqRow {
  43     private static final long serialVersionUID = 6051774809356082219L;
  44 
  45     private static final Logger LOG = LoggerFactory.getLogger(KuduAllReqRow.class);
  46 
  47     /**
  48      * Ëé∑ÂèñËøûÊé•ÁöÑÂ∞ùËØïÊ¨°Êï∞
  49      */
  50     private static final int CONN_RETRY_NUM = 3;
  51 
  52     /**
  53      * ÁºìÂ≠òÊù°Êï∞
  54      */
  55     private static final Long FETCH_SIZE = 1000L;
  56 
  57     private KuduClient client;
  58 
  59     private KuduTable table;
  60 
  61     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  62 
<abbr title="  63     public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  63     public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, Abüîµ</abbr>
  64         super(new KuduAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  65     }
  66 
  67     @Override
  68     protected void initCache() throws SQLException {
  69         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  70         cacheRef.set(newCache);
  71         loadData(newCache);
  72     }
  73 
  74     @Override
  75     protected void reloadCache() {
  76         //reload cacheRef and replace to old cacheRef
  77         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  78         loadData(newCache);
  79 
  80         cacheRef.set(newCache);
  81         LOG.info(&quot;----- kudu all cacheRef reload end:{}&quot;, Calendar.getInstance());
  82     }
  83 
  84     @Override
  85     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
  86         List&lt;Object&gt; inputParams = Lists.newArrayList();
  87         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
  88             Object equalObj = input.getField(conValIndex);
  89             if (equalObj == null) {
  90                 out.collect(null);
  91             }
  92             inputParams.add(equalObj);
  93         }
  94         String key = buildKey(inputParams);
  95         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
  96         if (CollectionUtils.isEmpty(cacheList)) {
  97             if (sideInfo.getJoinType() == JoinType.LEFT) {
  98                 Row row = fillData(input, null);
  99                 RowDataComplete.collectRow(out, row);
 100             }
 101             return;
 102         }
 103         for (Map&lt;String, Object&gt; one : cacheList) {
 104             Row row = fillData(input, one);
 105             RowDataComplete.collectRow(out, row);
 106         }
 107     }
 108 
 109     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) {
 110         KuduSideTableInfo tableInfo = (KuduSideTableInfo) sideInfo.getSideTableInfo();
 111         KuduScanner scanner = null;
 112         try {
 113             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 114                 try {
 115                     scanner = getConn(tableInfo);
 116                     break;
 117                 } catch (Exception e) {
 118                     if (i == CONN_RETRY_NUM - 1) {
 119                         throw new RuntimeException(&quot;&quot;, e);
 120                     }
 121                     try {
<abbr title=" 122                         String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tableInfo.getTableName();"> 122                         String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tüîµ</abbr>
 123                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 124                         Thread.sleep(5 * 1000);
 125                     } catch (InterruptedException e1) {
 126                         LOG.error(&quot;&quot;,e1);
 127                     }
 128                 }
 129             }
 130             //load data from table
 131             assert scanner != null;
 132             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 133 
 134 
 135             while (scanner.hasMoreRows()) {
 136                 RowResultIterator results = scanner.nextRows();
 137                 while (results.hasNext()) {
 138                     RowResult result = results.next();
 139                     Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 140                     for (String sideFieldName1 : sideFieldNames) {
 141                         String sideFieldName = sideFieldName1.trim();
 142                         ColumnSchema columnSchema = table.getSchema().getColumn(sideFieldName);
 143                         if (null != columnSchema) {
 144                             KuduUtil.setMapValue(columnSchema.getType(), oneRow, sideFieldName, result);
 145                         }
 146                     }
 147                     String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 148                     List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 148                     List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newAüîµ</abbr>
 149                     list.add(oneRow);
 150                 }
 151             }
 152 
 153         } catch (Exception e) {
 154             LOG.error(&quot;&quot;, e);
 155         } finally {
 156             if (null != scanner) {
 157                 try {
 158                     scanner.close();
 159                 } catch (KuduException e) {
 160                     LOG.error(&quot;Error while closing scanner.&quot;, e);
 161                 }
 162             }
 163         }
 164 
 165 
 166     }
 167 
 168     private String buildKey(List&lt;Object&gt; equalValList) {
 169         StringBuilder sb = new StringBuilder(&quot;&quot;);
 170         for (Object equalVal : equalValList) {
 171             sb.append(equalVal).append(&quot;_&quot;);
 172         }
 173 
 174         return sb.toString();
 175     }
 176 
 177     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 178         StringBuilder sb = new StringBuilder(&quot;&quot;);
 179         for (String equalField : equalFieldList) {
 180             sb.append(val.get(equalField)).append(&quot;_&quot;);
 181         }
 182         return sb.toString();
 183     }
 184 
 185     private KuduScanner getConn(KuduSideTableInfo tableInfo) {
 186         try {
 187             if (client == null) {
 188                 String kuduMasters = tableInfo.getKuduMasters();
 189                 String tableName = tableInfo.getTableName();
 190                 Integer workerCount = tableInfo.getWorkerCount();
 191                 Integer defaultSocketReadTimeoutMs = tableInfo.getDefaultSocketReadTimeoutMs();
 192                 Integer defaultOperationTimeoutMs = tableInfo.getDefaultOperationTimeoutMs();
 193 
 194                 Preconditions.checkNotNull(kuduMasters, &quot;kuduMasters could not be null&quot;);
 195 
<abbr title=" 196                 KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMasters);"> 196                 KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMasüîµ</abbr>
 197                 if (null != workerCount) {
 198                     kuduClientBuilder.workerCount(workerCount);
 199                 }
 200 
 201                 if (null != defaultOperationTimeoutMs) {
 202                     kuduClientBuilder.defaultOperationTimeoutMs(defaultOperationTimeoutMs);
 203                 }
 204                 client = kuduClientBuilder.build();
 205 
 206                 if (!client.tableExists(tableName)) {
 207                     throw new IllegalArgumentException(&quot;Table Open Failed , please check table exists&quot;);
 208                 }
 209                 table = client.openTable(tableName);
 210             }
 211             Schema schema = table.getSchema();
 212             KuduScanner.KuduScannerBuilder tokenBuilder = client.newScannerBuilder(table);
 213             return buildScanner(tokenBuilder, schema, tableInfo);
 214         } catch (Exception e) {
 215             LOG.error(&quot;connect kudu is error:&quot; + e.getMessage());
 216             throw new RuntimeException(e);
 217         }
 218     }
 219 
 220     /**
 221      * @param builder   ÂàõÂª∫AsyncKuduScannerÂØπË±°
 222      * @param schema    kudu‰∏≠Ë°®Á∫¶Êùü
 223      * @param tableInfo AsyncKuduScannerÁöÑÈÖçÁΩÆ‰ø°ÊÅØ
 224      * @return
 225      */
<abbr title=" 226     private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableInfo tableInfo) {"> 226     private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableüîµ</abbr>
 227         Integer batchSizeBytes = tableInfo.getBatchSizeBytes();
 228         Long limitNum = tableInfo.getLimitNum();
 229         Boolean isFaultTolerant = tableInfo.getFaultTolerant();
 230         //Êü•ËØ¢ÈúÄË¶ÅÁöÑÂ≠óÊÆµ
 231         String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 232         //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ∞èÂÄº
 233         String lowerBoundPrimaryKey = tableInfo.getLowerBoundPrimaryKey();
 234         //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ§ßÂÄº
 235         String upperBoundPrimaryKey = tableInfo.getUpperBoundPrimaryKey();
 236         //‰∏ªÈîÆÂ≠óÊÆµ
 237         String primaryKeys = tableInfo.getPrimaryKey();
 238         if (null == limitNum || limitNum &lt;= 0) {
 239             builder.limit(FETCH_SIZE);
 240         } else {
 241             builder.limit(limitNum);
 242         }
 243         if (null != batchSizeBytes) {
 244             builder.batchSizeBytes(batchSizeBytes);
 245         }
 246         if (null != isFaultTolerant) {
 247             builder.setFaultTolerant(isFaultTolerant);
 248         }
 249         //  Â°´ÂÖÖË∞ìËØç‰ø°ÊÅØ
 250         List&lt;PredicateInfo&gt; predicateInfoes = sideInfo.getSideTableInfo().getPredicateInfoes();
 251         if (predicateInfoes.size() &gt; 0) {
 252             predicateInfoes.stream().map(info -&gt; {
 253                 KuduPredicate kuduPredicate = KuduUtil.buildKuduPredicate(schema, info);
 254                 if (null != kuduPredicate) {
 255                     builder.addPredicate(kuduPredicate);
 256                 }
 257                 return info;
 258             }).count();
 259         }
 260 
 261         if (null != lowerBoundPrimaryKey &amp;&amp; null != upperBoundPrimaryKey &amp;&amp; null != primaryKeys) {
 262             List&lt;ColumnSchema&gt; columnSchemas = schema.getPrimaryKeyColumns();
 263             Map&lt;String, Integer&gt; columnName = new HashMap&lt;String, Integer&gt;(columnSchemas.size());
 264             for (int i = 0; i &lt; columnSchemas.size(); i++) {
 265                 columnName.put(columnSchemas.get(i).getName(), i);
 266             }
 267             String[] primaryKey = splitString(primaryKeys);
 268             String[] lowerBounds = splitString(lowerBoundPrimaryKey);
 269             String[] upperBounds = splitString(upperBoundPrimaryKey);
 270             PartialRow lowerPartialRow = schema.newPartialRow();
 271             PartialRow upperPartialRow = schema.newPartialRow();
 272             for (int i = 0; i &lt; primaryKey.length; i++) {
 273                 Integer index = columnName.get(primaryKey[i]);
<abbr title=" 274                 KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[i], lowerBounds[i]);"> 274                 KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[üîµ</abbr>
<abbr title=" 275                 KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[i], upperBounds[i]);"> 275                 KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[üîµ</abbr>
 276             }
 277             builder.lowerBound(lowerPartialRow);
 278             builder.exclusiveUpperBound(upperPartialRow);
 279         }
 280         List&lt;String&gt; projectColumns = Arrays.asList(sideFieldNames);
 281         return builder.setProjectedColumnNames(projectColumns).build();
 282     }
 283 
 284     private String[] splitString(String data) {
 285         return StringUtils.split(data, &quot;,&quot;);
 286     }
 287 
 288     @Override
 289     public void close() throws Exception {
 290         //ÂÖ¨Áî®‰∏Ä‰∏™client  Â¶ÇÊûúÊØèÊ¨°Âà∑Êñ∞Èó¥ÈöîÊó∂Èó¥ËæÉÈïøÂèØ‰ª•ÊØèÊ¨°Ëé∑Âèñ‰∏Ä‰∏™
 291         super.close();
 292         if (null != client) {
 293             try {
 294                 client.close();
 295             } catch (Exception e) {
 296                 LOG.error(&quot;Error while closing client.&quot;, e);
 297             }
 298         }
 299     }
 300 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.dtstack.flink.sql.side.kudu;
   2  
   3  import com.dtstack.flink.sql.side.BaseAllReqRow;
   4  import com.dtstack.flink.sql.side.FieldInfo;
   5  import com.dtstack.flink.sql.side.JoinInfo;
   6  import com.dtstack.flink.sql.side.PredicateInfo;
   7  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
   8  import com.dtstack.flink.sql.side.kudu.table.KuduSideTableInfo;
   9  import com.dtstack.flink.sql.side.kudu.utils.KuduUtil;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  10 +import com.dtstack.flink.sql.util.RowDataComplete;</span>
  11  import com.google.common.base.Preconditions;
  12  import com.google.common.collect.Lists;
  13  import com.google.common.collect.Maps;
  14  import org.apache.calcite.sql.JoinType;
  15  import org.apache.commons.collections.CollectionUtils;
  16  import org.apache.commons.lang3.StringUtils;
  17  import org.apache.flink.api.java.typeutils.RowTypeInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  18 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  19 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  20 +import org.apache.flink.table.dataformat.BaseRow;</span>
  21  import org.apache.flink.types.Row;
  22  import org.apache.flink.util.Collector;
  23  import org.apache.kudu.ColumnSchema;
  24  import org.apache.kudu.Schema;
  25  import org.apache.kudu.client.KuduClient;
  26  import org.apache.kudu.client.KuduException;
  27  import org.apache.kudu.client.KuduPredicate;
  28  import org.apache.kudu.client.KuduScanner;
  29  import org.apache.kudu.client.KuduTable;
  30  import org.apache.kudu.client.PartialRow;
  31  import org.apache.kudu.client.RowResult;
  32  import org.apache.kudu.client.RowResultIterator;
  33  import org.slf4j.Logger;
  34  import org.slf4j.LoggerFactory;
  35  
  36  import java.sql.SQLException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import java.sql.Timestamp;</span>
  38  import java.util.Arrays;
  39  import java.util.Calendar;
  40  import java.util.HashMap;
  41  import java.util.List;
  42  import java.util.Map;
  43  import java.util.concurrent.atomic.AtomicReference;
  44  
  45  public class KuduAllReqRow extends BaseAllReqRow {
  46  
  47      private static final long serialVersionUID = 6051774809356082219L;
  48  
  49      private static final Logger LOG = LoggerFactory.getLogger(KuduAllReqRow.class);
  50      /**
  51       * Ëé∑ÂèñËøûÊé•ÁöÑÂ∞ùËØïÊ¨°Êï∞
  52       */
  53      private static final int CONN_RETRY_NUM = 3;
  54      /**
  55       * ÁºìÂ≠òÊù°Êï∞
  56       */
  57      private static final Long FETCH_SIZE = 1000L;
  58  
  59      private KuduClient client;
  60  
  61      private KuduTable table;
  62  
  63  
  64      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  65  
<abbr title="  66      public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  66      public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSidüîµ</abbr>
  67          super(new KuduAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  68      }
  69  
  70  
  71      @Override
  72      public Row fillData(Row input, Object sideInput) {
  73          Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  74          Row row = new Row(sideInfo.getOutFieldInfoList().size());
  75          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  76              Object obj = input.getField(entry.getValue());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  77 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  77 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoüîµ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  79 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  79 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL timüîµ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -            if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -                //ÂéªÈô§‰∏ä‰∏ÄÂ±ÇOutputRowtimeProcessFunction Ë∞ÉÁî®Êó∂Âå∫ÂØºËá¥ÁöÑÂΩ±Âìç</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -                obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  84 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +            obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
  86              row.setField(entry.getKey(), obj);
  87          }
  88  
  89          for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
  90              if (cacheInfo == null) {
  91                  row.setField(entry.getKey(), null);
  92              } else {
  93                  row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
  94              }
  95          }
  96  
  97          return row;
  98      }
  99  
 100      @Override
 101      protected void initCache() throws SQLException {
 102          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 103          cacheRef.set(newCache);
 104          loadData(newCache);
 105      }
 106  
 107  
 108      @Override
 109      protected void reloadCache() {
 110          //reload cacheRef and replace to old cacheRef
 111          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 112          loadData(newCache);
 113  
 114          cacheRef.set(newCache);
 115          LOG.info(&quot;----- kudu all cacheRef reload end:{}&quot;, Calendar.getInstance());
 116      }
 117  
 118  
 119      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -    public void flatMap(CRow input, Collector&lt;CRow&gt; out) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +    public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {</span>
 122          List&lt;Object&gt; inputParams = Lists.newArrayList();
 123          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -            Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +            Object equalObj = input.getField(conValIndex);</span>
 126              if (equalObj == null) {
 127                  out.collect(null);
 128              }
 129              inputParams.add(equalObj);
 130          }
 131  
 132          String key = buildKey(inputParams);
 133          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 134          if (CollectionUtils.isEmpty(cacheList)) {
 135              if (sideInfo.getJoinType() == JoinType.LEFT) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -                Row row = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -                out.collect(new CRow(row, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +                Row row = fillData(input, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 139 +                RowDataComplete.collectRow(out, row);</span>
 140              }
 141              return;
 142          }
 143  
 144          for (Map&lt;String, Object&gt; one : cacheList) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -            out.collect(new CRow(fillData(input.row(), one), input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +            Row row = fillData(input, one);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +            RowDataComplete.collectRow(out, row);</span>
 148          }
 149      }
 150  
 151      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) {
 152          KuduSideTableInfo tableInfo = (KuduSideTableInfo) sideInfo.getSideTableInfo();
 153          KuduScanner scanner = null;
 154          try {
 155              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 156                  try {
 157                      scanner = getConn(tableInfo);
 158                      break;
 159                  } catch (Exception e) {
 160                      if (i == CONN_RETRY_NUM - 1) {
 161                          throw new RuntimeException(&quot;&quot;, e);
 162                      }
 163                      try {
<abbr title=" 164                          String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tableInfo.getTableName();"> 164                          String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tableInfo.üîµ</abbr>
 165                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 166                          Thread.sleep(5 * 1000);
 167                      } catch (InterruptedException e1) {
 168                          LOG.error(&quot;&quot;,e1);
 169                      }
 170                  }
 171              }
 172              //load data from table
 173              assert scanner != null;
 174              String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 175  
 176  
 177              while (scanner.hasMoreRows()) {
 178                  RowResultIterator results = scanner.nextRows();
 179                  while (results.hasNext()) {
 180                      RowResult result = results.next();
 181                      Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 182                      for (String sideFieldName1 : sideFieldNames) {
 183                          String sideFieldName = sideFieldName1.trim();
 184                          ColumnSchema columnSchema = table.getSchema().getColumn(sideFieldName);
 185                          if (null != columnSchema) {
 186                              KuduUtil.setMapValue(columnSchema.getType(), oneRow, sideFieldName, result);
 187                          }
 188                      }
 189                      String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 190                      List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 190                      List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList(üîµ</abbr>
 191                      list.add(oneRow);
 192                  }
 193              }
 194  
 195          } catch (Exception e) {
 196              LOG.error(&quot;&quot;, e);
 197          } finally {
 198              if (null != scanner) {
 199                  try {
 200                      scanner.close();
 201                  } catch (KuduException e) {
 202                      LOG.error(&quot;Error while closing scanner.&quot;, e);
 203                  }
 204              }
 205          }
 206  
 207  
 208      }
 209  
 210      private String buildKey(List&lt;Object&gt; equalValList) {
 211          StringBuilder sb = new StringBuilder(&quot;&quot;);
 212          for (Object equalVal : equalValList) {
 213              sb.append(equalVal).append(&quot;_&quot;);
 214          }
 215  
 216          return sb.toString();
 217      }
 218  
 219      private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 220          StringBuilder sb = new StringBuilder(&quot;&quot;);
 221          for (String equalField : equalFieldList) {
 222              sb.append(val.get(equalField)).append(&quot;_&quot;);
 223          }
 224          return sb.toString();
 225      }
 226  
 227      private KuduScanner getConn(KuduSideTableInfo tableInfo) {
 228          try {
 229              if (client == null) {
 230                  String kuduMasters = tableInfo.getKuduMasters();
 231                  String tableName = tableInfo.getTableName();
 232                  Integer workerCount = tableInfo.getWorkerCount();
 233                  Integer defaultSocketReadTimeoutMs = tableInfo.getDefaultSocketReadTimeoutMs();
 234                  Integer defaultOperationTimeoutMs = tableInfo.getDefaultOperationTimeoutMs();
 235  
 236                  Preconditions.checkNotNull(kuduMasters, &quot;kuduMasters could not be null&quot;);
 237  
 238                  KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMasters);
 239                  if (null != workerCount) {
 240                      kuduClientBuilder.workerCount(workerCount);
 241                  }
 242  
 243                  if (null != defaultOperationTimeoutMs) {
 244                      kuduClientBuilder.defaultOperationTimeoutMs(defaultOperationTimeoutMs);
 245                  }
 246                  client = kuduClientBuilder.build();
 247  
 248                  if (!client.tableExists(tableName)) {
 249                      throw new IllegalArgumentException(&quot;Table Open Failed , please check table exists&quot;);
 250                  }
 251                  table = client.openTable(tableName);
 252              }
 253              Schema schema = table.getSchema();
 254              KuduScanner.KuduScannerBuilder tokenBuilder = client.newScannerBuilder(table);
 255              return buildScanner(tokenBuilder, schema, tableInfo);
 256          } catch (Exception e) {
 257              LOG.error(&quot;connect kudu is error:&quot; + e.getMessage());
 258              throw new RuntimeException(e);
 259          }
 260      }
 261  
 262  
 263      /**
 264       * @param builder   ÂàõÂª∫AsyncKuduScannerÂØπË±°
 265       * @param schema    kudu‰∏≠Ë°®Á∫¶Êùü
 266       * @param tableInfo AsyncKuduScannerÁöÑÈÖçÁΩÆ‰ø°ÊÅØ
 267       * @return
 268       */
<abbr title=" 269      private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableInfo tableInfo) {"> 269      private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableInfo tablüîµ</abbr>
 270          Integer batchSizeBytes = tableInfo.getBatchSizeBytes();
 271          Long limitNum = tableInfo.getLimitNum();
 272          Boolean isFaultTolerant = tableInfo.getFaultTolerant();
 273          //Êü•ËØ¢ÈúÄË¶ÅÁöÑÂ≠óÊÆµ
 274          String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 275          //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ∞èÂÄº
 276          String lowerBoundPrimaryKey = tableInfo.getLowerBoundPrimaryKey();
 277          //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ§ßÂÄº
 278          String upperBoundPrimaryKey = tableInfo.getUpperBoundPrimaryKey();
 279          //‰∏ªÈîÆÂ≠óÊÆµ
 280          String primaryKeys = tableInfo.getPrimaryKey();
 281          if (null == limitNum || limitNum &lt;= 0) {
 282              builder.limit(FETCH_SIZE);
 283          } else {
 284              builder.limit(limitNum);
 285          }
 286          if (null != batchSizeBytes) {
 287              builder.batchSizeBytes(batchSizeBytes);
 288          }
 289          if (null != isFaultTolerant) {
 290              builder.setFaultTolerant(isFaultTolerant);
 291          }
 292          //  Â°´ÂÖÖË∞ìËØç‰ø°ÊÅØ
 293          List&lt;PredicateInfo&gt; predicateInfoes = sideInfo.getSideTableInfo().getPredicateInfoes();
 294          if (predicateInfoes.size() &gt; 0) {
 295              predicateInfoes.stream().map(info -&gt; {
 296                  KuduPredicate kuduPredicate = KuduUtil.buildKuduPredicate(schema, info);
 297                  if (null != kuduPredicate) {
 298                      builder.addPredicate(kuduPredicate);
 299                  }
 300                  return info;
 301              }).count();
 302          }
 303  
 304          if (null != lowerBoundPrimaryKey &amp;&amp; null != upperBoundPrimaryKey &amp;&amp; null != primaryKeys) {
 305              List&lt;ColumnSchema&gt; columnSchemas = schema.getPrimaryKeyColumns();
 306              Map&lt;String, Integer&gt; columnName = new HashMap&lt;String, Integer&gt;(columnSchemas.size());
 307              for (int i = 0; i &lt; columnSchemas.size(); i++) {
 308                  columnName.put(columnSchemas.get(i).getName(), i);
 309              }
 310              String[] primaryKey = splitString(primaryKeys);
 311              String[] lowerBounds = splitString(lowerBoundPrimaryKey);
 312              String[] upperBounds = splitString(upperBoundPrimaryKey);
 313              PartialRow lowerPartialRow = schema.newPartialRow();
 314              PartialRow upperPartialRow = schema.newPartialRow();
 315              for (int i = 0; i &lt; primaryKey.length; i++) {
 316                  Integer index = columnName.get(primaryKey[i]);
<abbr title=" 317                  KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[i], lowerBounds[i]);"> 317                  KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[i], lowerüîµ</abbr>
<abbr title=" 318                  KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[i], upperBounds[i]);"> 318                  KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[i], upperüîµ</abbr>
 319              }
 320              builder.lowerBound(lowerPartialRow);
 321              builder.exclusiveUpperBound(upperPartialRow);
 322          }
 323          List&lt;String&gt; projectColumns = Arrays.asList(sideFieldNames);
 324          return builder.setProjectedColumnNames(projectColumns).build();
 325      }
 326  
 327      private String[] splitString(String data) {
 328          return StringUtils.split(data, &quot;,&quot;);
 329      }
 330  
 331      @Override
 332      public void close() throws Exception {
 333          //ÂÖ¨Áî®‰∏Ä‰∏™client  Â¶ÇÊûúÊØèÊ¨°Âà∑Êñ∞Èó¥ÈöîÊó∂Èó¥ËæÉÈïøÂèØ‰ª•ÊØèÊ¨°Ëé∑Âèñ‰∏Ä‰∏™
 334          super.close();
 335          if (null != client) {
 336              try {
 337                  client.close();
 338              } catch (Exception e) {
 339                  LOG.error(&quot;Error while closing client.&quot;, e);
 340              }
 341          }
 342      }
 343  }</pre></td>
                            <td><pre>   1  package com.dtstack.flink.sql.side.kudu;
   2  
   3  import com.dtstack.flink.sql.side.BaseAllReqRow;
   4  import com.dtstack.flink.sql.side.FieldInfo;
   5  import com.dtstack.flink.sql.side.JoinInfo;
   6  import com.dtstack.flink.sql.side.PredicateInfo;
   7  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
   8  import com.dtstack.flink.sql.side.kudu.table.KuduSideTableInfo;
   9  import com.dtstack.flink.sql.side.kudu.utils.KuduUtil;

  10  import com.google.common.base.Preconditions;
  11  import com.google.common.collect.Lists;
  12  import com.google.common.collect.Maps;
  13  import org.apache.calcite.sql.JoinType;
  14  import org.apache.commons.collections.CollectionUtils;
  15  import org.apache.commons.lang3.StringUtils;
  16  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  17  import org.apache.flink.table.runtime.types.CRow;
  18  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;

  19  import org.apache.flink.types.Row;
  20  import org.apache.flink.util.Collector;
  21  import org.apache.kudu.ColumnSchema;
  22  import org.apache.kudu.Schema;
  23  import org.apache.kudu.client.KuduClient;
  24  import org.apache.kudu.client.KuduException;
  25  import org.apache.kudu.client.KuduPredicate;
  26  import org.apache.kudu.client.KuduScanner;
  27  import org.apache.kudu.client.KuduTable;
  28  import org.apache.kudu.client.PartialRow;
  29  import org.apache.kudu.client.RowResult;
  30  import org.apache.kudu.client.RowResultIterator;
  31  import org.slf4j.Logger;
  32  import org.slf4j.LoggerFactory;
  33  
  34  import java.sql.SQLException;
  35  import java.sql.Timestamp;
  36  import java.util.Arrays;
  37  import java.util.Calendar;
  38  import java.util.HashMap;
  39  import java.util.List;
  40  import java.util.Map;
  41  import java.util.concurrent.atomic.AtomicReference;
  42  
  43  public class KuduAllReqRow extends BaseAllReqRow {
  44  
  45      private static final long serialVersionUID = 6051774809356082219L;
  46  
  47      private static final Logger LOG = LoggerFactory.getLogger(KuduAllReqRow.class);
  48      /**
  49       * Ëé∑ÂèñËøûÊé•ÁöÑÂ∞ùËØïÊ¨°Êï∞
  50       */
  51      private static final int CONN_RETRY_NUM = 3;
  52      /**
  53       * ÁºìÂ≠òÊù°Êï∞
  54       */
  55      private static final Long FETCH_SIZE = 1000L;
  56  
  57      private KuduClient client;
  58  
  59      private KuduTable table;
  60  
  61  
  62      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  63  
<abbr title="  64      public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  64      public KuduAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSidüîµ</abbr>
  65          super(new KuduAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  66      }
  67  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -    public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  72 -        Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -        for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -            Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  75 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  75 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoüîµ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  76 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  77 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  77 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL timüîµ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -            if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -                //ÂéªÈô§‰∏ä‰∏ÄÂ±ÇOutputRowtimeProcessFunction Ë∞ÉÁî®Êó∂Âå∫ÂØºËá¥ÁöÑÂΩ±Âìç</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -                obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -            row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  84 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  85 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  86 -        for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -            if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  88 -                row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  89 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -                row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -        return row;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -</span>
  97      @Override
  98      protected void initCache() throws SQLException {
  99          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 100          cacheRef.set(newCache);
 101          loadData(newCache);
 102      }
 103  
 104  
 105      @Override
 106      protected void reloadCache() {
 107          //reload cacheRef and replace to old cacheRef
 108          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 109          loadData(newCache);
 110  
 111          cacheRef.set(newCache);
 112          LOG.info(&quot;----- kudu all cacheRef reload end:{}&quot;, Calendar.getInstance());
 113      }
 114  
 115  
 116      @Override
 117      public void flatMap(CRow input, Collector&lt;CRow&gt; out) throws Exception {

 118          List&lt;Object&gt; inputParams = Lists.newArrayList();
 119          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 120              Object equalObj = input.row().getField(conValIndex);

 121              if (equalObj == null) {
 122                  out.collect(null);
 123              }
 124              inputParams.add(equalObj);
 125          }
 126  
 127          String key = buildKey(inputParams);
 128          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 129          if (CollectionUtils.isEmpty(cacheList)) {
 130              if (sideInfo.getJoinType() == JoinType.LEFT) {
 131                  Row row = fillData(input.row(), null);
 132                  out.collect(new CRow(row, input.change()));


 133              }
 134              return;
 135          }
 136  
 137          for (Map&lt;String, Object&gt; one : cacheList) {
 138              out.collect(new CRow(fillData(input.row(), one), input.change()));


 139          }
 140      }
 141  
 142      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) {
 143          KuduSideTableInfo tableInfo = (KuduSideTableInfo) sideInfo.getSideTableInfo();
 144          KuduScanner scanner = null;
 145          try {
 146              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 147                  try {
 148                      scanner = getConn(tableInfo);
 149                      break;
 150                  } catch (Exception e) {
 151                      if (i == CONN_RETRY_NUM - 1) {
 152                          throw new RuntimeException(&quot;&quot;, e);
 153                      }
 154                      try {
<abbr title=" 155                          String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tableInfo.getTableName();"> 155                          String connInfo = &quot;kuduMasters:&quot; + tableInfo.getKuduMasters() + &quot;;tableName:&quot; + tableInfo.üîµ</abbr>
 156                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 157                          Thread.sleep(5 * 1000);
 158                      } catch (InterruptedException e1) {
 159                          LOG.error(&quot;&quot;,e1);
 160                      }
 161                  }
 162              }
 163              //load data from table
 164              assert scanner != null;
 165              String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 166  
 167  
 168              while (scanner.hasMoreRows()) {
 169                  RowResultIterator results = scanner.nextRows();
 170                  while (results.hasNext()) {
 171                      RowResult result = results.next();
 172                      Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 173                      for (String sideFieldName1 : sideFieldNames) {
 174                          String sideFieldName = sideFieldName1.trim();
 175                          ColumnSchema columnSchema = table.getSchema().getColumn(sideFieldName);
 176                          if (null != columnSchema) {
 177                              KuduUtil.setMapValue(columnSchema.getType(), oneRow, sideFieldName, result);
 178                          }
 179                      }
 180                      String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 181                      List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 181                      List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList(üîµ</abbr>
 182                      list.add(oneRow);
 183                  }
 184              }
 185  
 186          } catch (Exception e) {
 187              LOG.error(&quot;&quot;, e);
 188          } finally {
 189              if (null != scanner) {
 190                  try {
 191                      scanner.close();
 192                  } catch (KuduException e) {
 193                      LOG.error(&quot;Error while closing scanner.&quot;, e);
 194                  }
 195              }
 196          }
 197  
 198  
 199      }
 200  
 201      private String buildKey(List&lt;Object&gt; equalValList) {
 202          StringBuilder sb = new StringBuilder(&quot;&quot;);
 203          for (Object equalVal : equalValList) {
 204              sb.append(equalVal).append(&quot;_&quot;);
 205          }
 206  
 207          return sb.toString();
 208      }
 209  
 210      private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 211          StringBuilder sb = new StringBuilder(&quot;&quot;);
 212          for (String equalField : equalFieldList) {
 213              sb.append(val.get(equalField)).append(&quot;_&quot;);
 214          }
 215          return sb.toString();
 216      }
 217  
 218      private KuduScanner getConn(KuduSideTableInfo tableInfo) {
 219          try {
 220              if (client == null) {
 221                  String kuduMasters = tableInfo.getKuduMasters();
 222                  String tableName = tableInfo.getTableName();
 223                  Integer workerCount = tableInfo.getWorkerCount();
 224                  Integer defaultSocketReadTimeoutMs = tableInfo.getDefaultSocketReadTimeoutMs();
 225                  Integer defaultOperationTimeoutMs = tableInfo.getDefaultOperationTimeoutMs();
 226  
 227                  Preconditions.checkNotNull(kuduMasters, &quot;kuduMasters could not be null&quot;);
 228  
 229                  KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMasters);
 230                  if (null != workerCount) {
 231                      kuduClientBuilder.workerCount(workerCount);
 232                  }
 233  
 234                  if (null != defaultOperationTimeoutMs) {
 235                      kuduClientBuilder.defaultOperationTimeoutMs(defaultOperationTimeoutMs);
 236                  }
 237                  client = kuduClientBuilder.build();
 238  
 239                  if (!client.tableExists(tableName)) {
 240                      throw new IllegalArgumentException(&quot;Table Open Failed , please check table exists&quot;);
 241                  }
 242                  table = client.openTable(tableName);
 243              }
 244              Schema schema = table.getSchema();
 245              KuduScanner.KuduScannerBuilder tokenBuilder = client.newScannerBuilder(table);
 246              return buildScanner(tokenBuilder, schema, tableInfo);
 247          } catch (Exception e) {
 248              LOG.error(&quot;connect kudu is error:&quot; + e.getMessage());
 249              throw new RuntimeException(e);
 250          }
 251      }
 252  
 253  
 254      /**
 255       * @param builder   ÂàõÂª∫AsyncKuduScannerÂØπË±°
 256       * @param schema    kudu‰∏≠Ë°®Á∫¶Êùü
 257       * @param tableInfo AsyncKuduScannerÁöÑÈÖçÁΩÆ‰ø°ÊÅØ
 258       * @return
 259       */
<abbr title=" 260      private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableInfo tableInfo) {"> 260      private KuduScanner buildScanner(KuduScanner.KuduScannerBuilder builder, Schema schema, KuduSideTableInfo tablüîµ</abbr>
 261          Integer batchSizeBytes = tableInfo.getBatchSizeBytes();
 262          Long limitNum = tableInfo.getLimitNum();
 263          Boolean isFaultTolerant = tableInfo.getFaultTolerant();
 264          //Êü•ËØ¢ÈúÄË¶ÅÁöÑÂ≠óÊÆµ
 265          String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 266          //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ∞èÂÄº
 267          String lowerBoundPrimaryKey = tableInfo.getLowerBoundPrimaryKey();
 268          //‰∏ªÈîÆËøáÊª§Êù°‰ª∂ ‰∏ªÈîÆÊúÄÂ§ßÂÄº
 269          String upperBoundPrimaryKey = tableInfo.getUpperBoundPrimaryKey();
 270          //‰∏ªÈîÆÂ≠óÊÆµ
 271          String primaryKeys = tableInfo.getPrimaryKey();
 272          if (null == limitNum || limitNum &lt;= 0) {
 273              builder.limit(FETCH_SIZE);
 274          } else {
 275              builder.limit(limitNum);
 276          }
 277          if (null != batchSizeBytes) {
 278              builder.batchSizeBytes(batchSizeBytes);
 279          }
 280          if (null != isFaultTolerant) {
 281              builder.setFaultTolerant(isFaultTolerant);
 282          }
 283          //  Â°´ÂÖÖË∞ìËØç‰ø°ÊÅØ
 284          List&lt;PredicateInfo&gt; predicateInfoes = sideInfo.getSideTableInfo().getPredicateInfoes();
 285          if (predicateInfoes.size() &gt; 0) {
 286              predicateInfoes.stream().map(info -&gt; {
 287                  KuduPredicate kuduPredicate = KuduUtil.buildKuduPredicate(schema, info);
 288                  if (null != kuduPredicate) {
 289                      builder.addPredicate(kuduPredicate);
 290                  }
 291                  return info;
 292              }).count();
 293          }
 294  
 295          if (null != lowerBoundPrimaryKey &amp;&amp; null != upperBoundPrimaryKey &amp;&amp; null != primaryKeys) {
 296              List&lt;ColumnSchema&gt; columnSchemas = schema.getPrimaryKeyColumns();
 297              Map&lt;String, Integer&gt; columnName = new HashMap&lt;String, Integer&gt;(columnSchemas.size());
 298              for (int i = 0; i &lt; columnSchemas.size(); i++) {
 299                  columnName.put(columnSchemas.get(i).getName(), i);
 300              }
 301              String[] primaryKey = splitString(primaryKeys);
 302              String[] lowerBounds = splitString(lowerBoundPrimaryKey);
 303              String[] upperBounds = splitString(upperBoundPrimaryKey);
 304              PartialRow lowerPartialRow = schema.newPartialRow();
 305              PartialRow upperPartialRow = schema.newPartialRow();
 306              for (int i = 0; i &lt; primaryKey.length; i++) {
 307                  Integer index = columnName.get(primaryKey[i]);
<abbr title=" 308                  KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[i], lowerBounds[i]);"> 308                  KuduUtil.primaryKeyRange(lowerPartialRow, columnSchemas.get(index).getType(), primaryKey[i], lowerüîµ</abbr>
<abbr title=" 309                  KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[i], upperBounds[i]);"> 309                  KuduUtil.primaryKeyRange(upperPartialRow, columnSchemas.get(index).getType(), primaryKey[i], upperüîµ</abbr>
 310              }
 311              builder.lowerBound(lowerPartialRow);
 312              builder.exclusiveUpperBound(upperPartialRow);
 313          }
 314          List&lt;String&gt; projectColumns = Arrays.asList(sideFieldNames);
 315          return builder.setProjectedColumnNames(projectColumns).build();
 316      }
 317  
 318      private String[] splitString(String data) {
 319          return StringUtils.split(data, &quot;,&quot;);
 320      }
 321  
 322      @Override
 323      public void close() throws Exception {
 324          //ÂÖ¨Áî®‰∏Ä‰∏™client  Â¶ÇÊûúÊØèÊ¨°Âà∑Êñ∞Èó¥ÈöîÊó∂Èó¥ËæÉÈïøÂèØ‰ª•ÊØèÊ¨°Ëé∑Âèñ‰∏Ä‰∏™
 325          super.close();
 326          if (null != client) {
 327              try {
 328                  client.close();
 329              } catch (Exception e) {
 330                  LOG.error(&quot;Error while closing client.&quot;, e);
 331              }
 332          }
 333      }
 334  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            