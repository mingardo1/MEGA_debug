<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>252</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    252
                    <a href="251.html">prev</a>
                    <a href="253.html">next</a>
                    <a href="252_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_522131259c6f69ad7467dfcaf422c74f0f4c667c_admin/broadleaf-admin-module/src/main/java/org/broadleafcommerce/admin/server/service/handler/SkuCustomPersistenceHandler.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;522131259c6f69ad7467dfcaf422c74f0f4c667c:admin/broadleaf-admin-module/src/main/java/org/broadleafcommerce/admin/server/service/handler/SkuCustomPersistenceHandler.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;522131259c6f69ad7467dfcaf422c74f0f4c667c^1:admin/broadleaf-admin-module/src/main/java/org/broadleafcommerce/admin/server/service/handler/SkuCustomPersistenceHandler.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;522131259c6f69ad7467dfcaf422c74f0f4c667c^2:admin/broadleaf-admin-module/src/main/java/org/broadleafcommerce/admin/server/service/handler/SkuCustomPersistenceHandler.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;f5f52a0a63fcbc018b0183c6fbb4fa4c84da7d26:admin/broadleaf-admin-module/src/main/java/org/broadleafcommerce/admin/server/service/handler/SkuCustomPersistenceHandler.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [b], [s]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Admin Module
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.admin.server.service.handler;
  20 
  21 import static com.google.common.base.CharMatcher.DIGIT;
  22 
  23 import org.apache.commons.collections.CollectionUtils;
  24 import org.apache.commons.collections.Transformer;
  25 import org.apache.commons.lang.BooleanUtils;
  26 import org.apache.commons.lang3.ArrayUtils;
  27 import org.apache.commons.lang3.StringUtils;
  28 import org.apache.commons.lang3.math.NumberUtils;
  29 import org.apache.commons.logging.Log;
  30 import org.apache.commons.logging.LogFactory;
  31 import org.broadleafcommerce.admin.server.service.SkuMetadataCacheService;
  32 import org.broadleafcommerce.common.exception.ServiceException;
  33 import org.broadleafcommerce.common.presentation.client.LookupType;
  34 import org.broadleafcommerce.common.presentation.client.OperationType;
  35 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  36 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  37 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  38 import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  39 import org.broadleafcommerce.common.util.BLCCollectionUtils;
  40 import org.broadleafcommerce.common.util.StringUtil;
  41 import org.broadleafcommerce.common.util.TypedTransformer;
  42 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  43 import org.broadleafcommerce.core.catalog.domain.Product;
  44 import org.broadleafcommerce.core.catalog.domain.ProductBundle;
  45 import org.broadleafcommerce.core.catalog.domain.ProductImpl;
  46 import org.broadleafcommerce.core.catalog.domain.ProductOption;
  47 import org.broadleafcommerce.core.catalog.domain.ProductOptionImpl;
  48 import org.broadleafcommerce.core.catalog.domain.ProductOptionValue;
  49 import org.broadleafcommerce.core.catalog.domain.ProductOptionValueImpl;
  50 import org.broadleafcommerce.core.catalog.domain.Sku;
  51 import org.broadleafcommerce.core.catalog.domain.SkuImpl;
  52 import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXref;
  53 import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXrefImpl;
  54 import org.broadleafcommerce.core.catalog.service.CatalogService;
  55 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  56 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  57 import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;
  58 import org.broadleafcommerce.openadmin.dto.DynamicResultSet;
  59 import org.broadleafcommerce.openadmin.dto.Entity;
  60 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  61 import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;
  62 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  63 import org.broadleafcommerce.openadmin.dto.PersistencePackage;
  64 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  65 import org.broadleafcommerce.openadmin.dto.Property;
  66 import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  67 import org.broadleafcommerce.openadmin.server.dao.DynamicEntityDao;
  68 import org.broadleafcommerce.openadmin.server.service.handler.CustomPersistenceHandlerAdapter;
  69 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  70 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManagerFactory;
  71 import org.broadleafcommerce.openadmin.server.service.persistence.module.InspectHelper;
  72 import org.broadleafcommerce.openadmin.server.service.persistence.module.PersistenceModule;
  73 import org.broadleafcommerce.openadmin.server.service.persistence.module.RecordHelper;
  74 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;
  75 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;
  76 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;
  77 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;
  78 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;
<abbr title="  79 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  79 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
  80 import org.springframework.beans.factory.annotation.Value;
  81 import org.springframework.stereotype.Component;
  82 
  83 import java.io.Serializable;
  84 import java.util.ArrayList;
  85 import java.util.Arrays;
  86 import java.util.Collection;
  87 import java.util.Collections;
  88 import java.util.HashMap;
  89 import java.util.Iterator;
  90 import java.util.List;
  91 import java.util.Map;
  92 
  93 import javax.annotation.Resource;
  94 import javax.persistence.EntityManager;
  95 import javax.persistence.PersistenceContext;
  96 import javax.persistence.TypedQuery;
  97 import javax.persistence.criteria.CriteriaBuilder;
  98 import javax.persistence.criteria.From;
  99 import javax.persistence.criteria.Path;
 100 import javax.persistence.criteria.Predicate;
 101 
 102 /**
 103  * @author Phillip Verheyden
 104  *
 105  */
 106 @Component(&quot;blSkuCustomPersistenceHandler&quot;)
 107 public class SkuCustomPersistenceHandler extends CustomPersistenceHandlerAdapter {
 108 
 109     private static final Log LOG = LogFactory.getLog(SkuCustomPersistenceHandler.class);
 110 
 111     public static String PRODUCT_OPTION_FIELD_PREFIX = &quot;productOption&quot;;
 112     public static String INVENTORY_ONLY_CRITERIA = &quot;onlyInventoryProperties&quot;;
 113 
 114     @Value(&quot;${use.to.one.lookup.sku.product.option.value:false}&quot;)
 115     protected boolean useToOneLookupSkuProductOptionValue = false;
 116 
 117     @Resource(name =&quot;blSkuMetadataCacheService&quot;)
 118     protected SkuMetadataCacheService skuMetadataCacheService;
 119 
 120     @Resource(name=&quot;blAdornedTargetListPersistenceModule&quot;)
 121     protected PersistenceModule adornedPersistenceModule;
 122 
 123     @Resource(name = &quot;blSkuCustomPersistenceHandlerExtensionManager&quot;)
 124     protected SkuCustomPersistenceHandlerExtensionManager extensionManager;
 125 
 126     /**
<abbr title=" 127      * This represents the field that all of the product option values will be stored in. This would be used in the case"> 127      * This represents the field that all of the product option values will be stored in. This would be uðŸ”µ</abbr>
<abbr title=" 128      * where there are a bunch of product options and displaying each option as a grid header would have everything"> 128      * where there are a bunch of product options and displaying each option as a grid header would have ðŸ”µ</abbr>
 129      * squashed together. Filtering on this field is currently unsupported.
 130      */
 131     public static String CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME = &quot;consolidatedProductOptions&quot;;
 132     public static String CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER = &quot;; &quot;;
 133 
 134     @Resource(name=&quot;blCatalogService&quot;)
 135     protected CatalogService catalogService;
 136 
 137     @PersistenceContext(unitName = &quot;blPU&quot;)
 138     protected EntityManager em;
 139 
 140     @Resource(name = &quot;blCriteriaTranslator&quot;)
 141     protected CriteriaTranslator criteriaTranslator;
 142 
 143     @Resource(name = &quot;blSandBoxHelper&quot;)
 144     protected SandBoxHelper sandBoxHelper;
 145 
 146     @Override
 147     public Boolean canHandleInspect(PersistencePackage persistencePackage) {
<abbr title=" 148         return canHandle(persistencePackage, persistencePackage.getPersistencePerspective().getOperationTypes()"> 148         return canHandle(persistencePackage, persistencePackage.getPersistencePerspective().getOperationTðŸ”µ</abbr>
 149                 .getInspectType());
 150     }
 151 
 152     @Override
 153     public Boolean canHandleFetch(PersistencePackage persistencePackage) {
<abbr title=" 154         OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFetchType();"> 154         OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFðŸ”µ</abbr>
 155         return canHandle(persistencePackage, fetchType);
 156     }
 157 
 158     @Override
 159     public Boolean canHandleAdd(PersistencePackage persistencePackage) {
<abbr title=" 160         OperationType addType = persistencePackage.getPersistencePerspective().getOperationTypes().getAddType();"> 160         OperationType addType = persistencePackage.getPersistencePerspective().getOperationTypes().getAddðŸ”µ</abbr>
 161         return canHandle(persistencePackage, addType);
 162     }
 163 
 164     @Override
 165     public Boolean canHandleUpdate(PersistencePackage persistencePackage) {
<abbr title=" 166         OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getUpdateType();"> 166         OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getðŸ”µ</abbr>
 167         return canHandle(persistencePackage, updateType);
 168     }
 169 
 170     /**
<abbr title=" 171      * Since this is the default for all Skus, it&#x27;s possible that we are providing custom criteria for this"> 171      * Since this is the default for all Skus, it&#x27;s possible that we are providing custom criteria for thðŸ”µ</abbr>
<abbr title=" 172      * Sku lookup. In that case, we probably want to delegate to a child class, so only use this particular"> 172      * Sku lookup. In that case, we probably want to delegate to a child class, so only use this particulðŸ”µ</abbr>
<abbr title=" 173      * persistence handler if there is no custom criteria being used and the ceiling entity is an instance of Sku. The"> 173      * persistence handler if there is no custom criteria being used and the ceiling entity is an instancðŸ”µ</abbr>
<abbr title=" 174      * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for the ceiling entity"> 174      * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for thðŸ”µ</abbr>
<abbr title=" 175      * class name. That should be handled by the map structure module though, so only handle things in the Sku custom"> 175      * class name. That should be handled by the map structure module though, so only handle things in thðŸ”µ</abbr>
 176      * persistence handler for OperationType.BASIC
 177      *
 178      */
 179     protected Boolean canHandle(PersistencePackage persistencePackage, OperationType operationType) {
<abbr title=" 180         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 180         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 181         try {
 182             Class testClass = Class.forName(ceilingEntityFullyQualifiedClassname);
 183             return Sku.class.isAssignableFrom(testClass) &amp;&amp;
 184                     //ArrayUtils.isEmpty(persistencePackage.getCustomCriteria()) &amp;&amp;
 185                     OperationType.BASIC.equals(operationType) &amp;&amp;
<abbr title=" 186                     (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.ADORNEDTARGETLIST) == null);"> 186                     (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 187         } catch (ClassNotFoundException e) {
 188             return false;
 189         }
 190     }
 191 
 192     /**
 193      * Build out the extra fields for the product options
 194      */
 195     @Override
<abbr title=" 196     public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, InspectHelper helper) throws ServiceException {"> 196     public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityðŸ”µ</abbr>
 197         try {
<abbr title=" 198             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 198             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 199             Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties = new HashMap&lt;&gt;();
 200 
 201             String productIdStr = getOwningProductId(persistencePackage.getSectionCrumbs());
 202             String cacheKey = skuMetadataCacheService.buildCacheKey(productIdStr);
 203 
 204             Map&lt;String, FieldMetadata&gt; properties = null;
 205             boolean useCache = skuMetadataCacheService.useCache();
 206             if (useCache) {
 207                 properties = skuMetadataCacheService.getFromCache(cacheKey);
 208             }
 209             if (properties == null) {
 210                 //Grab the default properties for the Sku
<abbr title=" 211                 properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspective);"> 211                 properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspecðŸ”µ</abbr>
 212 
 213                 boolean isFirstCriteriaNAN = productIdStr == null;
 214                 if (!isFirstCriteriaNAN &amp;&amp; useToOneLookupSkuProductOptionValue) {
 215 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 216                     isFirstCriteriaNAN = !NumberUtils.isParsable(productIdStr);</span>
 217 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 218                 properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspective);"> 218                 properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspecðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 220                 boolean isFirstCriteriaNAN = persistencePackage.getCustomCriteria() == null || persistencePackage.getCustomCriteria().length == 0;"> 220                 boolean isFirstCriteriaNAN = persistencePackage.getCustomCriteria() == null || persistencðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221                 if (!isFirstCriteriaNAN &amp;&amp; useToOneLookupSkuProductOptionValue) {</span>
 222 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 223                     isFirstCriteriaNAN = !NumberUtils.isNumber(productIdStr);</span>
 224 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 225                 }
 226                 if (isFirstCriteriaNAN) {
 227                     //look up all the ProductOptions and then create new fields for each of them
 228                     List&lt;ProductOption&gt; options = catalogService.readAllProductOptions();
 229                     int order = 0;
 230                     for (ProductOption option : options) {
 231                         //add this to the built Sku properties
 232                         FieldMetadata md = createIndividualOptionField(option, order);
 233                         if (md != null) {
 234                             properties.put(&quot;productOption&quot; + option.getId(), md);
 235                         }
 236                     }
 237                 } else {
 238                     // If we have a product to filter the list of available product options, then use it
 239                     try {
 240                         Long productId = Long.parseLong(productIdStr);
 241                         Product product = catalogService.findProductById(productId);
 242                         for (ProductOption option : product.getProductOptions()) {
 243                             FieldMetadata md = createIndividualOptionField(option, 0);
 244                             if (md != null) {
 245                                 properties.put(&quot;productOption&quot; + option.getId(), md);
 246                             }
 247                         }
 248                     } catch (NumberFormatException e) {
 249                         // there wasn&#x27;t a valid product id, just don&#x27;t do anything
 250                     }
 251                 }
 252 
<abbr title=" 253                 //also build the consolidated field; if using the SkuBasicClientEntityModule then this field will be"> 253                 //also build the consolidated field; if using the SkuBasicClientEntityModule then this fiðŸ”µ</abbr>
 254                 //permanently hidden
<abbr title=" 255                 properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuImpl.class));"> 255                 properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuðŸ”µ</abbr>
 256 
 257                 if (useCache) {
 258                     skuMetadataCacheService.addToCache(cacheKey, properties);
 259                 }
 260             }
 261 
 262             allMergedProperties.put(MergedPropertyType.PRIMARY, properties);
 263 
 264             //allow the adorned list to contribute properties as well in the case of Sku bundle items
 265             adornedPersistenceModule.setPersistenceManager((PersistenceManager)helper);
 266             adornedPersistenceModule.updateMergedProperties(persistencePackage, allMergedProperties);
 267 
<abbr title=" 268             Class&lt;?&gt;[] entityClasses = dynamicEntityDao.getAllPolymorphicEntitiesFromCeiling(SkuImpl.class);"> 268             Class&lt;?&gt;[] entityClasses = dynamicEntityDao.getAllPolymorphicEntitiesFromCeiling(SkuImpl.clasðŸ”µ</abbr>
 269 
<abbr title=" 270             for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.entrySet()) {"> 270             for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.enðŸ”µ</abbr>
 271                 filterOutProductMetadata(entry.getValue());
 272             }
 273 
<abbr title=" 274             ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, allMergedProperties);"> 274             ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, aðŸ”µ</abbr>
 275             DynamicResultSet results = new DynamicResultSet(mergedMetadata, null, null);
 276 
 277             return results;
 278         } catch (Exception e) {
 279             ServiceException ex = new ServiceException(&quot;Unable to retrieve inspection results for &quot; +
 280                     persistencePackage.getCeilingEntityFullyQualifiedClassname(), e);
 281             throw ex;
 282         }
 283     }
 284 
 285     protected String getOwningProductId(SectionCrumb[] sectionCrumbs) {
 286         if (ArrayUtils.isNotEmpty(sectionCrumbs) &amp;&amp; ProductImpl.class.getCanonicalName()
 287                 .equals(sectionCrumbs[0].getSectionIdentifier())) {
 288             return sectionCrumbs[0].getSectionId();
 289         }
 290         return null;
 291     }
 292 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 293 </span>
 294 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 295         List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 296         for (Map.Entry&lt;String, FieldMetadata&gt; entry : map.entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 297             if (entry.getKey().contains(&quot;defaultProduct.&quot;) || entry.getKey().contains(&quot;product.&quot;)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 298                 removeKeys.add(entry.getKey());</span>
 299 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 300     </span>
 301 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 302     protected void filterOutProductMetadata(Map&lt;String, FieldMetadata&gt; map) {
<abbr title=" 303         //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdminPresentation,"> 303         //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdmðŸ”µ</abbr>
 304         //but there&#x27;s a bug preventing this behavior from completely working correctly
 305         List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 306         for (Map.Entry&lt;String, FieldMetadata&gt; entry : map.entrySet()) {
 307             if (entry.getKey().contains(&quot;defaultProduct.&quot;) || entry.getKey().contains(&quot;product.&quot;)) {
 308                 removeKeys.add(entry.getKey());
 309             }
 310         }
 311         for (String removeKey : removeKeys) {
 312             map.remove(removeKey);
 313         }
 314     }
 315 
 316     /**
<abbr title=" 317      * Creates the metadata necessary for displaying all of the product option values in a single field. The display of this"> 317      * Creates the metadata necessary for displaying all of the product option values in a single field. ðŸ”µ</abbr>
<abbr title=" 318      * field is a single string with every product option value appended to it separated by a semicolon. This method should"> 318      * field is a single string with every product option value appended to it separated by a semicolon. ðŸ”µ</abbr>
<abbr title=" 319      * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be populated on fetch."> 319      * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be pðŸ”µ</abbr>
 320      *
<abbr title=" 321      * The metadata that is returned will also be set to prominent by default so that it will be ready to display on whatever"> 321      * The metadata that is returned will also be set to prominent by default so that it will be ready toðŸ”µ</abbr>
<abbr title=" 322      * grid is being inspected. If you do not want this behavior you will need to override this functionality in the metadata"> 322      * grid is being inspected. If you do not want this behavior you will need to override this functionaðŸ”µ</abbr>
 323      * that is returned.
 324      *
<abbr title=" 325      * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, but if you want to"> 325      * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, bðŸ”µ</abbr>
 326      * display this field with a different entity then this should be that entity
 327      * @return
 328      */
 329     public FieldMetadata createConsolidatedOptionField(Class&lt;?&gt; inheritedFromType) {
 330         BasicFieldMetadata metadata = new BasicFieldMetadata();
 331         metadata.setFieldType(SupportedFieldType.STRING);
 332         metadata.setMutable(false);
 333         metadata.setInheritedFromType(inheritedFromType.getName());
 334 
<abbr title=" 335         metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 335         metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useðŸ”µ</abbr>
 336         metadata.setForeignKeyCollection(false);
 337         metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 338 
 339         metadata.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 340         metadata.setFriendlyName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 341         metadata.setGroup(&quot;&quot;);
 342         metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 343         metadata.setProminent(true);
 344         metadata.setVisibility(VisibilityEnum.FORM_HIDDEN);
 345         metadata.setBroadleafEnumeration(&quot;&quot;);
 346         metadata.setReadOnly(true);
 347         metadata.setRequiredOverride(false);
 348         metadata.setGridOrder(Integer.MAX_VALUE);
 349 
 350         return metadata;
 351     }
 352 
 353     /**
<abbr title=" 354      * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed in. This should be"> 354      * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed iðŸ”µ</abbr>
 355      * invoked on a fetch and the returned property should be added to the fetched {@link Entity} dto.
 356      *
 357      * @param values
 358      * @return
 359      * @see {@link #createConsolidatedOptionField(Class)};
 360      */
 361     public Property getConsolidatedOptionProperty(Collection&lt;ProductOptionValue&gt; values) {
 362         Property optionValueProperty = new Property();
 363         optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 364 
 365         //order the values by the display order of their correspond product option
 366         //        Collections.sort(values, new Comparator&lt;ProductOptionValue&gt;() {
 367         //
 368         //            @Override
 369         //            public int compare(ProductOptionValue value1, ProductOptionValue value2) {
<abbr title=" 370         //                return new CompareToBuilder().append(value1.getProductOption().getDisplayOrder(),"> 370         //                return new CompareToBuilder().append(value1.getProductOption().getDisplayOrder(ðŸ”µ</abbr>
 371         //                        value2.getProductOption().getDisplayOrder()).toComparison();
 372         //            }
 373         //        });
 374 
 375         ArrayList&lt;String&gt; stringValues = new ArrayList&lt;&gt;();
 376         CollectionUtils.collect(values, new Transformer() {
 377 
 378             @Override
 379             public Object transform(Object input) {
 380                 return ((ProductOptionValue) input).getAttributeValue();
 381             }
 382         }, stringValues);
 383 
<abbr title=" 384         optionValueProperty.setValue(StringUtils.join(stringValues, CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER));"> 384         optionValueProperty.setValue(StringUtils.join(stringValues, CONSOLIDATED_PRODUCT_OPTIONS_DELIMETEðŸ”µ</abbr>
 385         return optionValueProperty;
 386     }
 387 
 388     /**
 389      * @return a blank {@link Property} corresponding to the CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME
 390      */
 391     public Property getBlankConsolidatedOptionProperty() {
 392         Property optionValueProperty = new Property();
 393         optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 394         optionValueProperty.setValue(&quot;&quot;);
 395         return optionValueProperty;
 396     }
 397 
 398     /**
<abbr title=" 399      * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum field whose values will"> 399      * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum fieðŸ”µ</abbr>
<abbr title=" 400      * be the option values for this option.  This is useful when you would like to display each product option in as its"> 400      * be the option values for this option.  This is useful when you would like to display each product ðŸ”µ</abbr>
 401      * own field in a grid so that you can further filter by product option values.&lt;/p&gt;
<abbr title=" 402      * &lt;p&gt;In order for these fields to be utilized property on the fetch, in the GWT frontend you must use the"> 402      * &lt;p&gt;In order for these fields to be utilized property on the fetch, in the GWT frontend you must usðŸ”µ</abbr>
 403      * for your datasource.&lt;/p&gt;
 404      *
 405      * @param option
 406      * @param order
 407      * @return
 408      */
 409     public FieldMetadata createIndividualOptionField(ProductOption option, int order) {
 410         if (useToOneLookupSkuProductOptionValue) {
 411             return createToOneIndividualOptionField(option, order);
 412         } else {
 413             return createExplicitEnumerationIndividualOptionField(option, order);
 414         }
 415     }
 416 
<abbr title=" 417     protected FieldMetadata createExplicitEnumerationIndividualOptionField(ProductOption option, int order) {"> 417     protected FieldMetadata createExplicitEnumerationIndividualOptionField(ProductOption option, int ordeðŸ”µ</abbr>
 418         BasicFieldMetadata metadata = new BasicFieldMetadata();
 419         List&lt;ProductOptionValue&gt; allowedValues = option.getAllowedValues();
 420         if (CollectionUtils.isNotEmpty(allowedValues)) {
 421             metadata.setFieldType(SupportedFieldType.EXPLICIT_ENUMERATION);
 422             metadata.setMutable(true);
 423             metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 424             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 424             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheServiceðŸ”µ</abbr>
 425             metadata.setForeignKeyCollection(false);
 426             metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 427 
 428             //Set up the enumeration based on the product option values
 429             String[][] optionValues = new String[allowedValues.size()][2];
 430             for (int i = 0; i &lt; allowedValues.size(); i++) {
 431                 ProductOptionValue value = option.getAllowedValues().get(i);
 432                 optionValues[i][0] = value.getId().toString();
 433                 optionValues[i][1] = value.getAttributeValue();
 434             }
 435             metadata.setEnumerationValues(optionValues);
 436 
 437             metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 438             metadata.setFriendlyName(option.getLabel());
 439             metadata.setGroup(&quot;productOption_group&quot;);
 440             metadata.setGroupOrder(-1);
 441             metadata.setOrder(order);
 442             metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 443             metadata.setProminent(false);
 444             metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 445             metadata.setBroadleafEnumeration(&quot;&quot;);
 446             metadata.setReadOnly(false);
 447             metadata.setRequiredOverride(BooleanUtils.isFalse(option.getRequired()));
 448 
 449             return metadata;
 450         }
 451         return null;
 452     }
 453 
 454     /**
<abbr title=" 455      * Using a ToOne lookup performs much better for large product option value lists, speeds up initial page load,"> 455      * Using a ToOne lookup performs much better for large product option value lists, speeds up initial ðŸ”µ</abbr>
<abbr title=" 456      * and is generally more accurate in relation to option value updates and how they impact available selections and cache."> 456      * and is generally more accurate in relation to option value updates and how they impact available sðŸ”µ</abbr>
 457      *
 458      * @param option
 459      * @param order
 460      * @return
 461      */
 462     protected FieldMetadata createToOneIndividualOptionField(ProductOption option, int order) {
 463         PersistenceManager persistenceManager = PersistenceManagerFactory.getPersistenceManager();
 464         FilterMapping filterMapping = new FilterMapping().withDirectFilterValues(
<abbr title=" 465                 sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(new Restriction()"> 465                 sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(newðŸ”µ</abbr>
 466             .withPredicateProvider(new PredicateProvider() {
 467                 @Override
<abbr title=" 468                 public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder, From root,"> 468                 public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuildeðŸ”µ</abbr>
<abbr title=" 469                                                 String ceilingEntity, String fullPropertyName, Path explicitPath, List directValues) {"> 469                                                 String ceilingEntity, String fullPropertyName, Path expliðŸ”µ</abbr>
 470                     return root.get(&quot;productOption&quot;).get(&quot;id&quot;).in(directValues);
 471             }
 472         }));
 473         List&lt;FilterMapping&gt; mappings = new ArrayList&lt;&gt;();
 474         mappings.add(filterMapping);
<abbr title=" 475         TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),"> 475         TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.gðŸ”µ</abbr>
 476                 ProductOptionValueImpl.class.getName(), mappings);
 477         Long count = (Long) countQuery.getSingleResult();
 478         BasicFieldMetadata metadata = null;
 479         if (count &gt; 0) {
 480             metadata = new BasicFieldMetadata();
 481             metadata.setFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 482             metadata.setSecondaryType(SupportedFieldType.INTEGER);
 483             metadata.setForeignKeyProperty(&quot;id&quot;);
 484             metadata.setForeignKeyClass(ProductOptionValueImpl.class.getName());
 485             metadata.setForeignKeyDisplayValueProperty(&quot;attributeValue&quot;);
 486             metadata.setLookupDisplayProperty(&quot;attributeValue&quot;);
 487             metadata.setForeignKeyCollection(false);
 488             metadata.setCustomCriteria(new String[]{&quot;option=&quot; + String.valueOf(option.getId())});
 489             metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 490             metadata.setFriendlyName(option.getLabel());
 491             metadata.setGroup(&quot;productOption_group&quot;);
 492             metadata.setGroupOrder(-1);
 493             metadata.setOrder(order);
 494             metadata.setExplicitFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 495             metadata.setProminent(false);
 496             metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 497             metadata.setReadOnly(false);
<abbr title=" 498             //these may not be actually required, but the CPH has this as a requirement for parsing the data, so we&#x27;ll stick with it here"> 498             //these may not be actually required, but the CPH has this as a requirement for parsing the dðŸ”µ</abbr>
 499             metadata.setRequiredOverride(true);
 500             metadata.setLookupType(LookupType.STANDARD);
 501             metadata.setMutable(true);
 502             metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 503             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 503             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheServiceðŸ”µ</abbr>
 504             metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 505             metadata.setTargetClass(SkuImpl.class.getName());
 506             metadata.setFieldName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 507         }
 508         return metadata;
 509     }
 510 
 511     @SuppressWarnings(&quot;unchecked&quot;)
 512     @Override
<abbr title=" 513     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 513     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynaðŸ”µ</abbr>
<abbr title=" 514         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 514         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 515         try {
<abbr title=" 516             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 516             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 517             //get the default properties from Sku and its subclasses
<abbr title=" 518             Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 518             Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getNameðŸ”µ</abbr>
 519 
 520             //Pull back the Skus based on the criteria from the client
<abbr title=" 521             List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, originalProps);"> 521             List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceðŸ”µ</abbr>
 522 
 523             //allow subclasses to provide additional criteria before executing the query
 524             applyProductOptionValueCriteria(filterMappings, cto, persistencePackage, null);
 525             applySkuBundleItemValueCriteria(filterMappings, cto, persistencePackage);
 526             applyAdditionalFetchCriteria(filterMappings, cto, persistencePackage);
 527 
<abbr title=" 528             List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings, cto.getFirstResult(), cto.getMaxResults());"> 528             List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFðŸ”µ</abbr>
 529             //Convert Skus into the client-side Entity representation
 530             Entity[] payload = helper.getRecords(originalProps, records);
 531 
<abbr title=" 532             int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings);"> 532             int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 533 
<abbr title=" 534             //Now fill out the relevant properties for the product options for the Skus that were returned"> 534             //Now fill out the relevant properties for the product options for the Skus that were returneðŸ”µ</abbr>
 535             updateProductOptionFieldsForFetch(records, payload);
 536 
 537             return new DynamicResultSet(payload, totalRecords);
 538         } catch (Exception e) {
<abbr title=" 539             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiedClassname, e);"> 539             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiðŸ”µ</abbr>
 540         }
 541     }
 542 
 543     /**
<abbr title=" 544      * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a ListGrid context."> 544      * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a LðŸ”µ</abbr>
 545      *
 546      * @param records
 547      * @param payload
 548      * @return
 549      */
 550     public void updateProductOptionFieldsForFetch(List&lt;Serializable&gt; records, Entity[] payload) {
 551         for (int i = 0; i &lt; records.size(); i++) {
 552             Sku sku = (Sku) records.get(i);
 553             Entity entity = payload[i];
 554 
<abbr title=" 555             List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionValueXrefs(), new TypedTransformer&lt;ProductOptionValue&gt;() {"> 555             List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionVaðŸ”µ</abbr>
 556                 @Override
 557                 public ProductOptionValue transform(Object input) {
 558                     return ((SkuProductOptionValueXref) input).getProductOptionValue();
 559                 }
 560             });
 561 
 562             for (ProductOptionValue value : optionValues) {
 563                 Property optionProperty = new Property();
 564                 optionProperty.setName(PRODUCT_OPTION_FIELD_PREFIX + value.getProductOption().getId());
 565                 optionProperty.setValue(value.getId().toString());
 566                 optionProperty.setDisplayValue(value.getAttributeValue());
 567                 entity.addProperty(optionProperty);
 568             }
 569 
 570             if (CollectionUtils.isNotEmpty(optionValues)) {
 571                 entity.addProperty(getConsolidatedOptionProperty(optionValues));
 572             } else {
 573                 entity.addProperty(getBlankConsolidatedOptionProperty());
 574             }
 575         }
 576     }
 577 
 578     /**
<abbr title=" 579      * Add filter restriction such that a ProductBundle cannot add its own default sku as a Sku Bundle Item"> 579      * Add filter restriction such that a ProductBundle cannot add its own default sku as a Sku Bundle ItðŸ”µ</abbr>
 580      */
<abbr title=" 581     private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 581     private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObjeðŸ”µ</abbr>
 582         SectionCrumb[] sectionCrumbs = persistencePackage.getSectionCrumbs();
 583         if (isSkuBundleItemLookup(persistencePackage, sectionCrumbs)) {
 584             final Long defaultSkuId = getOwningProductBundlesDefaultSkuId(sectionCrumbs[0]);
 585 
 586             filterMappings.add(new FilterMapping()
 587                     .withDirectFilterValues(Collections.singletonList(defaultSkuId))
 588                     .withRestriction(new Restriction()
 589                                     .withPredicateProvider(new PredicateProvider() {
 590                                         @Override
 591                                         public Predicate buildPredicate(CriteriaBuilder builder,
 592                                                 FieldPathBuilder fieldPathBuilder,
 593                                                 From root, String ceilingEntity,
 594                                                 String fullPropertyName, Path explicitPath,
 595                                                 List directValues) {
 596                                             return builder.notEqual(root, directValues.get(0));
 597                                         }
 598                                     })
 599                     ));
 600         }
 601     }
 602 
 603     private boolean isSkuBundleItemLookup(PersistencePackage pkg, SectionCrumb[] sectionCrumbs) {
 604         boolean owningClassMatch = false;
 605         boolean requestingFieldMatch = false;
 606 
 607         if (pkg.getCustomCriteria() == null || ArrayUtils.isEmpty(sectionCrumbs)) {
 608             return false;
 609         }
 610 
 611         for (String criteria : pkg.getCustomCriteria()) {
<abbr title=" 612             if (&quot;owningClass=org.broadleafcommerce.core.catalog.domain.SkuBundleItemImpl&quot;.equals(criteria)) {"> 612             if (&quot;owningClass=org.broadleafcommerce.core.catalog.domain.SkuBundleItemImpl&quot;.equals(criteriaðŸ”µ</abbr>
 613                 owningClassMatch = true;
 614             } else if (&quot;requestingField=sku&quot;.equals(criteria)) {
 615                 requestingFieldMatch = true;
 616             }
 617         }
 618 
<abbr title=" 619         boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectionIdentifier());"> 619         boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectiðŸ”µ</abbr>
 620 
 621         return owningClassMatch &amp;&amp; requestingFieldMatch &amp;&amp; sectionCrumbMatch;
 622     }
 623 
 624     private Long getOwningProductBundlesDefaultSkuId(SectionCrumb sectionCrumb) {
 625         if (ProductImpl.class.getCanonicalName().equals(sectionCrumb.getSectionIdentifier())
 626                 &amp;&amp; sectionCrumb.getSectionId() != null) {
<abbr title=" 627             ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(sectionCrumb.getSectionId()));"> 627             ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(secðŸ”µ</abbr>
 628             return productBundle.getDefaultSku().getId();
 629         }
 630         return null;
 631     }
 632 
<abbr title=" 633     public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage, String skuPropertyPrefix) {"> 633     public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObjecðŸ”µ</abbr>
 634 
 635         //if the front
 636         final List&lt;Long&gt; productOptionValueFilterIDs = new ArrayList&lt;&gt;();
 637         for (String filterProperty : cto.getCriteriaMap().keySet()) {
 638             if (filterProperty.startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 639                 FilterAndSortCriteria criteria = cto.get(filterProperty);
 640                 productOptionValueFilterIDs.add(Long.parseLong(criteria.getFilterValues().get(0)));
 641             }
 642         }
 643 
 644         //also determine if there is a consolidated POV query
 645         final List&lt;String&gt; productOptionValueFilterValues = new ArrayList&lt;&gt;();
 646         FilterAndSortCriteria consolidatedCriteria = cto.get(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 647         if (!consolidatedCriteria.getFilterValues().isEmpty()) {
 648             //the criteria in this case would be a semi-colon delimeter value list
<abbr title=" 649             productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.getFilterValues().get(0), CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER)));"> 649             productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.geðŸ”µ</abbr>
 650         }
 651 
 652         if (productOptionValueFilterIDs.size() &gt; 0) {
 653             FilterMapping filterMapping = new FilterMapping()
<abbr title=" 654                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.id&quot;))"> 654                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?ðŸ”µ</abbr>
 655                 .withDirectFilterValues(productOptionValueFilterIDs)
 656                 .withRestriction(new Restriction()
 657                     .withPredicateProvider(new PredicateProvider() {
 658                         @Override
<abbr title=" 659                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 659                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPaðŸ”µ</abbr>
 660                                                         From root, String ceilingEntity,
<abbr title=" 661                                                         String fullPropertyName, Path explicitPath, List directValues) {"> 661                                                         String fullPropertyName, Path explicitPath, List ðŸ”µ</abbr>
 662                             return explicitPath.as(Long.class).in(directValues);
 663                         }
 664                     })
 665                 );
 666             filterMappings.add(filterMapping);
 667         }
 668         if (productOptionValueFilterValues.size() &gt; 0) {
 669             FilterMapping filterMapping = new FilterMapping()
<abbr title=" 670                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.attributeValue&quot;))"> 670                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?ðŸ”µ</abbr>
 671                 .withDirectFilterValues(productOptionValueFilterValues)
 672                 .withRestriction(new Restriction()
 673                     .withPredicateProvider(new PredicateProvider() {
 674                         @Override
<abbr title=" 675                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 675                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPaðŸ”µ</abbr>
 676                                                         From root, String ceilingEntity,
<abbr title=" 677                                                         String fullPropertyName, Path explicitPath, List directValues) {"> 677                                                         String fullPropertyName, Path explicitPath, List ðŸ”µ</abbr>
 678                             return explicitPath.as(String.class).in(directValues);
 679                         }
 680                     })
 681                 );
 682             filterMappings.add(filterMapping);
 683         }
 684     }
 685 
 686     /**
<abbr title=" 687      * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the queryCritiera. At the"> 687      * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the qðŸ”µ</abbr>
<abbr title=" 688      * point that this method has been called, criteria from the frontend has already been applied, thus allowing you to"> 688      * point that this method has been called, criteria from the frontend has already been applied, thus ðŸ”µ</abbr>
 689      * override from there as well.&lt;/p&gt;
<abbr title=" 690      * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filter criteria"> 690      * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filtðŸ”µ</abbr>
 691      * can be applied for product option values&lt;/p&gt;
 692      *
 693      */
<abbr title=" 694     public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 694     public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cðŸ”µ</abbr>
 695         //unimplemented
 696     }
 697 
 698     @Override
<abbr title=" 699     public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 699     public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelðŸ”µ</abbr>
 700         Entity entity = persistencePackage.getEntity();
 701         try {
 702             //Fill out the Sku instance from the form
<abbr title=" 703             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 703             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 704             Sku adminInstance = (Sku) Class.forName(entity.getType()[0]).newInstance();
<abbr title=" 705             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 705             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getNaðŸ”µ</abbr>
 706             filterOutProductMetadata(adminProperties);
<abbr title=" 707             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);"> 707             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, ðŸ”µ</abbr>
 708 
 709             //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 710             Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
<abbr title=" 711                                                                              getProductOptionProperties(entity),"> 711                                                                              getProductOptionProperties(eðŸ”µ</abbr>
 712                                                                              null);
 713             if (errorEntity != null) {
 714                 entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 715                 return entity;
 716             }
 717 
 718             //persist the newly-created Sku
 719             adminInstance = dynamicEntityDao.persist(adminInstance);
 720 
 721             //associate the product option values
 722             associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 723 
 724             //After associating the product option values, save off the Sku
 725             adminInstance = dynamicEntityDao.merge(adminInstance);
 726 
 727             //Fill out the DTO and add in the product option value properties to it
 728             Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 729             for (Property property : getProductOptionProperties(entity)) {
 730                 result.addProperty(property);
 731             }
 732             return result;
 733         } catch (Exception e) {
 734             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + Sku.class.getName(), e);
 735         }
 736     }
 737 
 738     @Override
<abbr title=" 739     public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 739     public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordðŸ”µ</abbr>
 740         Entity entity = persistencePackage.getEntity();
 741         try {
 742             //Fill out the Sku instance from the form
<abbr title=" 743             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 743             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title=" 744             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 744             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getNaðŸ”µ</abbr>
 745             filterOutProductMetadata(adminProperties);
 746             Object primaryKey = helper.getPrimaryKey(entity, adminProperties);
<abbr title=" 747             Sku adminInstance = (Sku) dynamicEntityDao.retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 747             Sku adminInstance = (Sku) dynamicEntityDao.retrieve(Class.forName(entity.getType()[0]), primaðŸ”µ</abbr>
<abbr title=" 748             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);"> 748             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, ðŸ”µ</abbr>
 749 
 750             //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 751             Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
<abbr title=" 752                                                                             getProductOptionProperties(entity),"> 752                                                                             getProductOptionProperties(enðŸ”µ</abbr>
 753                                                                             adminInstance);
 754             if (errorEntity != null) {
 755                 entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 756                 return entity;
 757             }
 758 
 759             // Only modify product options if this ISN&#x27;T an update for inventory properties
 760             if (!persistencePackage.containsCriteria(INVENTORY_ONLY_CRITERIA)) {
 761                 associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 762             }
 763 
 764             adminInstance = dynamicEntityDao.merge(adminInstance);
 765 
 766             extensionManager.getProxy().skuUpdated(adminInstance);
 767 
 768             //Fill out the DTO and add in the product option value properties to it
 769             Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 770             for (Property property : getProductOptionProperties(entity)) {
 771                 result.addProperty(property);
 772             }
 773             return result;
 774         } catch (Exception e) {
 775             throw new ServiceException(&quot;Unable to perform update for entity: &quot; + Sku.class.getName(), e);
 776         }
 777     }
 778 
 779     @Override
 780     protected String[] getPolymorphicClasses(Class&lt;?&gt; clazz, EntityManager em, boolean useCache) {
 781         DynamicDaoHelperImpl helper = new DynamicDaoHelperImpl();
 782         Class&lt;?&gt;[] classes = helper.getAllPolymorphicEntitiesFromCeiling(clazz, true, useCache);
 783         String[] result = new String[classes.length];
 784         for (int i = 0; i &lt; classes.length; i++) {
 785             result[i] = classes[i].getName();
 786         }
 787         return result;
 788     }
 789 
 790     /**
<abbr title=" 791      * This initially removes all of the product option values that are currently related to the Sku and then re-associates"> 791      * This initially removes all of the product option values that are currently related to the Sku and ðŸ”µ</abbr>
 792      * the {@link ProductOptionValue}s
 793      * @param entity
 794      * @param adminInstance
 795      */
<abbr title=" 796     protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dynamicEntityDao) {"> 796     protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dðŸ”µ</abbr>
 797         //Get the list of product option value ids that were selected from the form
 798         List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 799         for (Property property : getProductOptionProperties(entity)) {
 800             Long propId = Long.parseLong(property.getValue());
 801             productOptionValueIds.add(propId);
 802             property.setIsDirty(true);
 803         }
 804 
 805         // Only process associations if product option value changes came in via the form
 806         if (CollectionUtils.isNotEmpty(productOptionValueIds)) {
 807             //remove the current list of product option values from the Sku
 808             if (adminInstance.getProductOptionValueXrefs().size() &gt; 0) {
<abbr title=" 809                 Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs().iterator();"> 809                 Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs()ðŸ”µ</abbr>
 810                 while (iterator.hasNext()) {
 811                     dynamicEntityDao.remove(iterator.next());
 812                 }
 813                 dynamicEntityDao.merge(adminInstance);
 814             }
 815 
 816             //Associate the product option values from the form with the Sku
 817             for (Long id : productOptionValueIds) {
<abbr title=" 818                 //Simply find the changed ProductOptionValues directly - seems to work better with sandboxing code"> 818                 //Simply find the changed ProductOptionValues directly - seems to work better with sandboðŸ”µ</abbr>
<abbr title=" 819                 ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpl.class, id);"> 819                 ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpðŸ”µ</abbr>
 820                 SkuProductOptionValueXref xref = new SkuProductOptionValueXrefImpl(adminInstance, pov);
 821                 xref = dynamicEntityDao.merge(xref);
 822                 adminInstance.getProductOptionValueXrefs().add(xref);
 823             }
 824         }
 825     }
 826 
 827     protected List&lt;Property&gt; getProductOptionProperties(Entity entity) {
 828         List&lt;Property&gt; productOptionProperties = new ArrayList&lt;&gt;();
 829         for (Property property : entity.getProperties()) {
 830             if (property.getName().startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 831                 productOptionProperties.add(property);
 832             }
 833         }
 834         return productOptionProperties;
 835     }
 836 
 837     /**
<abbr title=" 838      * Ensures that the given list of {@link ProductOptionValue} IDs is unique for the given {@link Product}."> 838      * Ensures that the given list of {@link ProductOptionValue} IDs is unique for the given {@link ProduðŸ”µ</abbr>
 839      *
<abbr title=" 840      * If sku browsing is enabled, then it is assumed that a single combination of {@link ProductOptionValue} IDs"> 840      * If sku browsing is enabled, then it is assumed that a single combination of {@link ProductOptionVaðŸ”µ</abbr>
<abbr title=" 841      * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProductOptionValue} IDs."> 841      * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProducðŸ”µ</abbr>
 842      * In this case, the following validation is skipped.
 843      *
 844      * @param product
 845      * @param productOptionProperties
<abbr title=" 846      * @param currentSku - for update operations, this is the current Sku that is being updated; should be excluded from"> 846      * @param currentSku - for update operations, this is the current Sku that is being updated; should bðŸ”µ</abbr>
 847      * attempting validation
 848      * @return &lt;b&gt;null&lt;/b&gt; if successfully validation, the error entity otherwise
 849      */
<abbr title=" 850     protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOptionProperties, Sku currentSku) {"> 850     protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOðŸ”µ</abbr>
 851         //do not attempt POV validation if no PO properties were passed in
 852         if (CollectionUtils.isNotEmpty(productOptionProperties)) {
 853             List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 854             for (Property property : productOptionProperties) {
 855                 productOptionValueIds.add(Long.parseLong(property.getValue()));
 856             }
 857 
 858             boolean validated = true;
 859             for (Sku sku : product.getAdditionalSkus()) {
 860                 if (currentSku == null || !sku.getId().equals(currentSku.getId())) {
 861                     List&lt;Long&gt; testList = new ArrayList&lt;&gt;();
 862                     for (ProductOptionValue optionValue : sku.getProductOptionValues()) {
 863                         testList.add(optionValue.getId());
 864                     }
 865 
 866                     if (CollectionUtils.isNotEmpty(testList) &amp;&amp;
 867                             productOptionValueIds.containsAll(testList) &amp;&amp;
 868                             productOptionValueIds.size() == testList.size()) {
 869                         validated = false;
 870                         break;
 871                     }
 872                 }
 873             }
 874 
 875             if (!validated) {
 876                 Entity errorEntity = new Entity();
 877                 for (Property productOptionProperty : productOptionProperties) {
 878                     errorEntity.addValidationError(productOptionProperty.getName(), &quot;uniqueSkuError&quot;);
 879                 }
 880                 return errorEntity;
 881             }
 882         }
 883         return null;
 884     }
 885 
 886 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Admin Module
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.admin.server.service.handler;
  20 
  21 import static com.google.common.base.CharMatcher.DIGIT;
  22 
  23 import org.apache.commons.collections.CollectionUtils;
  24 import org.apache.commons.collections.Transformer;
  25 import org.apache.commons.lang.BooleanUtils;
  26 import org.apache.commons.lang3.ArrayUtils;
  27 import org.apache.commons.lang3.StringUtils;
  28 import org.apache.commons.lang3.math.NumberUtils;
  29 import org.apache.commons.logging.Log;
  30 import org.apache.commons.logging.LogFactory;
  31 import org.broadleafcommerce.admin.server.service.SkuMetadataCacheService;
  32 import org.broadleafcommerce.common.exception.ServiceException;
  33 import org.broadleafcommerce.common.presentation.client.LookupType;
  34 import org.broadleafcommerce.common.presentation.client.OperationType;
  35 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  36 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  37 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  38 import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  39 import org.broadleafcommerce.common.util.BLCCollectionUtils;
  40 import org.broadleafcommerce.common.util.StringUtil;
  41 import org.broadleafcommerce.common.util.TypedTransformer;
  42 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  43 import org.broadleafcommerce.core.catalog.domain.Product;
  44 import org.broadleafcommerce.core.catalog.domain.ProductBundle;
  45 import org.broadleafcommerce.core.catalog.domain.ProductImpl;
  46 import org.broadleafcommerce.core.catalog.domain.ProductOption;
  47 import org.broadleafcommerce.core.catalog.domain.ProductOptionImpl;
  48 import org.broadleafcommerce.core.catalog.domain.ProductOptionValue;
  49 import org.broadleafcommerce.core.catalog.domain.ProductOptionValueImpl;
  50 import org.broadleafcommerce.core.catalog.domain.Sku;
  51 import org.broadleafcommerce.core.catalog.domain.SkuImpl;
  52 import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXref;
  53 import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXrefImpl;
  54 import org.broadleafcommerce.core.catalog.service.CatalogService;
  55 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  56 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  57 import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;
  58 import org.broadleafcommerce.openadmin.dto.DynamicResultSet;
  59 import org.broadleafcommerce.openadmin.dto.Entity;
  60 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  61 import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;
  62 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  63 import org.broadleafcommerce.openadmin.dto.PersistencePackage;
  64 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  65 import org.broadleafcommerce.openadmin.dto.Property;
  66 import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  67 import org.broadleafcommerce.openadmin.server.dao.DynamicEntityDao;
  68 import org.broadleafcommerce.openadmin.server.service.handler.CustomPersistenceHandlerAdapter;
  69 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  70 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManagerFactory;
  71 import org.broadleafcommerce.openadmin.server.service.persistence.module.InspectHelper;
  72 import org.broadleafcommerce.openadmin.server.service.persistence.module.PersistenceModule;
  73 import org.broadleafcommerce.openadmin.server.service.persistence.module.RecordHelper;
  74 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;
  75 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;
  76 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;
  77 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;
  78 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;
<abbr title="  79 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  79 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
  80 import org.springframework.beans.factory.annotation.Value;
  81 import org.springframework.stereotype.Component;
  82 
  83 import java.io.Serializable;
  84 import java.util.ArrayList;
  85 import java.util.Arrays;
  86 import java.util.Collection;
  87 import java.util.Collections;
  88 import java.util.HashMap;
  89 import java.util.Iterator;
  90 import java.util.List;
  91 import java.util.Map;
  92 
  93 import javax.annotation.Resource;
  94 import javax.persistence.EntityManager;
  95 import javax.persistence.PersistenceContext;
  96 import javax.persistence.TypedQuery;
  97 import javax.persistence.criteria.CriteriaBuilder;
  98 import javax.persistence.criteria.From;
  99 import javax.persistence.criteria.Path;
 100 import javax.persistence.criteria.Predicate;
 101 
 102 /**
 103  * @author Phillip Verheyden
 104  *
 105  */
 106 @Component(&quot;blSkuCustomPersistenceHandler&quot;)
 107 public class SkuCustomPersistenceHandler extends CustomPersistenceHandlerAdapter {
 108 
 109     private static final Log LOG = LogFactory.getLog(SkuCustomPersistenceHandler.class);
 110 
 111     public static String PRODUCT_OPTION_FIELD_PREFIX = &quot;productOption&quot;;
 112     public static String INVENTORY_ONLY_CRITERIA = &quot;onlyInventoryProperties&quot;;
 113 
 114     @Value(&quot;${use.to.one.lookup.sku.product.option.value:false}&quot;)
 115     protected boolean useToOneLookupSkuProductOptionValue = false;
 116 
 117     @Resource(name =&quot;blSkuMetadataCacheService&quot;)
 118     protected SkuMetadataCacheService skuMetadataCacheService;
 119 
 120     @Resource(name=&quot;blAdornedTargetListPersistenceModule&quot;)
 121     protected PersistenceModule adornedPersistenceModule;
 122 
 123     @Resource(name = &quot;blSkuCustomPersistenceHandlerExtensionManager&quot;)
 124     protected SkuCustomPersistenceHandlerExtensionManager extensionManager;
 125 
 126     /**
<abbr title=" 127      * This represents the field that all of the product option values will be stored in. This would be used in the case"> 127      * This represents the field that all of the product option values will be stored in. This would be uðŸ”µ</abbr>
<abbr title=" 128      * where there are a bunch of product options and displaying each option as a grid header would have everything"> 128      * where there are a bunch of product options and displaying each option as a grid header would have ðŸ”µ</abbr>
 129      * squashed together. Filtering on this field is currently unsupported.
 130      */
 131     public static String CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME = &quot;consolidatedProductOptions&quot;;
 132     public static String CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER = &quot;; &quot;;
 133 
 134     @Resource(name=&quot;blCatalogService&quot;)
 135     protected CatalogService catalogService;
 136 
 137     @PersistenceContext(unitName = &quot;blPU&quot;)
 138     protected EntityManager em;
 139 
 140     @Resource(name = &quot;blCriteriaTranslator&quot;)
 141     protected CriteriaTranslator criteriaTranslator;
 142 
 143     @Resource(name = &quot;blSandBoxHelper&quot;)
 144     protected SandBoxHelper sandBoxHelper;
 145 
 146     @Override
 147     public Boolean canHandleInspect(PersistencePackage persistencePackage) {
<abbr title=" 148         return canHandle(persistencePackage, persistencePackage.getPersistencePerspective().getOperationTypes()"> 148         return canHandle(persistencePackage, persistencePackage.getPersistencePerspective().getOperationTðŸ”µ</abbr>
 149                 .getInspectType());
 150     }
 151 
 152     @Override
 153     public Boolean canHandleFetch(PersistencePackage persistencePackage) {
<abbr title=" 154         OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFetchType();"> 154         OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFðŸ”µ</abbr>
 155         return canHandle(persistencePackage, fetchType);
 156     }
 157 
 158     @Override
 159     public Boolean canHandleAdd(PersistencePackage persistencePackage) {
<abbr title=" 160         OperationType addType = persistencePackage.getPersistencePerspective().getOperationTypes().getAddType();"> 160         OperationType addType = persistencePackage.getPersistencePerspective().getOperationTypes().getAddðŸ”µ</abbr>
 161         return canHandle(persistencePackage, addType);
 162     }
 163 
 164     @Override
 165     public Boolean canHandleUpdate(PersistencePackage persistencePackage) {
<abbr title=" 166         OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getUpdateType();"> 166         OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getðŸ”µ</abbr>
 167         return canHandle(persistencePackage, updateType);
 168     }
 169 
 170     /**
<abbr title=" 171      * Since this is the default for all Skus, it&#x27;s possible that we are providing custom criteria for this"> 171      * Since this is the default for all Skus, it&#x27;s possible that we are providing custom criteria for thðŸ”µ</abbr>
<abbr title=" 172      * Sku lookup. In that case, we probably want to delegate to a child class, so only use this particular"> 172      * Sku lookup. In that case, we probably want to delegate to a child class, so only use this particulðŸ”µ</abbr>
<abbr title=" 173      * persistence handler if there is no custom criteria being used and the ceiling entity is an instance of Sku. The"> 173      * persistence handler if there is no custom criteria being used and the ceiling entity is an instancðŸ”µ</abbr>
<abbr title=" 174      * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for the ceiling entity"> 174      * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for thðŸ”µ</abbr>
<abbr title=" 175      * class name. That should be handled by the map structure module though, so only handle things in the Sku custom"> 175      * class name. That should be handled by the map structure module though, so only handle things in thðŸ”µ</abbr>
 176      * persistence handler for OperationType.BASIC
 177      *
 178      */
 179     protected Boolean canHandle(PersistencePackage persistencePackage, OperationType operationType) {
<abbr title=" 180         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 180         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 181         try {
 182             Class testClass = Class.forName(ceilingEntityFullyQualifiedClassname);
 183             return Sku.class.isAssignableFrom(testClass) &amp;&amp;
 184                     //ArrayUtils.isEmpty(persistencePackage.getCustomCriteria()) &amp;&amp;
 185                     OperationType.BASIC.equals(operationType) &amp;&amp;
<abbr title=" 186                     (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.ADORNEDTARGETLIST) == null);"> 186                     (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 187         } catch (ClassNotFoundException e) {
 188             return false;
 189         }
 190     }
 191 
 192     /**
 193      * Build out the extra fields for the product options
 194      */
 195     @Override
<abbr title=" 196     public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, InspectHelper helper) throws ServiceException {"> 196     public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityðŸ”µ</abbr>
 197         try {
<abbr title=" 198             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 198             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 199             Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties = new HashMap&lt;&gt;();
 200 
 201             String productIdStr = getOwningProductId(persistencePackage.getSectionCrumbs());
 202             String cacheKey = skuMetadataCacheService.buildCacheKey(productIdStr);
 203 
 204             Map&lt;String, FieldMetadata&gt; properties = null;
 205             boolean useCache = skuMetadataCacheService.useCache();
 206             if (useCache) {
 207                 properties = skuMetadataCacheService.getFromCache(cacheKey);
 208             }
 209             if (properties == null) {
 210                 //Grab the default properties for the Sku
<abbr title=" 211                 properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspective);"> 211                 properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspecðŸ”µ</abbr>
 212 
 213                 boolean isFirstCriteriaNAN = productIdStr == null;
 214                 if (!isFirstCriteriaNAN &amp;&amp; useToOneLookupSkuProductOptionValue) {
 215 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 216                     isFirstCriteriaNAN = !NumberUtils.isParsable(productIdStr);</span>
 217 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218 </span>
 219 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 220                     isFirstCriteriaNAN = !NumberUtils.isNumber(productIdStr);</span>
 221 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 222                 }
 223                 if (isFirstCriteriaNAN) {
 224                     //look up all the ProductOptions and then create new fields for each of them
 225                     List&lt;ProductOption&gt; options = catalogService.readAllProductOptions();
 226                     int order = 0;
 227                     for (ProductOption option : options) {
 228                         //add this to the built Sku properties
 229                         FieldMetadata md = createIndividualOptionField(option, order);
 230                         if (md != null) {
 231                             properties.put(&quot;productOption&quot; + option.getId(), md);
 232                         }
 233                     }
 234                 } else {
 235                     // If we have a product to filter the list of available product options, then use it
 236                     try {
 237                         Long productId = Long.parseLong(productIdStr);
 238                         Product product = catalogService.findProductById(productId);
 239                         for (ProductOption option : product.getProductOptions()) {
 240                             FieldMetadata md = createIndividualOptionField(option, 0);
 241                             if (md != null) {
 242                                 properties.put(&quot;productOption&quot; + option.getId(), md);
 243                             }
 244                         }
 245                     } catch (NumberFormatException e) {
 246                         // there wasn&#x27;t a valid product id, just don&#x27;t do anything
 247                     }
 248                 }
 249 
<abbr title=" 250                 //also build the consolidated field; if using the SkuBasicClientEntityModule then this field will be"> 250                 //also build the consolidated field; if using the SkuBasicClientEntityModule then this fiðŸ”µ</abbr>
 251                 //permanently hidden
<abbr title=" 252                 properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuImpl.class));"> 252                 properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuðŸ”µ</abbr>
 253 
 254                 if (useCache) {
 255                     skuMetadataCacheService.addToCache(cacheKey, properties);
 256                 }
 257             }
 258 
 259             allMergedProperties.put(MergedPropertyType.PRIMARY, properties);
 260 
 261             //allow the adorned list to contribute properties as well in the case of Sku bundle items
 262             adornedPersistenceModule.setPersistenceManager((PersistenceManager)helper);
 263             adornedPersistenceModule.updateMergedProperties(persistencePackage, allMergedProperties);
 264 
<abbr title=" 265             Class&lt;?&gt;[] entityClasses = dynamicEntityDao.getAllPolymorphicEntitiesFromCeiling(SkuImpl.class);"> 265             Class&lt;?&gt;[] entityClasses = dynamicEntityDao.getAllPolymorphicEntitiesFromCeiling(SkuImpl.clasðŸ”µ</abbr>
 266 
<abbr title=" 267             for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.entrySet()) {"> 267             for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.enðŸ”µ</abbr>
 268                 filterOutProductMetadata(entry.getValue());
 269             }
 270 
<abbr title=" 271             ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, allMergedProperties);"> 271             ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, aðŸ”µ</abbr>
 272             DynamicResultSet results = new DynamicResultSet(mergedMetadata, null, null);
 273 
 274             return results;
 275         } catch (Exception e) {
 276             ServiceException ex = new ServiceException(&quot;Unable to retrieve inspection results for &quot; +
 277                     persistencePackage.getCeilingEntityFullyQualifiedClassname(), e);
 278             throw ex;
 279         }
 280     }
 281 
 282     protected String getOwningProductId(SectionCrumb[] sectionCrumbs) {
 283         if (ArrayUtils.isNotEmpty(sectionCrumbs) &amp;&amp; ProductImpl.class.getCanonicalName()
 284                 .equals(sectionCrumbs[0].getSectionIdentifier())) {
 285             return sectionCrumbs[0].getSectionId();
 286         }
 287         return null;
 288     }
 289 
 290     protected void filterOutProductMetadata(Map&lt;String, FieldMetadata&gt; map) {
<abbr title=" 291         //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdminPresentation,"> 291         //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdmðŸ”µ</abbr>
 292         //but there&#x27;s a bug preventing this behavior from completely working correctly
 293         List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 294         for (Map.Entry&lt;String, FieldMetadata&gt; entry : map.entrySet()) {
 295             if (entry.getKey().contains(&quot;defaultProduct.&quot;) || entry.getKey().contains(&quot;product.&quot;)) {
 296                 removeKeys.add(entry.getKey());
 297             }
 298         }
 299         for (String removeKey : removeKeys) {
 300             map.remove(removeKey);
 301         }
 302     }
 303 
 304     /**
<abbr title=" 305      * Creates the metadata necessary for displaying all of the product option values in a single field. The display of this"> 305      * Creates the metadata necessary for displaying all of the product option values in a single field. ðŸ”µ</abbr>
<abbr title=" 306      * field is a single string with every product option value appended to it separated by a semicolon. This method should"> 306      * field is a single string with every product option value appended to it separated by a semicolon. ðŸ”µ</abbr>
<abbr title=" 307      * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be populated on fetch."> 307      * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be pðŸ”µ</abbr>
 308      *
<abbr title=" 309      * The metadata that is returned will also be set to prominent by default so that it will be ready to display on whatever"> 309      * The metadata that is returned will also be set to prominent by default so that it will be ready toðŸ”µ</abbr>
<abbr title=" 310      * grid is being inspected. If you do not want this behavior you will need to override this functionality in the metadata"> 310      * grid is being inspected. If you do not want this behavior you will need to override this functionaðŸ”µ</abbr>
 311      * that is returned.
 312      *
<abbr title=" 313      * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, but if you want to"> 313      * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, bðŸ”µ</abbr>
 314      * display this field with a different entity then this should be that entity
 315      * @return
 316      */
 317     public FieldMetadata createConsolidatedOptionField(Class&lt;?&gt; inheritedFromType) {
 318         BasicFieldMetadata metadata = new BasicFieldMetadata();
 319         metadata.setFieldType(SupportedFieldType.STRING);
 320         metadata.setMutable(false);
 321         metadata.setInheritedFromType(inheritedFromType.getName());
 322 
<abbr title=" 323         metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 323         metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useðŸ”µ</abbr>
 324         metadata.setForeignKeyCollection(false);
 325         metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 326 
 327         metadata.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 328         metadata.setFriendlyName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 329         metadata.setGroup(&quot;&quot;);
 330         metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 331         metadata.setProminent(true);
 332         metadata.setVisibility(VisibilityEnum.FORM_HIDDEN);
 333         metadata.setBroadleafEnumeration(&quot;&quot;);
 334         metadata.setReadOnly(true);
 335         metadata.setRequiredOverride(false);
 336         metadata.setGridOrder(Integer.MAX_VALUE);
 337 
 338         return metadata;
 339     }
 340 
 341     /**
<abbr title=" 342      * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed in. This should be"> 342      * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed iðŸ”µ</abbr>
 343      * invoked on a fetch and the returned property should be added to the fetched {@link Entity} dto.
 344      *
 345      * @param values
 346      * @return
 347      * @see {@link #createConsolidatedOptionField(Class)};
 348      */
 349     public Property getConsolidatedOptionProperty(Collection&lt;ProductOptionValue&gt; values) {
 350         Property optionValueProperty = new Property();
 351         optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 352 
 353         //order the values by the display order of their correspond product option
 354         //        Collections.sort(values, new Comparator&lt;ProductOptionValue&gt;() {
 355         //
 356         //            @Override
 357         //            public int compare(ProductOptionValue value1, ProductOptionValue value2) {
<abbr title=" 358         //                return new CompareToBuilder().append(value1.getProductOption().getDisplayOrder(),"> 358         //                return new CompareToBuilder().append(value1.getProductOption().getDisplayOrder(ðŸ”µ</abbr>
 359         //                        value2.getProductOption().getDisplayOrder()).toComparison();
 360         //            }
 361         //        });
 362 
 363         ArrayList&lt;String&gt; stringValues = new ArrayList&lt;&gt;();
 364         CollectionUtils.collect(values, new Transformer() {
 365 
 366             @Override
 367             public Object transform(Object input) {
 368                 return ((ProductOptionValue) input).getAttributeValue();
 369             }
 370         }, stringValues);
 371 
<abbr title=" 372         optionValueProperty.setValue(StringUtils.join(stringValues, CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER));"> 372         optionValueProperty.setValue(StringUtils.join(stringValues, CONSOLIDATED_PRODUCT_OPTIONS_DELIMETEðŸ”µ</abbr>
 373         return optionValueProperty;
 374     }
 375 
 376     /**
 377      * @return a blank {@link Property} corresponding to the CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME
 378      */
 379     public Property getBlankConsolidatedOptionProperty() {
 380         Property optionValueProperty = new Property();
 381         optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 382         optionValueProperty.setValue(&quot;&quot;);
 383         return optionValueProperty;
 384     }
 385 
 386     /**
<abbr title=" 387      * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum field whose values will"> 387      * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum fieðŸ”µ</abbr>
<abbr title=" 388      * be the option values for this option.  This is useful when you would like to display each product option in as its"> 388      * be the option values for this option.  This is useful when you would like to display each product ðŸ”µ</abbr>
 389      * own field in a grid so that you can further filter by product option values.&lt;/p&gt;
<abbr title=" 390      * &lt;p&gt;In order for these fields to be utilized property on the fetch, in the GWT frontend you must use the"> 390      * &lt;p&gt;In order for these fields to be utilized property on the fetch, in the GWT frontend you must usðŸ”µ</abbr>
 391      * for your datasource.&lt;/p&gt;
 392      *
 393      * @param option
 394      * @param order
 395      * @return
 396      */
 397     public FieldMetadata createIndividualOptionField(ProductOption option, int order) {
 398         if (useToOneLookupSkuProductOptionValue) {
 399             return createToOneIndividualOptionField(option, order);
 400         } else {
 401             return createExplicitEnumerationIndividualOptionField(option, order);
 402         }
 403     }
 404 
<abbr title=" 405     protected FieldMetadata createExplicitEnumerationIndividualOptionField(ProductOption option, int order) {"> 405     protected FieldMetadata createExplicitEnumerationIndividualOptionField(ProductOption option, int ordeðŸ”µ</abbr>
 406         BasicFieldMetadata metadata = new BasicFieldMetadata();
 407         List&lt;ProductOptionValue&gt; allowedValues = option.getAllowedValues();
 408         if (CollectionUtils.isNotEmpty(allowedValues)) {
 409             metadata.setFieldType(SupportedFieldType.EXPLICIT_ENUMERATION);
 410             metadata.setMutable(true);
 411             metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 412             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 412             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheServiceðŸ”µ</abbr>
 413             metadata.setForeignKeyCollection(false);
 414             metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 415 
 416             //Set up the enumeration based on the product option values
 417             String[][] optionValues = new String[allowedValues.size()][2];
 418             for (int i = 0; i &lt; allowedValues.size(); i++) {
 419                 ProductOptionValue value = option.getAllowedValues().get(i);
 420                 optionValues[i][0] = value.getId().toString();
 421                 optionValues[i][1] = value.getAttributeValue();
 422             }
 423             metadata.setEnumerationValues(optionValues);
 424 
 425             metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 426             metadata.setFriendlyName(option.getLabel());
 427             metadata.setGroup(&quot;productOption_group&quot;);
 428             metadata.setGroupOrder(-1);
 429             metadata.setOrder(order);
 430             metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 431             metadata.setProminent(false);
 432             metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 433             metadata.setBroadleafEnumeration(&quot;&quot;);
 434             metadata.setReadOnly(false);
 435             metadata.setRequiredOverride(BooleanUtils.isFalse(option.getRequired()));
 436 
 437             return metadata;
 438         }
 439         return null;
 440     }
 441 
 442     /**
<abbr title=" 443      * Using a ToOne lookup performs much better for large product option value lists, speeds up initial page load,"> 443      * Using a ToOne lookup performs much better for large product option value lists, speeds up initial ðŸ”µ</abbr>
<abbr title=" 444      * and is generally more accurate in relation to option value updates and how they impact available selections and cache."> 444      * and is generally more accurate in relation to option value updates and how they impact available sðŸ”µ</abbr>
 445      *
 446      * @param option
 447      * @param order
 448      * @return
 449      */
 450     protected FieldMetadata createToOneIndividualOptionField(ProductOption option, int order) {
 451         PersistenceManager persistenceManager = PersistenceManagerFactory.getPersistenceManager();
 452         FilterMapping filterMapping = new FilterMapping().withDirectFilterValues(
<abbr title=" 453                 sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(new Restriction()"> 453                 sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(newðŸ”µ</abbr>
 454             .withPredicateProvider(new PredicateProvider() {
 455                 @Override
<abbr title=" 456                 public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder, From root,"> 456                 public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuildeðŸ”µ</abbr>
<abbr title=" 457                                                 String ceilingEntity, String fullPropertyName, Path explicitPath, List directValues) {"> 457                                                 String ceilingEntity, String fullPropertyName, Path expliðŸ”µ</abbr>
 458                     return root.get(&quot;productOption&quot;).get(&quot;id&quot;).in(directValues);
 459             }
 460         }));
 461         List&lt;FilterMapping&gt; mappings = new ArrayList&lt;&gt;();
 462         mappings.add(filterMapping);
<abbr title=" 463         TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),"> 463         TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.gðŸ”µ</abbr>
 464                 ProductOptionValueImpl.class.getName(), mappings);
 465         Long count = (Long) countQuery.getSingleResult();
 466         BasicFieldMetadata metadata = null;
 467         if (count &gt; 0) {
 468             metadata = new BasicFieldMetadata();
 469             metadata.setFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 470             metadata.setSecondaryType(SupportedFieldType.INTEGER);
 471             metadata.setForeignKeyProperty(&quot;id&quot;);
 472             metadata.setForeignKeyClass(ProductOptionValueImpl.class.getName());
 473             metadata.setForeignKeyDisplayValueProperty(&quot;attributeValue&quot;);
 474             metadata.setLookupDisplayProperty(&quot;attributeValue&quot;);
 475             metadata.setForeignKeyCollection(false);
 476             metadata.setCustomCriteria(new String[]{&quot;option=&quot; + String.valueOf(option.getId())});
 477             metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 478             metadata.setFriendlyName(option.getLabel());
 479             metadata.setGroup(&quot;productOption_group&quot;);
 480             metadata.setGroupOrder(-1);
 481             metadata.setOrder(order);
 482             metadata.setExplicitFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 483             metadata.setProminent(false);
 484             metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 485             metadata.setReadOnly(false);
<abbr title=" 486             //these may not be actually required, but the CPH has this as a requirement for parsing the data, so we&#x27;ll stick with it here"> 486             //these may not be actually required, but the CPH has this as a requirement for parsing the dðŸ”µ</abbr>
 487             metadata.setRequiredOverride(true);
 488             metadata.setLookupType(LookupType.STANDARD);
 489             metadata.setMutable(true);
 490             metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 491             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 491             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheServiceðŸ”µ</abbr>
 492             metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 493             metadata.setTargetClass(SkuImpl.class.getName());
 494             metadata.setFieldName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 495         }
 496         return metadata;
 497     }
 498 
 499     @SuppressWarnings(&quot;unchecked&quot;)
 500     @Override
<abbr title=" 501     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 501     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynaðŸ”µ</abbr>
<abbr title=" 502         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 502         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 503         try {
<abbr title=" 504             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 504             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 505             //get the default properties from Sku and its subclasses
<abbr title=" 506             Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 506             Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getNameðŸ”µ</abbr>
 507 
 508             //Pull back the Skus based on the criteria from the client
<abbr title=" 509             List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, originalProps);"> 509             List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceðŸ”µ</abbr>
 510 
 511             //allow subclasses to provide additional criteria before executing the query
 512             applyProductOptionValueCriteria(filterMappings, cto, persistencePackage, null);
 513             applySkuBundleItemValueCriteria(filterMappings, cto, persistencePackage);
 514             applyAdditionalFetchCriteria(filterMappings, cto, persistencePackage);
 515 
<abbr title=" 516             List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings, cto.getFirstResult(), cto.getMaxResults());"> 516             List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFðŸ”µ</abbr>
 517             //Convert Skus into the client-side Entity representation
 518             Entity[] payload = helper.getRecords(originalProps, records);
 519 
<abbr title=" 520             int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings);"> 520             int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 521 
<abbr title=" 522             //Now fill out the relevant properties for the product options for the Skus that were returned"> 522             //Now fill out the relevant properties for the product options for the Skus that were returneðŸ”µ</abbr>
 523             updateProductOptionFieldsForFetch(records, payload);
 524 
 525             return new DynamicResultSet(payload, totalRecords);
 526         } catch (Exception e) {
<abbr title=" 527             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiedClassname, e);"> 527             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiðŸ”µ</abbr>
 528         }
 529     }
 530 
 531     /**
<abbr title=" 532      * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a ListGrid context."> 532      * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a LðŸ”µ</abbr>
 533      *
 534      * @param records
 535      * @param payload
 536      * @return
 537      */
 538     public void updateProductOptionFieldsForFetch(List&lt;Serializable&gt; records, Entity[] payload) {
 539         for (int i = 0; i &lt; records.size(); i++) {
 540             Sku sku = (Sku) records.get(i);
 541             Entity entity = payload[i];
 542 
<abbr title=" 543             List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionValueXrefs(), new TypedTransformer&lt;ProductOptionValue&gt;() {"> 543             List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionVaðŸ”µ</abbr>
 544                 @Override
 545                 public ProductOptionValue transform(Object input) {
 546                     return ((SkuProductOptionValueXref) input).getProductOptionValue();
 547                 }
 548             });
 549 
 550             for (ProductOptionValue value : optionValues) {
 551                 Property optionProperty = new Property();
 552                 optionProperty.setName(PRODUCT_OPTION_FIELD_PREFIX + value.getProductOption().getId());
 553                 optionProperty.setValue(value.getId().toString());
 554                 optionProperty.setDisplayValue(value.getAttributeValue());
 555                 entity.addProperty(optionProperty);
 556             }
 557 
 558             if (CollectionUtils.isNotEmpty(optionValues)) {
 559                 entity.addProperty(getConsolidatedOptionProperty(optionValues));
 560             } else {
 561                 entity.addProperty(getBlankConsolidatedOptionProperty());
 562             }
 563         }
 564     }
 565 
 566     /**
<abbr title=" 567      * Add filter restriction such that a ProductBundle cannot add its own default sku as a Sku Bundle Item"> 567      * Add filter restriction such that a ProductBundle cannot add its own default sku as a Sku Bundle ItðŸ”µ</abbr>
 568      */
<abbr title=" 569     private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 569     private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObjeðŸ”µ</abbr>
 570         SectionCrumb[] sectionCrumbs = persistencePackage.getSectionCrumbs();
 571         if (isSkuBundleItemLookup(persistencePackage, sectionCrumbs)) {
 572             final Long defaultSkuId = getOwningProductBundlesDefaultSkuId(sectionCrumbs[0]);
 573 
 574             filterMappings.add(new FilterMapping()
 575                     .withDirectFilterValues(Collections.singletonList(defaultSkuId))
 576                     .withRestriction(new Restriction()
 577                                     .withPredicateProvider(new PredicateProvider() {
 578                                         @Override
 579                                         public Predicate buildPredicate(CriteriaBuilder builder,
 580                                                 FieldPathBuilder fieldPathBuilder,
 581                                                 From root, String ceilingEntity,
 582                                                 String fullPropertyName, Path explicitPath,
 583                                                 List directValues) {
 584                                             return builder.notEqual(root, directValues.get(0));
 585                                         }
 586                                     })
 587                     ));
 588         }
 589     }
 590 
 591     private boolean isSkuBundleItemLookup(PersistencePackage pkg, SectionCrumb[] sectionCrumbs) {
 592         boolean owningClassMatch = false;
 593         boolean requestingFieldMatch = false;
 594 
 595         if (pkg.getCustomCriteria() == null || ArrayUtils.isEmpty(sectionCrumbs)) {
 596             return false;
 597         }
 598 
 599         for (String criteria : pkg.getCustomCriteria()) {
<abbr title=" 600             if (&quot;owningClass=org.broadleafcommerce.core.catalog.domain.SkuBundleItemImpl&quot;.equals(criteria)) {"> 600             if (&quot;owningClass=org.broadleafcommerce.core.catalog.domain.SkuBundleItemImpl&quot;.equals(criteriaðŸ”µ</abbr>
 601                 owningClassMatch = true;
 602             } else if (&quot;requestingField=sku&quot;.equals(criteria)) {
 603                 requestingFieldMatch = true;
 604             }
 605         }
 606 
<abbr title=" 607         boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectionIdentifier());"> 607         boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectiðŸ”µ</abbr>
 608 
 609         return owningClassMatch &amp;&amp; requestingFieldMatch &amp;&amp; sectionCrumbMatch;
 610     }
 611 
 612     private Long getOwningProductBundlesDefaultSkuId(SectionCrumb sectionCrumb) {
 613         if (ProductImpl.class.getCanonicalName().equals(sectionCrumb.getSectionIdentifier())
 614                 &amp;&amp; sectionCrumb.getSectionId() != null) {
<abbr title=" 615             ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(sectionCrumb.getSectionId()));"> 615             ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(secðŸ”µ</abbr>
 616             return productBundle.getDefaultSku().getId();
 617         }
 618         return null;
 619     }
 620 
<abbr title=" 621     public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage, String skuPropertyPrefix) {"> 621     public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObjecðŸ”µ</abbr>
 622 
 623         //if the front
 624         final List&lt;Long&gt; productOptionValueFilterIDs = new ArrayList&lt;&gt;();
 625         for (String filterProperty : cto.getCriteriaMap().keySet()) {
 626             if (filterProperty.startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 627                 FilterAndSortCriteria criteria = cto.get(filterProperty);
 628                 productOptionValueFilterIDs.add(Long.parseLong(criteria.getFilterValues().get(0)));
 629             }
 630         }
 631 
 632         //also determine if there is a consolidated POV query
 633         final List&lt;String&gt; productOptionValueFilterValues = new ArrayList&lt;&gt;();
 634         FilterAndSortCriteria consolidatedCriteria = cto.get(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 635         if (!consolidatedCriteria.getFilterValues().isEmpty()) {
 636             //the criteria in this case would be a semi-colon delimeter value list
<abbr title=" 637             productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.getFilterValues().get(0), CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER)));"> 637             productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.geðŸ”µ</abbr>
 638         }
 639 
 640         if (productOptionValueFilterIDs.size() &gt; 0) {
 641             FilterMapping filterMapping = new FilterMapping()
<abbr title=" 642                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.id&quot;))"> 642                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?ðŸ”µ</abbr>
 643                 .withDirectFilterValues(productOptionValueFilterIDs)
 644                 .withRestriction(new Restriction()
 645                     .withPredicateProvider(new PredicateProvider() {
 646                         @Override
<abbr title=" 647                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 647                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPaðŸ”µ</abbr>
 648                                                         From root, String ceilingEntity,
<abbr title=" 649                                                         String fullPropertyName, Path explicitPath, List directValues) {"> 649                                                         String fullPropertyName, Path explicitPath, List ðŸ”µ</abbr>
 650                             return explicitPath.as(Long.class).in(directValues);
 651                         }
 652                     })
 653                 );
 654             filterMappings.add(filterMapping);
 655         }
 656         if (productOptionValueFilterValues.size() &gt; 0) {
 657             FilterMapping filterMapping = new FilterMapping()
<abbr title=" 658                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.attributeValue&quot;))"> 658                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?ðŸ”µ</abbr>
 659                 .withDirectFilterValues(productOptionValueFilterValues)
 660                 .withRestriction(new Restriction()
 661                     .withPredicateProvider(new PredicateProvider() {
 662                         @Override
<abbr title=" 663                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 663                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPaðŸ”µ</abbr>
 664                                                         From root, String ceilingEntity,
<abbr title=" 665                                                         String fullPropertyName, Path explicitPath, List directValues) {"> 665                                                         String fullPropertyName, Path explicitPath, List ðŸ”µ</abbr>
 666                             return explicitPath.as(String.class).in(directValues);
 667                         }
 668                     })
 669                 );
 670             filterMappings.add(filterMapping);
 671         }
 672     }
 673 
 674     /**
<abbr title=" 675      * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the queryCritiera. At the"> 675      * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the qðŸ”µ</abbr>
<abbr title=" 676      * point that this method has been called, criteria from the frontend has already been applied, thus allowing you to"> 676      * point that this method has been called, criteria from the frontend has already been applied, thus ðŸ”µ</abbr>
 677      * override from there as well.&lt;/p&gt;
<abbr title=" 678      * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filter criteria"> 678      * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filtðŸ”µ</abbr>
 679      * can be applied for product option values&lt;/p&gt;
 680      *
 681      */
<abbr title=" 682     public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 682     public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cðŸ”µ</abbr>
 683         //unimplemented
 684     }
 685 
 686     @Override
<abbr title=" 687     public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 687     public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelðŸ”µ</abbr>
 688         Entity entity = persistencePackage.getEntity();
 689         try {
 690             //Fill out the Sku instance from the form
<abbr title=" 691             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 691             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 692             Sku adminInstance = (Sku) Class.forName(entity.getType()[0]).newInstance();
<abbr title=" 693             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 693             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getNaðŸ”µ</abbr>
 694             filterOutProductMetadata(adminProperties);
<abbr title=" 695             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);"> 695             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, ðŸ”µ</abbr>
 696 
 697             //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 698             Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
<abbr title=" 699                                                                              getProductOptionProperties(entity),"> 699                                                                              getProductOptionProperties(eðŸ”µ</abbr>
 700                                                                              null);
 701             if (errorEntity != null) {
 702                 entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 703                 return entity;
 704             }
 705 
 706             //persist the newly-created Sku
 707             adminInstance = dynamicEntityDao.persist(adminInstance);
 708 
 709             //associate the product option values
 710             associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 711 
 712             //After associating the product option values, save off the Sku
 713             adminInstance = dynamicEntityDao.merge(adminInstance);
 714 
 715             //Fill out the DTO and add in the product option value properties to it
 716             Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 717             for (Property property : getProductOptionProperties(entity)) {
 718                 result.addProperty(property);
 719             }
 720             return result;
 721         } catch (Exception e) {
 722             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + Sku.class.getName(), e);
 723         }
 724     }
 725 
 726     @Override
<abbr title=" 727     public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 727     public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordðŸ”µ</abbr>
 728         Entity entity = persistencePackage.getEntity();
 729         try {
 730             //Fill out the Sku instance from the form
<abbr title=" 731             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 731             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title=" 732             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 732             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getNaðŸ”µ</abbr>
 733             filterOutProductMetadata(adminProperties);
 734             Object primaryKey = helper.getPrimaryKey(entity, adminProperties);
<abbr title=" 735             Sku adminInstance = (Sku) dynamicEntityDao.retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 735             Sku adminInstance = (Sku) dynamicEntityDao.retrieve(Class.forName(entity.getType()[0]), primaðŸ”µ</abbr>
<abbr title=" 736             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);"> 736             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, ðŸ”µ</abbr>
 737 
 738             //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 739             Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
<abbr title=" 740                                                                             getProductOptionProperties(entity),"> 740                                                                             getProductOptionProperties(enðŸ”µ</abbr>
 741                                                                             adminInstance);
 742             if (errorEntity != null) {
 743                 entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 744                 return entity;
 745             }
 746 
 747             // Only modify product options if this ISN&#x27;T an update for inventory properties
 748             if (!persistencePackage.containsCriteria(INVENTORY_ONLY_CRITERIA)) {
 749                 associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 750             }
 751 
 752             adminInstance = dynamicEntityDao.merge(adminInstance);
 753 
 754             extensionManager.getProxy().skuUpdated(adminInstance);
 755 
 756             //Fill out the DTO and add in the product option value properties to it
 757             Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 758             for (Property property : getProductOptionProperties(entity)) {
 759                 result.addProperty(property);
 760             }
 761             return result;
 762         } catch (Exception e) {
 763             throw new ServiceException(&quot;Unable to perform update for entity: &quot; + Sku.class.getName(), e);
 764         }
 765     }
 766 
 767     @Override
 768     protected String[] getPolymorphicClasses(Class&lt;?&gt; clazz, EntityManager em, boolean useCache) {
 769         DynamicDaoHelperImpl helper = new DynamicDaoHelperImpl();
 770         Class&lt;?&gt;[] classes = helper.getAllPolymorphicEntitiesFromCeiling(clazz, true, useCache);
 771         String[] result = new String[classes.length];
 772         for (int i = 0; i &lt; classes.length; i++) {
 773             result[i] = classes[i].getName();
 774         }
 775         return result;
 776     }
 777 
 778     /**
<abbr title=" 779      * This initially removes all of the product option values that are currently related to the Sku and then re-associates"> 779      * This initially removes all of the product option values that are currently related to the Sku and ðŸ”µ</abbr>
 780      * the {@link ProductOptionValue}s
 781      * @param entity
 782      * @param adminInstance
 783      */
<abbr title=" 784     protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dynamicEntityDao) {"> 784     protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dðŸ”µ</abbr>
 785         //Get the list of product option value ids that were selected from the form
 786         List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 787         for (Property property : getProductOptionProperties(entity)) {
 788             Long propId = Long.parseLong(property.getValue());
 789             productOptionValueIds.add(propId);
 790             property.setIsDirty(true);
 791         }
 792 
 793         // Only process associations if product option value changes came in via the form
 794         if (CollectionUtils.isNotEmpty(productOptionValueIds)) {
 795             //remove the current list of product option values from the Sku
 796             if (adminInstance.getProductOptionValueXrefs().size() &gt; 0) {
<abbr title=" 797                 Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs().iterator();"> 797                 Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs()ðŸ”µ</abbr>
 798                 while (iterator.hasNext()) {
 799                     dynamicEntityDao.remove(iterator.next());
 800                 }
 801                 dynamicEntityDao.merge(adminInstance);
 802             }
 803 
 804             //Associate the product option values from the form with the Sku
 805             for (Long id : productOptionValueIds) {
<abbr title=" 806                 //Simply find the changed ProductOptionValues directly - seems to work better with sandboxing code"> 806                 //Simply find the changed ProductOptionValues directly - seems to work better with sandboðŸ”µ</abbr>
<abbr title=" 807                 ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpl.class, id);"> 807                 ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpðŸ”µ</abbr>
 808                 SkuProductOptionValueXref xref = new SkuProductOptionValueXrefImpl(adminInstance, pov);
 809                 xref = dynamicEntityDao.merge(xref);
 810                 adminInstance.getProductOptionValueXrefs().add(xref);
 811             }
 812         }
 813     }
 814 
 815     protected List&lt;Property&gt; getProductOptionProperties(Entity entity) {
 816         List&lt;Property&gt; productOptionProperties = new ArrayList&lt;&gt;();
 817         for (Property property : entity.getProperties()) {
 818             if (property.getName().startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 819                 productOptionProperties.add(property);
 820             }
 821         }
 822         return productOptionProperties;
 823     }
 824 
 825     /**
<abbr title=" 826      * Ensures that the given list of {@link ProductOptionValue} IDs is unique for the given {@link Product}."> 826      * Ensures that the given list of {@link ProductOptionValue} IDs is unique for the given {@link ProduðŸ”µ</abbr>
 827      *
<abbr title=" 828      * If sku browsing is enabled, then it is assumed that a single combination of {@link ProductOptionValue} IDs"> 828      * If sku browsing is enabled, then it is assumed that a single combination of {@link ProductOptionVaðŸ”µ</abbr>
<abbr title=" 829      * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProductOptionValue} IDs."> 829      * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProducðŸ”µ</abbr>
 830      * In this case, the following validation is skipped.
 831      *
 832      * @param product
 833      * @param productOptionProperties
<abbr title=" 834      * @param currentSku - for update operations, this is the current Sku that is being updated; should be excluded from"> 834      * @param currentSku - for update operations, this is the current Sku that is being updated; should bðŸ”µ</abbr>
 835      * attempting validation
 836      * @return &lt;b&gt;null&lt;/b&gt; if successfully validation, the error entity otherwise
 837      */
<abbr title=" 838     protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOptionProperties, Sku currentSku) {"> 838     protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOðŸ”µ</abbr>
 839         //do not attempt POV validation if no PO properties were passed in
 840         if (CollectionUtils.isNotEmpty(productOptionProperties)) {
 841             List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 842             for (Property property : productOptionProperties) {
 843                 productOptionValueIds.add(Long.parseLong(property.getValue()));
 844             }
 845 
 846             boolean validated = true;
 847             for (Sku sku : product.getAdditionalSkus()) {
 848                 if (currentSku == null || !sku.getId().equals(currentSku.getId())) {
 849                     List&lt;Long&gt; testList = new ArrayList&lt;&gt;();
 850                     for (ProductOptionValue optionValue : sku.getProductOptionValues()) {
 851                         testList.add(optionValue.getId());
 852                     }
 853 
 854                     if (CollectionUtils.isNotEmpty(testList) &amp;&amp;
 855                             productOptionValueIds.containsAll(testList) &amp;&amp;
 856                             productOptionValueIds.size() == testList.size()) {
 857                         validated = false;
 858                         break;
 859                     }
 860                 }
 861             }
 862 
 863             if (!validated) {
 864                 Entity errorEntity = new Entity();
 865                 for (Property productOptionProperty : productOptionProperties) {
 866                     errorEntity.addValidationError(productOptionProperty.getName(), &quot;uniqueSkuError&quot;);
 867                 }
 868                 return errorEntity;
 869             }
 870         }
 871         return null;
 872     }
 873 
 874 }
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Admin Module
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.admin.server.service.handler;
  19 
  20 import java.io.Serializable;
  21 import java.util.ArrayList;
  22 import java.util.Arrays;
  23 import java.util.Collection;
  24 import java.util.Collections;
  25 import java.util.HashMap;
  26 import java.util.Iterator;
  27 import java.util.List;
  28 import java.util.Map;
  29 import javax.annotation.Resource;
  30 import javax.persistence.EntityManager;
  31 import javax.persistence.PersistenceContext;
  32 import javax.persistence.TypedQuery;
  33 import javax.persistence.criteria.CriteriaBuilder;
  34 import javax.persistence.criteria.From;
  35 import javax.persistence.criteria.Path;
  36 import javax.persistence.criteria.Predicate;
  37 import org.apache.commons.collections.CollectionUtils;
  38 import org.apache.commons.collections.Transformer;
  39 import org.apache.commons.lang.BooleanUtils;
  40 import org.apache.commons.lang3.ArrayUtils;
  41 import org.apache.commons.lang3.StringUtils;
  42 import org.apache.commons.lang3.math.NumberUtils;
  43 import org.apache.commons.logging.Log;
  44 import org.apache.commons.logging.LogFactory;
  45 import org.broadleafcommerce.admin.server.service.SkuMetadataCacheService;
  46 import org.broadleafcommerce.common.exception.ServiceException;
  47 import org.broadleafcommerce.common.presentation.client.LookupType;
  48 import org.broadleafcommerce.common.presentation.client.OperationType;
  49 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  50 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  51 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  52 import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  53 import org.broadleafcommerce.common.util.BLCCollectionUtils;
  54 import org.broadleafcommerce.common.util.StringUtil;
  55 import org.broadleafcommerce.common.util.TypedTransformer;
  56 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  57 import org.broadleafcommerce.core.catalog.domain.Product;
  58 import org.broadleafcommerce.core.catalog.domain.ProductBundle;
  59 import org.broadleafcommerce.core.catalog.domain.ProductImpl;
  60 import org.broadleafcommerce.core.catalog.domain.ProductOption;
  61 import org.broadleafcommerce.core.catalog.domain.ProductOptionImpl;
  62 import org.broadleafcommerce.core.catalog.domain.ProductOptionValue;
  63 import org.broadleafcommerce.core.catalog.domain.ProductOptionValueImpl;
  64 import org.broadleafcommerce.core.catalog.domain.Sku;
  65 import org.broadleafcommerce.core.catalog.domain.SkuImpl;
  66 import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXref;
  67 import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXrefImpl;
  68 import org.broadleafcommerce.core.catalog.service.CatalogService;
  69 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  70 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  71 import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;
  72 import org.broadleafcommerce.openadmin.dto.DynamicResultSet;
  73 import org.broadleafcommerce.openadmin.dto.Entity;
  74 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  75 import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;
  76 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  77 import org.broadleafcommerce.openadmin.dto.PersistencePackage;
  78 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  79 import org.broadleafcommerce.openadmin.dto.Property;
  80 import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  81 import org.broadleafcommerce.openadmin.server.dao.DynamicEntityDao;
  82 import org.broadleafcommerce.openadmin.server.service.handler.CustomPersistenceHandlerAdapter;
  83 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  84 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManagerFactory;
  85 import org.broadleafcommerce.openadmin.server.service.persistence.module.InspectHelper;
  86 import org.broadleafcommerce.openadmin.server.service.persistence.module.PersistenceModule;
  87 import org.broadleafcommerce.openadmin.server.service.persistence.module.RecordHelper;
  88 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;
  89 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;
  90 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;
  91 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;
  92 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;
<abbr title="  93 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  93 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
  94 import org.springframework.beans.factory.annotation.Value;
  95 import org.springframework.stereotype.Component;
  96 import static com.google.common.base.CharMatcher.DIGIT;
  97 
  98 
  99 /**
 100  * @author Phillip Verheyden
 101  *
 102  */
 103 @Component(&quot;blSkuCustomPersistenceHandler&quot;)
 104 public class SkuCustomPersistenceHandler extends CustomPersistenceHandlerAdapter {
 105     private static final Log LOG = LogFactory.getLog(SkuCustomPersistenceHandler.class);
 106 
 107     public static String PRODUCT_OPTION_FIELD_PREFIX = &quot;productOption&quot;;
 108 
 109     public static String INVENTORY_ONLY_CRITERIA = &quot;onlyInventoryProperties&quot;;
 110 
 111     @Value(&quot;${use.to.one.lookup.sku.product.option.value:false}&quot;)
 112     protected boolean useToOneLookupSkuProductOptionValue = false;
 113 
 114     @Resource(name =&quot;blSkuMetadataCacheService&quot;)
 115     protected SkuMetadataCacheService skuMetadataCacheService;
 116 
 117     @Resource(name=&quot;blAdornedTargetListPersistenceModule&quot;)
 118     protected PersistenceModule adornedPersistenceModule;
 119 
 120     @Resource(name = &quot;blSkuCustomPersistenceHandlerExtensionManager&quot;)
 121     protected SkuCustomPersistenceHandlerExtensionManager extensionManager;
 122 
 123     /**
<abbr title=" 124      * This represents the field that all of the product option values will be stored in. This would be used in the case"> 124      * This represents the field that all of the product option values will be stored in. This would be uðŸ”µ</abbr>
<abbr title=" 125      * where there are a bunch of product options and displaying each option as a grid header would have everything"> 125      * where there are a bunch of product options and displaying each option as a grid header would have ðŸ”µ</abbr>
 126      * squashed together. Filtering on this field is currently unsupported.
 127      */
 128     public static String CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME = &quot;consolidatedProductOptions&quot;;
 129 
 130     public static String CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER = &quot;; &quot;;
 131 
 132     @Resource(name=&quot;blCatalogService&quot;)
 133     protected CatalogService catalogService;
 134 
 135     @PersistenceContext(unitName = &quot;blPU&quot;)
 136     protected EntityManager em;
 137 
 138     @Resource(name = &quot;blCriteriaTranslator&quot;)
 139     protected CriteriaTranslator criteriaTranslator;
 140 
 141     @Resource(name = &quot;blSandBoxHelper&quot;)
 142     protected SandBoxHelper sandBoxHelper;
 143 
 144     @Override
 145     public Boolean canHandleInspect(PersistencePackage persistencePackage) {
<abbr title=" 146         return canHandle(persistencePackage, persistencePackage.getPersistencePerspective().getOperationTypes()"> 146         return canHandle(persistencePackage, persistencePackage.getPersistencePerspective().getOperationTðŸ”µ</abbr>
 147                 .getInspectType());
 148     }
 149 
 150     @Override
 151     public Boolean canHandleFetch(PersistencePackage persistencePackage) {
<abbr title=" 152         OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFetchType();"> 152         OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFðŸ”µ</abbr>
 153         return canHandle(persistencePackage, fetchType);
 154     }
 155 
 156     @Override
 157     public Boolean canHandleAdd(PersistencePackage persistencePackage) {
<abbr title=" 158         OperationType addType = persistencePackage.getPersistencePerspective().getOperationTypes().getAddType();"> 158         OperationType addType = persistencePackage.getPersistencePerspective().getOperationTypes().getAddðŸ”µ</abbr>
 159         return canHandle(persistencePackage, addType);
 160     }
 161 
 162     @Override
 163     public Boolean canHandleUpdate(PersistencePackage persistencePackage) {
<abbr title=" 164         OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getUpdateType();"> 164         OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getðŸ”µ</abbr>
 165         return canHandle(persistencePackage, updateType);
 166     }
 167 
 168     /**
<abbr title=" 169      * Since this is the default for all Skus, it&#x27;s possible that we are providing custom criteria for this"> 169      * Since this is the default for all Skus, it&#x27;s possible that we are providing custom criteria for thðŸ”µ</abbr>
<abbr title=" 170      * Sku lookup. In that case, we probably want to delegate to a child class, so only use this particular"> 170      * Sku lookup. In that case, we probably want to delegate to a child class, so only use this particulðŸ”µ</abbr>
<abbr title=" 171      * persistence handler if there is no custom criteria being used and the ceiling entity is an instance of Sku. The"> 171      * persistence handler if there is no custom criteria being used and the ceiling entity is an instancðŸ”µ</abbr>
<abbr title=" 172      * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for the ceiling entity"> 172      * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for thðŸ”µ</abbr>
<abbr title=" 173      * class name. That should be handled by the map structure module though, so only handle things in the Sku custom"> 173      * class name. That should be handled by the map structure module though, so only handle things in thðŸ”µ</abbr>
 174      * persistence handler for OperationType.BASIC
 175      *
 176      */
 177     protected Boolean canHandle(PersistencePackage persistencePackage, OperationType operationType) {
<abbr title=" 178         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 178         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 179         try {
 180             Class testClass = Class.forName(ceilingEntityFullyQualifiedClassname);
 181             return Sku.class.isAssignableFrom(testClass) &amp;&amp;
 182                     //ArrayUtils.isEmpty(persistencePackage.getCustomCriteria()) &amp;&amp;
 183                     OperationType.BASIC.equals(operationType) &amp;&amp;
<abbr title=" 184                     (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.ADORNEDTARGETLIST) == null);"> 184                     (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 185         } catch (ClassNotFoundException e) {
 186             return false;
 187         }
 188     }
 189 
 190     /**
 191      * Build out the extra fields for the product options
 192      */
 193     @Override
<abbr title=" 194     public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, InspectHelper helper) throws ServiceException {"> 194     public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityðŸ”µ</abbr>
 195         try {
<abbr title=" 196             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 196             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 197             Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties = new HashMap&lt;&gt;();
 198             String productIdStr = getOwningProductId(persistencePackage.getSectionCrumbs());
 199             String cacheKey = skuMetadataCacheService.buildCacheKey(productIdStr);
 200             Map&lt;String, FieldMetadata&gt; properties = null;
 201             boolean useCache = skuMetadataCacheService.useCache();
 202             if (useCache) {
 203                 properties = skuMetadataCacheService.getFromCache(cacheKey);
 204             }
 205             if (properties == null) {
 206                 // Grab the default properties for the Sku
<abbr title=" 207                 properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspective);"> 207                 properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspecðŸ”µ</abbr>
 208                 boolean isFirstCriteriaNAN = productIdStr == null;
 209                 if ((!isFirstCriteriaNAN) &amp;&amp; useToOneLookupSkuProductOptionValue) {
 210                     isFirstCriteriaNAN = !;
 211                 }
 212                 if (isFirstCriteriaNAN) {
 213                     // look up all the ProductOptions and then create new fields for each of them
 214                     List&lt;ProductOption&gt; options = catalogService.readAllProductOptions();
 215                     int order = 0;
 216                     for (ProductOption option : options) {
 217                         // add this to the built Sku properties
 218                         FieldMetadata md = createIndividualOptionField(option, order);
 219                         if (md != null) {
 220                             properties.put(&quot;productOption&quot; + option.getId(), md);
 221                         }
 222                     }
 223                 } else {
 224                     // If we have a product to filter the list of available product options, then use it
 225                     try {
 226                         Long productId = Long.parseLong(productIdStr);
 227                         Product product = catalogService.findProductById(productId);
 228                         for (ProductOption option : product.getProductOptions()) {
 229                             FieldMetadata md = createIndividualOptionField(option, 0);
 230                             if (md != null) {
 231                                 properties.put(&quot;productOption&quot; + option.getId(), md);
 232                             }
 233                         }
 234                     } catch (java.lang.NumberFormatException e) {
 235                         // there wasn&#x27;t a valid product id, just don&#x27;t do anything
 236                     }
 237                 }
<abbr title=" 238                 // also build the consolidated field; if using the SkuBasicClientEntityModule then this field will be"> 238                 // also build the consolidated field; if using the SkuBasicClientEntityModule then this fðŸ”µ</abbr>
 239                 // permanently hidden
<abbr title=" 240                 properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuImpl.class));"> 240                 properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuðŸ”µ</abbr>
 241                 if (useCache) {
 242                     skuMetadataCacheService.addToCache(cacheKey, properties);
 243                 }
 244             }
 245             allMergedProperties.put(MergedPropertyType.PRIMARY, properties);
 246             // allow the adorned list to contribute properties as well in the case of Sku bundle items
 247             adornedPersistenceModule.setPersistenceManager(((PersistenceManager) (helper)));
 248             adornedPersistenceModule.updateMergedProperties(persistencePackage, allMergedProperties);
<abbr title=" 249             Class&lt;?&gt;[] entityClasses = dynamicEntityDao.getAllPolymorphicEntitiesFromCeiling(SkuImpl.class);"> 249             Class&lt;?&gt;[] entityClasses = dynamicEntityDao.getAllPolymorphicEntitiesFromCeiling(SkuImpl.clasðŸ”µ</abbr>
<abbr title=" 250             for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.entrySet()) {"> 250             for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.enðŸ”µ</abbr>
 251                 filterOutProductMetadata(entry.getValue());
 252             }
<abbr title=" 253             ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, allMergedProperties);"> 253             ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, aðŸ”µ</abbr>
 254             DynamicResultSet results = new DynamicResultSet(mergedMetadata, null, null);
 255             return results;
 256         } catch (java.lang.Exception e) {
<abbr title=" 257             ServiceException ex = new ServiceException(&quot;Unable to retrieve inspection results for &quot; + persistencePackage.getCeilingEntityFullyQualifiedClassname(), e);"> 257             ServiceException ex = new ServiceException(&quot;Unable to retrieve inspection results for &quot; + perðŸ”µ</abbr>
 258             throw ex;
 259         }
 260     }
 261 
 262     protected String getOwningProductId(SectionCrumb[] sectionCrumbs) {
<abbr title=" 263         if (ArrayUtils.isNotEmpty(sectionCrumbs) &amp;&amp; ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectionIdentifier())) {"> 263         if (ArrayUtils.isNotEmpty(sectionCrumbs) &amp;&amp; ProductImpl.class.getCanonicalName().equals(sectionCrðŸ”µ</abbr>
 264             return sectionCrumbs[0].getSectionId();
 265         }
 266 
 267 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 268             return null;</span>
 269 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 270 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 270 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 271 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 272 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 273         return null;</span>
 274 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 275 
 276     }
 277 
 278     protected void filterOutProductMetadata(Map&lt;String, FieldMetadata&gt; map) {
<abbr title=" 279         //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdminPresentation,"> 279         //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdmðŸ”µ</abbr>
 280         //but there&#x27;s a bug preventing this behavior from completely working correctly
 281         List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 282         for (Map.Entry&lt;String, FieldMetadata&gt; entry : map.entrySet()) {
 283             if (entry.getKey().contains(&quot;defaultProduct.&quot;) || entry.getKey().contains(&quot;product.&quot;)) {
 284                 removeKeys.add(entry.getKey());
 285             }
 286         }
 287         for (String removeKey : removeKeys) {
 288             map.remove(removeKey);
 289         }
 290     }
 291 
 292     /**
<abbr title=" 293      * Creates the metadata necessary for displaying all of the product option values in a single field. The display of this"> 293      * Creates the metadata necessary for displaying all of the product option values in a single field. ðŸ”µ</abbr>
<abbr title=" 294      * field is a single string with every product option value appended to it separated by a semicolon. This method should"> 294      * field is a single string with every product option value appended to it separated by a semicolon. ðŸ”µ</abbr>
<abbr title=" 295      * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be populated on fetch."> 295      * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be pðŸ”µ</abbr>
 296      *
<abbr title=" 297      * The metadata that is returned will also be set to prominent by default so that it will be ready to display on whatever"> 297      * The metadata that is returned will also be set to prominent by default so that it will be ready toðŸ”µ</abbr>
<abbr title=" 298      * grid is being inspected. If you do not want this behavior you will need to override this functionality in the metadata"> 298      * grid is being inspected. If you do not want this behavior you will need to override this functionaðŸ”µ</abbr>
 299      * that is returned.
 300      *
<abbr title=" 301      * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, but if you want to"> 301      * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, bðŸ”µ</abbr>
 302      * display this field with a different entity then this should be that entity
 303      * @return
 304      */
 305     public FieldMetadata createConsolidatedOptionField(Class&lt;?&gt; inheritedFromType) {
 306         BasicFieldMetadata metadata = new BasicFieldMetadata();
 307         metadata.setFieldType(SupportedFieldType.STRING);
 308         metadata.setMutable(false);
 309         metadata.setInheritedFromType(inheritedFromType.getName());
 310 
<abbr title=" 311         metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 311         metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useðŸ”µ</abbr>
 312         metadata.setForeignKeyCollection(false);
 313         metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 314 
 315         metadata.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 316         metadata.setFriendlyName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 317         metadata.setGroup(&quot;&quot;);
 318         metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 319         metadata.setProminent(true);
 320         metadata.setVisibility(VisibilityEnum.FORM_HIDDEN);
 321         metadata.setBroadleafEnumeration(&quot;&quot;);
 322         metadata.setReadOnly(true);
 323         metadata.setRequiredOverride(false);
 324         metadata.setGridOrder(Integer.MAX_VALUE);
 325 
 326         return metadata;
 327     }
 328 
 329     /**
<abbr title=" 330      * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed in. This should be"> 330      * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed iðŸ”µ</abbr>
 331      * invoked on a fetch and the returned property should be added to the fetched {@link Entity} dto.
 332      *
 333      * @param values
 334      * @return
 335      * @see {@link #createConsolidatedOptionField(Class)};
 336      */
 337     public Property getConsolidatedOptionProperty(Collection&lt;ProductOptionValue&gt; values) {
 338         Property optionValueProperty = new Property();
 339         optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 340 
 341         //order the values by the display order of their correspond product option
 342         //        Collections.sort(values, new Comparator&lt;ProductOptionValue&gt;() {
 343         //
 344         //            @Override
 345         //            public int compare(ProductOptionValue value1, ProductOptionValue value2) {
<abbr title=" 346         //                return new CompareToBuilder().append(value1.getProductOption().getDisplayOrder(),"> 346         //                return new CompareToBuilder().append(value1.getProductOption().getDisplayOrder(ðŸ”µ</abbr>
 347         //                        value2.getProductOption().getDisplayOrder()).toComparison();
 348         //            }
 349         //        });
 350 
 351         ArrayList&lt;String&gt; stringValues = new ArrayList&lt;&gt;();
 352         CollectionUtils.collect(values, new Transformer() {
 353 
 354             @Override
 355             public Object transform(Object input) {
 356                 return ((ProductOptionValue) input).getAttributeValue();
 357             }
 358         }, stringValues);
 359 
<abbr title=" 360         optionValueProperty.setValue(StringUtils.join(stringValues, CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER));"> 360         optionValueProperty.setValue(StringUtils.join(stringValues, CONSOLIDATED_PRODUCT_OPTIONS_DELIMETEðŸ”µ</abbr>
 361         return optionValueProperty;
 362     }
 363 
 364     /**
 365      * @return a blank {@link Property} corresponding to the CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME
 366      */
 367     public Property getBlankConsolidatedOptionProperty() {
 368         Property optionValueProperty = new Property();
 369         optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 370         optionValueProperty.setValue(&quot;&quot;);
 371         return optionValueProperty;
 372     }
 373 
 374     /**
<abbr title=" 375      * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum field whose values will"> 375      * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum fieðŸ”µ</abbr>
<abbr title=" 376      * be the option values for this option.  This is useful when you would like to display each product option in as its"> 376      * be the option values for this option.  This is useful when you would like to display each product ðŸ”µ</abbr>
 377      * own field in a grid so that you can further filter by product option values.&lt;/p&gt;
<abbr title=" 378      * &lt;p&gt;In order for these fields to be utilized property on the fetch, in the GWT frontend you must use the"> 378      * &lt;p&gt;In order for these fields to be utilized property on the fetch, in the GWT frontend you must usðŸ”µ</abbr>
 379      * for your datasource.&lt;/p&gt;
 380      *
 381      * @param option
 382      * @param order
 383      * @return
 384      */
 385     public FieldMetadata createIndividualOptionField(ProductOption option, int order) {
 386         if (useToOneLookupSkuProductOptionValue) {
 387             return createToOneIndividualOptionField(option, order);
 388         } else {
 389             return createExplicitEnumerationIndividualOptionField(option, order);
 390         }
 391     }
 392 
<abbr title=" 393     protected FieldMetadata createExplicitEnumerationIndividualOptionField(ProductOption option, int order) {"> 393     protected FieldMetadata createExplicitEnumerationIndividualOptionField(ProductOption option, int ordeðŸ”µ</abbr>
 394         BasicFieldMetadata metadata = new BasicFieldMetadata();
 395         List&lt;ProductOptionValue&gt; allowedValues = option.getAllowedValues();
 396         if (CollectionUtils.isNotEmpty(allowedValues)) {
 397             metadata.setFieldType(SupportedFieldType.EXPLICIT_ENUMERATION);
 398             metadata.setMutable(true);
 399             metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 400             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 400             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheServiceðŸ”µ</abbr>
 401             metadata.setForeignKeyCollection(false);
 402             metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 403 
 404             //Set up the enumeration based on the product option values
 405             String[][] optionValues = new String[allowedValues.size()][2];
 406             for (int i = 0; i &lt; allowedValues.size(); i++) {
 407                 ProductOptionValue value = option.getAllowedValues().get(i);
 408                 optionValues[i][0] = value.getId().toString();
 409                 optionValues[i][1] = value.getAttributeValue();
 410             }
 411             metadata.setEnumerationValues(optionValues);
 412 
 413             metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 414             metadata.setFriendlyName(option.getLabel());
 415             metadata.setGroup(&quot;productOption_group&quot;);
 416             metadata.setGroupOrder(-1);
 417             metadata.setOrder(order);
 418             metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 419             metadata.setProminent(false);
 420             metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 421             metadata.setBroadleafEnumeration(&quot;&quot;);
 422             metadata.setReadOnly(false);
 423             metadata.setRequiredOverride(BooleanUtils.isFalse(option.getRequired()));
 424 
 425             return metadata;
 426         }
 427         return null;
 428     }
 429 
 430     /**
<abbr title=" 431      * Using a ToOne lookup performs much better for large product option value lists, speeds up initial page load,"> 431      * Using a ToOne lookup performs much better for large product option value lists, speeds up initial ðŸ”µ</abbr>
<abbr title=" 432      * and is generally more accurate in relation to option value updates and how they impact available selections and cache."> 432      * and is generally more accurate in relation to option value updates and how they impact available sðŸ”µ</abbr>
 433      *
 434      * @param option
 435      * @param order
 436      * @return
 437      */
 438     protected FieldMetadata createToOneIndividualOptionField(ProductOption option, int order) {
 439         PersistenceManager persistenceManager = PersistenceManagerFactory.getPersistenceManager();
 440         FilterMapping filterMapping = new FilterMapping().withDirectFilterValues(
<abbr title=" 441                 sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(new Restriction()"> 441                 sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(newðŸ”µ</abbr>
 442             .withPredicateProvider(new PredicateProvider() {
 443                 @Override
<abbr title=" 444                 public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder, From root,"> 444                 public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuildeðŸ”µ</abbr>
<abbr title=" 445                                                 String ceilingEntity, String fullPropertyName, Path explicitPath, List directValues) {"> 445                                                 String ceilingEntity, String fullPropertyName, Path expliðŸ”µ</abbr>
 446                     return root.get(&quot;productOption&quot;).get(&quot;id&quot;).in(directValues);
 447             }
 448         }));
 449         List&lt;FilterMapping&gt; mappings = new ArrayList&lt;&gt;();
 450         mappings.add(filterMapping);
<abbr title=" 451         TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),"> 451         TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.gðŸ”µ</abbr>
 452                 ProductOptionValueImpl.class.getName(), mappings);
 453         Long count = (Long) countQuery.getSingleResult();
 454         BasicFieldMetadata metadata = null;
 455         if (count &gt; 0) {
 456             metadata = new BasicFieldMetadata();
 457             metadata.setFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 458             metadata.setSecondaryType(SupportedFieldType.INTEGER);
 459             metadata.setForeignKeyProperty(&quot;id&quot;);
 460             metadata.setForeignKeyClass(ProductOptionValueImpl.class.getName());
 461             metadata.setForeignKeyDisplayValueProperty(&quot;attributeValue&quot;);
 462             metadata.setLookupDisplayProperty(&quot;attributeValue&quot;);
 463             metadata.setForeignKeyCollection(false);
 464             metadata.setCustomCriteria(new String[]{&quot;option=&quot; + String.valueOf(option.getId())});
 465             metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 466             metadata.setFriendlyName(option.getLabel());
 467             metadata.setGroup(&quot;productOption_group&quot;);
 468             metadata.setGroupOrder(-1);
 469             metadata.setOrder(order);
 470             metadata.setExplicitFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 471             metadata.setProminent(false);
 472             metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 473             metadata.setReadOnly(false);
<abbr title=" 474             //these may not be actually required, but the CPH has this as a requirement for parsing the data, so we&#x27;ll stick with it here"> 474             //these may not be actually required, but the CPH has this as a requirement for parsing the dðŸ”µ</abbr>
 475             metadata.setRequiredOverride(true);
 476             metadata.setLookupType(LookupType.STANDARD);
 477             metadata.setMutable(true);
 478             metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 479             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 479             metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheServiceðŸ”µ</abbr>
 480             metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 481             metadata.setTargetClass(SkuImpl.class.getName());
 482             metadata.setFieldName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 483         }
 484         return metadata;
 485     }
 486 
 487     @SuppressWarnings(&quot;unchecked&quot;)
 488     @Override
<abbr title=" 489     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 489     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynaðŸ”µ</abbr>
<abbr title=" 490         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 490         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 491         try {
<abbr title=" 492             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 492             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 493             //get the default properties from Sku and its subclasses
<abbr title=" 494             Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 494             Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getNameðŸ”µ</abbr>
 495 
 496             //Pull back the Skus based on the criteria from the client
<abbr title=" 497             List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, originalProps);"> 497             List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceðŸ”µ</abbr>
 498 
 499             //allow subclasses to provide additional criteria before executing the query
 500             applyProductOptionValueCriteria(filterMappings, cto, persistencePackage, null);
 501             applySkuBundleItemValueCriteria(filterMappings, cto, persistencePackage);
 502             applyAdditionalFetchCriteria(filterMappings, cto, persistencePackage);
 503 
<abbr title=" 504             List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings, cto.getFirstResult(), cto.getMaxResults());"> 504             List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFðŸ”µ</abbr>
 505             //Convert Skus into the client-side Entity representation
 506             Entity[] payload = helper.getRecords(originalProps, records);
 507 
<abbr title=" 508             int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings);"> 508             int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 509 
<abbr title=" 510             //Now fill out the relevant properties for the product options for the Skus that were returned"> 510             //Now fill out the relevant properties for the product options for the Skus that were returneðŸ”µ</abbr>
 511             updateProductOptionFieldsForFetch(records, payload);
 512 
 513             return new DynamicResultSet(payload, totalRecords);
 514         } catch (Exception e) {
<abbr title=" 515             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiedClassname, e);"> 515             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiðŸ”µ</abbr>
 516         }
 517     }
 518 
 519     /**
<abbr title=" 520      * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a ListGrid context."> 520      * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a LðŸ”µ</abbr>
 521      *
 522      * @param records
 523      * @param payload
 524      * @return
 525      */
 526     public void updateProductOptionFieldsForFetch(List&lt;Serializable&gt; records, Entity[] payload) {
 527         for (int i = 0; i &lt; records.size(); i++) {
 528             Sku sku = (Sku) records.get(i);
 529             Entity entity = payload[i];
 530 
<abbr title=" 531             List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionValueXrefs(), new TypedTransformer&lt;ProductOptionValue&gt;() {"> 531             List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionVaðŸ”µ</abbr>
 532                 @Override
 533                 public ProductOptionValue transform(Object input) {
 534                     return ((SkuProductOptionValueXref) input).getProductOptionValue();
 535                 }
 536             });
 537 
 538             for (ProductOptionValue value : optionValues) {
 539                 Property optionProperty = new Property();
 540                 optionProperty.setName(PRODUCT_OPTION_FIELD_PREFIX + value.getProductOption().getId());
 541                 optionProperty.setValue(value.getId().toString());
 542                 optionProperty.setDisplayValue(value.getAttributeValue());
 543                 entity.addProperty(optionProperty);
 544             }
 545 
 546             if (CollectionUtils.isNotEmpty(optionValues)) {
 547                 entity.addProperty(getConsolidatedOptionProperty(optionValues));
 548             } else {
 549                 entity.addProperty(getBlankConsolidatedOptionProperty());
 550             }
 551         }
 552     }
 553 
 554     /**
<abbr title=" 555      * Add filter restriction such that a ProductBundle cannot add its own default sku as a Sku Bundle Item"> 555      * Add filter restriction such that a ProductBundle cannot add its own default sku as a Sku Bundle ItðŸ”µ</abbr>
 556      */
<abbr title=" 557     private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 557     private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObjeðŸ”µ</abbr>
 558         SectionCrumb[] sectionCrumbs = persistencePackage.getSectionCrumbs();
 559         if (isSkuBundleItemLookup(persistencePackage, sectionCrumbs)) {
 560             final Long defaultSkuId = getOwningProductBundlesDefaultSkuId(sectionCrumbs[0]);
 561 
 562             filterMappings.add(new FilterMapping()
 563                     .withDirectFilterValues(Collections.singletonList(defaultSkuId))
 564                     .withRestriction(new Restriction()
 565                                     .withPredicateProvider(new PredicateProvider() {
 566                                         @Override
 567                                         public Predicate buildPredicate(CriteriaBuilder builder,
 568                                                 FieldPathBuilder fieldPathBuilder,
 569                                                 From root, String ceilingEntity,
 570                                                 String fullPropertyName, Path explicitPath,
 571                                                 List directValues) {
 572                                             return builder.notEqual(root, directValues.get(0));
 573                                         }
 574                                     })
 575                     ));
 576         }
 577     }
 578 
 579     private boolean isSkuBundleItemLookup(PersistencePackage pkg, SectionCrumb[] sectionCrumbs) {
 580         boolean owningClassMatch = false;
 581         boolean requestingFieldMatch = false;
 582 
 583         if (pkg.getCustomCriteria() == null || ArrayUtils.isEmpty(sectionCrumbs)) {
 584             return false;
 585         }
 586 
 587         for (String criteria : pkg.getCustomCriteria()) {
<abbr title=" 588             if (&quot;owningClass=org.broadleafcommerce.core.catalog.domain.SkuBundleItemImpl&quot;.equals(criteria)) {"> 588             if (&quot;owningClass=org.broadleafcommerce.core.catalog.domain.SkuBundleItemImpl&quot;.equals(criteriaðŸ”µ</abbr>
 589                 owningClassMatch = true;
 590             } else if (&quot;requestingField=sku&quot;.equals(criteria)) {
 591                 requestingFieldMatch = true;
 592             }
 593         }
 594 
<abbr title=" 595         boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectionIdentifier());"> 595         boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectiðŸ”µ</abbr>
 596 
 597         return owningClassMatch &amp;&amp; requestingFieldMatch &amp;&amp; sectionCrumbMatch;
 598     }
 599 
 600     private Long getOwningProductBundlesDefaultSkuId(SectionCrumb sectionCrumb) {
 601         if (ProductImpl.class.getCanonicalName().equals(sectionCrumb.getSectionIdentifier())
 602                 &amp;&amp; sectionCrumb.getSectionId() != null) {
<abbr title=" 603             ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(sectionCrumb.getSectionId()));"> 603             ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(secðŸ”µ</abbr>
 604             return productBundle.getDefaultSku().getId();
 605         }
 606         return null;
 607     }
 608 
<abbr title=" 609     public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage, String skuPropertyPrefix) {"> 609     public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObjecðŸ”µ</abbr>
 610 
 611         //if the front
 612         final List&lt;Long&gt; productOptionValueFilterIDs = new ArrayList&lt;&gt;();
 613         for (String filterProperty : cto.getCriteriaMap().keySet()) {
 614             if (filterProperty.startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 615                 FilterAndSortCriteria criteria = cto.get(filterProperty);
 616                 productOptionValueFilterIDs.add(Long.parseLong(criteria.getFilterValues().get(0)));
 617             }
 618         }
 619 
 620         //also determine if there is a consolidated POV query
 621         final List&lt;String&gt; productOptionValueFilterValues = new ArrayList&lt;&gt;();
 622         FilterAndSortCriteria consolidatedCriteria = cto.get(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 623         if (!consolidatedCriteria.getFilterValues().isEmpty()) {
 624             //the criteria in this case would be a semi-colon delimeter value list
<abbr title=" 625             productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.getFilterValues().get(0), CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER)));"> 625             productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.geðŸ”µ</abbr>
 626         }
 627 
 628         if (productOptionValueFilterIDs.size() &gt; 0) {
 629             FilterMapping filterMapping = new FilterMapping()
<abbr title=" 630                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.id&quot;))"> 630                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?ðŸ”µ</abbr>
 631                 .withDirectFilterValues(productOptionValueFilterIDs)
 632                 .withRestriction(new Restriction()
 633                     .withPredicateProvider(new PredicateProvider() {
 634                         @Override
<abbr title=" 635                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 635                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPaðŸ”µ</abbr>
 636                                                         From root, String ceilingEntity,
<abbr title=" 637                                                         String fullPropertyName, Path explicitPath, List directValues) {"> 637                                                         String fullPropertyName, Path explicitPath, List ðŸ”µ</abbr>
 638                             return explicitPath.as(Long.class).in(directValues);
 639                         }
 640                     })
 641                 );
 642             filterMappings.add(filterMapping);
 643         }
 644         if (productOptionValueFilterValues.size() &gt; 0) {
 645             FilterMapping filterMapping = new FilterMapping()
<abbr title=" 646                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.attributeValue&quot;))"> 646                 .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?ðŸ”µ</abbr>
 647                 .withDirectFilterValues(productOptionValueFilterValues)
 648                 .withRestriction(new Restriction()
 649                     .withPredicateProvider(new PredicateProvider() {
 650                         @Override
<abbr title=" 651                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 651                         public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPaðŸ”µ</abbr>
 652                                                         From root, String ceilingEntity,
<abbr title=" 653                                                         String fullPropertyName, Path explicitPath, List directValues) {"> 653                                                         String fullPropertyName, Path explicitPath, List ðŸ”µ</abbr>
 654                             return explicitPath.as(String.class).in(directValues);
 655                         }
 656                     })
 657                 );
 658             filterMappings.add(filterMapping);
 659         }
 660     }
 661 
 662     /**
<abbr title=" 663      * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the queryCritiera. At the"> 663      * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the qðŸ”µ</abbr>
<abbr title=" 664      * point that this method has been called, criteria from the frontend has already been applied, thus allowing you to"> 664      * point that this method has been called, criteria from the frontend has already been applied, thus ðŸ”µ</abbr>
 665      * override from there as well.&lt;/p&gt;
<abbr title=" 666      * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filter criteria"> 666      * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filtðŸ”µ</abbr>
 667      * can be applied for product option values&lt;/p&gt;
 668      *
 669      */
<abbr title=" 670     public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 670     public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cðŸ”µ</abbr>
 671         //unimplemented
 672     }
 673 
 674     @Override
<abbr title=" 675     public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 675     public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelðŸ”µ</abbr>
 676         Entity entity = persistencePackage.getEntity();
 677         try {
 678             //Fill out the Sku instance from the form
<abbr title=" 679             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 679             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
 680             Sku adminInstance = (Sku) Class.forName(entity.getType()[0]).newInstance();
<abbr title=" 681             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 681             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getNaðŸ”µ</abbr>
 682             filterOutProductMetadata(adminProperties);
<abbr title=" 683             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);"> 683             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, ðŸ”µ</abbr>
 684 
 685             //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 686             Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
<abbr title=" 687                                                                              getProductOptionProperties(entity),"> 687                                                                              getProductOptionProperties(eðŸ”µ</abbr>
 688                                                                              null);
 689             if (errorEntity != null) {
 690                 entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 691                 return entity;
 692             }
 693 
 694             //persist the newly-created Sku
 695             adminInstance = dynamicEntityDao.persist(adminInstance);
 696 
 697             //associate the product option values
 698             associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 699 
 700             //After associating the product option values, save off the Sku
 701             adminInstance = dynamicEntityDao.merge(adminInstance);
 702 
 703             //Fill out the DTO and add in the product option value properties to it
 704             Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 705             for (Property property : getProductOptionProperties(entity)) {
 706                 result.addProperty(property);
 707             }
 708             return result;
 709         } catch (Exception e) {
 710             throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + Sku.class.getName(), e);
 711         }
 712     }
 713 
 714     @Override
<abbr title=" 715     public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 715     public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordðŸ”µ</abbr>
 716         Entity entity = persistencePackage.getEntity();
 717         try {
 718             //Fill out the Sku instance from the form
<abbr title=" 719             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 719             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title=" 720             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 720             Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getNaðŸ”µ</abbr>
 721             filterOutProductMetadata(adminProperties);
 722             Object primaryKey = helper.getPrimaryKey(entity, adminProperties);
<abbr title=" 723             Sku adminInstance = (Sku) dynamicEntityDao.retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 723             Sku adminInstance = (Sku) dynamicEntityDao.retrieve(Class.forName(entity.getType()[0]), primaðŸ”µ</abbr>
<abbr title=" 724             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);"> 724             adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, ðŸ”µ</abbr>
 725 
 726             //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 727             Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
<abbr title=" 728                                                                             getProductOptionProperties(entity),"> 728                                                                             getProductOptionProperties(enðŸ”µ</abbr>
 729                                                                             adminInstance);
 730             if (errorEntity != null) {
 731                 entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 732                 return entity;
 733             }
 734 
 735             // Only modify product options if this ISN&#x27;T an update for inventory properties
 736             if (!persistencePackage.containsCriteria(INVENTORY_ONLY_CRITERIA)) {
 737                 associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 738             }
 739 
 740             adminInstance = dynamicEntityDao.merge(adminInstance);
 741 
 742             extensionManager.getProxy().skuUpdated(adminInstance);
 743 
 744             //Fill out the DTO and add in the product option value properties to it
 745             Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 746             for (Property property : getProductOptionProperties(entity)) {
 747                 result.addProperty(property);
 748             }
 749             return result;
 750         } catch (Exception e) {
 751             throw new ServiceException(&quot;Unable to perform update for entity: &quot; + Sku.class.getName(), e);
 752         }
 753     }
 754 
 755     @Override
 756     protected String[] getPolymorphicClasses(Class&lt;?&gt; clazz, EntityManager em, boolean useCache) {
 757         DynamicDaoHelperImpl helper = new DynamicDaoHelperImpl();
 758         Class&lt;?&gt;[] classes = helper.getAllPolymorphicEntitiesFromCeiling(clazz, true, useCache);
 759         String[] result = new String[classes.length];
 760         for (int i = 0; i &lt; classes.length; i++) {
 761             result[i] = classes[i].getName();
 762         }
 763         return result;
 764     }
 765 
 766     /**
<abbr title=" 767      * This initially removes all of the product option values that are currently related to the Sku and then re-associates"> 767      * This initially removes all of the product option values that are currently related to the Sku and ðŸ”µ</abbr>
 768      * the {@link ProductOptionValue}s
 769      * @param entity
 770      * @param adminInstance
 771      */
<abbr title=" 772     protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dynamicEntityDao) {"> 772     protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dðŸ”µ</abbr>
 773         //Get the list of product option value ids that were selected from the form
 774         List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 775         for (Property property : getProductOptionProperties(entity)) {
 776             Long propId = Long.parseLong(property.getValue());
 777             productOptionValueIds.add(propId);
 778             property.setIsDirty(true);
 779         }
 780 
 781         // Only process associations if product option value changes came in via the form
 782         if (CollectionUtils.isNotEmpty(productOptionValueIds)) {
 783             //remove the current list of product option values from the Sku
 784             if (adminInstance.getProductOptionValueXrefs().size() &gt; 0) {
<abbr title=" 785                 Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs().iterator();"> 785                 Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs()ðŸ”µ</abbr>
 786                 while (iterator.hasNext()) {
 787                     dynamicEntityDao.remove(iterator.next());
 788                 }
 789                 dynamicEntityDao.merge(adminInstance);
 790             }
 791 
 792             //Associate the product option values from the form with the Sku
 793             for (Long id : productOptionValueIds) {
<abbr title=" 794                 //Simply find the changed ProductOptionValues directly - seems to work better with sandboxing code"> 794                 //Simply find the changed ProductOptionValues directly - seems to work better with sandboðŸ”µ</abbr>
<abbr title=" 795                 ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpl.class, id);"> 795                 ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpðŸ”µ</abbr>
 796                 SkuProductOptionValueXref xref = new SkuProductOptionValueXrefImpl(adminInstance, pov);
 797                 xref = dynamicEntityDao.merge(xref);
 798                 adminInstance.getProductOptionValueXrefs().add(xref);
 799             }
 800         }
 801     }
 802 
 803     protected List&lt;Property&gt; getProductOptionProperties(Entity entity) {
 804         List&lt;Property&gt; productOptionProperties = new ArrayList&lt;&gt;();
 805         for (Property property : entity.getProperties()) {
 806             if (property.getName().startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 807                 productOptionProperties.add(property);
 808             }
 809         }
 810         return productOptionProperties;
 811     }
 812 
 813     /**
<abbr title=" 814      * Ensures that the given list of {@link ProductOptionValue} IDs is unique for the given {@link Product}."> 814      * Ensures that the given list of {@link ProductOptionValue} IDs is unique for the given {@link ProduðŸ”µ</abbr>
 815      *
<abbr title=" 816      * If sku browsing is enabled, then it is assumed that a single combination of {@link ProductOptionValue} IDs"> 816      * If sku browsing is enabled, then it is assumed that a single combination of {@link ProductOptionVaðŸ”µ</abbr>
<abbr title=" 817      * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProductOptionValue} IDs."> 817      * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProducðŸ”µ</abbr>
 818      * In this case, the following validation is skipped.
 819      *
 820      * @param product
 821      * @param productOptionProperties
<abbr title=" 822      * @param currentSku - for update operations, this is the current Sku that is being updated; should be excluded from"> 822      * @param currentSku - for update operations, this is the current Sku that is being updated; should bðŸ”µ</abbr>
 823      * attempting validation
 824      * @return &lt;b&gt;null&lt;/b&gt; if successfully validation, the error entity otherwise
 825      */
<abbr title=" 826     protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOptionProperties, Sku currentSku) {"> 826     protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOðŸ”µ</abbr>
 827         // do not attempt POV validation if no PO properties were passed in
 828         if (CollectionUtils.isNotEmpty(productOptionProperties)) {
 829             List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 830             for (Property property : productOptionProperties) {
 831                 productOptionValueIds.add(Long.parseLong(property.getValue()));
 832             }
 833             boolean validated = true;
 834             for (Sku sku : product.getAdditionalSkus()) {
 835                 if ((currentSku == null) || (!sku.getId().equals(currentSku.getId()))) {
 836                     List&lt;Long&gt; testList = new ArrayList&lt;&gt;();
 837                     for (ProductOptionValue optionValue : sku.getProductOptionValues()) {
 838                         testList.add(optionValue.getId());
 839                     }
<abbr title=" 840                     if ((CollectionUtils.isNotEmpty(testList) &amp;&amp; productOptionValueIds.containsAll(testList)) &amp;&amp; (productOptionValueIds.size() == testList.size())) {"> 840                     if ((CollectionUtils.isNotEmpty(testList) &amp;&amp; productOptionValueIds.containsAll(testLiðŸ”µ</abbr>
 841                         validated = false;
 842                         break;
 843                     }
 844                 }
 845             }
 846             if (!validated) {
 847                 Entity errorEntity = new Entity();
 848                 for (Property productOptionProperty : productOptionProperties) {
 849                     errorEntity.addValidationError(productOptionProperty.getName(), &quot;uniqueSkuError&quot;);
 850                 }
 851                 return errorEntity;
 852             }
 853         }
 854         return null;
 855     }
 856 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Admin Module
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  
  19  package org.broadleafcommerce.admin.server.service.handler;
  20  
  21  import static com.google.common.base.CharMatcher.DIGIT;
  22  
  23  import org.apache.commons.collections.CollectionUtils;
  24  import org.apache.commons.collections.Transformer;
  25  import org.apache.commons.lang.BooleanUtils;
  26  import org.apache.commons.lang3.ArrayUtils;
  27  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.commons.lang3.math.NumberUtils;</span>
  29  import org.apache.commons.logging.Log;
  30  import org.apache.commons.logging.LogFactory;
  31  import org.broadleafcommerce.admin.server.service.SkuMetadataCacheService;
  32  import org.broadleafcommerce.common.exception.ServiceException;
  33  import org.broadleafcommerce.common.presentation.client.LookupType;
  34  import org.broadleafcommerce.common.presentation.client.OperationType;
  35  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  36  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  37  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  38  import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  39  import org.broadleafcommerce.common.util.BLCCollectionUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import org.broadleafcommerce.common.util.StringUtil;</span>
  41  import org.broadleafcommerce.common.util.TypedTransformer;
  42  import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  43  import org.broadleafcommerce.core.catalog.domain.Product;
  44  import org.broadleafcommerce.core.catalog.domain.ProductBundle;
  45  import org.broadleafcommerce.core.catalog.domain.ProductImpl;
  46  import org.broadleafcommerce.core.catalog.domain.ProductOption;
  47  import org.broadleafcommerce.core.catalog.domain.ProductOptionImpl;
  48  import org.broadleafcommerce.core.catalog.domain.ProductOptionValue;
  49  import org.broadleafcommerce.core.catalog.domain.ProductOptionValueImpl;
  50  import org.broadleafcommerce.core.catalog.domain.Sku;
  51  import org.broadleafcommerce.core.catalog.domain.SkuImpl;
  52  import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXref;
  53  import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXrefImpl;
  54  import org.broadleafcommerce.core.catalog.service.CatalogService;
  55  import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  56  import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  57  import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;
  58  import org.broadleafcommerce.openadmin.dto.DynamicResultSet;
  59  import org.broadleafcommerce.openadmin.dto.Entity;
  60  import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  61  import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;
  62  import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  63  import org.broadleafcommerce.openadmin.dto.PersistencePackage;
  64  import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  65  import org.broadleafcommerce.openadmin.dto.Property;
  66  import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  67  import org.broadleafcommerce.openadmin.server.dao.DynamicEntityDao;
  68  import org.broadleafcommerce.openadmin.server.service.handler.CustomPersistenceHandlerAdapter;
  69  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  70  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManagerFactory;
  71  import org.broadleafcommerce.openadmin.server.service.persistence.module.InspectHelper;
  72  import org.broadleafcommerce.openadmin.server.service.persistence.module.PersistenceModule;
  73  import org.broadleafcommerce.openadmin.server.service.persistence.module.RecordHelper;
  74  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;
  75  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;
  76  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;
  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;
  78  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;
  79  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -import org.hibernate.ejb.HibernateEntityManager;</span>
  81  import org.springframework.beans.factory.annotation.Value;
  82  import org.springframework.stereotype.Component;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +</span>
  84  import java.io.Serializable;
  85  import java.util.ArrayList;
  86  import java.util.Arrays;
  87  import java.util.Collection;
  88  import java.util.Collections;
  89  import java.util.HashMap;
  90  import java.util.Iterator;
  91  import java.util.List;
  92  import java.util.Map;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +</span>
  94  import javax.annotation.Resource;
  95  import javax.persistence.EntityManager;
  96  import javax.persistence.PersistenceContext;
  97  import javax.persistence.TypedQuery;
  98  import javax.persistence.criteria.CriteriaBuilder;
  99  import javax.persistence.criteria.From;
 100  import javax.persistence.criteria.Path;
 101  import javax.persistence.criteria.Predicate;
 102  
 103  /**
 104   * @author Phillip Verheyden
 105   *
 106   */
 107  @Component(&quot;blSkuCustomPersistenceHandler&quot;)
 108  public class SkuCustomPersistenceHandler extends CustomPersistenceHandlerAdapter {
 109  
 110      private static final Log LOG = LogFactory.getLog(SkuCustomPersistenceHandler.class);
 111  
 112      public static String PRODUCT_OPTION_FIELD_PREFIX = &quot;productOption&quot;;
 113      public static String INVENTORY_ONLY_CRITERIA = &quot;onlyInventoryProperties&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 115 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 116 -    @Value(&quot;${solr.index.use.sku}&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -    protected boolean useSku;</span>
 118  
 119      @Value(&quot;${use.to.one.lookup.sku.product.option.value:false}&quot;)
 120      protected boolean useToOneLookupSkuProductOptionValue = false;
 121  
 122      @Resource(name =&quot;blSkuMetadataCacheService&quot;)
 123      protected SkuMetadataCacheService skuMetadataCacheService;
 124  
 125      @Resource(name=&quot;blAdornedTargetListPersistenceModule&quot;)
 126      protected PersistenceModule adornedPersistenceModule;
 127  
 128      @Resource(name = &quot;blSkuCustomPersistenceHandlerExtensionManager&quot;)
 129      protected SkuCustomPersistenceHandlerExtensionManager extensionManager;
 130  
 131      /**
<abbr title=" 132       * This represents the field that all of the product option values will be stored in. This would be used in the case"> 132       * This represents the field that all of the product option values will be stored in. This would be used in thðŸ”µ</abbr>
<abbr title=" 133       * where there are a bunch of product options and displaying each option as a grid header would have everything"> 133       * where there are a bunch of product options and displaying each option as a grid header would have everythinðŸ”µ</abbr>
 134       * squashed together. Filtering on this field is currently unsupported.
 135       */
 136      public static String CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME = &quot;consolidatedProductOptions&quot;;
 137      public static String CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER = &quot;; &quot;;
 138  
 139      @Resource(name=&quot;blCatalogService&quot;)
 140      protected CatalogService catalogService;
 141  
 142      @PersistenceContext(unitName = &quot;blPU&quot;)
 143      protected EntityManager em;
 144  
 145      @Resource(name = &quot;blCriteriaTranslator&quot;)
 146      protected CriteriaTranslator criteriaTranslator;
 147  
 148      @Resource(name = &quot;blSandBoxHelper&quot;)
 149      protected SandBoxHelper sandBoxHelper;
 150  
 151      @Override
 152      public Boolean canHandleInspect(PersistencePackage persistencePackage) {
 153          return canHandle(persistencePackage, persistencePackage.getPersistencePerspective().getOperationTypes()
 154                  .getInspectType());
 155      }
 156  
 157      @Override
 158      public Boolean canHandleFetch(PersistencePackage persistencePackage) {
<abbr title=" 159          OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFetchType();"> 159          OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFetchType(ðŸ”µ</abbr>
 160          return canHandle(persistencePackage, fetchType);
 161      }
 162  
 163      @Override
 164      public Boolean canHandleAdd(PersistencePackage persistencePackage) {
 165          OperationType addType = persistencePackage.getPersistencePerspective().getOperationTypes().getAddType();
 166          return canHandle(persistencePackage, addType);
 167      }
 168  
 169      @Override
 170      public Boolean canHandleUpdate(PersistencePackage persistencePackage) {
<abbr title=" 171          OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getUpdateType();"> 171          OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getUpdateTypðŸ”µ</abbr>
 172          return canHandle(persistencePackage, updateType);
 173      }
 174  
 175      /**
 176       * Since this is the default for all Skus, it&#x27;s possible that we are providing custom criteria for this
 177       * Sku lookup. In that case, we probably want to delegate to a child class, so only use this particular
<abbr title=" 178       * persistence handler if there is no custom criteria being used and the ceiling entity is an instance of Sku. The"> 178       * persistence handler if there is no custom criteria being used and the ceiling entity is an instance of Sku.ðŸ”µ</abbr>
<abbr title=" 179       * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for the ceiling entity"> 179       * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for the ceilingðŸ”µ</abbr>
<abbr title=" 180       * class name. That should be handled by the map structure module though, so only handle things in the Sku custom"> 180       * class name. That should be handled by the map structure module though, so only handle things in the Sku cusðŸ”µ</abbr>
 181       * persistence handler for OperationType.BASIC
 182       *
 183       */
 184      protected Boolean canHandle(PersistencePackage persistencePackage, OperationType operationType) {
<abbr title=" 185          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 185          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 186          try {
 187              Class testClass = Class.forName(ceilingEntityFullyQualifiedClassname);
 188              return Sku.class.isAssignableFrom(testClass) &amp;&amp;
 189                      //ArrayUtils.isEmpty(persistencePackage.getCustomCriteria()) &amp;&amp;
 190                      OperationType.BASIC.equals(operationType) &amp;&amp;
<abbr title=" 191                      (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.ADORNEDTARGETLIST) == null);"> 191                      (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
 192          } catch (ClassNotFoundException e) {
 193              return false;
 194          }
 195      }
 196  
 197      /**
 198       * Build out the extra fields for the product options
 199       */
 200      @Override
<abbr title=" 201      public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, InspectHelper helper) throws ServiceException {"> 201      public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, InspðŸ”µ</abbr>
 202          try {
 203              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 204              Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties = new HashMap&lt;&gt;();
 205  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -            String productIdStr = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 207 -            if (persistencePackage.getCustomCriteria() != null &amp;&amp; persistencePackage.getCustomCriteria().length &gt; 0) {"> 207 -            if (persistencePackage.getCustomCriteria() != null &amp;&amp; persistencePackage.getCustomCriteria().length &gt; ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -                productIdStr = persistencePackage.getCustomCriteria()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +            String productIdStr = getOwningProductId(persistencePackage.getSectionCrumbs());</span>
 211              String cacheKey = skuMetadataCacheService.buildCacheKey(productIdStr);
 212  
 213              Map&lt;String, FieldMetadata&gt; properties = null;
 214              boolean useCache = skuMetadataCacheService.useCache();
 215              if (useCache) {
 216                  properties = skuMetadataCacheService.getFromCache(cacheKey);
 217              }
 218              if (properties == null) {
 219                  //Grab the default properties for the Sku
 220                  properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspective);
 221  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 222 -                boolean isFirstCriteriaNAN = persistencePackage.getCustomCriteria() == null || persistencePackage.getCustomCriteria().length == 0;"> 222 -                boolean isFirstCriteriaNAN = persistencePackage.getCustomCriteria() == null || persistencePackage.ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +                boolean isFirstCriteriaNAN = productIdStr == null;</span>
 224                  if (!isFirstCriteriaNAN &amp;&amp; useToOneLookupSkuProductOptionValue) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 225 -                    isFirstCriteriaNAN = !DIGIT.matchesAllOf(persistencePackage.getCustomCriteria()[0]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +                    isFirstCriteriaNAN = !NumberUtils.isParsable(productIdStr);</span>
 227                  }
 228                  if (isFirstCriteriaNAN) {
 229                      //look up all the ProductOptions and then create new fields for each of them
 230                      List&lt;ProductOption&gt; options = catalogService.readAllProductOptions();
 231                      int order = 0;
 232                      for (ProductOption option : options) {
 233                          //add this to the built Sku properties
 234                          FieldMetadata md = createIndividualOptionField(option, order);
 235                          if (md != null) {
 236                              properties.put(&quot;productOption&quot; + option.getId(), md);
 237                          }
 238                      }
 239                  } else {
 240                      // If we have a product to filter the list of available product options, then use it
 241                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -                        Long productId = Long.parseLong(persistencePackage.getCustomCriteria()[0]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +                        Long productId = Long.parseLong(productIdStr);</span>
 244                          Product product = catalogService.findProductById(productId);
 245                          for (ProductOption option : product.getProductOptions()) {
 246                              FieldMetadata md = createIndividualOptionField(option, 0);
 247                              if (md != null) {
 248                                  properties.put(&quot;productOption&quot; + option.getId(), md);
 249                              }
 250                          }
 251                      } catch (NumberFormatException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -                        // the criteria wasn&#x27;t a product id, just don&#x27;t do anything</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +                        // there wasn&#x27;t a valid product id, just don&#x27;t do anything</span>
 254                      }
 255                  }
 256  
<abbr title=" 257                  //also build the consolidated field; if using the SkuBasicClientEntityModule then this field will be"> 257                  //also build the consolidated field; if using the SkuBasicClientEntityModule then this field will ðŸ”µ</abbr>
 258                  //permanently hidden
<abbr title=" 259                  properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuImpl.class));"> 259                  properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuImpl.clasðŸ”µ</abbr>
 260  
 261                  if (useCache) {
 262                      skuMetadataCacheService.addToCache(cacheKey, properties);
 263                  }
 264              }
 265  
 266              allMergedProperties.put(MergedPropertyType.PRIMARY, properties);
 267  
 268              //allow the adorned list to contribute properties as well in the case of Sku bundle items
 269              adornedPersistenceModule.setPersistenceManager((PersistenceManager)helper);
 270              adornedPersistenceModule.updateMergedProperties(persistencePackage, allMergedProperties);
 271  
 272              Class&lt;?&gt;[] entityClasses = dynamicEntityDao.getAllPolymorphicEntitiesFromCeiling(SkuImpl.class);
 273  
<abbr title=" 274              for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.entrySet()) {"> 274              for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.entrySet())ðŸ”µ</abbr>
 275                  filterOutProductMetadata(entry.getValue());
 276              }
 277  
<abbr title=" 278              ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, allMergedProperties);"> 278              ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, allMergedPðŸ”µ</abbr>
 279              DynamicResultSet results = new DynamicResultSet(mergedMetadata, null, null);
 280  
 281              return results;
 282          } catch (Exception e) {
 283              ServiceException ex = new ServiceException(&quot;Unable to retrieve inspection results for &quot; +
 284                      persistencePackage.getCeilingEntityFullyQualifiedClassname(), e);
 285              throw ex;
 286          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +    protected String getOwningProductId(SectionCrumb[] sectionCrumbs) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +        if (ArrayUtils.isNotEmpty(sectionCrumbs) &amp;&amp; ProductImpl.class.getCanonicalName()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +                .equals(sectionCrumbs[0].getSectionIdentifier())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +            return sectionCrumbs[0].getSectionId();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +        return null;</span>
 295      }
 296  
 297      protected void filterOutProductMetadata(Map&lt;String, FieldMetadata&gt; map) {
<abbr title=" 298          //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdminPresentation,"> 298          //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdminPresentðŸ”µ</abbr>
 299          //but there&#x27;s a bug preventing this behavior from completely working correctly
 300          List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 301          for (Map.Entry&lt;String, FieldMetadata&gt; entry : map.entrySet()) {
 302              if (entry.getKey().contains(&quot;defaultProduct.&quot;) || entry.getKey().contains(&quot;product.&quot;)) {
 303                  removeKeys.add(entry.getKey());
 304              }
 305          }
 306          for (String removeKey : removeKeys) {
 307              map.remove(removeKey);
 308          }
 309      }
 310  
 311      /**
<abbr title=" 312       * Creates the metadata necessary for displaying all of the product option values in a single field. The display of this"> 312       * Creates the metadata necessary for displaying all of the product option values in a single field. The displðŸ”µ</abbr>
<abbr title=" 313       * field is a single string with every product option value appended to it separated by a semicolon. This method should"> 313       * field is a single string with every product option value appended to it separated by a semicolon. This methðŸ”µ</abbr>
<abbr title=" 314       * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be populated on fetch."> 314       * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be populated ðŸ”µ</abbr>
 315       *
<abbr title=" 316       * The metadata that is returned will also be set to prominent by default so that it will be ready to display on whatever"> 316       * The metadata that is returned will also be set to prominent by default so that it will be ready to display ðŸ”µ</abbr>
<abbr title=" 317       * grid is being inspected. If you do not want this behavior you will need to override this functionality in the metadata"> 317       * grid is being inspected. If you do not want this behavior you will need to override this functionality in tðŸ”µ</abbr>
 318       * that is returned.
 319       *
<abbr title=" 320       * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, but if you want to"> 320       * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, but if youðŸ”µ</abbr>
 321       * display this field with a different entity then this should be that entity
 322       * @return
 323       */
 324      public FieldMetadata createConsolidatedOptionField(Class&lt;?&gt; inheritedFromType) {
 325          BasicFieldMetadata metadata = new BasicFieldMetadata();
 326          metadata.setFieldType(SupportedFieldType.STRING);
 327          metadata.setMutable(false);
 328          metadata.setInheritedFromType(inheritedFromType.getName());
 329  
<abbr title=" 330          metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 330          metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()))ðŸ”µ</abbr>
 331          metadata.setForeignKeyCollection(false);
 332          metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 333  
 334          metadata.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 335          metadata.setFriendlyName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 336          metadata.setGroup(&quot;&quot;);
 337          metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 338          metadata.setProminent(true);
 339          metadata.setVisibility(VisibilityEnum.FORM_HIDDEN);
 340          metadata.setBroadleafEnumeration(&quot;&quot;);
 341          metadata.setReadOnly(true);
 342          metadata.setRequiredOverride(false);
 343          metadata.setGridOrder(Integer.MAX_VALUE);
 344  
 345          return metadata;
 346      }
 347  
 348      /**
<abbr title=" 349       * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed in. This should be"> 349       * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed in. This sðŸ”µ</abbr>
 350       * invoked on a fetch and the returned property should be added to the fetched {@link Entity} dto.
 351       *
 352       * @param values
 353       * @return
 354       * @see {@link #createConsolidatedOptionField(Class)};
 355       */
 356      public Property getConsolidatedOptionProperty(Collection&lt;ProductOptionValue&gt; values) {
 357          Property optionValueProperty = new Property();
 358          optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 359  
 360          //order the values by the display order of their correspond product option
 361          //        Collections.sort(values, new Comparator&lt;ProductOptionValue&gt;() {
 362          //
 363          //            @Override
 364          //            public int compare(ProductOptionValue value1, ProductOptionValue value2) {
 365          //                return new CompareToBuilder().append(value1.getProductOption().getDisplayOrder(),
 366          //                        value2.getProductOption().getDisplayOrder()).toComparison();
 367          //            }
 368          //        });
 369  
 370          ArrayList&lt;String&gt; stringValues = new ArrayList&lt;&gt;();
 371          CollectionUtils.collect(values, new Transformer() {
 372  
 373              @Override
 374              public Object transform(Object input) {
 375                  return ((ProductOptionValue) input).getAttributeValue();
 376              }
 377          }, stringValues);
 378  
 379          optionValueProperty.setValue(StringUtils.join(stringValues, CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER));
 380          return optionValueProperty;
 381      }
 382  
 383      /**
 384       * @return a blank {@link Property} corresponding to the CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME
 385       */
 386      public Property getBlankConsolidatedOptionProperty() {
 387          Property optionValueProperty = new Property();
 388          optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 389          optionValueProperty.setValue(&quot;&quot;);
 390          return optionValueProperty;
 391      }
 392  
 393      /**
<abbr title=" 394       * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum field whose values will"> 394       * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum field whose ðŸ”µ</abbr>
<abbr title=" 395       * be the option values for this option.  This is useful when you would like to display each product option in as its"> 395       * be the option values for this option.  This is useful when you would like to display each product option inðŸ”µ</abbr>
 396       * own field in a grid so that you can further filter by product option values.&lt;/p&gt;
 397       * &lt;p&gt;In order for these fields to be utilized property on the fetch, in the GWT frontend you must use the
 398       * for your datasource.&lt;/p&gt;
 399       *
 400       * @param option
 401       * @param order
 402       * @return
 403       */
 404      public FieldMetadata createIndividualOptionField(ProductOption option, int order) {
 405          if (useToOneLookupSkuProductOptionValue) {
 406              return createToOneIndividualOptionField(option, order);
 407          } else {
 408              return createExplicitEnumerationIndividualOptionField(option, order);
 409          }
 410      }
 411  
 412      protected FieldMetadata createExplicitEnumerationIndividualOptionField(ProductOption option, int order) {
 413          BasicFieldMetadata metadata = new BasicFieldMetadata();
 414          List&lt;ProductOptionValue&gt; allowedValues = option.getAllowedValues();
 415          if (CollectionUtils.isNotEmpty(allowedValues)) {
 416              metadata.setFieldType(SupportedFieldType.EXPLICIT_ENUMERATION);
 417              metadata.setMutable(true);
 418              metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 419              metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 419              metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCacheðŸ”µ</abbr>
 420              metadata.setForeignKeyCollection(false);
 421              metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 422  
 423              //Set up the enumeration based on the product option values
 424              String[][] optionValues = new String[allowedValues.size()][2];
 425              for (int i = 0; i &lt; allowedValues.size(); i++) {
 426                  ProductOptionValue value = option.getAllowedValues().get(i);
 427                  optionValues[i][0] = value.getId().toString();
 428                  optionValues[i][1] = value.getAttributeValue();
 429              }
 430              metadata.setEnumerationValues(optionValues);
 431  
 432              metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 433              metadata.setFriendlyName(option.getLabel());
 434              metadata.setGroup(&quot;productOption_group&quot;);
 435              metadata.setGroupOrder(-1);
 436              metadata.setOrder(order);
 437              metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 438              metadata.setProminent(false);
 439              metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 440              metadata.setBroadleafEnumeration(&quot;&quot;);
 441              metadata.setReadOnly(false);
 442              metadata.setRequiredOverride(BooleanUtils.isFalse(option.getRequired()));
 443  
 444              return metadata;
 445          }
 446          return null;
 447      }
 448  
 449      /**
<abbr title=" 450       * Using a ToOne lookup performs much better for large product option value lists, speeds up initial page load,"> 450       * Using a ToOne lookup performs much better for large product option value lists, speeds up initial page loadðŸ”µ</abbr>
<abbr title=" 451       * and is generally more accurate in relation to option value updates and how they impact available selections and cache."> 451       * and is generally more accurate in relation to option value updates and how they impact available selectionsðŸ”µ</abbr>
 452       *
 453       * @param option
 454       * @param order
 455       * @return
 456       */
 457      protected FieldMetadata createToOneIndividualOptionField(ProductOption option, int order) {
 458          PersistenceManager persistenceManager = PersistenceManagerFactory.getPersistenceManager();
 459          FilterMapping filterMapping = new FilterMapping().withDirectFilterValues(
<abbr title=" 460                  sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(new Restriction()"> 460                  sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(new RestrictðŸ”µ</abbr>
 461              .withPredicateProvider(new PredicateProvider() {
 462                  @Override
<abbr title=" 463                  public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder, From root,"> 463                  public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder, From rðŸ”µ</abbr>
<abbr title=" 464                                                  String ceilingEntity, String fullPropertyName, Path explicitPath, List directValues) {"> 464                                                  String ceilingEntity, String fullPropertyName, Path explicitPath, ðŸ”µ</abbr>
 465                      return root.get(&quot;productOption&quot;).get(&quot;id&quot;).in(directValues);
 466              }
 467          }));
 468          List&lt;FilterMapping&gt; mappings = new ArrayList&lt;&gt;();
 469          mappings.add(filterMapping);
<abbr title=" 470          TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),"> 470          TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.getDynamicðŸ”µ</abbr>
 471                  ProductOptionValueImpl.class.getName(), mappings);
 472          Long count = (Long) countQuery.getSingleResult();
 473          BasicFieldMetadata metadata = null;
 474          if (count &gt; 0) {
 475              metadata = new BasicFieldMetadata();
 476              metadata.setFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 477              metadata.setSecondaryType(SupportedFieldType.INTEGER);
 478              metadata.setForeignKeyProperty(&quot;id&quot;);
 479              metadata.setForeignKeyClass(ProductOptionValueImpl.class.getName());
 480              metadata.setForeignKeyDisplayValueProperty(&quot;attributeValue&quot;);
 481              metadata.setLookupDisplayProperty(&quot;attributeValue&quot;);
 482              metadata.setForeignKeyCollection(false);
 483              metadata.setCustomCriteria(new String[]{&quot;option=&quot; + String.valueOf(option.getId())});
 484              metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 485              metadata.setFriendlyName(option.getLabel());
 486              metadata.setGroup(&quot;productOption_group&quot;);
 487              metadata.setGroupOrder(-1);
 488              metadata.setOrder(order);
 489              metadata.setExplicitFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 490              metadata.setProminent(false);
 491              metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 492              metadata.setReadOnly(false);
<abbr title=" 493              //these may not be actually required, but the CPH has this as a requirement for parsing the data, so we&#x27;ll stick with it here"> 493              //these may not be actually required, but the CPH has this as a requirement for parsing the data, so wðŸ”µ</abbr>
 494              metadata.setRequiredOverride(true);
 495              metadata.setLookupType(LookupType.STANDARD);
 496              metadata.setMutable(true);
 497              metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 498              metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 498              metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCacheðŸ”µ</abbr>
 499              metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 500              metadata.setTargetClass(SkuImpl.class.getName());
 501              metadata.setFieldName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 502          }
 503          return metadata;
 504      }
 505  
 506      @SuppressWarnings(&quot;unchecked&quot;)
 507      @Override
<abbr title=" 508      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 508      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynamicEntityðŸ”µ</abbr>
<abbr title=" 509          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 509          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 510          try {
 511              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 512              //get the default properties from Sku and its subclasses
<abbr title=" 513              Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 513              Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getName(), persiðŸ”µ</abbr>
 514  
 515              //Pull back the Skus based on the criteria from the client
<abbr title=" 516              List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, originalProps);"> 516              List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceilingEntiðŸ”µ</abbr>
 517  
 518              //allow subclasses to provide additional criteria before executing the query
 519              applyProductOptionValueCriteria(filterMappings, cto, persistencePackage, null);
 520              applySkuBundleItemValueCriteria(filterMappings, cto, persistencePackage);
 521              applyAdditionalFetchCriteria(filterMappings, cto, persistencePackage);
 522  
<abbr title=" 523              List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings, cto.getFirstResult(), cto.getMaxResults());"> 523              List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFullyQualiðŸ”µ</abbr>
 524              //Convert Skus into the client-side Entity representation
 525              Entity[] payload = helper.getRecords(originalProps, records);
 526  
<abbr title=" 527              int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings);"> 527              int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 528  
 529              //Now fill out the relevant properties for the product options for the Skus that were returned
 530              updateProductOptionFieldsForFetch(records, payload);
 531  
 532              return new DynamicResultSet(payload, totalRecords);
 533          } catch (Exception e) {
<abbr title=" 534              throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiedClassname, e);"> 534              throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiedClassnaðŸ”µ</abbr>
 535          }
 536      }
 537  
 538      /**
<abbr title=" 539       * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a ListGrid context."> 539       * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a ListGrid cðŸ”µ</abbr>
 540       *
 541       * @param records
 542       * @param payload
 543       * @return
 544       */
 545      public void updateProductOptionFieldsForFetch(List&lt;Serializable&gt; records, Entity[] payload) {
 546          for (int i = 0; i &lt; records.size(); i++) {
 547              Sku sku = (Sku) records.get(i);
 548              Entity entity = payload[i];
 549  
<abbr title=" 550              List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionValueXrefs(), new TypedTransformer&lt;ProductOptionValue&gt;() {"> 550              List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionValueXrefs(ðŸ”µ</abbr>
 551                  @Override
 552                  public ProductOptionValue transform(Object input) {
 553                      return ((SkuProductOptionValueXref) input).getProductOptionValue();
 554                  }
 555              });
 556  
 557              for (ProductOptionValue value : optionValues) {
 558                  Property optionProperty = new Property();
 559                  optionProperty.setName(PRODUCT_OPTION_FIELD_PREFIX + value.getProductOption().getId());
 560                  optionProperty.setValue(value.getId().toString());
 561                  optionProperty.setDisplayValue(value.getAttributeValue());
 562                  entity.addProperty(optionProperty);
 563              }
 564  
 565              if (CollectionUtils.isNotEmpty(optionValues)) {
 566                  entity.addProperty(getConsolidatedOptionProperty(optionValues));
 567              } else {
 568                  entity.addProperty(getBlankConsolidatedOptionProperty());
 569              }
 570          }
 571      }
 572  
 573      /**
 574       * Add filter restriction such that a ProductBundle cannot add its own default sku as a Sku Bundle Item
 575       */
<abbr title=" 576      private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 576      private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PðŸ”µ</abbr>
 577          SectionCrumb[] sectionCrumbs = persistencePackage.getSectionCrumbs();
 578          if (isSkuBundleItemLookup(persistencePackage, sectionCrumbs)) {
 579              final Long defaultSkuId = getOwningProductBundlesDefaultSkuId(sectionCrumbs[0]);
 580  
 581              filterMappings.add(new FilterMapping()
 582                      .withDirectFilterValues(Collections.singletonList(defaultSkuId))
 583                      .withRestriction(new Restriction()
 584                                      .withPredicateProvider(new PredicateProvider() {
 585                                          @Override
 586                                          public Predicate buildPredicate(CriteriaBuilder builder,
 587                                                  FieldPathBuilder fieldPathBuilder,
 588                                                  From root, String ceilingEntity,
 589                                                  String fullPropertyName, Path explicitPath,
 590                                                  List directValues) {
 591                                              return builder.notEqual(root, directValues.get(0));
 592                                          }
 593                                      })
 594                      ));
 595          }
 596      }
 597  
 598      private boolean isSkuBundleItemLookup(PersistencePackage pkg, SectionCrumb[] sectionCrumbs) {
 599          boolean owningClassMatch = false;
 600          boolean requestingFieldMatch = false;
 601  
 602          if (pkg.getCustomCriteria() == null || ArrayUtils.isEmpty(sectionCrumbs)) {
 603              return false;
 604          }
 605  
 606          for (String criteria : pkg.getCustomCriteria()) {
 607              if (&quot;owningClass=org.broadleafcommerce.core.catalog.domain.SkuBundleItemImpl&quot;.equals(criteria)) {
 608                  owningClassMatch = true;
 609              } else if (&quot;requestingField=sku&quot;.equals(criteria)) {
 610                  requestingFieldMatch = true;
 611              }
 612          }
 613  
<abbr title=" 614          boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectionIdentifier());"> 614          boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectionIdentifðŸ”µ</abbr>
 615  
 616          return owningClassMatch &amp;&amp; requestingFieldMatch &amp;&amp; sectionCrumbMatch;
 617      }
 618  
 619      private Long getOwningProductBundlesDefaultSkuId(SectionCrumb sectionCrumb) {
 620          if (ProductImpl.class.getCanonicalName().equals(sectionCrumb.getSectionIdentifier())
 621                  &amp;&amp; sectionCrumb.getSectionId() != null) {
<abbr title=" 622              ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(sectionCrumb.getSectionId()));"> 622              ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(sectionCrumbðŸ”µ</abbr>
 623              return productBundle.getDefaultSku().getId();
 624          }
 625          return null;
 626      }
 627  
<abbr title=" 628      public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage, String skuPropertyPrefix) {"> 628      public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PeðŸ”µ</abbr>
 629  
 630          //if the front
 631          final List&lt;Long&gt; productOptionValueFilterIDs = new ArrayList&lt;&gt;();
 632          for (String filterProperty : cto.getCriteriaMap().keySet()) {
 633              if (filterProperty.startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 634                  FilterAndSortCriteria criteria = cto.get(filterProperty);
 635                  productOptionValueFilterIDs.add(Long.parseLong(criteria.getFilterValues().get(0)));
 636              }
 637          }
 638  
 639          //also determine if there is a consolidated POV query
 640          final List&lt;String&gt; productOptionValueFilterValues = new ArrayList&lt;&gt;();
 641          FilterAndSortCriteria consolidatedCriteria = cto.get(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 642          if (!consolidatedCriteria.getFilterValues().isEmpty()) {
 643              //the criteria in this case would be a semi-colon delimeter value list
<abbr title=" 644              productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.getFilterValues().get(0), CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER)));"> 644              productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.getFilterVaðŸ”µ</abbr>
 645          }
 646  
 647          if (productOptionValueFilterIDs.size() &gt; 0) {
 648              FilterMapping filterMapping = new FilterMapping()
<abbr title=" 649                  .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.id&quot;))"> 649                  .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuProðŸ”µ</abbr>
 650                  .withDirectFilterValues(productOptionValueFilterIDs)
 651                  .withRestriction(new Restriction()
 652                      .withPredicateProvider(new PredicateProvider() {
 653                          @Override
<abbr title=" 654                          public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 654                          public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilderðŸ”µ</abbr>
 655                                                          From root, String ceilingEntity,
<abbr title=" 656                                                          String fullPropertyName, Path explicitPath, List directValues) {"> 656                                                          String fullPropertyName, Path explicitPath, List directValðŸ”µ</abbr>
 657                              return explicitPath.as(Long.class).in(directValues);
 658                          }
 659                      })
 660                  );
 661              filterMappings.add(filterMapping);
 662          }
 663          if (productOptionValueFilterValues.size() &gt; 0) {
 664              FilterMapping filterMapping = new FilterMapping()
<abbr title=" 665                  .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.attributeValue&quot;))"> 665                  .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuProðŸ”µ</abbr>
 666                  .withDirectFilterValues(productOptionValueFilterValues)
 667                  .withRestriction(new Restriction()
 668                      .withPredicateProvider(new PredicateProvider() {
 669                          @Override
<abbr title=" 670                          public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 670                          public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilderðŸ”µ</abbr>
 671                                                          From root, String ceilingEntity,
<abbr title=" 672                                                          String fullPropertyName, Path explicitPath, List directValues) {"> 672                                                          String fullPropertyName, Path explicitPath, List directValðŸ”µ</abbr>
 673                              return explicitPath.as(String.class).in(directValues);
 674                          }
 675                      })
 676                  );
 677              filterMappings.add(filterMapping);
 678          }
 679      }
 680  
 681      /**
<abbr title=" 682       * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the queryCritiera. At the"> 682       * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the queryCritiðŸ”µ</abbr>
<abbr title=" 683       * point that this method has been called, criteria from the frontend has already been applied, thus allowing you to"> 683       * point that this method has been called, criteria from the frontend has already been applied, thus allowing ðŸ”µ</abbr>
 684       * override from there as well.&lt;/p&gt;
<abbr title=" 685       * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filter criteria"> 685       * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filter criterðŸ”µ</abbr>
 686       * can be applied for product option values&lt;/p&gt;
 687       *
 688       */
<abbr title=" 689      public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 689      public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersiðŸ”µ</abbr>
 690          //unimplemented
 691      }
 692  
 693      @Override
<abbr title=" 694      public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 694      public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helpeðŸ”µ</abbr>
 695          Entity entity = persistencePackage.getEntity();
 696          try {
 697              //Fill out the Sku instance from the form
 698              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 699              Sku adminInstance = (Sku) Class.forName(entity.getType()[0]).newInstance();
<abbr title=" 700              Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 700              Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), perðŸ”µ</abbr>
 701              filterOutProductMetadata(adminProperties);
 702              adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);
 703  
 704              //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 705              Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
 706                                                                               getProductOptionProperties(entity),
 707                                                                               null);
 708              if (errorEntity != null) {
 709                  entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 710                  return entity;
 711              }
 712  
 713              //persist the newly-created Sku
 714              adminInstance = dynamicEntityDao.persist(adminInstance);
 715  
 716              //associate the product option values
 717              associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 718  
 719              //After associating the product option values, save off the Sku
 720              adminInstance = dynamicEntityDao.merge(adminInstance);
 721  
 722              //Fill out the DTO and add in the product option value properties to it
 723              Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 724              for (Property property : getProductOptionProperties(entity)) {
 725                  result.addProperty(property);
 726              }
 727              return result;
 728          } catch (Exception e) {
 729              throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + Sku.class.getName(), e);
 730          }
 731      }
 732  
 733      @Override
<abbr title=" 734      public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 734      public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper heðŸ”µ</abbr>
 735          Entity entity = persistencePackage.getEntity();
 736          try {
 737              //Fill out the Sku instance from the form
 738              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 739              Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 739              Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), perðŸ”µ</abbr>
 740              filterOutProductMetadata(adminProperties);
 741              Object primaryKey = helper.getPrimaryKey(entity, adminProperties);
 742              Sku adminInstance = (Sku) dynamicEntityDao.retrieve(Class.forName(entity.getType()[0]), primaryKey);
 743              adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);
 744  
 745              //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 746              Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
 747                                                                              getProductOptionProperties(entity),
 748                                                                              adminInstance);
 749              if (errorEntity != null) {
 750                  entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 751                  return entity;
 752              }
 753  
 754              // Only modify product options if this ISN&#x27;T an update for inventory properties
 755              if (!persistencePackage.containsCriteria(INVENTORY_ONLY_CRITERIA)) {
 756                  associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 757              }
 758  
 759              adminInstance = dynamicEntityDao.merge(adminInstance);
 760  
 761              extensionManager.getProxy().skuUpdated(adminInstance);
 762  
 763              //Fill out the DTO and add in the product option value properties to it
 764              Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 765              for (Property property : getProductOptionProperties(entity)) {
 766                  result.addProperty(property);
 767              }
 768              return result;
 769          } catch (Exception e) {
 770              throw new ServiceException(&quot;Unable to perform update for entity: &quot; + Sku.class.getName(), e);
 771          }
 772      }
 773  
 774      @Override
 775      protected String[] getPolymorphicClasses(Class&lt;?&gt; clazz, EntityManager em, boolean useCache) {
 776          DynamicDaoHelperImpl helper = new DynamicDaoHelperImpl();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 777 -        Class&lt;?&gt;[] classes = helper.getAllPolymorphicEntitiesFromCeiling(clazz,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 778 -                helper.getSessionFactory((HibernateEntityManager) em), true, useCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 779 +        Class&lt;?&gt;[] classes = helper.getAllPolymorphicEntitiesFromCeiling(clazz, true, useCache);</span>
 780          String[] result = new String[classes.length];
 781          for (int i = 0; i &lt; classes.length; i++) {
 782              result[i] = classes[i].getName();
 783          }
 784          return result;
 785      }
 786  
 787      /**
<abbr title=" 788       * This initially removes all of the product option values that are currently related to the Sku and then re-associates"> 788       * This initially removes all of the product option values that are currently related to the Sku and then re-aðŸ”µ</abbr>
 789       * the {@link ProductOptionValue}s
 790       * @param entity
 791       * @param adminInstance
 792       */
<abbr title=" 793      protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dynamicEntityDao) {"> 793      protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dynamicEntðŸ”µ</abbr>
 794          //Get the list of product option value ids that were selected from the form
 795          List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 796          for (Property property : getProductOptionProperties(entity)) {
 797              Long propId = Long.parseLong(property.getValue());
 798              productOptionValueIds.add(propId);
 799              property.setIsDirty(true);
 800          }
 801  
 802          // Only process associations if product option value changes came in via the form
 803          if (CollectionUtils.isNotEmpty(productOptionValueIds)) {
 804              //remove the current list of product option values from the Sku
 805              if (adminInstance.getProductOptionValueXrefs().size() &gt; 0) {
<abbr title=" 806                  Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs().iterator();"> 806                  Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs().iteratorðŸ”µ</abbr>
 807                  while (iterator.hasNext()) {
 808                      dynamicEntityDao.remove(iterator.next());
 809                  }
 810                  dynamicEntityDao.merge(adminInstance);
 811              }
 812  
 813              //Associate the product option values from the form with the Sku
 814              for (Long id : productOptionValueIds) {
 815                  //Simply find the changed ProductOptionValues directly - seems to work better with sandboxing code
<abbr title=" 816                  ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpl.class, id);"> 816                  ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpl.class, ðŸ”µ</abbr>
 817                  SkuProductOptionValueXref xref = new SkuProductOptionValueXrefImpl(adminInstance, pov);
 818                  xref = dynamicEntityDao.merge(xref);
 819                  adminInstance.getProductOptionValueXrefs().add(xref);
 820              }
 821          }
 822      }
 823  
 824      protected List&lt;Property&gt; getProductOptionProperties(Entity entity) {
 825          List&lt;Property&gt; productOptionProperties = new ArrayList&lt;&gt;();
 826          for (Property property : entity.getProperties()) {
 827              if (property.getName().startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 828                  productOptionProperties.add(property);
 829              }
 830          }
 831          return productOptionProperties;
 832      }
 833  
 834      /**
 835       * Ensures that the given list of {@link ProductOptionValue} IDs is unique for the given {@link Product}.
 836       *
 837       * If sku browsing is enabled, then it is assumed that a single combination of {@link ProductOptionValue} IDs
<abbr title=" 838       * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProductOptionValue} IDs."> 838       * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProductOptionVaðŸ”µ</abbr>
 839       * In this case, the following validation is skipped.
 840       *
 841       * @param product
 842       * @param productOptionProperties
<abbr title=" 843       * @param currentSku - for update operations, this is the current Sku that is being updated; should be excluded from"> 843       * @param currentSku - for update operations, this is the current Sku that is being updated; should be excludeðŸ”µ</abbr>
 844       * attempting validation
 845       * @return &lt;b&gt;null&lt;/b&gt; if successfully validation, the error entity otherwise
 846       */
<abbr title=" 847      protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOptionProperties, Sku currentSku) {"> 847      protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOptionPropðŸ”µ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 848 -        if(useSku) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 849 -            return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 850 -        }</span>
 851          //do not attempt POV validation if no PO properties were passed in
 852          if (CollectionUtils.isNotEmpty(productOptionProperties)) {
 853              List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 854              for (Property property : productOptionProperties) {
 855                  productOptionValueIds.add(Long.parseLong(property.getValue()));
 856              }
 857  
 858              boolean validated = true;
 859              for (Sku sku : product.getAdditionalSkus()) {
 860                  if (currentSku == null || !sku.getId().equals(currentSku.getId())) {
 861                      List&lt;Long&gt; testList = new ArrayList&lt;&gt;();
 862                      for (ProductOptionValue optionValue : sku.getProductOptionValues()) {
 863                          testList.add(optionValue.getId());
 864                      }
 865  
 866                      if (CollectionUtils.isNotEmpty(testList) &amp;&amp;
 867                              productOptionValueIds.containsAll(testList) &amp;&amp;
 868                              productOptionValueIds.size() == testList.size()) {
 869                          validated = false;
 870                          break;
 871                      }
 872                  }
 873              }
 874  
 875              if (!validated) {
 876                  Entity errorEntity = new Entity();
 877                  for (Property productOptionProperty : productOptionProperties) {
 878                      errorEntity.addValidationError(productOptionProperty.getName(), &quot;uniqueSkuError&quot;);
 879                  }
 880                  return errorEntity;
 881              }
 882          }
 883          return null;
 884      }
 885  
 886  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Admin Module
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  
  19  package org.broadleafcommerce.admin.server.service.handler;
  20  
  21  import static com.google.common.base.CharMatcher.DIGIT;
  22  
  23  import org.apache.commons.collections.CollectionUtils;
  24  import org.apache.commons.collections.Transformer;
  25  import org.apache.commons.lang.BooleanUtils;
  26  import org.apache.commons.lang3.ArrayUtils;
  27  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.commons.lang3.math.NumberUtils;</span>
  29  import org.apache.commons.logging.Log;
  30  import org.apache.commons.logging.LogFactory;
  31  import org.broadleafcommerce.admin.server.service.SkuMetadataCacheService;
  32  import org.broadleafcommerce.common.exception.ServiceException;
  33  import org.broadleafcommerce.common.presentation.client.LookupType;
  34  import org.broadleafcommerce.common.presentation.client.OperationType;
  35  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  36  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  37  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  38  import org.broadleafcommerce.common.sandbox.SandBoxHelper;
  39  import org.broadleafcommerce.common.util.BLCCollectionUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import org.broadleafcommerce.common.util.StringUtil;</span>
  41  import org.broadleafcommerce.common.util.TypedTransformer;
  42  import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  43  import org.broadleafcommerce.core.catalog.domain.Product;
  44  import org.broadleafcommerce.core.catalog.domain.ProductBundle;
  45  import org.broadleafcommerce.core.catalog.domain.ProductImpl;
  46  import org.broadleafcommerce.core.catalog.domain.ProductOption;
  47  import org.broadleafcommerce.core.catalog.domain.ProductOptionImpl;
  48  import org.broadleafcommerce.core.catalog.domain.ProductOptionValue;
  49  import org.broadleafcommerce.core.catalog.domain.ProductOptionValueImpl;
  50  import org.broadleafcommerce.core.catalog.domain.Sku;
  51  import org.broadleafcommerce.core.catalog.domain.SkuImpl;
  52  import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXref;
  53  import org.broadleafcommerce.core.catalog.domain.SkuProductOptionValueXrefImpl;
  54  import org.broadleafcommerce.core.catalog.service.CatalogService;
  55  import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  56  import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  57  import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;
  58  import org.broadleafcommerce.openadmin.dto.DynamicResultSet;
  59  import org.broadleafcommerce.openadmin.dto.Entity;
  60  import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  61  import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;
  62  import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  63  import org.broadleafcommerce.openadmin.dto.PersistencePackage;
  64  import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  65  import org.broadleafcommerce.openadmin.dto.Property;
  66  import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  67  import org.broadleafcommerce.openadmin.server.dao.DynamicEntityDao;
  68  import org.broadleafcommerce.openadmin.server.service.handler.CustomPersistenceHandlerAdapter;
  69  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  70  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManagerFactory;
  71  import org.broadleafcommerce.openadmin.server.service.persistence.module.InspectHelper;
  72  import org.broadleafcommerce.openadmin.server.service.persistence.module.PersistenceModule;
  73  import org.broadleafcommerce.openadmin.server.service.persistence.module.RecordHelper;
  74  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;
  75  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;
  76  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;
  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;
  78  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;
  79  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;
  80  import org.hibernate.ejb.HibernateEntityManager;
  81  import org.springframework.beans.factory.annotation.Value;
  82  import org.springframework.stereotype.Component;

  83  import java.io.Serializable;
  84  import java.util.ArrayList;
  85  import java.util.Arrays;
  86  import java.util.Collection;
  87  import java.util.Collections;
  88  import java.util.HashMap;
  89  import java.util.Iterator;
  90  import java.util.List;
  91  import java.util.Map;

  92  import javax.annotation.Resource;
  93  import javax.persistence.EntityManager;
  94  import javax.persistence.PersistenceContext;
  95  import javax.persistence.TypedQuery;
  96  import javax.persistence.criteria.CriteriaBuilder;
  97  import javax.persistence.criteria.From;
  98  import javax.persistence.criteria.Path;
  99  import javax.persistence.criteria.Predicate;
 100  
 101  /**
 102   * @author Phillip Verheyden
 103   *
 104   */
 105  @Component(&quot;blSkuCustomPersistenceHandler&quot;)
 106  public class SkuCustomPersistenceHandler extends CustomPersistenceHandlerAdapter {
 107  
 108      private static final Log LOG = LogFactory.getLog(SkuCustomPersistenceHandler.class);
 109  
 110      public static String PRODUCT_OPTION_FIELD_PREFIX = &quot;productOption&quot;;
 111      public static String INVENTORY_ONLY_CRITERIA = &quot;onlyInventoryProperties&quot;;
 112  
 113  
 114      @Value(&quot;${solr.index.use.sku}&quot;)
 115      protected boolean useSku;
 116  
 117      @Value(&quot;${use.to.one.lookup.sku.product.option.value:false}&quot;)
 118      protected boolean useToOneLookupSkuProductOptionValue = false;
 119  
 120      @Resource(name =&quot;blSkuMetadataCacheService&quot;)
 121      protected SkuMetadataCacheService skuMetadataCacheService;
 122  
 123      @Resource(name=&quot;blAdornedTargetListPersistenceModule&quot;)
 124      protected PersistenceModule adornedPersistenceModule;
 125  
 126      @Resource(name = &quot;blSkuCustomPersistenceHandlerExtensionManager&quot;)
 127      protected SkuCustomPersistenceHandlerExtensionManager extensionManager;
 128  
 129      /**
<abbr title=" 130       * This represents the field that all of the product option values will be stored in. This would be used in the case"> 130       * This represents the field that all of the product option values will be stored in. This would be used in thðŸ”µ</abbr>
<abbr title=" 131       * where there are a bunch of product options and displaying each option as a grid header would have everything"> 131       * where there are a bunch of product options and displaying each option as a grid header would have everythinðŸ”µ</abbr>
 132       * squashed together. Filtering on this field is currently unsupported.
 133       */
 134      public static String CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME = &quot;consolidatedProductOptions&quot;;
 135      public static String CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER = &quot;; &quot;;
 136  
 137      @Resource(name=&quot;blCatalogService&quot;)
 138      protected CatalogService catalogService;
 139  
 140      @PersistenceContext(unitName = &quot;blPU&quot;)
 141      protected EntityManager em;
 142  
 143      @Resource(name = &quot;blCriteriaTranslator&quot;)
 144      protected CriteriaTranslator criteriaTranslator;
 145  
 146      @Resource(name = &quot;blSandBoxHelper&quot;)
 147      protected SandBoxHelper sandBoxHelper;
 148  
 149      @Override
 150      public Boolean canHandleInspect(PersistencePackage persistencePackage) {
 151          return canHandle(persistencePackage, persistencePackage.getPersistencePerspective().getOperationTypes()
 152                  .getInspectType());
 153      }
 154  
 155      @Override
 156      public Boolean canHandleFetch(PersistencePackage persistencePackage) {
<abbr title=" 157          OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFetchType();"> 157          OperationType fetchType = persistencePackage.getPersistencePerspective().getOperationTypes().getFetchType(ðŸ”µ</abbr>
 158          return canHandle(persistencePackage, fetchType);
 159      }
 160  
 161      @Override
 162      public Boolean canHandleAdd(PersistencePackage persistencePackage) {
 163          OperationType addType = persistencePackage.getPersistencePerspective().getOperationTypes().getAddType();
 164          return canHandle(persistencePackage, addType);
 165      }
 166  
 167      @Override
 168      public Boolean canHandleUpdate(PersistencePackage persistencePackage) {
<abbr title=" 169          OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getUpdateType();"> 169          OperationType updateType = persistencePackage.getPersistencePerspective().getOperationTypes().getUpdateTypðŸ”µ</abbr>
 170          return canHandle(persistencePackage, updateType);
 171      }
 172  
 173      /**
 174       * Since this is the default for all Skus, it&#x27;s possible that we are providing custom criteria for this
 175       * Sku lookup. In that case, we probably want to delegate to a child class, so only use this particular
<abbr title=" 176       * persistence handler if there is no custom criteria being used and the ceiling entity is an instance of Sku. The"> 176       * persistence handler if there is no custom criteria being used and the ceiling entity is an instance of Sku.ðŸ”µ</abbr>
<abbr title=" 177       * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for the ceiling entity"> 177       * exception to this rule is when we are pulling back Media, since the admin actually uses Sku for the ceilingðŸ”µ</abbr>
<abbr title=" 178       * class name. That should be handled by the map structure module though, so only handle things in the Sku custom"> 178       * class name. That should be handled by the map structure module though, so only handle things in the Sku cusðŸ”µ</abbr>
 179       * persistence handler for OperationType.BASIC
 180       *
 181       */
 182      protected Boolean canHandle(PersistencePackage persistencePackage, OperationType operationType) {
<abbr title=" 183          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 183          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 184          try {
 185              Class testClass = Class.forName(ceilingEntityFullyQualifiedClassname);
 186              return Sku.class.isAssignableFrom(testClass) &amp;&amp;
 187                      //ArrayUtils.isEmpty(persistencePackage.getCustomCriteria()) &amp;&amp;
 188                      OperationType.BASIC.equals(operationType) &amp;&amp;
<abbr title=" 189                      (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.ADORNEDTARGETLIST) == null);"> 189                      (persistencePackage.getPersistencePerspective().getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
 190          } catch (ClassNotFoundException e) {
 191              return false;
 192          }
 193      }
 194  
 195      /**
 196       * Build out the extra fields for the product options
 197       */
 198      @Override
<abbr title=" 199      public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, InspectHelper helper) throws ServiceException {"> 199      public DynamicResultSet inspect(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, InspðŸ”µ</abbr>
 200          try {
 201              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 202              Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties = new HashMap&lt;&gt;();
 203  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -            String productIdStr = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 205 -            if (persistencePackage.getCustomCriteria() != null &amp;&amp; persistencePackage.getCustomCriteria().length &gt; 0) {"> 205 -            if (persistencePackage.getCustomCriteria() != null &amp;&amp; persistencePackage.getCustomCriteria().length &gt; ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -                productIdStr = persistencePackage.getCustomCriteria()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +            String productIdStr = getOwningProductId(persistencePackage.getSectionCrumbs());</span>
 209              String cacheKey = skuMetadataCacheService.buildCacheKey(productIdStr);
 210  
 211              Map&lt;String, FieldMetadata&gt; properties = null;
 212              boolean useCache = skuMetadataCacheService.useCache();
 213              if (useCache) {
 214                  properties = skuMetadataCacheService.getFromCache(cacheKey);
 215              }
 216              if (properties == null) {
 217                  //Grab the default properties for the Sku
 218                  properties = helper.getSimpleMergedProperties(SkuImpl.class.getName(), persistencePerspective);
 219  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 220 -                boolean isFirstCriteriaNAN = persistencePackage.getCustomCriteria() == null || persistencePackage.getCustomCriteria().length == 0;"> 220 -                boolean isFirstCriteriaNAN = persistencePackage.getCustomCriteria() == null || persistencePackage.ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +                boolean isFirstCriteriaNAN = productIdStr == null;</span>
 222                  if (!isFirstCriteriaNAN &amp;&amp; useToOneLookupSkuProductOptionValue) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 223 -                    isFirstCriteriaNAN = !DIGIT.matchesAllOf(persistencePackage.getCustomCriteria()[0]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +                    isFirstCriteriaNAN = !NumberUtils.isNumber(productIdStr);</span>
 225                  }
 226                  if (isFirstCriteriaNAN) {
 227                      //look up all the ProductOptions and then create new fields for each of them
 228                      List&lt;ProductOption&gt; options = catalogService.readAllProductOptions();
 229                      int order = 0;
 230                      for (ProductOption option : options) {
 231                          //add this to the built Sku properties
 232                          FieldMetadata md = createIndividualOptionField(option, order);
 233                          if (md != null) {
 234                              properties.put(&quot;productOption&quot; + option.getId(), md);
 235                          }
 236                      }
 237                  } else {
 238                      // If we have a product to filter the list of available product options, then use it
 239                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -                        Long productId = Long.parseLong(persistencePackage.getCustomCriteria()[0]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +                        Long productId = Long.parseLong(productIdStr);</span>
 242                          Product product = catalogService.findProductById(productId);
 243                          for (ProductOption option : product.getProductOptions()) {
 244                              FieldMetadata md = createIndividualOptionField(option, 0);
 245                              if (md != null) {
 246                                  properties.put(&quot;productOption&quot; + option.getId(), md);
 247                              }
 248                          }
 249                      } catch (NumberFormatException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 250 -                        // the criteria wasn&#x27;t a product id, just don&#x27;t do anything</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +                        // there wasn&#x27;t a valid product id, just don&#x27;t do anything</span>
 252                      }
 253                  }
 254  
<abbr title=" 255                  //also build the consolidated field; if using the SkuBasicClientEntityModule then this field will be"> 255                  //also build the consolidated field; if using the SkuBasicClientEntityModule then this field will ðŸ”µ</abbr>
 256                  //permanently hidden
<abbr title=" 257                  properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuImpl.class));"> 257                  properties.put(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME, createConsolidatedOptionField(SkuImpl.clasðŸ”µ</abbr>
 258  
 259                  if (useCache) {
 260                      skuMetadataCacheService.addToCache(cacheKey, properties);
 261                  }
 262              }
 263  
 264              allMergedProperties.put(MergedPropertyType.PRIMARY, properties);
 265  
 266              //allow the adorned list to contribute properties as well in the case of Sku bundle items
 267              adornedPersistenceModule.setPersistenceManager((PersistenceManager)helper);
 268              adornedPersistenceModule.updateMergedProperties(persistencePackage, allMergedProperties);
 269  
 270              Class&lt;?&gt;[] entityClasses = dynamicEntityDao.getAllPolymorphicEntitiesFromCeiling(SkuImpl.class);
 271  
<abbr title=" 272              for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.entrySet()) {"> 272              for (Map.Entry&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; entry : allMergedProperties.entrySet())ðŸ”µ</abbr>
 273                  filterOutProductMetadata(entry.getValue());
 274              }
 275  
<abbr title=" 276              ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, allMergedProperties);"> 276              ClassMetadata mergedMetadata = helper.buildClassMetadata(entityClasses, persistencePackage, allMergedPðŸ”µ</abbr>
 277              DynamicResultSet results = new DynamicResultSet(mergedMetadata, null, null);
 278  
 279              return results;
 280          } catch (Exception e) {
 281              ServiceException ex = new ServiceException(&quot;Unable to retrieve inspection results for &quot; +
 282                      persistencePackage.getCeilingEntityFullyQualifiedClassname(), e);
 283              throw ex;
 284          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +    protected String getOwningProductId(SectionCrumb[] sectionCrumbs) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +        if (ArrayUtils.isNotEmpty(sectionCrumbs) &amp;&amp; ProductImpl.class.getCanonicalName()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +                .equals(sectionCrumbs[0].getSectionIdentifier())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +            return sectionCrumbs[0].getSectionId();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +        return null;</span>
 293      }
 294  
 295      protected void filterOutProductMetadata(Map&lt;String, FieldMetadata&gt; map) {
<abbr title=" 296          //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdminPresentation,"> 296          //TODO we shouldn&#x27;t have to filter out these keys here -- we should be able to exclude using @AdminPresentðŸ”µ</abbr>
 297          //but there&#x27;s a bug preventing this behavior from completely working correctly
 298          List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 299          for (Map.Entry&lt;String, FieldMetadata&gt; entry : map.entrySet()) {
 300              if (entry.getKey().contains(&quot;defaultProduct.&quot;) || entry.getKey().contains(&quot;product.&quot;)) {
 301                  removeKeys.add(entry.getKey());
 302              }
 303          }
 304          for (String removeKey : removeKeys) {
 305              map.remove(removeKey);
 306          }
 307      }
 308  
 309      /**
<abbr title=" 310       * Creates the metadata necessary for displaying all of the product option values in a single field. The display of this"> 310       * Creates the metadata necessary for displaying all of the product option values in a single field. The displðŸ”µ</abbr>
<abbr title=" 311       * field is a single string with every product option value appended to it separated by a semicolon. This method should"> 311       * field is a single string with every product option value appended to it separated by a semicolon. This methðŸ”µ</abbr>
<abbr title=" 312       * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be populated on fetch."> 312       * be invoked on an inspect for whatever is utilizing this so that the property will be ready to be populated ðŸ”µ</abbr>
 313       *
<abbr title=" 314       * The metadata that is returned will also be set to prominent by default so that it will be ready to display on whatever"> 314       * The metadata that is returned will also be set to prominent by default so that it will be ready to display ðŸ”µ</abbr>
<abbr title=" 315       * grid is being inspected. If you do not want this behavior you will need to override this functionality in the metadata"> 315       * grid is being inspected. If you do not want this behavior you will need to override this functionality in tðŸ”µ</abbr>
 316       * that is returned.
 317       *
<abbr title=" 318       * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, but if you want to"> 318       * @param inheritedFromType which type this should appear on. This would normally be SkuImpl.class, but if youðŸ”µ</abbr>
 319       * display this field with a different entity then this should be that entity
 320       * @return
 321       */
 322      public FieldMetadata createConsolidatedOptionField(Class&lt;?&gt; inheritedFromType) {
 323          BasicFieldMetadata metadata = new BasicFieldMetadata();
 324          metadata.setFieldType(SupportedFieldType.STRING);
 325          metadata.setMutable(false);
 326          metadata.setInheritedFromType(inheritedFromType.getName());
 327  
<abbr title=" 328          metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 328          metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()))ðŸ”µ</abbr>
 329          metadata.setForeignKeyCollection(false);
 330          metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 331  
 332          metadata.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 333          metadata.setFriendlyName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 334          metadata.setGroup(&quot;&quot;);
 335          metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 336          metadata.setProminent(true);
 337          metadata.setVisibility(VisibilityEnum.FORM_HIDDEN);
 338          metadata.setBroadleafEnumeration(&quot;&quot;);
 339          metadata.setReadOnly(true);
 340          metadata.setRequiredOverride(false);
 341          metadata.setGridOrder(Integer.MAX_VALUE);
 342  
 343          return metadata;
 344      }
 345  
 346      /**
<abbr title=" 347       * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed in. This should be"> 347       * Returns a {@link Property} filled out with a delimited list of the &lt;b&gt;values&lt;/b&gt; that are passed in. This sðŸ”µ</abbr>
 348       * invoked on a fetch and the returned property should be added to the fetched {@link Entity} dto.
 349       *
 350       * @param values
 351       * @return
 352       * @see {@link #createConsolidatedOptionField(Class)};
 353       */
 354      public Property getConsolidatedOptionProperty(Collection&lt;ProductOptionValue&gt; values) {
 355          Property optionValueProperty = new Property();
 356          optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 357  
 358          //order the values by the display order of their correspond product option
 359          //        Collections.sort(values, new Comparator&lt;ProductOptionValue&gt;() {
 360          //
 361          //            @Override
 362          //            public int compare(ProductOptionValue value1, ProductOptionValue value2) {
 363          //                return new CompareToBuilder().append(value1.getProductOption().getDisplayOrder(),
 364          //                        value2.getProductOption().getDisplayOrder()).toComparison();
 365          //            }
 366          //        });
 367  
 368          ArrayList&lt;String&gt; stringValues = new ArrayList&lt;&gt;();
 369          CollectionUtils.collect(values, new Transformer() {
 370  
 371              @Override
 372              public Object transform(Object input) {
 373                  return ((ProductOptionValue) input).getAttributeValue();
 374              }
 375          }, stringValues);
 376  
 377          optionValueProperty.setValue(StringUtils.join(stringValues, CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER));
 378          return optionValueProperty;
 379      }
 380  
 381      /**
 382       * @return a blank {@link Property} corresponding to the CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME
 383       */
 384      public Property getBlankConsolidatedOptionProperty() {
 385          Property optionValueProperty = new Property();
 386          optionValueProperty.setName(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 387          optionValueProperty.setValue(&quot;&quot;);
 388          return optionValueProperty;
 389      }
 390  
 391      /**
<abbr title=" 392       * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum field whose values will"> 392       * &lt;p&gt;Creates an individual property for the specified product option. This should set up an enum field whose ðŸ”µ</abbr>
<abbr title=" 393       * be the option values for this option.  This is useful when you would like to display each product option in as its"> 393       * be the option values for this option.  This is useful when you would like to display each product option inðŸ”µ</abbr>
 394       * own field in a grid so that you can further filter by product option values.&lt;/p&gt;
 395       * &lt;p&gt;In order for these fields to be utilized property on the fetch, in the GWT frontend you must use the
 396       * for your datasource.&lt;/p&gt;
 397       *
 398       * @param option
 399       * @param order
 400       * @return
 401       */
 402      public FieldMetadata createIndividualOptionField(ProductOption option, int order) {
 403          if (useToOneLookupSkuProductOptionValue) {
 404              return createToOneIndividualOptionField(option, order);
 405          } else {
 406              return createExplicitEnumerationIndividualOptionField(option, order);
 407          }
 408      }
 409  
 410      protected FieldMetadata createExplicitEnumerationIndividualOptionField(ProductOption option, int order) {
 411          BasicFieldMetadata metadata = new BasicFieldMetadata();
 412          List&lt;ProductOptionValue&gt; allowedValues = option.getAllowedValues();
 413          if (CollectionUtils.isNotEmpty(allowedValues)) {
 414              metadata.setFieldType(SupportedFieldType.EXPLICIT_ENUMERATION);
 415              metadata.setMutable(true);
 416              metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 417              metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 417              metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCacheðŸ”µ</abbr>
 418              metadata.setForeignKeyCollection(false);
 419              metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 420  
 421              //Set up the enumeration based on the product option values
 422              String[][] optionValues = new String[allowedValues.size()][2];
 423              for (int i = 0; i &lt; allowedValues.size(); i++) {
 424                  ProductOptionValue value = option.getAllowedValues().get(i);
 425                  optionValues[i][0] = value.getId().toString();
 426                  optionValues[i][1] = value.getAttributeValue();
 427              }
 428              metadata.setEnumerationValues(optionValues);
 429  
 430              metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 431              metadata.setFriendlyName(option.getLabel());
 432              metadata.setGroup(&quot;productOption_group&quot;);
 433              metadata.setGroupOrder(-1);
 434              metadata.setOrder(order);
 435              metadata.setExplicitFieldType(SupportedFieldType.UNKNOWN);
 436              metadata.setProminent(false);
 437              metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 438              metadata.setBroadleafEnumeration(&quot;&quot;);
 439              metadata.setReadOnly(false);
 440              metadata.setRequiredOverride(BooleanUtils.isFalse(option.getRequired()));
 441  
 442              return metadata;
 443          }
 444          return null;
 445      }
 446  
 447      /**
<abbr title=" 448       * Using a ToOne lookup performs much better for large product option value lists, speeds up initial page load,"> 448       * Using a ToOne lookup performs much better for large product option value lists, speeds up initial page loadðŸ”µ</abbr>
<abbr title=" 449       * and is generally more accurate in relation to option value updates and how they impact available selections and cache."> 449       * and is generally more accurate in relation to option value updates and how they impact available selectionsðŸ”µ</abbr>
 450       *
 451       * @param option
 452       * @param order
 453       * @return
 454       */
 455      protected FieldMetadata createToOneIndividualOptionField(ProductOption option, int order) {
 456          PersistenceManager persistenceManager = PersistenceManagerFactory.getPersistenceManager();
 457          FilterMapping filterMapping = new FilterMapping().withDirectFilterValues(
<abbr title=" 458                  sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(new Restriction()"> 458                  sandBoxHelper.mergeCloneIds(ProductOptionImpl.class, option.getId())).withRestriction(new RestrictðŸ”µ</abbr>
 459              .withPredicateProvider(new PredicateProvider() {
 460                  @Override
<abbr title=" 461                  public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder, From root,"> 461                  public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder, From rðŸ”µ</abbr>
<abbr title=" 462                                                  String ceilingEntity, String fullPropertyName, Path explicitPath, List directValues) {"> 462                                                  String ceilingEntity, String fullPropertyName, Path explicitPath, ðŸ”µ</abbr>
 463                      return root.get(&quot;productOption&quot;).get(&quot;id&quot;).in(directValues);
 464              }
 465          }));
 466          List&lt;FilterMapping&gt; mappings = new ArrayList&lt;&gt;();
 467          mappings.add(filterMapping);
<abbr title=" 468          TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),"> 468          TypedQuery&lt;Serializable&gt; countQuery = criteriaTranslator.translateCountQuery(persistenceManager.getDynamicðŸ”µ</abbr>
 469                  ProductOptionValueImpl.class.getName(), mappings);
 470          Long count = (Long) countQuery.getSingleResult();
 471          BasicFieldMetadata metadata = null;
 472          if (count &gt; 0) {
 473              metadata = new BasicFieldMetadata();
 474              metadata.setFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 475              metadata.setSecondaryType(SupportedFieldType.INTEGER);
 476              metadata.setForeignKeyProperty(&quot;id&quot;);
 477              metadata.setForeignKeyClass(ProductOptionValueImpl.class.getName());
 478              metadata.setForeignKeyDisplayValueProperty(&quot;attributeValue&quot;);
 479              metadata.setLookupDisplayProperty(&quot;attributeValue&quot;);
 480              metadata.setForeignKeyCollection(false);
 481              metadata.setCustomCriteria(new String[]{&quot;option=&quot; + String.valueOf(option.getId())});
 482              metadata.setName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 483              metadata.setFriendlyName(option.getLabel());
 484              metadata.setGroup(&quot;productOption_group&quot;);
 485              metadata.setGroupOrder(-1);
 486              metadata.setOrder(order);
 487              metadata.setExplicitFieldType(SupportedFieldType.ADDITIONAL_FOREIGN_KEY);
 488              metadata.setProminent(false);
 489              metadata.setVisibility(VisibilityEnum.FORM_EXPLICITLY_SHOWN);
 490              metadata.setReadOnly(false);
<abbr title=" 491              //these may not be actually required, but the CPH has this as a requirement for parsing the data, so we&#x27;ll stick with it here"> 491              //these may not be actually required, but the CPH has this as a requirement for parsing the data, so wðŸ”µ</abbr>
 492              metadata.setRequiredOverride(true);
 493              metadata.setLookupType(LookupType.STANDARD);
 494              metadata.setMutable(true);
 495              metadata.setInheritedFromType(SkuImpl.class.getName());
<abbr title=" 496              metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCache()));"> 496              metadata.setAvailableToTypes(getPolymorphicClasses(SkuImpl.class, em, skuMetadataCacheService.useCacheðŸ”µ</abbr>
 497              metadata.setMergedPropertyType(MergedPropertyType.PRIMARY);
 498              metadata.setTargetClass(SkuImpl.class.getName());
 499              metadata.setFieldName(PRODUCT_OPTION_FIELD_PREFIX + option.getId());
 500          }
 501          return metadata;
 502      }
 503  
 504      @SuppressWarnings(&quot;unchecked&quot;)
 505      @Override
<abbr title=" 506      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 506      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto, DynamicEntityðŸ”µ</abbr>
<abbr title=" 507          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 507          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 508          try {
 509              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 510              //get the default properties from Sku and its subclasses
<abbr title=" 511              Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 511              Map&lt;String, FieldMetadata&gt; originalProps = helper.getSimpleMergedProperties(Sku.class.getName(), persiðŸ”µ</abbr>
 512  
 513              //Pull back the Skus based on the criteria from the client
<abbr title=" 514              List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, originalProps);"> 514              List&lt;FilterMapping&gt; filterMappings = helper.getFilterMappings(persistencePerspective, cto, ceilingEntiðŸ”µ</abbr>
 515  
 516              //allow subclasses to provide additional criteria before executing the query
 517              applyProductOptionValueCriteria(filterMappings, cto, persistencePackage, null);
 518              applySkuBundleItemValueCriteria(filterMappings, cto, persistencePackage);
 519              applyAdditionalFetchCriteria(filterMappings, cto, persistencePackage);
 520  
<abbr title=" 521              List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings, cto.getFirstResult(), cto.getMaxResults());"> 521              List&lt;Serializable&gt; records = helper.getPersistentRecords(persistencePackage.getCeilingEntityFullyQualiðŸ”µ</abbr>
 522              //Convert Skus into the client-side Entity representation
 523              Entity[] payload = helper.getRecords(originalProps, records);
 524  
<abbr title=" 525              int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname(), filterMappings);"> 525              int totalRecords = helper.getTotalRecords(persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 526  
 527              //Now fill out the relevant properties for the product options for the Skus that were returned
 528              updateProductOptionFieldsForFetch(records, payload);
 529  
 530              return new DynamicResultSet(payload, totalRecords);
 531          } catch (Exception e) {
<abbr title=" 532              throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiedClassname, e);"> 532              throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + ceilingEntityFullyQualifiedClassnaðŸ”µ</abbr>
 533          }
 534      }
 535  
 536      /**
<abbr title=" 537       * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a ListGrid context."> 537       * Sets the {@link ProductOptionValue}s of the given {@link Sku}s in a list format for display in a ListGrid cðŸ”µ</abbr>
 538       *
 539       * @param records
 540       * @param payload
 541       * @return
 542       */
 543      public void updateProductOptionFieldsForFetch(List&lt;Serializable&gt; records, Entity[] payload) {
 544          for (int i = 0; i &lt; records.size(); i++) {
 545              Sku sku = (Sku) records.get(i);
 546              Entity entity = payload[i];
 547  
<abbr title=" 548              List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionValueXrefs(), new TypedTransformer&lt;ProductOptionValue&gt;() {"> 548              List&lt;ProductOptionValue&gt; optionValues = BLCCollectionUtils.collectList(sku.getProductOptionValueXrefs(ðŸ”µ</abbr>
 549                  @Override
 550                  public ProductOptionValue transform(Object input) {
 551                      return ((SkuProductOptionValueXref) input).getProductOptionValue();
 552                  }
 553              });
 554  
 555              for (ProductOptionValue value : optionValues) {
 556                  Property optionProperty = new Property();
 557                  optionProperty.setName(PRODUCT_OPTION_FIELD_PREFIX + value.getProductOption().getId());
 558                  optionProperty.setValue(value.getId().toString());
 559                  optionProperty.setDisplayValue(value.getAttributeValue());
 560                  entity.addProperty(optionProperty);
 561              }
 562  
 563              if (CollectionUtils.isNotEmpty(optionValues)) {
 564                  entity.addProperty(getConsolidatedOptionProperty(optionValues));
 565              } else {
 566                  entity.addProperty(getBlankConsolidatedOptionProperty());
 567              }
 568          }
 569      }
 570  
 571      /**
 572       * Add filter restriction such that a ProductBundle cannot add its own default sku as a Sku Bundle Item
 573       */
<abbr title=" 574      private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 574      private void applySkuBundleItemValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PðŸ”µ</abbr>
 575          SectionCrumb[] sectionCrumbs = persistencePackage.getSectionCrumbs();
 576          if (isSkuBundleItemLookup(persistencePackage, sectionCrumbs)) {
 577              final Long defaultSkuId = getOwningProductBundlesDefaultSkuId(sectionCrumbs[0]);
 578  
 579              filterMappings.add(new FilterMapping()
 580                      .withDirectFilterValues(Collections.singletonList(defaultSkuId))
 581                      .withRestriction(new Restriction()
 582                                      .withPredicateProvider(new PredicateProvider() {
 583                                          @Override
 584                                          public Predicate buildPredicate(CriteriaBuilder builder,
 585                                                  FieldPathBuilder fieldPathBuilder,
 586                                                  From root, String ceilingEntity,
 587                                                  String fullPropertyName, Path explicitPath,
 588                                                  List directValues) {
 589                                              return builder.notEqual(root, directValues.get(0));
 590                                          }
 591                                      })
 592                      ));
 593          }
 594      }
 595  
 596      private boolean isSkuBundleItemLookup(PersistencePackage pkg, SectionCrumb[] sectionCrumbs) {
 597          boolean owningClassMatch = false;
 598          boolean requestingFieldMatch = false;
 599  
 600          if (pkg.getCustomCriteria() == null || ArrayUtils.isEmpty(sectionCrumbs)) {
 601              return false;
 602          }
 603  
 604          for (String criteria : pkg.getCustomCriteria()) {
 605              if (&quot;owningClass=org.broadleafcommerce.core.catalog.domain.SkuBundleItemImpl&quot;.equals(criteria)) {
 606                  owningClassMatch = true;
 607              } else if (&quot;requestingField=sku&quot;.equals(criteria)) {
 608                  requestingFieldMatch = true;
 609              }
 610          }
 611  
<abbr title=" 612          boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectionIdentifier());"> 612          boolean sectionCrumbMatch = ProductImpl.class.getCanonicalName().equals(sectionCrumbs[0].getSectionIdentifðŸ”µ</abbr>
 613  
 614          return owningClassMatch &amp;&amp; requestingFieldMatch &amp;&amp; sectionCrumbMatch;
 615      }
 616  
 617      private Long getOwningProductBundlesDefaultSkuId(SectionCrumb sectionCrumb) {
 618          if (ProductImpl.class.getCanonicalName().equals(sectionCrumb.getSectionIdentifier())
 619                  &amp;&amp; sectionCrumb.getSectionId() != null) {
<abbr title=" 620              ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(sectionCrumb.getSectionId()));"> 620              ProductBundle productBundle = (ProductBundle) catalogService.findProductById(Long.valueOf(sectionCrumbðŸ”µ</abbr>
 621              return productBundle.getDefaultSku().getId();
 622          }
 623          return null;
 624      }
 625  
<abbr title=" 626      public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage, String skuPropertyPrefix) {"> 626      public void applyProductOptionValueCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PeðŸ”µ</abbr>
 627  
 628          //if the front
 629          final List&lt;Long&gt; productOptionValueFilterIDs = new ArrayList&lt;&gt;();
 630          for (String filterProperty : cto.getCriteriaMap().keySet()) {
 631              if (filterProperty.startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 632                  FilterAndSortCriteria criteria = cto.get(filterProperty);
 633                  productOptionValueFilterIDs.add(Long.parseLong(criteria.getFilterValues().get(0)));
 634              }
 635          }
 636  
 637          //also determine if there is a consolidated POV query
 638          final List&lt;String&gt; productOptionValueFilterValues = new ArrayList&lt;&gt;();
 639          FilterAndSortCriteria consolidatedCriteria = cto.get(CONSOLIDATED_PRODUCT_OPTIONS_FIELD_NAME);
 640          if (!consolidatedCriteria.getFilterValues().isEmpty()) {
 641              //the criteria in this case would be a semi-colon delimeter value list
<abbr title=" 642              productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.getFilterValues().get(0), CONSOLIDATED_PRODUCT_OPTIONS_DELIMETER)));"> 642              productOptionValueFilterValues.addAll(Arrays.asList(StringUtils.split(consolidatedCriteria.getFilterVaðŸ”µ</abbr>
 643          }
 644  
 645          if (productOptionValueFilterIDs.size() &gt; 0) {
 646              FilterMapping filterMapping = new FilterMapping()
<abbr title=" 647                  .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.id&quot;))"> 647                  .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuProðŸ”µ</abbr>
 648                  .withDirectFilterValues(productOptionValueFilterIDs)
 649                  .withRestriction(new Restriction()
 650                      .withPredicateProvider(new PredicateProvider() {
 651                          @Override
<abbr title=" 652                          public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 652                          public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilderðŸ”µ</abbr>
 653                                                          From root, String ceilingEntity,
<abbr title=" 654                                                          String fullPropertyName, Path explicitPath, List directValues) {"> 654                                                          String fullPropertyName, Path explicitPath, List directValðŸ”µ</abbr>
 655                              return explicitPath.as(Long.class).in(directValues);
 656                          }
 657                      })
 658                  );
 659              filterMappings.add(filterMapping);
 660          }
 661          if (productOptionValueFilterValues.size() &gt; 0) {
 662              FilterMapping filterMapping = new FilterMapping()
<abbr title=" 663                  .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuPropertyPrefix + &quot;.productOptionValueXrefs.productOptionValue.attributeValue&quot;))"> 663                  .withFieldPath(new FieldPath().withTargetProperty(StringUtils.isEmpty(skuPropertyPrefix)?&quot;&quot;:skuProðŸ”µ</abbr>
 664                  .withDirectFilterValues(productOptionValueFilterValues)
 665                  .withRestriction(new Restriction()
 666                      .withPredicateProvider(new PredicateProvider() {
 667                          @Override
<abbr title=" 668                          public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilder,"> 668                          public Predicate buildPredicate(CriteriaBuilder builder, FieldPathBuilder fieldPathBuilderðŸ”µ</abbr>
 669                                                          From root, String ceilingEntity,
<abbr title=" 670                                                          String fullPropertyName, Path explicitPath, List directValues) {"> 670                                                          String fullPropertyName, Path explicitPath, List directValðŸ”µ</abbr>
 671                              return explicitPath.as(String.class).in(directValues);
 672                          }
 673                      })
 674                  );
 675              filterMappings.add(filterMapping);
 676          }
 677      }
 678  
 679      /**
<abbr title=" 680       * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the queryCritiera. At the"> 680       * &lt;p&gt;Available override point for subclasses if they would like to add additional criteria via the queryCritiðŸ”µ</abbr>
<abbr title=" 681       * point that this method has been called, criteria from the frontend has already been applied, thus allowing you to"> 681       * point that this method has been called, criteria from the frontend has already been applied, thus allowing ðŸ”µ</abbr>
 682       * override from there as well.&lt;/p&gt;
<abbr title=" 683       * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filter criteria"> 683       * &lt;p&gt;Subclasses that choose to override this should also call this super method so that correct filter criterðŸ”µ</abbr>
 684       * can be applied for product option values&lt;/p&gt;
 685       *
 686       */
<abbr title=" 687      public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersistencePackage persistencePackage) {"> 687      public void applyAdditionalFetchCriteria(List&lt;FilterMapping&gt; filterMappings, CriteriaTransferObject cto, PersiðŸ”µ</abbr>
 688          //unimplemented
 689      }
 690  
 691      @Override
<abbr title=" 692      public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 692      public Entity add(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helpeðŸ”µ</abbr>
 693          Entity entity = persistencePackage.getEntity();
 694          try {
 695              //Fill out the Sku instance from the form
 696              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 697              Sku adminInstance = (Sku) Class.forName(entity.getType()[0]).newInstance();
<abbr title=" 698              Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 698              Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), perðŸ”µ</abbr>
 699              filterOutProductMetadata(adminProperties);
 700              adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);
 701  
 702              //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 703              Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
 704                                                                               getProductOptionProperties(entity),
 705                                                                               null);
 706              if (errorEntity != null) {
 707                  entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 708                  return entity;
 709              }
 710  
 711              //persist the newly-created Sku
 712              adminInstance = dynamicEntityDao.persist(adminInstance);
 713  
 714              //associate the product option values
 715              associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 716  
 717              //After associating the product option values, save off the Sku
 718              adminInstance = dynamicEntityDao.merge(adminInstance);
 719  
 720              //Fill out the DTO and add in the product option value properties to it
 721              Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 722              for (Property property : getProductOptionProperties(entity)) {
 723                  result.addProperty(property);
 724              }
 725              return result;
 726          } catch (Exception e) {
 727              throw new ServiceException(&quot;Unable to perform fetch for entity: &quot; + Sku.class.getName(), e);
 728          }
 729      }
 730  
 731      @Override
<abbr title=" 732      public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) throws ServiceException {"> 732      public Entity update(PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper heðŸ”µ</abbr>
 733          Entity entity = persistencePackage.getEntity();
 734          try {
 735              //Fill out the Sku instance from the form
 736              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 737              Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), persistencePerspective);"> 737              Map&lt;String, FieldMetadata&gt; adminProperties = helper.getSimpleMergedProperties(Sku.class.getName(), perðŸ”µ</abbr>
 738              filterOutProductMetadata(adminProperties);
 739              Object primaryKey = helper.getPrimaryKey(entity, adminProperties);
 740              Sku adminInstance = (Sku) dynamicEntityDao.retrieve(Class.forName(entity.getType()[0]), primaryKey);
 741              adminInstance = (Sku) helper.createPopulatedInstance(adminInstance, entity, adminProperties, false);
 742  
 743              //Verify that there isn&#x27;t already a Sku for this particular product option value combo
 744              Entity errorEntity = validateUniqueProductOptionValueCombination(adminInstance.getProduct(),
 745                                                                              getProductOptionProperties(entity),
 746                                                                              adminInstance);
 747              if (errorEntity != null) {
 748                  entity.setPropertyValidationErrors(errorEntity.getPropertyValidationErrors());
 749                  return entity;
 750              }
 751  
 752              // Only modify product options if this ISN&#x27;T an update for inventory properties
 753              if (!persistencePackage.containsCriteria(INVENTORY_ONLY_CRITERIA)) {
 754                  associateProductOptionValuesToSku(entity, adminInstance, dynamicEntityDao);
 755              }
 756  
 757              adminInstance = dynamicEntityDao.merge(adminInstance);
 758  
 759              extensionManager.getProxy().skuUpdated(adminInstance);
 760  
 761              //Fill out the DTO and add in the product option value properties to it
 762              Entity result = helper.getRecord(adminProperties, adminInstance, null, null);
 763              for (Property property : getProductOptionProperties(entity)) {
 764                  result.addProperty(property);
 765              }
 766              return result;
 767          } catch (Exception e) {
 768              throw new ServiceException(&quot;Unable to perform update for entity: &quot; + Sku.class.getName(), e);
 769          }
 770      }
 771  
 772      @Override
 773      protected String[] getPolymorphicClasses(Class&lt;?&gt; clazz, EntityManager em, boolean useCache) {
 774          DynamicDaoHelperImpl helper = new DynamicDaoHelperImpl();
 775          Class&lt;?&gt;[] classes = helper.getAllPolymorphicEntitiesFromCeiling(clazz,
 776                  helper.getSessionFactory((HibernateEntityManager) em), true, useCache);

 777          String[] result = new String[classes.length];
 778          for (int i = 0; i &lt; classes.length; i++) {
 779              result[i] = classes[i].getName();
 780          }
 781          return result;
 782      }
 783  
 784      /**
<abbr title=" 785       * This initially removes all of the product option values that are currently related to the Sku and then re-associates"> 785       * This initially removes all of the product option values that are currently related to the Sku and then re-aðŸ”µ</abbr>
 786       * the {@link ProductOptionValue}s
 787       * @param entity
 788       * @param adminInstance
 789       */
<abbr title=" 790      protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dynamicEntityDao) {"> 790      protected void associateProductOptionValuesToSku(Entity entity, Sku adminInstance, DynamicEntityDao dynamicEntðŸ”µ</abbr>
 791          //Get the list of product option value ids that were selected from the form
 792          List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 793          for (Property property : getProductOptionProperties(entity)) {
 794              Long propId = Long.parseLong(property.getValue());
 795              productOptionValueIds.add(propId);
 796              property.setIsDirty(true);
 797          }
 798  
 799          // Only process associations if product option value changes came in via the form
 800          if (CollectionUtils.isNotEmpty(productOptionValueIds)) {
 801              //remove the current list of product option values from the Sku
 802              if (adminInstance.getProductOptionValueXrefs().size() &gt; 0) {
<abbr title=" 803                  Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs().iterator();"> 803                  Iterator&lt;SkuProductOptionValueXref&gt; iterator = adminInstance.getProductOptionValueXrefs().iteratorðŸ”µ</abbr>
 804                  while (iterator.hasNext()) {
 805                      dynamicEntityDao.remove(iterator.next());
 806                  }
 807                  dynamicEntityDao.merge(adminInstance);
 808              }
 809  
 810              //Associate the product option values from the form with the Sku
 811              for (Long id : productOptionValueIds) {
 812                  //Simply find the changed ProductOptionValues directly - seems to work better with sandboxing code
<abbr title=" 813                  ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpl.class, id);"> 813                  ProductOptionValue pov = (ProductOptionValue) dynamicEntityDao.find(ProductOptionValueImpl.class, ðŸ”µ</abbr>
 814                  SkuProductOptionValueXref xref = new SkuProductOptionValueXrefImpl(adminInstance, pov);
 815                  xref = dynamicEntityDao.merge(xref);
 816                  adminInstance.getProductOptionValueXrefs().add(xref);
 817              }
 818          }
 819      }
 820  
 821      protected List&lt;Property&gt; getProductOptionProperties(Entity entity) {
 822          List&lt;Property&gt; productOptionProperties = new ArrayList&lt;&gt;();
 823          for (Property property : entity.getProperties()) {
 824              if (property.getName().startsWith(PRODUCT_OPTION_FIELD_PREFIX)) {
 825                  productOptionProperties.add(property);
 826              }
 827          }
 828          return productOptionProperties;
 829      }
 830  
 831      /**
 832       * Ensures that the given list of {@link ProductOptionValue} IDs is unique for the given {@link Product}.
 833       *
 834       * If sku browsing is enabled, then it is assumed that a single combination of {@link ProductOptionValue} IDs
<abbr title=" 835       * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProductOptionValue} IDs."> 835       * is not unique and more than one {@link Sku} could have the exact same combination of {@link ProductOptionVaðŸ”µ</abbr>
 836       * In this case, the following validation is skipped.
 837       *
 838       * @param product
 839       * @param productOptionProperties
<abbr title=" 840       * @param currentSku - for update operations, this is the current Sku that is being updated; should be excluded from"> 840       * @param currentSku - for update operations, this is the current Sku that is being updated; should be excludeðŸ”µ</abbr>
 841       * attempting validation
 842       * @return &lt;b&gt;null&lt;/b&gt; if successfully validation, the error entity otherwise
 843       */
<abbr title=" 844      protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOptionProperties, Sku currentSku) {"> 844      protected Entity validateUniqueProductOptionValueCombination(Product product, List&lt;Property&gt; productOptionPropðŸ”µ</abbr>
 845          if(useSku) {
 846              return null;
 847          }
 848          //do not attempt POV validation if no PO properties were passed in
 849          if (CollectionUtils.isNotEmpty(productOptionProperties)) {
 850              List&lt;Long&gt; productOptionValueIds = new ArrayList&lt;&gt;();
 851              for (Property property : productOptionProperties) {
 852                  productOptionValueIds.add(Long.parseLong(property.getValue()));
 853              }
 854  
 855              boolean validated = true;
 856              for (Sku sku : product.getAdditionalSkus()) {
 857                  if (currentSku == null || !sku.getId().equals(currentSku.getId())) {
 858                      List&lt;Long&gt; testList = new ArrayList&lt;&gt;();
 859                      for (ProductOptionValue optionValue : sku.getProductOptionValues()) {
 860                          testList.add(optionValue.getId());
 861                      }
 862  
 863                      if (CollectionUtils.isNotEmpty(testList) &amp;&amp;
 864                              productOptionValueIds.containsAll(testList) &amp;&amp;
 865                              productOptionValueIds.size() == testList.size()) {
 866                          validated = false;
 867                          break;
 868                      }
 869                  }
 870              }
 871  
 872              if (!validated) {
 873                  Entity errorEntity = new Entity();
 874                  for (Property productOptionProperty : productOptionProperties) {
 875                      errorEntity.addValidationError(productOptionProperty.getName(), &quot;uniqueSkuError&quot;);
 876                  }
 877                  return errorEntity;
 878              }
 879          }
 880          return null;
 881      }
 882  
 883  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            