<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>33</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    33
                    <a href="32.html">prev</a>
                    <a href="34.html">next</a>
                    <a href="33_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    AriaLyy/Aria_cb1f0e730bde28a18e672c263c1236eb9c4df4fa_Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;cb1f0e730bde28a18e672c263c1236eb9c4df4fa:Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;cb1f0e730bde28a18e672c263c1236eb9c4df4fa^1:Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;cb1f0e730bde28a18e672c263c1236eb9c4df4fa^2:Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;e362621c3899fe60df42df4433560ff4649f9a1e:Aria/src/main/java/com/arialyy/aria/core/common/AbsFileer.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.content.Context;
  19 import com.arialyy.aria.core.AriaManager;
  20 import com.arialyy.aria.core.download.DownloadEntity;
  21 import com.arialyy.aria.core.inf.AbsNormalEntity;
  22 import com.arialyy.aria.core.inf.AbsTaskEntity;
  23 import com.arialyy.aria.core.inf.IDownloadListener;
  24 import com.arialyy.aria.core.inf.IEventListener;
  25 import com.arialyy.aria.orm.DbEntity;
  26 import com.arialyy.aria.util.ALog;
  27 import com.arialyy.aria.util.CommonUtil;
  28 import com.arialyy.aria.util.DbHelper;
  29 import java.io.File;
  30 import java.util.ArrayList;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.List;
  34 import java.util.Map;
  35 import java.util.Properties;
  36 import java.util.Set;
  37 import java.util.Timer;
  38 import java.util.TimerTask;
  39 import java.util.concurrent.ExecutorService;
  40 import java.util.concurrent.Executors;
  41 
  42 /**
  43  * Created by AriaL on 2017/7/1.
  44  * 任务处理器
  45  */
<abbr title="  46 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt;">  46 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;🔵</abbr>
  47     implements Runnable, IUtil {
  48   private static final String STATE = &quot;_state_&quot;;
  49   private static final String RECORD = &quot;_record_&quot;;
  50   /**
  51    * 小于1m的文件不启用多线程
  52    */
  53   protected static final long SUB_LEN = 1024 * 1024;
  54 
  55   private final String TAG = &quot;AbsFileer&quot;;
  56   protected IEventListener mListener;
  57   protected TASK_ENTITY mTaskEntity;
  58   protected ENTITY mEntity;
  59   protected Context mContext;
  60   protected File mTempFile; //文件
  61   protected StateConstance mConstance;
  62   private ExecutorService mFixedThreadPool;
  63   //总线程数
  64   protected int mTotalThreadNum;
  65   //启动线程数
  66   private int mStartThreadNum;
  67   //已完成的线程数
  68   private int mCompleteThreadNum;
  69   private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();
  70 
  71   private Timer mTimer;
  72   @Deprecated private File mConfigFile;
  73   /**
  74    * 进度刷新间隔
  75    */
  76   private long mUpdateInterval = 1000;
  77   private TaskRecord mRecord;
  78 
  79   protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
  80     mListener = listener;
  81     mTaskEntity = taskEntity;
  82     mEntity = mTaskEntity.getEntity();
  83     mContext = AriaManager.APP;
  84     mConstance = new StateConstance();
  85   }
  86 
  87   public void setNewTask(boolean newTask) {
  88     mTaskEntity.setNewTask(newTask);
  89   }
  90 
  91   @Override public void setMaxSpeed(double maxSpeed) {
  92     for (int i = 0; i &lt; mTotalThreadNum; i++) {
  93       AbsThreadTask task = mTask.get(i);
  94       if (task != null) {
  95         task.setMaxSpeed(maxSpeed);
  96       }
  97     }
  98   }
  99 
 100   @Override public void run() {
 101     if (mConstance.isRunning) {
 102       return;
 103     }
 104     startFlow();
 105   }
 106 
 107   /**
 108    * 开始流程
 109    */
 110   private void startFlow() {
 111     mConstance.resetState();
 112     checkTask();
 113     mConstance.TASK_RECORD = mRecord;
 114     if (mListener instanceof IDownloadListener) {
 115       ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 116     }
 117     if (!mTaskEntity.isSupportBP()) {
 118       mTotalThreadNum = 1;
 119       mStartThreadNum = 1;
 120       handleNoSupportBP();
 121     } else {
 122       mTotalThreadNum =
 123           mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 124       handleBreakpoint();
 125     }
 126     mConstance.START_THREAD_NUM = mTotalThreadNum;
 127     /*
 128      * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 129      * 动态长度条件：
 130      * 1、总线程数为1，并且是新任务
 131      * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 132      */
 133     if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 134         || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 135       mConstance.isOpenDynamicFile = true;
 136     }
 137     startTimer();
 138   }
 139 
 140   /**
 141    * 设置新任务的最大线程数
 142    */
 143   protected abstract int setNewTaskThreadNum();
 144 
 145   /**
 146    * 启动进度获取定时器
 147    */
 148   private void startTimer() {
 149     mTimer = new Timer(true);
 150     mTimer.schedule(new TimerTask() {
 151       @Override public void run() {
 152         if (mConstance.isComplete()
 153             || mConstance.isStop()
 154             || mConstance.isCancel()
 155             || !mConstance.isRunning) {
 156           closeTimer();
 157         } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 158           mListener.onProgress(mConstance.CURRENT_LOCATION);
 159         }
 160       }
 161     }, 0, mUpdateInterval);
 162   }
 163 
 164   protected void closeTimer() {
 165     if (mTimer != null) {
 166       mTimer.purge();
 167       mTimer.cancel();
 168       mTimer = null;
 169     }
 170   }
 171 
 172   /**
 173    * 设置定时器更新间隔
 174    *
 175    * @param interval 单位毫秒，不能小于0
 176    */
 177   protected void setUpdateInterval(long interval) {
 178     if (interval &lt; 0) {
 179       ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 180       return;
 181     }
 182     mUpdateInterval = interval;
 183   }
 184 
 185   @Override public long getFileSize() {
 186     return mEntity.getFileSize();
 187   }
 188 
 189   /**
 190    * 获取当前任务位置
 191    */
 192   @Override public long getCurrentLocation() {
 193     return mConstance.CURRENT_LOCATION;
 194   }
 195 
 196   @Override public boolean isRunning() {
 197     return mConstance.isRunning;
 198   }
 199 
 200   @Override public void cancel() {
 201     closeTimer();
 202     mConstance.isRunning = false;
 203     mConstance.isCancel = true;
 204     if (mFixedThreadPool != null) {
 205       mFixedThreadPool.shutdown();
 206     }
 207     for (int i = 0; i &lt; mStartThreadNum; i++) {
 208       AbsThreadTask task = mTask.get(i);
 209       if (task != null) {
 210         task.cancel();
 211       }
 212     }
 213   }
 214 
 215   @Override public void stop() {
 216     closeTimer();
 217     mConstance.isRunning = false;
 218     mConstance.isStop = true;
 219     if (mConstance.isComplete()) return;
 220     if (mFixedThreadPool != null) {
 221       mFixedThreadPool.shutdown();
 222     }
 223     for (int i = 0; i &lt; mStartThreadNum; i++) {
 224       AbsThreadTask task = mTask.get(i);
 225       if (task != null) {
 226         task.stop();
 227       }
 228     }
 229   }
 230 
 231   /**
 232    * 直接调用的时候会自动启动线程执行
 233    */
 234   @Override public void start() {
 235     new Thread(this).start();
 236   }
 237 
 238   @Override public void resume() {
 239     start();
 240   }
 241 
 242   /**
 243    * 检查任务、检查线程数
 244    * 新任务条件：
 245    * 1、文件不存在
 246    * 2、任务记录文件缺失或不匹配
 247    * 3、数据库记录不存在
 248    * 4、不支持断点，则是新任务
 249    */
 250   private void checkTask() {
 251     mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 252     if (mConfigFile.exists()) {
 253       convertDb();
 254     } else {
 255       mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 256       if (mRecord == null) {
 257         initRecord();
 258         mTaskEntity.setNewTask(true);
 259       } else {
 260         if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 261           initRecord();
 262           mTaskEntity.setNewTask(true);
 263         } else if (mTempFile.length() == 0) {
 264           mRecord.deleteData();
 265           initRecord();
 266           mTaskEntity.setNewTask(true);
 267         } else {
 268           for (ThreadRecord tr : mRecord.threadRecords) {
 269             if (tr.isComplete) {
 270               mCompleteThreadNum++;
 271             } else {
 272               mStartThreadNum++;
 273             }
 274           }
 275           mTotalThreadNum = mRecord.threadRecords.size();
 276           mTaskEntity.setNewTask(false);
 277         }
 278       }
 279     }
 280   }
 281 
 282   /**
 283    * convertDb 为兼容性代码
 284    * 从3.4.1开始，线程配置信息将存储在数据库中。
 285    * 将配置文件的内容复制到数据库中，并将配置文件删除
 286    */
 287   private void convertDb() {
 288     List&lt;RecordWrapper&gt; records =
 289         DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 290             mTaskEntity.getKey());
 291     if (records == null || records.size() == 0) {
 292       Properties pro = CommonUtil.loadConfig(mConfigFile);
 293       if (pro.isEmpty()) {
 294         mTaskEntity.setNewTask(true);
 295         return;
 296       }
 297       initRecord();
 298       Set&lt;Object&gt; keys = pro.keySet();
 299       // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 300       // 第一步应该是record 和 state去重取正确的线程数
 301       Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 302       for (Object key : keys) {
 303         String str = String.valueOf(key);
 304         int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 305         set.add(i);
 306       }
 307       int threadNum = set.size();
 308       if (threadNum == 0) {
 309         mTaskEntity.setNewTask(true);
 310         return;
 311       }
 312       mRecord.threadNum = threadNum;
 313       mTotalThreadNum = threadNum;
 314 
 315       for (int i = 0; i &lt; threadNum; i++) {
 316         ThreadRecord tRecord = new ThreadRecord();
 317         tRecord.key = mRecord.filePath;
 318         Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 319         Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
 320         if (state != null &amp;&amp; Integer.parseInt(String.valueOf(state)) == 1) {
 321           mCompleteThreadNum++;
 322           tRecord.isComplete = true;
 323           continue;
 324         }
 325         mStartThreadNum++;
 326         if (record != null) {
 327           Long temp = Long.parseLong(String.valueOf(record));
 328           tRecord.startLocation = temp &gt; 0 ? temp : 0;
 329         } else {
 330           tRecord.startLocation = 0;
 331         }
 332         mRecord.threadRecords.add(tRecord);
 333       }
 334       mConfigFile.delete();
 335     }
 336   }
 337 
 338   /**
 339    * 初始化记录
 340    */
 341   private void initRecord() {
 342     mRecord = new TaskRecord();
 343     mRecord.fileName = mEntity.getFileName();
 344     mRecord.filePath = mTaskEntity.getKey();
 345     mRecord.threadRecords = new ArrayList&lt;&gt;();
 346     mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 347     if (mRecord.isGroupRecord) {
 348       if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 349         mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 350       }
 351     }
 352   }
 353 
 354   /**
 355    * 保存任务记录
 356    */
 357   private void saveRecord() {
 358     mRecord.threadNum = mRecord.threadRecords.size();
 359     mRecord.save();
 360     for (ThreadRecord tr : mRecord.threadRecords) {
 361       tr.save();
 362     }
 363   }
 364 
 365   public TaskRecord getRecord() {
 366     return mRecord;
 367   }
 368 
 369   /**
 370    * 恢复记录地址
 371    *
 372    * @return {@code true}任务已完成
 373    */
 374   private boolean resumeRecordLocation(int i, long startL, long endL) {
 375     mConstance.CURRENT_LOCATION += endL - startL;
 376     ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));
 377     mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 378     mConstance.STOP_NUM++;
 379     mConstance.CANCEL_NUM++;
 380     if (mConstance.isComplete()) {
 381       mRecord.deleteData();
 382       mListener.onComplete();
 383       mConstance.isRunning = false;
 384       return true;
 385     }
 386     return false;
 387   }
 388 
 389   /**
 390    * 启动断点任务时，创建单线程任务
 391    *
 392    * @param i 线程id
 393    * @param startL 该任务起始位置
 394    * @param endL 该任务结束位置
 395    * @param fileLength 该任务需要处理的文件长度
 396    */
 397   private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 398       ThreadRecord record) {
 399     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 400     config.FILE_SIZE = fileLength;
 401     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 402     config.TEMP_FILE = mTempFile;
 403     config.THREAD_ID = i;
 404     config.START_LOCATION = startL;
 405     config.END_LOCATION = endL;
 406     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 407     config.TASK_ENTITY = mTaskEntity;
 408     config.THREAD_RECORD = record;
 409     return selectThreadTask(config);
 410   }
 411 
 412   private void handleBreakpoint() {
 413     long fileLength = mEntity.getFileSize();
 414     long blockSize = fileLength / mTotalThreadNum;
 415     int[] threadId = new int[mTotalThreadNum];
 416     int rl = 0;
 417 
 418     mRecord.fileLength = fileLength;
 419     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 420       threadId[i] = -1;
 421     }
 422     if (mTaskEntity.isNewTask() &amp;&amp; !handleNewTask()) {
 423       return;
 424     }
 425     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 426       long startL = i * blockSize, endL = (i + 1) * blockSize;
 427       ThreadRecord tr;
 428       boolean isNewTr = false;  // 是否是新的线程记录
 429       if (mTaskEntity.isNewTask()) {
 430         tr = new ThreadRecord();
 431         tr.key = mRecord.filePath;
 432         tr.threadId = i;
 433         isNewTr = true;
 434       } else {
 435         tr = mRecord.threadRecords.get(i);
 436       }
 437       if (tr.isComplete) {//该线程已经完成
 438         if (resumeRecordLocation(i, startL, endL)) return;
 439         continue;
 440       }
 441 
 442       //如果有记录，则恢复任务
 443       if (tr.startLocation &gt;= 0) {
 444         Long r = tr.startLocation;
 445         //记录的位置需要在线程区间中
 446         if (startL &lt; r &amp;&amp; r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL)) {
 447           mConstance.CURRENT_LOCATION += r - startL;
 448           startL = r;
 449         }
 450         ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));
 451       }
 452       //最后一个线程的结束位置即为文件的总长度
 453       if (i == (mTotalThreadNum - 1)) {
 454         endL = fileLength;
 455       }
 456       // 更新记录
 457       tr.startLocation = startL;
 458       tr.endLocation = endL;
 459       if (isNewTr) {
 460         mRecord.threadRecords.add(tr);
 461       }
 462       AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 463       if (task == null) return;
 464       mTask.put(i, task);
 465       threadId[rl] = i;
 466       rl++;
 467     }
 468     if (mConstance.CURRENT_LOCATION != 0
 469         &amp;&amp; mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress()) {
 470       ALog.d(TAG, &quot;进度修正&quot;);
 471       mEntity.setCurrentProgress(mConstance.CURRENT_LOCATION);
 472     }
 473     saveRecord();
 474     startThreadTask(threadId);
 475   }
 476 
 477   /**
 478    * 启动单线程任务
 479    */
 480   private void startThreadTask(int[] recordL) {
 481     if (mConstance.CURRENT_LOCATION &gt; 0) {
 482       mListener.onResume(mConstance.CURRENT_LOCATION);
 483     } else {
 484       mListener.onStart(mConstance.CURRENT_LOCATION);
 485     }
 486     mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 487     for (int l : recordL) {
 488       if (l == -1) continue;
 489       Runnable task = mTask.get(l);
 490       if (task != null) {
 491         mFixedThreadPool.execute(task);
 492       }
 493     }
 494   }
 495 
 496   /**
 497    * 重试线程任务，只有线程创建成功才能重试
 498    */
 499   public void retryThreadTask() {
 500     if (mTask == null || mTask.size() == 0) {
 501       ALog.w(TAG, &quot;没有线程任务&quot;);
 502       return;
 503     }
 504     Set&lt;Integer&gt; keys = mTask.keySet();
 505     for (Integer key : keys) {
 506       AbsThreadTask task = mTask.get(key);
 507       if (task != null &amp;&amp; !task.isThreadComplete()) {
 508         task.getConfig().START_LOCATION = task.getCurrentLocation();
 509 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 510         mConstance.isStop = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 511         mConstance.isCancel = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 512         mConstance.isRunning = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 513         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 514             key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
 515 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 516         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 517             key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 518         mFixedThreadPool.execute(task);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 519       }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 520     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 521   }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 522 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 523   /**</span>
 524 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 525         ALog.d(TAG,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 526             String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(), key,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 527                 task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
 528 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 529         mFixedThreadPool.execute(task);
 530       }
 531     }
 532   }
 533 
 534   /**
 535    * 处理新任务
 536    *
 537    * @return {@code true}创建新任务失败
 538    */
 539   protected abstract boolean handleNewTask();
 540 
 541   /**
 542    * 处理不支持断点的任务
 543    */
 544   private void handleNoSupportBP() {
 545     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 546     config.FILE_SIZE = mEntity.getFileSize();
 547     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 548     config.TEMP_FILE = mTempFile;
 549     config.THREAD_ID = 0;
 550     config.START_LOCATION = 0;
 551     config.END_LOCATION = config.FILE_SIZE;
 552     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 553     config.TASK_ENTITY = mTaskEntity;
 554     AbsThreadTask task = selectThreadTask(config);
 555     if (task == null) return;
 556     mTask.put(0, task);
 557     mFixedThreadPool = Executors.newFixedThreadPool(1);
 558     mFixedThreadPool.execute(task);
 559     mListener.onStart(0);
 560   }
 561 
 562   /**
 563    * 选择单任务线程的类型
 564    */
 565   protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 566 }
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.content.Context;
  19 import com.arialyy.aria.core.AriaManager;
  20 import com.arialyy.aria.core.download.DownloadEntity;
  21 import com.arialyy.aria.core.inf.AbsNormalEntity;
  22 import com.arialyy.aria.core.inf.AbsTaskEntity;
  23 import com.arialyy.aria.core.inf.IDownloadListener;
  24 import com.arialyy.aria.core.inf.IEventListener;
  25 import com.arialyy.aria.orm.DbEntity;
  26 import com.arialyy.aria.util.ALog;
  27 import com.arialyy.aria.util.CommonUtil;
  28 import com.arialyy.aria.util.DbHelper;
  29 import java.io.File;
  30 import java.util.ArrayList;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.List;
  34 import java.util.Map;
  35 import java.util.Properties;
  36 import java.util.Set;
  37 import java.util.Timer;
  38 import java.util.TimerTask;
  39 import java.util.concurrent.ExecutorService;
  40 import java.util.concurrent.Executors;
  41 
  42 /**
  43  * Created by AriaL on 2017/7/1.
  44  * 任务处理器
  45  */
<abbr title="  46 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt;">  46 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;🔵</abbr>
  47     implements Runnable, IUtil {
  48   private static final String STATE = &quot;_state_&quot;;
  49   private static final String RECORD = &quot;_record_&quot;;
  50   /**
  51    * 小于1m的文件不启用多线程
  52    */
  53   protected static final long SUB_LEN = 1024 * 1024;
  54 
  55   private final String TAG = &quot;AbsFileer&quot;;
  56   protected IEventListener mListener;
  57   protected TASK_ENTITY mTaskEntity;
  58   protected ENTITY mEntity;
  59   protected Context mContext;
  60   protected File mTempFile; //文件
  61   protected StateConstance mConstance;
  62   private ExecutorService mFixedThreadPool;
  63   //总线程数
  64   protected int mTotalThreadNum;
  65   //启动线程数
  66   private int mStartThreadNum;
  67   //已完成的线程数
  68   private int mCompleteThreadNum;
  69   private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();
  70 
  71   private Timer mTimer;
  72   @Deprecated private File mConfigFile;
  73   /**
  74    * 进度刷新间隔
  75    */
  76   private long mUpdateInterval = 1000;
  77   private TaskRecord mRecord;
  78 
  79   protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
  80     mListener = listener;
  81     mTaskEntity = taskEntity;
  82     mEntity = mTaskEntity.getEntity();
  83     mContext = AriaManager.APP;
  84     mConstance = new StateConstance();
  85   }
  86 
  87   public void setNewTask(boolean newTask) {
  88     mTaskEntity.setNewTask(newTask);
  89   }
  90 
  91   @Override public void setMaxSpeed(double maxSpeed) {
  92     for (int i = 0; i &lt; mTotalThreadNum; i++) {
  93       AbsThreadTask task = mTask.get(i);
  94       if (task != null) {
  95         task.setMaxSpeed(maxSpeed);
  96       }
  97     }
  98   }
  99 
 100   @Override public void run() {
 101     if (mConstance.isRunning) {
 102       return;
 103     }
 104     startFlow();
 105   }
 106 
 107   /**
 108    * 开始流程
 109    */
 110   private void startFlow() {
 111     mConstance.resetState();
 112     checkTask();
 113     mConstance.TASK_RECORD = mRecord;
 114     if (mListener instanceof IDownloadListener) {
 115       ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 116     }
 117     if (!mTaskEntity.isSupportBP()) {
 118       mTotalThreadNum = 1;
 119       mStartThreadNum = 1;
 120       handleNoSupportBP();
 121     } else {
 122       mTotalThreadNum =
 123           mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 124       handleBreakpoint();
 125     }
 126     mConstance.START_THREAD_NUM = mTotalThreadNum;
 127     /*
 128      * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 129      * 动态长度条件：
 130      * 1、总线程数为1，并且是新任务
 131      * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 132      */
 133     if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 134         || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 135       mConstance.isOpenDynamicFile = true;
 136     }
 137     startTimer();
 138   }
 139 
 140   /**
 141    * 设置新任务的最大线程数
 142    */
 143   protected abstract int setNewTaskThreadNum();
 144 
 145   /**
 146    * 启动进度获取定时器
 147    */
 148   private void startTimer() {
 149     mTimer = new Timer(true);
 150     mTimer.schedule(new TimerTask() {
 151       @Override public void run() {
 152         if (mConstance.isComplete()
 153             || mConstance.isStop()
 154             || mConstance.isCancel()
 155             || !mConstance.isRunning) {
 156           closeTimer();
 157         } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 158           mListener.onProgress(mConstance.CURRENT_LOCATION);
 159         }
 160       }
 161     }, 0, mUpdateInterval);
 162   }
 163 
 164   protected void closeTimer() {
 165     if (mTimer != null) {
 166       mTimer.purge();
 167       mTimer.cancel();
 168       mTimer = null;
 169     }
 170   }
 171 
 172   /**
 173    * 设置定时器更新间隔
 174    *
 175    * @param interval 单位毫秒，不能小于0
 176    */
 177   protected void setUpdateInterval(long interval) {
 178     if (interval &lt; 0) {
 179       ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 180       return;
 181     }
 182     mUpdateInterval = interval;
 183   }
 184 
 185   @Override public long getFileSize() {
 186     return mEntity.getFileSize();
 187   }
 188 
 189   /**
 190    * 获取当前任务位置
 191    */
 192   @Override public long getCurrentLocation() {
 193     return mConstance.CURRENT_LOCATION;
 194   }
 195 
 196   @Override public boolean isRunning() {
 197     return mConstance.isRunning;
 198   }
 199 
 200   @Override public void cancel() {
 201     closeTimer();
 202     mConstance.isRunning = false;
 203     mConstance.isCancel = true;
 204     if (mFixedThreadPool != null) {
 205       mFixedThreadPool.shutdown();
 206     }
 207     for (int i = 0; i &lt; mStartThreadNum; i++) {
 208       AbsThreadTask task = mTask.get(i);
 209       if (task != null) {
 210         task.cancel();
 211       }
 212     }
 213   }
 214 
 215   @Override public void stop() {
 216     closeTimer();
 217     mConstance.isRunning = false;
 218     mConstance.isStop = true;
 219     if (mConstance.isComplete()) return;
 220     if (mFixedThreadPool != null) {
 221       mFixedThreadPool.shutdown();
 222     }
 223     for (int i = 0; i &lt; mStartThreadNum; i++) {
 224       AbsThreadTask task = mTask.get(i);
 225       if (task != null) {
 226         task.stop();
 227       }
 228     }
 229   }
 230 
 231   /**
 232    * 直接调用的时候会自动启动线程执行
 233    */
 234   @Override public void start() {
 235     new Thread(this).start();
 236   }
 237 
 238   @Override public void resume() {
 239     start();
 240   }
 241 
 242   /**
 243    * 检查任务、检查线程数
 244    * 新任务条件：
 245    * 1、文件不存在
 246    * 2、任务记录文件缺失或不匹配
 247    * 3、数据库记录不存在
 248    * 4、不支持断点，则是新任务
 249    */
 250   private void checkTask() {
 251     mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 252     if (mConfigFile.exists()) {
 253       convertDb();
 254     } else {
 255       mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 256       if (mRecord == null) {
 257         initRecord();
 258         mTaskEntity.setNewTask(true);
 259       } else {
 260         if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 261           initRecord();
 262           mTaskEntity.setNewTask(true);
 263         } else if (mTempFile.length() == 0) {
 264           mRecord.deleteData();
 265           initRecord();
 266           mTaskEntity.setNewTask(true);
 267         } else {
 268           for (ThreadRecord tr : mRecord.threadRecords) {
 269             if (tr.isComplete) {
 270               mCompleteThreadNum++;
 271             } else {
 272               mStartThreadNum++;
 273             }
 274           }
 275           mTotalThreadNum = mRecord.threadRecords.size();
 276           mTaskEntity.setNewTask(false);
 277         }
 278       }
 279     }
 280   }
 281 
 282   /**
 283    * convertDb 为兼容性代码
 284    * 从3.4.1开始，线程配置信息将存储在数据库中。
 285    * 将配置文件的内容复制到数据库中，并将配置文件删除
 286    */
 287   private void convertDb() {
 288     List&lt;RecordWrapper&gt; records =
 289         DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 290             mTaskEntity.getKey());
 291     if (records == null || records.size() == 0) {
 292       Properties pro = CommonUtil.loadConfig(mConfigFile);
 293       if (pro.isEmpty()) {
 294         mTaskEntity.setNewTask(true);
 295         return;
 296       }
 297       initRecord();
 298       Set&lt;Object&gt; keys = pro.keySet();
 299       // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 300       // 第一步应该是record 和 state去重取正确的线程数
 301       Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 302       for (Object key : keys) {
 303         String str = String.valueOf(key);
 304         int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 305         set.add(i);
 306       }
 307       int threadNum = set.size();
 308       if (threadNum == 0) {
 309         mTaskEntity.setNewTask(true);
 310         return;
 311       }
 312       mRecord.threadNum = threadNum;
 313       mTotalThreadNum = threadNum;
 314 
 315       for (int i = 0; i &lt; threadNum; i++) {
 316         ThreadRecord tRecord = new ThreadRecord();
 317         tRecord.key = mRecord.filePath;
 318         Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 319         Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
 320         if (state != null &amp;&amp; Integer.parseInt(String.valueOf(state)) == 1) {
 321           mCompleteThreadNum++;
 322           tRecord.isComplete = true;
 323           continue;
 324         }
 325         mStartThreadNum++;
 326         if (record != null) {
 327           Long temp = Long.parseLong(String.valueOf(record));
 328           tRecord.startLocation = temp &gt; 0 ? temp : 0;
 329         } else {
 330           tRecord.startLocation = 0;
 331         }
 332         mRecord.threadRecords.add(tRecord);
 333       }
 334       mConfigFile.delete();
 335     }
 336   }
 337 
 338   /**
 339    * 初始化记录
 340    */
 341   private void initRecord() {
 342     mRecord = new TaskRecord();
 343     mRecord.fileName = mEntity.getFileName();
 344     mRecord.filePath = mTaskEntity.getKey();
 345     mRecord.threadRecords = new ArrayList&lt;&gt;();
 346     mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 347     if (mRecord.isGroupRecord) {
 348       if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 349         mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 350       }
 351     }
 352   }
 353 
 354   /**
 355    * 保存任务记录
 356    */
 357   private void saveRecord() {
 358     mRecord.threadNum = mRecord.threadRecords.size();
 359     mRecord.save();
 360     for (ThreadRecord tr : mRecord.threadRecords) {
 361       tr.save();
 362     }
 363   }
 364 
 365   public TaskRecord getRecord() {
 366     return mRecord;
 367   }
 368 
 369   /**
 370    * 恢复记录地址
 371    *
 372    * @return {@code true}任务已完成
 373    */
 374   private boolean resumeRecordLocation(int i, long startL, long endL) {
 375     mConstance.CURRENT_LOCATION += endL - startL;
 376     ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));
 377     mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 378     mConstance.STOP_NUM++;
 379     mConstance.CANCEL_NUM++;
 380     if (mConstance.isComplete()) {
 381       mRecord.deleteData();
 382       mListener.onComplete();
 383       mConstance.isRunning = false;
 384       return true;
 385     }
 386     return false;
 387   }
 388 
 389   /**
 390    * 启动断点任务时，创建单线程任务
 391    *
 392    * @param i 线程id
 393    * @param startL 该任务起始位置
 394    * @param endL 该任务结束位置
 395    * @param fileLength 该任务需要处理的文件长度
 396    */
 397   private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 398       ThreadRecord record) {
 399     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 400     config.FILE_SIZE = fileLength;
 401     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 402     config.TEMP_FILE = mTempFile;
 403     config.THREAD_ID = i;
 404     config.START_LOCATION = startL;
 405     config.END_LOCATION = endL;
 406     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 407     config.TASK_ENTITY = mTaskEntity;
 408     config.THREAD_RECORD = record;
 409     return selectThreadTask(config);
 410   }
 411 
 412   private void handleBreakpoint() {
 413     long fileLength = mEntity.getFileSize();
 414     long blockSize = fileLength / mTotalThreadNum;
 415     int[] threadId = new int[mTotalThreadNum];
 416     int rl = 0;
 417 
 418     mRecord.fileLength = fileLength;
 419     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 420       threadId[i] = -1;
 421     }
 422     if (mTaskEntity.isNewTask() &amp;&amp; !handleNewTask()) {
 423       return;
 424     }
 425     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 426       long startL = i * blockSize, endL = (i + 1) * blockSize;
 427       ThreadRecord tr;
 428       boolean isNewTr = false;  // 是否是新的线程记录
 429       if (mTaskEntity.isNewTask()) {
 430         tr = new ThreadRecord();
 431         tr.key = mRecord.filePath;
 432         tr.threadId = i;
 433         isNewTr = true;
 434       } else {
 435         tr = mRecord.threadRecords.get(i);
 436       }
 437       if (tr.isComplete) {//该线程已经完成
 438         if (resumeRecordLocation(i, startL, endL)) return;
 439         continue;
 440       }
 441 
 442       //如果有记录，则恢复任务
 443       if (tr.startLocation &gt;= 0) {
 444         Long r = tr.startLocation;
 445         //记录的位置需要在线程区间中
 446         if (startL &lt; r &amp;&amp; r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL)) {
 447           mConstance.CURRENT_LOCATION += r - startL;
 448           startL = r;
 449         }
 450         ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));
 451       }
 452       //最后一个线程的结束位置即为文件的总长度
 453       if (i == (mTotalThreadNum - 1)) {
 454         endL = fileLength;
 455       }
 456       // 更新记录
 457       tr.startLocation = startL;
 458       tr.endLocation = endL;
 459       if (isNewTr) {
 460         mRecord.threadRecords.add(tr);
 461       }
 462       AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 463       if (task == null) return;
 464       mTask.put(i, task);
 465       threadId[rl] = i;
 466       rl++;
 467     }
 468     if (mConstance.CURRENT_LOCATION != 0
 469         &amp;&amp; mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress()) {
 470       ALog.d(TAG, &quot;进度修正&quot;);
 471       mEntity.setCurrentProgress(mConstance.CURRENT_LOCATION);
 472     }
 473     saveRecord();
 474     startThreadTask(threadId);
 475   }
 476 
 477   /**
 478    * 启动单线程任务
 479    */
 480   private void startThreadTask(int[] recordL) {
 481     if (mConstance.CURRENT_LOCATION &gt; 0) {
 482       mListener.onResume(mConstance.CURRENT_LOCATION);
 483     } else {
 484       mListener.onStart(mConstance.CURRENT_LOCATION);
 485     }
 486     mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 487     for (int l : recordL) {
 488       if (l == -1) continue;
 489       Runnable task = mTask.get(l);
 490       if (task != null) {
 491         mFixedThreadPool.execute(task);
 492       }
 493     }
 494   }
 495 
 496   /**
 497    * 重试线程任务，只有线程创建成功才能重试
 498    */
 499   public void retryThreadTask() {
 500     if (mTask == null || mTask.size() == 0) {
 501       ALog.w(TAG, &quot;没有线程任务&quot;);
 502       return;
 503     }
 504     Set&lt;Integer&gt; keys = mTask.keySet();
 505     for (Integer key : keys) {
 506       AbsThreadTask task = mTask.get(key);
 507       if (task != null &amp;&amp; !task.isThreadComplete()) {
 508         task.getConfig().START_LOCATION = task.getCurrentLocation();
 509 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 510         mConstance.isStop = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 511         mConstance.isCancel = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 512         mConstance.isRunning = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 513         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 514             key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
 515 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 516         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 517             key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 518         mFixedThreadPool.execute(task);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 519       }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 520     }</span>
 521 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 522         ALog.d(TAG,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 523             String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(), key,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 524                 task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
 525 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 526         mFixedThreadPool.execute(task);
 527       }
 528     }
 529   }
 530 
 531   /**
 532    * 处理新任务
 533    *
 534    * @return {@code true}创建新任务失败
 535    */
 536   protected abstract boolean handleNewTask();
 537 
 538   /**
 539    * 处理不支持断点的任务
 540    */
 541   private void handleNoSupportBP() {
 542     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 543     config.FILE_SIZE = mEntity.getFileSize();
 544     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 545     config.TEMP_FILE = mTempFile;
 546     config.THREAD_ID = 0;
 547     config.START_LOCATION = 0;
 548     config.END_LOCATION = config.FILE_SIZE;
 549     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 550     config.TASK_ENTITY = mTaskEntity;
 551     AbsThreadTask task = selectThreadTask(config);
 552     if (task == null) return;
 553     mTask.put(0, task);
 554     mFixedThreadPool = Executors.newFixedThreadPool(1);
 555     mFixedThreadPool.execute(task);
 556     mListener.onStart(0);
 557   }
 558 
 559   /**
 560    * 选择单任务线程的类型
 561    */
 562   protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 563 }
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.content.Context;
  19 import com.arialyy.aria.core.AriaManager;
  20 import com.arialyy.aria.core.download.DownloadEntity;
  21 import com.arialyy.aria.core.inf.AbsNormalEntity;
  22 import com.arialyy.aria.core.inf.AbsTaskEntity;
  23 import com.arialyy.aria.core.inf.IDownloadListener;
  24 import com.arialyy.aria.core.inf.IEventListener;
  25 import com.arialyy.aria.orm.DbEntity;
  26 import com.arialyy.aria.util.ALog;
  27 import com.arialyy.aria.util.CommonUtil;
  28 import com.arialyy.aria.util.DbHelper;
  29 import java.io.File;
  30 import java.util.ArrayList;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.List;
  34 import java.util.Map;
  35 import java.util.Properties;
  36 import java.util.Set;
  37 import java.util.Timer;
  38 import java.util.TimerTask;
  39 import java.util.concurrent.ExecutorService;
  40 import java.util.concurrent.Executors;
  41 
  42 
  43 /**
  44  * Created by AriaL on 2017/7/1.
  45  * 任务处理器
  46  */
<abbr title="  47 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt; implements Runnable , IUtil {">  47 public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;🔵</abbr>
  48   private static final String STATE = &quot;_state_&quot;;
  49 
  50   private static final String RECORD = &quot;_record_&quot;;
  51 
  52   /**
  53    * 小于1m的文件不启用多线程
  54    */
  55   protected static final long SUB_LEN = 1024 * 1024;
  56 
  57   private final String TAG = &quot;AbsFileer&quot;;
  58 
  59   protected IEventListener mListener;
  60 
  61   protected TASK_ENTITY mTaskEntity;
  62 
  63   protected ENTITY mEntity;
  64 
  65   protected Context mContext;
  66 
  67   //文件
  68   protected File mTempFile; //文件
  69 
  70   protected StateConstance mConstance;
  71 
  72   private ExecutorService mFixedThreadPool;
  73 
  74   //总线程数
  75   //总线程数
  76   protected int mTotalThreadNum;
  77 
  78   //启动线程数
  79   //启动线程数
  80   private int mStartThreadNum;
  81 
  82   //已完成的线程数
  83   //已完成的线程数
  84   private int mCompleteThreadNum;
  85 
  86   private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();
  87 
  88   private Timer mTimer;
  89 
  90   @Deprecated
  91   private File mConfigFile;
  92 
  93   /**
  94    * 进度刷新间隔
  95    */
  96   private long mUpdateInterval = 1000;
  97 
  98   private TaskRecord mRecord;
  99 
 100   protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
 101     mListener = listener;
 102     mTaskEntity = taskEntity;
 103     mEntity = mTaskEntity.getEntity();
 104     mContext = AriaManager.APP;
 105     mConstance = new StateConstance();
 106   }
 107 
 108   public void setNewTask(boolean newTask) {
 109     mTaskEntity.setNewTask(newTask);
 110   }
 111 
 112   @Override public void setMaxSpeed(double maxSpeed) {
 113     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 114       AbsThreadTask task = mTask.get(i);
 115       if (task != null) {
 116         task.setMaxSpeed(maxSpeed);
 117       }
 118     }
 119   }
 120 
 121   @Override public void run() {
 122     if (mConstance.isRunning) {
 123       return;
 124     }
 125     startFlow();
 126   }
 127 
 128   /**
 129    * 开始流程
 130    */
 131   private void startFlow() {
 132     mConstance.resetState();
 133     checkTask();
 134     mConstance.TASK_RECORD = mRecord;
 135     if (mListener instanceof IDownloadListener) {
 136       ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 137     }
 138     if (!mTaskEntity.isSupportBP()) {
 139       mTotalThreadNum = 1;
 140       mStartThreadNum = 1;
 141       handleNoSupportBP();
 142     } else {
 143       mTotalThreadNum =
 144           mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 145       handleBreakpoint();
 146     }
 147     mConstance.START_THREAD_NUM = mTotalThreadNum;
 148     /*
 149      * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 150      * 动态长度条件：
 151      * 1、总线程数为1，并且是新任务
 152      * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 153      */
 154     if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 155         || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 156       mConstance.isOpenDynamicFile = true;
 157     }
 158     startTimer();
 159   }
 160 
 161   /**
 162    * 设置新任务的最大线程数
 163    */
 164   protected abstract int setNewTaskThreadNum();
 165 
 166   /**
 167    * 启动进度获取定时器
 168    */
 169   private void startTimer() {
 170     mTimer = new Timer(true);
 171     mTimer.schedule(new TimerTask() {
 172       @Override public void run() {
 173         if (mConstance.isComplete()
 174             || mConstance.isStop()
 175             || mConstance.isCancel()
 176             || !mConstance.isRunning) {
 177           closeTimer();
 178         } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 179           mListener.onProgress(mConstance.CURRENT_LOCATION);
 180         }
 181       }
 182     }, 0, mUpdateInterval);
 183   }
 184 
 185   protected void closeTimer() {
 186     if (mTimer != null) {
 187       mTimer.purge();
 188       mTimer.cancel();
 189       mTimer = null;
 190     }
 191   }
 192 
 193   /**
 194    * 设置定时器更新间隔
 195    *
 196    * @param interval 单位毫秒，不能小于0
 197    */
 198   protected void setUpdateInterval(long interval) {
 199     if (interval &lt; 0) {
 200       ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 201       return;
 202     }
 203     mUpdateInterval = interval;
 204   }
 205 
 206   @Override public long getFileSize() {
 207     return mEntity.getFileSize();
 208   }
 209 
 210   /**
 211    * 获取当前任务位置
 212    */
 213   @Override public long getCurrentLocation() {
 214     return mConstance.CURRENT_LOCATION;
 215   }
 216 
 217   @Override public boolean isRunning() {
 218     return mConstance.isRunning;
 219   }
 220 
 221   @Override public void cancel() {
 222     closeTimer();
 223     mConstance.isRunning = false;
 224     mConstance.isCancel = true;
 225     if (mFixedThreadPool != null) {
 226       mFixedThreadPool.shutdown();
 227     }
 228     for (int i = 0; i &lt; mStartThreadNum; i++) {
 229       AbsThreadTask task = mTask.get(i);
 230       if (task != null) {
 231         task.cancel();
 232       }
 233     }
 234   }
 235 
 236   @Override public void stop() {
 237     closeTimer();
 238     mConstance.isRunning = false;
 239     mConstance.isStop = true;
 240     if (mConstance.isComplete()) return;
 241     if (mFixedThreadPool != null) {
 242       mFixedThreadPool.shutdown();
 243     }
 244     for (int i = 0; i &lt; mStartThreadNum; i++) {
 245       AbsThreadTask task = mTask.get(i);
 246       if (task != null) {
 247         task.stop();
 248       }
 249     }
 250   }
 251 
 252   /**
 253    * 直接调用的时候会自动启动线程执行
 254    */
 255   @Override public void start() {
 256     new Thread(this).start();
 257   }
 258 
 259   @Override public void resume() {
 260     start();
 261   }
 262 
 263   /**
 264    * 检查任务、检查线程数
 265    * 新任务条件：
 266    * 1、文件不存在
 267    * 2、任务记录文件缺失或不匹配
 268    * 3、数据库记录不存在
 269    * 4、不支持断点，则是新任务
 270    */
 271   private void checkTask() {
 272     mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 273     if (mConfigFile.exists()) {
 274       convertDb();
 275     } else {
 276       mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 277       if (mRecord == null) {
 278         initRecord();
 279         mTaskEntity.setNewTask(true);
 280       } else {
 281         if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 282           initRecord();
 283           mTaskEntity.setNewTask(true);
 284         } else if (mTempFile.length() == 0) {
 285           mRecord.deleteData();
 286           initRecord();
 287           mTaskEntity.setNewTask(true);
 288         } else {
 289           for (ThreadRecord tr : mRecord.threadRecords) {
 290             if (tr.isComplete) {
 291               mCompleteThreadNum++;
 292             } else {
 293               mStartThreadNum++;
 294             }
 295           }
 296           mTotalThreadNum = mRecord.threadRecords.size();
 297           mTaskEntity.setNewTask(false);
 298         }
 299       }
 300     }
 301   }
 302 
 303   /**
 304    * convertDb 为兼容性代码
 305    * 从3.4.1开始，线程配置信息将存储在数据库中。
 306    * 将配置文件的内容复制到数据库中，并将配置文件删除
 307    */
 308   private void convertDb() {
 309     List&lt;RecordWrapper&gt; records =
 310         DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 311             mTaskEntity.getKey());
 312     if (records == null || records.size() == 0) {
 313       Properties pro = CommonUtil.loadConfig(mConfigFile);
 314       if (pro.isEmpty()) {
 315         mTaskEntity.setNewTask(true);
 316         return;
 317       }
 318       initRecord();
 319       Set&lt;Object&gt; keys = pro.keySet();
 320       // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 321       // 第一步应该是record 和 state去重取正确的线程数
 322       Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 323       for (Object key : keys) {
 324         String str = String.valueOf(key);
 325         int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 326         set.add(i);
 327       }
 328       int threadNum = set.size();
 329       if (threadNum == 0) {
 330         mTaskEntity.setNewTask(true);
 331         return;
 332       }
 333       mRecord.threadNum = threadNum;
 334       mTotalThreadNum = threadNum;
 335 
 336       for (int i = 0; i &lt; threadNum; i++) {
 337         ThreadRecord tRecord = new ThreadRecord();
 338         tRecord.key = mRecord.filePath;
 339         Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 340         Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
 341         if (state != null &amp;&amp; Integer.parseInt(String.valueOf(state)) == 1) {
 342           mCompleteThreadNum++;
 343           tRecord.isComplete = true;
 344           continue;
 345         }
 346         mStartThreadNum++;
 347         if (record != null) {
 348           Long temp = Long.parseLong(String.valueOf(record));
 349           tRecord.startLocation = temp &gt; 0 ? temp : 0;
 350         } else {
 351           tRecord.startLocation = 0;
 352         }
 353         mRecord.threadRecords.add(tRecord);
 354       }
 355       mConfigFile.delete();
 356     }
 357   }
 358 
 359   /**
 360    * 初始化记录
 361    */
 362   private void initRecord() {
 363     mRecord = new TaskRecord();
 364     mRecord.fileName = mEntity.getFileName();
 365     mRecord.filePath = mTaskEntity.getKey();
 366     mRecord.threadRecords = new ArrayList&lt;&gt;();
 367     mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 368     if (mRecord.isGroupRecord) {
 369       if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 370         mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 371       }
 372     }
 373   }
 374 
 375   /**
 376    * 保存任务记录
 377    */
 378   private void saveRecord() {
 379     mRecord.threadNum = mRecord.threadRecords.size();
 380     mRecord.save();
 381     for (ThreadRecord tr : mRecord.threadRecords) {
 382       tr.save();
 383     }
 384   }
 385 
 386   public TaskRecord getRecord() {
 387     return mRecord;
 388   }
 389 
 390   /**
 391    * 恢复记录地址
 392    *
 393    * @return {@code true}任务已完成
 394    */
 395   private boolean resumeRecordLocation(int i, long startL, long endL) {
 396     mConstance.CURRENT_LOCATION += endL - startL;
 397     ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));
 398     mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 399     mConstance.STOP_NUM++;
 400     mConstance.CANCEL_NUM++;
 401     if (mConstance.isComplete()) {
 402       mRecord.deleteData();
 403       mListener.onComplete();
 404       mConstance.isRunning = false;
 405       return true;
 406     }
 407     return false;
 408   }
 409 
 410   /**
 411    * 启动断点任务时，创建单线程任务
 412    *
 413    * @param i 线程id
 414    * @param startL 该任务起始位置
 415    * @param endL 该任务结束位置
 416    * @param fileLength 该任务需要处理的文件长度
 417    */
 418   private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 419       ThreadRecord record) {
 420     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 421     config.FILE_SIZE = fileLength;
 422     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 423     config.TEMP_FILE = mTempFile;
 424     config.THREAD_ID = i;
 425     config.START_LOCATION = startL;
 426     config.END_LOCATION = endL;
 427     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 428     config.TASK_ENTITY = mTaskEntity;
 429     config.THREAD_RECORD = record;
 430     return selectThreadTask(config);
 431   }
 432 
 433   private void handleBreakpoint() {
 434     long fileLength = mEntity.getFileSize();
 435     long blockSize = fileLength / mTotalThreadNum;
 436     int[] threadId = new int[mTotalThreadNum];
 437     int rl = 0;
 438     mRecord.fileLength = fileLength;
 439     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 440       threadId[i] = -1;
 441     }
 442     if (mTaskEntity.isNewTask() &amp;&amp; (!handleNewTask())) {
 443       return;
 444     }
 445     for (int i = 0; i &lt; mTotalThreadNum; i++) {
 446       long startL = i * blockSize;
 447       long endL = (i + 1) * blockSize;
 448       ThreadRecord tr;
 449       boolean isNewTr = false;// 是否是新的线程记录
 450 
 451       if (mTaskEntity.isNewTask()) {
 452         tr = new ThreadRecord();
 453         tr.key = mRecord.filePath;
 454         tr.threadId = i;
 455         isNewTr = true;
 456       } else {
 457         tr = mRecord.threadRecords.get(i);
 458       }
 459       if (tr.isComplete) {
 460         // 该线程已经完成
 461         if (resumeRecordLocation(i, startL, endL)) {
 462           return;
 463         }
 464         continue;
 465       }
 466       // 如果有记录，则恢复任务
 467       if (tr.startLocation &gt;= 0) {
 468         Long r = tr.startLocation;
 469         // 记录的位置需要在线程区间中
 470         if ((startL &lt; r) &amp;&amp; (r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL))) {
 471           mConstance.CURRENT_LOCATION += r - startL;
 472           startL = r;
 473         }
 474         ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));
 475       }
 476       // 最后一个线程的结束位置即为文件的总长度
 477       if (i == (mTotalThreadNum - 1)) {
 478         endL = fileLength;
 479       }
 480       // 更新记录
 481       tr.startLocation = startL;
 482       tr.endLocation = endL;
 483       if (isNewTr) {
 484         mRecord.threadRecords.add(tr);
 485       }
 486       AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 487       if (task == null) {
 488         return;
 489       }
 490       mTask.put(i, task);
 491       threadId[rl] = i;
 492       rl++;
 493     }
<abbr title=" 494     if ((mConstance.CURRENT_LOCATION != 0) &amp;&amp; (mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress())) {"> 494     if ((mConstance.CURRENT_LOCATION != 0) &amp;&amp; (mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress(🔵</abbr>
 495       ALog.d(TAG, &quot;进度修正&quot;);
 496       mEntity.setCurrentProgress(mConstance.CURRENT_LOCATION);
 497     }
 498     saveRecord();
 499     startThreadTask(threadId);
 500   }
 501 
 502   /**
 503    * 启动单线程任务
 504    */
 505   private void startThreadTask(int[] recordL) {
 506     if (mConstance.CURRENT_LOCATION &gt; 0) {
 507       mListener.onResume(mConstance.CURRENT_LOCATION);
 508     } else {
 509       mListener.onStart(mConstance.CURRENT_LOCATION);
 510     }
 511     mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 512     for (int l : recordL) {
 513       if (l == -1) continue;
 514       Runnable task = mTask.get(l);
 515       if (task != null) {
 516         mFixedThreadPool.execute(task);
 517       }
 518     }
 519   }
 520 
 521   /**
 522    * 重试线程任务，只有线程创建成功才能重试
 523    */
 524   public void retryThreadTask() {
 525     if ((mTask == null) || (mTask.size() == 0)) {
 526       ALog.w(TAG, &quot;没有线程任务&quot;);
 527       return;
 528     }
 529     Set&lt;Integer&gt; keys = mTask.keySet();
 530     for (Integer key : keys) {
 531       AbsThreadTask task = mTask.get(key);
 532       if ((task != null) &amp;&amp; (!task.isThreadComplete())) {
 533         task.getConfig().START_LOCATION = task.getCurrentLocation();
 534         mConstance.isStop = false;
 535         mConstance.isCancel = false;
 536         mConstance.isRunning = true;
<abbr title=" 537         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(), key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));"> 537         ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(), key, tas🔵</abbr>
 538         mFixedThreadPool.execute(task);
 539       }
 540     }
 541   }
 542 
 543   /**
 544    * 处理新任务
 545    *
 546    * @return {@code true}创建新任务失败
 547    */
 548   protected abstract boolean handleNewTask();
 549 
 550   /**
 551    * 处理不支持断点的任务
 552    */
 553   private void handleNoSupportBP() {
 554     SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 555     config.FILE_SIZE = mEntity.getFileSize();
 556     config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 557     config.TEMP_FILE = mTempFile;
 558     config.THREAD_ID = 0;
 559     config.START_LOCATION = 0;
 560     config.END_LOCATION = config.FILE_SIZE;
 561     config.SUPPORT_BP = mTaskEntity.isSupportBP();
 562     config.TASK_ENTITY = mTaskEntity;
 563     AbsThreadTask task = selectThreadTask(config);
 564     if (task == null) return;
 565     mTask.put(0, task);
 566     mFixedThreadPool = Executors.newFixedThreadPool(1);
 567     mFixedThreadPool.execute(task);
 568     mListener.onStart(0);
 569   }
 570 
 571   /**
 572    * 选择单任务线程的类型
 573    */
 574   protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 575 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.arialyy.aria.core.common;
  17  
  18  import android.content.Context;
  19  import com.arialyy.aria.core.AriaManager;
  20  import com.arialyy.aria.core.download.DownloadEntity;
  21  import com.arialyy.aria.core.inf.AbsNormalEntity;
  22  import com.arialyy.aria.core.inf.AbsTaskEntity;
  23  import com.arialyy.aria.core.inf.IDownloadListener;
  24  import com.arialyy.aria.core.inf.IEventListener;
  25  import com.arialyy.aria.orm.DbEntity;
  26  import com.arialyy.aria.util.ALog;
  27  import com.arialyy.aria.util.CommonUtil;
  28  import com.arialyy.aria.util.DbHelper;
  29  import java.io.File;
  30  import java.util.ArrayList;
  31  import java.util.HashMap;
  32  import java.util.HashSet;
  33  import java.util.List;
  34  import java.util.Map;
  35  import java.util.Properties;
  36  import java.util.Set;
  37  import java.util.Timer;
  38  import java.util.TimerTask;
  39  import java.util.concurrent.ExecutorService;
  40  import java.util.concurrent.Executors;
  41  
  42  /**
  43   * Created by AriaL on 2017/7/1.
  44   * 任务处理器
  45   */
  46  public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt;
  47      implements Runnable, IUtil {
  48    private static final String STATE = &quot;_state_&quot;;
  49    private static final String RECORD = &quot;_record_&quot;;
  50    /**
  51     * 小于1m的文件不启用多线程
  52     */
  53    protected static final long SUB_LEN = 1024 * 1024;
  54  
  55    private final String TAG = &quot;AbsFileer&quot;;
  56    protected IEventListener mListener;
  57    protected TASK_ENTITY mTaskEntity;
  58    protected ENTITY mEntity;
  59    protected Context mContext;
  60    protected File mTempFile; //文件
  61    protected StateConstance mConstance;
  62    private ExecutorService mFixedThreadPool;
  63    //总线程数
  64    protected int mTotalThreadNum;
  65    //启动线程数
  66    private int mStartThreadNum;
  67    //已完成的线程数
  68    private int mCompleteThreadNum;
  69    private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();
  70  
  71    private Timer mTimer;
  72    @Deprecated
  73    private File mConfigFile;

  74    /**
  75     * 进度刷新间隔
  76     */
  77    private long mUpdateInterval = 1000;
  78    private TaskRecord mRecord;
  79  
  80    protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
  81      mListener = listener;
  82      mTaskEntity = taskEntity;
  83      mEntity = mTaskEntity.getEntity();
  84      mContext = AriaManager.APP;
  85      mConstance = new StateConstance();
  86    }
  87  
  88    public void setNewTask(boolean newTask) {
  89      mTaskEntity.setNewTask(newTask);
  90    }
  91  
  92    @Override public void setMaxSpeed(double maxSpeed) {
  93      for (int i = 0; i &lt; mTotalThreadNum; i++) {
  94        AbsThreadTask task = mTask.get(i);
  95        if (task != null) {
  96          task.setMaxSpeed(maxSpeed);
  97        }
  98      }
  99    }
 100  
 101    @Override public void run() {
 102      if (mConstance.isRunning) {
 103        return;
 104      }
 105      startFlow();
 106    }
 107  
 108    /**
 109     * 开始流程
 110     */
 111    private void startFlow() {
 112      mConstance.resetState();
 113      checkTask();
 114      mConstance.TASK_RECORD = mRecord;
 115      if (mListener instanceof IDownloadListener) {
 116        ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 117      }
 118      if (!mTaskEntity.isSupportBP()) {
 119        mTotalThreadNum = 1;
 120        mStartThreadNum = 1;
 121        handleNoSupportBP();
 122      } else {
 123        mTotalThreadNum =
 124            mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 125        handleBreakpoint();
 126      }
 127      mConstance.START_THREAD_NUM = mTotalThreadNum;
 128      /*
 129       * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 130       * 动态长度条件：
 131       * 1、总线程数为1，并且是新任务
 132       * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 133       */
 134      if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 135          || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 136        mConstance.isOpenDynamicFile = true;
 137      }
 138      startTimer();
 139    }
 140  
 141    /**
 142     * 设置新任务的最大线程数
 143     */
 144    protected abstract int setNewTaskThreadNum();
 145  
 146    /**
 147     * 启动进度获取定时器
 148     */
 149    private void startTimer() {
 150      mTimer = new Timer(true);
 151      mTimer.schedule(new TimerTask() {
 152        @Override public void run() {
 153          if (mConstance.isComplete()
 154              || mConstance.isStop()
 155              || mConstance.isCancel()
 156              || !mConstance.isRunning) {
 157            closeTimer();
 158          } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 159            mListener.onProgress(mConstance.CURRENT_LOCATION);
 160          }
 161        }
 162      }, 0, mUpdateInterval);
 163    }
 164  
 165    protected void closeTimer() {
 166      if (mTimer != null) {
 167        mTimer.purge();
 168        mTimer.cancel();
 169        mTimer = null;
 170      }
 171    }
 172  
 173    /**
 174     * 设置定时器更新间隔
 175     *
 176     * @param interval 单位毫秒，不能小于0
 177     */
 178    protected void setUpdateInterval(long interval) {
 179      if (interval &lt; 0) {
 180        ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 181        return;
 182      }
 183      mUpdateInterval = interval;
 184    }
 185  
 186    @Override public long getFileSize() {
 187      return mEntity.getFileSize();
 188    }
 189  
 190    /**
 191     * 获取当前任务位置
 192     */
 193    @Override public long getCurrentLocation() {
 194      return mConstance.CURRENT_LOCATION;
 195    }
 196  
 197    @Override public boolean isRunning() {
 198      return mConstance.isRunning;
 199    }
 200  
 201    @Override public void cancel() {
 202      closeTimer();
 203      mConstance.isRunning = false;
 204      mConstance.isCancel = true;
 205      if (mFixedThreadPool != null) {
 206        mFixedThreadPool.shutdown();
 207      }
 208      for (int i = 0; i &lt; mStartThreadNum; i++) {
 209        AbsThreadTask task = mTask.get(i);
 210        if (task != null) {
 211          task.cancel();
 212        }
 213      }
 214    }
 215  
 216    @Override public void stop() {
 217      closeTimer();
 218      mConstance.isRunning = false;
 219      mConstance.isStop = true;
 220      if (mConstance.isComplete()) return;
 221      if (mFixedThreadPool != null) {
 222        mFixedThreadPool.shutdown();
 223      }
 224      for (int i = 0; i &lt; mStartThreadNum; i++) {
 225        AbsThreadTask task = mTask.get(i);
 226        if (task != null) {
 227          task.stop();
 228        }
 229      }
 230    }
 231  
 232    /**
 233     * 直接调用的时候会自动启动线程执行
 234     */
 235    @Override public void start() {
 236      new Thread(this).start();
 237    }
 238  
 239    @Override public void resume() {
 240      start();
 241    }
 242  
 243    /**
 244     * 检查任务、检查线程数
 245     * 新任务条件：
 246     * 1、文件不存在
 247     * 2、任务记录文件缺失或不匹配
 248     * 3、数据库记录不存在
 249     * 4、不支持断点，则是新任务
 250     */
 251    private void checkTask() {
 252      mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 253      if (mConfigFile.exists()) {
 254        convertDb();
 255      } else {
 256        mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 257        if (mRecord == null) {
 258          initRecord();
 259          mTaskEntity.setNewTask(true);
 260        } else {
 261          if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 262            initRecord();
 263            mTaskEntity.setNewTask(true);
 264          } else if (mTempFile.length() == 0) {
 265            mRecord.deleteData();
 266            initRecord();
 267            mTaskEntity.setNewTask(true);
 268          } else {
 269            for (ThreadRecord tr : mRecord.threadRecords) {
 270              if (tr.isComplete) {
 271                mCompleteThreadNum++;
 272              } else {
 273                mStartThreadNum++;
 274              }
 275            }
 276            mTotalThreadNum = mRecord.threadRecords.size();
 277            mTaskEntity.setNewTask(false);
 278          }
 279        }
 280      }
 281    }
 282  
 283    /**
 284     * convertDb 为兼容性代码
 285     * 从3.4.1开始，线程配置信息将存储在数据库中。
 286     * 将配置文件的内容复制到数据库中，并将配置文件删除
 287     */
 288    private void convertDb() {
 289      List&lt;RecordWrapper&gt; records =
 290          DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 291              mTaskEntity.getKey());
 292      if (records == null || records.size() == 0) {
 293        Properties pro = CommonUtil.loadConfig(mConfigFile);
 294        if (pro.isEmpty()) {
 295          mTaskEntity.setNewTask(true);
 296          return;
 297        }
 298        initRecord();
 299        Set&lt;Object&gt; keys = pro.keySet();
 300        // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 301        // 第一步应该是record 和 state去重取正确的线程数
 302        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 303        for (Object key : keys) {
 304          String str = String.valueOf(key);
 305          int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 306          set.add(i);
 307        }
 308        int threadNum = set.size();
 309        if (threadNum == 0) {
 310          mTaskEntity.setNewTask(true);
 311          return;
 312        }
 313        mRecord.threadNum = threadNum;
 314        mTotalThreadNum = threadNum;
 315  
 316        for (int i = 0; i &lt; threadNum; i++) {
 317          ThreadRecord tRecord = new ThreadRecord();
 318          tRecord.key = mRecord.filePath;
 319          Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 320          Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
 321          if (state != null &amp;&amp; Integer.parseInt(String.valueOf(state)) == 1) {
 322            mCompleteThreadNum++;
 323            tRecord.isComplete = true;
 324            continue;
 325          }
 326          mStartThreadNum++;
 327          if (record != null) {
 328            Long temp = Long.parseLong(String.valueOf(record));
 329            tRecord.startLocation = temp &gt; 0 ? temp : 0;
 330          } else {
 331            tRecord.startLocation = 0;
 332          }
 333          mRecord.threadRecords.add(tRecord);
 334        }
 335        mConfigFile.delete();
 336      }
 337    }
 338  
 339    /**
 340     * 初始化记录
 341     */
 342    private void initRecord() {
 343      mRecord = new TaskRecord();
 344      mRecord.fileName = mEntity.getFileName();
 345      mRecord.filePath = mTaskEntity.getKey();
 346      mRecord.threadRecords = new ArrayList&lt;&gt;();
 347      mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 348      if (mRecord.isGroupRecord) {
 349        if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 350          mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 351        }
 352      }
 353    }
 354  
 355    /**
 356     * 保存任务记录
 357     */
 358    private void saveRecord() {

 359      mRecord.save();
 360      for (ThreadRecord tr : mRecord.threadRecords) {
 361        tr.save();
 362      }
 363    }
 364  
 365    public TaskRecord getRecord() {
 366      return mRecord;
 367    }
 368  
 369    /**
 370     * 恢复记录地址
 371     *
 372     * @return {@code true}任务已完成
 373     */
 374    private boolean resumeRecordLocation(int i, long startL, long endL) {
 375      mConstance.CURRENT_LOCATION += endL - startL;
 376      ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));
 377      mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 378      mConstance.STOP_NUM++;
 379      mConstance.CANCEL_NUM++;
 380      if (mConstance.isComplete()) {
 381        mRecord.deleteData();
 382        mListener.onComplete();
 383        mConstance.isRunning = false;
 384        return true;
 385      }
 386      return false;
 387    }
 388  
 389    /**
 390     * 启动断点任务时，创建单线程任务
 391     *
 392     * @param i 线程id
 393     * @param startL 该任务起始位置
 394     * @param endL 该任务结束位置
 395     * @param fileLength 该任务需要处理的文件长度
 396     */
 397    private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 398        ThreadRecord record) {
 399      SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 400      config.FILE_SIZE = fileLength;
 401      config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 402      config.TEMP_FILE = mTempFile;
 403      config.THREAD_ID = i;
 404      config.START_LOCATION = startL;
 405      config.END_LOCATION = endL;
 406      config.SUPPORT_BP = mTaskEntity.isSupportBP();
 407      config.TASK_ENTITY = mTaskEntity;
 408      config.THREAD_RECORD = record;
 409      return selectThreadTask(config);
 410    }
 411  
 412    private void handleBreakpoint() {
 413      long fileLength = mEntity.getFileSize();
 414      long blockSize = fileLength / mTotalThreadNum;
 415      int[] threadId = new int[mTotalThreadNum];
 416      int rl = 0;
 417  
 418      mRecord.fileLength = fileLength;
 419      for (int i = 0; i &lt; mTotalThreadNum; i++) {
 420        threadId[i] = -1;
 421      }
 422      if (mTaskEntity.isNewTask() &amp;&amp; !handleNewTask()) {
 423        return;
 424      }
 425      for (int i = 0; i &lt; mTotalThreadNum; i++) {
 426        long startL = i * blockSize, endL = (i + 1) * blockSize;
 427        ThreadRecord tr;
 428        boolean isNewTr = false;  // 是否是新的线程记录
 429        if (mTaskEntity.isNewTask()) {
 430          tr = new ThreadRecord();
 431          tr.key = mRecord.filePath;
 432          tr.threadId = i;
 433          isNewTr = true;
 434        } else {
 435          tr = mRecord.threadRecords.get(i);
 436        }
 437        if (tr.isComplete) {//该线程已经完成
 438          if (resumeRecordLocation(i, startL, endL)) return;
 439          continue;
 440        }
 441  
 442        //如果有记录，则恢复任务
 443        if (tr.startLocation &gt;= 0) {
 444          Long r = tr.startLocation;
 445          //记录的位置需要在线程区间中
 446          if (startL &lt; r &amp;&amp; r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL)) {
 447            mConstance.CURRENT_LOCATION += r - startL;
 448            startL = r;
 449          }
 450          ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));
 451        }
 452        //最后一个线程的结束位置即为文件的总长度
 453        if (i == (mTotalThreadNum - 1)) {
 454          endL = fileLength;
 455        }
 456        // 更新记录
 457        tr.startLocation = startL;
 458        tr.endLocation = endL;
 459        if (isNewTr) {
 460          mRecord.threadRecords.add(tr);
 461        }
 462        AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 463        if (task == null) return;
 464        mTask.put(i, task);
 465        threadId[rl] = i;
 466        rl++;
 467      }





 468      saveRecord();
 469      startThreadTask(threadId);
 470    }
 471  
 472    /**
 473     * 启动单线程任务
 474     */
 475    private void startThreadTask(int[] recordL) {
 476      if (mConstance.CURRENT_LOCATION &gt; 0) {
 477        mListener.onResume(mConstance.CURRENT_LOCATION);
 478      } else {
 479        mListener.onStart(mConstance.CURRENT_LOCATION);
 480      }
 481      mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 482      for (int l : recordL) {
 483        if (l == -1) continue;
 484        Runnable task = mTask.get(l);
 485        if (task != null) {
 486          mFixedThreadPool.execute(task);
 487        }
 488      }
 489    }
 490  
 491    /**
 492     * 重试线程任务，只有线程创建成功才能重试
 493     */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 494 -  public void retryThradTask() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 495 +  public void retryThreadTask() {</span>
 496      if (mTask == null || mTask.size() == 0) {
 497        ALog.w(TAG, &quot;没有线程任务&quot;);
 498        return;
 499      }
 500      Set&lt;Integer&gt; keys = mTask.keySet();
 501      for (Integer key : keys) {
 502        AbsThreadTask task = mTask.get(key);
 503        if (task != null &amp;&amp; !task.isThreadComplete()) {
 504          task.getConfig().START_LOCATION = task.getCurrentLocation();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 505 +        mConstance.isStop = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 506 +        mConstance.isCancel = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 507 +        mConstance.isRunning = true;</span>
 508          ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),
 509              key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));



 510          mFixedThreadPool.execute(task);
 511        }
 512      }
 513    }
 514  
 515    /**
 516     * 处理新任务
 517     *
 518     * @return {@code true}创建新任务失败
 519     */
 520    protected abstract boolean handleNewTask();
 521  
 522    /**
 523     * 处理不支持断点的任务
 524     */
 525    private void handleNoSupportBP() {
 526      SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 527      config.FILE_SIZE = mEntity.getFileSize();
 528      config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 529      config.TEMP_FILE = mTempFile;
 530      config.THREAD_ID = 0;
 531      config.START_LOCATION = 0;
 532      config.END_LOCATION = config.FILE_SIZE;
 533      config.SUPPORT_BP = mTaskEntity.isSupportBP();
 534      config.TASK_ENTITY = mTaskEntity;
 535      AbsThreadTask task = selectThreadTask(config);
 536      if (task == null) return;
 537      mTask.put(0, task);
 538      mFixedThreadPool = Executors.newFixedThreadPool(1);
 539      mFixedThreadPool.execute(task);
 540      mListener.onStart(0);
 541    }
 542  
 543    /**
 544     * 选择单任务线程的类型
 545     */
 546    protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 547  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.arialyy.aria.core.common;
  17  
  18  import android.content.Context;
  19  import com.arialyy.aria.core.AriaManager;
  20  import com.arialyy.aria.core.download.DownloadEntity;
  21  import com.arialyy.aria.core.inf.AbsNormalEntity;
  22  import com.arialyy.aria.core.inf.AbsTaskEntity;
  23  import com.arialyy.aria.core.inf.IDownloadListener;
  24  import com.arialyy.aria.core.inf.IEventListener;
  25  import com.arialyy.aria.orm.DbEntity;
  26  import com.arialyy.aria.util.ALog;
  27  import com.arialyy.aria.util.CommonUtil;
  28  import com.arialyy.aria.util.DbHelper;
  29  import java.io.File;
  30  import java.util.ArrayList;
  31  import java.util.HashMap;
  32  import java.util.HashSet;
  33  import java.util.List;
  34  import java.util.Map;
  35  import java.util.Properties;
  36  import java.util.Set;
  37  import java.util.Timer;
  38  import java.util.TimerTask;
  39  import java.util.concurrent.ExecutorService;
  40  import java.util.concurrent.Executors;
  41  
  42  /**
  43   * Created by AriaL on 2017/7/1.
  44   * 任务处理器
  45   */
  46  public abstract class AbsFileer&lt;ENTITY extends AbsNormalEntity, TASK_ENTITY extends AbsTaskEntity&lt;ENTITY&gt;&gt;
  47      implements Runnable, IUtil {
  48    private static final String STATE = &quot;_state_&quot;;
  49    private static final String RECORD = &quot;_record_&quot;;
  50    /**
  51     * 小于1m的文件不启用多线程
  52     */
  53    protected static final long SUB_LEN = 1024 * 1024;
  54  
  55    private final String TAG = &quot;AbsFileer&quot;;
  56    protected IEventListener mListener;
  57    protected TASK_ENTITY mTaskEntity;
  58    protected ENTITY mEntity;
  59    protected Context mContext;
  60    protected File mTempFile; //文件
  61    protected StateConstance mConstance;
  62    private ExecutorService mFixedThreadPool;
  63    //总线程数
  64    protected int mTotalThreadNum;
  65    //启动线程数
  66    private int mStartThreadNum;
  67    //已完成的线程数
  68    private int mCompleteThreadNum;
  69    private Map&lt;Integer, AbsThreadTask&gt; mTask = new HashMap&lt;&gt;();
  70  
  71    private Timer mTimer;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  72 -  @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -  private File mConfigFile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +  @Deprecated private File mConfigFile;</span>
  75    /**
  76     * 进度刷新间隔
  77     */
  78    private long mUpdateInterval = 1000;
  79    private TaskRecord mRecord;
  80  
  81    protected AbsFileer(IEventListener listener, TASK_ENTITY taskEntity) {
  82      mListener = listener;
  83      mTaskEntity = taskEntity;
  84      mEntity = mTaskEntity.getEntity();
  85      mContext = AriaManager.APP;
  86      mConstance = new StateConstance();
  87    }
  88  
  89    public void setNewTask(boolean newTask) {
  90      mTaskEntity.setNewTask(newTask);
  91    }
  92  
  93    @Override public void setMaxSpeed(double maxSpeed) {
  94      for (int i = 0; i &lt; mTotalThreadNum; i++) {
  95        AbsThreadTask task = mTask.get(i);
  96        if (task != null) {
  97          task.setMaxSpeed(maxSpeed);
  98        }
  99      }
 100    }
 101  
 102    @Override public void run() {
 103      if (mConstance.isRunning) {
 104        return;
 105      }
 106      startFlow();
 107    }
 108  
 109    /**
 110     * 开始流程
 111     */
 112    private void startFlow() {
 113      mConstance.resetState();
 114      checkTask();
 115      mConstance.TASK_RECORD = mRecord;
 116      if (mListener instanceof IDownloadListener) {
 117        ((IDownloadListener) mListener).onPostPre(mEntity.getFileSize());
 118      }
 119      if (!mTaskEntity.isSupportBP()) {
 120        mTotalThreadNum = 1;
 121        mStartThreadNum = 1;
 122        handleNoSupportBP();
 123      } else {
 124        mTotalThreadNum =
 125            mTaskEntity.isNewTask() ? (mStartThreadNum = setNewTaskThreadNum()) : mTotalThreadNum;
 126        handleBreakpoint();
 127      }
 128      mConstance.START_THREAD_NUM = mTotalThreadNum;
 129      /*
 130       * mTaskEntity.getEntity().getFileSize() != mTempFile.length()为兼容以前老版本代码
 131       * 动态长度条件：
 132       * 1、总线程数为1，并且是新任务
 133       * 2、总线程数为1，不是新任务，但是长度不是文件全长度
 134       */
 135      if (mTotalThreadNum == 1 &amp;&amp; (mTaskEntity.isNewTask()
 136          || mTaskEntity.getEntity().getFileSize() != mTempFile.length())) {
 137        mConstance.isOpenDynamicFile = true;
 138      }
 139      startTimer();
 140    }
 141  
 142    /**
 143     * 设置新任务的最大线程数
 144     */
 145    protected abstract int setNewTaskThreadNum();
 146  
 147    /**
 148     * 启动进度获取定时器
 149     */
 150    private void startTimer() {
 151      mTimer = new Timer(true);
 152      mTimer.schedule(new TimerTask() {
 153        @Override public void run() {
 154          if (mConstance.isComplete()
 155              || mConstance.isStop()
 156              || mConstance.isCancel()
 157              || !mConstance.isRunning) {
 158            closeTimer();
 159          } else if (mConstance.CURRENT_LOCATION &gt;= 0) {
 160            mListener.onProgress(mConstance.CURRENT_LOCATION);
 161          }
 162        }
 163      }, 0, mUpdateInterval);
 164    }
 165  
 166    protected void closeTimer() {
 167      if (mTimer != null) {
 168        mTimer.purge();
 169        mTimer.cancel();
 170        mTimer = null;
 171      }
 172    }
 173  
 174    /**
 175     * 设置定时器更新间隔
 176     *
 177     * @param interval 单位毫秒，不能小于0
 178     */
 179    protected void setUpdateInterval(long interval) {
 180      if (interval &lt; 0) {
 181        ALog.w(TAG, &quot;更新间隔不能小于0，默认为1000毫秒&quot;);
 182        return;
 183      }
 184      mUpdateInterval = interval;
 185    }
 186  
 187    @Override public long getFileSize() {
 188      return mEntity.getFileSize();
 189    }
 190  
 191    /**
 192     * 获取当前任务位置
 193     */
 194    @Override public long getCurrentLocation() {
 195      return mConstance.CURRENT_LOCATION;
 196    }
 197  
 198    @Override public boolean isRunning() {
 199      return mConstance.isRunning;
 200    }
 201  
 202    @Override public void cancel() {
 203      closeTimer();
 204      mConstance.isRunning = false;
 205      mConstance.isCancel = true;
 206      if (mFixedThreadPool != null) {
 207        mFixedThreadPool.shutdown();
 208      }
 209      for (int i = 0; i &lt; mStartThreadNum; i++) {
 210        AbsThreadTask task = mTask.get(i);
 211        if (task != null) {
 212          task.cancel();
 213        }
 214      }
 215    }
 216  
 217    @Override public void stop() {
 218      closeTimer();
 219      mConstance.isRunning = false;
 220      mConstance.isStop = true;
 221      if (mConstance.isComplete()) return;
 222      if (mFixedThreadPool != null) {
 223        mFixedThreadPool.shutdown();
 224      }
 225      for (int i = 0; i &lt; mStartThreadNum; i++) {
 226        AbsThreadTask task = mTask.get(i);
 227        if (task != null) {
 228          task.stop();
 229        }
 230      }
 231    }
 232  
 233    /**
 234     * 直接调用的时候会自动启动线程执行
 235     */
 236    @Override public void start() {
 237      new Thread(this).start();
 238    }
 239  
 240    @Override public void resume() {
 241      start();
 242    }
 243  
 244    /**
 245     * 检查任务、检查线程数
 246     * 新任务条件：
 247     * 1、文件不存在
 248     * 2、任务记录文件缺失或不匹配
 249     * 3、数据库记录不存在
 250     * 4、不支持断点，则是新任务
 251     */
 252    private void checkTask() {
 253      mConfigFile = new File(CommonUtil.getFileConfigPath(false, mEntity.getFileName()));
 254      if (mConfigFile.exists()) {
 255        convertDb();
 256      } else {
 257        mRecord = DbHelper.getTaskRecord(mTaskEntity.getKey());
 258        if (mRecord == null) {
 259          initRecord();
 260          mTaskEntity.setNewTask(true);
 261        } else {
 262          if (mRecord.threadRecords == null || mRecord.threadRecords.isEmpty()) {
 263            initRecord();
 264            mTaskEntity.setNewTask(true);
 265          } else if (mTempFile.length() == 0) {
 266            mRecord.deleteData();
 267            initRecord();
 268            mTaskEntity.setNewTask(true);
 269          } else {
 270            for (ThreadRecord tr : mRecord.threadRecords) {
 271              if (tr.isComplete) {
 272                mCompleteThreadNum++;
 273              } else {
 274                mStartThreadNum++;
 275              }
 276            }
 277            mTotalThreadNum = mRecord.threadRecords.size();
 278            mTaskEntity.setNewTask(false);
 279          }
 280        }
 281      }
 282    }
 283  
 284    /**
 285     * convertDb 为兼容性代码
 286     * 从3.4.1开始，线程配置信息将存储在数据库中。
 287     * 将配置文件的内容复制到数据库中，并将配置文件删除
 288     */
 289    private void convertDb() {
 290      List&lt;RecordWrapper&gt; records =
 291          DbEntity.findRelationData(RecordWrapper.class, &quot;TaskRecord.filePath=?&quot;,
 292              mTaskEntity.getKey());
 293      if (records == null || records.size() == 0) {
 294        Properties pro = CommonUtil.loadConfig(mConfigFile);
 295        if (pro.isEmpty()) {
 296          mTaskEntity.setNewTask(true);
 297          return;
 298        }
 299        initRecord();
 300        Set&lt;Object&gt; keys = pro.keySet();
 301        // 老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...
 302        // 第一步应该是record 和 state去重取正确的线程数
 303        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
 304        for (Object key : keys) {
 305          String str = String.valueOf(key);
 306          int i = Integer.parseInt(str.substring(str.length() - 1, str.length()));
 307          set.add(i);
 308        }
 309        int threadNum = set.size();
 310        if (threadNum == 0) {
 311          mTaskEntity.setNewTask(true);
 312          return;
 313        }
 314        mRecord.threadNum = threadNum;
 315        mTotalThreadNum = threadNum;
 316  
 317        for (int i = 0; i &lt; threadNum; i++) {
 318          ThreadRecord tRecord = new ThreadRecord();
 319          tRecord.key = mRecord.filePath;
 320          Object state = pro.getProperty(mTempFile.getName() + STATE + i);
 321          Object record = pro.getProperty(mTempFile.getName() + RECORD + i);
 322          if (state != null &amp;&amp; Integer.parseInt(String.valueOf(state)) == 1) {
 323            mCompleteThreadNum++;
 324            tRecord.isComplete = true;
 325            continue;
 326          }
 327          mStartThreadNum++;
 328          if (record != null) {
 329            Long temp = Long.parseLong(String.valueOf(record));
 330            tRecord.startLocation = temp &gt; 0 ? temp : 0;
 331          } else {
 332            tRecord.startLocation = 0;
 333          }
 334          mRecord.threadRecords.add(tRecord);
 335        }
 336        mConfigFile.delete();
 337      }
 338    }
 339  
 340    /**
 341     * 初始化记录
 342     */
 343    private void initRecord() {
 344      mRecord = new TaskRecord();
 345      mRecord.fileName = mEntity.getFileName();
 346      mRecord.filePath = mTaskEntity.getKey();
 347      mRecord.threadRecords = new ArrayList&lt;&gt;();
 348      mRecord.isGroupRecord = mTaskEntity.getEntity().isGroupChild();
 349      if (mRecord.isGroupRecord) {
 350        if (mTaskEntity.getEntity() instanceof DownloadEntity) {
 351          mRecord.dGroupName = ((DownloadEntity) mTaskEntity.getEntity()).getGroupName();
 352        }
 353      }
 354    }
 355  
 356    /**
 357     * 保存任务记录
 358     */
 359    private void saveRecord() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +    mRecord.threadNum = mRecord.threadRecords.size();</span>
 361      mRecord.save();
 362      for (ThreadRecord tr : mRecord.threadRecords) {
 363        tr.save();
 364      }
 365    }
 366  
 367    public TaskRecord getRecord() {
 368      return mRecord;
 369    }
 370  
 371    /**
 372     * 恢复记录地址
 373     *
 374     * @return {@code true}任务已完成
 375     */
 376    private boolean resumeRecordLocation(int i, long startL, long endL) {
 377      mConstance.CURRENT_LOCATION += endL - startL;
 378      ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__已完成&quot;, mTaskEntity.getEntity().getFileName(), i));
 379      mConstance.COMPLETE_THREAD_NUM = mCompleteThreadNum;
 380      mConstance.STOP_NUM++;
 381      mConstance.CANCEL_NUM++;
 382      if (mConstance.isComplete()) {
 383        mRecord.deleteData();
 384        mListener.onComplete();
 385        mConstance.isRunning = false;
 386        return true;
 387      }
 388      return false;
 389    }
 390  
 391    /**
 392     * 启动断点任务时，创建单线程任务
 393     *
 394     * @param i 线程id
 395     * @param startL 该任务起始位置
 396     * @param endL 该任务结束位置
 397     * @param fileLength 该任务需要处理的文件长度
 398     */
 399    private AbsThreadTask createSingThreadTask(int i, long startL, long endL, long fileLength,
 400        ThreadRecord record) {
 401      SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 402      config.FILE_SIZE = fileLength;
 403      config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 404      config.TEMP_FILE = mTempFile;
 405      config.THREAD_ID = i;
 406      config.START_LOCATION = startL;
 407      config.END_LOCATION = endL;
 408      config.SUPPORT_BP = mTaskEntity.isSupportBP();
 409      config.TASK_ENTITY = mTaskEntity;
 410      config.THREAD_RECORD = record;
 411      return selectThreadTask(config);
 412    }
 413  
 414    private void handleBreakpoint() {
 415      long fileLength = mEntity.getFileSize();
 416      long blockSize = fileLength / mTotalThreadNum;
 417      int[] threadId = new int[mTotalThreadNum];
 418      int rl = 0;
 419  
 420      mRecord.fileLength = fileLength;
 421      for (int i = 0; i &lt; mTotalThreadNum; i++) {
 422        threadId[i] = -1;
 423      }
 424      if (mTaskEntity.isNewTask() &amp;&amp; !handleNewTask()) {
 425        return;
 426      }
 427      for (int i = 0; i &lt; mTotalThreadNum; i++) {
 428        long startL = i * blockSize, endL = (i + 1) * blockSize;
 429        ThreadRecord tr;
 430        boolean isNewTr = false;  // 是否是新的线程记录
 431        if (mTaskEntity.isNewTask()) {
 432          tr = new ThreadRecord();
 433          tr.key = mRecord.filePath;
 434          tr.threadId = i;
 435          isNewTr = true;
 436        } else {
 437          tr = mRecord.threadRecords.get(i);
 438        }
 439        if (tr.isComplete) {//该线程已经完成
 440          if (resumeRecordLocation(i, startL, endL)) return;
 441          continue;
 442        }
 443  
 444        //如果有记录，则恢复任务
 445        if (tr.startLocation &gt;= 0) {
 446          Long r = tr.startLocation;
 447          //记录的位置需要在线程区间中
 448          if (startL &lt; r &amp;&amp; r &lt; (i == (mTotalThreadNum - 1) ? fileLength : endL)) {
 449            mConstance.CURRENT_LOCATION += r - startL;
 450            startL = r;
 451          }
 452          ALog.d(TAG, String.format(&quot;任务【%s】线程__%s__恢复任务&quot;, mEntity.getFileName(), i));
 453        }
 454        //最后一个线程的结束位置即为文件的总长度
 455        if (i == (mTotalThreadNum - 1)) {
 456          endL = fileLength;
 457        }
 458        // 更新记录
 459        tr.startLocation = startL;
 460        tr.endLocation = endL;
 461        if (isNewTr) {
 462          mRecord.threadRecords.add(tr);
 463        }
 464        AbsThreadTask task = createSingThreadTask(i, startL, endL, fileLength, tr);
 465        if (task == null) return;
 466        mTask.put(i, task);
 467        threadId[rl] = i;
 468        rl++;
 469      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +    if (mConstance.CURRENT_LOCATION != 0</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +        &amp;&amp; mConstance.CURRENT_LOCATION != mEntity.getCurrentProgress()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +      ALog.d(TAG, &quot;进度修正&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 473 +      mEntity.setCurrentProgress(mConstance.CURRENT_LOCATION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 474 +    }</span>
 475      saveRecord();
 476      startThreadTask(threadId);
 477    }
 478  
 479    /**
 480     * 启动单线程任务
 481     */
 482    private void startThreadTask(int[] recordL) {
 483      if (mConstance.CURRENT_LOCATION &gt; 0) {
 484        mListener.onResume(mConstance.CURRENT_LOCATION);
 485      } else {
 486        mListener.onStart(mConstance.CURRENT_LOCATION);
 487      }
 488      mFixedThreadPool = Executors.newFixedThreadPool(recordL.length);
 489      for (int l : recordL) {
 490        if (l == -1) continue;
 491        Runnable task = mTask.get(l);
 492        if (task != null) {
 493          mFixedThreadPool.execute(task);
 494        }
 495      }
 496    }
 497  
 498    /**
 499     * 重试线程任务，只有线程创建成功才能重试
 500     */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -  public void retryThradTask() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 502 +  public void retryThreadTask() {</span>
 503      if (mTask == null || mTask.size() == 0) {
 504        ALog.w(TAG, &quot;没有线程任务&quot;);
 505        return;
 506      }
 507      Set&lt;Integer&gt; keys = mTask.keySet();
 508      for (Integer key : keys) {
 509        AbsThreadTask task = mTask.get(key);
 510        if (task != null &amp;&amp; !task.isThreadComplete()) {
 511          task.getConfig().START_LOCATION = task.getCurrentLocation();



<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 512 -        ALog.d(TAG, String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 513 -            key, task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 514 +        ALog.d(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 515 +            String.format(&quot;任务【%s】开始重试，线程__%s__【开始位置：%s，结束位置：%s】&quot;, mEntity.getFileName(), key,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 516 +                task.getConfig().START_LOCATION, task.getConfig().END_LOCATION));</span>
 517          mFixedThreadPool.execute(task);
 518        }
 519      }
 520    }
 521  
 522    /**
 523     * 处理新任务
 524     *
 525     * @return {@code true}创建新任务失败
 526     */
 527    protected abstract boolean handleNewTask();
 528  
 529    /**
 530     * 处理不支持断点的任务
 531     */
 532    private void handleNoSupportBP() {
 533      SubThreadConfig&lt;TASK_ENTITY&gt; config = new SubThreadConfig&lt;&gt;();
 534      config.FILE_SIZE = mEntity.getFileSize();
 535      config.URL = mEntity.isRedirect() ? mEntity.getRedirectUrl() : mEntity.getUrl();
 536      config.TEMP_FILE = mTempFile;
 537      config.THREAD_ID = 0;
 538      config.START_LOCATION = 0;
 539      config.END_LOCATION = config.FILE_SIZE;
 540      config.SUPPORT_BP = mTaskEntity.isSupportBP();
 541      config.TASK_ENTITY = mTaskEntity;
 542      AbsThreadTask task = selectThreadTask(config);
 543      if (task == null) return;
 544      mTask.put(0, task);
 545      mFixedThreadPool = Executors.newFixedThreadPool(1);
 546      mFixedThreadPool.execute(task);
 547      mListener.onStart(0);
 548    }
 549  
 550    /**
 551     * 选择单任务线程的类型
 552     */
 553    protected abstract AbsThreadTask selectThreadTask(SubThreadConfig&lt;TASK_ENTITY&gt; config);
 554  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            